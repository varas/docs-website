{
  "/docs/apm/new-relic-apm/maintenance/remove-applications-new-relic": [
    {
      "sections": [
        "Record and monitor deployments",
        "Options for tracking deployments",
        "Tip",
        "Record deployments with the REST API",
        "Record a deployment with POST",
        "Record a deployment with PowerShell",
        "View a list of deployments with GET",
        "Sample output from GET",
        "Delete a deployment with DELETE",
        "Character limits and JSON parameters",
        "Important",
        "Record deployments using the New Relic agent",
        "Notify your team of deployments",
        "End of life notification: Hipchat, Campfire"
      ],
      "title": "Record and monitor deployments",
      "type": "docs",
      "tags": [
        "APM",
        "New Relic APM",
        "Maintenance"
      ],
      "external_id": "00b24338386fd261daea0733fe03c01639cce083",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/maintenance/record-monitor-deployments/",
      "published_at": "2021-07-02T08:38:45Z",
      "updated_at": "2021-04-22T09:32:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Deploying an app can be a risky eventâ€”when your app breaks, a bad deployment is often the cause. New Relic allows you to track deployments so you can correlate deploy to your app's performance. Tracking deployments creates deployment markers that appear in APM charts. Options for tracking deployments You can use the New Relic REST API v2 to record new deployments, retrieve a list of past deployments, and delete past deployments on your APM application. In addition, some APM agents have agent-specific methods to record deployments automatically. You can use your Slack integration with New Relic, or a simple webhook, to notify your team in real time of deployments for applications monitored by APM. Slack provides a webhook URL that allows you to post generic JSON that will appear formatted in a chosen Slack channel. There are a few places where you can view deployments in the New Relic UI after they have been recorded. You can view deployments in the UI: In the activity feed of the APM Summary, New Relic One Service summary, and entity summary pages. On APM performance charts as a chart marker. On the Deployments page for summary performance. Tip Deployment markers are not available for Browser applications, but see Browser releases for a way to tag errors with release versions. Record deployments with the REST API You can use the New Relic REST API v2 to record deployments, get a list of past deployments, and delete deployments. The examples in this document use curl as a command line tool. However, you can use any method to make your REST requests. You can also create, view, and delete deployments with the API Explorer. JSON uses double quotes \" for element names and content. Using single quotes ' will cause errors. Record a deployment with POST To record a new deployment, send a POST request that includes your API key to the deployments endpoint. Attach the payload in JSON format (see Character limits and JSON parameters). All payload parameters are optional except revision. For example: curl -X POST \"https://api.newrelic.com/v2/applications/$APP_ID/deployments.json\" \\ -H \"Api-Key:$API_KEY\" \\ -i \\ -H \"Content-Type: application/json\" \\ -d \\ '{ \"deployment\": { \"revision\": \"REVISION\", \"changelog\": \"Added: /v2/deployments.rb, Removed: None\", \"description\": \"Added a deployments resource to the v2 API\", \"user\": \"datanerd@example.com\", \"timestamp\": \"2019-10-08T00:15:36Z\" } }' Copy Record a deployment with PowerShell To record a deployment with PowerShell, send a POST request that includes your API key to the deployments endpoint. Attach the payload in JSON format (see Character limits and JSON parameters). All payload parameters are optional except revision. This example uses PowerShell version 3 or higher: Invoke-WebRequest -Uri https://api.newrelic.com/v2/applications/YOUR_APP_ID/deployments.json -Method POST -Headers @{'Api-Key'='$API_KEY'} -ContentType 'application/json' -Body '{ \"deployment\": { \"revision\": \"REVISION\", \"changelog\": \"Added: /v2/deployments.rb, Removed: None\", \"description\": \"Added a deployments resource to the v2 API\", \"user\": \"datanerd@example.com\", \"timestamp\": \"2019-10-08T00:15:36Z\" } }' Copy This example uses PowerShell version 2 (requires .NET framework 3.5 or higher): $encoding = [System.Text.Encoding]::GetEncoding(\"ASCII\") $data ='{ \"deployment\": { \"revision\": \"REVISION\", \"changelog\": \"Added: /v2/deployments.rb, Removed: None\", \"description\": \"Added a deployments resource to the v2 API\", \"user\": \"datanerd@example.com\", \"timestamp\": \"2019-10-08T00:15:36Z\" } }' $postData = $encoding.GetBytes($data) $request = [System.Net.WebRequest]::Create('https://api.newrelic.com/v2/applications/$APP_ID/deployments.json') $request.Method = 'POST' $request.Headers.add('Api-Key','$API_KEY') $request.ContentType='application/json' $stream = $request.GetRequestStream() $stream.Write($postData,0,$postData.Length) $request.GetResponse() Copy View a list of deployments with GET To retrieve a list of all past deployments for your app, send a GET request that includes your API key to the deployments endpoint. GET requests do not use a JSON payload. For example: curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/deployments.json\" \\ -H \"Api-Key:$API_KEY\" \\ -i Copy Sample output from GET This example requests a list of deployments for app ID 9999999: curl -X GET \"https://api.newrelic.com/v2/applications/9999999/deployments.json\" \\ -H \"Api-Key:ABCDEFGHIJKLMNOPQRSTUVWXabcdefghijklmnopqrstuvwx\" \\ -i Copy The API returns this list of deployments: HTTP/1.1 200 OK ETag: \"ABCDEFGHIJKabcdefghijk0123456789\" Cache-Control: max-age=0, private, must-revalidate Content-Type: application/json { \"deployments\": [ { \"id\": 1234567, \"revision\": \"1234123412341234123412341234123412341234\", \"changelog\": \"Fixed the bugs for real this time\", \"description\": \"Example description two\", \"user\": \"Data Nerd\", \"timestamp\": \"2016-02-24T10:09:27-08:00\", \"links\": { \"application\": 9999999 } }, { \"id\": 2345678, \"revision\": \"7890789078907890789078907890789078907890\", \"changelog\": \"Think I fixed all the bugs\", \"description\": null, \"user\": \"Dren Atad\", \"timestamp\": \"2014-10-22T12:23:47-07:00\", \"links\": { \"application\": 9999999 } } ], \"links\": { \"deployment.agent\": \"/v2/applications/{application_id}\" } } Copy Delete a deployment with DELETE To delete a deployment, send a DELETE request that includes your API key to the deployments endpoint. DELETE requests do not use a JSON payload, but you must specify the ID for the deployment you want to delete. To retrieve the ID for a deployment, use the GET request. For example: curl -X DELETE \"https://api.newrelic.com/v2/applications/$APP_ID/deployments/$DEPLOYMENT_ID.json\" \\ -H \"Api-Key:$API_KEY\" \\ -i Copy Character limits and JSON parameters The JSON payload can include the following parameters. Important UTF-8 4 byte characters, such as Emojis and some non-Latin language glyphs, cannot be used in the deployment text. Parameter Data type Description revision String, 127 character maximum Required. A unique ID for this deployment, visible in the Summary page and on the Deployments page. Can be any string, but is usually a version number or a Git checksum. changelog String, 65535 character maximum Optional. A summary of what changed in this deployment, visible in the Deployments page when you select (selected deployment) > Change log. description String, 65535 character maximum Optional. A high-level description of this deployment, visible in the Summary page and on the Deployments page when you select an individual deployment. user String, 31 character maximum Optional. A username to associate with the deployment, visible in the Summary page and on the Deployments page. timestamp ISO 8601 Optional. When the deployment occurred, down to the second. If not specified, the deployment will be recorded at the time when the API call was received. Timestamp requirements: Must be in UTC time. Must be after the most recent deployment timestamp. Cannot be in the future. Must be in ISO8601 format; for example, \"2019-10-08T00:15:36Z\". Record deployments using the New Relic agent Some agents have additional methods to record deployments: All agents: Use the New Relic REST API v2. C: No SDK-specific methods. Use the REST API. Go: No agent-specific methods. Use the REST API. Java: Call the Java agent jar. .NET: Use PowerShell and the REST API. Node.js: No agent-specific methods. Use the REST API. PHP: Use a PHP script. Python: Use the record-deploy subcommand of the newrelic-admin script. Ruby: Use a Capistrano recipe. Notify your team of deployments After a deployment is recorded using the REST API, you can optionally notify a webhook endpoint of the deployment. The destination of the webhook can be your Slack instance. To use webhooks to set up a deployment notification for a Slack channel: Log in to your Slack account as an admin, then go to App directory > Manage > Apps. Search for your New Relic app, then select Add configuration. From Post to channel, select an existing Slack channel or add a new channel, then Add configuration. From the list of options, copy the webhook URL. Go to one.newrelic.com > (account dropdown) > Account settings > Integrations > Deploy notifications > Webhook. Paste the Slack webhook URL, then save. Optional: Send a test message. Tip You can also use webhooks, Slack channels, and other options for alert notifications with New Relic Alerts. End of life notification: Hipchat, Campfire As of September 9, 2019, integrations with Hipchat and Campfire for APM deployment notifications will no longer be available. Recommendation: If you are still using Hipchat or Campfire, use webhooks with Slack channels instead. For more information, see the New Relic Explorers Hub post.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.06688,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Record deployments using the <em>New</em> <em>Relic</em> agent",
        "tags": "<em>New</em> <em>Relic</em> <em>APM</em>",
        "body": "Deploying an app can be a risky eventâ€”when your app breaks, a bad deployment is often the cause. <em>New</em> <em>Relic</em> allows you to track deployments so you can correlate deploy to your app&#x27;s performance. Tracking deployments creates deployment markers that appear in <em>APM</em> charts. Options for tracking"
      },
      "id": "603eb1c364441fd58b4e888b"
    },
    {
      "sections": [
        "Disable the APM agent",
        "C SDK",
        "Go",
        "Tip",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby"
      ],
      "title": "Disable the APM agent",
      "type": "docs",
      "tags": [
        "APM",
        "New Relic APM",
        "Maintenance"
      ],
      "external_id": "86abf4b21d23156a566b9cf171c8eb8a36385518",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/maintenance/disable-apm-agent/",
      "published_at": "2021-07-02T08:37:16Z",
      "updated_at": "2021-03-16T07:13:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You may want to temporarily disable an APM agent for the purposes of testing or troubleshooting. This document explains procedures for temporarily turning off the APM agent. Related procedures: To permanently disable APM, uninstall the agent. To configure an agent to monitor some things but not others, use custom instrumentation. Disable the APM agent Select your agent type for instructions: C SDK The C SDK cannot be turned on or off directly. However, you can write your code for the SDK so that a quick recompile and deploy can enable or disable your instrumentation. Follow standard procedures to disable or uninstall the C SDK. Go There are two main ways to disable the Go agent: Remove the import of the github.com/newrelic/go-agent package from your application, and remove or comment out any calls to the newrelic namespace. Then, recompile and restart your app. Use the enabled configuration setting. Then, recompile and restart your app. (This will not reduce overhead because the instrumentation is still running; it will only prevent the sending of data to the New Relic collector.) Tip After you disable the agent, it may take several minutes for data to stop showing up. Java There are three main ways to disable the Java agent: Set agent_enabled to false, then restart the JVM. Use the JVM command line flag: -Dnewrelic.config.agent_enabled=false Copy Then restart the JVM. Remove the newrelic.jar or newrelic.yml file, then restart the JVM. Tip After you disable the agent, it may take several minutes for data to stop showing up. .NET The method to disable the agent depends on if you are using Framework or Core: .NET Framework: Set agentEnabled to false in the global newrelic.config file, found in C:\\ProgramData\\New Relic\\.NET Agent\\. If the application is IIS-hosted, restart IIS. If it's self-hosted (non-IIS), restart the application. .NET Core: Set agentEnabled to false in the newrelic.config file found in the Core agentâ€™s installation directory (for Windows alongside NewRelic.Profiler.dll and for Linux alongside NewRelic.Profiler.so). If you use the ASP.NET Core Module, reset IIS. Otherwise, restart your Core application. Tip After you disable the agent, it may take several minutes for data to stop showing up. Node.js There are two main ways to disable the Node.js agent: Set agent_enabled to false in your agent config file, then restart the app server. Set the NEW_RELIC_ENABLED environment variable to false. Tip After you disable the agent, it may take several minutes for data to stop showing up. PHP To disable the PHP agent, set the enabled config setting to false, then restart the web server or PHP. Tip After you disable the agent, it may take several minutes for data to stop showing up. Python There are three main ways to disable the Python agent, depending on your preference and setup: Standard install: Use the monitor_mode configuration setting. This can be done by editing the config file or by using an environment variable. Standard install with newrelic-admin script: Remove reference to that script in your application. Manual instrumentation: Remove the initialization script from your application. Tip After you disable the agent, it may take several minutes for data to stop showing up. Ruby There are several ways to disable the Ruby agent, depending on your preference and setup. These methods will remove most instrumentation but there will still be a small amount of activity and overhead: Use the agent_enabled configuration setting. This can be done in the configuration file or in the per-environment stanzas. Restart your app server afterward. Do the same via an environment variable, then restart the app server. The following methods will remove all instrumentation and overhead: Remove newrelic_rpm from the Gemfile and bundle install. Set the following in the Gemfile and bundle install: gem 'newrelic_rpm', :require => false Copy This option ensures the gem is installed if it's required somewhere in the app, but doesn't install it when bundling. Tip After you disable the agent, it may take several minutes for data to stop showing up.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 129.02982,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Disable the <em>APM</em> agent",
        "sections": "Disable the <em>APM</em> agent",
        "tags": "<em>New</em> <em>Relic</em> <em>APM</em>",
        "body": " configuration setting. Then, recompile and restart your app. (This will not reduce overhead because the instrumentation is still running; it will only prevent the sending of data to the <em>New</em> <em>Relic</em> collector.) Tip After you disable the agent, it may take several minutes for data to stop showing up. Java"
      },
      "id": "603e83ac196a67266ea83dda"
    },
    {
      "sections": [
        "View your Apdex score",
        "Tip",
        "View Apdex score in APM",
        "View transactions with highest Apdex dissatisfaction",
        "View Apdex score in Browser",
        "Visualize Apdex data in query builder"
      ],
      "title": "View your Apdex score",
      "type": "docs",
      "tags": [
        "APM",
        "New Relic APM",
        "Apdex"
      ],
      "external_id": "b34782101a020897a16b6201cc9552afc298f2d9",
      "image": "https://docs.newrelic.com/static/812f8a389bc5e177470348dbe79dc536/01bf6/apdex_question_mark.png",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/apdex/view-your-apdex-score/",
      "published_at": "2021-07-02T08:43:04Z",
      "updated_at": "2021-03-30T09:22:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your Apdex score measures users' satisfaction with the response time of your web applications and services. The dissatisfaction score is the difference between a perfect Apdex score (1.0) and your app's apdex_t (\"tolerating\") score based on your Apdex settings. To help identify and troubleshoot Apdex level changes that indicate poor customer experiences with your site, use any of these resources: New Relic's user interface (explained in this document) New Relic REST API Alert notifications Tip Apdex applies only to web apps or services. The Apdex chart in the UI appears blank for non-web transactions. To get a high-level overview of all your applications and services, use the New Relic Explorer. View Apdex score in APM Apdex dissatisfaction levels of Tolerating (apdex_t) and Frustrated (apdex_f) indicate how slow site performance contributes to poor customer experiences in your app. For example: 1.0: All responses are satisfactory. Tolerating responses half satisfy a user. For example, if all responses are Tolerating, then the Apdex score will be 0.50. 0.0: None of the responses are satisfactory. To view the Apdex score for your web apps or services: Go to one.newrelic.com > (select an app) > Summary. From the APM Summary page, review the Apdex score chart. If you want to... Do this... View your Apdex T value Mouse over the Apdex icon. View summary information for any point in time on the chart Mouse over the Apdex score chart. View detailed information about any point in time on the chart Click or drag anywhere on the Apdex score chart. View the corresponding Apdex score for browsers Select the Apdex chart's End user link. Go directly to detailed Apdex information Go to one.newrelic.com > (select an app) > Transactions > See transactions table, and then sort by Apdex. View transactions with highest Apdex dissatisfaction Transactions at the top of APM's Transactions page often are good candidates for performance tuning or fixing errors. To view transactions with the highest Apdex dissatisfaction percentage: Go to one.newrelic.com > APM > (select an app) > Transactions > See transactions table. Sort Apdex to find the most dissatisfying. Specific web transaction: To view details about a specific transaction, select its row. By definition, the All transactions row always contributes 100% of the app's total dissatisfaction, even if no responses are dissatisfying (100% of zero is zero). In this situation, 100% does not mean that all of your transactions are dissatisfying. The sum of all the other values in this column is 100%. To focus on Apdex levels for specific transactions, you can also: Configure transaction traces to capture apdex_f, which is four times your app server's apdex_t. Create key transactions to track changes in Apdex values for specific transactions that are important to your business, such as signups, purchase confirmations, searches, site logins, etc. View Apdex score in Browser Use Browser to: Set Apdex levels for browser monitoring. Review Apdex levels from the perspective of real-user browser performance of your app. Track browser performance levels for selected countries you want to monitor. Visualize Apdex data in query builder Use query builder to: Create dashboards to analyze and share your Apdex data. Analyze your Apdex data with NRQL queries.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 83.449036,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View Apdex score in <em>APM</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>APM</em>",
        "body": " transactions. To get a high-level overview of all your applications and services, use the <em>New</em> <em>Relic</em> Explorer. View Apdex score in <em>APM</em> Apdex dissatisfaction levels of Tolerating (apdex_t) and Frustrated (apdex_f) indicate how slow site performance contributes to poor customer experiences in your app"
      },
      "id": "603ebe19e7b9d22a5f2f91d0"
    }
  ],
  "/docs/apm/new-relic-apm/troubleshooting/charts-missing-or-do-not-render": [
    {
      "sections": [
        "Remove applications from New Relic",
        "Before attempting to remove an app",
        "Remove an application from New Relic",
        "APM applications",
        "Browser",
        "Tip",
        "Mobile",
        "Troubleshooting",
        "You are not an admin on your full user account",
        "You have not waited long enough",
        "Not all agents are disabled",
        "You have problems removing your PHP app",
        "You don't know where the app's data is coming from",
        "Browser data is still reporting",
        "For more help"
      ],
      "title": "Remove applications from New Relic",
      "type": "docs",
      "tags": [
        "APM",
        "New Relic APM",
        "Maintenance"
      ],
      "external_id": "f457af939892708a477895093f97b65d08ff015a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/maintenance/remove-applications-new-relic/",
      "published_at": "2021-07-02T09:20:58Z",
      "updated_at": "2021-05-21T18:31:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Applications are automatically removed from New Relic after 93 days without sending data to our platform. You can also remove an application using the UI, once it has stopped sending data. Key metrics will continue to be available via the New Relic REST API, with the application name remaining reserved. For more information, see Inactive apps in New Relic One and our data retention guidelines. Before attempting to remove an app Before attempting to remove an APM, browser, or mobile app from the New Relic UI, keep in mind: You can downgrade your account to pay less or make it entirely free. To remove an app, you must have a user role with that capability. If an agent is still sending data from an app, you cannot remove an app. Remove an application from New Relic Before removing an APM, browser, or mobile application from New Relic, stop the application from sending data either by disabling the agent or by uninstalling it completely. APM applications Disable the APM agent: C SDK: Do a quick recompile and deploy. For example, surround your instrumentation in #ifdef, and set the value of YOURNAMESPACE_NEWRELIC_ENABLED with your build system. Go: Set Enabled to false. Java: Set agent_enabled to false. .NET: Set Newrelic.AgentEnabled to false. Node.js: Set agent_enabled to false. PHP: Remove or disable both the newrelic.so and newrelic-daemon components. Set newrelic.enabled to false. Python: Set monitor_mode to false. Ruby: Set agent_enabled to false. Restart the application server and wait up to ten minutes. Verify the color-coded health status for the app has turned to gray and is no longer reporting data. To remove the APM application and any browser applications linked to it, you have two options: Click the Delete application button on the APM application/service's Settings page. Go to one.newrelic.com > APM > (select an app/service) > Settings > Application. Or, call the /applications/delete endpoint of the New Relic REST API. For example: curl -X DELETE 'https://api.newrelic.com/v2/applications/YOUR_APP_ID.json' \\ -H 'X-Api-Key:YOUR_API_KEY' -i Copy Browser If you've used the copy/paste method to install the browser agent, remove the JavaScript snippet from your application's pages. After 93 days, the application will be removed from New Relic. Tip If browser data continues to be reported, see our suggestions below. Once your browser application has stopped reporting, you have two ways to remove it: If your browser application is linked to an APM application, deleting the APM application also removes the browser application. See the instructions for deleting an APM application/service above for details. Or, click the Delete application button on the browser application's Application settings page. Go to one.newrelic.com > Browser > (select an app) > Settings > Application settings . Mobile Remove all references/dependencies to the New Relic's mobile SDK/frameworks, then rebuild the application. For more information, see the iOS and Android install docs. After 93 days, the application will be removed from New Relic. Or, once your mobile application has stopped reporting, you can also remove it manually: Click the Delete application button on the mobile application's Settings page. Go to one.newrelic.com > Mobile > (select an app) > Settings > Application . Troubleshooting If you have problems removing an app, here are some possible causes and suggested solutions: You are not an admin on your full user account If you don't have proper permissions, you won't be able to remove an application. You have not waited long enough All app data must stop reporting to New Relic before you can remove that entity from New Relic. In most cases, this takes between 10-15 minutes. In rare cases, it can take a few minutes longer. Not all agents are disabled If you have multiple agents reporting data under the same UI name, then you must make sure you disable or uninstall all of the agents associated with that entity. You have problems removing your PHP app If you have a PHP app and aren't able to remove it from the UI, possible causes include: You have not disabled both components of the PHP agent. You must stop or uninstall both newrelic.so and newrelic-daemon in order to be able to remove a PHP app. For more information, see New Relic daemon processes. You have set up per-directory monitoring of your PHP app, and unexpected PHP data is reporting as the default PHP application in the New Relic UI. To fix this, change the default app name in the PHP agent config. You don't know where the app's data is coming from If you don't know where an app's data is coming from, it may be because the app's name has been changed. When an app name is changed in the UI, it does not change the underlying app name being reported; it only changes how the app name appears in the UI. To see if there is a difference between the reported name and the displayed name: From one.newrelic.com, select APM, then select an application. Scroll down to Settings and select Application. Compare the name in the Application alias field to the name in the Your application still reports as message directly beneath it. To get host information about an app you are not familiar with: From one.newrelic.com, select APM, then select an application. From the summary view, review the Servers list. Once you have identified where app data is coming from, you can remove the app from New Relic. Browser data is still reporting To remove an app from New Relic, all data must have stopped reporting, including browser monitoring data. To verify that you have disabled or uninstalled the APM agent associated with the app: Ensure that browser monitoring is disabled. If your browser monitoring script is inserted by the APM agent, turn it off from inside the UI, in the agent's config file, or in both. If you copied and pasted the monitoring JavaScript snippet in certain pages, remove that JavaScript snippet manually. Ensure all caches have been cleared that the application uses, such as host caches, CDNs, or anything else that caches built pages. Optional: To see a count of how many page views report from each domain, use this NRQL query: SELECT count(*) FROM PageView WHERE appName = 'YOUR_BROWSER_APP_NAME' FACET domain Copy If these steps don't resolve the issue, it is likely due to an end-user's browser cache that hasn't yet cleared. Wait until those caches clear. If your app has internal users, you may be able to identify the users and clear those caches. For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.14737,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Remove applications from <em>New</em> <em>Relic</em>",
        "sections": "Remove applications from <em>New</em> <em>Relic</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>APM</em>",
        "body": " reserved. For more information, see Inactive apps in <em>New</em> <em>Relic</em> One and our data retention guidelines. Before attempting to remove an app Before attempting to remove an <em>APM</em>, browser, or mobile app from the <em>New</em> <em>Relic</em> UI, keep in mind: You can downgrade your account to pay less or make it entirely free"
      },
      "id": "603ebbef28ccbc48d1eba78d"
    },
    {
      "sections": [
        "Event limits and sampling for APM and mobile monitoring",
        "Difference between events and metrics",
        "Why sampling of events is necessary",
        "The impact of sampling",
        "Important",
        "Change how sampling occurs",
        "APM: Compensate for sampling"
      ],
      "title": "Event limits and sampling for APM and mobile monitoring",
      "type": "docs",
      "tags": [
        "APM",
        "New Relic APM",
        "Troubleshooting"
      ],
      "external_id": "27b04d675cbdea50185303ed1c6c9290990488d6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/data/understand-data/new-relic-event-limits-sampling/",
      "published_at": "2021-07-02T11:33:39Z",
      "updated_at": "2021-03-16T15:50:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our APM agents and mobile agents have limits on the number of events that can be reported. This document explains: Why event-reporting limits are necessary How sampling works How to work with and understand sampled data Difference between events and metrics This document is about limits on event data and how those limits lead to sampling. First, it may help you to understand the differences between these two types of data: Metrics: aggregated measurements over time. Examples: average response time over a one-minute time range, throughput over time, CPU utilization over time. Events: discrete events that happen at a specific moment in time. Examples: a log or error being reported, or a configuration change. Some events are aggregated over time to form metrics (for example: a count of errors over time). These two types of data have different uses: metrics are useful for recognizing patterns over time in your system, and events are useful for drilling down and getting detail about the causes of those patterns. Because metrics are aggregated over time, theyâ€™re useful for spotting trends and changes in system behavior. For metrics that represent an aggregated count of events (like an HTTP response time metric), the individual events give you granular detail about what happened, and let you facet by attributes that have high cardinality (like account or user ID). Why sampling of events is necessary Our APM agents and mobile agents have limits on how many events can be reported per harvest cycle. This is necessary because if there were no limit, a very large number of events being sent could have performance impacts on your application or on New Relic. When the limit is reached, the agents begin sampling events. Different agents have different limits, but the goal is to give a representative sample from across the harvest cycle. Also, agents may sample if they can't connect to New Relic. When an agent canâ€™t connect to New Relic, it continues to store data locally. But it must restrict the size of the payload that is eventually sent. For this reason, it samples events during the disconnected period. The longer it is disconnected, the more it will sample. The impact of sampling One result of sampling is that there can be a discrepancy between unsampled metric data and sampled event data. Examples of this: An APM chart showing unsampled metric data may show you higher throughput than an equivalent NRQL query of sampled event data. For more about the difference between our metric timeslice data and event data, see Data types. A non-New Relic monitoring service may show different results from New Relic. Events that are capped and subject to sampling include: Transaction TransactionError Span (see Distributed tracing sampling) Custom events reported via agent API (example: the .NET agent's RecordCustomEvent) Mobile MobileRequest MobileCrash MobileHandledException Important For APM, you can compensate for sampling when querying data. Change how sampling occurs Before attempting to change how sampling occurs, please read these caveats and recommendations: Reporting more events will result in the agent using more memory. There will usually be a way for you to get the data you need without raising an agent's event-reporting limit. The payload size limit is 1MB (10^6 bytes) (compressed), so the number of events may still be affected by that limit. To determine if events are being dropped, see the agent log for a 413 HTTP status message. Here are some ways to impact sampling: Most agents have configuration options for changing the limit on sampled transactions (examples: Java agentâ€™s max_samples_stored or the Android mobile agentâ€™s setMaxEventPoolSize). If itâ€™s important to you that a specific app activity not be sampled, you can use the Event API. You could deploy your application across a greater number of instances. Because the limits are per-agent, more agents will mean a larger event reservoir. APM: Compensate for sampling When querying APM-reported events, you can compensate for sampling by using EXTRAPOLATE. This will give you an approximation of what unsampled data looks like.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.65497,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Event limits and sampling for <em>APM</em> and mobile monitoring",
        "sections": "Event limits and sampling for <em>APM</em> and mobile monitoring",
        "tags": "<em>New</em> <em>Relic</em> <em>APM</em>",
        "body": " harvest cycle. This is necessary because if there were no limit, a very large number of events being sent could have performance impacts on your application or on <em>New</em> <em>Relic</em>. When the limit is reached, the agents begin sampling events. Different agents have different limits, but the goal is to give"
      },
      "id": "603eb32564441f35734e886f"
    },
    {
      "sections": [
        "Errors while using other APM software",
        "Problem",
        "Solution"
      ],
      "title": "Errors while using other APM software",
      "type": "docs",
      "tags": [
        "APM",
        "New Relic APM",
        "Troubleshooting"
      ],
      "external_id": "585c393ba05316bfb72d665760e1cb2d7e0e0631",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/troubleshooting/errors-while-using-other-apm-software/",
      "published_at": "2021-07-02T09:35:58Z",
      "updated_at": "2021-03-16T07:15:34Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When other monitoring software is running alongside one of our APM agents, we cannot guarantee that our agents will work correctly. In some cases, running more than one type of APM software can cause issues such as unreliable metrics and agent crashes. For specifics, see the requirements and compatibility documentation for a specific APM agent. Solution If you think that running other monitoring software might be causing an issue, here are some recommendations: Read the requirements and compatibility documentation for the New Relic APM agent you're using. To troubleshoot if this is causing an issue, temporarily disable or uninstall other APM software to see if the issue is still present.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.62579,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Errors while using other <em>APM</em> software",
        "sections": "Errors while using other <em>APM</em> software",
        "tags": "<em>New</em> <em>Relic</em> <em>APM</em>",
        "body": " and compatibility documentation for a specific <em>APM</em> agent. Solution If you think that running other monitoring software might be causing an issue, here are some recommendations: Read the requirements and compatibility documentation for the <em>New</em> <em>Relic</em> <em>APM</em> agent you&#x27;re using. To <em>troubleshoot</em> if this is causing an issue, temporarily disable or uninstall other <em>APM</em> software to see if the issue is still present."
      },
      "id": "603ea87828ccbc65f2eba74a"
    }
  ],
  "/docs/apm/new-relic-apm/troubleshooting/cpu-usage-mismatch-or-usage-over-100": [
    {
      "sections": [
        "Remove applications from New Relic",
        "Before attempting to remove an app",
        "Remove an application from New Relic",
        "APM applications",
        "Browser",
        "Tip",
        "Mobile",
        "Troubleshooting",
        "You are not an admin on your full user account",
        "You have not waited long enough",
        "Not all agents are disabled",
        "You have problems removing your PHP app",
        "You don't know where the app's data is coming from",
        "Browser data is still reporting",
        "For more help"
      ],
      "title": "Remove applications from New Relic",
      "type": "docs",
      "tags": [
        "APM",
        "New Relic APM",
        "Maintenance"
      ],
      "external_id": "f457af939892708a477895093f97b65d08ff015a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/maintenance/remove-applications-new-relic/",
      "published_at": "2021-07-02T09:20:58Z",
      "updated_at": "2021-05-21T18:31:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Applications are automatically removed from New Relic after 93 days without sending data to our platform. You can also remove an application using the UI, once it has stopped sending data. Key metrics will continue to be available via the New Relic REST API, with the application name remaining reserved. For more information, see Inactive apps in New Relic One and our data retention guidelines. Before attempting to remove an app Before attempting to remove an APM, browser, or mobile app from the New Relic UI, keep in mind: You can downgrade your account to pay less or make it entirely free. To remove an app, you must have a user role with that capability. If an agent is still sending data from an app, you cannot remove an app. Remove an application from New Relic Before removing an APM, browser, or mobile application from New Relic, stop the application from sending data either by disabling the agent or by uninstalling it completely. APM applications Disable the APM agent: C SDK: Do a quick recompile and deploy. For example, surround your instrumentation in #ifdef, and set the value of YOURNAMESPACE_NEWRELIC_ENABLED with your build system. Go: Set Enabled to false. Java: Set agent_enabled to false. .NET: Set Newrelic.AgentEnabled to false. Node.js: Set agent_enabled to false. PHP: Remove or disable both the newrelic.so and newrelic-daemon components. Set newrelic.enabled to false. Python: Set monitor_mode to false. Ruby: Set agent_enabled to false. Restart the application server and wait up to ten minutes. Verify the color-coded health status for the app has turned to gray and is no longer reporting data. To remove the APM application and any browser applications linked to it, you have two options: Click the Delete application button on the APM application/service's Settings page. Go to one.newrelic.com > APM > (select an app/service) > Settings > Application. Or, call the /applications/delete endpoint of the New Relic REST API. For example: curl -X DELETE 'https://api.newrelic.com/v2/applications/YOUR_APP_ID.json' \\ -H 'X-Api-Key:YOUR_API_KEY' -i Copy Browser If you've used the copy/paste method to install the browser agent, remove the JavaScript snippet from your application's pages. After 93 days, the application will be removed from New Relic. Tip If browser data continues to be reported, see our suggestions below. Once your browser application has stopped reporting, you have two ways to remove it: If your browser application is linked to an APM application, deleting the APM application also removes the browser application. See the instructions for deleting an APM application/service above for details. Or, click the Delete application button on the browser application's Application settings page. Go to one.newrelic.com > Browser > (select an app) > Settings > Application settings . Mobile Remove all references/dependencies to the New Relic's mobile SDK/frameworks, then rebuild the application. For more information, see the iOS and Android install docs. After 93 days, the application will be removed from New Relic. Or, once your mobile application has stopped reporting, you can also remove it manually: Click the Delete application button on the mobile application's Settings page. Go to one.newrelic.com > Mobile > (select an app) > Settings > Application . Troubleshooting If you have problems removing an app, here are some possible causes and suggested solutions: You are not an admin on your full user account If you don't have proper permissions, you won't be able to remove an application. You have not waited long enough All app data must stop reporting to New Relic before you can remove that entity from New Relic. In most cases, this takes between 10-15 minutes. In rare cases, it can take a few minutes longer. Not all agents are disabled If you have multiple agents reporting data under the same UI name, then you must make sure you disable or uninstall all of the agents associated with that entity. You have problems removing your PHP app If you have a PHP app and aren't able to remove it from the UI, possible causes include: You have not disabled both components of the PHP agent. You must stop or uninstall both newrelic.so and newrelic-daemon in order to be able to remove a PHP app. For more information, see New Relic daemon processes. You have set up per-directory monitoring of your PHP app, and unexpected PHP data is reporting as the default PHP application in the New Relic UI. To fix this, change the default app name in the PHP agent config. You don't know where the app's data is coming from If you don't know where an app's data is coming from, it may be because the app's name has been changed. When an app name is changed in the UI, it does not change the underlying app name being reported; it only changes how the app name appears in the UI. To see if there is a difference between the reported name and the displayed name: From one.newrelic.com, select APM, then select an application. Scroll down to Settings and select Application. Compare the name in the Application alias field to the name in the Your application still reports as message directly beneath it. To get host information about an app you are not familiar with: From one.newrelic.com, select APM, then select an application. From the summary view, review the Servers list. Once you have identified where app data is coming from, you can remove the app from New Relic. Browser data is still reporting To remove an app from New Relic, all data must have stopped reporting, including browser monitoring data. To verify that you have disabled or uninstalled the APM agent associated with the app: Ensure that browser monitoring is disabled. If your browser monitoring script is inserted by the APM agent, turn it off from inside the UI, in the agent's config file, or in both. If you copied and pasted the monitoring JavaScript snippet in certain pages, remove that JavaScript snippet manually. Ensure all caches have been cleared that the application uses, such as host caches, CDNs, or anything else that caches built pages. Optional: To see a count of how many page views report from each domain, use this NRQL query: SELECT count(*) FROM PageView WHERE appName = 'YOUR_BROWSER_APP_NAME' FACET domain Copy If these steps don't resolve the issue, it is likely due to an end-user's browser cache that hasn't yet cleared. Wait until those caches clear. If your app has internal users, you may be able to identify the users and clear those caches. For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.14737,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Remove applications from <em>New</em> <em>Relic</em>",
        "sections": "Remove applications from <em>New</em> <em>Relic</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>APM</em>",
        "body": " reserved. For more information, see Inactive apps in <em>New</em> <em>Relic</em> One and our data retention guidelines. Before attempting to remove an app Before attempting to remove an <em>APM</em>, browser, or mobile app from the <em>New</em> <em>Relic</em> UI, keep in mind: You can downgrade your account to pay less or make it entirely free"
      },
      "id": "603ebbef28ccbc48d1eba78d"
    },
    {
      "sections": [
        "Event limits and sampling for APM and mobile monitoring",
        "Difference between events and metrics",
        "Why sampling of events is necessary",
        "The impact of sampling",
        "Important",
        "Change how sampling occurs",
        "APM: Compensate for sampling"
      ],
      "title": "Event limits and sampling for APM and mobile monitoring",
      "type": "docs",
      "tags": [
        "APM",
        "New Relic APM",
        "Troubleshooting"
      ],
      "external_id": "27b04d675cbdea50185303ed1c6c9290990488d6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/data/understand-data/new-relic-event-limits-sampling/",
      "published_at": "2021-07-02T11:33:39Z",
      "updated_at": "2021-03-16T15:50:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our APM agents and mobile agents have limits on the number of events that can be reported. This document explains: Why event-reporting limits are necessary How sampling works How to work with and understand sampled data Difference between events and metrics This document is about limits on event data and how those limits lead to sampling. First, it may help you to understand the differences between these two types of data: Metrics: aggregated measurements over time. Examples: average response time over a one-minute time range, throughput over time, CPU utilization over time. Events: discrete events that happen at a specific moment in time. Examples: a log or error being reported, or a configuration change. Some events are aggregated over time to form metrics (for example: a count of errors over time). These two types of data have different uses: metrics are useful for recognizing patterns over time in your system, and events are useful for drilling down and getting detail about the causes of those patterns. Because metrics are aggregated over time, theyâ€™re useful for spotting trends and changes in system behavior. For metrics that represent an aggregated count of events (like an HTTP response time metric), the individual events give you granular detail about what happened, and let you facet by attributes that have high cardinality (like account or user ID). Why sampling of events is necessary Our APM agents and mobile agents have limits on how many events can be reported per harvest cycle. This is necessary because if there were no limit, a very large number of events being sent could have performance impacts on your application or on New Relic. When the limit is reached, the agents begin sampling events. Different agents have different limits, but the goal is to give a representative sample from across the harvest cycle. Also, agents may sample if they can't connect to New Relic. When an agent canâ€™t connect to New Relic, it continues to store data locally. But it must restrict the size of the payload that is eventually sent. For this reason, it samples events during the disconnected period. The longer it is disconnected, the more it will sample. The impact of sampling One result of sampling is that there can be a discrepancy between unsampled metric data and sampled event data. Examples of this: An APM chart showing unsampled metric data may show you higher throughput than an equivalent NRQL query of sampled event data. For more about the difference between our metric timeslice data and event data, see Data types. A non-New Relic monitoring service may show different results from New Relic. Events that are capped and subject to sampling include: Transaction TransactionError Span (see Distributed tracing sampling) Custom events reported via agent API (example: the .NET agent's RecordCustomEvent) Mobile MobileRequest MobileCrash MobileHandledException Important For APM, you can compensate for sampling when querying data. Change how sampling occurs Before attempting to change how sampling occurs, please read these caveats and recommendations: Reporting more events will result in the agent using more memory. There will usually be a way for you to get the data you need without raising an agent's event-reporting limit. The payload size limit is 1MB (10^6 bytes) (compressed), so the number of events may still be affected by that limit. To determine if events are being dropped, see the agent log for a 413 HTTP status message. Here are some ways to impact sampling: Most agents have configuration options for changing the limit on sampled transactions (examples: Java agentâ€™s max_samples_stored or the Android mobile agentâ€™s setMaxEventPoolSize). If itâ€™s important to you that a specific app activity not be sampled, you can use the Event API. You could deploy your application across a greater number of instances. Because the limits are per-agent, more agents will mean a larger event reservoir. APM: Compensate for sampling When querying APM-reported events, you can compensate for sampling by using EXTRAPOLATE. This will give you an approximation of what unsampled data looks like.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.65497,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Event limits and sampling for <em>APM</em> and mobile monitoring",
        "sections": "Event limits and sampling for <em>APM</em> and mobile monitoring",
        "tags": "<em>New</em> <em>Relic</em> <em>APM</em>",
        "body": " harvest cycle. This is necessary because if there were no limit, a very large number of events being sent could have performance impacts on your application or on <em>New</em> <em>Relic</em>. When the limit is reached, the agents begin sampling events. Different agents have different limits, but the goal is to give"
      },
      "id": "603eb32564441f35734e886f"
    },
    {
      "sections": [
        "Errors while using other APM software",
        "Problem",
        "Solution"
      ],
      "title": "Errors while using other APM software",
      "type": "docs",
      "tags": [
        "APM",
        "New Relic APM",
        "Troubleshooting"
      ],
      "external_id": "585c393ba05316bfb72d665760e1cb2d7e0e0631",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/troubleshooting/errors-while-using-other-apm-software/",
      "published_at": "2021-07-02T09:35:58Z",
      "updated_at": "2021-03-16T07:15:34Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When other monitoring software is running alongside one of our APM agents, we cannot guarantee that our agents will work correctly. In some cases, running more than one type of APM software can cause issues such as unreliable metrics and agent crashes. For specifics, see the requirements and compatibility documentation for a specific APM agent. Solution If you think that running other monitoring software might be causing an issue, here are some recommendations: Read the requirements and compatibility documentation for the New Relic APM agent you're using. To troubleshoot if this is causing an issue, temporarily disable or uninstall other APM software to see if the issue is still present.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.62579,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Errors while using other <em>APM</em> software",
        "sections": "Errors while using other <em>APM</em> software",
        "tags": "<em>New</em> <em>Relic</em> <em>APM</em>",
        "body": " and compatibility documentation for a specific <em>APM</em> agent. Solution If you think that running other monitoring software might be causing an issue, here are some recommendations: Read the requirements and compatibility documentation for the <em>New</em> <em>Relic</em> <em>APM</em> agent you&#x27;re using. To <em>troubleshoot</em> if this is causing an issue, temporarily disable or uninstall other <em>APM</em> software to see if the issue is still present."
      },
      "id": "603ea87828ccbc65f2eba74a"
    }
  ],
  "/docs/apm/new-relic-apm/troubleshooting/errors-while-using-other-apm-software": [
    {
      "sections": [
        "Remove applications from New Relic",
        "Before attempting to remove an app",
        "Remove an application from New Relic",
        "APM applications",
        "Browser",
        "Tip",
        "Mobile",
        "Troubleshooting",
        "You are not an admin on your full user account",
        "You have not waited long enough",
        "Not all agents are disabled",
        "You have problems removing your PHP app",
        "You don't know where the app's data is coming from",
        "Browser data is still reporting",
        "For more help"
      ],
      "title": "Remove applications from New Relic",
      "type": "docs",
      "tags": [
        "APM",
        "New Relic APM",
        "Maintenance"
      ],
      "external_id": "f457af939892708a477895093f97b65d08ff015a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/maintenance/remove-applications-new-relic/",
      "published_at": "2021-07-02T09:20:58Z",
      "updated_at": "2021-05-21T18:31:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Applications are automatically removed from New Relic after 93 days without sending data to our platform. You can also remove an application using the UI, once it has stopped sending data. Key metrics will continue to be available via the New Relic REST API, with the application name remaining reserved. For more information, see Inactive apps in New Relic One and our data retention guidelines. Before attempting to remove an app Before attempting to remove an APM, browser, or mobile app from the New Relic UI, keep in mind: You can downgrade your account to pay less or make it entirely free. To remove an app, you must have a user role with that capability. If an agent is still sending data from an app, you cannot remove an app. Remove an application from New Relic Before removing an APM, browser, or mobile application from New Relic, stop the application from sending data either by disabling the agent or by uninstalling it completely. APM applications Disable the APM agent: C SDK: Do a quick recompile and deploy. For example, surround your instrumentation in #ifdef, and set the value of YOURNAMESPACE_NEWRELIC_ENABLED with your build system. Go: Set Enabled to false. Java: Set agent_enabled to false. .NET: Set Newrelic.AgentEnabled to false. Node.js: Set agent_enabled to false. PHP: Remove or disable both the newrelic.so and newrelic-daemon components. Set newrelic.enabled to false. Python: Set monitor_mode to false. Ruby: Set agent_enabled to false. Restart the application server and wait up to ten minutes. Verify the color-coded health status for the app has turned to gray and is no longer reporting data. To remove the APM application and any browser applications linked to it, you have two options: Click the Delete application button on the APM application/service's Settings page. Go to one.newrelic.com > APM > (select an app/service) > Settings > Application. Or, call the /applications/delete endpoint of the New Relic REST API. For example: curl -X DELETE 'https://api.newrelic.com/v2/applications/YOUR_APP_ID.json' \\ -H 'X-Api-Key:YOUR_API_KEY' -i Copy Browser If you've used the copy/paste method to install the browser agent, remove the JavaScript snippet from your application's pages. After 93 days, the application will be removed from New Relic. Tip If browser data continues to be reported, see our suggestions below. Once your browser application has stopped reporting, you have two ways to remove it: If your browser application is linked to an APM application, deleting the APM application also removes the browser application. See the instructions for deleting an APM application/service above for details. Or, click the Delete application button on the browser application's Application settings page. Go to one.newrelic.com > Browser > (select an app) > Settings > Application settings . Mobile Remove all references/dependencies to the New Relic's mobile SDK/frameworks, then rebuild the application. For more information, see the iOS and Android install docs. After 93 days, the application will be removed from New Relic. Or, once your mobile application has stopped reporting, you can also remove it manually: Click the Delete application button on the mobile application's Settings page. Go to one.newrelic.com > Mobile > (select an app) > Settings > Application . Troubleshooting If you have problems removing an app, here are some possible causes and suggested solutions: You are not an admin on your full user account If you don't have proper permissions, you won't be able to remove an application. You have not waited long enough All app data must stop reporting to New Relic before you can remove that entity from New Relic. In most cases, this takes between 10-15 minutes. In rare cases, it can take a few minutes longer. Not all agents are disabled If you have multiple agents reporting data under the same UI name, then you must make sure you disable or uninstall all of the agents associated with that entity. You have problems removing your PHP app If you have a PHP app and aren't able to remove it from the UI, possible causes include: You have not disabled both components of the PHP agent. You must stop or uninstall both newrelic.so and newrelic-daemon in order to be able to remove a PHP app. For more information, see New Relic daemon processes. You have set up per-directory monitoring of your PHP app, and unexpected PHP data is reporting as the default PHP application in the New Relic UI. To fix this, change the default app name in the PHP agent config. You don't know where the app's data is coming from If you don't know where an app's data is coming from, it may be because the app's name has been changed. When an app name is changed in the UI, it does not change the underlying app name being reported; it only changes how the app name appears in the UI. To see if there is a difference between the reported name and the displayed name: From one.newrelic.com, select APM, then select an application. Scroll down to Settings and select Application. Compare the name in the Application alias field to the name in the Your application still reports as message directly beneath it. To get host information about an app you are not familiar with: From one.newrelic.com, select APM, then select an application. From the summary view, review the Servers list. Once you have identified where app data is coming from, you can remove the app from New Relic. Browser data is still reporting To remove an app from New Relic, all data must have stopped reporting, including browser monitoring data. To verify that you have disabled or uninstalled the APM agent associated with the app: Ensure that browser monitoring is disabled. If your browser monitoring script is inserted by the APM agent, turn it off from inside the UI, in the agent's config file, or in both. If you copied and pasted the monitoring JavaScript snippet in certain pages, remove that JavaScript snippet manually. Ensure all caches have been cleared that the application uses, such as host caches, CDNs, or anything else that caches built pages. Optional: To see a count of how many page views report from each domain, use this NRQL query: SELECT count(*) FROM PageView WHERE appName = 'YOUR_BROWSER_APP_NAME' FACET domain Copy If these steps don't resolve the issue, it is likely due to an end-user's browser cache that hasn't yet cleared. Wait until those caches clear. If your app has internal users, you may be able to identify the users and clear those caches. For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.14737,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Remove applications from <em>New</em> <em>Relic</em>",
        "sections": "Remove applications from <em>New</em> <em>Relic</em>",
        "tags": "<em>New</em> <em>Relic</em> <em>APM</em>",
        "body": " reserved. For more information, see Inactive apps in <em>New</em> <em>Relic</em> One and our data retention guidelines. Before attempting to remove an app Before attempting to remove an <em>APM</em>, browser, or mobile app from the <em>New</em> <em>Relic</em> UI, keep in mind: You can downgrade your account to pay less or make it entirely free"
      },
      "id": "603ebbef28ccbc48d1eba78d"
    },
    {
      "sections": [
        "Event limits and sampling for APM and mobile monitoring",
        "Difference between events and metrics",
        "Why sampling of events is necessary",
        "The impact of sampling",
        "Important",
        "Change how sampling occurs",
        "APM: Compensate for sampling"
      ],
      "title": "Event limits and sampling for APM and mobile monitoring",
      "type": "docs",
      "tags": [
        "APM",
        "New Relic APM",
        "Troubleshooting"
      ],
      "external_id": "27b04d675cbdea50185303ed1c6c9290990488d6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/data/understand-data/new-relic-event-limits-sampling/",
      "published_at": "2021-07-02T11:33:39Z",
      "updated_at": "2021-03-16T15:50:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our APM agents and mobile agents have limits on the number of events that can be reported. This document explains: Why event-reporting limits are necessary How sampling works How to work with and understand sampled data Difference between events and metrics This document is about limits on event data and how those limits lead to sampling. First, it may help you to understand the differences between these two types of data: Metrics: aggregated measurements over time. Examples: average response time over a one-minute time range, throughput over time, CPU utilization over time. Events: discrete events that happen at a specific moment in time. Examples: a log or error being reported, or a configuration change. Some events are aggregated over time to form metrics (for example: a count of errors over time). These two types of data have different uses: metrics are useful for recognizing patterns over time in your system, and events are useful for drilling down and getting detail about the causes of those patterns. Because metrics are aggregated over time, theyâ€™re useful for spotting trends and changes in system behavior. For metrics that represent an aggregated count of events (like an HTTP response time metric), the individual events give you granular detail about what happened, and let you facet by attributes that have high cardinality (like account or user ID). Why sampling of events is necessary Our APM agents and mobile agents have limits on how many events can be reported per harvest cycle. This is necessary because if there were no limit, a very large number of events being sent could have performance impacts on your application or on New Relic. When the limit is reached, the agents begin sampling events. Different agents have different limits, but the goal is to give a representative sample from across the harvest cycle. Also, agents may sample if they can't connect to New Relic. When an agent canâ€™t connect to New Relic, it continues to store data locally. But it must restrict the size of the payload that is eventually sent. For this reason, it samples events during the disconnected period. The longer it is disconnected, the more it will sample. The impact of sampling One result of sampling is that there can be a discrepancy between unsampled metric data and sampled event data. Examples of this: An APM chart showing unsampled metric data may show you higher throughput than an equivalent NRQL query of sampled event data. For more about the difference between our metric timeslice data and event data, see Data types. A non-New Relic monitoring service may show different results from New Relic. Events that are capped and subject to sampling include: Transaction TransactionError Span (see Distributed tracing sampling) Custom events reported via agent API (example: the .NET agent's RecordCustomEvent) Mobile MobileRequest MobileCrash MobileHandledException Important For APM, you can compensate for sampling when querying data. Change how sampling occurs Before attempting to change how sampling occurs, please read these caveats and recommendations: Reporting more events will result in the agent using more memory. There will usually be a way for you to get the data you need without raising an agent's event-reporting limit. The payload size limit is 1MB (10^6 bytes) (compressed), so the number of events may still be affected by that limit. To determine if events are being dropped, see the agent log for a 413 HTTP status message. Here are some ways to impact sampling: Most agents have configuration options for changing the limit on sampled transactions (examples: Java agentâ€™s max_samples_stored or the Android mobile agentâ€™s setMaxEventPoolSize). If itâ€™s important to you that a specific app activity not be sampled, you can use the Event API. You could deploy your application across a greater number of instances. Because the limits are per-agent, more agents will mean a larger event reservoir. APM: Compensate for sampling When querying APM-reported events, you can compensate for sampling by using EXTRAPOLATE. This will give you an approximation of what unsampled data looks like.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.65497,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Event limits and sampling for <em>APM</em> and mobile monitoring",
        "sections": "Event limits and sampling for <em>APM</em> and mobile monitoring",
        "tags": "<em>New</em> <em>Relic</em> <em>APM</em>",
        "body": " harvest cycle. This is necessary because if there were no limit, a very large number of events being sent could have performance impacts on your application or on <em>New</em> <em>Relic</em>. When the limit is reached, the agents begin sampling events. Different agents have different limits, but the goal is to give"
      },
      "id": "603eb32564441f35734e886f"
    },
    {
      "sections": [
        "Charts missing or do not render",
        "Problem",
        "Solution"
      ],
      "title": "Charts missing or do not render",
      "type": "docs",
      "tags": [
        "APM",
        "New Relic APM",
        "Troubleshooting"
      ],
      "external_id": "9eda8feae019ed62d0e20e59f2d2f941faa80229",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/new-relic-apm/troubleshooting/charts-missing-or-do-not-render/",
      "published_at": "2021-07-02T09:34:30Z",
      "updated_at": "2021-03-16T06:47:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem Charts in the New Relic UI are missing or not displaying correctly. Solution Browser extensions that modify JavaScript, such as Adblock, Ghostery, or Request Maker, can cause display issues. To fix this issue, add our New Relic domains to your allow list, or uninstall the extension. Also, your browser might be too old to display New Relic charts. Verify your browser meets our minimum supported browser versions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.62423,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>New</em> <em>Relic</em> <em>APM</em>",
        "body": "Problem Charts in the <em>New</em> <em>Relic</em> UI are missing or not displaying correctly. Solution Browser extensions that modify JavaScript, such as Adblock, Ghostery, or Request Maker, can cause display issues. To fix this issue, add our <em>New</em> <em>Relic</em> domains to your allow list, or uninstall the extension. Also, your browser might be too old to display <em>New</em> <em>Relic</em> charts. Verify your browser meets our minimum supported browser versions."
      },
      "id": "603eb813196a67d9d9a83d97"
    }
  ],
  "/docs/apm/reports/other-performance-analysis/background-jobs-analysis-report": [
    {
      "sections": [
        "Weekly performance report",
        "Important",
        "View example report details",
        "Selected applications",
        "Opt in or out of report emails",
        "Analyze your data"
      ],
      "title": "Weekly performance report ",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "2648d299a52f3e5694035bb27a16536934c8dc89",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/weekly-performance-report/",
      "published_at": "2021-07-02T09:38:23Z",
      "updated_at": "2021-03-16T07:16:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Every Monday, New Relic sends a weekly performance report via email to any of your account's users who have selected to receive this report. The email report contains summary performance metrics for the past week for a select group of your applications. The weekly performance report is different than APM's Service Level Agreement (SLA) reports. Important At this time, weekly performance reports are not available for accounts in the EU region. View example report details To see an example of a weekly performance report for your account: From the account dropdown, select User preferences. Select Weekly summaries and select See sample email. The performance report is split into sections: Section Description Featured app This provides both throughput pattern and performance metrics for the application with the highest call count in your account. Applications with linked browser monitoring will be prioritized over those that don't, even if the call count is lower. All apps report This section provides important performance metrics for the 20 applications in your account with the highest call count. Metrics in this list include uptime, Apdex, load time, and throughput. Recent events This section contains any recent alerts, deployments you have made to your app, or other events that are recorded for applications in your account. Selected applications New Relic selects the top 20 apps by call count that meet these criteria: The app must have at least 25 requests per minute (rpm) throughput. The app must include web transactions. Applications with linked browser monitoring will be prioritized over those that don't, even if the call count is lower. Opt in or out of report emails To manage your weekly performance report emails, go to one.newrelic.com, click the account dropdown, and select User preferences. Note that you opt in/out separately for every New Relic account you have access to. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.89706,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Weekly <em>performance</em> <em>report</em> ",
        "sections": "Weekly <em>performance</em> <em>report</em>",
        "tags": "<em>Other</em> <em>performance</em> <em>analysis</em>",
        "body": " than <em>APM</em>&#x27;s Service Level Agreement (SLA) <em>reports</em>. Important At this time, weekly <em>performance</em> <em>reports</em> are not available for accounts in the EU region. View example <em>report</em> details To see an example of a weekly <em>performance</em> <em>report</em> for your account: From the account dropdown, select User preferences"
      },
      "id": "603ec4e8196a67c3daa83dea"
    },
    {
      "sections": [
        "Web transactions analysis report",
        "View the Web transactions analysis report",
        "Analyze your data"
      ],
      "title": "Web transactions analysis report",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "c853c17692f878455c491e9f1a78341059f6a199",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/web-transactions-analysis-report/",
      "published_at": "2021-07-02T09:38:23Z",
      "updated_at": "2021-03-16T07:16:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM's web transactions analysis report provides comparison information for web transactions, including the amount of time spent in throughput (requests per minute or rpm), total time in the web transaction, average time to execute it, and Apdex score. You can compare the past 24 hours of data with the previous 24 hour period, 7 days ago, and averages over the last 7 days. Use this information to analyze which web transactions consume the most time, have the most number of calls, have the greatest number of standard deviations, and more. This information can help you identify where to fine-tune your app. View the Web transactions analysis report To view the web transactions analysis report for your app: Go to one.newrelic.com > APM > (select an app) > Reports > Web transactions. The default report compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over the last 7 days. Apdex entries followed by an asterisk ( * ) indicate that more than one Apdex threshold was set for the given time period. If you want to... Do this Change the amount of detail shown Select or clear the time period checkbox options, then select Apply. Limit the transactions that appear Use the Filter text box; for example, to report only on transactions that include user in the name. Change the sort order Select any column's title to sort in ascending or descending order. Select what data appears as a bar chart Select a Plotting option. View web transaction details Select the web transaction's title to go directly to the APM Transactions page. Return the original settings Select the reset link. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.89706,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Web transactions <em>analysis</em> <em>report</em>",
        "sections": "Web transactions <em>analysis</em> <em>report</em>",
        "tags": "<em>Other</em> <em>performance</em> <em>analysis</em>",
        "body": "-tune your app. View the Web transactions <em>analysis</em> <em>report</em> To view the web transactions <em>analysis</em> <em>report</em> for your app: Go to one.newrelic.com &gt; <em>APM</em> &gt; (select an app) &gt; <em>Reports</em> &gt; Web transactions. The default <em>report</em> compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over"
      },
      "id": "603ebfc7196a67aa0da83daa"
    },
    {
      "sections": [
        "Database analysis report",
        "View the database analysis report",
        "Analyze your data"
      ],
      "title": "Database analysis report",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "2627a588c2c730695f87d497407630fbd525ed16",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/database-analysis-report/",
      "published_at": "2021-07-02T09:37:25Z",
      "updated_at": "2021-03-16T07:15:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM's database analysis report allows you to analyze your application's performance from the database viewpoint, from the past 24 hours back to the past seven days. It shows comparison information for transactions, including the amount of time spent in throughput (operation requests per minute or rpm), total time spent in the operation, and average time to execute it. View the database analysis report To view the database analysis report for your app: Go to one.newrelic.com > APM > (select an app) > Reports > Database. The default report compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over the last 7 days. If you want to... Do this Change the amount of detail shown Select or clear the time period checkbox options, then select Apply. Limit the transactions that appear Type the value in the Filter text box; for example, to show only transactions for Model operations that contain the value User. Change the sort order Select any column's title to sort in ascending or descending order. Select what data appears as a bar chart Select a Plotting option. View transaction details Select the transaction's title to go directly to APM's Database and slow queries page. Return the original settings Select the reset link. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.89693,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Database <em>analysis</em> <em>report</em>",
        "sections": "Database <em>analysis</em> <em>report</em>",
        "tags": "<em>Other</em> <em>performance</em> <em>analysis</em>",
        "body": "<em>APM</em>&#x27;s database <em>analysis</em> <em>report</em> allows you to analyze your application&#x27;s <em>performance</em> from the database viewpoint, from the past 24 hours back to the past seven days. It shows comparison information for transactions, including the amount of time spent in throughput (operation requests per minute"
      },
      "id": "603ebf8964441fd4df4e887a"
    }
  ],
  "/docs/apm/reports/other-performance-analysis/capacity-analysis-report": [
    {
      "sections": [
        "Weekly performance report",
        "Important",
        "View example report details",
        "Selected applications",
        "Opt in or out of report emails",
        "Analyze your data"
      ],
      "title": "Weekly performance report ",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "2648d299a52f3e5694035bb27a16536934c8dc89",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/weekly-performance-report/",
      "published_at": "2021-07-02T09:38:23Z",
      "updated_at": "2021-03-16T07:16:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Every Monday, New Relic sends a weekly performance report via email to any of your account's users who have selected to receive this report. The email report contains summary performance metrics for the past week for a select group of your applications. The weekly performance report is different than APM's Service Level Agreement (SLA) reports. Important At this time, weekly performance reports are not available for accounts in the EU region. View example report details To see an example of a weekly performance report for your account: From the account dropdown, select User preferences. Select Weekly summaries and select See sample email. The performance report is split into sections: Section Description Featured app This provides both throughput pattern and performance metrics for the application with the highest call count in your account. Applications with linked browser monitoring will be prioritized over those that don't, even if the call count is lower. All apps report This section provides important performance metrics for the 20 applications in your account with the highest call count. Metrics in this list include uptime, Apdex, load time, and throughput. Recent events This section contains any recent alerts, deployments you have made to your app, or other events that are recorded for applications in your account. Selected applications New Relic selects the top 20 apps by call count that meet these criteria: The app must have at least 25 requests per minute (rpm) throughput. The app must include web transactions. Applications with linked browser monitoring will be prioritized over those that don't, even if the call count is lower. Opt in or out of report emails To manage your weekly performance report emails, go to one.newrelic.com, click the account dropdown, and select User preferences. Note that you opt in/out separately for every New Relic account you have access to. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.89706,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Weekly <em>performance</em> <em>report</em> ",
        "sections": "Weekly <em>performance</em> <em>report</em>",
        "tags": "<em>Other</em> <em>performance</em> <em>analysis</em>",
        "body": " than <em>APM</em>&#x27;s Service Level Agreement (SLA) <em>reports</em>. Important At this time, weekly <em>performance</em> <em>reports</em> are not available for accounts in the EU region. View example <em>report</em> details To see an example of a weekly <em>performance</em> <em>report</em> for your account: From the account dropdown, select User preferences"
      },
      "id": "603ec4e8196a67c3daa83dea"
    },
    {
      "sections": [
        "Web transactions analysis report",
        "View the Web transactions analysis report",
        "Analyze your data"
      ],
      "title": "Web transactions analysis report",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "c853c17692f878455c491e9f1a78341059f6a199",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/web-transactions-analysis-report/",
      "published_at": "2021-07-02T09:38:23Z",
      "updated_at": "2021-03-16T07:16:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM's web transactions analysis report provides comparison information for web transactions, including the amount of time spent in throughput (requests per minute or rpm), total time in the web transaction, average time to execute it, and Apdex score. You can compare the past 24 hours of data with the previous 24 hour period, 7 days ago, and averages over the last 7 days. Use this information to analyze which web transactions consume the most time, have the most number of calls, have the greatest number of standard deviations, and more. This information can help you identify where to fine-tune your app. View the Web transactions analysis report To view the web transactions analysis report for your app: Go to one.newrelic.com > APM > (select an app) > Reports > Web transactions. The default report compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over the last 7 days. Apdex entries followed by an asterisk ( * ) indicate that more than one Apdex threshold was set for the given time period. If you want to... Do this Change the amount of detail shown Select or clear the time period checkbox options, then select Apply. Limit the transactions that appear Use the Filter text box; for example, to report only on transactions that include user in the name. Change the sort order Select any column's title to sort in ascending or descending order. Select what data appears as a bar chart Select a Plotting option. View web transaction details Select the web transaction's title to go directly to the APM Transactions page. Return the original settings Select the reset link. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.89706,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Web transactions <em>analysis</em> <em>report</em>",
        "sections": "Web transactions <em>analysis</em> <em>report</em>",
        "tags": "<em>Other</em> <em>performance</em> <em>analysis</em>",
        "body": "-tune your app. View the Web transactions <em>analysis</em> <em>report</em> To view the web transactions <em>analysis</em> <em>report</em> for your app: Go to one.newrelic.com &gt; <em>APM</em> &gt; (select an app) &gt; <em>Reports</em> &gt; Web transactions. The default <em>report</em> compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over"
      },
      "id": "603ebfc7196a67aa0da83daa"
    },
    {
      "sections": [
        "Background jobs analysis report",
        "View report in UI",
        "Analyze your data"
      ],
      "title": "Background jobs analysis report",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "7402d8928cc5753497e2cfec0104d992c2cddacd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/background-jobs-analysis-report/",
      "published_at": "2021-07-02T09:35:58Z",
      "updated_at": "2021-03-16T07:15:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Background jobs analysis report helps you analyze the performance of jobs and other non-web transactions running in production that use frameworks instrumented by New Relic, such as DelayedJob and Resque. The report shows comparison information from the past 24 hours back to the past 7 days, including the amount of time spent in throughput (requests per minute or rpm), total time spent in the job, and average time to execute it. View report in UI To view the Background jobs analysis report for your app: Go to one.newrelic.com > APM > (select an app) > Reports > Background jobs. The default report compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over the last 7 days. If you want to... Do this Change the amount of detail shown Select or clear the time period checkbox options, and then select Apply. Limit the transactions that appear Use the Filter text box. Change the sort order Select any column's title to sort in ascending or descending order. Select what data appears as a bar chart Select a Plotting option. View transaction details Select the transaction's title to go directly to the APM Transactions page. Return the original settings Select the reset link. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.89693,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Background jobs <em>analysis</em> <em>report</em>",
        "sections": "Background jobs <em>analysis</em> <em>report</em>",
        "tags": "<em>Other</em> <em>performance</em> <em>analysis</em>",
        "body": "The Background jobs <em>analysis</em> <em>report</em> helps you analyze the <em>performance</em> of jobs and <em>other</em> non-web transactions running in production that use frameworks instrumented by New Relic, such as DelayedJob and Resque. The <em>report</em> shows comparison information from the past 24 hours back to the past 7 days"
      },
      "id": "603ebf8964441f0c044e885b"
    }
  ],
  "/docs/apm/reports/other-performance-analysis/database-analysis-report": [
    {
      "sections": [
        "Weekly performance report",
        "Important",
        "View example report details",
        "Selected applications",
        "Opt in or out of report emails",
        "Analyze your data"
      ],
      "title": "Weekly performance report ",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "2648d299a52f3e5694035bb27a16536934c8dc89",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/weekly-performance-report/",
      "published_at": "2021-07-02T09:38:23Z",
      "updated_at": "2021-03-16T07:16:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Every Monday, New Relic sends a weekly performance report via email to any of your account's users who have selected to receive this report. The email report contains summary performance metrics for the past week for a select group of your applications. The weekly performance report is different than APM's Service Level Agreement (SLA) reports. Important At this time, weekly performance reports are not available for accounts in the EU region. View example report details To see an example of a weekly performance report for your account: From the account dropdown, select User preferences. Select Weekly summaries and select See sample email. The performance report is split into sections: Section Description Featured app This provides both throughput pattern and performance metrics for the application with the highest call count in your account. Applications with linked browser monitoring will be prioritized over those that don't, even if the call count is lower. All apps report This section provides important performance metrics for the 20 applications in your account with the highest call count. Metrics in this list include uptime, Apdex, load time, and throughput. Recent events This section contains any recent alerts, deployments you have made to your app, or other events that are recorded for applications in your account. Selected applications New Relic selects the top 20 apps by call count that meet these criteria: The app must have at least 25 requests per minute (rpm) throughput. The app must include web transactions. Applications with linked browser monitoring will be prioritized over those that don't, even if the call count is lower. Opt in or out of report emails To manage your weekly performance report emails, go to one.newrelic.com, click the account dropdown, and select User preferences. Note that you opt in/out separately for every New Relic account you have access to. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.89706,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Weekly <em>performance</em> <em>report</em> ",
        "sections": "Weekly <em>performance</em> <em>report</em>",
        "tags": "<em>Other</em> <em>performance</em> <em>analysis</em>",
        "body": " than <em>APM</em>&#x27;s Service Level Agreement (SLA) <em>reports</em>. Important At this time, weekly <em>performance</em> <em>reports</em> are not available for accounts in the EU region. View example <em>report</em> details To see an example of a weekly <em>performance</em> <em>report</em> for your account: From the account dropdown, select User preferences"
      },
      "id": "603ec4e8196a67c3daa83dea"
    },
    {
      "sections": [
        "Web transactions analysis report",
        "View the Web transactions analysis report",
        "Analyze your data"
      ],
      "title": "Web transactions analysis report",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "c853c17692f878455c491e9f1a78341059f6a199",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/web-transactions-analysis-report/",
      "published_at": "2021-07-02T09:38:23Z",
      "updated_at": "2021-03-16T07:16:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM's web transactions analysis report provides comparison information for web transactions, including the amount of time spent in throughput (requests per minute or rpm), total time in the web transaction, average time to execute it, and Apdex score. You can compare the past 24 hours of data with the previous 24 hour period, 7 days ago, and averages over the last 7 days. Use this information to analyze which web transactions consume the most time, have the most number of calls, have the greatest number of standard deviations, and more. This information can help you identify where to fine-tune your app. View the Web transactions analysis report To view the web transactions analysis report for your app: Go to one.newrelic.com > APM > (select an app) > Reports > Web transactions. The default report compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over the last 7 days. Apdex entries followed by an asterisk ( * ) indicate that more than one Apdex threshold was set for the given time period. If you want to... Do this Change the amount of detail shown Select or clear the time period checkbox options, then select Apply. Limit the transactions that appear Use the Filter text box; for example, to report only on transactions that include user in the name. Change the sort order Select any column's title to sort in ascending or descending order. Select what data appears as a bar chart Select a Plotting option. View web transaction details Select the web transaction's title to go directly to the APM Transactions page. Return the original settings Select the reset link. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.89706,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Web transactions <em>analysis</em> <em>report</em>",
        "sections": "Web transactions <em>analysis</em> <em>report</em>",
        "tags": "<em>Other</em> <em>performance</em> <em>analysis</em>",
        "body": "-tune your app. View the Web transactions <em>analysis</em> <em>report</em> To view the web transactions <em>analysis</em> <em>report</em> for your app: Go to one.newrelic.com &gt; <em>APM</em> &gt; (select an app) &gt; <em>Reports</em> &gt; Web transactions. The default <em>report</em> compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over"
      },
      "id": "603ebfc7196a67aa0da83daa"
    },
    {
      "sections": [
        "Background jobs analysis report",
        "View report in UI",
        "Analyze your data"
      ],
      "title": "Background jobs analysis report",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "7402d8928cc5753497e2cfec0104d992c2cddacd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/background-jobs-analysis-report/",
      "published_at": "2021-07-02T09:35:58Z",
      "updated_at": "2021-03-16T07:15:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Background jobs analysis report helps you analyze the performance of jobs and other non-web transactions running in production that use frameworks instrumented by New Relic, such as DelayedJob and Resque. The report shows comparison information from the past 24 hours back to the past 7 days, including the amount of time spent in throughput (requests per minute or rpm), total time spent in the job, and average time to execute it. View report in UI To view the Background jobs analysis report for your app: Go to one.newrelic.com > APM > (select an app) > Reports > Background jobs. The default report compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over the last 7 days. If you want to... Do this Change the amount of detail shown Select or clear the time period checkbox options, and then select Apply. Limit the transactions that appear Use the Filter text box. Change the sort order Select any column's title to sort in ascending or descending order. Select what data appears as a bar chart Select a Plotting option. View transaction details Select the transaction's title to go directly to the APM Transactions page. Return the original settings Select the reset link. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.89693,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Background jobs <em>analysis</em> <em>report</em>",
        "sections": "Background jobs <em>analysis</em> <em>report</em>",
        "tags": "<em>Other</em> <em>performance</em> <em>analysis</em>",
        "body": "The Background jobs <em>analysis</em> <em>report</em> helps you analyze the <em>performance</em> of jobs and <em>other</em> non-web transactions running in production that use frameworks instrumented by New Relic, such as DelayedJob and Resque. The <em>report</em> shows comparison information from the past 24 hours back to the past 7 days"
      },
      "id": "603ebf8964441f0c044e885b"
    }
  ],
  "/docs/apm/reports/other-performance-analysis/scalability-analysis-report": [
    {
      "sections": [
        "Weekly performance report",
        "Important",
        "View example report details",
        "Selected applications",
        "Opt in or out of report emails",
        "Analyze your data"
      ],
      "title": "Weekly performance report ",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "2648d299a52f3e5694035bb27a16536934c8dc89",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/weekly-performance-report/",
      "published_at": "2021-07-02T09:38:23Z",
      "updated_at": "2021-03-16T07:16:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Every Monday, New Relic sends a weekly performance report via email to any of your account's users who have selected to receive this report. The email report contains summary performance metrics for the past week for a select group of your applications. The weekly performance report is different than APM's Service Level Agreement (SLA) reports. Important At this time, weekly performance reports are not available for accounts in the EU region. View example report details To see an example of a weekly performance report for your account: From the account dropdown, select User preferences. Select Weekly summaries and select See sample email. The performance report is split into sections: Section Description Featured app This provides both throughput pattern and performance metrics for the application with the highest call count in your account. Applications with linked browser monitoring will be prioritized over those that don't, even if the call count is lower. All apps report This section provides important performance metrics for the 20 applications in your account with the highest call count. Metrics in this list include uptime, Apdex, load time, and throughput. Recent events This section contains any recent alerts, deployments you have made to your app, or other events that are recorded for applications in your account. Selected applications New Relic selects the top 20 apps by call count that meet these criteria: The app must have at least 25 requests per minute (rpm) throughput. The app must include web transactions. Applications with linked browser monitoring will be prioritized over those that don't, even if the call count is lower. Opt in or out of report emails To manage your weekly performance report emails, go to one.newrelic.com, click the account dropdown, and select User preferences. Note that you opt in/out separately for every New Relic account you have access to. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.89706,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Weekly <em>performance</em> <em>report</em> ",
        "sections": "Weekly <em>performance</em> <em>report</em>",
        "tags": "<em>Other</em> <em>performance</em> <em>analysis</em>",
        "body": " than <em>APM</em>&#x27;s Service Level Agreement (SLA) <em>reports</em>. Important At this time, weekly <em>performance</em> <em>reports</em> are not available for accounts in the EU region. View example <em>report</em> details To see an example of a weekly <em>performance</em> <em>report</em> for your account: From the account dropdown, select User preferences"
      },
      "id": "603ec4e8196a67c3daa83dea"
    },
    {
      "sections": [
        "Web transactions analysis report",
        "View the Web transactions analysis report",
        "Analyze your data"
      ],
      "title": "Web transactions analysis report",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "c853c17692f878455c491e9f1a78341059f6a199",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/web-transactions-analysis-report/",
      "published_at": "2021-07-02T09:38:23Z",
      "updated_at": "2021-03-16T07:16:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM's web transactions analysis report provides comparison information for web transactions, including the amount of time spent in throughput (requests per minute or rpm), total time in the web transaction, average time to execute it, and Apdex score. You can compare the past 24 hours of data with the previous 24 hour period, 7 days ago, and averages over the last 7 days. Use this information to analyze which web transactions consume the most time, have the most number of calls, have the greatest number of standard deviations, and more. This information can help you identify where to fine-tune your app. View the Web transactions analysis report To view the web transactions analysis report for your app: Go to one.newrelic.com > APM > (select an app) > Reports > Web transactions. The default report compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over the last 7 days. Apdex entries followed by an asterisk ( * ) indicate that more than one Apdex threshold was set for the given time period. If you want to... Do this Change the amount of detail shown Select or clear the time period checkbox options, then select Apply. Limit the transactions that appear Use the Filter text box; for example, to report only on transactions that include user in the name. Change the sort order Select any column's title to sort in ascending or descending order. Select what data appears as a bar chart Select a Plotting option. View web transaction details Select the web transaction's title to go directly to the APM Transactions page. Return the original settings Select the reset link. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.89706,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Web transactions <em>analysis</em> <em>report</em>",
        "sections": "Web transactions <em>analysis</em> <em>report</em>",
        "tags": "<em>Other</em> <em>performance</em> <em>analysis</em>",
        "body": "-tune your app. View the Web transactions <em>analysis</em> <em>report</em> To view the web transactions <em>analysis</em> <em>report</em> for your app: Go to one.newrelic.com &gt; <em>APM</em> &gt; (select an app) &gt; <em>Reports</em> &gt; Web transactions. The default <em>report</em> compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over"
      },
      "id": "603ebfc7196a67aa0da83daa"
    },
    {
      "sections": [
        "Background jobs analysis report",
        "View report in UI",
        "Analyze your data"
      ],
      "title": "Background jobs analysis report",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "7402d8928cc5753497e2cfec0104d992c2cddacd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/background-jobs-analysis-report/",
      "published_at": "2021-07-02T09:35:58Z",
      "updated_at": "2021-03-16T07:15:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Background jobs analysis report helps you analyze the performance of jobs and other non-web transactions running in production that use frameworks instrumented by New Relic, such as DelayedJob and Resque. The report shows comparison information from the past 24 hours back to the past 7 days, including the amount of time spent in throughput (requests per minute or rpm), total time spent in the job, and average time to execute it. View report in UI To view the Background jobs analysis report for your app: Go to one.newrelic.com > APM > (select an app) > Reports > Background jobs. The default report compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over the last 7 days. If you want to... Do this Change the amount of detail shown Select or clear the time period checkbox options, and then select Apply. Limit the transactions that appear Use the Filter text box. Change the sort order Select any column's title to sort in ascending or descending order. Select what data appears as a bar chart Select a Plotting option. View transaction details Select the transaction's title to go directly to the APM Transactions page. Return the original settings Select the reset link. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.89693,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Background jobs <em>analysis</em> <em>report</em>",
        "sections": "Background jobs <em>analysis</em> <em>report</em>",
        "tags": "<em>Other</em> <em>performance</em> <em>analysis</em>",
        "body": "The Background jobs <em>analysis</em> <em>report</em> helps you analyze the <em>performance</em> of jobs and <em>other</em> non-web transactions running in production that use frameworks instrumented by New Relic, such as DelayedJob and Resque. The <em>report</em> shows comparison information from the past 24 hours back to the past 7 days"
      },
      "id": "603ebf8964441f0c044e885b"
    }
  ],
  "/docs/apm/reports/other-performance-analysis/web-transactions-analysis-report": [
    {
      "sections": [
        "Weekly performance report",
        "Important",
        "View example report details",
        "Selected applications",
        "Opt in or out of report emails",
        "Analyze your data"
      ],
      "title": "Weekly performance report ",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "2648d299a52f3e5694035bb27a16536934c8dc89",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/weekly-performance-report/",
      "published_at": "2021-07-02T09:38:23Z",
      "updated_at": "2021-03-16T07:16:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Every Monday, New Relic sends a weekly performance report via email to any of your account's users who have selected to receive this report. The email report contains summary performance metrics for the past week for a select group of your applications. The weekly performance report is different than APM's Service Level Agreement (SLA) reports. Important At this time, weekly performance reports are not available for accounts in the EU region. View example report details To see an example of a weekly performance report for your account: From the account dropdown, select User preferences. Select Weekly summaries and select See sample email. The performance report is split into sections: Section Description Featured app This provides both throughput pattern and performance metrics for the application with the highest call count in your account. Applications with linked browser monitoring will be prioritized over those that don't, even if the call count is lower. All apps report This section provides important performance metrics for the 20 applications in your account with the highest call count. Metrics in this list include uptime, Apdex, load time, and throughput. Recent events This section contains any recent alerts, deployments you have made to your app, or other events that are recorded for applications in your account. Selected applications New Relic selects the top 20 apps by call count that meet these criteria: The app must have at least 25 requests per minute (rpm) throughput. The app must include web transactions. Applications with linked browser monitoring will be prioritized over those that don't, even if the call count is lower. Opt in or out of report emails To manage your weekly performance report emails, go to one.newrelic.com, click the account dropdown, and select User preferences. Note that you opt in/out separately for every New Relic account you have access to. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.89706,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Weekly <em>performance</em> <em>report</em> ",
        "sections": "Weekly <em>performance</em> <em>report</em>",
        "tags": "<em>Other</em> <em>performance</em> <em>analysis</em>",
        "body": " than <em>APM</em>&#x27;s Service Level Agreement (SLA) <em>reports</em>. Important At this time, weekly <em>performance</em> <em>reports</em> are not available for accounts in the EU region. View example <em>report</em> details To see an example of a weekly <em>performance</em> <em>report</em> for your account: From the account dropdown, select User preferences"
      },
      "id": "603ec4e8196a67c3daa83dea"
    },
    {
      "sections": [
        "Background jobs analysis report",
        "View report in UI",
        "Analyze your data"
      ],
      "title": "Background jobs analysis report",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "7402d8928cc5753497e2cfec0104d992c2cddacd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/background-jobs-analysis-report/",
      "published_at": "2021-07-02T09:35:58Z",
      "updated_at": "2021-03-16T07:15:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Background jobs analysis report helps you analyze the performance of jobs and other non-web transactions running in production that use frameworks instrumented by New Relic, such as DelayedJob and Resque. The report shows comparison information from the past 24 hours back to the past 7 days, including the amount of time spent in throughput (requests per minute or rpm), total time spent in the job, and average time to execute it. View report in UI To view the Background jobs analysis report for your app: Go to one.newrelic.com > APM > (select an app) > Reports > Background jobs. The default report compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over the last 7 days. If you want to... Do this Change the amount of detail shown Select or clear the time period checkbox options, and then select Apply. Limit the transactions that appear Use the Filter text box. Change the sort order Select any column's title to sort in ascending or descending order. Select what data appears as a bar chart Select a Plotting option. View transaction details Select the transaction's title to go directly to the APM Transactions page. Return the original settings Select the reset link. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.89693,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Background jobs <em>analysis</em> <em>report</em>",
        "sections": "Background jobs <em>analysis</em> <em>report</em>",
        "tags": "<em>Other</em> <em>performance</em> <em>analysis</em>",
        "body": "The Background jobs <em>analysis</em> <em>report</em> helps you analyze the <em>performance</em> of jobs and <em>other</em> non-web transactions running in production that use frameworks instrumented by New Relic, such as DelayedJob and Resque. The <em>report</em> shows comparison information from the past 24 hours back to the past 7 days"
      },
      "id": "603ebf8964441f0c044e885b"
    },
    {
      "sections": [
        "Database analysis report",
        "View the database analysis report",
        "Analyze your data"
      ],
      "title": "Database analysis report",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "2627a588c2c730695f87d497407630fbd525ed16",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/database-analysis-report/",
      "published_at": "2021-07-02T09:37:25Z",
      "updated_at": "2021-03-16T07:15:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM's database analysis report allows you to analyze your application's performance from the database viewpoint, from the past 24 hours back to the past seven days. It shows comparison information for transactions, including the amount of time spent in throughput (operation requests per minute or rpm), total time spent in the operation, and average time to execute it. View the database analysis report To view the database analysis report for your app: Go to one.newrelic.com > APM > (select an app) > Reports > Database. The default report compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over the last 7 days. If you want to... Do this Change the amount of detail shown Select or clear the time period checkbox options, then select Apply. Limit the transactions that appear Type the value in the Filter text box; for example, to show only transactions for Model operations that contain the value User. Change the sort order Select any column's title to sort in ascending or descending order. Select what data appears as a bar chart Select a Plotting option. View transaction details Select the transaction's title to go directly to APM's Database and slow queries page. Return the original settings Select the reset link. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.89693,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Database <em>analysis</em> <em>report</em>",
        "sections": "Database <em>analysis</em> <em>report</em>",
        "tags": "<em>Other</em> <em>performance</em> <em>analysis</em>",
        "body": "<em>APM</em>&#x27;s database <em>analysis</em> <em>report</em> allows you to analyze your application&#x27;s <em>performance</em> from the database viewpoint, from the past 24 hours back to the past seven days. It shows comparison information for transactions, including the amount of time spent in throughput (operation requests per minute"
      },
      "id": "603ebf8964441fd4df4e887a"
    }
  ],
  "/docs/apm/reports/other-performance-analysis/weekly-performance-report": [
    {
      "sections": [
        "Web transactions analysis report",
        "View the Web transactions analysis report",
        "Analyze your data"
      ],
      "title": "Web transactions analysis report",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "c853c17692f878455c491e9f1a78341059f6a199",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/web-transactions-analysis-report/",
      "published_at": "2021-07-02T09:38:23Z",
      "updated_at": "2021-03-16T07:16:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM's web transactions analysis report provides comparison information for web transactions, including the amount of time spent in throughput (requests per minute or rpm), total time in the web transaction, average time to execute it, and Apdex score. You can compare the past 24 hours of data with the previous 24 hour period, 7 days ago, and averages over the last 7 days. Use this information to analyze which web transactions consume the most time, have the most number of calls, have the greatest number of standard deviations, and more. This information can help you identify where to fine-tune your app. View the Web transactions analysis report To view the web transactions analysis report for your app: Go to one.newrelic.com > APM > (select an app) > Reports > Web transactions. The default report compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over the last 7 days. Apdex entries followed by an asterisk ( * ) indicate that more than one Apdex threshold was set for the given time period. If you want to... Do this Change the amount of detail shown Select or clear the time period checkbox options, then select Apply. Limit the transactions that appear Use the Filter text box; for example, to report only on transactions that include user in the name. Change the sort order Select any column's title to sort in ascending or descending order. Select what data appears as a bar chart Select a Plotting option. View web transaction details Select the web transaction's title to go directly to the APM Transactions page. Return the original settings Select the reset link. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.89706,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Web transactions <em>analysis</em> <em>report</em>",
        "sections": "Web transactions <em>analysis</em> <em>report</em>",
        "tags": "<em>Other</em> <em>performance</em> <em>analysis</em>",
        "body": "-tune your app. View the Web transactions <em>analysis</em> <em>report</em> To view the web transactions <em>analysis</em> <em>report</em> for your app: Go to one.newrelic.com &gt; <em>APM</em> &gt; (select an app) &gt; <em>Reports</em> &gt; Web transactions. The default <em>report</em> compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over"
      },
      "id": "603ebfc7196a67aa0da83daa"
    },
    {
      "sections": [
        "Background jobs analysis report",
        "View report in UI",
        "Analyze your data"
      ],
      "title": "Background jobs analysis report",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "7402d8928cc5753497e2cfec0104d992c2cddacd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/background-jobs-analysis-report/",
      "published_at": "2021-07-02T09:35:58Z",
      "updated_at": "2021-03-16T07:15:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Background jobs analysis report helps you analyze the performance of jobs and other non-web transactions running in production that use frameworks instrumented by New Relic, such as DelayedJob and Resque. The report shows comparison information from the past 24 hours back to the past 7 days, including the amount of time spent in throughput (requests per minute or rpm), total time spent in the job, and average time to execute it. View report in UI To view the Background jobs analysis report for your app: Go to one.newrelic.com > APM > (select an app) > Reports > Background jobs. The default report compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over the last 7 days. If you want to... Do this Change the amount of detail shown Select or clear the time period checkbox options, and then select Apply. Limit the transactions that appear Use the Filter text box. Change the sort order Select any column's title to sort in ascending or descending order. Select what data appears as a bar chart Select a Plotting option. View transaction details Select the transaction's title to go directly to the APM Transactions page. Return the original settings Select the reset link. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.89693,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Background jobs <em>analysis</em> <em>report</em>",
        "sections": "Background jobs <em>analysis</em> <em>report</em>",
        "tags": "<em>Other</em> <em>performance</em> <em>analysis</em>",
        "body": "The Background jobs <em>analysis</em> <em>report</em> helps you analyze the <em>performance</em> of jobs and <em>other</em> non-web transactions running in production that use frameworks instrumented by New Relic, such as DelayedJob and Resque. The <em>report</em> shows comparison information from the past 24 hours back to the past 7 days"
      },
      "id": "603ebf8964441f0c044e885b"
    },
    {
      "sections": [
        "Database analysis report",
        "View the database analysis report",
        "Analyze your data"
      ],
      "title": "Database analysis report",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "2627a588c2c730695f87d497407630fbd525ed16",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/database-analysis-report/",
      "published_at": "2021-07-02T09:37:25Z",
      "updated_at": "2021-03-16T07:15:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM's database analysis report allows you to analyze your application's performance from the database viewpoint, from the past 24 hours back to the past seven days. It shows comparison information for transactions, including the amount of time spent in throughput (operation requests per minute or rpm), total time spent in the operation, and average time to execute it. View the database analysis report To view the database analysis report for your app: Go to one.newrelic.com > APM > (select an app) > Reports > Database. The default report compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over the last 7 days. If you want to... Do this Change the amount of detail shown Select or clear the time period checkbox options, then select Apply. Limit the transactions that appear Type the value in the Filter text box; for example, to show only transactions for Model operations that contain the value User. Change the sort order Select any column's title to sort in ascending or descending order. Select what data appears as a bar chart Select a Plotting option. View transaction details Select the transaction's title to go directly to APM's Database and slow queries page. Return the original settings Select the reset link. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 222.89693,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Database <em>analysis</em> <em>report</em>",
        "sections": "Database <em>analysis</em> <em>report</em>",
        "tags": "<em>Other</em> <em>performance</em> <em>analysis</em>",
        "body": "<em>APM</em>&#x27;s database <em>analysis</em> <em>report</em> allows you to analyze your application&#x27;s <em>performance</em> from the database viewpoint, from the past 24 hours back to the past seven days. It shows comparison information for transactions, including the amount of time spent in throughput (operation requests per minute"
      },
      "id": "603ebf8964441fd4df4e887a"
    }
  ],
  "/docs/apm/reports/service-level-agreements/api-examples-sla-reports": [
    {
      "sections": [
        "APM SLA reports",
        "View SLA reports",
        "View metric trends",
        "Analyze your data"
      ],
      "title": "APM SLA reports",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Service level agreements"
      ],
      "external_id": "f66a2ccdfd774a7befcd9df4bd8a9d7f633e234c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/service-level-agreements/apm-sla-reports/",
      "published_at": "2021-07-02T09:39:46Z",
      "updated_at": "2021-03-16T08:21:11Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM provides service level agreement (SLA) reports. SLA reports help you better understand your application performance by showing application downtime and trends over time. SLA reports for an application only include web transactions. If your application creates only non-web transactions, New Relic does not produce SLA reports for that app. SLA reports can be viewed in APM or downloaded as comma-separated value (.csv) files. Depending on your account level's data retention policy, you can view daily, weekly, or monthly reports. View SLA reports To view the SLA reports for your app: Go to one.newrelic.com > Applications > (select an app) > Reports > SLA. The report defaults to the Weekly SLA report tab. SLA report data shows the account owner's time zone, with periods beginning and ending at midnight in that time zone. If you have not enabled browser for your app, the SLA report shows links to requests, response time, and Apdex only for your application server. If you want to... Do this Show or hide details Select the End user tier (if available) or Application server heading. View another time period Select the tab for daily, weekly, or monthly SLA reports if available. Save or export the report Select Download this report as .csv to create a report file with comma-separated values. View metric trends To drill down into detailed information, select the link. This includes: End users (from browser): Page views, load time, and Apdex Application server (from APM agents, such as Java or Ruby): Requests, response time, and Apdex The metric detail window below the report list shows trends over the selected period (12 days, weeks, or months). Use any of New Relic's available standard page functions to drill down into detailed information. In addition: To view other details, select its link. To clear the details and return to the main SLA report, select the tab. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 230.8347,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>APM</em> SLA <em>reports</em>",
        "sections": "<em>APM</em> SLA <em>reports</em>",
        "tags": "<em>Service</em> <em>level</em> <em>agreements</em>",
        "body": "<em>APM</em> provides <em>service</em> <em>level</em> <em>agreement</em> (SLA) <em>reports</em>. SLA <em>reports</em> help you better understand your application performance by showing application downtime and trends over time. SLA <em>reports</em> for an application only include web transactions. If your application creates only non-web transactions, New"
      },
      "id": "603ebe4d196a679981a83dc0"
    },
    {
      "sections": [
        "Weekly performance report",
        "Important",
        "View example report details",
        "Selected applications",
        "Opt in or out of report emails",
        "Analyze your data"
      ],
      "title": "Weekly performance report ",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "2648d299a52f3e5694035bb27a16536934c8dc89",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/weekly-performance-report/",
      "published_at": "2021-07-02T09:38:23Z",
      "updated_at": "2021-03-16T07:16:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Every Monday, New Relic sends a weekly performance report via email to any of your account's users who have selected to receive this report. The email report contains summary performance metrics for the past week for a select group of your applications. The weekly performance report is different than APM's Service Level Agreement (SLA) reports. Important At this time, weekly performance reports are not available for accounts in the EU region. View example report details To see an example of a weekly performance report for your account: From the account dropdown, select User preferences. Select Weekly summaries and select See sample email. The performance report is split into sections: Section Description Featured app This provides both throughput pattern and performance metrics for the application with the highest call count in your account. Applications with linked browser monitoring will be prioritized over those that don't, even if the call count is lower. All apps report This section provides important performance metrics for the 20 applications in your account with the highest call count. Metrics in this list include uptime, Apdex, load time, and throughput. Recent events This section contains any recent alerts, deployments you have made to your app, or other events that are recorded for applications in your account. Selected applications New Relic selects the top 20 apps by call count that meet these criteria: The app must have at least 25 requests per minute (rpm) throughput. The app must include web transactions. Applications with linked browser monitoring will be prioritized over those that don't, even if the call count is lower. Opt in or out of report emails To manage your weekly performance report emails, go to one.newrelic.com, click the account dropdown, and select User preferences. Note that you opt in/out separately for every New Relic account you have access to. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 80.04202,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Weekly performance <em>report</em> ",
        "sections": "Weekly performance <em>report</em>",
        "tags": "<em>Reports</em>",
        "body": " than <em>APM</em>&#x27;s <em>Service</em> <em>Level</em> <em>Agreement</em> (SLA) <em>reports</em>. Important At this time, weekly performance <em>reports</em> are not available for accounts in the EU region. View example <em>report</em> details To see an example of a weekly performance <em>report</em> for your account: From the account dropdown, select User preferences"
      },
      "id": "603ec4e8196a67c3daa83dea"
    },
    {
      "sections": [
        "Web transactions analysis report",
        "View the Web transactions analysis report",
        "Analyze your data"
      ],
      "title": "Web transactions analysis report",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "c853c17692f878455c491e9f1a78341059f6a199",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/web-transactions-analysis-report/",
      "published_at": "2021-07-02T09:38:23Z",
      "updated_at": "2021-03-16T07:16:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM's web transactions analysis report provides comparison information for web transactions, including the amount of time spent in throughput (requests per minute or rpm), total time in the web transaction, average time to execute it, and Apdex score. You can compare the past 24 hours of data with the previous 24 hour period, 7 days ago, and averages over the last 7 days. Use this information to analyze which web transactions consume the most time, have the most number of calls, have the greatest number of standard deviations, and more. This information can help you identify where to fine-tune your app. View the Web transactions analysis report To view the web transactions analysis report for your app: Go to one.newrelic.com > APM > (select an app) > Reports > Web transactions. The default report compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over the last 7 days. Apdex entries followed by an asterisk ( * ) indicate that more than one Apdex threshold was set for the given time period. If you want to... Do this Change the amount of detail shown Select or clear the time period checkbox options, then select Apply. Limit the transactions that appear Use the Filter text box; for example, to report only on transactions that include user in the name. Change the sort order Select any column's title to sort in ascending or descending order. Select what data appears as a bar chart Select a Plotting option. View web transaction details Select the web transaction's title to go directly to the APM Transactions page. Return the original settings Select the reset link. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 80.04202,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Web transactions analysis <em>report</em>",
        "sections": "Web transactions analysis <em>report</em>",
        "tags": "<em>Reports</em>",
        "body": "-tune your app. View the Web transactions analysis <em>report</em> To view the web transactions analysis <em>report</em> for your app: Go to one.newrelic.com &gt; <em>APM</em> &gt; (select an app) &gt; <em>Reports</em> &gt; Web transactions. The default <em>report</em> compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over"
      },
      "id": "603ebfc7196a67aa0da83daa"
    }
  ],
  "/docs/apm/reports/service-level-agreements/apm-sla-reports": [
    {
      "sections": [
        "API examples for SLA reports",
        "Tip",
        "Browser metrics for SLAs",
        "App server metrics for SLAs",
        "Tips for collecting metrics",
        "Examples",
        "REST API v2 commands",
        "Browser load time and page view count (v2)",
        "App response time and request count (v2)",
        "Apdex SLA data (v2)",
        "REST API v1 commands (deprecated)",
        "Browser load time and page view count (v1)",
        "App response time and request count (v1)",
        "Apdex SLA data (v1)",
        "Analyze your data"
      ],
      "title": "API examples for SLA reports",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Service level agreements"
      ],
      "external_id": "3b4dafc002932fc100b6375a3ae87b01350d57fc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/service-level-agreements/api-examples-sla-reports/",
      "published_at": "2021-07-02T09:39:46Z",
      "updated_at": "2021-03-16T07:16:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic stores SLA data forever for eligible accounts, so you can use the New Relic REST API to generate service level agreement reports over any time period. For example, you can create SLA reports going back more than 12 days, weeks, or months. Tip Access to this feature depends on your subscription level. Browser metrics for SLAs Browser metrics for the End user tier are available only if you have enabled New Relic Browser. Browser (End user tier) SLA metric name:value (and formula) Page Views thousands EndUser : call_count Load time sec EndUser : average_response_time Apdex EndUser/Apdex : score % Satisfied EndUser/Apdex : s divided by EndUser : call_count % Tolerating EndUser/Apdex : t divided by Enduser : call_count % Frustrated EndUser/Apdex : f divided by Enduser : call_count App server metrics for SLAs Here are the SLA metrics for application servers. App server SLA metric name:value (and formula) Requests millions HttpDispatcher : call_count (scaled appropriately) Resp. time ms HttpDispatcher : average_response_time (multiplied by 1000) Apdex Apdex : score % Satisfied Apdex : s divided by Apdex : count % Tolerating Apdex : t divided by Apdex : count % Frustrated Apdex : f divided by Apdex : count Tips for collecting metrics Here are some tips for planning which metrics to collect. SLA tips Comments Requirements When using the cURL command examples, be sure to replace the placeholder text with your account ID, an API key, and the application ID. Time ranges You are not limited to standard day, week, or month time ranges. For example, you can extract metric data for a \"holiday weekend\" from 12/23 to 12/26 or \"the 20 minutes after our site had problems\" or whatever other period interests you. UTC XML time format You must specify the time in UTC XML format, so be sure to adjust for your time zone compared to UTC. For example, New Relic starts at 16:00:00 on the day before the selected data, since New Relic headquarters are in UTC-8. Summary reports When requesting metrics to use with summary reports, include the query string parameter summarize=true (v2) or summary=1 (v1) as shown in the examples. Scaled statistics Your report has some statistics that are scaled in the SLA reports in New Relic's user interface. New Relic changes the scale of page views in your report to show small numbers. Depending on your traffic, typically it might be displayed in thousands, millions, or billions. Recommendation: To avoid a string of zeroes, divide this number appropriately for your own purposes. End user statistics End user statistics will reflect only the calls in which New Relic Browser data was gathered. For example, end user stats may not appear in situations such as: Browsers types Clients (they might have disabled the JavaScript agent, or blocked traffic to New Relic sites for JavaScript code's location Transactions not in one of those categories, in case the page load did not complete for any reason This is why there are fewer (sometimes many fewer) page views in the End User (Browser) data section than in the App server data section. Examples The following sections contain code examples to acquire the data for values described above for the Daily (24hr) SLA statistics in the default GMT/UTC time zone. Adjust the from= and to= for your time range as desired. There are syntactical differences between New Relic's REST API v2 and v1. The examples show how to use each. REST API v2 commands Browser load time and page view count (v2) To obtain the Browser (EndUser/RUM) load time and page view count for v2, from the command line, type: curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.xml\"\\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=EndUser&values[]=call_count&values[]=average_response_time&from=2014-06-09T00:00:00+00:00&to=2014-06-09T23:00:00+00:00&summarize=true' Copy In Ruby: require 'rubygems' require 'curb' response = Curl::Easy.http_get(\"https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.xml?names[]=EndUser&values[]=call_count&values[]=average_response_time&from=2012-01-01T00:00:00+00:00&to=2012-01-08T00:00:00+00:00&summarize=true\") do |curl| curl.headers[\"api-key\"] = \"$API_KEY\" curl.header_in_body=true end puts response.body_str Copy App response time and request count (v2) To obtain the Application response time and request count for v2, from the command line, type: curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.xml\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=HttpDispatcher&values[]=average_response_time&values[]=call_count&from=2014-06-09T00:00:00+00:00&to=2014-06-09T23:00:00+00:00&summarize=true' Copy In Ruby: require 'rubygems' require 'curb' response = Curl::Easy.http_get(\"https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.xml?names[]=HttpDispatcher&values[]=average_response_time&values[]=call_count&from=2012-01-01T00:00:00+00:00&to=2012-01-08T00:00:00+00:00&summarize=true\") do |curl| curl.headers[\"api-key\"] = \"$API_KEY\" curl.header_in_body=true end puts response.body_str Copy Apdex SLA data (v2) To obtain the Apdex related data for v2, from the command line, type: curl -X GET \"https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.xml\" \\ -H \"Api-Key:$API_KEY\" -i \\ -d 'names[]=Apdex&names[]=EndUser/Apdex&from=2014-06-09T00:00:00+00:00&to=2014-06-09T23:00:00+00:00&summarize=true' Copy In Ruby: require 'rubygems' require 'curb' response = Curl::Easy.http_get(\"https://api.newrelic.com/v2/applications/$APP_ID/metrics/data.xml?names[]=EndUser/Apdex&from=2012-01-01T00:00:00+00:00&to=2012-01-08T00:00:00+00:00&summarize=true\") do |curl| curl.headers[\"api-key\"] = \"$API_KEY\" curl.header_in_body=true end puts response.body_str Copy REST API v1 commands (deprecated) REST API v1 is deprecated. Browser load time and page view count (v1) To obtain the Browser (EndUser/RUM) load time and page view count for v1, from the command line, type: curl -gH \"api-key:$API_KEY\" \"https://api.newrelic.com/api/v1/accounts/$ACCOUNT_ID/applications/$APP_ID/data.xml?metrics[]=EndUser&field=call_count&field=average_response_time&summary=1&begin=2012-01-01T00:00:00Z&end=2012-01-08T00:00:00Z\" Copy In Ruby: require 'rubygems' require 'curb' response = Curl::Easy.perform(\"https://api.newrelic.com/api/v1/accounts/$ACCOUNT_ID/applications/$APP_ID/data.xml?metrics[]=EndUser&field=call_count&field=average_response_time&summary=1&begin=2012-01-01T00:00:00Z&end=2012-01-08T00:00:00Z\") do |curl| curl.headers[\"api-key\"] = \"$API_KEY\" end puts response.body_str Copy App response time and request count (v1) To obtain the Application response time and request count for v1, from the command line, type: curl -gH \"api-key:$API_KEY\" \"https://api.newrelic.com/api/v1/accounts/$ACCOUNT_ID/applications/$APP_ID/data.xml?metrics[]=HttpDispatcher&field=average_response_time&field=call_count&summary=1&begin=2012-01-01T00:00:00Z&end=2012-01-08T00:00:00Z\" Copy In Ruby: require 'rubygems' require 'curb' response = Curl::Easy.perform(\"https://api.newrelic.com/api/v1/accounts/$ACCOUNT_ID/applications/$APP_ID/data.xml?metrics[]=HttpDispatcher&field=average_response_time&field=call_count&summary=1&begin=2012-01-01T00:00:00Z&end=2012-01-08T00:00:00Z\") do |curl| curl.headers[\"api-key\"] = \"$API_KEY\" end puts response.body_str Copy Apdex SLA data (v1) To obtain the Apdex related data for v1, from the command line, type: curl -gH \"api-key:$API_KEY\" \"https://api.newrelic.com/api/v1/accounts/$ACCOUNT_ID/applications/$APP_ID/data.xml?metrics[]=Apdex&metrics[]=EndUser/Apdex&summary=1&begin=2012-01-01T00:00:00Z&end=2012-01-08T00:00:00Z\" Copy In Ruby: require 'rubygems' require 'curb' response = Curl::Easy.perform(\"https://api.newrelic.com/api/v1/accounts/$ACCOUNT_ID/applications/$APP_ID/data.xml?metrics[]=Apdex&metrics[]=EndUser/Apdex&summary=1&begin=2012-01-01T00:00:00Z&end=2012-01-08T00:00:00Z\") do |curl| curl.headers[\"api-key\"] = \"$API_KEY\" end puts response.body_str Copy Analyze your data New Relic APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use New Relic Insights.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 230.82727,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "API examples for SLA <em>reports</em>",
        "sections": "API examples for SLA <em>reports</em>",
        "tags": "<em>Service</em> <em>level</em> <em>agreements</em>",
        "body": "New Relic stores SLA data forever for eligible accounts, so you can use the New Relic REST API to generate <em>service</em> <em>level</em> <em>agreement</em> <em>reports</em> over any time period. For example, you can create SLA <em>reports</em> going back more than 12 days, weeks, or months. Tip Access to this feature depends on your"
      },
      "id": "603ebe82196a67631fa83dd7"
    },
    {
      "sections": [
        "Weekly performance report",
        "Important",
        "View example report details",
        "Selected applications",
        "Opt in or out of report emails",
        "Analyze your data"
      ],
      "title": "Weekly performance report ",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "2648d299a52f3e5694035bb27a16536934c8dc89",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/weekly-performance-report/",
      "published_at": "2021-07-02T09:38:23Z",
      "updated_at": "2021-03-16T07:16:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Every Monday, New Relic sends a weekly performance report via email to any of your account's users who have selected to receive this report. The email report contains summary performance metrics for the past week for a select group of your applications. The weekly performance report is different than APM's Service Level Agreement (SLA) reports. Important At this time, weekly performance reports are not available for accounts in the EU region. View example report details To see an example of a weekly performance report for your account: From the account dropdown, select User preferences. Select Weekly summaries and select See sample email. The performance report is split into sections: Section Description Featured app This provides both throughput pattern and performance metrics for the application with the highest call count in your account. Applications with linked browser monitoring will be prioritized over those that don't, even if the call count is lower. All apps report This section provides important performance metrics for the 20 applications in your account with the highest call count. Metrics in this list include uptime, Apdex, load time, and throughput. Recent events This section contains any recent alerts, deployments you have made to your app, or other events that are recorded for applications in your account. Selected applications New Relic selects the top 20 apps by call count that meet these criteria: The app must have at least 25 requests per minute (rpm) throughput. The app must include web transactions. Applications with linked browser monitoring will be prioritized over those that don't, even if the call count is lower. Opt in or out of report emails To manage your weekly performance report emails, go to one.newrelic.com, click the account dropdown, and select User preferences. Note that you opt in/out separately for every New Relic account you have access to. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 80.04202,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Weekly performance <em>report</em> ",
        "sections": "Weekly performance <em>report</em>",
        "tags": "<em>Reports</em>",
        "body": " than <em>APM</em>&#x27;s <em>Service</em> <em>Level</em> <em>Agreement</em> (SLA) <em>reports</em>. Important At this time, weekly performance <em>reports</em> are not available for accounts in the EU region. View example <em>report</em> details To see an example of a weekly performance <em>report</em> for your account: From the account dropdown, select User preferences"
      },
      "id": "603ec4e8196a67c3daa83dea"
    },
    {
      "sections": [
        "Web transactions analysis report",
        "View the Web transactions analysis report",
        "Analyze your data"
      ],
      "title": "Web transactions analysis report",
      "type": "docs",
      "tags": [
        "APM",
        "Reports",
        "Other performance analysis"
      ],
      "external_id": "c853c17692f878455c491e9f1a78341059f6a199",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/reports/other-performance-analysis/web-transactions-analysis-report/",
      "published_at": "2021-07-02T09:38:23Z",
      "updated_at": "2021-03-16T07:16:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM's web transactions analysis report provides comparison information for web transactions, including the amount of time spent in throughput (requests per minute or rpm), total time in the web transaction, average time to execute it, and Apdex score. You can compare the past 24 hours of data with the previous 24 hour period, 7 days ago, and averages over the last 7 days. Use this information to analyze which web transactions consume the most time, have the most number of calls, have the greatest number of standard deviations, and more. This information can help you identify where to fine-tune your app. View the Web transactions analysis report To view the web transactions analysis report for your app: Go to one.newrelic.com > APM > (select an app) > Reports > Web transactions. The default report compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over the last 7 days. Apdex entries followed by an asterisk ( * ) indicate that more than one Apdex threshold was set for the given time period. If you want to... Do this Change the amount of detail shown Select or clear the time period checkbox options, then select Apply. Limit the transactions that appear Use the Filter text box; for example, to report only on transactions that include user in the name. Change the sort order Select any column's title to sort in ascending or descending order. Select what data appears as a bar chart Select a Plotting option. View web transaction details Select the web transaction's title to go directly to the APM Transactions page. Return the original settings Select the reset link. Analyze your data APM includes several reports in the user interface. To gather, analyze, and visualize data about your software in other formats, use query builder.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 80.04202,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Web transactions analysis <em>report</em>",
        "sections": "Web transactions analysis <em>report</em>",
        "tags": "<em>Reports</em>",
        "body": "-tune your app. View the Web transactions analysis <em>report</em> To view the web transactions analysis <em>report</em> for your app: Go to one.newrelic.com &gt; <em>APM</em> &gt; (select an app) &gt; <em>Reports</em> &gt; Web transactions. The default <em>report</em> compares the last 24 hours with the previous 24-hour period, 7 days ago, and averages over"
      },
      "id": "603ebfc7196a67aa0da83daa"
    }
  ],
  "/docs/apm/transactions/cross-application-traces/introduction-cross-application-traces": [
    {
      "sections": [
        "Troubleshoot cross application tracing",
        "Agent versions and protocols",
        "Config file requirements",
        "High throughput apps",
        "Proxies",
        "Multi-threaded processing (Java)",
        "Sub-accounts"
      ],
      "title": "Troubleshoot cross application tracing",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Cross application traces"
      ],
      "external_id": "fa4ecccd4906018947e6e36fbe96b78d6c005893",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/cross-application-traces/troubleshoot-cross-application-tracing/",
      "published_at": "2021-07-02T09:39:46Z",
      "updated_at": "2021-03-16T08:22:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Here are troubleshooting tips when using cross application traces. This is not the same as using New Relic's distributed tracing feature. Agent versions and protocols Make sure you meet these requirements for your agent's version, protocols, interfaces, or message queue libraries. If you are using a protocol that is not listed here, you will not see a connection between your applications. Agent version Notes C SDK Use distributed tracing. Go 1.11 or higher HTTP, HTTPS Java 3.9.0 or higher HTTP, HTTPs, JMS 1.1, RabbitMQ The Java agent also supports several message queue libraries, including those that use the JMS 1.1 interface. .NET 4.2 or higher HTTP, and supported .NET messaging systems Node.js 2.0.0 or higher HTTP, HTTPS, RabbitMQ PHP 4.19.0 or higher HTTP, HTTPS, and supported PHP message queuing systems Python 2.38.0.31 or higher HTTP, HTTPS, and supported Python message queuing systems Ruby 4.3.0 or higher HTTP, HTTPS, RabbitMQ Config file requirements In general, New Relic's cross application tracing feature is enabled by default. Requirements to change your configuration file vary, depending on your New Relic agent: C SDK (not supported) Go (not supported) Java .NET Node.js (no specific config file settings needed for Node.js) PHP Python Ruby High throughput apps Cross application traces rely on transaction events to associate related transactions. If you have a high throughput application, your agent may reach the maximum number of events that it can record in a minute and will fall back to sampling events. If a transactionâ€™s events are sampled, you may see an incomplete cross application trace, including sometimes only the transactions that you are focused on. If your application has high throughput, some cross application traces will appear incomplete, sometimes with no links. Try viewing a different transaction trace. To reduce or eliminate sampling, you can also adjust the number of transaction events stored in your agent configuration. High throughput apps Troubleshooting tips Java From the transaction_events stanza, adjust the setting for max_samples_stored. Ruby Adjust the setting for analytics_events.max_samples_stored. Proxies If you expect to see a cross application trace link but it consistently does not appear, there may be a proxy or broker between your applicationâ€™s communication. Cross application tracing relies on HTTP headers and JMS properties being passed from one application to other. HTTP proxies and message brokers sometimes strip those headers. Multi-threaded processing (Java) If one or more of your Java applications uses an async or \"reactive\" programming model, a transaction's activity may span across multiple threads. New Relic supports the Play framework and Servlet Async but not all async frameworks. For unsupported frameworks, activity on other threads is not reported as part of the transaction. Calls to other applications will not be traced. Sub-accounts Currently cross application traces do not cross New Relic accounts. If you have multiple New Relic accounts (including sub-accounts), you will only see traces for applications within one account.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.08794,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshoot <em>cross</em> <em>application</em> <em>tracing</em>",
        "sections": "Troubleshoot <em>cross</em> <em>application</em> <em>tracing</em>",
        "tags": "<em>Cross</em> <em>application</em> <em>traces</em>",
        "body": " in a minute and will fall back to sampling events. If a <em>transactionâ€™s</em> events are sampled, you may see an incomplete <em>cross</em> <em>application</em> <em>trace</em>, including sometimes only the <em>transactions</em> that you are focused on. If your <em>application</em> has high throughput, some <em>cross</em> <em>application</em> <em>traces</em> will appear incomplete"
      },
      "id": "603ec3cfe7b9d22f912a07af"
    },
    {
      "sections": [
        "Transactions in New Relic APM",
        "What is a transaction?",
        "Types of transactions",
        "Transaction segments",
        "Transaction naming",
        "Monitoring transactions",
        "Tip",
        "Query transactions"
      ],
      "title": "Transactions in New Relic APM",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Intro to transactions"
      ],
      "external_id": "2a96f455cbf6dfdc5dda2363ba4e69b6f9dba159",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/intro-transactions/transactions-new-relic-apm/",
      "published_at": "2021-07-02T09:42:04Z",
      "updated_at": "2021-03-30T08:07:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The word transaction can have several different meanings in the software industry. This document explains how the term is used by New Relic and how transactions are reported. What is a transaction? At New Relic, a transaction is defined as one logical unit of work in a software application. Specifically, it refers to the function calls and method calls that make up that unit of work. For APM, it will often refer to a web transaction, which represents activity that happens from when the application receives a web request to when the response is sent. When you install APM in a supported system, it begins automatically reporting web requests and other important functions and methods. To supplement the default level of monitoring, you can set up custom instrumentation to report additional transactions. Some frameworks do not have a natural concept of a transaction. In other words, there are no predefined pathways that can easily be recognized or monitored as transactions. To define transactions in such frameworks, you can use custom instrumentation. Types of transactions Cumulative transaction data appears in APM on the Transactions page. The two main categories of transactions are web and non-web: Web: Transactions are initiated with an HTTP request. For most organizations, these represent customer-centric interactions and thus are the most important transactions to monitor. Non-web: Non-web transactions are not initiated with a web request. They can include non-web worker processes, background processes, scripts, message queue activity, and other tasks. Transaction segments The individual functions and calls that make up a transaction are called segments. For example external service calls and database calls are segments, and both have their own UI pages in APM. The APM Transactions page displays aggregate transaction segment data. To add segments to a transaction, use custom instrumentation. To see the segments of a specific transaction, use transaction traces. Transaction naming For supported frameworks, transaction names can come from various sources, such as the name given to the transaction by the framework, function names detected during the transaction, or a web request's URL. For transactions that produce many names with a similar format, we consolidate those into general transaction categories. For example, a transaction might be displayed as /user/*/control_panel, where the * represents different user names. To rename transactions or adjust how names are consolidated, use custom instrumentation. Monitoring transactions Here are some other ways you can use APM to monitor transactions: If you want to monitor... Use this... Transactions important to your business Create key transactions, which emphasizes them in the UI and lets you set a custom level of monitoring for them. Async activity Follow the procedures to set up asynchronous activity for your specific APM language agent. Activity across applications Linking transactions across applications gives you more detail about business-relevant application activity. For more information, see the documentation about distributed tracing and cross application traces. Tip To get a high-level overview of all your applications and services, use the New Relic Explorer. Query transactions Transactions are available for querying with an in-depth set of default attributes attached. Using these attributes, you can run queries and create custom charts that APM does not provide by default. For information on how to query your data using our UI or NRQL, see Query New Relic data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.43948,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Transactions</em> in New Relic <em>APM</em>",
        "sections": "<em>Transactions</em> in New Relic <em>APM</em>",
        "tags": "<em>Transactions</em>",
        "body": " applications gives you more detail about business-relevant <em>application</em> activity. For more information, see the documentation about distributed tracing and <em>cross</em> <em>application</em> <em>traces</em>. Tip To get a high-level overview of all your applications and services, use the New Relic Explorer. Query <em>transactions</em>"
      },
      "id": "603e8774e7b9d2a6a42a07bc"
    },
    {
      "sections": [
        "Configure transaction traces",
        "Configure transaction trace settings via agent",
        "Configure transaction traces using server-side configuration",
        "Configure traces for specific (key) transactions",
        "Important",
        "Create custom transactions",
        "Collect HTTP request attributes, parameters",
        "Delete a transaction trace",
        "Delete a single transaction trace",
        "Delete all transaction traces",
        "Tip"
      ],
      "title": "Configure transaction traces",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "a79fa758e1b41c2c57f15d20bd8fd398a47d6414",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/configure-transaction-traces/",
      "published_at": "2021-07-02T09:09:02Z",
      "updated_at": "2021-03-16T07:18:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, transaction traces record in-depth details about your application's transactions and database calls. You can edit the default settings for transaction traces. Configure transaction trace settings via agent You can customize your transaction trace settings via New Relic agent configuration files and other \"local\" configuration methods such as environment variables. For more information about transaction trace configuration options, see the specific New Relic language agent's documentation: C SDK Go Java .NET Node PHP Python Ruby Configure transaction traces using server-side configuration The ability to configure transaction traces using server-side configuration depends on the New Relic agent. If server-side configuration is not supported, the transaction trace settings will be visible in the UI but not editable. If server-side configuration settings are available for your New Relic agent, you can see them at the following: one.newrelic.com > APM > (select an app) > Settings > Application > Server-side agent configuration. Transaction trace settings available using server-side configuration will differ depending on the New Relic agent you use. The UI includes descriptions of each. Settings in the UI may include: Transaction tracing and threshold Record SQL, including recording level and input fields Log SQL and stack trace threshold SQL query plans and threshold Error collection, including HTTP code and error class Slow query tracing Thread profiler Cross application tracing Configure traces for specific (key) transactions If you want to monitor or alert on a transaction differently than other transactions, make it a key transaction. This is useful, for example, when you want to set a transaction-specific Apdex that is different from your general Apdex T threshold. Changing a key transaction's Apdex changes the likelihood that it creates a transaction trace. For example: If you want to make it more likely a key transaction would generate transaction traces, lower its Apdex T value. If you want to make a key transaction less likely to be traced, raise its Apdex T value. Important If you have the transaction trace threshold set to a number of seconds, and not to the default Apdex setting, the number-of-seconds threshold will act as the threshold for all transactions, even for key transactions that have custom Apdex settings. Create custom transactions You can create custom transactions for app activity that isn't being automatically captured as a transaction by the New Relic agent. For more information, see Custom instrumentation. Collect HTTP request attributes, parameters For data security reasons, transaction traces do not collect potentially sensitive HTTP request attributes, sometimes called parameters. Traces do collect some basic HTTP request attributes, which New Relic calls agent attributes. To edit attribute collection settings, see the specific New Relic agent: C SDK Go Java .NET Node.js (does not allow HTTP attribute configuration) PHP Python Ruby For more information, see Collect custom attributes. Delete a transaction trace When you delete a transaction trace, it is deleted permanently. Delete a single transaction trace To delete a transaction trace record permanently: Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions. Under Transaction traces click on the trace you want to delete. On the details page, select Delete this trace. Delete all transaction traces To delete all traces for the selected app permanently: Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions. Click Delete all traces. It may take fifteen minutes or more for all transaction trace records to disappear from the UI. To delete all traces for your account, contact us at support.newrelic.com. Tip If you are doing general record cleanup, you may also want to delete databases and slow query traces or error traces. This will remove potentially sensitive data while retaining your other application data (such as Apdex, deployment information, etc.).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.66285,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Configure <em>transaction</em> <em>traces</em>",
        "sections": "Configure <em>traces</em> for specific (key) <em>transactions</em>",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": "In <em>APM</em>, transaction <em>traces</em> record in-depth details about your <em>application</em>&#x27;s <em>transactions</em> and database calls. You can edit the default settings for transaction <em>traces</em>. Configure transaction <em>trace</em> settings via agent You can customize your transaction <em>trace</em> settings via New Relic agent configuration"
      },
      "id": "603eb20028ccbc5775eba76a"
    }
  ],
  "/docs/apm/transactions/cross-application-traces/troubleshoot-cross-application-tracing": [
    {
      "sections": [
        "Introduction to cross application traces",
        "What is cross application tracing?",
        "Important",
        "Security considerations"
      ],
      "title": "Introduction to cross application traces",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Cross application traces"
      ],
      "external_id": "54c3bf54fc29f6ea190f7cd3dc9e1e1c15a92193",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/cross-application-traces/introduction-cross-application-traces/",
      "published_at": "2021-07-02T09:40:45Z",
      "updated_at": "2021-03-16T06:47:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic APM's cross application tracing lets you link transactions between your APM-monitored applications. What is cross application tracing? Important Instead of using cross application tracing, we recommend our distributed tracing features. Distributed tracing is an improvement on the cross application tracing feature and is recommended for large, distributed systems. New Relic APM's cross application traces link transactions between APM apps in your service-oriented architecture (SOA). This is useful, for example, to identify performance problems between your own application (the \"calling\" app) and any internal or external services (the \"called\" app), such as traffic to internal services. This helps you to: Spot bottlenecks in your cross application call flows. Understand from end to end how specific transactions are used by other applications and services. Diagnose problems faster and enhance collaboration across teams. Security considerations Cross application tracing relies on three HTTP headers in order to exchange information between the calling and called applications. The first two (X-NewRelic-ID and X-NewRelic-Transaction) appear as HTTP request headers in outgoing requests sent by an instrumented application. The remaining header (X-NewRelic-App-Data) is inserted into the HTTP response if the called application belongs to the same New Relic account as the calling application. New Relic obfuscates all of these headers using an obfuscation scheme identical to what is used for New Relic Browser's configuration for page load timing (sometimes referred to as real user monitoring or RUM) but with a different key. HTTP header Description X-NewRelic-ID (in request header) Contains the account ID and application ID of the application making the call X-NewRelic-Transaction (in request header) Contains information about an individual transaction created by the call (a GUID unique to the calling transaction, along with information about upstream calls that spawned the transaction) X-NewRelic-App-Data (in the response if applicable) Contains information about the called application, including: Account ID Application ID Name of the called transaction Timing information for the called transaction GUID of the called transaction",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 184.0792,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>cross</em> <em>application</em> <em>traces</em>",
        "sections": "Introduction to <em>cross</em> <em>application</em> <em>traces</em>",
        "tags": "<em>Cross</em> <em>application</em> <em>traces</em>",
        "body": " <em>application</em> tracing feature and is recommended for large, distributed systems. New Relic <em>APM</em>&#x27;s <em>cross</em> <em>application</em> <em>traces</em> link <em>transactions</em> between <em>APM</em> apps in your service-oriented architecture (SOA). This is useful, for example, to identify performance problems between your own <em>application</em>"
      },
      "id": "603ebfc764441fcfd94e8873"
    },
    {
      "sections": [
        "Transactions in New Relic APM",
        "What is a transaction?",
        "Types of transactions",
        "Transaction segments",
        "Transaction naming",
        "Monitoring transactions",
        "Tip",
        "Query transactions"
      ],
      "title": "Transactions in New Relic APM",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Intro to transactions"
      ],
      "external_id": "2a96f455cbf6dfdc5dda2363ba4e69b6f9dba159",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/intro-transactions/transactions-new-relic-apm/",
      "published_at": "2021-07-02T09:42:04Z",
      "updated_at": "2021-03-30T08:07:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The word transaction can have several different meanings in the software industry. This document explains how the term is used by New Relic and how transactions are reported. What is a transaction? At New Relic, a transaction is defined as one logical unit of work in a software application. Specifically, it refers to the function calls and method calls that make up that unit of work. For APM, it will often refer to a web transaction, which represents activity that happens from when the application receives a web request to when the response is sent. When you install APM in a supported system, it begins automatically reporting web requests and other important functions and methods. To supplement the default level of monitoring, you can set up custom instrumentation to report additional transactions. Some frameworks do not have a natural concept of a transaction. In other words, there are no predefined pathways that can easily be recognized or monitored as transactions. To define transactions in such frameworks, you can use custom instrumentation. Types of transactions Cumulative transaction data appears in APM on the Transactions page. The two main categories of transactions are web and non-web: Web: Transactions are initiated with an HTTP request. For most organizations, these represent customer-centric interactions and thus are the most important transactions to monitor. Non-web: Non-web transactions are not initiated with a web request. They can include non-web worker processes, background processes, scripts, message queue activity, and other tasks. Transaction segments The individual functions and calls that make up a transaction are called segments. For example external service calls and database calls are segments, and both have their own UI pages in APM. The APM Transactions page displays aggregate transaction segment data. To add segments to a transaction, use custom instrumentation. To see the segments of a specific transaction, use transaction traces. Transaction naming For supported frameworks, transaction names can come from various sources, such as the name given to the transaction by the framework, function names detected during the transaction, or a web request's URL. For transactions that produce many names with a similar format, we consolidate those into general transaction categories. For example, a transaction might be displayed as /user/*/control_panel, where the * represents different user names. To rename transactions or adjust how names are consolidated, use custom instrumentation. Monitoring transactions Here are some other ways you can use APM to monitor transactions: If you want to monitor... Use this... Transactions important to your business Create key transactions, which emphasizes them in the UI and lets you set a custom level of monitoring for them. Async activity Follow the procedures to set up asynchronous activity for your specific APM language agent. Activity across applications Linking transactions across applications gives you more detail about business-relevant application activity. For more information, see the documentation about distributed tracing and cross application traces. Tip To get a high-level overview of all your applications and services, use the New Relic Explorer. Query transactions Transactions are available for querying with an in-depth set of default attributes attached. Using these attributes, you can run queries and create custom charts that APM does not provide by default. For information on how to query your data using our UI or NRQL, see Query New Relic data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.43948,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Transactions</em> in New Relic <em>APM</em>",
        "sections": "<em>Transactions</em> in New Relic <em>APM</em>",
        "tags": "<em>Transactions</em>",
        "body": " applications gives you more detail about business-relevant <em>application</em> activity. For more information, see the documentation about distributed tracing and <em>cross</em> <em>application</em> <em>traces</em>. Tip To get a high-level overview of all your applications and services, use the New Relic Explorer. Query <em>transactions</em>"
      },
      "id": "603e8774e7b9d2a6a42a07bc"
    },
    {
      "sections": [
        "Configure transaction traces",
        "Configure transaction trace settings via agent",
        "Configure transaction traces using server-side configuration",
        "Configure traces for specific (key) transactions",
        "Important",
        "Create custom transactions",
        "Collect HTTP request attributes, parameters",
        "Delete a transaction trace",
        "Delete a single transaction trace",
        "Delete all transaction traces",
        "Tip"
      ],
      "title": "Configure transaction traces",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "a79fa758e1b41c2c57f15d20bd8fd398a47d6414",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/configure-transaction-traces/",
      "published_at": "2021-07-02T09:09:02Z",
      "updated_at": "2021-03-16T07:18:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, transaction traces record in-depth details about your application's transactions and database calls. You can edit the default settings for transaction traces. Configure transaction trace settings via agent You can customize your transaction trace settings via New Relic agent configuration files and other \"local\" configuration methods such as environment variables. For more information about transaction trace configuration options, see the specific New Relic language agent's documentation: C SDK Go Java .NET Node PHP Python Ruby Configure transaction traces using server-side configuration The ability to configure transaction traces using server-side configuration depends on the New Relic agent. If server-side configuration is not supported, the transaction trace settings will be visible in the UI but not editable. If server-side configuration settings are available for your New Relic agent, you can see them at the following: one.newrelic.com > APM > (select an app) > Settings > Application > Server-side agent configuration. Transaction trace settings available using server-side configuration will differ depending on the New Relic agent you use. The UI includes descriptions of each. Settings in the UI may include: Transaction tracing and threshold Record SQL, including recording level and input fields Log SQL and stack trace threshold SQL query plans and threshold Error collection, including HTTP code and error class Slow query tracing Thread profiler Cross application tracing Configure traces for specific (key) transactions If you want to monitor or alert on a transaction differently than other transactions, make it a key transaction. This is useful, for example, when you want to set a transaction-specific Apdex that is different from your general Apdex T threshold. Changing a key transaction's Apdex changes the likelihood that it creates a transaction trace. For example: If you want to make it more likely a key transaction would generate transaction traces, lower its Apdex T value. If you want to make a key transaction less likely to be traced, raise its Apdex T value. Important If you have the transaction trace threshold set to a number of seconds, and not to the default Apdex setting, the number-of-seconds threshold will act as the threshold for all transactions, even for key transactions that have custom Apdex settings. Create custom transactions You can create custom transactions for app activity that isn't being automatically captured as a transaction by the New Relic agent. For more information, see Custom instrumentation. Collect HTTP request attributes, parameters For data security reasons, transaction traces do not collect potentially sensitive HTTP request attributes, sometimes called parameters. Traces do collect some basic HTTP request attributes, which New Relic calls agent attributes. To edit attribute collection settings, see the specific New Relic agent: C SDK Go Java .NET Node.js (does not allow HTTP attribute configuration) PHP Python Ruby For more information, see Collect custom attributes. Delete a transaction trace When you delete a transaction trace, it is deleted permanently. Delete a single transaction trace To delete a transaction trace record permanently: Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions. Under Transaction traces click on the trace you want to delete. On the details page, select Delete this trace. Delete all transaction traces To delete all traces for the selected app permanently: Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions. Click Delete all traces. It may take fifteen minutes or more for all transaction trace records to disappear from the UI. To delete all traces for your account, contact us at support.newrelic.com. Tip If you are doing general record cleanup, you may also want to delete databases and slow query traces or error traces. This will remove potentially sensitive data while retaining your other application data (such as Apdex, deployment information, etc.).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.66285,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Configure <em>transaction</em> <em>traces</em>",
        "sections": "Configure <em>traces</em> for specific (key) <em>transactions</em>",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": "In <em>APM</em>, transaction <em>traces</em> record in-depth details about your <em>application</em>&#x27;s <em>transactions</em> and database calls. You can edit the default settings for transaction <em>traces</em>. Configure transaction <em>trace</em> settings via agent You can customize your transaction <em>trace</em> settings via New Relic agent configuration"
      },
      "id": "603eb20028ccbc5775eba76a"
    }
  ],
  "/docs/apm/transactions/intro-transactions/monitor-background-processes-other-non-web-transactions": [
    {
      "sections": [
        "Transactions in New Relic APM",
        "What is a transaction?",
        "Types of transactions",
        "Transaction segments",
        "Transaction naming",
        "Monitoring transactions",
        "Tip",
        "Query transactions"
      ],
      "title": "Transactions in New Relic APM",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Intro to transactions"
      ],
      "external_id": "2a96f455cbf6dfdc5dda2363ba4e69b6f9dba159",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/intro-transactions/transactions-new-relic-apm/",
      "published_at": "2021-07-02T09:42:04Z",
      "updated_at": "2021-03-30T08:07:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The word transaction can have several different meanings in the software industry. This document explains how the term is used by New Relic and how transactions are reported. What is a transaction? At New Relic, a transaction is defined as one logical unit of work in a software application. Specifically, it refers to the function calls and method calls that make up that unit of work. For APM, it will often refer to a web transaction, which represents activity that happens from when the application receives a web request to when the response is sent. When you install APM in a supported system, it begins automatically reporting web requests and other important functions and methods. To supplement the default level of monitoring, you can set up custom instrumentation to report additional transactions. Some frameworks do not have a natural concept of a transaction. In other words, there are no predefined pathways that can easily be recognized or monitored as transactions. To define transactions in such frameworks, you can use custom instrumentation. Types of transactions Cumulative transaction data appears in APM on the Transactions page. The two main categories of transactions are web and non-web: Web: Transactions are initiated with an HTTP request. For most organizations, these represent customer-centric interactions and thus are the most important transactions to monitor. Non-web: Non-web transactions are not initiated with a web request. They can include non-web worker processes, background processes, scripts, message queue activity, and other tasks. Transaction segments The individual functions and calls that make up a transaction are called segments. For example external service calls and database calls are segments, and both have their own UI pages in APM. The APM Transactions page displays aggregate transaction segment data. To add segments to a transaction, use custom instrumentation. To see the segments of a specific transaction, use transaction traces. Transaction naming For supported frameworks, transaction names can come from various sources, such as the name given to the transaction by the framework, function names detected during the transaction, or a web request's URL. For transactions that produce many names with a similar format, we consolidate those into general transaction categories. For example, a transaction might be displayed as /user/*/control_panel, where the * represents different user names. To rename transactions or adjust how names are consolidated, use custom instrumentation. Monitoring transactions Here are some other ways you can use APM to monitor transactions: If you want to monitor... Use this... Transactions important to your business Create key transactions, which emphasizes them in the UI and lets you set a custom level of monitoring for them. Async activity Follow the procedures to set up asynchronous activity for your specific APM language agent. Activity across applications Linking transactions across applications gives you more detail about business-relevant application activity. For more information, see the documentation about distributed tracing and cross application traces. Tip To get a high-level overview of all your applications and services, use the New Relic Explorer. Query transactions Transactions are available for querying with an in-depth set of default attributes attached. Using these attributes, you can run queries and create custom charts that APM does not provide by default. For information on how to query your data using our UI or NRQL, see Query New Relic data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 198.23582,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Transactions</em> in New Relic <em>APM</em>",
        "sections": "<em>Transactions</em> in New Relic <em>APM</em>",
        "tags": "<em>Intro</em> <em>to</em> <em>transactions</em>",
        "body": ", there are no predefined pathways that can easily be recognized or monitored as <em>transactions</em>. To define <em>transactions</em> in such frameworks, you can use custom instrumentation. Types of <em>transactions</em> Cumulative transaction data appears in <em>APM</em> on the <em>Transactions</em> page. The two main categories of <em>transactions</em>"
      },
      "id": "603e8774e7b9d2a6a42a07bc"
    },
    {
      "sections": [
        "Introduction to transaction traces",
        "What transactions record traces",
        "Configure transaction traces",
        "View transaction traces in UI",
        "Troubleshoot an issue with transaction traces"
      ],
      "title": "Introduction to transaction traces",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "b2a6521e60a66ca6e5b731b0c4fe7c80abe32675",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/introduction-transaction-traces/",
      "published_at": "2021-07-02T09:09:02Z",
      "updated_at": "2021-03-29T16:45:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, a transaction trace gives a detailed snapshot of a single transaction in your application. A transaction trace records the available function calls, database calls, and external calls. You can use transaction traces to troubleshoot performance issues and to get detailed low-level insight into how your app is working. What transactions record traces In APM, a transaction trace records the segments that make up a transaction. Because they give you more detail, you can use transaction traces to analyze and troubleshoot performance issues. Here are the default rules that govern which transactions a New Relic agent traces: Over the minute-long harvest cycle, all transactions that violate the threshold (either four times your Apdex T value or a specific number of seconds) are added to a pool of transactions. At the end of that minute, the New Relic agent selects the slowest transaction in that pool and performs a transaction trace on it. These are the general rules, but there are some agent-specific differences. For example: The Java agent collects occasional non-slow transactions. If one transaction is frequently traced, some agents will select other transactions to give a more diverse sampling. If you don't see traces in your account, it's possible that no transactions meet the necessary criteria. In this situation, you can adjust transaction trace settings to ensure some transactions will be traced. If you use Synthetic, you will likely have Synthetic monitor traces. Synthetic traces can happen more frequently than APM traces, potentially several per minute. Configure transaction traces To configure or edit trace settings, see the procedures for: Transaction traces Key transaction traces View transaction traces in UI To view transaction traces: Do one of the following: New Relic Explorer: Go to one.newrelic.com > Explorer > (select an app) > Monitor > Transactions. APM: Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions. In the Transaction traces section, click transaction traces to view additional details. Troubleshoot an issue with transaction traces If you expect to see transaction traces but do not see them, follow the troubleshooting procedures. For more information about using transaction traces, slow queries, and service maps to solve performance issues, see Analyze performance issues.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.43324,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> <em>to</em> <em>transaction</em> traces",
        "sections": "<em>Introduction</em> <em>to</em> <em>transaction</em> traces",
        "tags": "<em>Transactions</em>",
        "body": " into how your app is working. What <em>transactions</em> record traces In <em>APM</em>, a transaction trace records the segments that make up a transaction. Because they give you more detail, you can use transaction traces to analyze and troubleshoot performance issues. Here are the default rules that govern which"
      },
      "id": "603ebebae7b9d268562a07c8"
    },
    {
      "sections": [
        "Transaction traces: Trace details page",
        "Trace details page functions",
        "Drilldown options",
        "Color coding of segment duration data",
        "Application code in traces",
        "Partial traces",
        "Segment grouping rules"
      ],
      "title": "Transaction traces: Trace details page",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "77871dbce9242fbbb6bee421b1d6b7cd5e77a9d6",
      "image": "https://docs.newrelic.com/static/e1099bd92081eca96a51c0f0f27f8a65/c1b63/trx-trace-details.png",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/transaction-traces-trace-details-page/",
      "published_at": "2021-07-02T09:12:04Z",
      "updated_at": "2021-03-16T08:23:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, the Trace details tab shows the timing of individual segments in a transaction trace. This document describes the sections and features of the Trace details tab. Trace details page functions Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions > (select a transaction trace) > Trace details. The Trace details page displays a table with the timing data for the segments in a transaction, plus additional features and functions: Trace details page Description Primary trace data, functions The top of each transaction trace UI page shows several primary pieces of data, including the trace time, response time, and, if available, CPU info. Also, sometimes the UI may indicate a partial trace. Available functions include: Delete this trace: When you delete a trace, it cannot be retrieved. Track as key transaction. Duration column The duration of each segment and subsegment is shown as both the number of milliseconds and a percentage of the total transaction time. Especially slow segments are color-coded. Segment column The Segment column displays segment names and counts. Fast and repeat calls may be automatically grouped together. Sometimes you may see Application code as the name of a segment or subsegment. To expand segments, use either of the following: The Expand performance problems button at the top of the page The expand and collapse dropdown arrows next to the segments Drilldown column The Drilldown column may contain icons that link to additional transaction data, if available. Timestamp column The Timestamp column displays the start time of a segment or subsegment, relative to the start of the transaction. For example, a value of 3.150 s indicates that that segment started 3.15 seconds into the transaction. Drilldown options In the Drilldown column, icons indicate that additional data is available: Icon Description Database queries The database icon links to the raw database query for that query segment. Depending on your transaction trace settings, this query can either show as raw data or obfuscated data. If the total time for the segment exceeds the query plan threshold in your settings, the query analysis also will appear, along with a stack trace showing the exact location of the call in your code. Stack traces The magnifying glass links to stack trace details. Aggregate transaction details This icon indicates that cross application tracing details are not available. However, you can select this icon to view aggregated transaction information across multiple invocations of the transaction. Color coding of segment duration data The Duration column of the Trace details table is color-coded: Red: More than 25% of the total transaction time was spent in this segment. Yellow: More than 5% of the total transaction time was spent in this segment. Color-coded durations do not necessarily indicate a problem. Whether the timing is actually a problem depends on what you consider normal and acceptable for your application. Application code in traces If a segment is listed as Application code in the table, it indicates that that section of code was not instrumented. You can use custom instrumentation to get more detail on that part of the code. Segments will often be listed as Application code for partial traces. Partial traces For performance reasons, New Relic APM only captures the first 2,000 segments of a transaction trace (900 for Node.js). If a transaction trace exceeds that number of segments, the agent truncates the transaction trace and displays a message at the top of the Details page: This is a partial trace. The New Relic APM agents have differing rules for when to truncate segments. APM agent Truncate segment rules C SDK Truncates based on segment priority: The root segment has the highest priority. Segments that have seen distributed tracing activity have second-highest priority. Slow segments have third-highest priority. For more information, see the C SDK's documentation about newrelic_transaction_tracer_config_t on GitHub. Go The segment duration must be greater than the TransactionTracer.SegmentThreshold value set in your Go segment configuration. Java, .NET, Ruby These agents truncate traces chronologically. For more information, see the transaction tracer documentation for Java, .NET, or Ruby as applicable. Node.js The Node.js agent only captures the first 900 segments of a transaction trace. For more information, see Node.js transaction tracer configuration. PHP Truncates based on segment duration; the slowest 2,000 segments are captured for the trace. For more information, see PHP transaction tracer configuration. Python Truncates based on segment duration; the slowest 2,000 segments are captured for the trace. For more information, see Python transaction tracer configuration. Segment grouping rules Transaction traces that have a lot of segments can be hard to interpret. New Relic helps you by automatically grouping fast and/or repeated method calls into a single segment grouping. For example, you might see a segment titled 7 fast method calls. This means that, because of their fast completion, New Relic assumed these calls were unlikely to be a problem and grouped them together. You can expand that grouping to see the individual segments. Rules underlying segment grouping include: Fast calls: When New Relic detects four or more consecutive segments with a duration of 7.5 ms or less, these are grouped into a single collapsed header. Identical calls: When New Relic detects four or more consecutive identical calls, this usually indicates an N+1 problem. These segments are collapsed. Expanding the collapsed node displays only the first three calls, not all calls.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 88.47161,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Transaction</em> traces: Trace details page",
        "sections": "<em>Transaction</em> traces: Trace details page",
        "tags": "<em>Transactions</em>",
        "body": "In <em>APM</em>, the Trace details tab shows the timing of individual segments in a transaction trace. This document describes the sections and features of the Trace details tab. Trace details page functions Go to one.newrelic.com &gt; <em>APM</em> &gt; (select an app) &gt; Monitor &gt; <em>Transactions</em> &gt; (select a transaction"
      },
      "id": "603ebe83196a67703ca83dd0"
    }
  ],
  "/docs/apm/transactions/intro-transactions/transactions-new-relic-apm": [
    {
      "sections": [
        "Monitor background processes and other non-web transactions",
        "What are non-web transactions?",
        "Create non-web transactions",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Important",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "View non-web transactions"
      ],
      "title": "Monitor background processes and other non-web transactions",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Intro to transactions"
      ],
      "external_id": "aca55742ecc24a7f6bf212b853777224317d8924",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/intro-transactions/monitor-background-processes-other-non-web-transactions/",
      "published_at": "2021-07-02T09:40:46Z",
      "updated_at": "2021-03-30T08:07:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains what non-web transactions are in APM, and how you can instrument background tasks and other arbitrary activity to be reported as non-web transactions. What are non-web transactions? The two main New Relic APM transaction categories are web and non-web. Web transactions are transactions we detect as being initiated by a web request; they are the most common type of transaction reported by APM. Non-web transactions are transactions that are not web transactions; we do not detect they were initiated by a web request. This includes processes and jobs that do not handle web requests, such as message processing and background tasks. For example, you might schedule something to run periodically on your server to do database work, send emails, etc. The source is not a web request but something on your server. Some non-web transactions from supported frameworks or services are detected automatically by New Relic; others may be created using custom instrumentation. We intentionally separate your web and non-web transactions in the UI. Non-web vs. web transactions Comments Less directly important Non-web transactions are often background processes and tasks, and they are less directly important to your application's users when compared to web transactions. Long running Non-web transactions are often long-running processes. Separating them from web transactions prevents those results from skewing your customer-facing response times. Omitted from Apdex score Combining your non-web transactions with your web transactions would hurt your Apdex score (a measure of satisfaction with load times). This is why Apdex data for non-web transactions does not appear in the UI. Create non-web transactions To create new non-web transactions, follow the procedures for your APM language agent. C SDK Follow the procedures for instrumenting a non-web transaction. Go Follow the procedures for instrumenting a non-web transaction. Java Follow the procedures for instrumenting a transaction (instrumenting a transaction without web request parameters creates a non-web transaction). .NET By default, the APM .NET agent instruments IIS ASP workers. To instrument other (non-IIS) .NET applications, such as standalone (WCF) services, console apps, and other Windows services, see Instrumenting custom applications and Instrumenting WCF applications. Important For IIS applications, you cannot change web transactions to non-web transactions. Node.js Use startBackgroundTransaction(). PHP To mark a transaction as non-web: use newrelic_background_job and set the flag to true. The PHP agent reports all command-line run scripts as non-web transactions. Python See Python agent non-web transactions. The Python agent also supports non-web transaction reporting from Celery and Gearman. Ruby See Ruby agent non-web transactions. View non-web transactions To view non-web transaction data in the New Relic UI, go to the main chart on the following pages, and then select the Non-web option in the dropdown: New Relic Explorer: Go to one.newrelic.com > Explorer > (select an app) > Summary. APM: Go to one.newrelic.com > APM > (select an app) > Summary. Transactions: Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 198.23582,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Monitor background processes and other non-web <em>transactions</em>",
        "sections": "Monitor background processes and other non-web <em>transactions</em>",
        "tags": "<em>Intro</em> <em>to</em> <em>transactions</em>",
        "body": "This document explains what non-web <em>transactions</em> are in <em>APM</em>, and how you can instrument background tasks and other arbitrary activity to be reported as non-web <em>transactions</em>. What are non-web <em>transactions</em>? The two main New Relic <em>APM</em> transaction categories are web and non-web. Web <em>transactions</em>"
      },
      "id": "6044288664441f124c378ec7"
    },
    {
      "sections": [
        "Introduction to transaction traces",
        "What transactions record traces",
        "Configure transaction traces",
        "View transaction traces in UI",
        "Troubleshoot an issue with transaction traces"
      ],
      "title": "Introduction to transaction traces",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "b2a6521e60a66ca6e5b731b0c4fe7c80abe32675",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/introduction-transaction-traces/",
      "published_at": "2021-07-02T09:09:02Z",
      "updated_at": "2021-03-29T16:45:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, a transaction trace gives a detailed snapshot of a single transaction in your application. A transaction trace records the available function calls, database calls, and external calls. You can use transaction traces to troubleshoot performance issues and to get detailed low-level insight into how your app is working. What transactions record traces In APM, a transaction trace records the segments that make up a transaction. Because they give you more detail, you can use transaction traces to analyze and troubleshoot performance issues. Here are the default rules that govern which transactions a New Relic agent traces: Over the minute-long harvest cycle, all transactions that violate the threshold (either four times your Apdex T value or a specific number of seconds) are added to a pool of transactions. At the end of that minute, the New Relic agent selects the slowest transaction in that pool and performs a transaction trace on it. These are the general rules, but there are some agent-specific differences. For example: The Java agent collects occasional non-slow transactions. If one transaction is frequently traced, some agents will select other transactions to give a more diverse sampling. If you don't see traces in your account, it's possible that no transactions meet the necessary criteria. In this situation, you can adjust transaction trace settings to ensure some transactions will be traced. If you use Synthetic, you will likely have Synthetic monitor traces. Synthetic traces can happen more frequently than APM traces, potentially several per minute. Configure transaction traces To configure or edit trace settings, see the procedures for: Transaction traces Key transaction traces View transaction traces in UI To view transaction traces: Do one of the following: New Relic Explorer: Go to one.newrelic.com > Explorer > (select an app) > Monitor > Transactions. APM: Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions. In the Transaction traces section, click transaction traces to view additional details. Troubleshoot an issue with transaction traces If you expect to see transaction traces but do not see them, follow the troubleshooting procedures. For more information about using transaction traces, slow queries, and service maps to solve performance issues, see Analyze performance issues.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.43324,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Introduction</em> <em>to</em> <em>transaction</em> traces",
        "sections": "<em>Introduction</em> <em>to</em> <em>transaction</em> traces",
        "tags": "<em>Transactions</em>",
        "body": " into how your app is working. What <em>transactions</em> record traces In <em>APM</em>, a transaction trace records the segments that make up a transaction. Because they give you more detail, you can use transaction traces to analyze and troubleshoot performance issues. Here are the default rules that govern which"
      },
      "id": "603ebebae7b9d268562a07c8"
    },
    {
      "sections": [
        "Transaction traces: Trace details page",
        "Trace details page functions",
        "Drilldown options",
        "Color coding of segment duration data",
        "Application code in traces",
        "Partial traces",
        "Segment grouping rules"
      ],
      "title": "Transaction traces: Trace details page",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "77871dbce9242fbbb6bee421b1d6b7cd5e77a9d6",
      "image": "https://docs.newrelic.com/static/e1099bd92081eca96a51c0f0f27f8a65/c1b63/trx-trace-details.png",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/transaction-traces-trace-details-page/",
      "published_at": "2021-07-02T09:12:04Z",
      "updated_at": "2021-03-16T08:23:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, the Trace details tab shows the timing of individual segments in a transaction trace. This document describes the sections and features of the Trace details tab. Trace details page functions Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions > (select a transaction trace) > Trace details. The Trace details page displays a table with the timing data for the segments in a transaction, plus additional features and functions: Trace details page Description Primary trace data, functions The top of each transaction trace UI page shows several primary pieces of data, including the trace time, response time, and, if available, CPU info. Also, sometimes the UI may indicate a partial trace. Available functions include: Delete this trace: When you delete a trace, it cannot be retrieved. Track as key transaction. Duration column The duration of each segment and subsegment is shown as both the number of milliseconds and a percentage of the total transaction time. Especially slow segments are color-coded. Segment column The Segment column displays segment names and counts. Fast and repeat calls may be automatically grouped together. Sometimes you may see Application code as the name of a segment or subsegment. To expand segments, use either of the following: The Expand performance problems button at the top of the page The expand and collapse dropdown arrows next to the segments Drilldown column The Drilldown column may contain icons that link to additional transaction data, if available. Timestamp column The Timestamp column displays the start time of a segment or subsegment, relative to the start of the transaction. For example, a value of 3.150 s indicates that that segment started 3.15 seconds into the transaction. Drilldown options In the Drilldown column, icons indicate that additional data is available: Icon Description Database queries The database icon links to the raw database query for that query segment. Depending on your transaction trace settings, this query can either show as raw data or obfuscated data. If the total time for the segment exceeds the query plan threshold in your settings, the query analysis also will appear, along with a stack trace showing the exact location of the call in your code. Stack traces The magnifying glass links to stack trace details. Aggregate transaction details This icon indicates that cross application tracing details are not available. However, you can select this icon to view aggregated transaction information across multiple invocations of the transaction. Color coding of segment duration data The Duration column of the Trace details table is color-coded: Red: More than 25% of the total transaction time was spent in this segment. Yellow: More than 5% of the total transaction time was spent in this segment. Color-coded durations do not necessarily indicate a problem. Whether the timing is actually a problem depends on what you consider normal and acceptable for your application. Application code in traces If a segment is listed as Application code in the table, it indicates that that section of code was not instrumented. You can use custom instrumentation to get more detail on that part of the code. Segments will often be listed as Application code for partial traces. Partial traces For performance reasons, New Relic APM only captures the first 2,000 segments of a transaction trace (900 for Node.js). If a transaction trace exceeds that number of segments, the agent truncates the transaction trace and displays a message at the top of the Details page: This is a partial trace. The New Relic APM agents have differing rules for when to truncate segments. APM agent Truncate segment rules C SDK Truncates based on segment priority: The root segment has the highest priority. Segments that have seen distributed tracing activity have second-highest priority. Slow segments have third-highest priority. For more information, see the C SDK's documentation about newrelic_transaction_tracer_config_t on GitHub. Go The segment duration must be greater than the TransactionTracer.SegmentThreshold value set in your Go segment configuration. Java, .NET, Ruby These agents truncate traces chronologically. For more information, see the transaction tracer documentation for Java, .NET, or Ruby as applicable. Node.js The Node.js agent only captures the first 900 segments of a transaction trace. For more information, see Node.js transaction tracer configuration. PHP Truncates based on segment duration; the slowest 2,000 segments are captured for the trace. For more information, see PHP transaction tracer configuration. Python Truncates based on segment duration; the slowest 2,000 segments are captured for the trace. For more information, see Python transaction tracer configuration. Segment grouping rules Transaction traces that have a lot of segments can be hard to interpret. New Relic helps you by automatically grouping fast and/or repeated method calls into a single segment grouping. For example, you might see a segment titled 7 fast method calls. This means that, because of their fast completion, New Relic assumed these calls were unlikely to be a problem and grouped them together. You can expand that grouping to see the individual segments. Rules underlying segment grouping include: Fast calls: When New Relic detects four or more consecutive segments with a duration of 7.5 ms or less, these are grouped into a single collapsed header. Identical calls: When New Relic detects four or more consecutive identical calls, this usually indicates an N+1 problem. These segments are collapsed. Expanding the collapsed node displays only the first three calls, not all calls.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 88.47161,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Transaction</em> traces: Trace details page",
        "sections": "<em>Transaction</em> traces: Trace details page",
        "tags": "<em>Transactions</em>",
        "body": "In <em>APM</em>, the Trace details tab shows the timing of individual segments in a transaction trace. This document describes the sections and features of the Trace details tab. Trace details page functions Go to one.newrelic.com &gt; <em>APM</em> &gt; (select an app) &gt; Monitor &gt; <em>Transactions</em> &gt; (select a transaction"
      },
      "id": "603ebe83196a67703ca83dd0"
    }
  ],
  "/docs/apm/transactions/key-transactions/create-update-key-transactions": [
    {
      "sections": [
        "Tag key transactions",
        "Assign tags",
        "Tip",
        "Tag multiple transactions",
        "Filter"
      ],
      "title": "Tag key transactions",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Key transactions"
      ],
      "external_id": "760fa0d256c1404a48c8ff06a744c8a0cbd81874",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/key-transactions/tag-key-transactions/",
      "published_at": "2021-07-02T09:09:01Z",
      "updated_at": "2021-03-16T08:22:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, you can assign tags to key transactions. Tags are metadata associated with transactions. They're useful for applying to transactions that have things in common. For example, you might apply a checkout tag to all key transactions that are part of the checkout process. Then you can filter by checkout to see all of those transactions in one place. Assign tags To assign a tag to a key transaction: Go to one.newrelic.com > More > Key transactions. From the index page, select the tag icon beside the name of the transaction you want to tag. In the tag name box, type the tag's name. Press space to apply the tag. Tip Use any Unicode characters except commas , , angle brackets < >, parentheses ( ), or square brackets [ ]. Select outside the tag name box to exit tag creation. Tag multiple transactions You can assign a tag to all visible transactions in the index: Go to one.newrelic.com > More > Key transactions. Follow the tag creation instructions in Assign tags. To remove a bulk tag: From the bulk tag dropdown, select a tag name's x symbol. Filter To filter the key transaction index by tags: In the key transaction index search field, select the dropdown icon and select by tags. Type in the tag name.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.40144,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Tag <em>key</em> <em>transactions</em>",
        "sections": "Tag <em>key</em> <em>transactions</em>",
        "tags": "<em>Key</em> <em>transactions</em>",
        "body": "In <em>APM</em>, you can assign tags to <em>key</em> <em>transactions</em>. Tags are metadata associated with <em>transactions</em>. They&#x27;re useful for applying to <em>transactions</em> that have things in common. For example, you might apply a checkout tag to all <em>key</em> <em>transactions</em> that are part of the checkout process. Then you can filter"
      },
      "id": "603eb18928ccbc564deba79d"
    },
    {
      "sections": [
        "Introduction to key transactions",
        "What are key transactions?",
        "Create key transactions",
        "View key transactions in UI"
      ],
      "title": "Introduction to key transactions",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Key transactions"
      ],
      "external_id": "1224901400c4406015b22afe036d35ec3bb569bd",
      "image": "https://docs.newrelic.com/static/f5ea2688bbb03f205aef5cfbc5d04e30/e6c84/key-trx-overview.png",
      "url": "https://docs.newrelic.com/docs/apm/transactions/key-transactions/introduction-key-transactions/",
      "published_at": "2021-07-02T09:42:05Z",
      "updated_at": "2021-03-16T08:22:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, you can make a transaction a key transaction when you want it to have a custom level of monitoring, or when you want it to have its own alert policy. These may be web transactions or non-web transactions that are important to your business. For most New Relic agents, a key transaction can be any type of transaction. For the PHP, Node.js, and Go agents, only web transactions can be turned into key transactions. What are key transactions? In New Relic APM, making a transaction a key transaction gives you the following benefits: Key transactions are grouped together in the New Relic UI, so they are easy to find and examine. You can set a custom Apdex threshold for a key transaction. You can set an alert policy for a key transaction. Key transactions are useful for: Important transactions. For your app's most important transactions, making them key transactions means you can quickly find and examine them. You can set stricter Apdex requirements for them, and you can create alert policies for them. Slow transactions. If a transaction is regularly slower than other transactions, it can bring down the Apdex score of the entire application. When you make a transaction a key transaction, you can set a longer-duration Apdex threshold for it so it won't bring down your app's Apdex score. Create key transactions To create key transactions, see Create and update key transactions. View key transactions in UI The key transaction's page includes response time and throughput charts, service-level agreement information, a cross application tracing map (if available), and links to alert policy options. The key transaction index is a list of your key transactions: Go to one.newrelic.com > More > Key transactions > (select a transaction). Select a Key transaction from the index. View the selected key transaction's Summary page, including charts and drilldown options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.40143,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>key</em> <em>transactions</em>",
        "sections": "Introduction to <em>key</em> <em>transactions</em>",
        "tags": "<em>Key</em> <em>transactions</em>",
        "body": "In <em>APM</em>, you can make a transaction a <em>key</em> transaction when you want it to have a custom level of monitoring, or when you want it to have its own alert policy. These may be web <em>transactions</em> or non-web <em>transactions</em> that are important to your business. For most New Relic agents, a <em>key</em> transaction can"
      },
      "id": "603eb18a28ccbc564deba7a0"
    },
    {
      "sections": [
        "Key transaction charts and data",
        "Overview page",
        "SLA report page",
        "Alerts"
      ],
      "title": "Key transaction charts and data",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Key transactions"
      ],
      "external_id": "7eee1868178054d18f55452b0989d724546d8016",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/key-transactions/key-transaction-charts-data/",
      "published_at": "2021-07-02T08:56:42Z",
      "updated_at": "2021-03-16T06:47:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, every key transaction has its own Overview page and several other UI pages. Depending on the type of transaction (web or non-web), different information appears. Overview page When you select a transaction from the key transaction index, the key transaction's Overview page appears. The Overview page contains charts for response time, Apdex, throughput, and other data. It is similar to the main Overview page in New Relic APM, with standard New Relic page functions. SLA report page The SLA report page for a key transaction displays Service Level Agreement reports for that transaction. The SLA reports include daily and weekly data about throughput, response time, and Apdex. You can also download the report as a comma-separated value (CSV) spreadsheet. Alerts When you select a transaction from the key transaction index, you can also see options to view alert condition violations and set alert policies.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.39334,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Key</em> <em>transaction</em> charts and data",
        "sections": "<em>Key</em> <em>transaction</em> charts and data",
        "tags": "<em>Key</em> <em>transactions</em>",
        "body": "In <em>APM</em>, every <em>key</em> transaction has its own Overview page and several other UI pages. Depending on the type of transaction (web or non-web), different information appears. Overview page When you select a transaction from the <em>key</em> transaction index, the <em>key</em> transaction&#x27;s Overview page appears"
      },
      "id": "603ebd1128ccbc1ceaeba784"
    }
  ],
  "/docs/apm/transactions/key-transactions/introduction-key-transactions": [
    {
      "sections": [
        "Tag key transactions",
        "Assign tags",
        "Tip",
        "Tag multiple transactions",
        "Filter"
      ],
      "title": "Tag key transactions",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Key transactions"
      ],
      "external_id": "760fa0d256c1404a48c8ff06a744c8a0cbd81874",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/key-transactions/tag-key-transactions/",
      "published_at": "2021-07-02T09:09:01Z",
      "updated_at": "2021-03-16T08:22:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, you can assign tags to key transactions. Tags are metadata associated with transactions. They're useful for applying to transactions that have things in common. For example, you might apply a checkout tag to all key transactions that are part of the checkout process. Then you can filter by checkout to see all of those transactions in one place. Assign tags To assign a tag to a key transaction: Go to one.newrelic.com > More > Key transactions. From the index page, select the tag icon beside the name of the transaction you want to tag. In the tag name box, type the tag's name. Press space to apply the tag. Tip Use any Unicode characters except commas , , angle brackets < >, parentheses ( ), or square brackets [ ]. Select outside the tag name box to exit tag creation. Tag multiple transactions You can assign a tag to all visible transactions in the index: Go to one.newrelic.com > More > Key transactions. Follow the tag creation instructions in Assign tags. To remove a bulk tag: From the bulk tag dropdown, select a tag name's x symbol. Filter To filter the key transaction index by tags: In the key transaction index search field, select the dropdown icon and select by tags. Type in the tag name.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.40144,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Tag <em>key</em> <em>transactions</em>",
        "sections": "Tag <em>key</em> <em>transactions</em>",
        "tags": "<em>Key</em> <em>transactions</em>",
        "body": "In <em>APM</em>, you can assign tags to <em>key</em> <em>transactions</em>. Tags are metadata associated with <em>transactions</em>. They&#x27;re useful for applying to <em>transactions</em> that have things in common. For example, you might apply a checkout tag to all <em>key</em> <em>transactions</em> that are part of the checkout process. Then you can filter"
      },
      "id": "603eb18928ccbc564deba79d"
    },
    {
      "sections": [
        "Create and update key transactions",
        "Create key transactions",
        "From the key transaction index",
        "From a specific transaction page",
        "Rename a key transaction",
        "Change Apdex settings",
        "Important",
        "Delete key transactions"
      ],
      "title": "Create and update key transactions",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Key transactions"
      ],
      "external_id": "b62aaaec4cfc8c108262c4d310cecfd8f9cc081e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/key-transactions/create-update-key-transactions/",
      "published_at": "2021-07-02T09:42:05Z",
      "updated_at": "2021-03-16T07:16:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, you can make a transaction a key transaction when you want it to have a custom level of monitoring, or when you want it to have its own alert policy. For most New Relic agents, a key transaction can be any type of transaction. For the PHP, Node.js, and Go agents, only web transactions can be turned into key transactions. Create key transactions There are two ways to create a key transaction: From the key transaction index Go to one.newrelic.com > More > Key transactions to view the key transactions index. Select Add more. From a specific transaction page Go to one.newrelic.com > APM > (select an app) > Summary In the center of the page under Transactions, select a record. Select Track as key transaction. Rename a key transaction Here's how to rename: Go to one.newrelic.com > More > Key transactions. From the index, select the gear icon for the key transaction you want to rename. Enter a new name for the transaction, then save. Change Apdex settings You can set a custom Apdex threshold for a key transaction if it is a web transaction. (Apdex is not applicable for non-web-transactions.) This is useful if the transaction is expected to be faster or slower than other transactions. Important Key transaction Apdex settings override the T value set for that app. This can mean, for example, that a key transaction could be reported as Satisfied but a different transaction in the same app with the same response time could be Frustrated. To change a key transaction's Apdex threshold: Go to one.newrelic.com > More > Key transactions. Select the icon for the transaction you want to edit. Enter a new value in seconds under the Apdex T heading, then save. The Apdex threshold affects how key transaction traces are created. Delete key transactions To delete a key transaction: Go to one.newrelic.com > More > Key transactions. Select the gear icon for the key transaction you want to delete. Select Stop tracking. New Relic automatically deletes any associated alerts and events for the deleted key transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.39581,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create and update <em>key</em> <em>transactions</em>",
        "sections": "Create and update <em>key</em> <em>transactions</em>",
        "tags": "<em>Key</em> <em>transactions</em>",
        "body": "In <em>APM</em>, you can make a transaction a <em>key</em> transaction when you want it to have a custom level of monitoring, or when you want it to have its own alert policy. For most New Relic agents, a <em>key</em> transaction can be any type of transaction. For the PHP, Node.js, and Go agents, only web <em>transactions</em> can"
      },
      "id": "603ec83364441f03b44e888f"
    },
    {
      "sections": [
        "Key transaction charts and data",
        "Overview page",
        "SLA report page",
        "Alerts"
      ],
      "title": "Key transaction charts and data",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Key transactions"
      ],
      "external_id": "7eee1868178054d18f55452b0989d724546d8016",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/key-transactions/key-transaction-charts-data/",
      "published_at": "2021-07-02T08:56:42Z",
      "updated_at": "2021-03-16T06:47:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, every key transaction has its own Overview page and several other UI pages. Depending on the type of transaction (web or non-web), different information appears. Overview page When you select a transaction from the key transaction index, the key transaction's Overview page appears. The Overview page contains charts for response time, Apdex, throughput, and other data. It is similar to the main Overview page in New Relic APM, with standard New Relic page functions. SLA report page The SLA report page for a key transaction displays Service Level Agreement reports for that transaction. The SLA reports include daily and weekly data about throughput, response time, and Apdex. You can also download the report as a comma-separated value (CSV) spreadsheet. Alerts When you select a transaction from the key transaction index, you can also see options to view alert condition violations and set alert policies.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.39334,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Key</em> <em>transaction</em> charts and data",
        "sections": "<em>Key</em> <em>transaction</em> charts and data",
        "tags": "<em>Key</em> <em>transactions</em>",
        "body": "In <em>APM</em>, every <em>key</em> transaction has its own Overview page and several other UI pages. Depending on the type of transaction (web or non-web), different information appears. Overview page When you select a transaction from the <em>key</em> transaction index, the <em>key</em> transaction&#x27;s Overview page appears"
      },
      "id": "603ebd1128ccbc1ceaeba784"
    }
  ],
  "/docs/apm/transactions/key-transactions/key-transaction-alerts": [
    {
      "sections": [
        "Tag key transactions",
        "Assign tags",
        "Tip",
        "Tag multiple transactions",
        "Filter"
      ],
      "title": "Tag key transactions",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Key transactions"
      ],
      "external_id": "760fa0d256c1404a48c8ff06a744c8a0cbd81874",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/key-transactions/tag-key-transactions/",
      "published_at": "2021-07-02T09:09:01Z",
      "updated_at": "2021-03-16T08:22:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, you can assign tags to key transactions. Tags are metadata associated with transactions. They're useful for applying to transactions that have things in common. For example, you might apply a checkout tag to all key transactions that are part of the checkout process. Then you can filter by checkout to see all of those transactions in one place. Assign tags To assign a tag to a key transaction: Go to one.newrelic.com > More > Key transactions. From the index page, select the tag icon beside the name of the transaction you want to tag. In the tag name box, type the tag's name. Press space to apply the tag. Tip Use any Unicode characters except commas , , angle brackets < >, parentheses ( ), or square brackets [ ]. Select outside the tag name box to exit tag creation. Tag multiple transactions You can assign a tag to all visible transactions in the index: Go to one.newrelic.com > More > Key transactions. Follow the tag creation instructions in Assign tags. To remove a bulk tag: From the bulk tag dropdown, select a tag name's x symbol. Filter To filter the key transaction index by tags: In the key transaction index search field, select the dropdown icon and select by tags. Type in the tag name.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.40144,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Tag <em>key</em> <em>transactions</em>",
        "sections": "Tag <em>key</em> <em>transactions</em>",
        "tags": "<em>Key</em> <em>transactions</em>",
        "body": "In <em>APM</em>, you can assign tags to <em>key</em> <em>transactions</em>. Tags are metadata associated with <em>transactions</em>. They&#x27;re useful for applying to <em>transactions</em> that have things in common. For example, you might apply a checkout tag to all <em>key</em> <em>transactions</em> that are part of the checkout process. Then you can filter"
      },
      "id": "603eb18928ccbc564deba79d"
    },
    {
      "sections": [
        "Introduction to key transactions",
        "What are key transactions?",
        "Create key transactions",
        "View key transactions in UI"
      ],
      "title": "Introduction to key transactions",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Key transactions"
      ],
      "external_id": "1224901400c4406015b22afe036d35ec3bb569bd",
      "image": "https://docs.newrelic.com/static/f5ea2688bbb03f205aef5cfbc5d04e30/e6c84/key-trx-overview.png",
      "url": "https://docs.newrelic.com/docs/apm/transactions/key-transactions/introduction-key-transactions/",
      "published_at": "2021-07-02T09:42:05Z",
      "updated_at": "2021-03-16T08:22:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, you can make a transaction a key transaction when you want it to have a custom level of monitoring, or when you want it to have its own alert policy. These may be web transactions or non-web transactions that are important to your business. For most New Relic agents, a key transaction can be any type of transaction. For the PHP, Node.js, and Go agents, only web transactions can be turned into key transactions. What are key transactions? In New Relic APM, making a transaction a key transaction gives you the following benefits: Key transactions are grouped together in the New Relic UI, so they are easy to find and examine. You can set a custom Apdex threshold for a key transaction. You can set an alert policy for a key transaction. Key transactions are useful for: Important transactions. For your app's most important transactions, making them key transactions means you can quickly find and examine them. You can set stricter Apdex requirements for them, and you can create alert policies for them. Slow transactions. If a transaction is regularly slower than other transactions, it can bring down the Apdex score of the entire application. When you make a transaction a key transaction, you can set a longer-duration Apdex threshold for it so it won't bring down your app's Apdex score. Create key transactions To create key transactions, see Create and update key transactions. View key transactions in UI The key transaction's page includes response time and throughput charts, service-level agreement information, a cross application tracing map (if available), and links to alert policy options. The key transaction index is a list of your key transactions: Go to one.newrelic.com > More > Key transactions > (select a transaction). Select a Key transaction from the index. View the selected key transaction's Summary page, including charts and drilldown options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.40143,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>key</em> <em>transactions</em>",
        "sections": "Introduction to <em>key</em> <em>transactions</em>",
        "tags": "<em>Key</em> <em>transactions</em>",
        "body": "In <em>APM</em>, you can make a transaction a <em>key</em> transaction when you want it to have a custom level of monitoring, or when you want it to have its own alert policy. These may be web <em>transactions</em> or non-web <em>transactions</em> that are important to your business. For most New Relic agents, a <em>key</em> transaction can"
      },
      "id": "603eb18a28ccbc564deba7a0"
    },
    {
      "sections": [
        "Create and update key transactions",
        "Create key transactions",
        "From the key transaction index",
        "From a specific transaction page",
        "Rename a key transaction",
        "Change Apdex settings",
        "Important",
        "Delete key transactions"
      ],
      "title": "Create and update key transactions",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Key transactions"
      ],
      "external_id": "b62aaaec4cfc8c108262c4d310cecfd8f9cc081e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/key-transactions/create-update-key-transactions/",
      "published_at": "2021-07-02T09:42:05Z",
      "updated_at": "2021-03-16T07:16:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, you can make a transaction a key transaction when you want it to have a custom level of monitoring, or when you want it to have its own alert policy. For most New Relic agents, a key transaction can be any type of transaction. For the PHP, Node.js, and Go agents, only web transactions can be turned into key transactions. Create key transactions There are two ways to create a key transaction: From the key transaction index Go to one.newrelic.com > More > Key transactions to view the key transactions index. Select Add more. From a specific transaction page Go to one.newrelic.com > APM > (select an app) > Summary In the center of the page under Transactions, select a record. Select Track as key transaction. Rename a key transaction Here's how to rename: Go to one.newrelic.com > More > Key transactions. From the index, select the gear icon for the key transaction you want to rename. Enter a new name for the transaction, then save. Change Apdex settings You can set a custom Apdex threshold for a key transaction if it is a web transaction. (Apdex is not applicable for non-web-transactions.) This is useful if the transaction is expected to be faster or slower than other transactions. Important Key transaction Apdex settings override the T value set for that app. This can mean, for example, that a key transaction could be reported as Satisfied but a different transaction in the same app with the same response time could be Frustrated. To change a key transaction's Apdex threshold: Go to one.newrelic.com > More > Key transactions. Select the icon for the transaction you want to edit. Enter a new value in seconds under the Apdex T heading, then save. The Apdex threshold affects how key transaction traces are created. Delete key transactions To delete a key transaction: Go to one.newrelic.com > More > Key transactions. Select the gear icon for the key transaction you want to delete. Select Stop tracking. New Relic automatically deletes any associated alerts and events for the deleted key transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.39581,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create and update <em>key</em> <em>transactions</em>",
        "sections": "Create and update <em>key</em> <em>transactions</em>",
        "tags": "<em>Key</em> <em>transactions</em>",
        "body": "In <em>APM</em>, you can make a transaction a <em>key</em> transaction when you want it to have a custom level of monitoring, or when you want it to have its own alert policy. For most New Relic agents, a <em>key</em> transaction can be any type of transaction. For the PHP, Node.js, and Go agents, only web <em>transactions</em> can"
      },
      "id": "603ec83364441f03b44e888f"
    }
  ],
  "/docs/apm/transactions/key-transactions/key-transaction-charts-data": [
    {
      "sections": [
        "Tag key transactions",
        "Assign tags",
        "Tip",
        "Tag multiple transactions",
        "Filter"
      ],
      "title": "Tag key transactions",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Key transactions"
      ],
      "external_id": "760fa0d256c1404a48c8ff06a744c8a0cbd81874",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/key-transactions/tag-key-transactions/",
      "published_at": "2021-07-02T09:09:01Z",
      "updated_at": "2021-03-16T08:22:43Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, you can assign tags to key transactions. Tags are metadata associated with transactions. They're useful for applying to transactions that have things in common. For example, you might apply a checkout tag to all key transactions that are part of the checkout process. Then you can filter by checkout to see all of those transactions in one place. Assign tags To assign a tag to a key transaction: Go to one.newrelic.com > More > Key transactions. From the index page, select the tag icon beside the name of the transaction you want to tag. In the tag name box, type the tag's name. Press space to apply the tag. Tip Use any Unicode characters except commas , , angle brackets < >, parentheses ( ), or square brackets [ ]. Select outside the tag name box to exit tag creation. Tag multiple transactions You can assign a tag to all visible transactions in the index: Go to one.newrelic.com > More > Key transactions. Follow the tag creation instructions in Assign tags. To remove a bulk tag: From the bulk tag dropdown, select a tag name's x symbol. Filter To filter the key transaction index by tags: In the key transaction index search field, select the dropdown icon and select by tags. Type in the tag name.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.40144,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Tag <em>key</em> <em>transactions</em>",
        "sections": "Tag <em>key</em> <em>transactions</em>",
        "tags": "<em>Key</em> <em>transactions</em>",
        "body": "In <em>APM</em>, you can assign tags to <em>key</em> <em>transactions</em>. Tags are metadata associated with <em>transactions</em>. They&#x27;re useful for applying to <em>transactions</em> that have things in common. For example, you might apply a checkout tag to all <em>key</em> <em>transactions</em> that are part of the checkout process. Then you can filter"
      },
      "id": "603eb18928ccbc564deba79d"
    },
    {
      "sections": [
        "Introduction to key transactions",
        "What are key transactions?",
        "Create key transactions",
        "View key transactions in UI"
      ],
      "title": "Introduction to key transactions",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Key transactions"
      ],
      "external_id": "1224901400c4406015b22afe036d35ec3bb569bd",
      "image": "https://docs.newrelic.com/static/f5ea2688bbb03f205aef5cfbc5d04e30/e6c84/key-trx-overview.png",
      "url": "https://docs.newrelic.com/docs/apm/transactions/key-transactions/introduction-key-transactions/",
      "published_at": "2021-07-02T09:42:05Z",
      "updated_at": "2021-03-16T08:22:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, you can make a transaction a key transaction when you want it to have a custom level of monitoring, or when you want it to have its own alert policy. These may be web transactions or non-web transactions that are important to your business. For most New Relic agents, a key transaction can be any type of transaction. For the PHP, Node.js, and Go agents, only web transactions can be turned into key transactions. What are key transactions? In New Relic APM, making a transaction a key transaction gives you the following benefits: Key transactions are grouped together in the New Relic UI, so they are easy to find and examine. You can set a custom Apdex threshold for a key transaction. You can set an alert policy for a key transaction. Key transactions are useful for: Important transactions. For your app's most important transactions, making them key transactions means you can quickly find and examine them. You can set stricter Apdex requirements for them, and you can create alert policies for them. Slow transactions. If a transaction is regularly slower than other transactions, it can bring down the Apdex score of the entire application. When you make a transaction a key transaction, you can set a longer-duration Apdex threshold for it so it won't bring down your app's Apdex score. Create key transactions To create key transactions, see Create and update key transactions. View key transactions in UI The key transaction's page includes response time and throughput charts, service-level agreement information, a cross application tracing map (if available), and links to alert policy options. The key transaction index is a list of your key transactions: Go to one.newrelic.com > More > Key transactions > (select a transaction). Select a Key transaction from the index. View the selected key transaction's Summary page, including charts and drilldown options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.40143,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>key</em> <em>transactions</em>",
        "sections": "Introduction to <em>key</em> <em>transactions</em>",
        "tags": "<em>Key</em> <em>transactions</em>",
        "body": "In <em>APM</em>, you can make a transaction a <em>key</em> transaction when you want it to have a custom level of monitoring, or when you want it to have its own alert policy. These may be web <em>transactions</em> or non-web <em>transactions</em> that are important to your business. For most New Relic agents, a <em>key</em> transaction can"
      },
      "id": "603eb18a28ccbc564deba7a0"
    },
    {
      "sections": [
        "Create and update key transactions",
        "Create key transactions",
        "From the key transaction index",
        "From a specific transaction page",
        "Rename a key transaction",
        "Change Apdex settings",
        "Important",
        "Delete key transactions"
      ],
      "title": "Create and update key transactions",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Key transactions"
      ],
      "external_id": "b62aaaec4cfc8c108262c4d310cecfd8f9cc081e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/key-transactions/create-update-key-transactions/",
      "published_at": "2021-07-02T09:42:05Z",
      "updated_at": "2021-03-16T07:16:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, you can make a transaction a key transaction when you want it to have a custom level of monitoring, or when you want it to have its own alert policy. For most New Relic agents, a key transaction can be any type of transaction. For the PHP, Node.js, and Go agents, only web transactions can be turned into key transactions. Create key transactions There are two ways to create a key transaction: From the key transaction index Go to one.newrelic.com > More > Key transactions to view the key transactions index. Select Add more. From a specific transaction page Go to one.newrelic.com > APM > (select an app) > Summary In the center of the page under Transactions, select a record. Select Track as key transaction. Rename a key transaction Here's how to rename: Go to one.newrelic.com > More > Key transactions. From the index, select the gear icon for the key transaction you want to rename. Enter a new name for the transaction, then save. Change Apdex settings You can set a custom Apdex threshold for a key transaction if it is a web transaction. (Apdex is not applicable for non-web-transactions.) This is useful if the transaction is expected to be faster or slower than other transactions. Important Key transaction Apdex settings override the T value set for that app. This can mean, for example, that a key transaction could be reported as Satisfied but a different transaction in the same app with the same response time could be Frustrated. To change a key transaction's Apdex threshold: Go to one.newrelic.com > More > Key transactions. Select the icon for the transaction you want to edit. Enter a new value in seconds under the Apdex T heading, then save. The Apdex threshold affects how key transaction traces are created. Delete key transactions To delete a key transaction: Go to one.newrelic.com > More > Key transactions. Select the gear icon for the key transaction you want to delete. Select Stop tracking. New Relic automatically deletes any associated alerts and events for the deleted key transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.39581,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create and update <em>key</em> <em>transactions</em>",
        "sections": "Create and update <em>key</em> <em>transactions</em>",
        "tags": "<em>Key</em> <em>transactions</em>",
        "body": "In <em>APM</em>, you can make a transaction a <em>key</em> transaction when you want it to have a custom level of monitoring, or when you want it to have its own alert policy. For most New Relic agents, a <em>key</em> transaction can be any type of transaction. For the PHP, Node.js, and Go agents, only web <em>transactions</em> can"
      },
      "id": "603ec83364441f03b44e888f"
    }
  ],
  "/docs/apm/transactions/key-transactions/tag-key-transactions": [
    {
      "sections": [
        "Introduction to key transactions",
        "What are key transactions?",
        "Create key transactions",
        "View key transactions in UI"
      ],
      "title": "Introduction to key transactions",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Key transactions"
      ],
      "external_id": "1224901400c4406015b22afe036d35ec3bb569bd",
      "image": "https://docs.newrelic.com/static/f5ea2688bbb03f205aef5cfbc5d04e30/e6c84/key-trx-overview.png",
      "url": "https://docs.newrelic.com/docs/apm/transactions/key-transactions/introduction-key-transactions/",
      "published_at": "2021-07-02T09:42:05Z",
      "updated_at": "2021-03-16T08:22:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, you can make a transaction a key transaction when you want it to have a custom level of monitoring, or when you want it to have its own alert policy. These may be web transactions or non-web transactions that are important to your business. For most New Relic agents, a key transaction can be any type of transaction. For the PHP, Node.js, and Go agents, only web transactions can be turned into key transactions. What are key transactions? In New Relic APM, making a transaction a key transaction gives you the following benefits: Key transactions are grouped together in the New Relic UI, so they are easy to find and examine. You can set a custom Apdex threshold for a key transaction. You can set an alert policy for a key transaction. Key transactions are useful for: Important transactions. For your app's most important transactions, making them key transactions means you can quickly find and examine them. You can set stricter Apdex requirements for them, and you can create alert policies for them. Slow transactions. If a transaction is regularly slower than other transactions, it can bring down the Apdex score of the entire application. When you make a transaction a key transaction, you can set a longer-duration Apdex threshold for it so it won't bring down your app's Apdex score. Create key transactions To create key transactions, see Create and update key transactions. View key transactions in UI The key transaction's page includes response time and throughput charts, service-level agreement information, a cross application tracing map (if available), and links to alert policy options. The key transaction index is a list of your key transactions: Go to one.newrelic.com > More > Key transactions > (select a transaction). Select a Key transaction from the index. View the selected key transaction's Summary page, including charts and drilldown options.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.40143,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>key</em> <em>transactions</em>",
        "sections": "Introduction to <em>key</em> <em>transactions</em>",
        "tags": "<em>Key</em> <em>transactions</em>",
        "body": "In <em>APM</em>, you can make a transaction a <em>key</em> transaction when you want it to have a custom level of monitoring, or when you want it to have its own alert policy. These may be web <em>transactions</em> or non-web <em>transactions</em> that are important to your business. For most New Relic agents, a <em>key</em> transaction can"
      },
      "id": "603eb18a28ccbc564deba7a0"
    },
    {
      "sections": [
        "Create and update key transactions",
        "Create key transactions",
        "From the key transaction index",
        "From a specific transaction page",
        "Rename a key transaction",
        "Change Apdex settings",
        "Important",
        "Delete key transactions"
      ],
      "title": "Create and update key transactions",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Key transactions"
      ],
      "external_id": "b62aaaec4cfc8c108262c4d310cecfd8f9cc081e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/key-transactions/create-update-key-transactions/",
      "published_at": "2021-07-02T09:42:05Z",
      "updated_at": "2021-03-16T07:16:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, you can make a transaction a key transaction when you want it to have a custom level of monitoring, or when you want it to have its own alert policy. For most New Relic agents, a key transaction can be any type of transaction. For the PHP, Node.js, and Go agents, only web transactions can be turned into key transactions. Create key transactions There are two ways to create a key transaction: From the key transaction index Go to one.newrelic.com > More > Key transactions to view the key transactions index. Select Add more. From a specific transaction page Go to one.newrelic.com > APM > (select an app) > Summary In the center of the page under Transactions, select a record. Select Track as key transaction. Rename a key transaction Here's how to rename: Go to one.newrelic.com > More > Key transactions. From the index, select the gear icon for the key transaction you want to rename. Enter a new name for the transaction, then save. Change Apdex settings You can set a custom Apdex threshold for a key transaction if it is a web transaction. (Apdex is not applicable for non-web-transactions.) This is useful if the transaction is expected to be faster or slower than other transactions. Important Key transaction Apdex settings override the T value set for that app. This can mean, for example, that a key transaction could be reported as Satisfied but a different transaction in the same app with the same response time could be Frustrated. To change a key transaction's Apdex threshold: Go to one.newrelic.com > More > Key transactions. Select the icon for the transaction you want to edit. Enter a new value in seconds under the Apdex T heading, then save. The Apdex threshold affects how key transaction traces are created. Delete key transactions To delete a key transaction: Go to one.newrelic.com > More > Key transactions. Select the gear icon for the key transaction you want to delete. Select Stop tracking. New Relic automatically deletes any associated alerts and events for the deleted key transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.39581,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create and update <em>key</em> <em>transactions</em>",
        "sections": "Create and update <em>key</em> <em>transactions</em>",
        "tags": "<em>Key</em> <em>transactions</em>",
        "body": "In <em>APM</em>, you can make a transaction a <em>key</em> transaction when you want it to have a custom level of monitoring, or when you want it to have its own alert policy. For most New Relic agents, a <em>key</em> transaction can be any type of transaction. For the PHP, Node.js, and Go agents, only web <em>transactions</em> can"
      },
      "id": "603ec83364441f03b44e888f"
    },
    {
      "sections": [
        "Key transaction charts and data",
        "Overview page",
        "SLA report page",
        "Alerts"
      ],
      "title": "Key transaction charts and data",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Key transactions"
      ],
      "external_id": "7eee1868178054d18f55452b0989d724546d8016",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/key-transactions/key-transaction-charts-data/",
      "published_at": "2021-07-02T08:56:42Z",
      "updated_at": "2021-03-16T06:47:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, every key transaction has its own Overview page and several other UI pages. Depending on the type of transaction (web or non-web), different information appears. Overview page When you select a transaction from the key transaction index, the key transaction's Overview page appears. The Overview page contains charts for response time, Apdex, throughput, and other data. It is similar to the main Overview page in New Relic APM, with standard New Relic page functions. SLA report page The SLA report page for a key transaction displays Service Level Agreement reports for that transaction. The SLA reports include daily and weekly data about throughput, response time, and Apdex. You can also download the report as a comma-separated value (CSV) spreadsheet. Alerts When you select a transaction from the key transaction index, you can also see options to view alert condition violations and set alert policies.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.39334,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Key</em> <em>transaction</em> charts and data",
        "sections": "<em>Key</em> <em>transaction</em> charts and data",
        "tags": "<em>Key</em> <em>transactions</em>",
        "body": "In <em>APM</em>, every <em>key</em> transaction has its own Overview page and several other UI pages. Depending on the type of transaction (web or non-web), different information appears. Overview page When you select a transaction from the <em>key</em> transaction index, the <em>key</em> transaction&#x27;s Overview page appears"
      },
      "id": "603ebd1128ccbc1ceaeba784"
    }
  ],
  "/docs/apm/transactions/transaction-traces/configure-transaction-traces": [
    {
      "sections": [
        "Introduction to transaction traces",
        "What transactions record traces",
        "Configure transaction traces",
        "View transaction traces in UI",
        "Troubleshoot an issue with transaction traces"
      ],
      "title": "Introduction to transaction traces",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "b2a6521e60a66ca6e5b731b0c4fe7c80abe32675",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/introduction-transaction-traces/",
      "published_at": "2021-07-02T09:09:02Z",
      "updated_at": "2021-03-29T16:45:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, a transaction trace gives a detailed snapshot of a single transaction in your application. A transaction trace records the available function calls, database calls, and external calls. You can use transaction traces to troubleshoot performance issues and to get detailed low-level insight into how your app is working. What transactions record traces In APM, a transaction trace records the segments that make up a transaction. Because they give you more detail, you can use transaction traces to analyze and troubleshoot performance issues. Here are the default rules that govern which transactions a New Relic agent traces: Over the minute-long harvest cycle, all transactions that violate the threshold (either four times your Apdex T value or a specific number of seconds) are added to a pool of transactions. At the end of that minute, the New Relic agent selects the slowest transaction in that pool and performs a transaction trace on it. These are the general rules, but there are some agent-specific differences. For example: The Java agent collects occasional non-slow transactions. If one transaction is frequently traced, some agents will select other transactions to give a more diverse sampling. If you don't see traces in your account, it's possible that no transactions meet the necessary criteria. In this situation, you can adjust transaction trace settings to ensure some transactions will be traced. If you use Synthetic, you will likely have Synthetic monitor traces. Synthetic traces can happen more frequently than APM traces, potentially several per minute. Configure transaction traces To configure or edit trace settings, see the procedures for: Transaction traces Key transaction traces View transaction traces in UI To view transaction traces: Do one of the following: New Relic Explorer: Go to one.newrelic.com > Explorer > (select an app) > Monitor > Transactions. APM: Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions. In the Transaction traces section, click transaction traces to view additional details. Troubleshoot an issue with transaction traces If you expect to see transaction traces but do not see them, follow the troubleshooting procedures. For more information about using transaction traces, slow queries, and service maps to solve performance issues, see Analyze performance issues.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.60966,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>transaction</em> <em>traces</em>",
        "sections": "What <em>transactions</em> record <em>traces</em>",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": " into how your app is working. What <em>transactions</em> record <em>traces</em> In <em>APM</em>, a <em>transaction</em> <em>trace</em> records the segments that make up a <em>transaction</em>. Because they give you more detail, you can use <em>transaction</em> <em>traces</em> to analyze and troubleshoot performance issues. Here are the default rules that govern which"
      },
      "id": "603ebebae7b9d268562a07c8"
    },
    {
      "sections": [
        "Transaction traces: Trace details page",
        "Trace details page functions",
        "Drilldown options",
        "Color coding of segment duration data",
        "Application code in traces",
        "Partial traces",
        "Segment grouping rules"
      ],
      "title": "Transaction traces: Trace details page",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "77871dbce9242fbbb6bee421b1d6b7cd5e77a9d6",
      "image": "https://docs.newrelic.com/static/e1099bd92081eca96a51c0f0f27f8a65/c1b63/trx-trace-details.png",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/transaction-traces-trace-details-page/",
      "published_at": "2021-07-02T09:12:04Z",
      "updated_at": "2021-03-16T08:23:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, the Trace details tab shows the timing of individual segments in a transaction trace. This document describes the sections and features of the Trace details tab. Trace details page functions Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions > (select a transaction trace) > Trace details. The Trace details page displays a table with the timing data for the segments in a transaction, plus additional features and functions: Trace details page Description Primary trace data, functions The top of each transaction trace UI page shows several primary pieces of data, including the trace time, response time, and, if available, CPU info. Also, sometimes the UI may indicate a partial trace. Available functions include: Delete this trace: When you delete a trace, it cannot be retrieved. Track as key transaction. Duration column The duration of each segment and subsegment is shown as both the number of milliseconds and a percentage of the total transaction time. Especially slow segments are color-coded. Segment column The Segment column displays segment names and counts. Fast and repeat calls may be automatically grouped together. Sometimes you may see Application code as the name of a segment or subsegment. To expand segments, use either of the following: The Expand performance problems button at the top of the page The expand and collapse dropdown arrows next to the segments Drilldown column The Drilldown column may contain icons that link to additional transaction data, if available. Timestamp column The Timestamp column displays the start time of a segment or subsegment, relative to the start of the transaction. For example, a value of 3.150 s indicates that that segment started 3.15 seconds into the transaction. Drilldown options In the Drilldown column, icons indicate that additional data is available: Icon Description Database queries The database icon links to the raw database query for that query segment. Depending on your transaction trace settings, this query can either show as raw data or obfuscated data. If the total time for the segment exceeds the query plan threshold in your settings, the query analysis also will appear, along with a stack trace showing the exact location of the call in your code. Stack traces The magnifying glass links to stack trace details. Aggregate transaction details This icon indicates that cross application tracing details are not available. However, you can select this icon to view aggregated transaction information across multiple invocations of the transaction. Color coding of segment duration data The Duration column of the Trace details table is color-coded: Red: More than 25% of the total transaction time was spent in this segment. Yellow: More than 5% of the total transaction time was spent in this segment. Color-coded durations do not necessarily indicate a problem. Whether the timing is actually a problem depends on what you consider normal and acceptable for your application. Application code in traces If a segment is listed as Application code in the table, it indicates that that section of code was not instrumented. You can use custom instrumentation to get more detail on that part of the code. Segments will often be listed as Application code for partial traces. Partial traces For performance reasons, New Relic APM only captures the first 2,000 segments of a transaction trace (900 for Node.js). If a transaction trace exceeds that number of segments, the agent truncates the transaction trace and displays a message at the top of the Details page: This is a partial trace. The New Relic APM agents have differing rules for when to truncate segments. APM agent Truncate segment rules C SDK Truncates based on segment priority: The root segment has the highest priority. Segments that have seen distributed tracing activity have second-highest priority. Slow segments have third-highest priority. For more information, see the C SDK's documentation about newrelic_transaction_tracer_config_t on GitHub. Go The segment duration must be greater than the TransactionTracer.SegmentThreshold value set in your Go segment configuration. Java, .NET, Ruby These agents truncate traces chronologically. For more information, see the transaction tracer documentation for Java, .NET, or Ruby as applicable. Node.js The Node.js agent only captures the first 900 segments of a transaction trace. For more information, see Node.js transaction tracer configuration. PHP Truncates based on segment duration; the slowest 2,000 segments are captured for the trace. For more information, see PHP transaction tracer configuration. Python Truncates based on segment duration; the slowest 2,000 segments are captured for the trace. For more information, see Python transaction tracer configuration. Segment grouping rules Transaction traces that have a lot of segments can be hard to interpret. New Relic helps you by automatically grouping fast and/or repeated method calls into a single segment grouping. For example, you might see a segment titled 7 fast method calls. This means that, because of their fast completion, New Relic assumed these calls were unlikely to be a problem and grouped them together. You can expand that grouping to see the individual segments. Rules underlying segment grouping include: Fast calls: When New Relic detects four or more consecutive segments with a duration of 7.5 ms or less, these are grouped into a single collapsed header. Identical calls: When New Relic detects four or more consecutive identical calls, this usually indicates an N+1 problem. These segments are collapsed. Expanding the collapsed node displays only the first three calls, not all calls.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 168.77519,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Transaction</em> <em>traces</em>: <em>Trace</em> details page",
        "sections": "<em>Transaction</em> <em>traces</em>: <em>Trace</em> details page",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": "In <em>APM</em>, the <em>Trace</em> details tab shows the timing of individual segments in a <em>transaction</em> <em>trace</em>. This document describes the sections and features of the <em>Trace</em> details tab. <em>Trace</em> details page functions Go to one.newrelic.com &gt; <em>APM</em> &gt; (select an app) &gt; Monitor &gt; <em>Transactions</em> &gt; (select a <em>transaction</em>"
      },
      "id": "603ebe83196a67703ca83dd0"
    },
    {
      "sections": [
        "Transaction traces: Database queries page",
        "Find Database queries",
        "Use Database queries",
        "Configure database query settings",
        "Use database queries to improve performance",
        "Find other slow queries"
      ],
      "title": "Transaction traces: Database queries page",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "035eebbf2be9b92ae90b6bc7a7707410643f9e63",
      "image": "https://docs.newrelic.com/static/e9137d3161de025f768e647dab00ee18/c1b63/APM-transaction-trace-database-queries.png",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/transaction-traces-database-queries-page/",
      "published_at": "2021-07-02T09:11:11Z",
      "updated_at": "2021-03-16T08:22:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, transaction traces can contain database query data. Use the Database queries page to analyze a slow transaction or change database query collection settings. Find Database queries If database query data is associated with your selected transaction trace, the Database queries page will be visible from the Transaction trace details page. If you expect to see database data for a transaction trace but don't see it, you may need to change the Database query settings. Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions > (select a transaction trace) > Database queries. Use Database queries Use the Database queries page to analyze and troubleshoot a slow transaction. For example: You notice on the APM Overview page that a transaction is abnormally slow. You select a transaction trace to get more details about that transaction. If the trace has associated database data, you select the Database queries page to examine the slow queries in the trace, and use them as the basis to troubleshoot and improve your app's performance. Other functions include: If you want to... Do this... View hidden queries By default, New Relic hides queries that take less than five milliseconds. To view these hidden queries, select the Show fast queries checkbox. View stack traces To view stack traces associated with a database query, click the database icon (in the table's Total duration column). Configure database query settings You can change database query settings in the same way you change other transaction trace settings; for example, via configuring the New Relic agent or, for some agents, via the UI. Common database query setting changes include: Collecting raw query data instead of obfuscated or turning off query collection Changing the stack trace threshold Turning on query explain plan collection Use database queries to improve performance Here are some tips to improve your app's database performance: Use database queries Comments Time Look for queries where the TOTAL DURATION contributes large amounts of time to the overall transaction time. This indicates a good place to try to enhance your database query with an index or some other optimization. Duplicate queries Look for queries that repeatedly query the same kind of information; for example, multiple queries to look up individual account IDs. Try rewriting the query to INCLUDE the specific values (account IDs 1, 2, 10, 14, 17, etc.) so that a single query can get all the relevant items. Database overhead Look at the structure of your queries to see if there are opportunities to combine different types of information into a single call; for example, querying for the account ID, name, etc. This is useful, for example, if your database center is in a different geographical location, because this will reduce overhead. The amount of time for your database request and response may be very fast. However, by combining requests into fewer calls, you can reduce that time even more. MySQL From your app's main APM Summary page, compare the database time on the main chart to other processing time. Sudden spikes or larger amounts of database time compared to other processing times may indicate problems. Find other slow queries The Trace details page is useful for examining a specific transaction's details. To see all of your application's slowest queries in one place, use the Slow queries feature.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 168.7751,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Transaction</em> <em>traces</em>: Database queries page",
        "sections": "<em>Transaction</em> <em>traces</em>: Database queries page",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": "In <em>APM</em>, <em>transaction</em> <em>traces</em> can contain database query data. Use the Database queries page to analyze a slow <em>transaction</em> or change database query collection settings. Find Database queries If database query data is associated with your selected <em>transaction</em> <em>trace</em>, the Database queries page"
      },
      "id": "603ebf09e7b9d22a5f2f945c"
    }
  ],
  "/docs/apm/transactions/transaction-traces/introduction-transaction-traces": [
    {
      "sections": [
        "Transaction traces: Trace details page",
        "Trace details page functions",
        "Drilldown options",
        "Color coding of segment duration data",
        "Application code in traces",
        "Partial traces",
        "Segment grouping rules"
      ],
      "title": "Transaction traces: Trace details page",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "77871dbce9242fbbb6bee421b1d6b7cd5e77a9d6",
      "image": "https://docs.newrelic.com/static/e1099bd92081eca96a51c0f0f27f8a65/c1b63/trx-trace-details.png",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/transaction-traces-trace-details-page/",
      "published_at": "2021-07-02T09:12:04Z",
      "updated_at": "2021-03-16T08:23:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, the Trace details tab shows the timing of individual segments in a transaction trace. This document describes the sections and features of the Trace details tab. Trace details page functions Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions > (select a transaction trace) > Trace details. The Trace details page displays a table with the timing data for the segments in a transaction, plus additional features and functions: Trace details page Description Primary trace data, functions The top of each transaction trace UI page shows several primary pieces of data, including the trace time, response time, and, if available, CPU info. Also, sometimes the UI may indicate a partial trace. Available functions include: Delete this trace: When you delete a trace, it cannot be retrieved. Track as key transaction. Duration column The duration of each segment and subsegment is shown as both the number of milliseconds and a percentage of the total transaction time. Especially slow segments are color-coded. Segment column The Segment column displays segment names and counts. Fast and repeat calls may be automatically grouped together. Sometimes you may see Application code as the name of a segment or subsegment. To expand segments, use either of the following: The Expand performance problems button at the top of the page The expand and collapse dropdown arrows next to the segments Drilldown column The Drilldown column may contain icons that link to additional transaction data, if available. Timestamp column The Timestamp column displays the start time of a segment or subsegment, relative to the start of the transaction. For example, a value of 3.150 s indicates that that segment started 3.15 seconds into the transaction. Drilldown options In the Drilldown column, icons indicate that additional data is available: Icon Description Database queries The database icon links to the raw database query for that query segment. Depending on your transaction trace settings, this query can either show as raw data or obfuscated data. If the total time for the segment exceeds the query plan threshold in your settings, the query analysis also will appear, along with a stack trace showing the exact location of the call in your code. Stack traces The magnifying glass links to stack trace details. Aggregate transaction details This icon indicates that cross application tracing details are not available. However, you can select this icon to view aggregated transaction information across multiple invocations of the transaction. Color coding of segment duration data The Duration column of the Trace details table is color-coded: Red: More than 25% of the total transaction time was spent in this segment. Yellow: More than 5% of the total transaction time was spent in this segment. Color-coded durations do not necessarily indicate a problem. Whether the timing is actually a problem depends on what you consider normal and acceptable for your application. Application code in traces If a segment is listed as Application code in the table, it indicates that that section of code was not instrumented. You can use custom instrumentation to get more detail on that part of the code. Segments will often be listed as Application code for partial traces. Partial traces For performance reasons, New Relic APM only captures the first 2,000 segments of a transaction trace (900 for Node.js). If a transaction trace exceeds that number of segments, the agent truncates the transaction trace and displays a message at the top of the Details page: This is a partial trace. The New Relic APM agents have differing rules for when to truncate segments. APM agent Truncate segment rules C SDK Truncates based on segment priority: The root segment has the highest priority. Segments that have seen distributed tracing activity have second-highest priority. Slow segments have third-highest priority. For more information, see the C SDK's documentation about newrelic_transaction_tracer_config_t on GitHub. Go The segment duration must be greater than the TransactionTracer.SegmentThreshold value set in your Go segment configuration. Java, .NET, Ruby These agents truncate traces chronologically. For more information, see the transaction tracer documentation for Java, .NET, or Ruby as applicable. Node.js The Node.js agent only captures the first 900 segments of a transaction trace. For more information, see Node.js transaction tracer configuration. PHP Truncates based on segment duration; the slowest 2,000 segments are captured for the trace. For more information, see PHP transaction tracer configuration. Python Truncates based on segment duration; the slowest 2,000 segments are captured for the trace. For more information, see Python transaction tracer configuration. Segment grouping rules Transaction traces that have a lot of segments can be hard to interpret. New Relic helps you by automatically grouping fast and/or repeated method calls into a single segment grouping. For example, you might see a segment titled 7 fast method calls. This means that, because of their fast completion, New Relic assumed these calls were unlikely to be a problem and grouped them together. You can expand that grouping to see the individual segments. Rules underlying segment grouping include: Fast calls: When New Relic detects four or more consecutive segments with a duration of 7.5 ms or less, these are grouped into a single collapsed header. Identical calls: When New Relic detects four or more consecutive identical calls, this usually indicates an N+1 problem. These segments are collapsed. Expanding the collapsed node displays only the first three calls, not all calls.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 168.77518,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Transaction</em> <em>traces</em>: <em>Trace</em> details page",
        "sections": "<em>Transaction</em> <em>traces</em>: <em>Trace</em> details page",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": "In <em>APM</em>, the <em>Trace</em> details tab shows the timing of individual segments in a <em>transaction</em> <em>trace</em>. This document describes the sections and features of the <em>Trace</em> details tab. <em>Trace</em> details page functions Go to one.newrelic.com &gt; <em>APM</em> &gt; (select an app) &gt; Monitor &gt; <em>Transactions</em> &gt; (select a <em>transaction</em>"
      },
      "id": "603ebe83196a67703ca83dd0"
    },
    {
      "sections": [
        "Transaction traces: Database queries page",
        "Find Database queries",
        "Use Database queries",
        "Configure database query settings",
        "Use database queries to improve performance",
        "Find other slow queries"
      ],
      "title": "Transaction traces: Database queries page",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "035eebbf2be9b92ae90b6bc7a7707410643f9e63",
      "image": "https://docs.newrelic.com/static/e9137d3161de025f768e647dab00ee18/c1b63/APM-transaction-trace-database-queries.png",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/transaction-traces-database-queries-page/",
      "published_at": "2021-07-02T09:11:11Z",
      "updated_at": "2021-03-16T08:22:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, transaction traces can contain database query data. Use the Database queries page to analyze a slow transaction or change database query collection settings. Find Database queries If database query data is associated with your selected transaction trace, the Database queries page will be visible from the Transaction trace details page. If you expect to see database data for a transaction trace but don't see it, you may need to change the Database query settings. Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions > (select a transaction trace) > Database queries. Use Database queries Use the Database queries page to analyze and troubleshoot a slow transaction. For example: You notice on the APM Overview page that a transaction is abnormally slow. You select a transaction trace to get more details about that transaction. If the trace has associated database data, you select the Database queries page to examine the slow queries in the trace, and use them as the basis to troubleshoot and improve your app's performance. Other functions include: If you want to... Do this... View hidden queries By default, New Relic hides queries that take less than five milliseconds. To view these hidden queries, select the Show fast queries checkbox. View stack traces To view stack traces associated with a database query, click the database icon (in the table's Total duration column). Configure database query settings You can change database query settings in the same way you change other transaction trace settings; for example, via configuring the New Relic agent or, for some agents, via the UI. Common database query setting changes include: Collecting raw query data instead of obfuscated or turning off query collection Changing the stack trace threshold Turning on query explain plan collection Use database queries to improve performance Here are some tips to improve your app's database performance: Use database queries Comments Time Look for queries where the TOTAL DURATION contributes large amounts of time to the overall transaction time. This indicates a good place to try to enhance your database query with an index or some other optimization. Duplicate queries Look for queries that repeatedly query the same kind of information; for example, multiple queries to look up individual account IDs. Try rewriting the query to INCLUDE the specific values (account IDs 1, 2, 10, 14, 17, etc.) so that a single query can get all the relevant items. Database overhead Look at the structure of your queries to see if there are opportunities to combine different types of information into a single call; for example, querying for the account ID, name, etc. This is useful, for example, if your database center is in a different geographical location, because this will reduce overhead. The amount of time for your database request and response may be very fast. However, by combining requests into fewer calls, you can reduce that time even more. MySQL From your app's main APM Summary page, compare the database time on the main chart to other processing time. Sudden spikes or larger amounts of database time compared to other processing times may indicate problems. Find other slow queries The Trace details page is useful for examining a specific transaction's details. To see all of your application's slowest queries in one place, use the Slow queries feature.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 168.77509,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Transaction</em> <em>traces</em>: Database queries page",
        "sections": "<em>Transaction</em> <em>traces</em>: Database queries page",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": "In <em>APM</em>, <em>transaction</em> <em>traces</em> can contain database query data. Use the Database queries page to analyze a slow <em>transaction</em> or change database query collection settings. Find Database queries If database query data is associated with your selected <em>transaction</em> <em>trace</em>, the Database queries page"
      },
      "id": "603ebf09e7b9d22a5f2f945c"
    },
    {
      "sections": [
        "Security and transaction traces",
        "Database queries",
        "HTTP request attributes and parameters",
        "High security mode"
      ],
      "title": "Security and transaction traces",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "75566cc4a263be7241db16af2553d4fb3ed3274d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/security-transaction-traces/",
      "published_at": "2021-07-02T09:10:02Z",
      "updated_at": "2021-03-16T07:18:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM transaction traces collect detailed data about your application's transactions. Because they collect detailed data from your app, transaction traces can be a potential security concern. This document explains how to configure transaction traces for your data security needs. Database queries The database query types collected by transaction traces vary by New Relic language agent. Query collection is a potential security and/or privacy concern because queries can contain sensitive values. You can customize database query collection with three different security settings: Obfuscated: This is the default value. This setting strips string literals and numeric sequences from your queries and replaces them with the ? character. For example: the query select * from table where ssn='123-45-6789' would become select * from table where ssn=?. Off: Query collection is turned off entirely. Raw: If you are confident that full query data collection will not impact your data security or your users' privacy, you can change the setting to Raw, which will record all query values. You can edit database query collection with the Record SQL setting, explained in Configure transaction traces. HTTP request attributes and parameters The collection of HTTP request data can expose potentially sensitive data. New Relic calls the key/value data collected during an HTTP request attributes. By default, the collection of attributes is limited to only basic HTTP information that is not a source of sensitive data (for example, response code and host); these are part of the group of basic attributes that New Relic refers to as agent attributes. For data security reasons, the collection of other attributes, including user-specific parameters, is disabled by default. For information on how to enable/disable the collection of specific HTTP attributes and custom attributes, see Configure transaction traces. High security mode New Relic's default settings provide a high level of security. To force the most secure settings for all the applications in your account, you can use the high security mode. This mode ensures that, no matter how your admins and users configure your account, the most secure settings are forced and cannot be overridden. For more information, see High security mode.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 168.76967,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Security and <em>transaction</em> <em>traces</em>",
        "sections": "Security and <em>transaction</em> <em>traces</em>",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": "<em>APM</em> <em>transaction</em> <em>traces</em> collect detailed data about your application&#x27;s <em>transactions</em>. Because they collect detailed data from your app, <em>transaction</em> <em>traces</em> can be a potential security concern. This document explains how to configure <em>transaction</em> <em>traces</em> for your data security needs. Database queries"
      },
      "id": "603ebf89196a676a5aa83df0"
    }
  ],
  "/docs/apm/transactions/transaction-traces/security-transaction-traces": [
    {
      "sections": [
        "Introduction to transaction traces",
        "What transactions record traces",
        "Configure transaction traces",
        "View transaction traces in UI",
        "Troubleshoot an issue with transaction traces"
      ],
      "title": "Introduction to transaction traces",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "b2a6521e60a66ca6e5b731b0c4fe7c80abe32675",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/introduction-transaction-traces/",
      "published_at": "2021-07-02T09:09:02Z",
      "updated_at": "2021-03-29T16:45:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, a transaction trace gives a detailed snapshot of a single transaction in your application. A transaction trace records the available function calls, database calls, and external calls. You can use transaction traces to troubleshoot performance issues and to get detailed low-level insight into how your app is working. What transactions record traces In APM, a transaction trace records the segments that make up a transaction. Because they give you more detail, you can use transaction traces to analyze and troubleshoot performance issues. Here are the default rules that govern which transactions a New Relic agent traces: Over the minute-long harvest cycle, all transactions that violate the threshold (either four times your Apdex T value or a specific number of seconds) are added to a pool of transactions. At the end of that minute, the New Relic agent selects the slowest transaction in that pool and performs a transaction trace on it. These are the general rules, but there are some agent-specific differences. For example: The Java agent collects occasional non-slow transactions. If one transaction is frequently traced, some agents will select other transactions to give a more diverse sampling. If you don't see traces in your account, it's possible that no transactions meet the necessary criteria. In this situation, you can adjust transaction trace settings to ensure some transactions will be traced. If you use Synthetic, you will likely have Synthetic monitor traces. Synthetic traces can happen more frequently than APM traces, potentially several per minute. Configure transaction traces To configure or edit trace settings, see the procedures for: Transaction traces Key transaction traces View transaction traces in UI To view transaction traces: Do one of the following: New Relic Explorer: Go to one.newrelic.com > Explorer > (select an app) > Monitor > Transactions. APM: Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions. In the Transaction traces section, click transaction traces to view additional details. Troubleshoot an issue with transaction traces If you expect to see transaction traces but do not see them, follow the troubleshooting procedures. For more information about using transaction traces, slow queries, and service maps to solve performance issues, see Analyze performance issues.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.60966,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>transaction</em> <em>traces</em>",
        "sections": "What <em>transactions</em> record <em>traces</em>",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": " into how your app is working. What <em>transactions</em> record <em>traces</em> In <em>APM</em>, a <em>transaction</em> <em>trace</em> records the segments that make up a <em>transaction</em>. Because they give you more detail, you can use <em>transaction</em> <em>traces</em> to analyze and troubleshoot performance issues. Here are the default rules that govern which"
      },
      "id": "603ebebae7b9d268562a07c8"
    },
    {
      "sections": [
        "Transaction traces: Trace details page",
        "Trace details page functions",
        "Drilldown options",
        "Color coding of segment duration data",
        "Application code in traces",
        "Partial traces",
        "Segment grouping rules"
      ],
      "title": "Transaction traces: Trace details page",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "77871dbce9242fbbb6bee421b1d6b7cd5e77a9d6",
      "image": "https://docs.newrelic.com/static/e1099bd92081eca96a51c0f0f27f8a65/c1b63/trx-trace-details.png",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/transaction-traces-trace-details-page/",
      "published_at": "2021-07-02T09:12:04Z",
      "updated_at": "2021-03-16T08:23:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, the Trace details tab shows the timing of individual segments in a transaction trace. This document describes the sections and features of the Trace details tab. Trace details page functions Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions > (select a transaction trace) > Trace details. The Trace details page displays a table with the timing data for the segments in a transaction, plus additional features and functions: Trace details page Description Primary trace data, functions The top of each transaction trace UI page shows several primary pieces of data, including the trace time, response time, and, if available, CPU info. Also, sometimes the UI may indicate a partial trace. Available functions include: Delete this trace: When you delete a trace, it cannot be retrieved. Track as key transaction. Duration column The duration of each segment and subsegment is shown as both the number of milliseconds and a percentage of the total transaction time. Especially slow segments are color-coded. Segment column The Segment column displays segment names and counts. Fast and repeat calls may be automatically grouped together. Sometimes you may see Application code as the name of a segment or subsegment. To expand segments, use either of the following: The Expand performance problems button at the top of the page The expand and collapse dropdown arrows next to the segments Drilldown column The Drilldown column may contain icons that link to additional transaction data, if available. Timestamp column The Timestamp column displays the start time of a segment or subsegment, relative to the start of the transaction. For example, a value of 3.150 s indicates that that segment started 3.15 seconds into the transaction. Drilldown options In the Drilldown column, icons indicate that additional data is available: Icon Description Database queries The database icon links to the raw database query for that query segment. Depending on your transaction trace settings, this query can either show as raw data or obfuscated data. If the total time for the segment exceeds the query plan threshold in your settings, the query analysis also will appear, along with a stack trace showing the exact location of the call in your code. Stack traces The magnifying glass links to stack trace details. Aggregate transaction details This icon indicates that cross application tracing details are not available. However, you can select this icon to view aggregated transaction information across multiple invocations of the transaction. Color coding of segment duration data The Duration column of the Trace details table is color-coded: Red: More than 25% of the total transaction time was spent in this segment. Yellow: More than 5% of the total transaction time was spent in this segment. Color-coded durations do not necessarily indicate a problem. Whether the timing is actually a problem depends on what you consider normal and acceptable for your application. Application code in traces If a segment is listed as Application code in the table, it indicates that that section of code was not instrumented. You can use custom instrumentation to get more detail on that part of the code. Segments will often be listed as Application code for partial traces. Partial traces For performance reasons, New Relic APM only captures the first 2,000 segments of a transaction trace (900 for Node.js). If a transaction trace exceeds that number of segments, the agent truncates the transaction trace and displays a message at the top of the Details page: This is a partial trace. The New Relic APM agents have differing rules for when to truncate segments. APM agent Truncate segment rules C SDK Truncates based on segment priority: The root segment has the highest priority. Segments that have seen distributed tracing activity have second-highest priority. Slow segments have third-highest priority. For more information, see the C SDK's documentation about newrelic_transaction_tracer_config_t on GitHub. Go The segment duration must be greater than the TransactionTracer.SegmentThreshold value set in your Go segment configuration. Java, .NET, Ruby These agents truncate traces chronologically. For more information, see the transaction tracer documentation for Java, .NET, or Ruby as applicable. Node.js The Node.js agent only captures the first 900 segments of a transaction trace. For more information, see Node.js transaction tracer configuration. PHP Truncates based on segment duration; the slowest 2,000 segments are captured for the trace. For more information, see PHP transaction tracer configuration. Python Truncates based on segment duration; the slowest 2,000 segments are captured for the trace. For more information, see Python transaction tracer configuration. Segment grouping rules Transaction traces that have a lot of segments can be hard to interpret. New Relic helps you by automatically grouping fast and/or repeated method calls into a single segment grouping. For example, you might see a segment titled 7 fast method calls. This means that, because of their fast completion, New Relic assumed these calls were unlikely to be a problem and grouped them together. You can expand that grouping to see the individual segments. Rules underlying segment grouping include: Fast calls: When New Relic detects four or more consecutive segments with a duration of 7.5 ms or less, these are grouped into a single collapsed header. Identical calls: When New Relic detects four or more consecutive identical calls, this usually indicates an N+1 problem. These segments are collapsed. Expanding the collapsed node displays only the first three calls, not all calls.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 168.77518,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Transaction</em> <em>traces</em>: <em>Trace</em> details page",
        "sections": "<em>Transaction</em> <em>traces</em>: <em>Trace</em> details page",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": "In <em>APM</em>, the <em>Trace</em> details tab shows the timing of individual segments in a <em>transaction</em> <em>trace</em>. This document describes the sections and features of the <em>Trace</em> details tab. <em>Trace</em> details page functions Go to one.newrelic.com &gt; <em>APM</em> &gt; (select an app) &gt; Monitor &gt; <em>Transactions</em> &gt; (select a <em>transaction</em>"
      },
      "id": "603ebe83196a67703ca83dd0"
    },
    {
      "sections": [
        "Transaction traces: Database queries page",
        "Find Database queries",
        "Use Database queries",
        "Configure database query settings",
        "Use database queries to improve performance",
        "Find other slow queries"
      ],
      "title": "Transaction traces: Database queries page",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "035eebbf2be9b92ae90b6bc7a7707410643f9e63",
      "image": "https://docs.newrelic.com/static/e9137d3161de025f768e647dab00ee18/c1b63/APM-transaction-trace-database-queries.png",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/transaction-traces-database-queries-page/",
      "published_at": "2021-07-02T09:11:11Z",
      "updated_at": "2021-03-16T08:22:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, transaction traces can contain database query data. Use the Database queries page to analyze a slow transaction or change database query collection settings. Find Database queries If database query data is associated with your selected transaction trace, the Database queries page will be visible from the Transaction trace details page. If you expect to see database data for a transaction trace but don't see it, you may need to change the Database query settings. Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions > (select a transaction trace) > Database queries. Use Database queries Use the Database queries page to analyze and troubleshoot a slow transaction. For example: You notice on the APM Overview page that a transaction is abnormally slow. You select a transaction trace to get more details about that transaction. If the trace has associated database data, you select the Database queries page to examine the slow queries in the trace, and use them as the basis to troubleshoot and improve your app's performance. Other functions include: If you want to... Do this... View hidden queries By default, New Relic hides queries that take less than five milliseconds. To view these hidden queries, select the Show fast queries checkbox. View stack traces To view stack traces associated with a database query, click the database icon (in the table's Total duration column). Configure database query settings You can change database query settings in the same way you change other transaction trace settings; for example, via configuring the New Relic agent or, for some agents, via the UI. Common database query setting changes include: Collecting raw query data instead of obfuscated or turning off query collection Changing the stack trace threshold Turning on query explain plan collection Use database queries to improve performance Here are some tips to improve your app's database performance: Use database queries Comments Time Look for queries where the TOTAL DURATION contributes large amounts of time to the overall transaction time. This indicates a good place to try to enhance your database query with an index or some other optimization. Duplicate queries Look for queries that repeatedly query the same kind of information; for example, multiple queries to look up individual account IDs. Try rewriting the query to INCLUDE the specific values (account IDs 1, 2, 10, 14, 17, etc.) so that a single query can get all the relevant items. Database overhead Look at the structure of your queries to see if there are opportunities to combine different types of information into a single call; for example, querying for the account ID, name, etc. This is useful, for example, if your database center is in a different geographical location, because this will reduce overhead. The amount of time for your database request and response may be very fast. However, by combining requests into fewer calls, you can reduce that time even more. MySQL From your app's main APM Summary page, compare the database time on the main chart to other processing time. Sudden spikes or larger amounts of database time compared to other processing times may indicate problems. Find other slow queries The Trace details page is useful for examining a specific transaction's details. To see all of your application's slowest queries in one place, use the Slow queries feature.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 168.77509,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Transaction</em> <em>traces</em>: Database queries page",
        "sections": "<em>Transaction</em> <em>traces</em>: Database queries page",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": "In <em>APM</em>, <em>transaction</em> <em>traces</em> can contain database query data. Use the Database queries page to analyze a slow <em>transaction</em> or change database query collection settings. Find Database queries If database query data is associated with your selected <em>transaction</em> <em>trace</em>, the Database queries page"
      },
      "id": "603ebf09e7b9d22a5f2f945c"
    }
  ],
  "/docs/apm/transactions/transaction-traces/transaction-traces-database-queries-page": [
    {
      "sections": [
        "Introduction to transaction traces",
        "What transactions record traces",
        "Configure transaction traces",
        "View transaction traces in UI",
        "Troubleshoot an issue with transaction traces"
      ],
      "title": "Introduction to transaction traces",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "b2a6521e60a66ca6e5b731b0c4fe7c80abe32675",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/introduction-transaction-traces/",
      "published_at": "2021-07-02T09:09:02Z",
      "updated_at": "2021-03-29T16:45:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, a transaction trace gives a detailed snapshot of a single transaction in your application. A transaction trace records the available function calls, database calls, and external calls. You can use transaction traces to troubleshoot performance issues and to get detailed low-level insight into how your app is working. What transactions record traces In APM, a transaction trace records the segments that make up a transaction. Because they give you more detail, you can use transaction traces to analyze and troubleshoot performance issues. Here are the default rules that govern which transactions a New Relic agent traces: Over the minute-long harvest cycle, all transactions that violate the threshold (either four times your Apdex T value or a specific number of seconds) are added to a pool of transactions. At the end of that minute, the New Relic agent selects the slowest transaction in that pool and performs a transaction trace on it. These are the general rules, but there are some agent-specific differences. For example: The Java agent collects occasional non-slow transactions. If one transaction is frequently traced, some agents will select other transactions to give a more diverse sampling. If you don't see traces in your account, it's possible that no transactions meet the necessary criteria. In this situation, you can adjust transaction trace settings to ensure some transactions will be traced. If you use Synthetic, you will likely have Synthetic monitor traces. Synthetic traces can happen more frequently than APM traces, potentially several per minute. Configure transaction traces To configure or edit trace settings, see the procedures for: Transaction traces Key transaction traces View transaction traces in UI To view transaction traces: Do one of the following: New Relic Explorer: Go to one.newrelic.com > Explorer > (select an app) > Monitor > Transactions. APM: Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions. In the Transaction traces section, click transaction traces to view additional details. Troubleshoot an issue with transaction traces If you expect to see transaction traces but do not see them, follow the troubleshooting procedures. For more information about using transaction traces, slow queries, and service maps to solve performance issues, see Analyze performance issues.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.60966,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>transaction</em> <em>traces</em>",
        "sections": "What <em>transactions</em> record <em>traces</em>",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": " into how your app is working. What <em>transactions</em> record <em>traces</em> In <em>APM</em>, a <em>transaction</em> <em>trace</em> records the segments that make up a <em>transaction</em>. Because they give you more detail, you can use <em>transaction</em> <em>traces</em> to analyze and troubleshoot performance issues. Here are the default rules that govern which"
      },
      "id": "603ebebae7b9d268562a07c8"
    },
    {
      "sections": [
        "Transaction traces: Trace details page",
        "Trace details page functions",
        "Drilldown options",
        "Color coding of segment duration data",
        "Application code in traces",
        "Partial traces",
        "Segment grouping rules"
      ],
      "title": "Transaction traces: Trace details page",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "77871dbce9242fbbb6bee421b1d6b7cd5e77a9d6",
      "image": "https://docs.newrelic.com/static/e1099bd92081eca96a51c0f0f27f8a65/c1b63/trx-trace-details.png",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/transaction-traces-trace-details-page/",
      "published_at": "2021-07-02T09:12:04Z",
      "updated_at": "2021-03-16T08:23:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, the Trace details tab shows the timing of individual segments in a transaction trace. This document describes the sections and features of the Trace details tab. Trace details page functions Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions > (select a transaction trace) > Trace details. The Trace details page displays a table with the timing data for the segments in a transaction, plus additional features and functions: Trace details page Description Primary trace data, functions The top of each transaction trace UI page shows several primary pieces of data, including the trace time, response time, and, if available, CPU info. Also, sometimes the UI may indicate a partial trace. Available functions include: Delete this trace: When you delete a trace, it cannot be retrieved. Track as key transaction. Duration column The duration of each segment and subsegment is shown as both the number of milliseconds and a percentage of the total transaction time. Especially slow segments are color-coded. Segment column The Segment column displays segment names and counts. Fast and repeat calls may be automatically grouped together. Sometimes you may see Application code as the name of a segment or subsegment. To expand segments, use either of the following: The Expand performance problems button at the top of the page The expand and collapse dropdown arrows next to the segments Drilldown column The Drilldown column may contain icons that link to additional transaction data, if available. Timestamp column The Timestamp column displays the start time of a segment or subsegment, relative to the start of the transaction. For example, a value of 3.150 s indicates that that segment started 3.15 seconds into the transaction. Drilldown options In the Drilldown column, icons indicate that additional data is available: Icon Description Database queries The database icon links to the raw database query for that query segment. Depending on your transaction trace settings, this query can either show as raw data or obfuscated data. If the total time for the segment exceeds the query plan threshold in your settings, the query analysis also will appear, along with a stack trace showing the exact location of the call in your code. Stack traces The magnifying glass links to stack trace details. Aggregate transaction details This icon indicates that cross application tracing details are not available. However, you can select this icon to view aggregated transaction information across multiple invocations of the transaction. Color coding of segment duration data The Duration column of the Trace details table is color-coded: Red: More than 25% of the total transaction time was spent in this segment. Yellow: More than 5% of the total transaction time was spent in this segment. Color-coded durations do not necessarily indicate a problem. Whether the timing is actually a problem depends on what you consider normal and acceptable for your application. Application code in traces If a segment is listed as Application code in the table, it indicates that that section of code was not instrumented. You can use custom instrumentation to get more detail on that part of the code. Segments will often be listed as Application code for partial traces. Partial traces For performance reasons, New Relic APM only captures the first 2,000 segments of a transaction trace (900 for Node.js). If a transaction trace exceeds that number of segments, the agent truncates the transaction trace and displays a message at the top of the Details page: This is a partial trace. The New Relic APM agents have differing rules for when to truncate segments. APM agent Truncate segment rules C SDK Truncates based on segment priority: The root segment has the highest priority. Segments that have seen distributed tracing activity have second-highest priority. Slow segments have third-highest priority. For more information, see the C SDK's documentation about newrelic_transaction_tracer_config_t on GitHub. Go The segment duration must be greater than the TransactionTracer.SegmentThreshold value set in your Go segment configuration. Java, .NET, Ruby These agents truncate traces chronologically. For more information, see the transaction tracer documentation for Java, .NET, or Ruby as applicable. Node.js The Node.js agent only captures the first 900 segments of a transaction trace. For more information, see Node.js transaction tracer configuration. PHP Truncates based on segment duration; the slowest 2,000 segments are captured for the trace. For more information, see PHP transaction tracer configuration. Python Truncates based on segment duration; the slowest 2,000 segments are captured for the trace. For more information, see Python transaction tracer configuration. Segment grouping rules Transaction traces that have a lot of segments can be hard to interpret. New Relic helps you by automatically grouping fast and/or repeated method calls into a single segment grouping. For example, you might see a segment titled 7 fast method calls. This means that, because of their fast completion, New Relic assumed these calls were unlikely to be a problem and grouped them together. You can expand that grouping to see the individual segments. Rules underlying segment grouping include: Fast calls: When New Relic detects four or more consecutive segments with a duration of 7.5 ms or less, these are grouped into a single collapsed header. Identical calls: When New Relic detects four or more consecutive identical calls, this usually indicates an N+1 problem. These segments are collapsed. Expanding the collapsed node displays only the first three calls, not all calls.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 168.77518,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Transaction</em> <em>traces</em>: <em>Trace</em> details page",
        "sections": "<em>Transaction</em> <em>traces</em>: <em>Trace</em> details page",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": "In <em>APM</em>, the <em>Trace</em> details tab shows the timing of individual segments in a <em>transaction</em> <em>trace</em>. This document describes the sections and features of the <em>Trace</em> details tab. <em>Trace</em> details page functions Go to one.newrelic.com &gt; <em>APM</em> &gt; (select an app) &gt; Monitor &gt; <em>Transactions</em> &gt; (select a <em>transaction</em>"
      },
      "id": "603ebe83196a67703ca83dd0"
    },
    {
      "sections": [
        "Security and transaction traces",
        "Database queries",
        "HTTP request attributes and parameters",
        "High security mode"
      ],
      "title": "Security and transaction traces",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "75566cc4a263be7241db16af2553d4fb3ed3274d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/security-transaction-traces/",
      "published_at": "2021-07-02T09:10:02Z",
      "updated_at": "2021-03-16T07:18:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM transaction traces collect detailed data about your application's transactions. Because they collect detailed data from your app, transaction traces can be a potential security concern. This document explains how to configure transaction traces for your data security needs. Database queries The database query types collected by transaction traces vary by New Relic language agent. Query collection is a potential security and/or privacy concern because queries can contain sensitive values. You can customize database query collection with three different security settings: Obfuscated: This is the default value. This setting strips string literals and numeric sequences from your queries and replaces them with the ? character. For example: the query select * from table where ssn='123-45-6789' would become select * from table where ssn=?. Off: Query collection is turned off entirely. Raw: If you are confident that full query data collection will not impact your data security or your users' privacy, you can change the setting to Raw, which will record all query values. You can edit database query collection with the Record SQL setting, explained in Configure transaction traces. HTTP request attributes and parameters The collection of HTTP request data can expose potentially sensitive data. New Relic calls the key/value data collected during an HTTP request attributes. By default, the collection of attributes is limited to only basic HTTP information that is not a source of sensitive data (for example, response code and host); these are part of the group of basic attributes that New Relic refers to as agent attributes. For data security reasons, the collection of other attributes, including user-specific parameters, is disabled by default. For information on how to enable/disable the collection of specific HTTP attributes and custom attributes, see Configure transaction traces. High security mode New Relic's default settings provide a high level of security. To force the most secure settings for all the applications in your account, you can use the high security mode. This mode ensures that, no matter how your admins and users configure your account, the most secure settings are forced and cannot be overridden. For more information, see High security mode.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 168.76967,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Security and <em>transaction</em> <em>traces</em>",
        "sections": "Security and <em>transaction</em> <em>traces</em>",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": "<em>APM</em> <em>transaction</em> <em>traces</em> collect detailed data about your application&#x27;s <em>transactions</em>. Because they collect detailed data from your app, <em>transaction</em> <em>traces</em> can be a potential security concern. This document explains how to configure <em>transaction</em> <em>traces</em> for your data security needs. Database queries"
      },
      "id": "603ebf89196a676a5aa83df0"
    }
  ],
  "/docs/apm/transactions/transaction-traces/transaction-traces-summary-page": [
    {
      "sections": [
        "Introduction to transaction traces",
        "What transactions record traces",
        "Configure transaction traces",
        "View transaction traces in UI",
        "Troubleshoot an issue with transaction traces"
      ],
      "title": "Introduction to transaction traces",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "b2a6521e60a66ca6e5b731b0c4fe7c80abe32675",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/introduction-transaction-traces/",
      "published_at": "2021-07-02T09:09:02Z",
      "updated_at": "2021-03-29T16:45:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, a transaction trace gives a detailed snapshot of a single transaction in your application. A transaction trace records the available function calls, database calls, and external calls. You can use transaction traces to troubleshoot performance issues and to get detailed low-level insight into how your app is working. What transactions record traces In APM, a transaction trace records the segments that make up a transaction. Because they give you more detail, you can use transaction traces to analyze and troubleshoot performance issues. Here are the default rules that govern which transactions a New Relic agent traces: Over the minute-long harvest cycle, all transactions that violate the threshold (either four times your Apdex T value or a specific number of seconds) are added to a pool of transactions. At the end of that minute, the New Relic agent selects the slowest transaction in that pool and performs a transaction trace on it. These are the general rules, but there are some agent-specific differences. For example: The Java agent collects occasional non-slow transactions. If one transaction is frequently traced, some agents will select other transactions to give a more diverse sampling. If you don't see traces in your account, it's possible that no transactions meet the necessary criteria. In this situation, you can adjust transaction trace settings to ensure some transactions will be traced. If you use Synthetic, you will likely have Synthetic monitor traces. Synthetic traces can happen more frequently than APM traces, potentially several per minute. Configure transaction traces To configure or edit trace settings, see the procedures for: Transaction traces Key transaction traces View transaction traces in UI To view transaction traces: Do one of the following: New Relic Explorer: Go to one.newrelic.com > Explorer > (select an app) > Monitor > Transactions. APM: Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions. In the Transaction traces section, click transaction traces to view additional details. Troubleshoot an issue with transaction traces If you expect to see transaction traces but do not see them, follow the troubleshooting procedures. For more information about using transaction traces, slow queries, and service maps to solve performance issues, see Analyze performance issues.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.60966,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>transaction</em> <em>traces</em>",
        "sections": "What <em>transactions</em> record <em>traces</em>",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": " into how your app is working. What <em>transactions</em> record <em>traces</em> In <em>APM</em>, a <em>transaction</em> <em>trace</em> records the segments that make up a <em>transaction</em>. Because they give you more detail, you can use <em>transaction</em> <em>traces</em> to analyze and troubleshoot performance issues. Here are the default rules that govern which"
      },
      "id": "603ebebae7b9d268562a07c8"
    },
    {
      "sections": [
        "Transaction traces: Trace details page",
        "Trace details page functions",
        "Drilldown options",
        "Color coding of segment duration data",
        "Application code in traces",
        "Partial traces",
        "Segment grouping rules"
      ],
      "title": "Transaction traces: Trace details page",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "77871dbce9242fbbb6bee421b1d6b7cd5e77a9d6",
      "image": "https://docs.newrelic.com/static/e1099bd92081eca96a51c0f0f27f8a65/c1b63/trx-trace-details.png",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/transaction-traces-trace-details-page/",
      "published_at": "2021-07-02T09:12:04Z",
      "updated_at": "2021-03-16T08:23:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, the Trace details tab shows the timing of individual segments in a transaction trace. This document describes the sections and features of the Trace details tab. Trace details page functions Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions > (select a transaction trace) > Trace details. The Trace details page displays a table with the timing data for the segments in a transaction, plus additional features and functions: Trace details page Description Primary trace data, functions The top of each transaction trace UI page shows several primary pieces of data, including the trace time, response time, and, if available, CPU info. Also, sometimes the UI may indicate a partial trace. Available functions include: Delete this trace: When you delete a trace, it cannot be retrieved. Track as key transaction. Duration column The duration of each segment and subsegment is shown as both the number of milliseconds and a percentage of the total transaction time. Especially slow segments are color-coded. Segment column The Segment column displays segment names and counts. Fast and repeat calls may be automatically grouped together. Sometimes you may see Application code as the name of a segment or subsegment. To expand segments, use either of the following: The Expand performance problems button at the top of the page The expand and collapse dropdown arrows next to the segments Drilldown column The Drilldown column may contain icons that link to additional transaction data, if available. Timestamp column The Timestamp column displays the start time of a segment or subsegment, relative to the start of the transaction. For example, a value of 3.150 s indicates that that segment started 3.15 seconds into the transaction. Drilldown options In the Drilldown column, icons indicate that additional data is available: Icon Description Database queries The database icon links to the raw database query for that query segment. Depending on your transaction trace settings, this query can either show as raw data or obfuscated data. If the total time for the segment exceeds the query plan threshold in your settings, the query analysis also will appear, along with a stack trace showing the exact location of the call in your code. Stack traces The magnifying glass links to stack trace details. Aggregate transaction details This icon indicates that cross application tracing details are not available. However, you can select this icon to view aggregated transaction information across multiple invocations of the transaction. Color coding of segment duration data The Duration column of the Trace details table is color-coded: Red: More than 25% of the total transaction time was spent in this segment. Yellow: More than 5% of the total transaction time was spent in this segment. Color-coded durations do not necessarily indicate a problem. Whether the timing is actually a problem depends on what you consider normal and acceptable for your application. Application code in traces If a segment is listed as Application code in the table, it indicates that that section of code was not instrumented. You can use custom instrumentation to get more detail on that part of the code. Segments will often be listed as Application code for partial traces. Partial traces For performance reasons, New Relic APM only captures the first 2,000 segments of a transaction trace (900 for Node.js). If a transaction trace exceeds that number of segments, the agent truncates the transaction trace and displays a message at the top of the Details page: This is a partial trace. The New Relic APM agents have differing rules for when to truncate segments. APM agent Truncate segment rules C SDK Truncates based on segment priority: The root segment has the highest priority. Segments that have seen distributed tracing activity have second-highest priority. Slow segments have third-highest priority. For more information, see the C SDK's documentation about newrelic_transaction_tracer_config_t on GitHub. Go The segment duration must be greater than the TransactionTracer.SegmentThreshold value set in your Go segment configuration. Java, .NET, Ruby These agents truncate traces chronologically. For more information, see the transaction tracer documentation for Java, .NET, or Ruby as applicable. Node.js The Node.js agent only captures the first 900 segments of a transaction trace. For more information, see Node.js transaction tracer configuration. PHP Truncates based on segment duration; the slowest 2,000 segments are captured for the trace. For more information, see PHP transaction tracer configuration. Python Truncates based on segment duration; the slowest 2,000 segments are captured for the trace. For more information, see Python transaction tracer configuration. Segment grouping rules Transaction traces that have a lot of segments can be hard to interpret. New Relic helps you by automatically grouping fast and/or repeated method calls into a single segment grouping. For example, you might see a segment titled 7 fast method calls. This means that, because of their fast completion, New Relic assumed these calls were unlikely to be a problem and grouped them together. You can expand that grouping to see the individual segments. Rules underlying segment grouping include: Fast calls: When New Relic detects four or more consecutive segments with a duration of 7.5 ms or less, these are grouped into a single collapsed header. Identical calls: When New Relic detects four or more consecutive identical calls, this usually indicates an N+1 problem. These segments are collapsed. Expanding the collapsed node displays only the first three calls, not all calls.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 168.77518,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Transaction</em> <em>traces</em>: <em>Trace</em> details page",
        "sections": "<em>Transaction</em> <em>traces</em>: <em>Trace</em> details page",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": "In <em>APM</em>, the <em>Trace</em> details tab shows the timing of individual segments in a <em>transaction</em> <em>trace</em>. This document describes the sections and features of the <em>Trace</em> details tab. <em>Trace</em> details page functions Go to one.newrelic.com &gt; <em>APM</em> &gt; (select an app) &gt; Monitor &gt; <em>Transactions</em> &gt; (select a <em>transaction</em>"
      },
      "id": "603ebe83196a67703ca83dd0"
    },
    {
      "sections": [
        "Transaction traces: Database queries page",
        "Find Database queries",
        "Use Database queries",
        "Configure database query settings",
        "Use database queries to improve performance",
        "Find other slow queries"
      ],
      "title": "Transaction traces: Database queries page",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "035eebbf2be9b92ae90b6bc7a7707410643f9e63",
      "image": "https://docs.newrelic.com/static/e9137d3161de025f768e647dab00ee18/c1b63/APM-transaction-trace-database-queries.png",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/transaction-traces-database-queries-page/",
      "published_at": "2021-07-02T09:11:11Z",
      "updated_at": "2021-03-16T08:22:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, transaction traces can contain database query data. Use the Database queries page to analyze a slow transaction or change database query collection settings. Find Database queries If database query data is associated with your selected transaction trace, the Database queries page will be visible from the Transaction trace details page. If you expect to see database data for a transaction trace but don't see it, you may need to change the Database query settings. Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions > (select a transaction trace) > Database queries. Use Database queries Use the Database queries page to analyze and troubleshoot a slow transaction. For example: You notice on the APM Overview page that a transaction is abnormally slow. You select a transaction trace to get more details about that transaction. If the trace has associated database data, you select the Database queries page to examine the slow queries in the trace, and use them as the basis to troubleshoot and improve your app's performance. Other functions include: If you want to... Do this... View hidden queries By default, New Relic hides queries that take less than five milliseconds. To view these hidden queries, select the Show fast queries checkbox. View stack traces To view stack traces associated with a database query, click the database icon (in the table's Total duration column). Configure database query settings You can change database query settings in the same way you change other transaction trace settings; for example, via configuring the New Relic agent or, for some agents, via the UI. Common database query setting changes include: Collecting raw query data instead of obfuscated or turning off query collection Changing the stack trace threshold Turning on query explain plan collection Use database queries to improve performance Here are some tips to improve your app's database performance: Use database queries Comments Time Look for queries where the TOTAL DURATION contributes large amounts of time to the overall transaction time. This indicates a good place to try to enhance your database query with an index or some other optimization. Duplicate queries Look for queries that repeatedly query the same kind of information; for example, multiple queries to look up individual account IDs. Try rewriting the query to INCLUDE the specific values (account IDs 1, 2, 10, 14, 17, etc.) so that a single query can get all the relevant items. Database overhead Look at the structure of your queries to see if there are opportunities to combine different types of information into a single call; for example, querying for the account ID, name, etc. This is useful, for example, if your database center is in a different geographical location, because this will reduce overhead. The amount of time for your database request and response may be very fast. However, by combining requests into fewer calls, you can reduce that time even more. MySQL From your app's main APM Summary page, compare the database time on the main chart to other processing time. Sudden spikes or larger amounts of database time compared to other processing times may indicate problems. Find other slow queries The Trace details page is useful for examining a specific transaction's details. To see all of your application's slowest queries in one place, use the Slow queries feature.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 168.77509,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Transaction</em> <em>traces</em>: Database queries page",
        "sections": "<em>Transaction</em> <em>traces</em>: Database queries page",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": "In <em>APM</em>, <em>transaction</em> <em>traces</em> can contain database query data. Use the Database queries page to analyze a slow <em>transaction</em> or change database query collection settings. Find Database queries If database query data is associated with your selected <em>transaction</em> <em>trace</em>, the Database queries page"
      },
      "id": "603ebf09e7b9d22a5f2f945c"
    }
  ],
  "/docs/apm/transactions/transaction-traces/transaction-traces-trace-details-page": [
    {
      "sections": [
        "Introduction to transaction traces",
        "What transactions record traces",
        "Configure transaction traces",
        "View transaction traces in UI",
        "Troubleshoot an issue with transaction traces"
      ],
      "title": "Introduction to transaction traces",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "b2a6521e60a66ca6e5b731b0c4fe7c80abe32675",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/introduction-transaction-traces/",
      "published_at": "2021-07-02T09:09:02Z",
      "updated_at": "2021-03-29T16:45:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, a transaction trace gives a detailed snapshot of a single transaction in your application. A transaction trace records the available function calls, database calls, and external calls. You can use transaction traces to troubleshoot performance issues and to get detailed low-level insight into how your app is working. What transactions record traces In APM, a transaction trace records the segments that make up a transaction. Because they give you more detail, you can use transaction traces to analyze and troubleshoot performance issues. Here are the default rules that govern which transactions a New Relic agent traces: Over the minute-long harvest cycle, all transactions that violate the threshold (either four times your Apdex T value or a specific number of seconds) are added to a pool of transactions. At the end of that minute, the New Relic agent selects the slowest transaction in that pool and performs a transaction trace on it. These are the general rules, but there are some agent-specific differences. For example: The Java agent collects occasional non-slow transactions. If one transaction is frequently traced, some agents will select other transactions to give a more diverse sampling. If you don't see traces in your account, it's possible that no transactions meet the necessary criteria. In this situation, you can adjust transaction trace settings to ensure some transactions will be traced. If you use Synthetic, you will likely have Synthetic monitor traces. Synthetic traces can happen more frequently than APM traces, potentially several per minute. Configure transaction traces To configure or edit trace settings, see the procedures for: Transaction traces Key transaction traces View transaction traces in UI To view transaction traces: Do one of the following: New Relic Explorer: Go to one.newrelic.com > Explorer > (select an app) > Monitor > Transactions. APM: Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions. In the Transaction traces section, click transaction traces to view additional details. Troubleshoot an issue with transaction traces If you expect to see transaction traces but do not see them, follow the troubleshooting procedures. For more information about using transaction traces, slow queries, and service maps to solve performance issues, see Analyze performance issues.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.60966,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>transaction</em> <em>traces</em>",
        "sections": "What <em>transactions</em> record <em>traces</em>",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": " into how your app is working. What <em>transactions</em> record <em>traces</em> In <em>APM</em>, a <em>transaction</em> <em>trace</em> records the segments that make up a <em>transaction</em>. Because they give you more detail, you can use <em>transaction</em> <em>traces</em> to analyze and troubleshoot performance issues. Here are the default rules that govern which"
      },
      "id": "603ebebae7b9d268562a07c8"
    },
    {
      "sections": [
        "Transaction traces: Database queries page",
        "Find Database queries",
        "Use Database queries",
        "Configure database query settings",
        "Use database queries to improve performance",
        "Find other slow queries"
      ],
      "title": "Transaction traces: Database queries page",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "035eebbf2be9b92ae90b6bc7a7707410643f9e63",
      "image": "https://docs.newrelic.com/static/e9137d3161de025f768e647dab00ee18/c1b63/APM-transaction-trace-database-queries.png",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/transaction-traces-database-queries-page/",
      "published_at": "2021-07-02T09:11:11Z",
      "updated_at": "2021-03-16T08:22:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, transaction traces can contain database query data. Use the Database queries page to analyze a slow transaction or change database query collection settings. Find Database queries If database query data is associated with your selected transaction trace, the Database queries page will be visible from the Transaction trace details page. If you expect to see database data for a transaction trace but don't see it, you may need to change the Database query settings. Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions > (select a transaction trace) > Database queries. Use Database queries Use the Database queries page to analyze and troubleshoot a slow transaction. For example: You notice on the APM Overview page that a transaction is abnormally slow. You select a transaction trace to get more details about that transaction. If the trace has associated database data, you select the Database queries page to examine the slow queries in the trace, and use them as the basis to troubleshoot and improve your app's performance. Other functions include: If you want to... Do this... View hidden queries By default, New Relic hides queries that take less than five milliseconds. To view these hidden queries, select the Show fast queries checkbox. View stack traces To view stack traces associated with a database query, click the database icon (in the table's Total duration column). Configure database query settings You can change database query settings in the same way you change other transaction trace settings; for example, via configuring the New Relic agent or, for some agents, via the UI. Common database query setting changes include: Collecting raw query data instead of obfuscated or turning off query collection Changing the stack trace threshold Turning on query explain plan collection Use database queries to improve performance Here are some tips to improve your app's database performance: Use database queries Comments Time Look for queries where the TOTAL DURATION contributes large amounts of time to the overall transaction time. This indicates a good place to try to enhance your database query with an index or some other optimization. Duplicate queries Look for queries that repeatedly query the same kind of information; for example, multiple queries to look up individual account IDs. Try rewriting the query to INCLUDE the specific values (account IDs 1, 2, 10, 14, 17, etc.) so that a single query can get all the relevant items. Database overhead Look at the structure of your queries to see if there are opportunities to combine different types of information into a single call; for example, querying for the account ID, name, etc. This is useful, for example, if your database center is in a different geographical location, because this will reduce overhead. The amount of time for your database request and response may be very fast. However, by combining requests into fewer calls, you can reduce that time even more. MySQL From your app's main APM Summary page, compare the database time on the main chart to other processing time. Sudden spikes or larger amounts of database time compared to other processing times may indicate problems. Find other slow queries The Trace details page is useful for examining a specific transaction's details. To see all of your application's slowest queries in one place, use the Slow queries feature.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 168.77509,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Transaction</em> <em>traces</em>: Database queries page",
        "sections": "<em>Transaction</em> <em>traces</em>: Database queries page",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": "In <em>APM</em>, <em>transaction</em> <em>traces</em> can contain database query data. Use the Database queries page to analyze a slow <em>transaction</em> or change database query collection settings. Find Database queries If database query data is associated with your selected <em>transaction</em> <em>trace</em>, the Database queries page"
      },
      "id": "603ebf09e7b9d22a5f2f945c"
    },
    {
      "sections": [
        "Security and transaction traces",
        "Database queries",
        "HTTP request attributes and parameters",
        "High security mode"
      ],
      "title": "Security and transaction traces",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "75566cc4a263be7241db16af2553d4fb3ed3274d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/security-transaction-traces/",
      "published_at": "2021-07-02T09:10:02Z",
      "updated_at": "2021-03-16T07:18:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM transaction traces collect detailed data about your application's transactions. Because they collect detailed data from your app, transaction traces can be a potential security concern. This document explains how to configure transaction traces for your data security needs. Database queries The database query types collected by transaction traces vary by New Relic language agent. Query collection is a potential security and/or privacy concern because queries can contain sensitive values. You can customize database query collection with three different security settings: Obfuscated: This is the default value. This setting strips string literals and numeric sequences from your queries and replaces them with the ? character. For example: the query select * from table where ssn='123-45-6789' would become select * from table where ssn=?. Off: Query collection is turned off entirely. Raw: If you are confident that full query data collection will not impact your data security or your users' privacy, you can change the setting to Raw, which will record all query values. You can edit database query collection with the Record SQL setting, explained in Configure transaction traces. HTTP request attributes and parameters The collection of HTTP request data can expose potentially sensitive data. New Relic calls the key/value data collected during an HTTP request attributes. By default, the collection of attributes is limited to only basic HTTP information that is not a source of sensitive data (for example, response code and host); these are part of the group of basic attributes that New Relic refers to as agent attributes. For data security reasons, the collection of other attributes, including user-specific parameters, is disabled by default. For information on how to enable/disable the collection of specific HTTP attributes and custom attributes, see Configure transaction traces. High security mode New Relic's default settings provide a high level of security. To force the most secure settings for all the applications in your account, you can use the high security mode. This mode ensures that, no matter how your admins and users configure your account, the most secure settings are forced and cannot be overridden. For more information, see High security mode.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 168.76967,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Security and <em>transaction</em> <em>traces</em>",
        "sections": "Security and <em>transaction</em> <em>traces</em>",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": "<em>APM</em> <em>transaction</em> <em>traces</em> collect detailed data about your application&#x27;s <em>transactions</em>. Because they collect detailed data from your app, <em>transaction</em> <em>traces</em> can be a potential security concern. This document explains how to configure <em>transaction</em> <em>traces</em> for your data security needs. Database queries"
      },
      "id": "603ebf89196a676a5aa83df0"
    }
  ],
  "/docs/apm/transactions/transaction-traces/troubleshooting-not-seeing-transaction-traces": [
    {
      "sections": [
        "Introduction to transaction traces",
        "What transactions record traces",
        "Configure transaction traces",
        "View transaction traces in UI",
        "Troubleshoot an issue with transaction traces"
      ],
      "title": "Introduction to transaction traces",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "b2a6521e60a66ca6e5b731b0c4fe7c80abe32675",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/introduction-transaction-traces/",
      "published_at": "2021-07-02T09:09:02Z",
      "updated_at": "2021-03-29T16:45:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, a transaction trace gives a detailed snapshot of a single transaction in your application. A transaction trace records the available function calls, database calls, and external calls. You can use transaction traces to troubleshoot performance issues and to get detailed low-level insight into how your app is working. What transactions record traces In APM, a transaction trace records the segments that make up a transaction. Because they give you more detail, you can use transaction traces to analyze and troubleshoot performance issues. Here are the default rules that govern which transactions a New Relic agent traces: Over the minute-long harvest cycle, all transactions that violate the threshold (either four times your Apdex T value or a specific number of seconds) are added to a pool of transactions. At the end of that minute, the New Relic agent selects the slowest transaction in that pool and performs a transaction trace on it. These are the general rules, but there are some agent-specific differences. For example: The Java agent collects occasional non-slow transactions. If one transaction is frequently traced, some agents will select other transactions to give a more diverse sampling. If you don't see traces in your account, it's possible that no transactions meet the necessary criteria. In this situation, you can adjust transaction trace settings to ensure some transactions will be traced. If you use Synthetic, you will likely have Synthetic monitor traces. Synthetic traces can happen more frequently than APM traces, potentially several per minute. Configure transaction traces To configure or edit trace settings, see the procedures for: Transaction traces Key transaction traces View transaction traces in UI To view transaction traces: Do one of the following: New Relic Explorer: Go to one.newrelic.com > Explorer > (select an app) > Monitor > Transactions. APM: Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions. In the Transaction traces section, click transaction traces to view additional details. Troubleshoot an issue with transaction traces If you expect to see transaction traces but do not see them, follow the troubleshooting procedures. For more information about using transaction traces, slow queries, and service maps to solve performance issues, see Analyze performance issues.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.60966,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>transaction</em> <em>traces</em>",
        "sections": "What <em>transactions</em> record <em>traces</em>",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": " into how your app is working. What <em>transactions</em> record <em>traces</em> In <em>APM</em>, a <em>transaction</em> <em>trace</em> records the segments that make up a <em>transaction</em>. Because they give you more detail, you can use <em>transaction</em> <em>traces</em> to analyze and troubleshoot performance issues. Here are the default rules that govern which"
      },
      "id": "603ebebae7b9d268562a07c8"
    },
    {
      "sections": [
        "Transaction traces: Trace details page",
        "Trace details page functions",
        "Drilldown options",
        "Color coding of segment duration data",
        "Application code in traces",
        "Partial traces",
        "Segment grouping rules"
      ],
      "title": "Transaction traces: Trace details page",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "77871dbce9242fbbb6bee421b1d6b7cd5e77a9d6",
      "image": "https://docs.newrelic.com/static/e1099bd92081eca96a51c0f0f27f8a65/c1b63/trx-trace-details.png",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/transaction-traces-trace-details-page/",
      "published_at": "2021-07-02T09:12:04Z",
      "updated_at": "2021-03-16T08:23:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, the Trace details tab shows the timing of individual segments in a transaction trace. This document describes the sections and features of the Trace details tab. Trace details page functions Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions > (select a transaction trace) > Trace details. The Trace details page displays a table with the timing data for the segments in a transaction, plus additional features and functions: Trace details page Description Primary trace data, functions The top of each transaction trace UI page shows several primary pieces of data, including the trace time, response time, and, if available, CPU info. Also, sometimes the UI may indicate a partial trace. Available functions include: Delete this trace: When you delete a trace, it cannot be retrieved. Track as key transaction. Duration column The duration of each segment and subsegment is shown as both the number of milliseconds and a percentage of the total transaction time. Especially slow segments are color-coded. Segment column The Segment column displays segment names and counts. Fast and repeat calls may be automatically grouped together. Sometimes you may see Application code as the name of a segment or subsegment. To expand segments, use either of the following: The Expand performance problems button at the top of the page The expand and collapse dropdown arrows next to the segments Drilldown column The Drilldown column may contain icons that link to additional transaction data, if available. Timestamp column The Timestamp column displays the start time of a segment or subsegment, relative to the start of the transaction. For example, a value of 3.150 s indicates that that segment started 3.15 seconds into the transaction. Drilldown options In the Drilldown column, icons indicate that additional data is available: Icon Description Database queries The database icon links to the raw database query for that query segment. Depending on your transaction trace settings, this query can either show as raw data or obfuscated data. If the total time for the segment exceeds the query plan threshold in your settings, the query analysis also will appear, along with a stack trace showing the exact location of the call in your code. Stack traces The magnifying glass links to stack trace details. Aggregate transaction details This icon indicates that cross application tracing details are not available. However, you can select this icon to view aggregated transaction information across multiple invocations of the transaction. Color coding of segment duration data The Duration column of the Trace details table is color-coded: Red: More than 25% of the total transaction time was spent in this segment. Yellow: More than 5% of the total transaction time was spent in this segment. Color-coded durations do not necessarily indicate a problem. Whether the timing is actually a problem depends on what you consider normal and acceptable for your application. Application code in traces If a segment is listed as Application code in the table, it indicates that that section of code was not instrumented. You can use custom instrumentation to get more detail on that part of the code. Segments will often be listed as Application code for partial traces. Partial traces For performance reasons, New Relic APM only captures the first 2,000 segments of a transaction trace (900 for Node.js). If a transaction trace exceeds that number of segments, the agent truncates the transaction trace and displays a message at the top of the Details page: This is a partial trace. The New Relic APM agents have differing rules for when to truncate segments. APM agent Truncate segment rules C SDK Truncates based on segment priority: The root segment has the highest priority. Segments that have seen distributed tracing activity have second-highest priority. Slow segments have third-highest priority. For more information, see the C SDK's documentation about newrelic_transaction_tracer_config_t on GitHub. Go The segment duration must be greater than the TransactionTracer.SegmentThreshold value set in your Go segment configuration. Java, .NET, Ruby These agents truncate traces chronologically. For more information, see the transaction tracer documentation for Java, .NET, or Ruby as applicable. Node.js The Node.js agent only captures the first 900 segments of a transaction trace. For more information, see Node.js transaction tracer configuration. PHP Truncates based on segment duration; the slowest 2,000 segments are captured for the trace. For more information, see PHP transaction tracer configuration. Python Truncates based on segment duration; the slowest 2,000 segments are captured for the trace. For more information, see Python transaction tracer configuration. Segment grouping rules Transaction traces that have a lot of segments can be hard to interpret. New Relic helps you by automatically grouping fast and/or repeated method calls into a single segment grouping. For example, you might see a segment titled 7 fast method calls. This means that, because of their fast completion, New Relic assumed these calls were unlikely to be a problem and grouped them together. You can expand that grouping to see the individual segments. Rules underlying segment grouping include: Fast calls: When New Relic detects four or more consecutive segments with a duration of 7.5 ms or less, these are grouped into a single collapsed header. Identical calls: When New Relic detects four or more consecutive identical calls, this usually indicates an N+1 problem. These segments are collapsed. Expanding the collapsed node displays only the first three calls, not all calls.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 168.77518,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Transaction</em> <em>traces</em>: <em>Trace</em> details page",
        "sections": "<em>Transaction</em> <em>traces</em>: <em>Trace</em> details page",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": "In <em>APM</em>, the <em>Trace</em> details tab shows the timing of individual segments in a <em>transaction</em> <em>trace</em>. This document describes the sections and features of the <em>Trace</em> details tab. <em>Trace</em> details page functions Go to one.newrelic.com &gt; <em>APM</em> &gt; (select an app) &gt; Monitor &gt; <em>Transactions</em> &gt; (select a <em>transaction</em>"
      },
      "id": "603ebe83196a67703ca83dd0"
    },
    {
      "sections": [
        "Transaction traces: Database queries page",
        "Find Database queries",
        "Use Database queries",
        "Configure database query settings",
        "Use database queries to improve performance",
        "Find other slow queries"
      ],
      "title": "Transaction traces: Database queries page",
      "type": "docs",
      "tags": [
        "APM",
        "Transactions",
        "Transaction traces"
      ],
      "external_id": "035eebbf2be9b92ae90b6bc7a7707410643f9e63",
      "image": "https://docs.newrelic.com/static/e9137d3161de025f768e647dab00ee18/c1b63/APM-transaction-trace-database-queries.png",
      "url": "https://docs.newrelic.com/docs/apm/transactions/transaction-traces/transaction-traces-database-queries-page/",
      "published_at": "2021-07-02T09:11:11Z",
      "updated_at": "2021-03-16T08:22:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In APM, transaction traces can contain database query data. Use the Database queries page to analyze a slow transaction or change database query collection settings. Find Database queries If database query data is associated with your selected transaction trace, the Database queries page will be visible from the Transaction trace details page. If you expect to see database data for a transaction trace but don't see it, you may need to change the Database query settings. Go to one.newrelic.com > APM > (select an app) > Monitor > Transactions > (select a transaction trace) > Database queries. Use Database queries Use the Database queries page to analyze and troubleshoot a slow transaction. For example: You notice on the APM Overview page that a transaction is abnormally slow. You select a transaction trace to get more details about that transaction. If the trace has associated database data, you select the Database queries page to examine the slow queries in the trace, and use them as the basis to troubleshoot and improve your app's performance. Other functions include: If you want to... Do this... View hidden queries By default, New Relic hides queries that take less than five milliseconds. To view these hidden queries, select the Show fast queries checkbox. View stack traces To view stack traces associated with a database query, click the database icon (in the table's Total duration column). Configure database query settings You can change database query settings in the same way you change other transaction trace settings; for example, via configuring the New Relic agent or, for some agents, via the UI. Common database query setting changes include: Collecting raw query data instead of obfuscated or turning off query collection Changing the stack trace threshold Turning on query explain plan collection Use database queries to improve performance Here are some tips to improve your app's database performance: Use database queries Comments Time Look for queries where the TOTAL DURATION contributes large amounts of time to the overall transaction time. This indicates a good place to try to enhance your database query with an index or some other optimization. Duplicate queries Look for queries that repeatedly query the same kind of information; for example, multiple queries to look up individual account IDs. Try rewriting the query to INCLUDE the specific values (account IDs 1, 2, 10, 14, 17, etc.) so that a single query can get all the relevant items. Database overhead Look at the structure of your queries to see if there are opportunities to combine different types of information into a single call; for example, querying for the account ID, name, etc. This is useful, for example, if your database center is in a different geographical location, because this will reduce overhead. The amount of time for your database request and response may be very fast. However, by combining requests into fewer calls, you can reduce that time even more. MySQL From your app's main APM Summary page, compare the database time on the main chart to other processing time. Sudden spikes or larger amounts of database time compared to other processing times may indicate problems. Find other slow queries The Trace details page is useful for examining a specific transaction's details. To see all of your application's slowest queries in one place, use the Slow queries feature.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 168.77509,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Transaction</em> <em>traces</em>: Database queries page",
        "sections": "<em>Transaction</em> <em>traces</em>: Database queries page",
        "tags": "<em>Transaction</em> <em>traces</em>",
        "body": "In <em>APM</em>, <em>transaction</em> <em>traces</em> can contain database query data. Use the Database queries page to analyze a slow <em>transaction</em> or change database query collection settings. Find Database queries If database query data is associated with your selected <em>transaction</em> <em>trace</em>, the Database queries page"
      },
      "id": "603ebf09e7b9d22a5f2f945c"
    }
  ],
  "/docs/archive-campfire-example": [
    {
      "sections": [
        "Oracle Database monitoring integration",
        "Compatibility and requirements",
        "Oracle Database users and privileges",
        "Tip",
        "Install and activate",
        "Configure the integration",
        "Important",
        "Commands",
        "Arguments",
        "Labels",
        "Example configuration",
        "Example custom query configuration",
        "Find and use data",
        "Metric data",
        "Database metrics",
        "Tablespace metrics",
        "Inventory data",
        "Parameters",
        "Troubleshooting",
        "The Oracle library cannot be loaded",
        "ORACLE_HOME is not set correctly",
        "I get an ORA error",
        "Check the source code"
      ],
      "title": "Oracle Database monitoring integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "On-host integrations",
        "On-host integrations list"
      ],
      "external_id": "ec5ba9d06736a0cb168402e7af8a935068d748c9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/host-integrations/host-integrations-list/oracle-database-monitoring-integration/",
      "published_at": "2021-07-02T06:25:03Z",
      "updated_at": "2021-06-03T16:45:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Oracle Database integration collects key performance metrics on databases, tablespaces, and memory by default. You can customize your configuration to collect even more metrics, giving you detailed characterization of database performance. Read on to install the integration, and to see what data we collect. Compatibility and requirements Our integration is compatible with Oracle Database versions 11.2 and higher. Before installing the integration, make sure that you meet the following requirements: Linux distro compatible with infrastructure, except for RHEL/CentOS/OEL versions lower than 7. Install the infrastructure agent. Oracle Instant Client on the agent box. Oracle database with ORACLE_HOME configured to the correct directory for the root user. Oracle database user with both CONNECT and SELECT privileges on the required global views. Oracle database with a listener.ora file configured to monitor from a remote connection. By default, Oracle Database only listens to localhost. Oracle Database users and privileges In the Oracle database, execute the following statements to create a new user and assign user privileges. USERNAME and similar user-specific values must be replaced. If you use Oracle DB 12c or higher, use ALTER SESSION to access the database and manage users and user properties. Do not run this query if your Oracle DB version is lower than 12c. ALTER SESSION set \"_Oracle_SCRIPT\"=true; Copy Use CREATE USER to add a new user to the database. Replace USER_PASSWORD with the new user's password. CREATE USER USERNAME IDENTIFIED BY \"USER_PASSWORD\"; Copy Tip For assistance with user maintenance questions, consult the Oracle documentation or contact your system or database administrator. Grant CONNECT privileges to the user. GRANT CONNECT TO USERNAME; Copy Grant SELECT privileges to the user on the following global views: cdb_data_files cdb_pdbs cdb_users gv_$sysmetric gv_$pgastat gv_$instance gv_$filestat gv_$parameter sys.dba_data_files gv_$session gv_$sesstat gv_$statname gv_$rowcache gv_$sga gv_$sysstat v_$database gv_$librarycache gv_$sqlarea gv_$system_event dba_tablespaces gv_$session_wait gv_$rollstat v_$instance You can execute the following SQL statements together in one script or individually. GRANT SELECT ON cdb_data_files TO USERNAME; GRANT SELECT ON cdb_pdbs TO USERNAME; GRANT SELECT ON cdb_users TO USERNAME; GRANT SELECT ON gv_$sysmetric TO USERNAME; GRANT SELECT ON gv_$pgastat TO USERNAME; GRANT SELECT ON gv_$instance TO USERNAME; GRANT SELECT ON gv_$filestat TO USERNAME; GRANT SELECT ON gv_$parameter TO USERNAME; GRANT SELECT ON sys.dba_data_files TO USERNAME; GRANT SELECT ON DBA_TABLESPACES TO USERNAME; GRANT SELECT ON DBA_TABLESPACE_USAGE_METRICS TO USERNAME; GRANT SELECT ON gv_$session TO USERNAME; GRANT SELECT ON gv_$sesstat TO USERNAME; GRANT SELECT ON gv_$statname TO USERNAME; GRANT SELECT ON gv_$rowcache TO USERNAME; GRANT SELECT ON gv_$sga TO USERNAME; GRANT SELECT ON gv_$sysstat TO USERNAME; GRANT SELECT ON v_$database TO USERNAME; GRANT SELECT ON gv_$librarycache TO USERNAME; GRANT SELECT ON gv_$sqlarea TO USERNAME; GRANT SELECT ON gv_$system_event TO USERNAME; GRANT SELECT ON dba_tablespaces TO USERNAME; GRANT SELECT ON gv_$session_wait TO USERNAME; GRANT SELECT ON gv_$rollstat TO USERNAME; GRANT SELECT ON v_$instance TO USERNAME; Copy Install and activate To install the Oracle Database integration: Follow the instructions for installing an integration, using the file name nri-oracledb. Change directory to the integrations folder: cd /etc/newrelic-infra/integrations.d Copy Copy the sample configuration file: sudo cp oracledb-config.yml.sample oracledb-config.yml Copy Edit the oracledb-config.yml file as described in the configuration settings. Restart the infrastructure agent. Additional notes: Advanced: It's also possible to install the integration from a tarball file. This gives you full control over the installation and configuration process. On-host integrations do not automatically update. For best results, regularly update the integration package and the infrastructure agent. Configure the integration An integration's YAML-format configuration is where you can place required login credentials and configure how data is collected. Which options you change depend on your setup and preference. For an example configuration, see the example config file. Important With secrets management, you can configure on-host integrations with New Relic infrastructure's agent to use sensitive data (such as passwords) without having to write them as plain text into the integration's configuration file. For more information, see Secrets management. Commands The oracledb-config.yml file accepts the following commands: all_data: collects both inventory and metric data. Arguments The all_data command accepts the following arguments: service_name: Oracle Database service name of the instance (or cluster of instances) to monitor. This field is required. username: username of a user created with the required permissions. This field is required. password: password of a user created with the required permissions. This field is required. is_sys_dba: boolean value that indicates whether the authenticating user has SysDBA permissions. Default: false. oracle_home: path to where ORACLE_HOME is. This field is required. is_sys_oper: boolean value that indicates whether the authenticating user has SysOper permissions. Default: false. tablespaces: A JSON array of tablespaces to collect. If omitted, collects all tablespaces. Default: none (all tablespaces). Due to performance reasons, the integration will refuse to collect tablespace data for more than 200 tablespaces. If your database has more than 200 of tablespaces, you must restrict collection to a smaller number by using the tablespaces parameter. hostname: hostname of the instance to monitor. Default: 127.0.0.1. port: port number on which Oracle Database is running. Default: 1521. connection_string: a full connection string such as those found in tnsnames.ora. If this is specified, it takes priority over host, port, and service_name. extended_metrics: boolean value that indicates whether to collect extended metrics. Default: false. custom_metrics_query: a custom SQL query to run against the configured instance. Each row of the query is added as a new metric set on OracleCustomSample. Each non-null column in the row is added as an attribute on that metric set. custom_metrics_config: a path to a YAML file that contains a list of queries, along with custom sample names and metric type overrides. See example below for details. Labels The labels field controls the environment attribute. Default: production. Example configuration Example oracledb-config.yml file configuration: Example configuration integration_name: com.newrelic.oracledb instances: - name: oracledb command: all_data arguments: username: oracle_user password: oracle_password hostname: oracle-host.localnet oracle_home: <path to ORACLE_HOME> is_sys_dba: true service_name: ORCL custom_metrics_config: <path to custom queries yaml> # custom_metrics_query: >- # SELECT # 'physical_reads' AS \"metric_name\", # 'gauge' AS \"metric_type\", # SUM(PHYRDS) AS \"metric_value\", # INST_ID AS \"instanceID\" # FROM gv$filestat # GROUP BY INST_ID; labels: env: staging Copy Example custom query configuration --- queries: # Metric names are set to the column names in the query results - query: >- SELECT SUM(stat.gets) AS \"gets\", SUM(stat.waits) AS \"waits\", SUM(stat.waits)/SUM(stat.gets) AS \"ratio\", inst.inst_id FROM GV$ROLLSTAT stat, GV$INSTANCE inst WHERE stat.inst_id=inst.inst_id GROUP BY inst.inst_id # If not set explicitly here, metric type will default to # 'gauge' for numbers and 'attribute' for strings metric_types: gets: gauge # If unset, sample_name defaults to OracleCustomSample sample_name: MyCustomSample Copy For more about the general structure of on-host integration configuration, see Configuration. Find and use data To find your integration data in Infrastructure, go to one.newrelic.com > Infrastructure > Third-party services and select one of the Oracle Database integration links. Oracle Database data is attached to the following event types: OracleDatabaseSample OracleTablespaceSample For more on how to find and use your data, see Understand integration data. Metric data The Oracle Database integration collects the following metric data attributes. Each metric name is prefixed with a category indicator and a period, such as disk. or memory.. Database metrics These attributes can be found by querying the OracleDatabaseSample event type. Metric Description db.activeParallelSessions Active parallel sessions. db.activeSerialSessions Active serial sessions. db.averageActiveSessions Average active sessions. Extended: yes. db.backgroundCheckpointsPerSecond Checkpoints per second. db.backgroundCpuUsagePerSecond Background CPU usage per second. db.backgroundTimePerSecond Background time per second. db.blockChangesPerSecond DB block changes per second. db.blockChangesPerTransaction DB block changes per transaction. db.blockChangesPerUserCall DB block changes per user call. db.blockGetsPerSecond DB block gets per second. db.blockGetsPerTransaction DB block gets per transaction. db.blockGetsPerUserCall DB block gets per user call. db.branchNodeSplitsPerSecond Branch node splits per second. db.branchNodeSplitsPerTransaction Branch node splits per transaction. db.consistentReadChangesPerSecond Consistent read changes per second. db.consistentReadChangesPerTransaction Consistent read changes per transaction. db.consistentReadGetsPerSecond Consistent read gets per second. db.consistentReadGetsPerTransaction Consistent read gets per transaction. db.cpuTimeRatio Database CPU time ratio. db.cpuUsagePerSecond CPU usage per second. Extended: yes. db.cpuUsagePerTransaction CPU usage per transaction. db.crBlocksCreatedPerSecond CR blocks created per second. db.crBlocksCreatedPerTransaction CR blocks created per transaction. db.crUndoRecordsAppliedPerSecond CR undo records applied per second. db.crUndoRecordsAppliedPerTransaction CR undo records applied per transaction. db.currentLogons Current logons count. db.currentOpenCursors Current open cursors count. db.cursorCacheHitsPerAttempts Cursor cache hit ratio. db.databaseCpuTimePerSecond Database time per second. db.dbwrCheckpointsPerSecond DBWR checkpoints per second. db.enqueueDeadlocksPerSecond Enqueue deadlocks per second. db.enqueueDeadlocksPerTransaction Enqueue deadlocks per transaction db.enqueueRequestsPerSecond Enqueue requests per second db.enqueueRequestsPerTransaction Enqueue requests per transaction. db.enqueueTimeoutsPerSecond Enqueue timeouts per second. db.enqueueTimeoutsPerTransaction Enqueue timeouts per transaction. db.enqueueWaitsPerSecond Enqueue waits per second. db.enqueueWaitsPerTransaction Enqueue waits per transaction. db.executionsPerSecond Executions per second. db.executionsPerTransaction Executions per transaction. Extended: yes. db.executionsPerUserCall Executions per user call. db.fullIndexScansPerSecond Full index scans per second. db.fullIndexScansPerTransaction Full index scans per transaction. db.GcCrBlockRecievedPerSecond GC CR block received per second. db.GcCrBlockRecievedPerTransaction GC CR block received per transaction. db.GcCurrentBlockReceivedPerSecond GC current block received per second. db.GcCurrentBlockReceivedPerTransactino GC current block received per transaction. db.globalCacheAverageCrGetTime Global cache average CR get time. db.globalCacheAverageCurrentGetTime Global cache average current get time. db.hardParseCountPerSecond Hard parse count per second. db.hardParseCountPerTransaction Hard parse count per transaction. db.hostCpuUsagePerSecond Host CPU usage per second. db.hostCpuUtilization Host CPU utilization (percentage). Extended: yes. db.leafNodeSplitsPerSecond Leaf node splits per second. db.leafNodeSplitsPerTransaction Leaf node splits per transaction. db.libraryCacheHitRatio Library cache hit ratio. db.libraryCacheMissRatio Library cache miss ratio. db.logicalReadsPerSecond Logical reads per second. db.logicalReadsPerTransaction Logical reads per transaction. db.logonsPerSecond Logons per second. db.logonsPerTransaction Logons per transaction. db.longTableScansPerSecond Long table scans per second. db.longTableScansPerTransaction Long table scans per transaction. db.openCursorsPerSecond Open cursors per second. db.openCursorsPerTransaction Open cursors per transaction. db.osLoad Current OS load. db.parseFailureCountPerSecond Parse failure count per second. db.parseFailureCountPerTransaction Parse failure count per transaction. db.pgaCacheHitPercentage PGA cache hit percentage. db.processLimitPercentage Process limit percentage. db.recursiveCallsPerSecond Recursive calls per second. db.recursiveCallsPerTransaction Recursive calls per transaction. db.redoWritesPerSecond Redo writes per second. db.redoWritesPerTransaction Redo writes per transaction. db.responseTimePerTransaction Response time per transaction. db.rowCacheHitRatio Row cache hit ratio. db.rowCacheMissRatio Row cache miss ratio. db.rowsPerSort Rows per sort. db.sessionCount Session count. Extended: yes. db.sessionLimitPercentage Session limit percentage. db.sharedPoolFreePercentage Shared pool free percentage. db.softParseRatio Soft parse ratio. db.sortsPerUserCall Total sorts per user call. db.sqlServiceResponseTime SQL service response time. db.streamsPoolUsagePercentage Streams pool usage percentage. db.tableScansPerUserCall Total table scans per user call. db.totalIndexScansPerSecond Total index scans per second. Extended: yes. db.totalIndexScansPerTransaction Total index scans per transaction. db.totalParseCountPerSecond Total parse count per second. db.totalParseCountPerTransaction Total parse count per transaction. db.totalTableScansPerSecond Total table scans per second. Extended: yes. db.totalTableScansPerTransaction Total table scans per transaction. db.TransactionsPerLogon Transactions per logon. db.userCallsPerSecond User calls per second. db.userCallsPerTransaction User calls per transaction. db.userCallsRatio User calls ratio. db.userCommitsPercentage User commits percentage. db.userCommitsPerSecond User commits per second. db.userLimitPercentage User limit percentage. db.userRollbacksPercentage User rollbacks per transaction. db.userRollbacksPerSecond User rollbacks per second. db.userRollbackUndoRecordsAppliedPerSecond User rollback undo records applied per second. db.userRollbackUndoRecordsAppliedPerTransaction User rollback undo records applied per transaction. db.waitTimeRatio Database wait time ratio. disk.blocksRead Number of block reads. Extended: yes. disk.blocksWritten Number of block writes. Extended: yes. disk.logicalReadsPerUserCall Logical reads per user call. disk.physicalLobsReadsPerSecond Physical reads direct lobs per second. disk.physicalLobsWritesPerSecond Physical writes direct lobs per second. disk.physicalReadBytesPerSecond Physical read total bytes per second. Extended: yes. disk.physicalReadIoRequestsPerSecond Physical read total I/O requests per second. Extended: yes. disk.physicalReadsPerSecond Physical reads direct per second. Extended: yes. disk.physicalWriteBytesPerSecond Physical write total bytes per second. disk.physicalWriteIoRequestsPerSecond Physical write I/O requests per second. disk.physicalWritesPerSecond Physical writes direct per second. Extended: yes. disk.physicalWriteTotalIoRequestsPerSecond Physical write total I/O requests per second. Extended: yes. disk.reads Total number of physical reads. Extended: yes. disk.readTime Amount of file read time. Extended: yes. disk.sortPerSecond Disk sort per second. disk.sortPerTransaction Disk sort per transaction. disk.tempSpaceUsed Temp space used. disk.writes Total number of physical writes. Extended: yes. disk.writeTime Amount of file write time. Extended: yes. lockedAccounts Number of accounts whose account_status is not OPEN. longRunningQueries Number of long running (> 60s) queries. memory.bufferCacheHitRatio Buffer cache hit ratio. Extended: yes. memory.globalCacheBlocksCorrupted Global cache blocks corrupted. memory.globalCacheBlocksLost Global cache blocks lost. memory.pgaAllocated Current amount of PGA memory allocated by the instance. memory.pgaFreeable Number of bytes of PGA memory in all processes that could be freed back to the operating system. memory.pgaInUse Indicates how much PGA memory is currently consumed by work areas. This number can be used to determine how much memory is consumed by other consumers of the PGA memory (for example, PL/SQL or Java). memory.pgaMaxSize Maximum size of a work area executed in automatic mode. Extended: yes. memory.redoAllocationHitRatio Redo allocation hit ratio. memory.redoGeneratedBytesPerSecond Redo generated bytes per second. memory.redoGeneratedBytesPerTransaction Redo generated bytes per transaction. memory.sortsRatio Memory sorts ratio. network.ioMegabytesPerSecond I/O megabytes per second. network.ioRequestsPerSecond I/O requests per second. Extended: yes. network.trafficBytePerSecond Network traffic volume per second. Extended: yes. query.physicalLobsReadsPerTransaction Physical reads direct lobs per transaction. query.physicalLobsWritesPerTransaction Physical writes direct lobs per transaction. query.physicalReadsPerTransaction Physical reads per transaction. query.physicalReadsPerTransaction Physical reads direct per transaction. query.physicalWritesPerTransaction Physical writes per transaction. query.physicalWritesPerTransaction Physical writes direct per transaction. query.transactionsPerSecond User transaction per second. Extended: yes. redoLog.logFileSwitch Number of redo log file switch events. redoLog.logFileSwitchArchivingNeeded Number of redo log file switch events that need archiving. redoLog.logFileSwitchCheckpointIncomplete Number of redo log file switch event checkpoints that are incomplete. redoLog.waits Number of redo log waits. rollbackSegments.gets Number of rollback segments gets. rollbackSegments.ratioWait Ratio of waits for rollback segments. rollbackSegments.waits Number of rollback segments waits. sga.bufferBusyWaits Number of SGA buffer busy waits. sga.fixedSizeInBytes SGA fixed size. sga.freeBufferWaits Number of SGA free buffer waits. sga.freeBufferInspected Number of SGA free buffer inspected. sga.hitRatio Hit ratio for the SGA. sga.logBufferAllocationRetriesRatio Retry ratio of allocations for the SGA log buffer. sga.logBufferRedoAllocationRetries Redo allocation ratio for the SGA log buffer. sga.logBufferRedoEntries Number of Redo entries in the SGA log buffer. sga.logBufferSpaceWaits Buffer space waits for the SGA log buffer. sga.redoBuffersInBytes SGA Redo buffers, in bytes. sga.sharedPoolDictCacheMissRatio Miss ratio for the SGA shared pool dictionary (dict) cache. sga.sharedPoolLibraryCacheHitRatio Hit ratio for the SGA shared pool library cache. sga.sharedPoolLibraryCacheReloadRatio Reload ratio for the SGA shared pool library cache. sga.sharedPoolLibraryCacheShareableMemoryPerStatementInBytes SGA cacheable memory per statement, in bytes. sga.sharedPoolLibraryCacheShareableMemoryPerUserInBytes SGA cacheable memory per user, in bytes. sga.ugaTotalMemoryInBytes Total memory in the User Global Area (UGA). sorts.diskInBytes Sorts disk usage, in bytes. sorts.memoryInBytes Sorts memory usage, in bytes. Tablespace metrics The Oracle Database integration collects the following tablespace metrics. These attributes can be found by querying the OracleTablespaceSample event type. Metric Description tablespace.isOffline Boolean for tablespace offline status. Extended: yes. tablespace.offlinePDBDatafiles The number of PDB datafiles that are offline. tablespace.offlineCDBDatafiles The number of CDB datafiles that are offline. tablespace.pdbDatafilesNonWrite The number of PDB datafiles in a non-writable state. tablespace.spaceConsumedInBytes Consumed amount of tablespace in bytes. tablespace.spaceReservedInBytes Total reserved tablespace in bytes. tablespace.spaceUsedPercentage Ratio of used to total tablespace. Extended: yes. Inventory data The Oracle Database integration captures the configuration parameters of the Oracle database. The data is available on the Inventory page, under the config/oracledb source. For more about inventory data, see Understand integration data. The integration captures data for the following Oracle Database configuration parameters: Parameters Metric Description DBFIPS_140 Enable use of crypographic libraries in FIPS mode, public. O7_DICTIONARY_ACCESSIBILITY Version 7 dictionary accessibility support. active_instance_count Number of active instances in the cluster database. adg_account_info_tracking ADG user account info tracked in standby (LOCAL) or in primary (GLOBAL). allow_global_dblinks LDAP lookup for DBLINKS. allow_group_access_to_sga Allow read access for SGA to users of Oracle owner group. approx_for_aggregation Replace exact_aggregation with approximate_aggregation. approx_for_count_distinct Replace count_distinct with approx_count_distinct. approx_for_percentile Replace percentile_* with approx_percentile. aq_tm_processes Number of AQ time managers to start. archive_lag_target Maximum number of seconds of redos the standby could lose. asm_diskstring Disk set locations for discovery. asm_preferred_read_failure_groups Preferred read failure groups. audit_file_dest Directory in which auditing files are to reside. audit_sys_operations Enable sys auditing. audit_syslog_level Syslog facility and level. audit_trail Enable system auditing. autotask_max_active_pdbs Setting for autotask maximum maintenance PDBs. awr_pdb_autoflush_enabled Enable/Disable AWR automatic PDB flushing. awr_pdb_max_parallel_slaves Maximum concurrent AWR PDB MMON slaves per instance. awr_snapshot_time_offset Setting for AWR snapshot time offset. background_core_dump Core size for background processes. background_dump_dest Detached process dump directory. backup_tape_io_slaves Backup tape I/O slaves. bitmap_merge_area_size Maximum memory allow for bitmap merge. blank_trimming Blank trimming semantics parameter. buffer_pool_keep Number of database blocks/latches in keep buffer pool. buffer_pool_recycle Number of database blocks/latches in recycle buffer pool. cdb_cluster If TRUE startup in CDB cluster mode. cdb_cluster_name CDB cluster name. cell_offload_compaction Cell packet compaction strategy. cell_offload_decryption Enable SQL processing offload of encrypted data to cells. cell_offload_parameters Additional cell offload parameters. cell_offload_plan_display Cell offload explain plan display. cell_offload_processing Enable SQL processing offload to cells. cell_offloadgroup_name Set the offload group name. circuits Max number of circuits. client_result_cache_lag Client result cache maximum lag in milliseconds. client_result_cache_size Client result cache max size in bytes. clonedb Clone database. clonedb_dir CloneDB Directory. cluster_database If TRUE startup in cluster database mode. cluster_database_instances Number of instances to use for sizing cluster DB SGA structures. cluster_interconnects Interconnects for RAC use. commit_logging Transaction commit log write behaviour. commit_point_strength Bias this node has toward not preparing in a two-phase commit. commit_wait Transaction commit log wait behaviour. commit_write Transaction commit log write behaviour. common_user_prefix Enforce restriction on a prefix of a common user, role, or profile . compatible Database will be completely compatible with this software version. connection_brokers Connection brokers specification. containers_parallel_degree Parallel degree for a CONTAINERS() query. control_file_record_keep_time Control file record keep time in days. control_files Control file names list. control_management_pack_access Declares which manageability packs are enabled. core_dump_dest Core dump directory. cpu_count Number of CPUs for this instance. create_bitmap_area_size Size of create bitmap buffer for bitmap index. create_stored_outlines Create stored outlines for DML statements. cursor_bind_capture_destination Allowed destination for captured bind variables. cursor_invalidation Default for DDL cursor invalidation semantics. cursor_sharing Cursor sharing mode. cursor_space_for_time Use more memory in order to get faster execution. data_guard_sync_latency Data guard sync latency. data_transfer_cache_size Size of data transfer cache. db_16k_cache_size Size of cache for 16K buffers. db_2k_cache_size Size of cache for 2K buffers. db_32k_cache_size Size of cache for 32K buffers. db_4k_cache_size Size of cache for 4K buffers. db_8k_cache_size Size of cache for 8K buffers. db_big_table_cache_percent_target Big table cache target size in percentage. db_block_buffers Number of database blocks cached in memory. db_block_checking Header checking and data and index block checking. db_block_checksum Store checksum in DB blocks and check during reads. db_block_size Size of database block in bytes. db_cache_advice Buffer cache sizing advisory. db_cache_size Size of default buffer pool for standard block size buffers. db_create_file_dest Default database location. db_create_online_log_dest_1 Online log/controlfile destination #1. db_create_online_log_dest_2 Online log/controlfile destination #2. db_create_online_log_dest_3 Online log/controlfile destination #3. db_create_online_log_dest_4 Online log/controlfile destination #4. db_create_online_log_dest_5 Online log/controlfile destination #5. db_domain Directory part of global database name stored with CREATE DATABASE. db_file_multiblock_read_count DB block to be read each I/O. db_file_name_convert Datafile name convert patterns and strings for standby/clone db. db_files Max allowable number of db files. db_flash_cache_file Flash cache file for default block size. db_flash_cache_size Flash cache size for db_flash_cache_file. db_flashback_retention_target Maximum flashback database log retention time in minutes.. db_index_compression_inheritance Options for table or tablespace level compression inheritance. db_keep_cache_size Size of KEEP buffer pool for standard block size buffers. db_lost_write_protect Enable lost write detection. db_name Database name specified in CREATE DATABASE. db_performance_profile Database performance category. db_recovery_file_dest Default database recovery file location. db_recovery_file_dest_size Database recovery files size limit. db_recycle_cache_size Size of RECYCLE buffer pool for standard block size buffers. db_securefile Permit securefile storage during lob creation. db_ultra_safe Sets defaults for other parameters that control protection levels. db_unique_name Database unique name. db_unrecoverable_scn_tracking Track nologging SCN in controlfile. db_writer_processes Number of background database writer processes to start. dbwr_io_slaves DBWR I/O slaves. ddl_lock_timeout Timeout to restrict the time that DDLS wait for DML lock. default_sharing Default sharing clause. deferred_segment_creation Defer segment creation to first insert. dg_broker_config_file1 Data guard broker configuration file #1. dg_broker_config_file2 Data guard broker configuration file #2. dg_broker_start Start data guard broker (DMON process). diagnostic_dest Diagnostic base directory. disable_pdb_feature Disable features. disk_asynch_io Use asynch I/O for random access devices. dispatchers Specifications of dispatchers. distributed_lock_timeout Number of seconds a distributed transaction waits for a lock. dml_locks DML locks - one for each table modified in a transaction. dnfs_batch_size Max number of dNFS asynch I/O requests queued per session. dst_upgrade_insert_conv Enables/Disables internal conversions during DST upgrade. enable_automatic_maintenance_pdb Enable/Disable automated maintenance for non-root PDB. enable_ddl_logging Enable ddl logging. enable_dnfs_dispatcher Enable DNFS dispatcher. enable_goldengate_replication Goldengate replication enabled. enable_pluggable_database Enable pluggable database. enabled_PDBs_on_standby List of enabled PDB patterns. encrypt_new_tablespaces Whether to encrypt newly created tablespaces. event Debug event control - default null string. exafusion_enabled Enable exafusion. external_keystore_credential_location External keystore credential location. fal_client FAL client. fal_server FAL server list. fast_start_io_target Upper bound on recovery reads. fast_start_mttr_target MTTR target in seconds. fast_start_parallel_rollback Max number of parallel recovery slaves that may be used. file_mapping Enable file mapping. fileio_network_adapters Network adapters for File I/O. filesystemio_options IO operations on filesystem files. fixed_date Fixed SYSDATE value. forward_listener Forward listener. gcs_server_processes Number of background gcs server processes to start. global_names Enforce that database links have same name as remote database. global_txn_processes Number of background global transaction processes to start. hash_area_size Size of in-memory hash work area. heat_map ILM Heatmap Tracking. hi_shared_memory_address SGA starting address (high order 32-bits on 64-bit platforms). hs_autoregister Enable automatic server DD updates in HS agent self-registration. ifile Include file in init.Ora. inmemory_adg_enabled Enable IMC support on ADG. inmemory_automatic_level Enable Automatic In-Memory management. inmemory_clause_default Default in-memory clause for new tables. inmemory_expressions_usage Controls which In-Memory Expressions are populated in-memory. inmemory_force Force tables to be in-memory or not. inmemory_max_populate_servers Maximum inmemory populate servers. inmemory_optimized_arithmetic Controls whether or not DSBs are stored in-memory. inmemory_prefer_xmem_memcompress Prefer to store tables with given memcompress levels in xmem. inmemory_prefer_xmem_priority Prefer to store tables with given priority levels in xmem. inmemory_query Specifies whether in-memory queries are allowed. inmemory_size Size in bytes of in-memory area. inmemory_trickle_repopulate_servers_percent Inmemory trickle repopulate servers percent. inmemory_virtual_columns Controls which user-defined virtual columns are stored in-memory. inmemory_xmem_size Size in bytes of in-memory xmem area. instance_abort_delay_time Time to delay an internal initiated abort (in seconds). instance_groups List of instance group names. instance_mode Indicates whether the instance read-only or read-write or read-mostly. instance_name Instance name supported by the instance. instance_number Instance number. instance_type Type of instance to be executed. instant_restore Instant repopulation of datafiles. java_jit_enabled Java VM JIT enabled. java_max_sessionspace_size Max allowed size in bytes of a Java sessionspace. java_pool_size Size in bytes of java pool. java_restrict Restrict Java VM Access. java_soft_sessionspace_limit Warning limit on size in bytes of a Java sessionspace. job_queue_processes Maximum number of job queue slave processes. large_pool_size Size in bytes of large pool. ldap_directory_access RDBMS's LDAP access option. ldap_directory_sysauth OID usage parameter. license_max_sessions Maximum number of non-system user sessions allowed. license_max_users Maximum number of named users that can be created in the database. license_sessions_warning Warning level for number of non-system user sessions. listener_networks Listener registration networks. local_listener Local listener. lock_name_space Lock name space used for generating lock names for standby/clone database. lock_sga Lock entire SGA in physical memory. log_archive_config Log archive config. log_archive_dest Archival destination text string. log_archive_dest_1 Archival destination #1 text string. log_archive_dest_10 Archival destination #10 text string. log_archive_dest_11 Archival destination #11 text string. log_archive_dest_12 Archival destination #12 text string. log_archive_dest_13 Archival destination #13 text string. log_archive_dest_14 Archival destination #14 text string. log_archive_dest_15 Archival destination #15 text string. log_archive_dest_16 Archival destination #16 text string. log_archive_dest_17 Archival destination #17 text string. log_archive_dest_18 Archival destination #18 text string. log_archive_dest_19 Archival destination #19 text string. log_archive_dest_2 Archival destination #2 text string. log_archive_dest_20 Archival destination #20 text string. log_archive_dest_21 Archival destination #21 text string. log_archive_dest_22 Archival destination #22 text string. log_archive_dest_23 Archival destination #23 text string. log_archive_dest_24 Archival destination #24 text string. log_archive_dest_25 Archival destination #25 text string. log_archive_dest_26 Archival destination #26 text string. log_archive_dest_27 Archival destination #27 text string. log_archive_dest_28 Archival destination #28 text string. log_archive_dest_29 Archival destination #29 text string. log_archive_dest_3 Archival destination #3 text string. log_archive_dest_30 Archival destination #30 text string. log_archive_dest_31 Archival destination #31 text string. log_archive_dest_4 Archival destination #4 text string. log_archive_dest_5 Archival destination #5 text string. log_archive_dest_6 Archival destination #6 text string. log_archive_dest_7 Archival destination #7 text string. log_archive_dest_8 Archival destination #8 text string. log_archive_dest_9 Archival destination #9 text string. log_archive_dest_state_1 Archival destination #1 state text string. log_archive_dest_state_10 Archival destination #10 state text string. log_archive_dest_state_11 Archival destination #11 state text string. log_archive_dest_state_12 Archival destination #12 state text string. log_archive_dest_state_13 Archival destination #13 state text string. log_archive_dest_state_14 Archival destination #14 state text string. log_archive_dest_state_15 Archival destination #15 state text string. log_archive_dest_state_16 Archival destination #16 state text string. log_archive_dest_state_17 Archival destination #17 state text string. log_archive_dest_state_18 Archival destination #18 state text string. log_archive_dest_state_19 Archival destination #19 state text string. log_archive_dest_state_2 Archival destination #2 state text string. log_archive_dest_state_20 Archival destination #20 state text string. log_archive_dest_state_21 Archival destination #21 state text string. log_archive_dest_state_22 Archival destination #22 state text string. log_archive_dest_state_23 Archival destination #23 state text string. log_archive_dest_state_24 Archival destination #24 state text string. log_archive_dest_state_25 Archival destination #25 state text string. log_archive_dest_state_26 Archival destination #26 state text string. log_archive_dest_state_27 Archival destination #27 state text string. log_archive_dest_state_28 Archival destination #28 state text string. log_archive_dest_state_29 Archival destination #29 state text string. log_archive_dest_state_3 Archival destination #3 state text string. log_archive_dest_state_30 Archival destination #30 state text string. log_archive_dest_state_31 Archival destination #31 state text string. log_archive_dest_state_4 Archival destination #4 state text string. log_archive_dest_state_5 Archival destination #5 state text string. log_archive_dest_state_6 Archival destination #6 state text string. log_archive_dest_state_7 Archival destination #7 state text string. log_archive_dest_state_8 Archival destination #8 state text string. log_archive_dest_state_9 Archival destination #9 state text string. log_archive_duplex_dest duplex Archival destination text string. log_archive_format Archival destination format. log_archive_max_processes Maximum number of active ARCH processes. log_archive_min_succeed_dest Minimum number of archive destinations that must succeed. log_archive_start Start archival process on SGA initialization. log_archive_trace Establish archive operation tracing level. log_buffer Redo circular buffer size. log_checkpoint_interval Number of redo blocks checkpoint threshold. log_checkpoint_timeout Maximum time interval between checkpoints in seconds. log_checkpoints_to_alert Log checkpoint begin/end to alert file. log_file_name_convert Logfile name convert patterns and strings for standby/clone db. long_module_action Use longer module and action. max_datapump_jobs_per_pdb Maximum number of concurrent data pump jobs per PDB. max_dispatchers Max number of dispatchers. max_dump_file_size Maximum size (in bytes) of dump file. max_idle_time Maximum session idle time in minutes. max_iops MAX I/O per second. max_mbps MAX MB per second. max_pdbs Max number of pdbs allowed in CDB or Application ROOT. max_shared_servers Max number of shared servers. max_string_size Controls maximum size of VARCHAR2, NVARCHAR2, and RAW types in SQL. memoptimize_pool_size Size of cache for imoltp buffers. memory_max_target Max size for Memory Target. memory_target Target size of Oracle SGA and PGA memory. multishard_query_data_consistency Consistency setting for multishard queries. multishard_query_partial_results Enable partial results for multishard queries. nls_calendar NLS calendar system name. nls_comp NLS comparison. nls_currency NLS local currency symbol. nls_date_format NLS Oracle date format. nls_date_language NLS date language name. nls_dual_currency Dual currency symbol. nls_iso_currency NLS ISO currency territory name. nls_language NLS language name. nls_length_semantics Create columns using byte or char semantics by default. nls_nchar_conv_excp NLS raise an exception instead of allowing implicit conversion. nls_numeric_characters NLS numeric characters. nls_sort NLS linguistic definition name. nls_territory NLS territory name. nls_time_format Time format. nls_time_tz_format Time with timezone format. nls_timestamp_format Time stamp format. nls_timestamp_tz_format Timestamp with timezone format. noncdb_compatible Non-CDB Compatible. object_cache_max_size_percent Percentage of maximum size over optimal of the user session's object cache. object_cache_optimal_size Optimal size of the user session's object cache in bytes. ofs_threads Number of OFS threads. olap_page_pool_size Size of the olap page pool in bytes. one_step_plugin_for_pdb_with_tde Facilitate one-step plugin for PDB with TDE encrypted data. open_cursors Max number of cursors per session. open_links Max number of open links per session. open_links_per_instance Max number of open links per instance. optimizer_adaptive_plans Controls all types of adaptive plans. optimizer_adaptive_reporting_only Use reporting-only mode for adaptive optimizations. optimizer_adaptive_statistics Controls all types of adaptive statistics. optimizer_capture_sql_plan_baselines Automatic capture of SQL plan baselines for repeatable statements. optimizer_dynamic_sampling Optimizer dynamic sampling. optimizer_features_enable Optimizer plan compatibility parameter. optimizer_ignore_hints Enables the embedded hints to be ignored. optimizer_ignore_parallel_hints Enables embedded parallel hints to be ignored. optimizer_index_caching Optimizer percent index caching. optimizer_index_cost_adj Optimizer index cost adjustment. optimizer_inmemory_aware Optimizer in-memory columnar awareness. optimizer_mode Optimizer mode. optimizer_secure_view_merging Optimizer secure view merging and predicate pushdown/movearound. optimizer_use_invisible_indexes Usage of invisible indexes (TRUE or FALSE). optimizer_use_pending_statistics Control whether to use optimizer pending statistics. optimizer_use_sql_plan_baselines Use of SQL plan baselines for captured sql statements. os_authent_prefix Prefix for auto-logon accounts. os_roles Retrieve roles from the operating system. outbound_dblink_protocols Outbound DBLINK Protocols allowed. parallel_adaptive_multi_user Enable adaptive setting of degree for multiple user streams. parallel_degree_limit Limit placed on degree of parallelism. parallel_degree_policy Policy used to compute the degree of parallelism (MANUAL, LIMITED, AUTO, or ADAPTIVE). parallel_execution_message_size Message buffer size for parallel execution. parallel_force_local Force single instance execution. parallel_instance_group Instance group to use for all parallel operations. parallel_max_servers Maximum parallel query servers per instance. parallel_min_degree Controls the minimum DOP computed by auto DOP. parallel_min_percent Minimum percent of threads required for parallel query. parallel_min_servers Minimum parallel query servers per instance. parallel_min_time_threshold Threshold above which a plan is a candidate for parallelization (in seconds). parallel_servers_target Instance target in terms of number of parallel servers. parallel_threads_per_cpu Number of parallel execution threads per CPU. pdb_file_name_convert PDB file name convert patterns and strings for create cdb/pdb. pdb_lockdown Pluggable database lockdown profile. pdb_os_credential Pluggable database OS credential to bind. pdb_template PDB template. permit_92_wrap_format Allow 9.2 or older wrap format in PL/SQL. pga_aggregate_limit Limit of aggregate PGA memory for the instance or PDB. pga_aggregate_target Target size for the aggregate PGA memory consumed by the instance. plscope_settings Plscope_settings controls the compile time collection, cross reference, and storage of PL/SQL source code identifier and SQL statement data. plsql_ccflags PL/SQL ccflags. plsql_code_type PL/SQL code-type. plsql_debug PL/SQL debug. plsql_optimize_level PL/SQL optimize level. plsql_v2_compatibility PL/SQL version 2.X compatibility flag. plsql_warnings PL/SQL compiler warnings settings. pre_page_sga Pre-page sga for process. private_temp_table_prefix Private temporary table prefix. processes User processes. processor_group_name Name of the processor group that this instance should run in. query_rewrite_enabled Allow rewrite of queries using materialized views if enabled. query_rewrite_integrity Perform rewrite using materialized views with desired integrity. rdbms_server_dn RDBMS's distinguished name. read_only_open_delayed If TRUE delay opening of read only files until first access. recovery_parallelism Number of server processes to use for parallel recovery. recyclebin Recyclebin processing. redo_transport_user Data guard transport user when using password file. remote_dependencies_mode Remote-procedure-call dependencies mode parameter. remote_listener Remote listener. remote_login_passwordfile Password file usage parameter. remote_os_authent Allow non-secure remote clients to use auto-logon accounts. remote_os_roles Allow non-secure remote clients to use os roles. remote_recovery_file_dest Default remote database recovery file location for refresh/relocate. replication_dependency_tracking Tracking dependency for replication parallel propagation. resource_limit Master switch for resource limit. resource_manage_goldengate Goldengate resource manager enabled. resource_manager_cpu_allocation Resource Manager CPU allocation. resource_manager_plan Resource mgr top plan. result_cache_max_result Maximum result size as percent of cache size. result_cache_max_size Maximum amount of memory to be used by the cache. result_cache_mode Result cache operator usage mode. result_cache_remote_expiration Maximum life time (min) for any result using a remote object. resumable_timeout Set resumable timeout. rollback_segments Undo segment list. sec_case_sensitive_logon Case sensitive password enabled for logon. sec_max_failed_login_attempts Maximum number of failed login attempts on a connection. sec_protocol_error_further_action TTC protocol error continue action. sec_protocol_error_trace_action TTC protocol error action. sec_return_server_release_banner Whether the server returns the complete version information. serial_reuse Reuse the frame segments. service_names Service names supported by the instance. session_cached_cursors Number of cursors to cache in a session. session_max_open_files Maximum number of open files allowed per session. sessions User and system sessions. sga_max_size Max total SGA size. sga_min_size Minimum, guaranteed size of PDB's SGA. sga_target Target size of SGA. shadow_core_dump Core size for shadow processes. shared_memory_address SGA starting address (low order 32-bits on 64-bit platforms). shared_pool_reserved_size Size in bytes of reserved area of shared pool. shared_pool_size Size in bytes of shared pool. shared_server_sessions Max number of shared server sessions. shared_servers Number of shared servers to start up. shrd_dupl_table_refresh_rate Duplicated table refresh rate (in seconds). skip_unusable_indexes Skip unusable indexes if set to TRUE. smtp_out_server Utl_smtp server and port configuration parameter. sort_area_retained_size Size of in-memory sort work area retained between fetch calls. sort_area_size Size of in-memory sort work area. spatial_vector_acceleration Enable spatial vector acceleration. spfile Server parameter file. sql92_security Require select privilege for searched update/delete. sql_trace Enable SQL trace. sqltune_category Category qualifier for applying hintsets. standby_db_preserve_states Preserve state cross standby role transition. standby_file_management If auto, files are created/dropped automatically on standby. standby_pdb_source_file_dblink Database link to standby source files. standby_pdb_source_file_directory Standby source file directory location. star_transformation_enabled Enable the use of star transformation. statistics_level Statistics level. streams_pool_size Size in bytes of the streams pool. tape_asynch_io Use asynch I/O requests for tape devices. target_pdbs Parameter is a hint to adjust certain attributes of the CDB. tde_configuration Per-PDB configuration for transparent tata encryption. temp_undo_enabled Is temporary undo enabled. thread Redo thread to mount. threaded_execution Threaded Execution Mode. timed_os_statistics Internal os statistic gathering interval in seconds. timed_statistics Maintain internal timing statistics. trace_enabled Enable in memory tracing. tracefile_identifier Trace file custom identifier. transactions Max. Number of concurrent active transactions. transactions_per_rollback_segment Number of active transactions per rollback segment. undo_management Instance runs in SMU mode if TRUE, else in RBU mode. undo_retention Undo retention in seconds. undo_tablespace Use/switch undo tablespace. unified_audit_sga_queue_size Size of unified audit SGA queue. unified_audit_systemlog Syslog facility and level for unified audit. uniform_log_timestamp_format Use uniform timestamp formats vs pre-12.2 formats. use_dedicated_broker Use dedicated connection broker. use_large_pages Use large pages if available (TRUE, FALSE, or ONLY). user_dump_dest User process dump directory. version Oracle Database version. xwallet_root Wallet root instance initialization parameter. workarea_size_policy Policy used to size SQL working areas (MANUAL``AUTO). Troubleshooting Troubleshooting tips: The Oracle library cannot be loaded If monitoring remotely, install the Oracle Instant Client and follow the instructions on how to add libclntsh.so to the shared library search path. If monitoring from the box with Oracle Database installed, install the Oracle Instant Client and add the path ORACLE_HOME/lib to the ldconfig search path. ORACLE_HOME is not set correctly This error will appear in the logs as [ERR] ORA-01284: Error while trying to retrieve text for error. To avoid this error make sure ORACLE_HOME is set correctly for the agent process. The agent runs as root, so its environment is not the same as the oracle user. To verify this setting, execute cat /proc/$(pgrep newrelic-infra)/environ to print out the environment variables for the infrastructure process, the output should include ORACLE_HOME if configured correctly. I get an ORA error To resolve errors of the type ORA, refer to Oracle's error list. Check the source code This integration is open source software. That means you can browse its source code and send improvements, or create your own fork and build it.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 78.35178,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Example</em> configuration",
        "body": " login credentials and configure how data is collected. Which options you change depend on your setup and preference. For an <em>example</em> configuration, see the <em>example</em> config file. Important With secrets management, you can configure on-host integrations with New Relic infrastructure&#x27;s agent to use sensitive"
      },
      "id": "6044571428ccbc04a23101f8"
    },
    {
      "sections": [
        "NerdGraph tutorial: View and manage workloads",
        "Important",
        "Get the workloads of an account",
        "Get the list of entities in a workload",
        "Get the status of a workload",
        "Create a workload",
        "Modify a workload",
        "Set a static status for a workload",
        "Modify the automatic status rules for a workload",
        "Duplicate a workload",
        "Delete a workload"
      ],
      "title": "NerdGraph tutorial: View and manage workloads",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "ffa158d197dbb207d50d48b813198842752d4b62",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/tutorials/nerdgraph-workloads-api-tutorials/",
      "published_at": "2021-07-02T09:32:56Z",
      "updated_at": "2021-07-02T09:32:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic allows you to group entities together in groupings called workloads. This enables better monitoring of the full stack used by a team or project. Here we show you how to use our NerdGraph API to do some workloads-related tasks: Get the workloads of an account Get the list of entities in a workload Get the status of a workload Create a workload Modify a workload Set a static status for a workload Modify the automatic status rules for a workload Duplicate a workload Delete a workload Important You can also use the CLI and Terraform resource to automate these tasks. Get the workloads of an account To get all workloads of an account, use the following GraphQL query and pass the account ID via the id field. In this example, we retrieve three basic fields: guid: the workload GUID. name: the workload name. permalink: the permanent URLs on the New Relic One UI. { actor { account(id: YOUR_ACCOUNT_ID) { workload { collections { guid name permalink } } } } } Copy The response includes this type of data for each workload: { \"data\": { \"actor\": { \"account\": { \"workload\": { \"collections\": [ ..., { \"guid\": \"MTY...NTY\", \"name\": \"Acme Telco - Fulfillment Chain\", \"permalink\": \"https://one.newrelic.com/redirect/entity/MTY...NTY\" }, ... ] } } } }, \"extensions\": { ... } } Copy Get the list of entities in a workload You can get the entities that belong to a workload with the following query, just by passing the workload GUID (guid) as an argument. In this example we also retrieve some workload metadata: accountId: the workload account. name: the workload name. permalink: the workload permanent URL on the New Relic One UI. alertSeverity: the status of the workload. This value can have up to 10 minutes of delay; if you want to force the calculation of the workload status in query time, please use the Get the status of a workload example. The nested collection, members and results objects, which contain the actual list of entities: The name argument in the collection object takes the value WORKLOAD. count: Number of entities in the workload. { actor { entity(guid: \"YOUR_WORKLOAD_GUID\") { accountId name permalink ... on AlertableEntity { alertSeverity } ... on CollectionEntity { collection(name: \"WORKLOAD\") { members { count results { entities { accountId entityType name guid ... on AlertableEntityOutline { alertSeverity } } } } } } } } } Copy The query returns a list of entities that looks like this: { \"data\": { \"actor\": { \"entity\": { \"accountId\": 1606862, \"name\": \"Acme Telco - Ecommerce\", \"permalink\": \"https://one.newrelic.com/redirect/entity/MTYwNjg2MnxOUjF8V09SS0xPQUR8MTIyMzQ\", \"alertSeverity\": \"CRITICAL\", \"collection\": { \"members\": { \"count\": 201, \"results\": { \"entities\": [ { \"accountId\": 1606862, \"alertSeverity\": \"CRITICAL\", \"entityType\": \"APM_APPLICATION_ENTITY\", \"guid\": \"MTYwNjg2MnxBUE18QVBQTElDQVRJT058NDMxOTIwNTg\", \"name\": \"Fulfillment Service\" }, { \"accountId\": 1606862, \"alertSeverity\": \"NOT_ALERTING\", \"entityType\": \"INFRASTRUCTURE_HOST_ENTITY\", \"guid\": \"MTYwNjg2MnxJTkZSQXxOQXw3MDQzMzA2NzIyMjk2NDg4Mzc\", \"name\": \"ip-172-31-16-222\" }, { \"accountId\": 1606862, \"alertSeverity\": \"NOT_ALERTING\", \"entityType\": \"INFRASTRUCTURE_AWS_LAMBDA_FUNCTION_ENTITY\", \"guid\": \"MTYwNjg2MnxJTkZSQXxOQXw1MjMyNzM2ODgzNjAwNjYyMjE1\", \"name\": \"TelcoDT-purchase-log-lambda\" }, ... ] } } } } } } } Copy Get the status of a workload If you want to force the calculation of the status of a workload, you can use the following query, passing the account id (id) as the argument for the account field, and the workload GUID (guid) as the argument for the collection field. { actor { account(id: YOUR_ACCOUNT_ID) { workload { collection(guid: \"YOUR_WORKLOAD_GUID\") { guid status { value } } } } } } Copy And this is what you'll get in the response: { \"data\": { \"actor\": { \"account\": { \"workload\": { \"collection\": { \"guid\": \"MTYwNjg2MnxOUjF8V09SS0xPQUR8MTIyMzQ\", \"status\": { \"value\": \"OPERATIONAL\" } } } } } } } Copy Note that the DISRUPTED status value is a synonym for CRITICAL status. Create a workload The following is an example NerdGraph call that creates a workload using the workloadCreate mutation query: mutation { workloadCreate( accountId: NEW_WORKLOAD_ACCOUNT_ID, workload: { name: \"NAME_OF_WORKLOAD\", entityGuids: [\"ENTITY_GUID_1\", \"ENTITY_GUID_2\", ...], entitySearchQueries: [ { query: \"(type = 'SERVICE') and tags.label.environment = 'production'\" }, ... ], scopeAccounts: { accountIds: [NEW_RELIC_ACCOUNT_ID_1, NEW_RELIC_ACCOUNT_ID_2, ...] } } ) { guid } } Copy Some details on parts of this query: account: The workload account ID. Workloads can't be moved between accounts, so it's not possible to change this value later. name: A string with a user-friendly name for the workload. scopeAccounts: Scope accounts are the accounts where the entity data is fetched from. Scope accounts must belong to a group under the same parent account or enterprise partnership as the workload account. To define the entities in the workload, you can use one or both of these options: entitySearchQueries: This allows you to dynamically generate an array of entities. A name for each query is not needed. Here's an example dynamic query: (domain = 'INFRA' and type = 'HOST') and tags.label.environment = 'production' Copy entityGuids: This is for choosing specific entity GUIDs for inclusion in the workload. guid: This returns the workload guid. Because NerdGraph provides schema stitching, you can get other details about the workload, like the permalink. Modify a workload To modify a workload, use the workloadUpdate mutation. You must know the workload's guid. The workload account can't be changed. For the fields you can modify, see Create workloads. These additional rules apply: entitySearchQueries: This field must contain all the queries as you expect them to be stored. If you want to add a new query, include it in the query field and don't provide any query id. If you want to modify an existing query, include it in the query field and provide its existing id. If you want to delete an existing query, just don't add any query with that id anymore. Here's an example of the workloadUpdate query: mutation { workloadUpdate( guid: \"YOUR_WORKLOAD_GUID\", workload: { name: \"A new name for the workload\", entityGuids: [\"ENTITY_GUID_1\", \"ENTITY_GUID_2\", ...], entitySearchQueries: [ { query: \"(domain = 'INFRA' and type = 'HOST') and tags.label.environment = 'staging'\" }, { id: AN_EXISTING_QUERY_ID, query: \"(type = 'SERVICE') and tags.label.environment = 'staging'\" }, ... ], scopeAccounts: { accountIds: [NEW_RELIC_ACCOUNT_ID_1, NEW_RELIC_ACCOUNT_ID_2, ...] } } ) { guid } } Copy Set a static status for a workload You can set up a static status for a workload, which overrides any automatic status calculation. To set a static status, you must know the workload's guid and use the following fields: enabled: Remember to set this field to true to propagate the status value. status: The status value you want to set for this workload. Supported values are OPERATIONAL, DEGRADED or DISRUPTED. description: A text field to provide additional details. mutation { workloadUpdate( guid: \"YOUR_WORKLOAD_GUID\", workload: { statusConfig: { static: { enabled: true, status: DEGRADED, description: \"Game day. Expect some turbulence today between 8 and 9am PST.\" } } } ) { guid updatedAt status { value } } } Copy Modify the automatic status rules for a workload When you create a workload, you can use the statusConfig object to define which automatic rules you want to use to calculate the status of the workload. If you leave the rules array empty, no rules will be set up for your workload. However, if you just don't use the statusConfig object when you create a workload, the following rules will be added by default: \"statusConfig\": { \"automatic\": { \"enabled\": true, \"rules\": [ { \"entitySearchQueries\": [{\"query\": \"(domain = 'APM' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'MOBILE' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'BROWSER' and type = 'APPLICATION')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } }, { \"entitySearchQueries\": [{\"query\": \"(domain = 'SYNTH' and type = 'MONITOR')\"}], \"rollup\": { \"strategy\": \"WORST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } } ], \"remainingEntitiesRule\": { \"rollup\": { \"groupBy\": \"ENTITY_TYPE\", \"strategy\": \"BEST_STATUS_WINS\", \"thresholdType\": null, \"thresholdValue\": null } } } } Copy This is how you read the configuration: enabled: The automatic status calculation is enabled when this field is set to true. rules: An array of rules. In the default configuration, four rules are set for those entity types that are closer to the digital experience (that is, Synthetic monitors, Browser applications, Mobile applications, and Services). For each of these groups, the status of the unhealthiest rolls up. remainingEntitiesRule: This is the rule that will apply to all entities that haven't been evaluated in any other rule. In the default configuration, the remaining entities are grouped by entity type, and we make the status of each group to match that of its healthiest entity. If you want to modify these rules, you must use the workloadUpdate mutation, and send the complete new statusConfig object that you want to use. You can disable the automatic status calculation while keeping the configuration, by setting the statucConfig.automatic.enabled to false. Alternatively, you can delete all automatic regular rules by sending an empty array. And you can delete the rule for the remaining entities by just not adding the remainingEntitiesRule object. Duplicate a workload To duplicate a workload you first need to know its guid. In the workloadDuplicate mutation, you must pass as parameters: accountId: The account where you want to create the new workload. sourceGuid: the guid of the workload you want to duplicate. workload.name: Optional. You can specify a name for the new workload. If you don't specify one, the new workload will get the name of the original workload appended with - Copy. After duplicating a workload, you can modify it. mutation { workloadDuplicate( accountId: NEW_WORKLOAD_ACCOUNT_ID, sourceGuid: \"ORIGINAL_WORKLOAD_GUID\", workload: { name: \"New workload\" } ) { guid } } Copy Delete a workload To delete a workload, use the workloadDelete mutation and specify the workload GUID. When you delete a workload, all history and metadata is also deleted.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 75.11963,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Examples</em>",
        "body": " of an account To get all workloads of an account, use the following GraphQL query and pass the account ID via the id field. In this <em>example</em>, we retrieve three basic fields: guid: the workload GUID. name: the workload name. permalink: the permanent URLs on the New Relic One UI. { actor { account(id"
      },
      "id": "603e9eb7e7b9d22a5f2f37b1"
    },
    {
      "sections": [
        "NerdGraph tutorial: Configure cloud integrations",
        "Requirements",
        "Access the NerdGraph GraphiQL explorer",
        "Query examples",
        "Available provider accounts",
        "Specific provider account information",
        "Specific integration data from a specific cloud provider",
        "List of enabled cloud accounts",
        "Specific linked account data",
        "Enabled cloud integrations for all linked accounts",
        "Specific cloud integration data for a specific linked account",
        "Mutation examples",
        "Link an account",
        "Link an Amazon AWS account",
        "Link an Amazon AWS account using CloudWatch Metric Streams",
        "Link a Microsoft Azure account",
        "Link a Google Cloud Platform (GCP) project",
        "Rename one or more cloud accounts",
        "Enable an integration in a cloud account",
        "Enable an integration in multiple cloud accounts",
        "Enable multiple integrations in multiple cloud accounts",
        "Modify an integration's configuration (regions, polling intervals, etc.)",
        "Disable (remove) an integration",
        "Unlink account",
        "Caution",
        "Enable an Amazon AWS integration",
        "Send query to fetch account data",
        "Link AWS provider account",
        "Enable Amazon AWS SQS integration",
        "Enable integration in multiple provider accounts",
        "Change polling interval for Amazon AWS integration",
        "Update the polling interval",
        "Disable Amazon AWS integration",
        "Disable the SQS integration"
      ],
      "title": "NerdGraph tutorial: Configure cloud integrations",
      "type": "docs",
      "tags": [
        "APIs",
        "NerdGraph",
        "Examples"
      ],
      "external_id": "9b0b3a78186946732433d21aa149fc36e14bb2d8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/nerdgraph/examples/nerdgraph-cloud-integrations-api-tutorial/",
      "published_at": "2021-07-02T09:29:30Z",
      "updated_at": "2021-07-02T09:29:30Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides examples of how to use New Relic NerdGraph to query and modify your cloud integration configuration data, including Amazon AWS, Microsoft Azure, and Google Cloud Platform (GCP). Using the NerdGraph GraphiQL explorer, you can also query NRQL data. These examples for querying cloud integration configuration data use GraphQL queries and mutations: Queries: requests that are intended to only fetch data Mutations: requests that create or update data on the server Requirements Before querying cloud integration data with NerdGraph, ensure you have: Followed the instructions to connect cloud integrations with New Relic. Created an API key. Access the NerdGraph GraphiQL explorer To access the NerdGraph GraphiQL explorer: Go to api.newrelic.com/graphiql. Add any of the following examples. Query examples Queries are requests that are intended to only fetch data (no side effects). Queries in NerdGraph are not static, meaning that you can ask for more or less data depending on your needs. For each query, you can specify exactly what data you want to retrieve, as long as it is supported by the schema. Available provider accounts This query returns a list of all provider accounts available in your infrastructure data. Depending on the provider, additional properties can be requested. For example, for GCP, you can also ask for the serviceAccountId property, which is needed when linking a new GCP project to New Relic. Anonymous: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug ... on CloudGcpProvider { serviceAccountId } } } } } } Copy Named: query cloudProviders { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } } } } } Copy Specific provider account information This query returns information about a specific provider account for your Amazon AWS integration. The properties id, name, slug are requested, along with a list of integrations available to be monitored. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { id slug name services { id slug name } } } } } } Copy Specific integration data from a specific cloud provider This query returns information about a specific cloud service integration of a provider. In this example, the integration is the Amazon AWS ALB monitoring integration and the provider is AWS. The properties id, name, slug, and isAllowed are requested with the available configuration parameters. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { provider(slug: \"aws\") { service(slug: \"alb\") { id name slug isEnabled } } } } } } Copy List of enabled cloud accounts This query returns the list of cloud accounts enabled with your New Relic account. (Your cloud account associates your New Relic account and a specific provider account with your integration.) You can enable multiple cloud provider accounts in the same New Relic account, even with the same cloud provider. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { id name createdAt provider { id name } } } } } } Copy Specific linked account data This query returns information about a linked account, including the properties name, providerId, and a list of the cloud integrations enabled for monitoring. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integrations { id name createdAt updatedAt } } } } } } Copy Enabled cloud integrations for all linked accounts This query returns all monitored integrations for all the provider cloud accounts. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccounts { name provider { id name } integrations { id name service { id name } createdAt updatedAt } } } } } } Copy Specific cloud integration data for a specific linked account This query returns information about a specific integration from a specific linked account. { actor { account(id: <NR_ACCOUNT_ID>) { cloud { linkedAccount(id: <LINKED_CLOUD_ACCOUNT_ID>) { name provider { id name } integration(id: <INTEGRATION_ID>) { id name service { id name } createdAt updatedAt } } } } } } Copy Mutation examples Mutations are requests that are intended to have side effects, such as creating or updating data on the server. Mutations require the keyword mutation and the name of the mutation. NerdGraph mutations are restricted to a subset of all possible mutations. Link an account This mutation allows linking cloud provider accounts to a New Relic account, creating one or more linked accounts. It can link one specific cloud provider account (for example aws) to the New Relic account or multiple cloud provider accounts to one New Relic account. Required: The parameter <PROVIDER_ACCOUNT_NAME> is required and cannot be empty. It must be unique in your New Relic account. Other parameters are specific to the provider (AWS, GCP, and Azure) and are also required. In the following sections, you can see which parameters are required for each provider account. After linking an account the createdAt and updatedAt values are equal. mutation { cloudLinkAccount( accounts: { accountId: <NR_ACCOUNT_ID>, aws: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] azure: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, <other_params> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account This mutation links an Amazon AWS provider account to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link an Amazon AWS account using CloudWatch Metric Streams This mutation links an Amazon AWS account sending data through CloudWatch Metric Streams to your New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN>, metricCollectionMode: PUSH }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } } Copy Link a Microsoft Azure account This mutation links a Microsoft Azure cloud subscription to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { azure: [{ name: <PROVIDER_ACCOUNT_NAME>, applicationId: <azure_application_id>, clientSecret: <azure_application_key>, tenantId: <azure_tenant_id>, subscriptionId: <azure_subscription_id> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Link a Google Cloud Platform (GCP) project This mutation links a GCP project to the New Relic account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { gcp: [{ name: <PROVIDER_ACCOUNT_NAME>, projectId: <GCP_PROJECT_ID> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } } } Copy Rename one or more cloud accounts This mutation allows you to rename one or more linked provider accounts. The name parameter is required, cannot be empty, and must be unique within your New Relic account. mutation { cloudRenameAccount( accountId: <NR_ACCOUNT_ID>, accounts: [ { id: <linked_cloud_account_id_1>, name: <new_provider_account_name> }, { id: <linked_cloud_account_id_2>, name: <new_provider_account_name> } ] ) { linkedAccounts { id name } } } Copy Enable an integration in a cloud account This mutation allows you to enable the monitoring of one or more specific cloud integrations in an existing cloud account. With this mutation, New Relic records data for the enabled integration from the provider account. For each provider account you have access to different input parameters, matching each available service. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, <other_parameters> }] } } ) { integrations { id name integration { id slug } ... on SqsIntegration { awsRegions } } } } Copy Enable an integration in multiple cloud accounts If you have many provider accounts linked, you can enable the same integration in the many cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug> : { <integration_slug> : [ { linkedAccountId: <linked_cloud_account_id_1> }, { linkedAccountId: <linked_cloud_account_id_2> } ] } } ) { integrations { id name integration { id name } ... on SqsIntegration { awsRegions } } } } Copy Enable multiple integrations in multiple cloud accounts If you have multiple cloud accounts linked, you can also enable multiple integrations in multiple linked cloud accounts at the same time. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug_1>: { <integration_slug_1>: [ { linkedAccountId: <linked_cloud_account_id_1> } ] <integration_slug_2>: [ { linkedAccountId: <linked_cloud_account_id_2> } ] }, <provider_slug_2>: { <integration_slug_3>: [ { linkedAccountId: <linked_cloud_account_id_3>}, { linkedAccountId: <linked_cloud_account_id_4>} ] } } ) { integrations { id name service { id name } ... on SqsIntegration { awsRegions } } } } Copy Modify an integration's configuration (regions, polling intervals, etc.) This mutation also allows you to modify one or more cloud integrations and change one or more configuration parameters. Each service will have specific parameters that you can modify. For parameters of a type list (for example, awsRegion) supply the full list. For the output of the operation, you can use GraphQL fragments to ask for integration specific configuration parameters. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { <provider_slug>: { <integration_slug>: [{ linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: <new_polling_interval>, <parameter_1>: <value_1>, <parameter_N>: <value_N>, }] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval, <parameter_1>, <parameter_N> } } errors { type message } } } Copy Disable (remove) an integration This mutation allows you to disable an integration and stop data collection for the specific cloud integration. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { : { : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id name authLabel provider { id } } errors { type message } } } Copy Unlink account This mutation allows you to unlink cloud provider accounts from New Relic account. Caution This action can not be undone. However, you can link the account again, but account history will still be lost. mutation { cloudUnlinkAccount ( accountId: <NR_ACCOUNT_ID>, accounts: { { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } } ) { unlinkedAccounts { id name } errors { type message } } } Copy Enable an Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To enable an Amazon AWS integration: Send query to fetch account data Send a query to fetch data about the account, specifically available providers and already created provider accounts: { actor { account(id: <NR_ACCOUNT_ID>) { cloud { providers { id name slug } linkedAccounts { name integrations { id name } } } } } } Copy Link AWS provider account Link an AWS provider account, if there is not one already linked or if you want to link another AWS account: Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter. Provide a name for the provider account in the <PROVIDER_ACCOUNT_NAME>. Include the ARN of the AWS role used to fetch data from your AWS account. mutation { cloudLinkAccount( accountId: <NR_ACCOUNT_ID>, accounts: { aws: [{ name: <PROVIDER_ACCOUNT_NAME>, arn: <AWS_ROLE_ARN> }] } ) { linkedAccounts { id name authLabel createdAt updatedAt } errors { type message } } } Copy Enable Amazon AWS SQS integration Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider account in the <LINKED_CLOUD_ACCOUNT_ID> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { integrations { id name service { id name } } errors { type message } } } Copy Enable integration in multiple provider accounts If you have multiple accounts with the same provider account, you can enable the same integration in multiple provider accounts at the same time. Use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the ID of the provider accounts in the <LINKED_CLOUD_ACCOUNT_ID_n> parameter value. mutation { cloudConfigureIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_1> }, { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID_2>, configuration_param_1: value_1, configuration_param_2: value_2 } ] } } }) { integrations { id name service { id name } } errors { type message } } } Copy Change polling interval for Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To change the polling interval of an AWS integration: Update the polling interval To update the polling interval for an Amazon AWS SQS integration, use your New Relic account ID in the <NR_ACCOUNT_ID> parameter and the id of the linked provider account in the <LINKED_ACCOUNT_ID> parameter value: mutation { cloudConfigureIntegration( accountId: <NR_ACCOUNT_ID>, integrations: { aws : { sqs: [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID>, metricsPollingInterval: 300 } ] } } ) { integrations { id name service { id slug } ... on SqsIntegration { metricsPollingInterval } } errors { type message } } } Copy Disable Amazon AWS integration This example uses an Amazon AWS SQS integration and assumes you have connected an AWS account to New Relic. To disable an AWS integration: Disable the SQS integration Use your New Relic account identifier in the <NR_ACCOUNT_ID> parameter and the ID of the linked cloud account the <LINKED_ACCOUNT_ID> parameter value. mutation { cloudDisableIntegration ( accountId: <NR_ACCOUNT_ID>, integrations: { aws: { sqs : [ { linkedAccountId: <LINKED_CLOUD_ACCOUNT_ID> } ] } } ) { disabledIntegrations { id accountId name } errors { type message } } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 75.110214,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Query <em>examples</em>",
        "tags": "<em>Examples</em>",
        "body": " accounts available in your infrastructure data. Depending on the provider, additional properties can be requested. For <em>example</em>, for GCP, you can also ask for the serviceAccountId property, which is needed when linking a new GCP project to New Relic. Anonymous: { actor { account(id: &lt;NR_ACCOUNT_ID"
      },
      "id": "6044293864441f1bdc378f05"
    }
  ],
  "/docs/azure-cosmos-db-document-db-monitoring-integration-deprecated": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/infrastructure-release-notes/cloud-integration-release-notes/azure-databases-postgresql-mysql-mariadb-monitoring-integration/",
      "sections": [
        "Azure Databases for PostgreSQL, MySQL, and MariaDB monitoring integration",
        "New",
        "Changes"
      ],
      "published_at": "2021-07-02T11:47:29Z",
      "title": "Azure Databases for PostgreSQL, MySQL, and MariaDB monitoring integration",
      "updated_at": "2021-03-16T16:56:33Z",
      "type": "docs",
      "external_id": "cecb399449edbacdbaff5baa5a7f864a0e97656f",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Three new Azure Database integrations are now available: Azure Database for PostgreSQL Azure Database for MySQL Azure Database for MariaDB Changes The Azure Cosmos DB integration has been updated to gather metrics through the new Azure SDK. Details on all the new metrics can be found in the new Azure Cosmos DB integration documentation. For information on deprecated Cosmos DB events and metrics, see Azure Cosmos DB integration (deprecated). We strongly recommend migrating to the supported events and metrics in the new Azure Cosmos DB integration.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 187.55368,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Azure</em> Databases for PostgreSQL, MySQL, and MariaDB monitoring integration",
        "sections": "<em>Azure</em> Databases for PostgreSQL, MySQL, and MariaDB monitoring integration",
        "body": " <em>Azure</em> <em>Cosmos</em> <em>DB</em> integration documentation. For information on <em>deprecated</em> <em>Cosmos</em> <em>DB</em> events and <em>metrics</em>, see <em>Azure</em> <em>Cosmos</em> <em>DB</em> integration (<em>deprecated</em>). We strongly recommend migrating to the supported events and <em>metrics</em> in the new <em>Azure</em> <em>Cosmos</em> <em>DB</em> integration."
      },
      "id": "603e8d59196a67698fa83d85"
    },
    {
      "sections": [
        "Azure Cosmos DB (Document DB) monitoring integration",
        "Important",
        "Features",
        "Activate integration",
        "Configuration and polling",
        "View and query data",
        "Metric data",
        "Account Data",
        "DataBase Data",
        "Collection Data",
        "Inventory data"
      ],
      "title": "Azure Cosmos DB (Document DB) monitoring integration",
      "type": "docs",
      "tags": [
        "Integrations",
        "Microsoft Azure integrations",
        "Azure integrations list"
      ],
      "external_id": "fa5bd1f3ef6886f2999debbb913d732a6cf0acb2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/integrations/microsoft-azure-integrations/azure-integrations-list/azure-cosmos-db-document-db-monitoring-integration/",
      "published_at": "2021-07-02T16:14:11Z",
      "updated_at": "2021-03-11T07:43:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic infrastructure monitoring provides an integration for Microsoft Azure's Cosmos DB service that reports your Cosmos DB metrics and inventory data to New Relic. This document explains how to activate the Cosmos DB integration and describes the data that can be captured. Important For information on deprecated Cosmos DB events or metrics, see Azure Cosmos DB integration (deprecated). We strongly recommend migrating to the supported events and metrics in this document. Features New Relic gathers both database data and collection billing data from your Azure Cosmos DB service. You can monitor and alert on your Azure Cosmos DB data from New Relic, and you can create custom queries and custom chart dashboards. Activate integration To enable this integration follow standard procedures to activate your Azure service in New Relic. The Cosmos DB integration requires you to create an additional role and permission to fetch database and collection data: Go to the Azure Portal and open a shell by selecting the terminal icon. Add the following command: az role definition create --role-definition '{ \"Name\": \"NewRelic Integrations\", \"Actions\": [ \"*/read\", \"Microsoft.DocumentDB/databaseAccounts/listKeys/action\" ], \"NotActions\": [], \"AssignableScopes\": [ \"/subscriptions/YOUR_INSERT_SUBSCRIPTION_ID\" ], \"Description\": \"Read Only for NewRelic Integrations\", \"IsCustom\": \"true\" }' Copy From Services > Subscriptions, select the subscription, go to Access control (IAM), and then select Add. In the Role search box, add the name of the newly created role definition (for example, NewRelic Integrations). In the Select search box, add the name of the New Relic integration application, and select it. Ensure that the application is added to the Selected members list, then Save. Configuration and polling You can change the polling frequency and filter data using configuration options. Default polling information for the Cosmos DB integration: Polling interval: 5 minutes Resolution: 1 minute or 5 minutes, varies by metric. For resolution information on a specific metric, see Microsoft Azure's documentation about support metrics. View and query data To view your integration data, go to one.newrelic.com > Infrastructure > Azure and select the Cosmos DB Integration. You can query and explore your data using the following event types: Entity Event Type Provider Account AzureCosmosDbAccountSample AzureCosmosDbAccount Database AzureCosmosDbDatabaseSample AzureCosmosDbDatabase Collection AzureCosmosDbCollectionSample AzureCosmosDbCollection For more on how to find and use data, see Understand and use integration data. Metric data Important For information on deprecated Cosmos DB events or metrics, see Azure Cosmos DB integration (deprecated). We strongly recommend migrating to the supported events and metrics in this document. To view metrics reported by the Cosmos DB integration, query the Entities below. Use the metadata associated with each metric to filter and facet the data being reported. For detailed metric information, see the Azure supported metrics documentation. Account Data Metric Description Metadata totalRequests Total number of requests. account kind region offerType statusCode resourceGroup metadataRequests Count of metadata requests. account kind region offerType statusCode resourceGroup mongoRequests Count of Mongo requests made. account kind region commandName offerType errorCode resourceGroup mongoRequestCharge Total number of Mongo request units consumed. account kind region commandName offerType errorCode resourceGroup totalRequestUnits Total number of request units consumed. account kind region offerType statusCode resourceGroup provisionedThroughput Throughput provisioned for the database or collection. account offerType kind resourceGroup availableStorageBytes Total available storage, in bytes. account kind offerType region resourceGroup dataUsageBytes Total data usage reported, in bytes. account kind offerType region resourceGroup indexUsageBytes Total index usage reported, in bytes. account kind offerType region resourceGroup documentQuotaBytes Total storage quota reported, in bytes. account kind offerType region resourceGroup documentCount Total document count reported. account kind offerType region resourceGroup ReplicationLatency P99 replication latency across source and target regions for geo-enabled account, in milliseconds. account kind sourceRegion offerType targetRegion resourceGroup ServiceAvailability Account requests availability percentage in hour, day, or month granularity. No specific metadata. cassandraRequests Count of Cassandra requests made. account kind errorCode offerType opperationType region resourceType resourceGroup cassandraRequestCharges Total number of request units consumed for Cassandra requests. account kind errorCode offerType opperationType region resourceType resourceGroup cassandraConnectionClosures Total number of Cassandra connections that were closed. account kind closureReason offerType region resourceGroup DataBase Data Metric Description Metadata totalRequests Total number of requests. account databaseName region statusCode metadataRequests Count of metadata requests. account databaseName region statusCode mongoRequests Count of Mongo requests made. account databaseName region commandName errorCode mongoRequestCharge Total number of Mongo request units consumed. account databaseName region commandName errorCode totalRequestUnits Total number of request units consumed. account databaseName region statusCode provisionedThroughput Throughput provisioned for the database or collection. account databaseName availableStorageBytes Total available storage, in bytes. account databaseName region dataUsageBytes Total data usage reported, in bytes. account databaseName region indexUsageBytes Total index usage reported, in bytes. account databaseName region documentQuotaBytes Total storage quota reported, in bytes. account databaseName region documentCount Total document count reported. account databaseName region replicationLatencyMilliseconds P99 replication latency across source and target regions for geo-enabled account, in milliseconds. account sourceRegion targetRegion serviceAvailabilityPercent Account requests availability percentage in hour, day, or month granularity. No specific metadata. cassandraRequests Count of Cassandra requests made. account databaseName errorCode opperationType region resourceType cassandraRequestCharges Total number of request units consumed for Cassandra requests. account databaseName errorCode opperationType region resourceType cassandraConnectionClosures Total number of Cassandra connections that were closed. account closureReason region DataBase Data Metric Description Metadata totalRequests Total number of requests. account databaseName region statusCode metadataRequests Count of metadata requests. account databaseName region statusCode mongoRequests Count of Mongo requests made. account databaseName region commandName errorCode mongoRequestCharge Total number of Mongo request units consumed. account databaseName region commandName errorCode totalRequestUnits Total number of request units consumed. account databaseName region statusCode provisionedThroughput Throughput provisioned for the database or collection. account databaseName availableStorageBytes Total available storage, in bytes. account databaseName region dataUsageBytes Total data usage reported, in bytes. account databaseName region indexUsageBytes Total index usage reported, in bytes. account databaseName region documentQuotaBytes Total storage quota reported, in bytes. account databaseName region documentCount Total document count reported. account databaseName region replicationLatencyMilliseconds P99 replication latency across source and target regions for geo-enabled account, in milliseconds. account sourceRegion targetRegion serviceAvailabilityPercent Account requests availability percentage in hour, day, or month granularity. No specific metadata. cassandraRequests Count of Cassandra requests made. account databaseName errorCode opperationType region resourceType cassandraRequestCharges Total number of request units consumed for Cassandra requests. account databaseName errorCode opperationType region resourceType cassandraConnectionClosures Total number of Cassandra connections that were closed. account closureReason region Collection Data Metric Description Metadata totalRequests Total number of requests. account collectionName database region statusCode metadataRequests Count of metadata requests. account collectionName database region statusCode mongoRequests Count of Mongo requests made. account collectionName database region commandName errorCode mongoRequestCharge Total number of Mongo request units consumed. account collectionName database region commandName errorCode totalRequestUnits Total number of request units consumed. account collectionName database region statusCode provisionedThroughput Throughput provisioned for the database or collection. account collectionName database availableStorageBytes Total available storage, in bytes. account collectionName database region dataUsageBytes Total data usage reported, in bytes. account collectionName database region indexUsageBytes Total index usage reported, in bytes. account collectionName database region documentQuotaBytes Total storage quota reported, in bytes. account collectionName database region documentCount Total document count reported. account collectionName database region replicationLatencyMilliseconds P99 replication latency across source and target regions for geo-enabled account, in milliseconds. account collectionName sourceRegion targetRegion serviceAvailabilityPercent Account requests availability percentage in hour, day, or month granularity. No specific metadata. cassandraRequests Count of Cassandra requests made. account collectionName database errorCode opperationType region resourceType cassandraRequestCharges Total number of request units consumed for Cassandra requests. account collectionName database errorCode opperationType region resourceType cassandraConnectionClosures Total number of Cassandra connections that were closed. account collectionName closureReason region Inventory data Inventory data is information about your system's state and configuration. For details on how to find and use inventory data, see Understand and use data. The Cosmos DB integration reports the inventory data for the entity type azure/cosmosdb/account/ using the following metadata: documentEndpoint: The document end point. databaseAccountOfferType: The database account offer type. consistencyPolicy: The consistency policy for the Cosmos DB database account. defaultConsistencyLevel: The default consistency level for the Cosmos DB database account. kind: The type of database account set at database account creation. resourceGroupName: The Azure resource group name that the Cosmos DB database account belong to. regionName: The region name in which the Azure DocumentDB database account is deployed. type: The azure resource type, which is Microsoft.DocumentDB/databaseAccounts.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.62288,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Azure</em> <em>Cosmos</em> <em>DB</em> (Document <em>DB</em>) monitoring integration",
        "sections": "<em>Azure</em> <em>Cosmos</em> <em>DB</em> (Document <em>DB</em>) monitoring integration",
        "tags": "Microsoft <em>Azure</em> integrations",
        "body": " events or <em>metrics</em>, see <em>Azure</em> <em>Cosmos</em> <em>DB</em> integration (<em>deprecated</em>). We strongly recommend migrating to the supported events and <em>metrics</em> in this document. To view <em>metrics</em> reported by the <em>Cosmos</em> <em>DB</em> integration, query the Entities below. Use the metadata associated with each <em>metric</em> to filter and facet"
      },
      "id": "60450b8728ccbc77202c6083"
    },
    {
      "sections": [
        "Refactor your applications",
        "1. Deploy monitoring",
        "Cloud-based integrations",
        "2. Set deployment markers",
        "3. Establish baselines",
        "4. Refactor your applications",
        "5. Create dashboards to track refactoring your applications",
        "6. Create comparison dashboards",
        "For more help"
      ],
      "title": "Refactor your applications",
      "type": "docs",
      "tags": [
        "New Relic solutions",
        "New Relic solutions",
        "Cloud adoption"
      ],
      "external_id": "fcea859e043f6ff33898803636b9a7a6de04508a",
      "image": "https://docs.newrelic.com/static/fc360bb9af89fe16ea8351e90b16ec09/c1b63/screen-deployments-page.png",
      "url": "https://docs.newrelic.com/docs/new-relic-solutions/new-relic-solutions/plan-your-cloud-adoption/refactor-your-applications/",
      "published_at": "2021-07-02T21:09:54Z",
      "updated_at": "2021-05-15T22:19:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "At each step of your cloud adoption process, New Relic plays a critical role in helping you establish baselines, prioritize migration steps, validate improvements, and manage cloud costs. New Relic can also help you refactor, or re-architect, your software and services when you migrate them to the cloud. One key aspect of refactoring your software is splitting out your components into different services available from your cloud provider. For example, you might move your database component away from a traditional MySQL database to a cloud-hosted solution, like Amazon Relational Database (RDS) services such as DynamoDB or Aurora. If you move to the Azure cloud, you might adopt Azure SQL or Cosmos DB. When you move to solutions like those, you increase your database redundancy and resiliency. If you evaluate your overall ROI properly, you should start to see the cost/benefit ratio taking effect once you complete your refactoring. 1. Deploy monitoring New Relic is a true multi-tenant SaaS solution, meaning New Relic designed the agents to work at every layer of your application stack. To get started, deploy the agents: APM to collect application-tier performance metrics Browser monitoring to collect front-end web metrics Mobile monitoring to collect front-end mobile app metrics Infrastructure to collect host/server metrics Cloud-based integrations As you refactor your application and integrate new cloud services, you can also use New Relic to monitor and report data about your cloud services, offering you a comprehensive view of your entire architecture in one place. Cloud-based integrations available through New Relic include Amazon Web Services (AWS) and Microsoft Azure. This tutorial describes a database migration and focuses on APM and Infrastructure. 2. Set deployment markers With New Relic, you can track deployments by setting deployment markers. Deployment tracking lets you quickly see how deployments affect your applicationâ€™s performance and gauge its performance before and after you refactor. You can view deployments on the Deployments page in APM: rpm.newrelic.com/apm > (selected app) > Events > Deployments: Here is an example of the Deployments page and details about a selected deployment. 3. Establish baselines When you install the APM agent at the application layer, New Relic immediately starts collecting and displaying metrics. Use these metrics to set your pre-migration application baseline. APM agents collect performance metrics about outbound calls to databases. In the Monitoring section of the APM UI, click Databases to see a view of your database metrics. The following shows a database running on MySQL that will be refactored to use DynamoDB after migrating to AWS: one.newrelic.com > APM > (select an app) > Monitoring > Databases: Use this page to view and sort detailed information about database performance. 4. Refactor your applications To take advantage of the cloud, research what services are available from your cloud provider, and then re-architect and uncouple your applications. 5. Create dashboards to track refactoring your applications Apply your KPIs to your baseline measurements to validate cloud improvements, and, ideally, start seeing the impact of moving to the cloud. New Relicâ€™s reporting for database interactions goes much deeper than high-level performance metrics about calls to the database layer in APM. You get access to metrics about slow queries so you can filter by database vendor and cache type. You can also see host and instance details for databases visually within Service Maps and within the context of transaction traces. Because all of your performance metrics are available in New Relic Insights, it is easy to build dashboards to show the performance of your database calls before, during, and after your refactoring in a single unified view. Here is an example of an Insights dashboard for an application that uses DynamoDB and was migrated to AWS: insights.newrelic.com: Build a dashboard that shows the performance of your database calls. 6. Create comparison dashboards To compare both the pre- and post-refactor baselines, create an Insights dashboard that displays the KPIs you baselined. The following dashboard shows the MySQL request query latency as compared with all of the operations for DynamoDB. You can see that, for this example, the request query latency for DynamoDB is too small to even register on the graph. Performance is clearly optimized with this cloud-based database. insights.newrelic.com: Use Insights dashboards to visualize pre- and post-refactor baselines. With APM agents and the integrations New Relic provides, you can measure the effectiveness of refactoring your applications using a broad spectrum of metrics. For more help Explore the New Relic Platform.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 100.967255,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": ") services such as Dynamo<em>DB</em> or Aurora. If you move to the <em>Azure</em> cloud, you might adopt <em>Azure</em> SQL or <em>Cosmos</em> <em>DB</em>. When you move to solutions like those, you increase your database redundancy and resiliency. If you evaluate your overall ROI properly, you should start to see the cost&#x2F;benefit ratio taking"
      },
      "id": "60445da6e7b9d2bf265799ee"
    }
  ],
  "/docs/browser/browser-monitoring/browser-pro-features/ajax-page-identify-time-consuming-calls": [
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 337.3715,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>Pro</em> <em>features</em>",
        "body": " support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for <em>Browser</em> <em>monitoring</em>: Make sure you meet requirements, including having: Full-Stack Observability <em>Browser</em> <em>Pro</em>"
      },
      "id": "6043fe6f196a6784f0960f53"
    },
    {
      "sections": [
        "Filterable Geography: Webpage metrics by location",
        "Contents",
        "Requirements",
        "Factors affecting collected data",
        "View performance data by location",
        "Use map functions",
        "Tip",
        "Examine heat map details",
        "Filter performance metrics",
        "Unsatisfactory network performance by ASN",
        "Page rendering performance during sales promotion",
        "View comparative performance details",
        "Available metrics",
        "Performance and usage ranges",
        "Performance color ranges",
        "Usage color ranges",
        "For more help"
      ],
      "title": "Filterable Geography: Webpage metrics by location",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "6d8527b8a2ead507b7cfa95a87a7c75c567c1ee6",
      "image": "https://docs.newrelic.com/static/01bcd89f3ae221d22e388d936cede641/8c557/screen-browser-filter-geography.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/filterable-geography-webpage-metrics-location/",
      "published_at": "2021-07-02T00:24:05Z",
      "updated_at": "2021-05-16T09:50:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Browser's Filterable Geography page provides a world view with color-coded performance information about cities, regions, and countries anywhere around the world. You can filter and drill down into detailed information, or use your mouse to select or zoom in and out of any location on the map. The enhanced attributes provide deep visibility not only about your end users' experience with page load timing, but also with network performance anywhere around the world. This level of visual detail is especially useful for professionals in IT and Operations to make business decisions about peering agreements and CDN usage. Contents Requirements Your New Relic Browser subscription level and your time picker settings determine what data you can view: Pro or higher: As of January 2016, the Filterable Geography feature automatically appears in your New Relic Browser user interface. No special setup is required. You can view up to eight days of data. Your application must be enabled to send PageView data to New Relic Insights in order to use Filterable Geography. Lite: The Filterable Geography feature appears in your New Relic Browser's UI menu but currently is not available for use. Any subscription level: If you need to use New Relic Browser's legacy Geography feature, you can still view it from your selected browser app. Factors affecting collected data To capture page load timing information, New Relic Browser uses the Navigation Timing API, which most (but not all) browsers support. If the browsers do not support the Navigation Timing API, then New Relic Browser charts and data points can only show the network data they receive for DNS lookup, connection, secure handshake, etc. This may not be 100% of the app's overall traffic. Also, firewalls may have an impact on the geographical data collected about your end users. View performance data by location one.newrelic.com > Browser > (select an app) > Browser app > Filterable Geography: Here is an example of the map before drilling down into detailed information about London, England. To view or sort the performance information by location: Go to one.newrelic.com > Browser > (select an app) > Filterable Geography. Select the type of performance data to view from the dropdown, or use the default Average page load time. To drill down to a specific area, mouse over or select any area on the geographical map, or select any of the ten worst performing locations from the list to the right of the map. To view specific performance metrics, select any of the attributes below the funnel icon. To view comparison data, select the Page load performance or Historical performance chart below the selected location's geographical map. Use map functions Use any of New Relic's standard user interface functions and page functions to drill down into detailed information. Here is a summary of additional options with the Filterable Geography page. If you want to... Do this... Change what kind of performance data appears Select your choice from the dropdown. Default performance indicator is Average page load time. The map's legend lists the ten best or worst performing areas (depending on the selected performance indicator) for the selected time period. For example: If you select Count, the map's legend shows the top ten locations with the highest number of page loads, as well as the average page load time for each. If you select Connection setup, New Relic Browser first filters out areas with low throughput. Then the map's legend shows the top ten locations where average connection time is the slowest, as well as the average page load time and count for each. View summary performance information about a specific location Mouse over any colored area on the map, select a location from the list, or zoom in and out of any area on the map. View detailed data for a location Select any area of the map. For example: If you select Canada, the map and legend show color-coded performance data for each province and territory. The list to the right of the map shows the top ten worst performing areas. If you select a specific province or territory, the map shows color-coded performance data for the top ten cities. The map includes circled locations which you can mouse over or select to view detailed information. In addition, the Page load performance and Historical performance charts below the map automatically update with each location you select. Hide the list of available attributes Select the funnel icon. Return to a larger world view Select another location on the map, or clear the filter labels above the map. Tip To return to the original map view of the world, select any area on an ocean. Examine heat map details one.newrelic.com > Browser > (select an app) > Browser app > Filterable Geography: Here is an example of the map as you use filter and zoom tools to drill down into detailed information about London, England. Athough overall throughput for the area is good (green), the nearby yellow areas, and the smaller red and orange circles indicate nearby cities with varying levels of throughput problems, not the size of those cities. The Filterable Geography heat map identifies performance quality with color and with the size of circles. Heat map Description Color scale Performance quality ranges from green (the best) to yellow, orange, and then red (the worst). When selecting indicators of usage rather than performance, the heat map shows shades of purple, with the darkest shades indicating the highest usage. The color scale adapts to your app's specific performance. Each area is a percentile range. To view the range for each color segment, mouse over the heat map's legend. Thresholds Different thresholds are dynamically applied to the colors based on the type of performance indicator you select from the dropdown and the maximum value your app has reported. For example, green for Average page load time may indicate 0 to 3.3 seconds, while green for Average network time may indicate 0 to 256 milliseconds. Circles The map's colored circles help you identify areas with performance problems at a glance. Each circle's radius is based on throughput reported for the city it represents, not the size of the city itself. You may see many circles overlapping each other. This usually indicates a grouping of metropolitan areas which represent a geographic area of heavy traffic. Filter performance metrics The Filter feature allows you to select and group data by attributes in various categories, including: Page view Geography Browser Identity Custom The filtered results appear on the geographical map, where you can use any of the standard map functions to explore additional details. Here are some examples. Unsatisfactory network performance by ASN In this example, your organization is preparing to renew a peering agreement with the owner of an autonomous system, called \"My-ASN.\" You are concerned that continued outages and other connection issues are affecting customer satisfaction with your site, and you want to compare its performance with other ASNs. You have a New Relic Browser Pro account. Go to one.newrelic.com > Browser > (select an app) > Filterable Geography. From the performance type dropdown, select Connection setup. Select the funnel icon. To view the specific ASN's performance: From the search window, type My-ASN, and then select this name from the Filter by results. OR To compare performance with other ASNs: From Geography attributes > ASN organizations, review the performance data for each organization on the list, and then select Back to groupings list. To close the filter list, select the funnel icon. Follow standard procedures to use the map functions and view comparative performance details. To clear the filter, select the attribute name. Page rendering performance during sales promotion In this example, your organization has a special three-day sales promotion for an upcoming holiday. Your holiday-merchandise page has undergone major changes, including dozens of new images. You want to look for performance problems with page rendering on Android mobile devices during this sales period. You have a New Relic Browser Pro account. Go to one.newrelic.com > Browser > (select an app) > Filterable Geography. Use the time picker to change the date range to the promotion period. From the performance type dropdown, select Page rendering. Select the funnel icon. From Page view attributes > Page Url, select your site's holiday-merchandise page, and then select Back to groupings list. From Browser attributes > User agent OS, select Android, and then select Back to groupings list. To close the filter list, select the funnel icon. Follow standard procedures to use the map functions and view comparative performance details. To clear the filters, select their attribute names. View comparative performance details Charts on the Page load performance and Historical performance tabs automatically refresh with comparative performance details for the selected location. one.newrelic.com > Browser > (select an app) > Browser app > Filterable Geography: Charts on the Page load performance and Historical performance tabs automatically refresh with details for the selected location. The Page load performance tab shows two charts. The Average page load time chart includes: Average page load time for each segment of the page load timing process in seconds Request queuing information (the time after a request enters your production systems and before it reaches your application) if applicable The Average network time chart shows key elements, including how long it takes for DNS lookup, connection establishment, and secure handshake, in seconds. Tip Sometimes areas on the charts may appear to be zero or near zero. This is because some apps use existing TCP connections, and they do not need to establish new connections. The Historical performance tab shows comparison data for the selected time period, yesterday, and last week for the selected location. This includes: Average response time Throughput in pages per minute (ppm) Available metrics You can filter and group geographical performance data in New Relic Browser and in New Relic Insights. Available metrics include: Performance Metrics Webpage Page load time Throughput (pages per minute or ppm) Network time Connection time Secure connection time Network Autonomous system number and name (ASN) via IP mapping SSL negotiation timing DNS timing Time to first byte ASN latitude and longitude for Internet service providers (ISPs) To ensure end user security, New Relic Browser collects GeoIP information for the end user's ISP. New Relic Browser does not collect GeoIP information for the specific end user. For example, if an end user in Portland, Oregon uses an ISP located in Beaverton, Oregon, New Relic Browser collects the GeoIP information for the ISP in Beaverton. User agents Operating systems Browser names or types Browser versions Device types Performance and usage ranges The color-coded legend shows performance and usage as percentile ranges. Performance color ranges Percentile colors for performance range from green (the best) to red (the worst). Performance percentile ranges (best to worst) Green Yellow Orange Red Back-end duration 0-74.9 75-86.9 87-94.9 95+ Connection setup duration 0-96.9 97-97.9 98-98.9 99+ DNS lookup duration 0-96.9 97-97.9 98-98.9 99+ DOM processing duration 0-74.9 75-86.9 87-94.9 95+ Network duration 0-74.9 75-86.9 87-94.9 95+ Page load duration 0-74.9 75-86.9 87-94.9 95+ Page rendering duration 0-74.9 75-86.9 87-94.9 95+ Queue duration 0-74.9 75-86.9 87-94.9 95+ Secure handshake duration 0-96.9 97-97.9 98-98.9 99+ Web app duration 0-74.9 75-86.9 87-94.9 95+ Usage color ranges Percentile colors for usage counts appear as shades of purple, from lightest (lowest usage) to darkest (highest usage). Usage percentile ranges (lowest to highest) Lightest purple Light purple Darker purple Darkest purple Page load count 0-79.9 80-89.9 90-99.9 100 Unique sessions count 0-79.9 80-89.9 90-99.9 100 For more help Additional documentation resources include: Browser Geography (legacy Geography page with Apdex scores and performance information by location) Page views (details about end users' overall experience with your site)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.8843,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Page rendering performance during sales <em>promotion</em>",
        "tags": "<em>Browser</em> <em>Pro</em> <em>features</em>",
        "body": " peering agreements and CDN usage. Contents Requirements Your New Relic <em>Browser</em> subscription level and your time picker settings determine what data you can view: <em>Pro</em> or higher: As of January 2016, the Filterable Geography feature automatically appears in your New Relic <em>Browser</em> user interface"
      },
      "id": "6043fe6f28ccbc910c2c606a"
    },
    {
      "sections": [
        "Session traces: Explore a webpage's life cycle",
        "Identify problems and solutions",
        "Requirements",
        "Select a session trace",
        "Tip",
        "View session trace details",
        "Session segment definitions",
        "Slow JavaScript execution and repainting"
      ],
      "title": "Session traces: Explore a webpage's life cycle",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "2d34d77c7661be3ebd3f04a8188fe36d7233895f",
      "image": "https://docs.newrelic.com/static/a7f12a1603efe1412d15b9a51a312548/c1b63/browser_sessiontraces_overview.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/browser-pro-features/session-traces-explore-webpages-life-cycle/",
      "published_at": "2021-07-02T09:13:21Z",
      "updated_at": "2021-03-16T08:23:46Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's session traces provide a detailed timeline of the load and interaction events during a webpage's full life cycle, for as long as ten minutes. Page load timing, individual asset loads, user interactions, AJAX requests, callbacks, errors, and other events appear in an interactive timeline which includes a detailed waterfall visualization, a heat map overview, and highlighted metrics and problems related to that session. Identify problems and solutions Session traces help you understand: How users experience your page load, including time to DOM load, time waiting for AJAX requests to complete, and the user's interactions with the page How the New Relic metrics reflect your end users' experiences What is the sequence of JavaScript and browser events, which take longer than others, and when each event occurs Where bottlenecks occur, and what may be causing them Why one page load may be slower than others, by providing the context for individual events during a session By connecting performance to user experience and interactions to performance, this detailed and intuitive visualization of all events in the user's session can help pinpoint problem areas and easily identify solutions. Requirements To use Browser monitoring's session traces feature, make sure you meet these requirements: Your agent version must support Browser monitoring. If you're using multiple names for an app, session traces will only report to the most specific application. For accounts older than October 2014, you must enable Browser monitoring and the enhanced Pro features. Browser randomly captures traces only from browsers that support the Resource Timing API. Select a session trace The Session traces index lists the most recent traces based on the time picker selection for the selected app. Session traces are randomly sampled and stored at a rate of 90/hour. You can page through up to 500 traces at a time. Additionally, you can sort and search the list by attributes, including: Full URL, with query string parameters removed Browser type Started at date/time Page load time one.newrelic.com > Browser > (select an app) > Session traces: You can select a session trace from the Browser index. You can also select a session trace directly from the Browser Summary, Page views, JS errors, and AJAX pages. To select a specific session trace: Go to one.newrelic.com and click Browser > (select an app) > Session traces. To locate a session trace from a different date or time period, use the time picker. To limit the index to a specific type of trace, use the search window. To view detailed information, select the session trace's link. Tip You can also select a session trace directly from the Browser Summary, Page views, JS errors and AJAX pages. View session trace details The Session trace details page provides summary information about the trace, a heat map with timing details, and a waterfall of events that you can explore. The color-coded legend identifies the page load events during the webpage's life cycle. For apps that have been deployed using the copy/paste method, Browser monitoring includes web app and queue time in Network time as part of the page load timing process. This is because Browser relies on the server-side agent to pass the application values to the Browser agent through auto-injection. You can view detailed information about how this \"back end\" time breaks down from the browser's point of view. The session traces report on all the network related events available, so you can see on a case-by-case basis how the browser spends time on DNS lookups and other network events. one.newrelic.com > Browser > (select an app) > Session traces > (select a trace): Use Browser's session trace details to examine events and identify problems during the end user's webpage session. To navigate through a session trace, explore the waterfall chart by scrolling vertically through the event stack, or select individual events to view their details. If you want to... Do this... View the web page for this session trace Select the trace link. Jump to a specific time Select the time indicator or event on the heat map. View details about individual events Select any event in the waterfall chart. From there, select View full details if applicable. Change the location on the session trace Click on the heat map, or scroll vertically through the waterfall chart. Zoom in or out of the overall trace Select the plus or minus icons below the heat map. Share the session trace information Create a permalink to paste into a form, ticket, email, etc. Session segment definitions Important session trace measurements are displayed in the upper right corner of the Session traces page. The first four measurements represent how long into a session that the segment ended. For example, if Page Load is 0.202s, that means that the page load event completed 0.202 seconds after the request began. Session segment Description Backend The time from when the request began to when backend activity finished and DOM loading began. DOM processing The time from when the request began to when DOM processing finished. Page load The time from when the request began to when the page load event fired. Waiting on AJAX The time from when the request began to when AJAX activity ended. First interaction The time from when the request began to when the first user activity, like a mouse click or a scroll, was recorded. Duration The total duration of the session. Slow JavaScript execution and repainting Session traces help you identify callbacks in your JavaScript code that execute slowly and block the execution of subsequent calls on the browser's main thread. These calls should execute quickly in order to allow the browser to quickly repaint the page in response to user actions. Session traces highlight any callbacks longer than 33ms. If called in rapid succession (such as inside a requestAnimationFrame loop), callbacks longer than 33ms reduce the frame rate below 30 frames per second. This speed seems sluggish to users.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.56418,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Identify <em>problems</em> and solutions",
        "tags": "<em>Browser</em> <em>Pro</em> <em>features</em>",
        "body": " older than October 2014, you must enable <em>Browser</em> <em>monitoring</em> and the enhanced <em>Pro</em> <em>features</em>. <em>Browser</em> randomly captures traces only from browsers that support the Resource Timing API. Select a session trace The Session traces index lists the most recent traces based on the time picker selection"
      },
      "id": "603ecc4de7b9d2843d2a0806"
    }
  ],
  "/docs/browser/browser-monitoring/browser-pro-features/session-traces-explore-webpages-life-cycle": [
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 337.37128,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>Pro</em> <em>features</em>",
        "body": " support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for <em>Browser</em> <em>monitoring</em>: Make sure you meet requirements, including having: Full-Stack Observability <em>Browser</em> <em>Pro</em>"
      },
      "id": "6043fe6f196a6784f0960f53"
    },
    {
      "sections": [
        "Filterable Geography: Webpage metrics by location",
        "Contents",
        "Requirements",
        "Factors affecting collected data",
        "View performance data by location",
        "Use map functions",
        "Tip",
        "Examine heat map details",
        "Filter performance metrics",
        "Unsatisfactory network performance by ASN",
        "Page rendering performance during sales promotion",
        "View comparative performance details",
        "Available metrics",
        "Performance and usage ranges",
        "Performance color ranges",
        "Usage color ranges",
        "For more help"
      ],
      "title": "Filterable Geography: Webpage metrics by location",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "6d8527b8a2ead507b7cfa95a87a7c75c567c1ee6",
      "image": "https://docs.newrelic.com/static/01bcd89f3ae221d22e388d936cede641/8c557/screen-browser-filter-geography.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/filterable-geography-webpage-metrics-location/",
      "published_at": "2021-07-02T00:24:05Z",
      "updated_at": "2021-05-16T09:50:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Browser's Filterable Geography page provides a world view with color-coded performance information about cities, regions, and countries anywhere around the world. You can filter and drill down into detailed information, or use your mouse to select or zoom in and out of any location on the map. The enhanced attributes provide deep visibility not only about your end users' experience with page load timing, but also with network performance anywhere around the world. This level of visual detail is especially useful for professionals in IT and Operations to make business decisions about peering agreements and CDN usage. Contents Requirements Your New Relic Browser subscription level and your time picker settings determine what data you can view: Pro or higher: As of January 2016, the Filterable Geography feature automatically appears in your New Relic Browser user interface. No special setup is required. You can view up to eight days of data. Your application must be enabled to send PageView data to New Relic Insights in order to use Filterable Geography. Lite: The Filterable Geography feature appears in your New Relic Browser's UI menu but currently is not available for use. Any subscription level: If you need to use New Relic Browser's legacy Geography feature, you can still view it from your selected browser app. Factors affecting collected data To capture page load timing information, New Relic Browser uses the Navigation Timing API, which most (but not all) browsers support. If the browsers do not support the Navigation Timing API, then New Relic Browser charts and data points can only show the network data they receive for DNS lookup, connection, secure handshake, etc. This may not be 100% of the app's overall traffic. Also, firewalls may have an impact on the geographical data collected about your end users. View performance data by location one.newrelic.com > Browser > (select an app) > Browser app > Filterable Geography: Here is an example of the map before drilling down into detailed information about London, England. To view or sort the performance information by location: Go to one.newrelic.com > Browser > (select an app) > Filterable Geography. Select the type of performance data to view from the dropdown, or use the default Average page load time. To drill down to a specific area, mouse over or select any area on the geographical map, or select any of the ten worst performing locations from the list to the right of the map. To view specific performance metrics, select any of the attributes below the funnel icon. To view comparison data, select the Page load performance or Historical performance chart below the selected location's geographical map. Use map functions Use any of New Relic's standard user interface functions and page functions to drill down into detailed information. Here is a summary of additional options with the Filterable Geography page. If you want to... Do this... Change what kind of performance data appears Select your choice from the dropdown. Default performance indicator is Average page load time. The map's legend lists the ten best or worst performing areas (depending on the selected performance indicator) for the selected time period. For example: If you select Count, the map's legend shows the top ten locations with the highest number of page loads, as well as the average page load time for each. If you select Connection setup, New Relic Browser first filters out areas with low throughput. Then the map's legend shows the top ten locations where average connection time is the slowest, as well as the average page load time and count for each. View summary performance information about a specific location Mouse over any colored area on the map, select a location from the list, or zoom in and out of any area on the map. View detailed data for a location Select any area of the map. For example: If you select Canada, the map and legend show color-coded performance data for each province and territory. The list to the right of the map shows the top ten worst performing areas. If you select a specific province or territory, the map shows color-coded performance data for the top ten cities. The map includes circled locations which you can mouse over or select to view detailed information. In addition, the Page load performance and Historical performance charts below the map automatically update with each location you select. Hide the list of available attributes Select the funnel icon. Return to a larger world view Select another location on the map, or clear the filter labels above the map. Tip To return to the original map view of the world, select any area on an ocean. Examine heat map details one.newrelic.com > Browser > (select an app) > Browser app > Filterable Geography: Here is an example of the map as you use filter and zoom tools to drill down into detailed information about London, England. Athough overall throughput for the area is good (green), the nearby yellow areas, and the smaller red and orange circles indicate nearby cities with varying levels of throughput problems, not the size of those cities. The Filterable Geography heat map identifies performance quality with color and with the size of circles. Heat map Description Color scale Performance quality ranges from green (the best) to yellow, orange, and then red (the worst). When selecting indicators of usage rather than performance, the heat map shows shades of purple, with the darkest shades indicating the highest usage. The color scale adapts to your app's specific performance. Each area is a percentile range. To view the range for each color segment, mouse over the heat map's legend. Thresholds Different thresholds are dynamically applied to the colors based on the type of performance indicator you select from the dropdown and the maximum value your app has reported. For example, green for Average page load time may indicate 0 to 3.3 seconds, while green for Average network time may indicate 0 to 256 milliseconds. Circles The map's colored circles help you identify areas with performance problems at a glance. Each circle's radius is based on throughput reported for the city it represents, not the size of the city itself. You may see many circles overlapping each other. This usually indicates a grouping of metropolitan areas which represent a geographic area of heavy traffic. Filter performance metrics The Filter feature allows you to select and group data by attributes in various categories, including: Page view Geography Browser Identity Custom The filtered results appear on the geographical map, where you can use any of the standard map functions to explore additional details. Here are some examples. Unsatisfactory network performance by ASN In this example, your organization is preparing to renew a peering agreement with the owner of an autonomous system, called \"My-ASN.\" You are concerned that continued outages and other connection issues are affecting customer satisfaction with your site, and you want to compare its performance with other ASNs. You have a New Relic Browser Pro account. Go to one.newrelic.com > Browser > (select an app) > Filterable Geography. From the performance type dropdown, select Connection setup. Select the funnel icon. To view the specific ASN's performance: From the search window, type My-ASN, and then select this name from the Filter by results. OR To compare performance with other ASNs: From Geography attributes > ASN organizations, review the performance data for each organization on the list, and then select Back to groupings list. To close the filter list, select the funnel icon. Follow standard procedures to use the map functions and view comparative performance details. To clear the filter, select the attribute name. Page rendering performance during sales promotion In this example, your organization has a special three-day sales promotion for an upcoming holiday. Your holiday-merchandise page has undergone major changes, including dozens of new images. You want to look for performance problems with page rendering on Android mobile devices during this sales period. You have a New Relic Browser Pro account. Go to one.newrelic.com > Browser > (select an app) > Filterable Geography. Use the time picker to change the date range to the promotion period. From the performance type dropdown, select Page rendering. Select the funnel icon. From Page view attributes > Page Url, select your site's holiday-merchandise page, and then select Back to groupings list. From Browser attributes > User agent OS, select Android, and then select Back to groupings list. To close the filter list, select the funnel icon. Follow standard procedures to use the map functions and view comparative performance details. To clear the filters, select their attribute names. View comparative performance details Charts on the Page load performance and Historical performance tabs automatically refresh with comparative performance details for the selected location. one.newrelic.com > Browser > (select an app) > Browser app > Filterable Geography: Charts on the Page load performance and Historical performance tabs automatically refresh with details for the selected location. The Page load performance tab shows two charts. The Average page load time chart includes: Average page load time for each segment of the page load timing process in seconds Request queuing information (the time after a request enters your production systems and before it reaches your application) if applicable The Average network time chart shows key elements, including how long it takes for DNS lookup, connection establishment, and secure handshake, in seconds. Tip Sometimes areas on the charts may appear to be zero or near zero. This is because some apps use existing TCP connections, and they do not need to establish new connections. The Historical performance tab shows comparison data for the selected time period, yesterday, and last week for the selected location. This includes: Average response time Throughput in pages per minute (ppm) Available metrics You can filter and group geographical performance data in New Relic Browser and in New Relic Insights. Available metrics include: Performance Metrics Webpage Page load time Throughput (pages per minute or ppm) Network time Connection time Secure connection time Network Autonomous system number and name (ASN) via IP mapping SSL negotiation timing DNS timing Time to first byte ASN latitude and longitude for Internet service providers (ISPs) To ensure end user security, New Relic Browser collects GeoIP information for the end user's ISP. New Relic Browser does not collect GeoIP information for the specific end user. For example, if an end user in Portland, Oregon uses an ISP located in Beaverton, Oregon, New Relic Browser collects the GeoIP information for the ISP in Beaverton. User agents Operating systems Browser names or types Browser versions Device types Performance and usage ranges The color-coded legend shows performance and usage as percentile ranges. Performance color ranges Percentile colors for performance range from green (the best) to red (the worst). Performance percentile ranges (best to worst) Green Yellow Orange Red Back-end duration 0-74.9 75-86.9 87-94.9 95+ Connection setup duration 0-96.9 97-97.9 98-98.9 99+ DNS lookup duration 0-96.9 97-97.9 98-98.9 99+ DOM processing duration 0-74.9 75-86.9 87-94.9 95+ Network duration 0-74.9 75-86.9 87-94.9 95+ Page load duration 0-74.9 75-86.9 87-94.9 95+ Page rendering duration 0-74.9 75-86.9 87-94.9 95+ Queue duration 0-74.9 75-86.9 87-94.9 95+ Secure handshake duration 0-96.9 97-97.9 98-98.9 99+ Web app duration 0-74.9 75-86.9 87-94.9 95+ Usage color ranges Percentile colors for usage counts appear as shades of purple, from lightest (lowest usage) to darkest (highest usage). Usage percentile ranges (lowest to highest) Lightest purple Light purple Darker purple Darkest purple Page load count 0-79.9 80-89.9 90-99.9 100 Unique sessions count 0-79.9 80-89.9 90-99.9 100 For more help Additional documentation resources include: Browser Geography (legacy Geography page with Apdex scores and performance information by location) Page views (details about end users' overall experience with your site)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.88428,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Page rendering performance during sales <em>promotion</em>",
        "tags": "<em>Browser</em> <em>Pro</em> <em>features</em>",
        "body": " peering agreements and CDN usage. Contents Requirements Your New Relic <em>Browser</em> subscription level and your time picker settings determine what data you can view: <em>Pro</em> or higher: As of January 2016, the Filterable Geography feature automatically appears in your New Relic <em>Browser</em> user interface"
      },
      "id": "6043fe6f28ccbc910c2c606a"
    },
    {
      "sections": [
        "Browser error profiles: Find error causes",
        "View error profiles",
        "What are error profiles?",
        "Filter error profile data",
        "Example error profile explanation"
      ],
      "title": "Browser error profiles: Find error causes",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "57a8d5e43d7a661fa9062f4a8bba5eb9fb010c26",
      "image": "https://docs.newrelic.com/static/8cfa0de9d5cab457d02eded9473ee786/d7ab4/Browser-error-profile-example.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-error-profiles-find-error-causes/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-03-16T06:49:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "On Browser monitoring's JS errors UI page, error profiles give you insight about potential causes of your JavaScript errors. View error profiles To view Browser monitoring error profiles: Go to one.newrelic.com and click Browser > (select an app) > JS errors. To see error profile details: At the bottom of the JS errors UI page, select an error profile to expand it. What are error profiles? In Browser monitoring, an error profile is a potentially meaningful correlation New Relic has found between your JavaScript error attribute values when compared to normal PageView events. These correlations help you investigate the causes and contributing factors behind your errors. The screenshot below shows an example of an error profile. This error profile shows that the distribution of the userAgentOS attribute values varies significantly when JS error events are compared to normal (non-error) page view events. To investigate further, you could use the filter to display only Windows errors and see if there are other correlations. You can also filter the data used to generate error profiles to help you narrow down potential causes. For an analysis of a specific error profile, see the example error profile explanation. Filter error profile data To further filter the data used to generate error profiles and their comparison page views, use these JS errors page features: Time picker: select a time range used to generate the data. Filter: use the filter to display only error profiles and page views that have the attribute values you choose. You can select multiple attribute values. Example error profile explanation To help you better understand your own error profile data, this is an explanation of an example error profile's data. This error profile example has had a filter of userAgentName = Chrome applied, so it is only showing error data from Chrome browsers. This example profile has had a filter applied so that it is only showing error data from Chrome browsers. Column explanations: The first column is the attribute column. It shows the attribute values with the most deviation when compared to non-error page views. Less significant attribute values are aggregated in the Other category. In this example, the Chrome versions 36, 64, and 65 make up 100% of the errors for Chrome users. The JS errors column shows what percentage of JavaScriptError events have the attribute values from the first column. This column adds up to 100%, representing all errors from the chosen time range and filter set. In this example, a large percentage of Chrome errors are coming from Chrome version 36. If we wanted to investigate this further, we could filter to only show version 36 data. The Page views column shows what percentage of PageView events have the attribute values from the first column. In this example, less than 1% of Chrome users use Chrome version 36, but 55% of errors are generated by users with that version. The Difference column shows you the difference in percentage between the JS errors column and the Page views column. In this example, the 54% indicates that attribute is 54 percentage points higher for error events than for page views.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.55577,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> error <em>profiles</em>: Find error causes",
        "sections": "<em>Browser</em> error <em>profiles</em>: Find error causes",
        "tags": "<em>Browser</em> <em>Pro</em> <em>features</em>",
        "body": "On <em>Browser</em> <em>monitoring</em>&#x27;s JS errors UI page, error profiles give you insight about potential causes of your JavaScript errors. View error profiles To view <em>Browser</em> <em>monitoring</em> error profiles: Go to one.newrelic.com and click <em>Browser</em> &gt; (select an app) &gt; JS errors. To see error profile details"
      },
      "id": "603e884ce7b9d22e2e2a0815"
    }
  ],
  "/docs/browser/browser-monitoring/browser-pro-features/upload-source-maps-un-minify-js-errors": [
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 337.37128,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>Pro</em> <em>features</em>",
        "body": " support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for <em>Browser</em> <em>monitoring</em>: Make sure you meet requirements, including having: Full-Stack Observability <em>Browser</em> <em>Pro</em>"
      },
      "id": "6043fe6f196a6784f0960f53"
    },
    {
      "sections": [
        "Filterable Geography: Webpage metrics by location",
        "Contents",
        "Requirements",
        "Factors affecting collected data",
        "View performance data by location",
        "Use map functions",
        "Tip",
        "Examine heat map details",
        "Filter performance metrics",
        "Unsatisfactory network performance by ASN",
        "Page rendering performance during sales promotion",
        "View comparative performance details",
        "Available metrics",
        "Performance and usage ranges",
        "Performance color ranges",
        "Usage color ranges",
        "For more help"
      ],
      "title": "Filterable Geography: Webpage metrics by location",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "6d8527b8a2ead507b7cfa95a87a7c75c567c1ee6",
      "image": "https://docs.newrelic.com/static/01bcd89f3ae221d22e388d936cede641/8c557/screen-browser-filter-geography.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/filterable-geography-webpage-metrics-location/",
      "published_at": "2021-07-02T00:24:05Z",
      "updated_at": "2021-05-16T09:50:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Browser's Filterable Geography page provides a world view with color-coded performance information about cities, regions, and countries anywhere around the world. You can filter and drill down into detailed information, or use your mouse to select or zoom in and out of any location on the map. The enhanced attributes provide deep visibility not only about your end users' experience with page load timing, but also with network performance anywhere around the world. This level of visual detail is especially useful for professionals in IT and Operations to make business decisions about peering agreements and CDN usage. Contents Requirements Your New Relic Browser subscription level and your time picker settings determine what data you can view: Pro or higher: As of January 2016, the Filterable Geography feature automatically appears in your New Relic Browser user interface. No special setup is required. You can view up to eight days of data. Your application must be enabled to send PageView data to New Relic Insights in order to use Filterable Geography. Lite: The Filterable Geography feature appears in your New Relic Browser's UI menu but currently is not available for use. Any subscription level: If you need to use New Relic Browser's legacy Geography feature, you can still view it from your selected browser app. Factors affecting collected data To capture page load timing information, New Relic Browser uses the Navigation Timing API, which most (but not all) browsers support. If the browsers do not support the Navigation Timing API, then New Relic Browser charts and data points can only show the network data they receive for DNS lookup, connection, secure handshake, etc. This may not be 100% of the app's overall traffic. Also, firewalls may have an impact on the geographical data collected about your end users. View performance data by location one.newrelic.com > Browser > (select an app) > Browser app > Filterable Geography: Here is an example of the map before drilling down into detailed information about London, England. To view or sort the performance information by location: Go to one.newrelic.com > Browser > (select an app) > Filterable Geography. Select the type of performance data to view from the dropdown, or use the default Average page load time. To drill down to a specific area, mouse over or select any area on the geographical map, or select any of the ten worst performing locations from the list to the right of the map. To view specific performance metrics, select any of the attributes below the funnel icon. To view comparison data, select the Page load performance or Historical performance chart below the selected location's geographical map. Use map functions Use any of New Relic's standard user interface functions and page functions to drill down into detailed information. Here is a summary of additional options with the Filterable Geography page. If you want to... Do this... Change what kind of performance data appears Select your choice from the dropdown. Default performance indicator is Average page load time. The map's legend lists the ten best or worst performing areas (depending on the selected performance indicator) for the selected time period. For example: If you select Count, the map's legend shows the top ten locations with the highest number of page loads, as well as the average page load time for each. If you select Connection setup, New Relic Browser first filters out areas with low throughput. Then the map's legend shows the top ten locations where average connection time is the slowest, as well as the average page load time and count for each. View summary performance information about a specific location Mouse over any colored area on the map, select a location from the list, or zoom in and out of any area on the map. View detailed data for a location Select any area of the map. For example: If you select Canada, the map and legend show color-coded performance data for each province and territory. The list to the right of the map shows the top ten worst performing areas. If you select a specific province or territory, the map shows color-coded performance data for the top ten cities. The map includes circled locations which you can mouse over or select to view detailed information. In addition, the Page load performance and Historical performance charts below the map automatically update with each location you select. Hide the list of available attributes Select the funnel icon. Return to a larger world view Select another location on the map, or clear the filter labels above the map. Tip To return to the original map view of the world, select any area on an ocean. Examine heat map details one.newrelic.com > Browser > (select an app) > Browser app > Filterable Geography: Here is an example of the map as you use filter and zoom tools to drill down into detailed information about London, England. Athough overall throughput for the area is good (green), the nearby yellow areas, and the smaller red and orange circles indicate nearby cities with varying levels of throughput problems, not the size of those cities. The Filterable Geography heat map identifies performance quality with color and with the size of circles. Heat map Description Color scale Performance quality ranges from green (the best) to yellow, orange, and then red (the worst). When selecting indicators of usage rather than performance, the heat map shows shades of purple, with the darkest shades indicating the highest usage. The color scale adapts to your app's specific performance. Each area is a percentile range. To view the range for each color segment, mouse over the heat map's legend. Thresholds Different thresholds are dynamically applied to the colors based on the type of performance indicator you select from the dropdown and the maximum value your app has reported. For example, green for Average page load time may indicate 0 to 3.3 seconds, while green for Average network time may indicate 0 to 256 milliseconds. Circles The map's colored circles help you identify areas with performance problems at a glance. Each circle's radius is based on throughput reported for the city it represents, not the size of the city itself. You may see many circles overlapping each other. This usually indicates a grouping of metropolitan areas which represent a geographic area of heavy traffic. Filter performance metrics The Filter feature allows you to select and group data by attributes in various categories, including: Page view Geography Browser Identity Custom The filtered results appear on the geographical map, where you can use any of the standard map functions to explore additional details. Here are some examples. Unsatisfactory network performance by ASN In this example, your organization is preparing to renew a peering agreement with the owner of an autonomous system, called \"My-ASN.\" You are concerned that continued outages and other connection issues are affecting customer satisfaction with your site, and you want to compare its performance with other ASNs. You have a New Relic Browser Pro account. Go to one.newrelic.com > Browser > (select an app) > Filterable Geography. From the performance type dropdown, select Connection setup. Select the funnel icon. To view the specific ASN's performance: From the search window, type My-ASN, and then select this name from the Filter by results. OR To compare performance with other ASNs: From Geography attributes > ASN organizations, review the performance data for each organization on the list, and then select Back to groupings list. To close the filter list, select the funnel icon. Follow standard procedures to use the map functions and view comparative performance details. To clear the filter, select the attribute name. Page rendering performance during sales promotion In this example, your organization has a special three-day sales promotion for an upcoming holiday. Your holiday-merchandise page has undergone major changes, including dozens of new images. You want to look for performance problems with page rendering on Android mobile devices during this sales period. You have a New Relic Browser Pro account. Go to one.newrelic.com > Browser > (select an app) > Filterable Geography. Use the time picker to change the date range to the promotion period. From the performance type dropdown, select Page rendering. Select the funnel icon. From Page view attributes > Page Url, select your site's holiday-merchandise page, and then select Back to groupings list. From Browser attributes > User agent OS, select Android, and then select Back to groupings list. To close the filter list, select the funnel icon. Follow standard procedures to use the map functions and view comparative performance details. To clear the filters, select their attribute names. View comparative performance details Charts on the Page load performance and Historical performance tabs automatically refresh with comparative performance details for the selected location. one.newrelic.com > Browser > (select an app) > Browser app > Filterable Geography: Charts on the Page load performance and Historical performance tabs automatically refresh with details for the selected location. The Page load performance tab shows two charts. The Average page load time chart includes: Average page load time for each segment of the page load timing process in seconds Request queuing information (the time after a request enters your production systems and before it reaches your application) if applicable The Average network time chart shows key elements, including how long it takes for DNS lookup, connection establishment, and secure handshake, in seconds. Tip Sometimes areas on the charts may appear to be zero or near zero. This is because some apps use existing TCP connections, and they do not need to establish new connections. The Historical performance tab shows comparison data for the selected time period, yesterday, and last week for the selected location. This includes: Average response time Throughput in pages per minute (ppm) Available metrics You can filter and group geographical performance data in New Relic Browser and in New Relic Insights. Available metrics include: Performance Metrics Webpage Page load time Throughput (pages per minute or ppm) Network time Connection time Secure connection time Network Autonomous system number and name (ASN) via IP mapping SSL negotiation timing DNS timing Time to first byte ASN latitude and longitude for Internet service providers (ISPs) To ensure end user security, New Relic Browser collects GeoIP information for the end user's ISP. New Relic Browser does not collect GeoIP information for the specific end user. For example, if an end user in Portland, Oregon uses an ISP located in Beaverton, Oregon, New Relic Browser collects the GeoIP information for the ISP in Beaverton. User agents Operating systems Browser names or types Browser versions Device types Performance and usage ranges The color-coded legend shows performance and usage as percentile ranges. Performance color ranges Percentile colors for performance range from green (the best) to red (the worst). Performance percentile ranges (best to worst) Green Yellow Orange Red Back-end duration 0-74.9 75-86.9 87-94.9 95+ Connection setup duration 0-96.9 97-97.9 98-98.9 99+ DNS lookup duration 0-96.9 97-97.9 98-98.9 99+ DOM processing duration 0-74.9 75-86.9 87-94.9 95+ Network duration 0-74.9 75-86.9 87-94.9 95+ Page load duration 0-74.9 75-86.9 87-94.9 95+ Page rendering duration 0-74.9 75-86.9 87-94.9 95+ Queue duration 0-74.9 75-86.9 87-94.9 95+ Secure handshake duration 0-96.9 97-97.9 98-98.9 99+ Web app duration 0-74.9 75-86.9 87-94.9 95+ Usage color ranges Percentile colors for usage counts appear as shades of purple, from lightest (lowest usage) to darkest (highest usage). Usage percentile ranges (lowest to highest) Lightest purple Light purple Darker purple Darkest purple Page load count 0-79.9 80-89.9 90-99.9 100 Unique sessions count 0-79.9 80-89.9 90-99.9 100 For more help Additional documentation resources include: Browser Geography (legacy Geography page with Apdex scores and performance information by location) Page views (details about end users' overall experience with your site)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.88428,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Page rendering performance during sales <em>promotion</em>",
        "tags": "<em>Browser</em> <em>Pro</em> <em>features</em>",
        "body": " peering agreements and CDN usage. Contents Requirements Your New Relic <em>Browser</em> subscription level and your time picker settings determine what data you can view: <em>Pro</em> or higher: As of January 2016, the Filterable Geography feature automatically appears in your New Relic <em>Browser</em> user interface"
      },
      "id": "6043fe6f28ccbc910c2c606a"
    },
    {
      "sections": [
        "Session traces: Explore a webpage's life cycle",
        "Identify problems and solutions",
        "Requirements",
        "Select a session trace",
        "Tip",
        "View session trace details",
        "Session segment definitions",
        "Slow JavaScript execution and repainting"
      ],
      "title": "Session traces: Explore a webpage's life cycle",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "2d34d77c7661be3ebd3f04a8188fe36d7233895f",
      "image": "https://docs.newrelic.com/static/a7f12a1603efe1412d15b9a51a312548/c1b63/browser_sessiontraces_overview.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/browser-pro-features/session-traces-explore-webpages-life-cycle/",
      "published_at": "2021-07-02T09:13:21Z",
      "updated_at": "2021-03-16T08:23:46Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's session traces provide a detailed timeline of the load and interaction events during a webpage's full life cycle, for as long as ten minutes. Page load timing, individual asset loads, user interactions, AJAX requests, callbacks, errors, and other events appear in an interactive timeline which includes a detailed waterfall visualization, a heat map overview, and highlighted metrics and problems related to that session. Identify problems and solutions Session traces help you understand: How users experience your page load, including time to DOM load, time waiting for AJAX requests to complete, and the user's interactions with the page How the New Relic metrics reflect your end users' experiences What is the sequence of JavaScript and browser events, which take longer than others, and when each event occurs Where bottlenecks occur, and what may be causing them Why one page load may be slower than others, by providing the context for individual events during a session By connecting performance to user experience and interactions to performance, this detailed and intuitive visualization of all events in the user's session can help pinpoint problem areas and easily identify solutions. Requirements To use Browser monitoring's session traces feature, make sure you meet these requirements: Your agent version must support Browser monitoring. If you're using multiple names for an app, session traces will only report to the most specific application. For accounts older than October 2014, you must enable Browser monitoring and the enhanced Pro features. Browser randomly captures traces only from browsers that support the Resource Timing API. Select a session trace The Session traces index lists the most recent traces based on the time picker selection for the selected app. Session traces are randomly sampled and stored at a rate of 90/hour. You can page through up to 500 traces at a time. Additionally, you can sort and search the list by attributes, including: Full URL, with query string parameters removed Browser type Started at date/time Page load time one.newrelic.com > Browser > (select an app) > Session traces: You can select a session trace from the Browser index. You can also select a session trace directly from the Browser Summary, Page views, JS errors, and AJAX pages. To select a specific session trace: Go to one.newrelic.com and click Browser > (select an app) > Session traces. To locate a session trace from a different date or time period, use the time picker. To limit the index to a specific type of trace, use the search window. To view detailed information, select the session trace's link. Tip You can also select a session trace directly from the Browser Summary, Page views, JS errors and AJAX pages. View session trace details The Session trace details page provides summary information about the trace, a heat map with timing details, and a waterfall of events that you can explore. The color-coded legend identifies the page load events during the webpage's life cycle. For apps that have been deployed using the copy/paste method, Browser monitoring includes web app and queue time in Network time as part of the page load timing process. This is because Browser relies on the server-side agent to pass the application values to the Browser agent through auto-injection. You can view detailed information about how this \"back end\" time breaks down from the browser's point of view. The session traces report on all the network related events available, so you can see on a case-by-case basis how the browser spends time on DNS lookups and other network events. one.newrelic.com > Browser > (select an app) > Session traces > (select a trace): Use Browser's session trace details to examine events and identify problems during the end user's webpage session. To navigate through a session trace, explore the waterfall chart by scrolling vertically through the event stack, or select individual events to view their details. If you want to... Do this... View the web page for this session trace Select the trace link. Jump to a specific time Select the time indicator or event on the heat map. View details about individual events Select any event in the waterfall chart. From there, select View full details if applicable. Change the location on the session trace Click on the heat map, or scroll vertically through the waterfall chart. Zoom in or out of the overall trace Select the plus or minus icons below the heat map. Share the session trace information Create a permalink to paste into a form, ticket, email, etc. Session segment definitions Important session trace measurements are displayed in the upper right corner of the Session traces page. The first four measurements represent how long into a session that the segment ended. For example, if Page Load is 0.202s, that means that the page load event completed 0.202 seconds after the request began. Session segment Description Backend The time from when the request began to when backend activity finished and DOM loading began. DOM processing The time from when the request began to when DOM processing finished. Page load The time from when the request began to when the page load event fired. Waiting on AJAX The time from when the request began to when AJAX activity ended. First interaction The time from when the request began to when the first user activity, like a mouse click or a scroll, was recorded. Duration The total duration of the session. Slow JavaScript execution and repainting Session traces help you identify callbacks in your JavaScript code that execute slowly and block the execution of subsequent calls on the browser's main thread. These calls should execute quickly in order to allow the browser to quickly repaint the page in response to user actions. Session traces highlight any callbacks longer than 33ms. If called in rapid succession (such as inside a requestAnimationFrame loop), callbacks longer than 33ms reduce the frame rate below 30 frames per second. This speed seems sluggish to users.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.56418,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Identify <em>problems</em> and solutions",
        "tags": "<em>Browser</em> <em>Pro</em> <em>features</em>",
        "body": " older than October 2014, you must enable <em>Browser</em> <em>monitoring</em> and the enhanced <em>Pro</em> <em>features</em>. <em>Browser</em> randomly captures traces only from browsers that support the Resource Timing API. Select a session trace The Session traces index lists the most recent traces based on the time picker selection"
      },
      "id": "603ecc4de7b9d2843d2a0806"
    }
  ],
  "/docs/browser/browser-monitoring/configuration/browser-license-key-app-id": [
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 177.85144,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "If you use <em>Browser</em> to <em>monitor</em> end-user <em>browser</em> activity, you can now see end-user-originating <em>browser</em>-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data"
      },
      "id": "6043fe6f196a6784f0960f53"
    },
    {
      "sections": [
        "Collect custom attributes",
        "Requirements",
        "APM: Record custom attributes",
        "Important",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "Browser monitoring: Record custom attributes",
        "Infrastructure monitoring: Record custom attributes",
        "Mobile monitoring: Record custom attributes",
        "For more help"
      ],
      "title": "Collect custom attributes",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Install and configure"
      ],
      "external_id": "ad362b1a5cf3a5661eb416584fd9c79db064f539",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/data/customize-data/collect-custom-attributes/",
      "published_at": "2021-07-02T19:49:53Z",
      "updated_at": "2021-07-02T19:49:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some New Relic solutions, one way to report custom data to New Relic is to use custom attributes. For example, for New Relic browser monitoring, you might create a custom attribute to track the user name associated with a slow or failing request. Requirements Custom attributes are available for these New Relic solutions: APM Browser monitoring Mobile monitoring Infrastructure monitoring For other custom data solutions, see Intro to custom data. APM: Record custom attributes Important Review the list of reserved terms used by NRQL. Using reserved terms can cause issues. To enable and use custom attributes for APM, follow the procedure for your APM agent: C SDK To add custom attributes to applications monitored by the C SDK, call one of the attribute functions; for example, newrelic_add_attribute_double(). The key name for your custom attribute depends on what you specify when you call the function. Go Custom attribute collection is enabled by default in the Go agent. However, you can disable custom attribute collection. Java Custom attribute collection is enabled by default in Java. You can collect custom attributes using XML and the Java agent APIs. These two methods can be used in conjunction with each other. Method How to do it Specify attributes in XML XML allows you to specify custom attributes without changing any of your source code. You can have multiple XML files for custom attributes that are grouped by some logical facet. To set custom attributes for your Java app via XML: Review the New Relic Java agent's documentation about XML file format, methods and classes, and examples. From your Extensions directory within the New Relic Java agent, create a single XML file. Define the methods you want New Relic to monitor by editing your XML file directly. Define an XML instrumentation file using the New Relic UI. This may require additional config in the common: block of your newrelic.yml. See Report custom attributes under Instrumentation options for more detail. Call the agent's API Example 1: Adding custom attributes to transactions To collect custom attributes using the agent's API, call the relevant methods: For each method you want to record an attribute for, call NewRelic.addCustomParameter(...). Optional: Include or exclude certain attributes with attributes.include and attributes.exclude. For example, to record a variable named userId, include this code in the parent method: NewRelic.addCustomParameter(\"userId\", userId); Copy Example 2: Adding custom attributes to spans in distributed traces To collect custom attributes using the agent's API, call the relevant methods: For each span (currently executing method) that you want to record an attribute for, call NewRelic.getAgent().getTracedMethod().addCustomAttribute(...). Optional: Include or exclude certain attributes with span_events.attributes.include and span_events.attributes.exclude. For example, to record a variable named userId on the current span, include this code in the associated method: NewRelic.getAgent().getTracedMethod().addCustomAttribute(\"userId\", userId); Copy Collect user attributes The Java agent also includes a built-in mechanism to enable user attributes and collect user information from HttpServletRequest.getUserPrincipal() as custom attributes. .NET Custom attribute collection is enabled by default in .NET. To collect custom attributes, call the relevant API methods: For each method for which you want to record an attribute, call AddCustomAttribute. Optional: Include or exclude attributes with the include and exclude configuration options. For example, to record attributes for a coupon code (string) and an item ID code (number), you could include this code in the parent method: IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction .AddCustomAttribute(\"Discount Code\", \"Summer Super Sale\") .AddCustomAttribute(\"Item Code\", 31456); Copy Node.js Custom attribute collection is enabled by default in Node.js. To collect custom attributes, call the relevant API method: For each attribute you want to record, call newrelic.addCustomAttribute. To record multiple attributes using a single call, use newrelic.addCustomAttributes. For example, to record attributes for a coupon code and an item ID code, you could include this in the parent method: newrelic.addCustomAttributes({ \"Discount Code\": \"Summer Super Sale\", \"Item Code\": 31456 }); Copy PHP Custom attribute collection is enabled by default in PHP. To collect custom attributes, call the relevant API method for each method that you want to record an attribute; newrelic_add_custom_parameter for transaction events and spans newrelic_add_custom_span_parameter for only spans For example, to record a variable named $userId, include this code in the parent method: newrelic_add_custom_parameter ('userID', $userId) Copy Python Custom attribute collection is enabled by default in Python. To collect custom attributes, call add_custom_parameter for each method that you want to record an attribute. For example, to record a variable named user_id, include this code in the parent method: newrelic.agent.add_custom_parameter('user_id', user_id) Copy Ruby Custom attribute collection is enabled by default in Ruby. To collect custom attributes, call the relevant API methods: For Ruby agent version 3.12.0 or higher, use the add_custom_attributes method. For example, to record a variable named @user_id, include this code in the parent method: ::NewRelic::Agent.add_custom_attributes({ user_id: @user.id }) Copy For Ruby agent version 3.11.2 or lower, use the add_custom_parameters method. For example, to record a variable named @user_id, include this code in the parent method: ::NewRelic::Agent.add_custom_parameters({ user_id: @user.id }) Copy Browser monitoring: Record custom attributes The browser agent provides an API to specify extra details associated with a page view or browser interaction, either by forwarding attributes from APM to browser monitoring or by specifying custom attributes through JavaScript. Values forwarded from the APM agent are encoded and injected into browser attributes by our browser agent. Infrastructure monitoring: Record custom attributes Our Infrastructure monitoring lets you create custom attributes that are used to annotate the data from the infrastructure agent. You can use this metadata to build filter sets, group your results, and annotate your data. Mobile monitoring: Record custom attributes Mobile agents include API calls to record custom attributes: For an overview of mobile monitoring custom data, see Insert custom events and attributes Android method: setAttribute iOS method: setAttribute For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.55481,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Browser</em> <em>monitoring</em>: Record custom attributes",
        "tags": "Install and <em>configure</em>",
        "body": "For some New Relic solutions, one way to report custom data to New Relic is to use custom attributes. For example, for New Relic <em>browser</em> <em>monitoring</em>, you might create a custom attribute to track the user name associated with a slow or failing request. Requirements Custom attributes are available"
      },
      "id": "603eb9a3196a67a990a83da5"
    },
    {
      "sections": [
        "Install the browser monitoring agent",
        "Tip",
        "Select a deployment option",
        "Important",
        "Enable an APM-monitored app",
        "Enable with copy/paste",
        "Instrument webpages using the APM agent",
        "Troubleshoot Browser agent installation"
      ],
      "title": "Install the browser monitoring agent",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Installation"
      ],
      "external_id": "bc45bbc86cd4d8b81367ad0904907ddc735717f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/installation/install-browser-monitoring-agent/",
      "published_at": "2021-07-02T09:15:35Z",
      "updated_at": "2021-06-14T21:26:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser uses a JavaScript snippet (or \"agent\") to instrument your app's webpages. The JavaScript collects data for browser monitoring. To install the browser agent, you can choose from a number of deployment options. Tip To use Browser and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Select a deployment option No matter which option you use to deploy browser monitoring, the end result is to inject the browser agent's JavaScript snippet into your pages for browser monitoring. The method you select depends on your preferences and business needs. To view the procedure to install and enable the browser agent, click the link for the option you want to use. You can also use the Browser Application settings page to update settings. Important The following configuration options refer only to the browser monitoring agent. These are not the same as the New Relic user roles and editions. Browser deployment option Description Use the APM agent to inject the JavaScript You can use an APM agent to automatically inject the browser monitoring JavaScript snippet for you. This is the easiest way to install the agent for an app that already is being monitored by APM. (APM-monitored apps are listed on your APM Applications index.) Paste the JavaScript snippet into a webpage This allows you to control the exact placement of the JavaScript into your app's webpage(s) by copying and pasting the browser agent's JavaScript snippet. This is useful for: Standalone apps, static sites, and cached pages delivered by CDN APM apps that are not as closely coupled to the browser app as with a standard server-side app (for example, when your client-side app talks to a REST API back end) Enable single-page app (SPA) monitoring Enabling SPA requires a Pro + SPA browser agent subscription, and you may need to re-deploy the browser JavaScript agent. Use the REST API The REST API lets you manage deployment outside the browser UI. This is useful for large organizations deploying multiple apps. Use an APM agent API to manually instrument the JavaScript snippet For apps that are monitored by APM, you can use the APM agent's API to inject the JavaScript manually instead of automatically. Enable an APM-monitored app Use this procedure to automatically deploy the browser agent on an app that is monitored by APM: Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Enable via New Relic APM. In the Choose your instrumentation section, select Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Select your application section, type or use the search window to find an app's name. Click Enable. Important Node.js: To finish enabling the browser agent for a Node.js app, follow the additional procedure to insert the JavaScript header into the beginning of your HTML page's head tag. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. Enable with copy/paste Use this procedure to insert browser's JavaScript snippet for browser monitoring into your app's webpages yourself. This option is useful for monitoring static sites (such as Jekyll) or cached pages delivered by CDN. Tip Near the bottom of the generated JavaScript is your browser license key and application ID. This is useful with the REST API and API Explorer. Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Copy/Paste JavaScript Code. In the Choose your instrumentation section, select the type of agent: Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Name your app section, name your app: If your app is monitored by APM, select Yes, then type or use the search window to find the app's name. If you have a standalone app for Browser (not monitored by APM), select No, then type the app's name. Click Enable. A new section, Instrument the agent, opens on the page with JavaScript code for your project. Copy the code snippet, then paste it inline into your pages as close to the top of the <head> element as possible, but after any position-sensitive <meta> tags (for example, X-UA-Compatible or charset information). For more information on the inline head placement, see JavaScript placement requirements. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. If you use the copy/paste method, but don't finish the setup process, you can still view and copy the generated JavaScript snippet from your app's Browser Application settings page or by using the REST API (v2). Instrument webpages using the APM agent This information applies to apps that are also monitored by APM. New Relic's agents can instrument webpages with the required JavaScript for page load timing. If you use the APM agent to add the JavaScript snippet to your webpages, insert the instrumentation snippet as close to the top as possible. This allows you to take advantage of detailed information about browser's AJAX calls and JavaScript errors. For more information, see the instructions for your APM agent: C SDK Go Java .NET Node.js PHP Python Ruby Troubleshoot Browser agent installation When you enable browser Pro features for session traces, AJAX calls, or JavaScript errors, it may take approximately five minutes before information becomes available. If you have problems with your browser installation or if no data appears after five minutes, refer to the troubleshooting tips, and restart your agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.36908,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install the <em>browser</em> <em>monitoring</em> agent",
        "sections": "Install the <em>browser</em> <em>monitoring</em> agent",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " The following <em>configuration</em> options refer only to the <em>browser</em> <em>monitoring</em> agent. These are not the same as the New Relic user roles and editions. <em>Browser</em> deployment option Description Use the APM agent to inject the JavaScript You can use an APM agent to automatically inject the <em>browser</em> <em>monitoring</em> JavaScript"
      },
      "id": "604429e628ccbcb80b2c60d0"
    }
  ],
  "/docs/browser/browser-monitoring/getting-started/browser-summary-page": [
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.32077,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "If you use <em>Browser</em> to <em>monitor</em> end-user <em>browser</em> activity, you can now see end-user-originating <em>browser</em>-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data"
      },
      "id": "6043fe6f196a6784f0960f53"
    },
    {
      "sections": [
        "Get data into New Relic",
        "New Relic-built agents and integrations",
        "Report custom data"
      ],
      "title": "Get data into New Relic",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Get started"
      ],
      "external_id": "1b20f81fa22784c5d22e4e51eb7c0bf26cbdb0b6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/get-started/introduction-new-relic-data-ingest-apis-sdks/",
      "published_at": "2021-07-01T17:17:17Z",
      "updated_at": "2021-07-01T17:17:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are many ways to get data into your New Relic account. Any New Relic user can use any of our data ingest methods to report data to our Telemetry Data Platform. New Relic-built agents and integrations When you enable New Relic solutions like APM, browser monitoring, mobile monitoring, infrastructure monitoring, or any of our wide array of integrations, by default you'll receive data from your monitored applications, hosts, services, or other entities. Some options for getting started: Log into one.newrelic.com and click Add more data to get some guidance on setting up New Relic solutions. To browse our solutions, see New Relic integrations. Report custom data If you need to report data that our agents and integrations don't provide, we have tools that will allow you to bring in any type of data you need. To learn more, see Intro to custom data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 148.90091,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Get</em> data into New Relic",
        "sections": "<em>Get</em> data into New Relic",
        "tags": "<em>Get</em> <em>started</em>",
        "body": ", infrastructure <em>monitoring</em>, or any of our wide array of integrations, by default you&#x27;ll receive data from your monitored applications, hosts, services, or other entities. Some options for <em>getting</em> <em>started</em>: Log into one.newrelic.com and click Add more data to <em>get</em> some guidance on setting up New Relic solutions"
      },
      "id": "603eae7b196a671ea3a83dc7"
    },
    {
      "sections": [
        "Compatibility and requirements for Browser Monitoring",
        "Basic requirements",
        "Important",
        "Browser types",
        "APM agents",
        "Supported frameworks",
        "Content Security Policy (CSP) considerations"
      ],
      "title": "Compatibility and requirements for Browser Monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "538a44c0c5def08c38b57c43fff73aa1002e2a5f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/getting-started/compatibility-requirements-browser-monitoring/",
      "published_at": "2021-07-02T00:27:15Z",
      "updated_at": "2021-05-21T20:47:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring includes strict security measures to provide a robust, standalone product with browser monitoring features. Before you install the Browser agent, make sure your system meets these requirements. Basic requirements To report data to Browser, your application must at a minimum meet two basic requirements: The traffic to the application must be from clients able to load and execute Browser JavaScript code and set cookies. Clients accessing the application must be able to send data to New Relic through HTTP requests. HTTPS is required for Browser Pro features. Important Browsers that subscribe to a disconnect list or that use content filtering extensions such as AdBlock may not be able to send data to New Relic. For example, if you are using the Enhanced Tracking Prevention disconnect list for Mozilla Firefox 69.0 or higher, you will need to change the default configuration. Most typical browser applications meet these requirements. However, browser applications in restricted environments may have difficulty reporting data to New Relic; for example: Hybrid mobile applications Applications installed on unusual hardware, such as point-of-sale terminals or consumer appliances For more information, review the instrumentation for browser monitoring documentation, and verify end-user network access. Browser types Instrumentation is compatible with every browser type, including Google Chrome, Mozilla Firefox, Microsoft Internet Explorer and Edge, and Apple Safari. The user interface is compatible with New Relic's supported browser versions. Exceptions Comments Paint timings The firstPaint and firstContentfulPaint attributes in BrowserInteraction, PageView, and PageViewTiming events are only compatible with: Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile AJAX AJAX timing features are not available with: Chrome for iPhone and iPad IE 7 and 8 PageAction events PageAction events require a browser that fully supports cross-domain XMLHttpRequests. Internet Explorer versions 9 and lower cannot record PageAction events. Learn more on querying your data. Session traces Session traces are reported only from browsers that support the Resource Timing Specification. SHA-256 New Relic can only monitor browsers that are compatible with SHA-256. APM agents You can deploy the Browser agent for apps monitored by APM, or you can deploy the Browser agent for your standalone apps. For more information, see the installation procedures. If you are deploying Browser for an app using APM, make sure your agent supports Browser monitoring: C SDK: Version 1.0.0 or higher Go: Version 2.5.0 or higher Java: Version 3.4.0 or higher .NET: Version 2.20.25.0 or higher Node.js: Version 1.4.0 or higher PHP: Version 4.4.5.35 or higher Python: Version 2.10.1.9 or higher Ruby: Version 3.7.0.177 or higher Supported frameworks The Browser agent collects data on all front-end frameworks. However, the monitoring occurs on lower-level \"primitives\" that JavaScript frameworks use, so the level of detail collected by the instrumentation may vary depending on your specific framework. Exceptions Comments Zone.js If you're using AngularJS and you want to use Browser's SPA monitoring capabilities, note that Zone.js versions 0.6.18 to 0.6.24 are not compatible with Browser. In all cases, the Browser agent must be loaded before Zone.js to avoid errors. Cypress.io Browser is unable to properly instrument the open and send methods of requests when tests are run in Cypress. This will cause the following error to be thrown: Cannot set property 'status' of undefined Copy This will only affect customers running tests with the Browser agent present in their code. Production applications should not be affected. html2pdf.js This library is not compatible with our SPA-enabled Browser agent due to the way this library wraps promises. If you're using this library, we recommend the Browser Pro agent. Content Security Policy (CSP) considerations In order to obtain accurate browser performance metrics, Browser requires the use of a small, inline JavaScript snippet. New Relic carefully reviews the inline JavaScript to prevent Cross-Site Scripting (XSS) and other potential vulnerabilities. Content Security Policy Level 2 adds restrictions to the types of JavaScript allowed, such as inline scripts. It also limits which domains can load scripts during page load. Important If your website does not allow any third-party hosted JavaScript to run, you must request a CSP exception via your organizationâ€™s standard procedures in order to install the Browser monitoring agent. When requesting a CSP exception, follow your organization's standard procedures to contact your web or security team. The Browser JavaScript agent requires the following CSP exceptions in order to run properly. Alternatively, you can add all of these exceptions to the fallback default-src directive (instead of script-src and connect-src). CSP exception Comments unsafe-inline Add to the script-src directive or to the fallback default-src directive. This is required because the agent is installed by including an inline script. https://js-agent.newrelic.com Add to the script-src directive or to the fallback default-src directive. This is where additional script files that the agent requires are hosted. https://bam.nr-data.net https://bam-cell.nr-data.net Important Add https://gov-bam.nr-data.net if you're using FedRAMP-compliant endpoints. Add to the script-src directive or to the fallback default-src directive. This is where the agent sends its collected data. One of the calls to this URL is a JSONP call, which means that the URL must be allowed as a script source. Add to the connect-src directive or to the fallback default-src directive. The connect-src directive affects the URLs that scripts can call (for example, using the XMLHttpRequest interface). If you have CSP restrictions specifically around this directive, then add this URL as an exception.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.53795,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for <em>Browser</em> <em>Monitoring</em>",
        "sections": "Compatibility and requirements for <em>Browser</em> <em>Monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em> includes strict security measures to provide a robust, standalone product with <em>browser</em> <em>monitoring</em> features. Before you install the <em>Browser</em> agent, make sure your system meets these requirements. Basic requirements To report data to <em>Browser</em>, your application must at a minimum meet"
      },
      "id": "603ed6b664441f4a784e883f"
    }
  ],
  "/docs/browser/browser-monitoring/getting-started/introduction-browser-monitoring": [
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.32077,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "If you use <em>Browser</em> to <em>monitor</em> end-user <em>browser</em> activity, you can now see end-user-originating <em>browser</em>-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data"
      },
      "id": "6043fe6f196a6784f0960f53"
    },
    {
      "sections": [
        "Get data into New Relic",
        "New Relic-built agents and integrations",
        "Report custom data"
      ],
      "title": "Get data into New Relic",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Get started"
      ],
      "external_id": "1b20f81fa22784c5d22e4e51eb7c0bf26cbdb0b6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/get-started/introduction-new-relic-data-ingest-apis-sdks/",
      "published_at": "2021-07-01T17:17:17Z",
      "updated_at": "2021-07-01T17:17:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are many ways to get data into your New Relic account. Any New Relic user can use any of our data ingest methods to report data to our Telemetry Data Platform. New Relic-built agents and integrations When you enable New Relic solutions like APM, browser monitoring, mobile monitoring, infrastructure monitoring, or any of our wide array of integrations, by default you'll receive data from your monitored applications, hosts, services, or other entities. Some options for getting started: Log into one.newrelic.com and click Add more data to get some guidance on setting up New Relic solutions. To browse our solutions, see New Relic integrations. Report custom data If you need to report data that our agents and integrations don't provide, we have tools that will allow you to bring in any type of data you need. To learn more, see Intro to custom data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 148.90091,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Get</em> data into New Relic",
        "sections": "<em>Get</em> data into New Relic",
        "tags": "<em>Get</em> <em>started</em>",
        "body": ", infrastructure <em>monitoring</em>, or any of our wide array of integrations, by default you&#x27;ll receive data from your monitored applications, hosts, services, or other entities. Some options for <em>getting</em> <em>started</em>: Log into one.newrelic.com and click Add more data to <em>get</em> some guidance on setting up New Relic solutions"
      },
      "id": "603eae7b196a671ea3a83dc7"
    },
    {
      "sections": [
        "Compatibility and requirements for Browser Monitoring",
        "Basic requirements",
        "Important",
        "Browser types",
        "APM agents",
        "Supported frameworks",
        "Content Security Policy (CSP) considerations"
      ],
      "title": "Compatibility and requirements for Browser Monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "538a44c0c5def08c38b57c43fff73aa1002e2a5f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/getting-started/compatibility-requirements-browser-monitoring/",
      "published_at": "2021-07-02T00:27:15Z",
      "updated_at": "2021-05-21T20:47:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring includes strict security measures to provide a robust, standalone product with browser monitoring features. Before you install the Browser agent, make sure your system meets these requirements. Basic requirements To report data to Browser, your application must at a minimum meet two basic requirements: The traffic to the application must be from clients able to load and execute Browser JavaScript code and set cookies. Clients accessing the application must be able to send data to New Relic through HTTP requests. HTTPS is required for Browser Pro features. Important Browsers that subscribe to a disconnect list or that use content filtering extensions such as AdBlock may not be able to send data to New Relic. For example, if you are using the Enhanced Tracking Prevention disconnect list for Mozilla Firefox 69.0 or higher, you will need to change the default configuration. Most typical browser applications meet these requirements. However, browser applications in restricted environments may have difficulty reporting data to New Relic; for example: Hybrid mobile applications Applications installed on unusual hardware, such as point-of-sale terminals or consumer appliances For more information, review the instrumentation for browser monitoring documentation, and verify end-user network access. Browser types Instrumentation is compatible with every browser type, including Google Chrome, Mozilla Firefox, Microsoft Internet Explorer and Edge, and Apple Safari. The user interface is compatible with New Relic's supported browser versions. Exceptions Comments Paint timings The firstPaint and firstContentfulPaint attributes in BrowserInteraction, PageView, and PageViewTiming events are only compatible with: Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile AJAX AJAX timing features are not available with: Chrome for iPhone and iPad IE 7 and 8 PageAction events PageAction events require a browser that fully supports cross-domain XMLHttpRequests. Internet Explorer versions 9 and lower cannot record PageAction events. Learn more on querying your data. Session traces Session traces are reported only from browsers that support the Resource Timing Specification. SHA-256 New Relic can only monitor browsers that are compatible with SHA-256. APM agents You can deploy the Browser agent for apps monitored by APM, or you can deploy the Browser agent for your standalone apps. For more information, see the installation procedures. If you are deploying Browser for an app using APM, make sure your agent supports Browser monitoring: C SDK: Version 1.0.0 or higher Go: Version 2.5.0 or higher Java: Version 3.4.0 or higher .NET: Version 2.20.25.0 or higher Node.js: Version 1.4.0 or higher PHP: Version 4.4.5.35 or higher Python: Version 2.10.1.9 or higher Ruby: Version 3.7.0.177 or higher Supported frameworks The Browser agent collects data on all front-end frameworks. However, the monitoring occurs on lower-level \"primitives\" that JavaScript frameworks use, so the level of detail collected by the instrumentation may vary depending on your specific framework. Exceptions Comments Zone.js If you're using AngularJS and you want to use Browser's SPA monitoring capabilities, note that Zone.js versions 0.6.18 to 0.6.24 are not compatible with Browser. In all cases, the Browser agent must be loaded before Zone.js to avoid errors. Cypress.io Browser is unable to properly instrument the open and send methods of requests when tests are run in Cypress. This will cause the following error to be thrown: Cannot set property 'status' of undefined Copy This will only affect customers running tests with the Browser agent present in their code. Production applications should not be affected. html2pdf.js This library is not compatible with our SPA-enabled Browser agent due to the way this library wraps promises. If you're using this library, we recommend the Browser Pro agent. Content Security Policy (CSP) considerations In order to obtain accurate browser performance metrics, Browser requires the use of a small, inline JavaScript snippet. New Relic carefully reviews the inline JavaScript to prevent Cross-Site Scripting (XSS) and other potential vulnerabilities. Content Security Policy Level 2 adds restrictions to the types of JavaScript allowed, such as inline scripts. It also limits which domains can load scripts during page load. Important If your website does not allow any third-party hosted JavaScript to run, you must request a CSP exception via your organizationâ€™s standard procedures in order to install the Browser monitoring agent. When requesting a CSP exception, follow your organization's standard procedures to contact your web or security team. The Browser JavaScript agent requires the following CSP exceptions in order to run properly. Alternatively, you can add all of these exceptions to the fallback default-src directive (instead of script-src and connect-src). CSP exception Comments unsafe-inline Add to the script-src directive or to the fallback default-src directive. This is required because the agent is installed by including an inline script. https://js-agent.newrelic.com Add to the script-src directive or to the fallback default-src directive. This is where additional script files that the agent requires are hosted. https://bam.nr-data.net https://bam-cell.nr-data.net Important Add https://gov-bam.nr-data.net if you're using FedRAMP-compliant endpoints. Add to the script-src directive or to the fallback default-src directive. This is where the agent sends its collected data. One of the calls to this URL is a JSONP call, which means that the URL must be allowed as a script source. Add to the connect-src directive or to the fallback default-src directive. The connect-src directive affects the URLs that scripts can call (for example, using the XMLHttpRequest interface). If you have CSP restrictions specifically around this directive, then add this URL as an exception.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.53795,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for <em>Browser</em> <em>Monitoring</em>",
        "sections": "Compatibility and requirements for <em>Browser</em> <em>Monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em> includes strict security measures to provide a robust, standalone product with <em>browser</em> <em>monitoring</em> features. Before you install the <em>Browser</em> agent, make sure your system meets these requirements. Basic requirements To report data to <em>Browser</em>, your application must at a minimum meet"
      },
      "id": "603ed6b664441f4a784e883f"
    }
  ],
  "/docs/browser/browser-monitoring/installation/install-browser-monitoring-agent": [
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.74606,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "If you use <em>Browser</em> to <em>monitor</em> end-user <em>browser</em> activity, you can now see end-user-originating <em>browser</em>-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data"
      },
      "id": "6043fe6f196a6784f0960f53"
    },
    {
      "sections": [
        "Collect custom attributes",
        "Requirements",
        "APM: Record custom attributes",
        "Important",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "Browser monitoring: Record custom attributes",
        "Infrastructure monitoring: Record custom attributes",
        "Mobile monitoring: Record custom attributes",
        "For more help"
      ],
      "title": "Collect custom attributes",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Install and configure"
      ],
      "external_id": "ad362b1a5cf3a5661eb416584fd9c79db064f539",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/data/customize-data/collect-custom-attributes/",
      "published_at": "2021-07-02T19:49:53Z",
      "updated_at": "2021-07-02T19:49:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some New Relic solutions, one way to report custom data to New Relic is to use custom attributes. For example, for New Relic browser monitoring, you might create a custom attribute to track the user name associated with a slow or failing request. Requirements Custom attributes are available for these New Relic solutions: APM Browser monitoring Mobile monitoring Infrastructure monitoring For other custom data solutions, see Intro to custom data. APM: Record custom attributes Important Review the list of reserved terms used by NRQL. Using reserved terms can cause issues. To enable and use custom attributes for APM, follow the procedure for your APM agent: C SDK To add custom attributes to applications monitored by the C SDK, call one of the attribute functions; for example, newrelic_add_attribute_double(). The key name for your custom attribute depends on what you specify when you call the function. Go Custom attribute collection is enabled by default in the Go agent. However, you can disable custom attribute collection. Java Custom attribute collection is enabled by default in Java. You can collect custom attributes using XML and the Java agent APIs. These two methods can be used in conjunction with each other. Method How to do it Specify attributes in XML XML allows you to specify custom attributes without changing any of your source code. You can have multiple XML files for custom attributes that are grouped by some logical facet. To set custom attributes for your Java app via XML: Review the New Relic Java agent's documentation about XML file format, methods and classes, and examples. From your Extensions directory within the New Relic Java agent, create a single XML file. Define the methods you want New Relic to monitor by editing your XML file directly. Define an XML instrumentation file using the New Relic UI. This may require additional config in the common: block of your newrelic.yml. See Report custom attributes under Instrumentation options for more detail. Call the agent's API Example 1: Adding custom attributes to transactions To collect custom attributes using the agent's API, call the relevant methods: For each method you want to record an attribute for, call NewRelic.addCustomParameter(...). Optional: Include or exclude certain attributes with attributes.include and attributes.exclude. For example, to record a variable named userId, include this code in the parent method: NewRelic.addCustomParameter(\"userId\", userId); Copy Example 2: Adding custom attributes to spans in distributed traces To collect custom attributes using the agent's API, call the relevant methods: For each span (currently executing method) that you want to record an attribute for, call NewRelic.getAgent().getTracedMethod().addCustomAttribute(...). Optional: Include or exclude certain attributes with span_events.attributes.include and span_events.attributes.exclude. For example, to record a variable named userId on the current span, include this code in the associated method: NewRelic.getAgent().getTracedMethod().addCustomAttribute(\"userId\", userId); Copy Collect user attributes The Java agent also includes a built-in mechanism to enable user attributes and collect user information from HttpServletRequest.getUserPrincipal() as custom attributes. .NET Custom attribute collection is enabled by default in .NET. To collect custom attributes, call the relevant API methods: For each method for which you want to record an attribute, call AddCustomAttribute. Optional: Include or exclude attributes with the include and exclude configuration options. For example, to record attributes for a coupon code (string) and an item ID code (number), you could include this code in the parent method: IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction .AddCustomAttribute(\"Discount Code\", \"Summer Super Sale\") .AddCustomAttribute(\"Item Code\", 31456); Copy Node.js Custom attribute collection is enabled by default in Node.js. To collect custom attributes, call the relevant API method: For each attribute you want to record, call newrelic.addCustomAttribute. To record multiple attributes using a single call, use newrelic.addCustomAttributes. For example, to record attributes for a coupon code and an item ID code, you could include this in the parent method: newrelic.addCustomAttributes({ \"Discount Code\": \"Summer Super Sale\", \"Item Code\": 31456 }); Copy PHP Custom attribute collection is enabled by default in PHP. To collect custom attributes, call the relevant API method for each method that you want to record an attribute; newrelic_add_custom_parameter for transaction events and spans newrelic_add_custom_span_parameter for only spans For example, to record a variable named $userId, include this code in the parent method: newrelic_add_custom_parameter ('userID', $userId) Copy Python Custom attribute collection is enabled by default in Python. To collect custom attributes, call add_custom_parameter for each method that you want to record an attribute. For example, to record a variable named user_id, include this code in the parent method: newrelic.agent.add_custom_parameter('user_id', user_id) Copy Ruby Custom attribute collection is enabled by default in Ruby. To collect custom attributes, call the relevant API methods: For Ruby agent version 3.12.0 or higher, use the add_custom_attributes method. For example, to record a variable named @user_id, include this code in the parent method: ::NewRelic::Agent.add_custom_attributes({ user_id: @user.id }) Copy For Ruby agent version 3.11.2 or lower, use the add_custom_parameters method. For example, to record a variable named @user_id, include this code in the parent method: ::NewRelic::Agent.add_custom_parameters({ user_id: @user.id }) Copy Browser monitoring: Record custom attributes The browser agent provides an API to specify extra details associated with a page view or browser interaction, either by forwarding attributes from APM to browser monitoring or by specifying custom attributes through JavaScript. Values forwarded from the APM agent are encoded and injected into browser attributes by our browser agent. Infrastructure monitoring: Record custom attributes Our Infrastructure monitoring lets you create custom attributes that are used to annotate the data from the infrastructure agent. You can use this metadata to build filter sets, group your results, and annotate your data. Mobile monitoring: Record custom attributes Mobile agents include API calls to record custom attributes: For an overview of mobile monitoring custom data, see Insert custom events and attributes Android method: setAttribute iOS method: setAttribute For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.80817,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Browser</em> <em>monitoring</em>: Record custom attributes",
        "tags": "<em>Install</em> and configure",
        "body": "For some New Relic solutions, one way to report custom data to New Relic is to use custom attributes. For example, for New Relic <em>browser</em> <em>monitoring</em>, you might create a custom attribute to track the user name associated with a slow or failing request. Requirements Custom attributes are available"
      },
      "id": "603eb9a3196a67a990a83da5"
    },
    {
      "sections": [
        "Update the Browser agent",
        "Check your version number",
        "Check deployment method",
        "Update your APM-managed installation",
        "Update your copy/paste installation",
        "Caution",
        "Retrieve the snippet from the UI",
        "Extract the snippet with the REST API",
        "Update using the loader endpoint"
      ],
      "title": "Update the Browser agent",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Installation"
      ],
      "external_id": "88c27eeabc364683eae41935bd6a1b178cae36ed",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/installation/update-browser-agent/",
      "published_at": "2021-07-02T00:29:12Z",
      "updated_at": "2021-05-16T09:54:58Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Running the latest version of Browser monitoring ensures you can access all Browser features and enhancements. To update to the latest version, check your version number, then follow the steps to update an APM-managed installation or to upgrade a copy/paste installation. Check your version number To verify your Browser version number: View the source code of a page which includes the JavaScript snippet. Search the page source for js-agent.newrelic.com/nr-. The numbers that follow nr- are your current version. For example, js-agent.newrelic.com/nr-593.min.js indicates you are running version 593 of the Browser script. The Pro+SPA agent will have the format js-agent.newrelic.com/nr-spa-1184.min.js To verify the latest version of the Browser script loader: Go to js-agent.newrelic.com/nr-loader-full-current.min.js . Search for js-agent.newrelic.com/nr-, then note the numbers that follow nr-. If the latest version number is higher than the number of the version you are currently running, update your Browser agent. Check deployment method Your Browser agent may have been deployed using the copy/paste method rather than injected with APM. To check which deployment method was used, run this command in the JavaScript console: > newrelic.info.sa Copy If the command returns 1, then your Browser agent used the copy/paste method. Update your APM-managed installation To update your APM-managed Browser installation, restart your APM agent. Your app will automatically update to the latest JavaScript snippet. To ensure the new script registers, you may need to clear your cache. For more information, follow the troubleshooting procedures to manually check and clear the cache. Update your copy/paste installation Use any of the following options to access the Browser JavaScript snippet needed to update a copy/paste installation. After accessing the snippet, be sure to replace all of your existing snippet with the new version. If you have a standalone installation with a few applications, you can retrieve the snippet from the UI, and then replace it with the new version. If you have many applications, you can use the REST API or the loader endpoint to automate the update process. Caution Do not simply change the version number in the existing snippet. This can result in incomplete data collection. For best results after you use any of the following options, always update the agent. Retrieve the snippet from the UI Download the latest version of the snippet: Go to one.newrelic.com > Browser > (select an app) > Application settings. This option is only available for standalone installations. Extract the snippet with the REST API To update the snippet using the New Relic REST API, follow the process for viewing a specific Browser app. The loader_script attribute in your response will include the latest JavaScript snippet. This may be a good solution if you have many applications to manage, or if your Browser app is linked to an APM app. Update using the loader endpoint To update the snippet from the New Relic loader endpoint, use the Browser Pro + SPA endpoint, the Browser Pro endpoint, or the Browser Lite endpoint. These endpoints always point to the latest version of the script snippet. Recommendation: Use the Browser Pro or Pro + SPA loaders regardless of your Browser subscription level. These loaders are compatible with both the Pro and Lite subscription levels. These loader endpoints are generic and do not include your specific configuration data. To add your configuration data to the loaders: Find your Browser application ID and license key: Follow standard procedures to use the New Relic UI or the REST API. Set your Browser application ID and license key immediately after the snippet. NREUM.info = { applicationID: \"YOUR-APPLICATION-ID\", licenseKey: \"YOUR-BROWSER-LICENSE-KEY\" }; Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 131.79634,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Update the <em>Browser</em> agent",
        "sections": "Update your APM-managed <em>installation</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "Running the latest version of <em>Browser</em> <em>monitoring</em> ensures you can access all <em>Browser</em> features and enhancements. To update to the latest version, check your version number, then follow the steps to update an APM-managed <em>installation</em> or to upgrade a copy&#x2F;paste <em>installation</em>. Check your version number"
      },
      "id": "603ec40c64441f245f4e8879"
    }
  ],
  "/docs/browser/browser-monitoring/page-load-timing-resources/cookie-collection-session-tracking": [
    {
      "sections": [
        "PageViewTiming: Async or dynamic page details",
        "Why use PageViewTiming?",
        "Support for Google's Core Web Vitals",
        "Detailed visual, interactivity, and responsiveness metrics",
        "Compatibility and requirements",
        "Query your event data",
        "Percentile over timeseries",
        "Percentile by transaction and interaction",
        "Histogram of delay timings"
      ],
      "title": "PageViewTiming: Async or dynamic page details",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "069f311598f5df27ee46006693b077f7f8b8d146",
      "image": "https://docs.newrelic.com/static/e19694ae33f749d66a346968f23bfb5a/c1b63/core-web-vitals_0.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details/",
      "published_at": "2021-07-02T00:31:09Z",
      "updated_at": "2021-03-16T07:25:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its attributes to query data about your site, component loading, and user performance metrics, both from visual and responsiveness standpoints. Why use PageViewTiming? If your application uses asynchronous or dynamic pages, you may need additional details about site or component loading. But pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the Browser agent. For example, users may become impatient and begin clicking as soon as content is on the webpage. Or, they may wait to use the page until long after content is loaded. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. The additional metrics can help you understand how users experience your site, both from visual and responsiveness standpoints. Support for Google's Core Web Vitals We now, with the release of agent version 1177, have full support for Google's Core Web Vitals for 2020. The metrics that make up Core Web Vitals will evolve over time. The current set for 2020 focuses on three aspects of the user experienceâ€”loading, interactivity, and visual stabilityâ€”and includes the following metrics (and their respective thresholds): Core Web Vitals metrics include loading, interactivity, and visual stability. Largest Contentful Paint (LCP): measures loading performance. To provide a good user experience, LCP should occur within 2.5 seconds of when the page first starts loading. First Input Delay (FID): measures interactivity. To provide a good user experience, pages should have a FID of less than 100 milliseconds. Cumulative Layout Shift (CLS): measures visual stability. To provide a good user experience, pages should maintain a CLS of less than 0.1. For each of the above metrics, to ensure you're hitting the recommended target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices. To learn more, watch our Nerd Days talk on perceived performance. Detailed visual, interactivity, and responsiveness metrics The BrowserInteraction and PageView events end their reporting when they receive the page window load (or window load and AJAX) timing. However, paint and interactivity metrics can happen at any time. PageViewTiming delivers these metrics as a separate event to: Account for the variability in this timing. Avoid setting an arbitrary timeout. Prevent holding BrowserInteraction and PageView events indefinitely. Additional data Comments firstPaint and firstContentfulPaint The firstPaint and firstContentfulPaint attributes already are available with BrowserInteraction and PageView events. However, they are not always reliably captured before the window onload event fires. Using PageViewTiming gives you a way to capture these metrics even if they happen after the original page load time. This gives you a better understanding of the correlation between responsiveness of that load event and the visual rendering of your content. largestContentfulPaint This new metric, available with agent version 1163, largestContentfulPaint, reports the render time of the largest content element visible in the viewport. Google's research found looking at when the largest element was rendered was a more accurate way to measure when the main content of a page is loaded and useful. Details on this metric, including limitations and considerations can be found in the w3c draft. In addition, we now report the cumulative layout shift (CLS) score attribute with LCP. This attribute is reported as cumulativeLayoutShift. Largest Contentful Paint is one of three metrics identified by Google as the Core Web Vitals. LCP values up to 2.5 secs are considered \"Good\", between 2.5-4.0 secs considered \"Needs Improvement\", and above 4.0 secs considered \"Poor.\" firstInteraction and firstInputDelay With the addition of firstInteraction and firstInputDelay, you can quickly determine the ways that your users are interacting with that visual content. These metrics tell you not only when they interacted, but what type of interaction (mousedown, pointerdown, etc.) and how long it took for them to receive a response from your site. The firstInputDelay metric lies in the middle of FirstContentfulPaint and Time to Interactive (TTI) metrics, measuring the time between when a first input can be made and when the browser's main thread is able to respond to any interactions. In addition, we now report the cumulative layout shift (CLS) score attribute at the moment of the user's first interaction. This attribute is reported as cumulativeLayoutShift. First Input Delay is one of three metrics identified by Google as the Core Web Vitals. FID values up to 100 ms are considered \"Good\", between 100-300 ms considered \"Needs Improvement\", and above 300 ms considered \"Poor.\" For a more detailed explanation, see the Browser release notes. cumulativeLayoutShift Cumulative Layout Shift (CLS), available with agent v1177, is an important, user-centric metric for measuring visual stability because it helps quantify how often users experience unexpected layout shiftsâ€”a low CLS helps ensure that the page is delightful. This is one of three metrics identified by Google as the Core Web Vitals. Cumulative Layout Shift is one of three metrics identified by Google as the Core Web Vitals. CLS scores up to 0.1 are considered \"Good\", between 0.1-0.25 considered \"Needs Improvement\", and above 0.25 considered \"Poor.\" timingName You can review different types of activities with the timingName attribute, such as firstPaint, firstContentfulPaint, firstInteraction, largestContentfulPaint, pageHide and windowUnload. For example, a PageViewTiming event may have a timingName of firstPaint and a firstPaint value of .03. The event will also include all default attributes included with the standard BrowserInteraction and PageView events. elementId This is the Id, if specified, of the largestContentfulPaint element. This value will only be reported with the LCP metric. This value can be null. elementSize This is the reported size of the largestContentfulPaint element. This value will only be reported with the LCP metric. pageHide The pageHide event, available with agent v1177, is sent when the browser hides the current page in the process of presenting a different page from the session's history. For example, when the user clicks the browser's Back button, the current page receives a pageHide event before the previous page is shown. Supporting documentation and browser compatibility for the pageHide event can be found in MDN docs. In addition, we now report the cumulative layout shift (CLS) score attribute with pageHide. This attribute is reported as cumulativeLayoutShift. windowLoad The windowLoad event, available with agent v1177, is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. Supporting documentation and browser compatibility for the Window Load event can be found in MDN docs. In addition, we now report the cumulative layout shift (CLS) score attribute with windowLoad. This attribute is reported as cumulativeLayoutShift. windowUnload The windowUnload event, available with agent v1163, is fired when a document or child resource is being unloaded. Supporting documentation and browser compatibility for the Window Unload event can be found in MDN docs. In addition, we now report the cumulative layout shift (CLS) score attribute with windowUnload. This attribute is reported as cumulativeLayoutShift. Compatibility and requirements In addition to Browser's installation requirements, the PageViewTiming event requires Browser agent version 1153 or higher and a Browser Pro subscription. Follow our Browser agent release notes to find out when new metrics are released. These metrics are supported by the following browser versions. For unsupported browsers, no PageViewTiming events will be recorded. Metrics Supported browser versions cumulativeLayoutShift Chrome 79 Metric is elevated to stable; changes in metric definition will be reported in this log. Chrome 77 Metric exposed via API: Cumulative Layout Shift available via Layout Instability API firstPaint firstContentfulPaint Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile largestContentfulPaint Chrome 77 or higher for desktop and mobile firstInteraction firstInputDelay These metrics require the addEventListener Browser API. This API is available in all modern browsers, including: Apple Safari Google Chrome Microsoft Internet Explorer (IE) versions 9 or higher Mozilla Firefox pageHide This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowLoad This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowUnload This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. Query your event data Here are some sample queries for the event data to help you get started. Percentile over timeseries Show the 95th percentile of first paint and first contentful paint over a time series: SELECT FILTER(percentile(firstPaint, 95), where(timingName = ' firstPaint ')) as 'fp', FILTER(percentile( firstContentfulPaint , 95), where(timingName = 'firstContentfulPaint')) as 'fcp' FROM PageViewTiming TIMESERIES 1 minute SINCE 1 hour ago Copy Percentile by transaction and interaction Show the 95th percentile of first input delay over a time series, faceted by transaction name and interaction type: SELECT percentile( firstInputDelay , 95) as 'fid' FROM PageViewTiming WHERE timingName = 'firstInteraction' TIMESERIES 1 minute FACET browserTransactionName, interactionType SINCE 3 hours ago Copy Histogram of delay timings Show a histogram of first input delay timings faceted by first interaction time ranges: FROM PageViewTiming SELECT histogram( firstInputDelay , 1000, 10) SINCE 3 hours ago WHERE timingName = 'firstInteraction' FACET CASES (WHERE firstInteraction < 1, WHERE firstInteraction >= 1 AND firstInteraction < 5, WHERE firstInteraction >= 5) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.11307,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>PageViewTiming</em>: Async or dynamic <em>page</em> details",
        "sections": "<em>PageViewTiming</em>: Async or dynamic <em>page</em> details",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": " and firstContentfulPaint attributes already are available with <em>Browser</em>Interaction and <em>Page</em>View events. However, they are not always reliably captured before the window onload event fires. Using <em>PageViewTiming</em> gives you a way to capture these metrics even if they happen after the original <em>page</em> <em>load</em> <em>time</em>"
      },
      "id": "603ea90a64441f02614e88a4"
    },
    {
      "sections": [
        "New Relic cookies used by Browser",
        "Tip",
        "Data privacy and legal compliance",
        "JSESSIONID",
        "NREUM",
        "NRAGENT"
      ],
      "title": "New Relic cookies used by Browser",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "fe0f7b83aafd52fce5ffff3176545910ed9cbb54",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/page-load-timing-resources/new-relic-cookies-used-browser/",
      "published_at": "2021-07-02T09:17:12Z",
      "updated_at": "2021-03-11T05:02:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes data privacy related to Browser monitoring and cookies, and details about the cookies themselves. Page load timing (sometimes referred to as real user monitoring or RUM) creates the following cookies that Browser monitoring uses when session tracking in end-user browsers. Tip These cookies are related to Browser app monitoring. For more information about data privacy and requesting data to be deleted, see New Relic personal data requests. Data privacy and legal compliance The default Browser agent configuration does not retain any personal data as defined by common privacy laws such as the EU General Data Protection Regulation (GDPR) and California Consumer Privacy Act (CCPA). New Relic has taken steps to enable our customers who elect to process personal data in our products to do so in accordance with applicable privacy laws. Use the additional information below to help enable your compliance with such laws: Data Description IP addresses New Relic briefly collects and leverages the IP address from the end-user as part of the data collection process. The IP is captured when a connection is made between the end user's browser and the New Relic data collector. The IP address is included in the web request, much like a caller ID. New Relic uses the IP, much like you see a phone number when somebody calls you. The IP address is used as a lookup value that maps to additional details, allowing New Relic customers to diagnose performance issues. IP address lookup values include: countryCode regionCode city asn (Autonomous System Number) asnOrganization (ISP/Business/Institution) asnLatitude asnLongitude The mapping process for the IP address lookup value is typically complete within minutes, but in some extreme cases may take up to 24 hours to process. Once the mapping process is complete, New Relic no longer retains the IP address. Default cookies The Browser monitoring agent sets cookies by default. Cookies are placed by the Browser agent and the New Relic collector. The New Relic collector places a cookie when the Browser agent makes a connection and transmits data. A cookie consent manager that uses a conditional script loader that only loads tags/snippets when a visitor agrees to a specific type of cookies can be used. By choosing this option there is a risk that page performance will not be captured until the visitor has agreed and the Browser agent is running. With the release of Browser agent v1169, you can turn off cookie collection (JSESSIONID and NREUM) for your Browser app by using the Application settings page in the New Relic UI. Once this configuration value is set to false (OFF), you will no longer see the session information in your event data. By default, the value is set to true (ON) for all existing Browser apps as well as newly created ones. For more information, see our documentation about cookie collection and session tracking. Personal data through custom Browser configuration New Relic offers the option to manually configure your agent through the Browser monitoring API. This could be used to capture personal data, subject to the restrictions set forth in the Terms of Service with New Relic. (For example, no credit card numbers or sensitive categories of personal data, which are contractually prohibited.) New Relic responds to the instructions specified by the agents, including collecting personal data that may be custom configured. If you (as the data controller) receive a request from one of your own customers and determine that personal data sent to New Relic for processing must be deleted, see New Relic personal data requests. JSESSIONID The JSESSIONID cookie is used to store a session identifier so that New Relic can monitor session counts for an application. The cookie value is generated by Jetty. Components Description Session identifier This is used by New Relic to monitor session counts for an application. Domain The JSESSIONID cookie is associated with the New Relic domain. Expiration JSESSIONID is a session cookie that is deleted when the browser closes. NREUM This cookie is only created in browsers that do not support the Navigation Timing API. When a browser supports the Navigation Timing API, a native interface can be used to determine navigation start time. Mozilla Firefox versions 7 or higher support the Navigation Timing API. However, a bug exists in Firefox's early implementations of the Navigation Timing API that Browser monitoring works around by using this cookie. Components Description Navigation start time Navigation start time is required to measure end user response time. The cookie is written when the current page unloads (as the next navigation begins). Document location Stored as a hash. The document location is used with the referring page URL to validate that the start time refers to the page that was previously being viewed or refreshed (to avoid using an invalid start time from a different navigation). Referring page URLs Stored as a hash. The referring page URL is used with the document location to validate that the start time refers to the page that was previously being viewed or refreshed (to avoid using an invalid start time from a different navigation). Domain The NREUM cookie is associated with the root path of the domain in which the New Relic agent executes. Expiration NREUM is a session cookie that is deleted when the browser closes. NRAGENT The NRAGENT cookie is set only if you use Browser agent version v443 or lower. It is created when a token is handed out to an end user by the New Relic collector. End-user metrics are communicated to New Relic collectors via a JSONP request from the browser (script retrieval). The returned JavaScript contains a call to set the token identifier which is written to the cookie on the next navigation (when the page unloads). This achieves a cross-domain communication between the New Relic collector and the New Relic agent. This cookie is used to communicate between the New Relic collector aggregating end user metrics and the agent(s) running in the associated web application. A token identifies and correlates application tier transaction traces with corresponding browser traces. Components Description Token identifier The 16-character token identifier helps with cross-domain communication between the New Relic collector and the New Relic agent. Domain The NRAGENT cookie is associated with the root path of the domain in which the New Relic agent executes. Expiration NRAGENT is a session cookie that is deleted when the browser closes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 219.33656,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic cookies used by <em>Browser</em>",
        "sections": "New Relic cookies used by <em>Browser</em>",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "This document describes data privacy related to <em>Browser</em> <em>monitoring</em> and cookies, and details about the cookies themselves. <em>Page</em> <em>load</em> <em>timing</em> (sometimes referred to as real user <em>monitoring</em> or RUM) creates the following cookies that <em>Browser</em> <em>monitoring</em> uses when session tracking in end-user browsers"
      },
      "id": "60442a2f196a673c3e960f2f"
    },
    {
      "sections": [
        "Cached pages",
        "Contents",
        "Detecting cached pages",
        "For more help"
      ],
      "title": "Cached pages",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "abdc36d00ef805f7f51ca56c1f43a24efe9b00a5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/cached-pages/",
      "published_at": "2021-07-02T00:29:12Z",
      "updated_at": "2021-03-11T05:02:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Pages can be cached in the browser or on a server. A cached page will contain stale (previously generated) application and queue times. Contents Detecting cached pages Browser monitoring detects cached pages by comparing the total back-end time against app and queue time. When the sum of app and queue time is greater than the total back-end time, Browser monitoring assumes the page was cached and aggregates the request with app and queue times as 0. Here are some additional tips for cached pages: Java: Flush the app serverâ€™s \"work\" cache. This forces the app server to recompile. .NET: Make sure your asp.net cache directory is clean by using the command flush_dotnet_temp.cmd. This forces the app server to recompile ASPs with page load timing instrumentation. Node.js: By default, Node.js does not cache pages. PHP: If you have a CDN cache your dynamic pages, make sure the cache contains the page load timing instrumentation. Python: Restart your app. Ruby: Look at the header information for automatic vs. manual instrumentation. For example, if you want to ignore specific webpages, you must disable automatic browser monitoring from the user interface, and then manually instrument the webpages that you do want to be tagged. For more help Additional documentation resources include: Instrumentation for page load timing (JavaScript elements, data transmission) Page load timing process (overview including time segments and colors, differences between app server requests and page load timing, outliers)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 219.33656,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Cached <em>pages</em>",
        "sections": "Cached <em>pages</em>",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": " the <em>page</em> <em>load</em> <em>timing</em> instrumentation. Python: Restart your app. Ruby: Look at the header information for automatic vs. manual instrumentation. For example, if you want to ignore specific webpages, you must disable automatic <em>browser</em> <em>monitoring</em> from the user interface, and then manually instrument"
      },
      "id": "6043faac28ccbc2cc52c6087"
    }
  ],
  "/docs/browser/browser-monitoring/page-load-timing-resources/new-relic-cookies-used-browser": [
    {
      "sections": [
        "PageViewTiming: Async or dynamic page details",
        "Why use PageViewTiming?",
        "Support for Google's Core Web Vitals",
        "Detailed visual, interactivity, and responsiveness metrics",
        "Compatibility and requirements",
        "Query your event data",
        "Percentile over timeseries",
        "Percentile by transaction and interaction",
        "Histogram of delay timings"
      ],
      "title": "PageViewTiming: Async or dynamic page details",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "069f311598f5df27ee46006693b077f7f8b8d146",
      "image": "https://docs.newrelic.com/static/e19694ae33f749d66a346968f23bfb5a/c1b63/core-web-vitals_0.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details/",
      "published_at": "2021-07-02T00:31:09Z",
      "updated_at": "2021-03-16T07:25:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its attributes to query data about your site, component loading, and user performance metrics, both from visual and responsiveness standpoints. Why use PageViewTiming? If your application uses asynchronous or dynamic pages, you may need additional details about site or component loading. But pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the Browser agent. For example, users may become impatient and begin clicking as soon as content is on the webpage. Or, they may wait to use the page until long after content is loaded. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. The additional metrics can help you understand how users experience your site, both from visual and responsiveness standpoints. Support for Google's Core Web Vitals We now, with the release of agent version 1177, have full support for Google's Core Web Vitals for 2020. The metrics that make up Core Web Vitals will evolve over time. The current set for 2020 focuses on three aspects of the user experienceâ€”loading, interactivity, and visual stabilityâ€”and includes the following metrics (and their respective thresholds): Core Web Vitals metrics include loading, interactivity, and visual stability. Largest Contentful Paint (LCP): measures loading performance. To provide a good user experience, LCP should occur within 2.5 seconds of when the page first starts loading. First Input Delay (FID): measures interactivity. To provide a good user experience, pages should have a FID of less than 100 milliseconds. Cumulative Layout Shift (CLS): measures visual stability. To provide a good user experience, pages should maintain a CLS of less than 0.1. For each of the above metrics, to ensure you're hitting the recommended target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices. To learn more, watch our Nerd Days talk on perceived performance. Detailed visual, interactivity, and responsiveness metrics The BrowserInteraction and PageView events end their reporting when they receive the page window load (or window load and AJAX) timing. However, paint and interactivity metrics can happen at any time. PageViewTiming delivers these metrics as a separate event to: Account for the variability in this timing. Avoid setting an arbitrary timeout. Prevent holding BrowserInteraction and PageView events indefinitely. Additional data Comments firstPaint and firstContentfulPaint The firstPaint and firstContentfulPaint attributes already are available with BrowserInteraction and PageView events. However, they are not always reliably captured before the window onload event fires. Using PageViewTiming gives you a way to capture these metrics even if they happen after the original page load time. This gives you a better understanding of the correlation between responsiveness of that load event and the visual rendering of your content. largestContentfulPaint This new metric, available with agent version 1163, largestContentfulPaint, reports the render time of the largest content element visible in the viewport. Google's research found looking at when the largest element was rendered was a more accurate way to measure when the main content of a page is loaded and useful. Details on this metric, including limitations and considerations can be found in the w3c draft. In addition, we now report the cumulative layout shift (CLS) score attribute with LCP. This attribute is reported as cumulativeLayoutShift. Largest Contentful Paint is one of three metrics identified by Google as the Core Web Vitals. LCP values up to 2.5 secs are considered \"Good\", between 2.5-4.0 secs considered \"Needs Improvement\", and above 4.0 secs considered \"Poor.\" firstInteraction and firstInputDelay With the addition of firstInteraction and firstInputDelay, you can quickly determine the ways that your users are interacting with that visual content. These metrics tell you not only when they interacted, but what type of interaction (mousedown, pointerdown, etc.) and how long it took for them to receive a response from your site. The firstInputDelay metric lies in the middle of FirstContentfulPaint and Time to Interactive (TTI) metrics, measuring the time between when a first input can be made and when the browser's main thread is able to respond to any interactions. In addition, we now report the cumulative layout shift (CLS) score attribute at the moment of the user's first interaction. This attribute is reported as cumulativeLayoutShift. First Input Delay is one of three metrics identified by Google as the Core Web Vitals. FID values up to 100 ms are considered \"Good\", between 100-300 ms considered \"Needs Improvement\", and above 300 ms considered \"Poor.\" For a more detailed explanation, see the Browser release notes. cumulativeLayoutShift Cumulative Layout Shift (CLS), available with agent v1177, is an important, user-centric metric for measuring visual stability because it helps quantify how often users experience unexpected layout shiftsâ€”a low CLS helps ensure that the page is delightful. This is one of three metrics identified by Google as the Core Web Vitals. Cumulative Layout Shift is one of three metrics identified by Google as the Core Web Vitals. CLS scores up to 0.1 are considered \"Good\", between 0.1-0.25 considered \"Needs Improvement\", and above 0.25 considered \"Poor.\" timingName You can review different types of activities with the timingName attribute, such as firstPaint, firstContentfulPaint, firstInteraction, largestContentfulPaint, pageHide and windowUnload. For example, a PageViewTiming event may have a timingName of firstPaint and a firstPaint value of .03. The event will also include all default attributes included with the standard BrowserInteraction and PageView events. elementId This is the Id, if specified, of the largestContentfulPaint element. This value will only be reported with the LCP metric. This value can be null. elementSize This is the reported size of the largestContentfulPaint element. This value will only be reported with the LCP metric. pageHide The pageHide event, available with agent v1177, is sent when the browser hides the current page in the process of presenting a different page from the session's history. For example, when the user clicks the browser's Back button, the current page receives a pageHide event before the previous page is shown. Supporting documentation and browser compatibility for the pageHide event can be found in MDN docs. In addition, we now report the cumulative layout shift (CLS) score attribute with pageHide. This attribute is reported as cumulativeLayoutShift. windowLoad The windowLoad event, available with agent v1177, is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. Supporting documentation and browser compatibility for the Window Load event can be found in MDN docs. In addition, we now report the cumulative layout shift (CLS) score attribute with windowLoad. This attribute is reported as cumulativeLayoutShift. windowUnload The windowUnload event, available with agent v1163, is fired when a document or child resource is being unloaded. Supporting documentation and browser compatibility for the Window Unload event can be found in MDN docs. In addition, we now report the cumulative layout shift (CLS) score attribute with windowUnload. This attribute is reported as cumulativeLayoutShift. Compatibility and requirements In addition to Browser's installation requirements, the PageViewTiming event requires Browser agent version 1153 or higher and a Browser Pro subscription. Follow our Browser agent release notes to find out when new metrics are released. These metrics are supported by the following browser versions. For unsupported browsers, no PageViewTiming events will be recorded. Metrics Supported browser versions cumulativeLayoutShift Chrome 79 Metric is elevated to stable; changes in metric definition will be reported in this log. Chrome 77 Metric exposed via API: Cumulative Layout Shift available via Layout Instability API firstPaint firstContentfulPaint Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile largestContentfulPaint Chrome 77 or higher for desktop and mobile firstInteraction firstInputDelay These metrics require the addEventListener Browser API. This API is available in all modern browsers, including: Apple Safari Google Chrome Microsoft Internet Explorer (IE) versions 9 or higher Mozilla Firefox pageHide This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowLoad This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowUnload This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. Query your event data Here are some sample queries for the event data to help you get started. Percentile over timeseries Show the 95th percentile of first paint and first contentful paint over a time series: SELECT FILTER(percentile(firstPaint, 95), where(timingName = ' firstPaint ')) as 'fp', FILTER(percentile( firstContentfulPaint , 95), where(timingName = 'firstContentfulPaint')) as 'fcp' FROM PageViewTiming TIMESERIES 1 minute SINCE 1 hour ago Copy Percentile by transaction and interaction Show the 95th percentile of first input delay over a time series, faceted by transaction name and interaction type: SELECT percentile( firstInputDelay , 95) as 'fid' FROM PageViewTiming WHERE timingName = 'firstInteraction' TIMESERIES 1 minute FACET browserTransactionName, interactionType SINCE 3 hours ago Copy Histogram of delay timings Show a histogram of first input delay timings faceted by first interaction time ranges: FROM PageViewTiming SELECT histogram( firstInputDelay , 1000, 10) SINCE 3 hours ago WHERE timingName = 'firstInteraction' FACET CASES (WHERE firstInteraction < 1, WHERE firstInteraction >= 1 AND firstInteraction < 5, WHERE firstInteraction >= 5) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.11307,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>PageViewTiming</em>: Async or dynamic <em>page</em> details",
        "sections": "<em>PageViewTiming</em>: Async or dynamic <em>page</em> details",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": " and firstContentfulPaint attributes already are available with <em>Browser</em>Interaction and <em>Page</em>View events. However, they are not always reliably captured before the window onload event fires. Using <em>PageViewTiming</em> gives you a way to capture these metrics even if they happen after the original <em>page</em> <em>load</em> <em>time</em>"
      },
      "id": "603ea90a64441f02614e88a4"
    },
    {
      "sections": [
        "Cookie collection and session tracking",
        "How it works",
        "Enable or disable cookie collection"
      ],
      "title": "Cookie collection and session tracking",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "4ad3150808fab2f68a2f944a8966ab9b60ee684b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/page-load-timing-resources/cookie-collection-session-tracking/",
      "published_at": "2021-07-02T09:17:12Z",
      "updated_at": "2021-03-11T05:02:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's page load timing feature can track sessions by using cookies that contain a simple session identifier. How it works Here is the basic process for session tracking: A session begins when a user visits a website where New Relic's browser monitoring is installed and cookie collection is enabled. After the user's browser is opened, our browser monitoring script sets a simple cookie identifying the session. The script then reads the cookie on subsequent page loads. The same session will continue until the user's browser is closed. Session tracking will not work properly in these situations: If users have cookies disabled in their browser If the browser is configured to not allow information associated with the New Relic cookie to be sent with the request from the monitored site Enable or disable cookie collection At New Relic, we take data privacy seriously. By default, we do not retain any personal data collected by our Browser agent, and you can control session tracking. To turn cookie collection on or off for your app: Go to one.newrelic.com > Browser > (select an app) > Settings > Application settings. In your app's Privacy settings, toggle Cookie collection.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 219.33656,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "<em>Browser</em> <em>monitoring</em>&#x27;s <em>page</em> <em>load</em> <em>timing</em> feature can track sessions by using cookies that contain a simple session identifier. How it works Here is the basic process for session tracking: A session begins when a user visits a website where New Relic&#x27;s <em>browser</em> <em>monitoring</em> is installed and cookie"
      },
      "id": "60442a2f28ccbc1bfe2c60a7"
    },
    {
      "sections": [
        "Cached pages",
        "Contents",
        "Detecting cached pages",
        "For more help"
      ],
      "title": "Cached pages",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "abdc36d00ef805f7f51ca56c1f43a24efe9b00a5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/cached-pages/",
      "published_at": "2021-07-02T00:29:12Z",
      "updated_at": "2021-03-11T05:02:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Pages can be cached in the browser or on a server. A cached page will contain stale (previously generated) application and queue times. Contents Detecting cached pages Browser monitoring detects cached pages by comparing the total back-end time against app and queue time. When the sum of app and queue time is greater than the total back-end time, Browser monitoring assumes the page was cached and aggregates the request with app and queue times as 0. Here are some additional tips for cached pages: Java: Flush the app serverâ€™s \"work\" cache. This forces the app server to recompile. .NET: Make sure your asp.net cache directory is clean by using the command flush_dotnet_temp.cmd. This forces the app server to recompile ASPs with page load timing instrumentation. Node.js: By default, Node.js does not cache pages. PHP: If you have a CDN cache your dynamic pages, make sure the cache contains the page load timing instrumentation. Python: Restart your app. Ruby: Look at the header information for automatic vs. manual instrumentation. For example, if you want to ignore specific webpages, you must disable automatic browser monitoring from the user interface, and then manually instrument the webpages that you do want to be tagged. For more help Additional documentation resources include: Instrumentation for page load timing (JavaScript elements, data transmission) Page load timing process (overview including time segments and colors, differences between app server requests and page load timing, outliers)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 219.33656,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Cached <em>pages</em>",
        "sections": "Cached <em>pages</em>",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": " the <em>page</em> <em>load</em> <em>timing</em> instrumentation. Python: Restart your app. Ruby: Look at the header information for automatic vs. manual instrumentation. For example, if you want to ignore specific webpages, you must disable automatic <em>browser</em> <em>monitoring</em> from the user interface, and then manually instrument"
      },
      "id": "6043faac28ccbc2cc52c6087"
    }
  ],
  "/docs/browser/browser-monitoring/troubleshooting/troubleshoot-your-browser-monitoring-installation": [
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.33612,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "If you use <em>Browser</em> to <em>monitor</em> end-user <em>browser</em> activity, you can now see end-user-originating <em>browser</em>-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data"
      },
      "id": "6043fe6f196a6784f0960f53"
    },
    {
      "sections": [
        "Not seeing specific page or endpoint names in Browser data",
        "Problem",
        "Solution"
      ],
      "title": "Not seeing specific page or endpoint names in Browser data",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Troubleshooting"
      ],
      "external_id": "e91e38e0160cd95da45e928f462c70fde1457031",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/troubleshooting/not-seeing-specific-page-or-endpoint-names-browser-data/",
      "published_at": "2021-07-02T00:36:02Z",
      "updated_at": "2021-06-14T22:19:10Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You're looking for performance breakdowns for specific pages or endpoints on the browser monitoring Page views UI page or AJAX UI page. The UI doesn't show the URL group you're looking for, or it only shows / and /*. This behavior also appears in SPA data in BrowserInteraction events and applies to browserInteractionName, targetGroupedUrl, and previousGroupedUrl attributes. Solution Browser monitoring automatically \"learns\" to group your page views when your application is first deployed, and it adds that information to an allow list for URLs. Sometimes this grouping may not match your current page view information. To solve this problem, manage your application's URL segment list settings by editing existing rules or by adding the domains and URL segments that make up your site's URLs. After you add the necessary rules, you should see a useful breakdown of your information in the UI. Here are some useful tips: Adding segments to your allow list Tip Use constant URL segments. Only add the URL segments that remain constant across many page views. Do not add unique segments such as IDs or highly-specific categories, because this can lead to metric grouping issues. Enter exact matches. Enter any URL segments as exact matches, including case. Use existing rules. If a rule already appears for a domain: Go to one.newrelic.com > Browser > (select an app) > Settings > Segment allow lists. Rather than creating a new rule, edit the existing rule, and add the domain to the UI's Allow listed segments field. Group sub-domains. Group similar sub-domains such as foo.domain.com and bar.domain.com under *.domain.com. This grouping must occur just before the top-level domain name. Set up single-page apps. If your site is a single-page application and you only see / under page views, then your grouping is working correctly. New Relic records subsequent requests as AJAX loads, and your AJAX page will contain more detailed information. If it doesn't, then follow the tips in this document. Remove rules when appropriate. If you need to remove a rule, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.2814,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Not seeing specific page or endpoint names in <em>Browser</em> data",
        "sections": "Not seeing specific page or endpoint names in <em>Browser</em> data",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "Problem You&#x27;re looking for performance breakdowns for specific pages or endpoints on the <em>browser</em> <em>monitoring</em> Page views UI page or AJAX UI page. The UI doesn&#x27;t show the URL group you&#x27;re looking for, or it only shows &#x2F; and &#x2F;*. This behavior also appears in SPA data in <em>Browser</em>Interaction events"
      },
      "id": "603e8fff28ccbc8813eba7a1"
    },
    {
      "sections": [
        "Install the browser monitoring agent",
        "Tip",
        "Select a deployment option",
        "Important",
        "Enable an APM-monitored app",
        "Enable with copy/paste",
        "Instrument webpages using the APM agent",
        "Troubleshoot Browser agent installation"
      ],
      "title": "Install the browser monitoring agent",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Installation"
      ],
      "external_id": "bc45bbc86cd4d8b81367ad0904907ddc735717f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/installation/install-browser-monitoring-agent/",
      "published_at": "2021-07-02T09:15:35Z",
      "updated_at": "2021-06-14T21:26:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser uses a JavaScript snippet (or \"agent\") to instrument your app's webpages. The JavaScript collects data for browser monitoring. To install the browser agent, you can choose from a number of deployment options. Tip To use Browser and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Select a deployment option No matter which option you use to deploy browser monitoring, the end result is to inject the browser agent's JavaScript snippet into your pages for browser monitoring. The method you select depends on your preferences and business needs. To view the procedure to install and enable the browser agent, click the link for the option you want to use. You can also use the Browser Application settings page to update settings. Important The following configuration options refer only to the browser monitoring agent. These are not the same as the New Relic user roles and editions. Browser deployment option Description Use the APM agent to inject the JavaScript You can use an APM agent to automatically inject the browser monitoring JavaScript snippet for you. This is the easiest way to install the agent for an app that already is being monitored by APM. (APM-monitored apps are listed on your APM Applications index.) Paste the JavaScript snippet into a webpage This allows you to control the exact placement of the JavaScript into your app's webpage(s) by copying and pasting the browser agent's JavaScript snippet. This is useful for: Standalone apps, static sites, and cached pages delivered by CDN APM apps that are not as closely coupled to the browser app as with a standard server-side app (for example, when your client-side app talks to a REST API back end) Enable single-page app (SPA) monitoring Enabling SPA requires a Pro + SPA browser agent subscription, and you may need to re-deploy the browser JavaScript agent. Use the REST API The REST API lets you manage deployment outside the browser UI. This is useful for large organizations deploying multiple apps. Use an APM agent API to manually instrument the JavaScript snippet For apps that are monitored by APM, you can use the APM agent's API to inject the JavaScript manually instead of automatically. Enable an APM-monitored app Use this procedure to automatically deploy the browser agent on an app that is monitored by APM: Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Enable via New Relic APM. In the Choose your instrumentation section, select Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Select your application section, type or use the search window to find an app's name. Click Enable. Important Node.js: To finish enabling the browser agent for a Node.js app, follow the additional procedure to insert the JavaScript header into the beginning of your HTML page's head tag. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. Enable with copy/paste Use this procedure to insert browser's JavaScript snippet for browser monitoring into your app's webpages yourself. This option is useful for monitoring static sites (such as Jekyll) or cached pages delivered by CDN. Tip Near the bottom of the generated JavaScript is your browser license key and application ID. This is useful with the REST API and API Explorer. Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Copy/Paste JavaScript Code. In the Choose your instrumentation section, select the type of agent: Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Name your app section, name your app: If your app is monitored by APM, select Yes, then type or use the search window to find the app's name. If you have a standalone app for Browser (not monitored by APM), select No, then type the app's name. Click Enable. A new section, Instrument the agent, opens on the page with JavaScript code for your project. Copy the code snippet, then paste it inline into your pages as close to the top of the <head> element as possible, but after any position-sensitive <meta> tags (for example, X-UA-Compatible or charset information). For more information on the inline head placement, see JavaScript placement requirements. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. If you use the copy/paste method, but don't finish the setup process, you can still view and copy the generated JavaScript snippet from your app's Browser Application settings page or by using the REST API (v2). Instrument webpages using the APM agent This information applies to apps that are also monitored by APM. New Relic's agents can instrument webpages with the required JavaScript for page load timing. If you use the APM agent to add the JavaScript snippet to your webpages, insert the instrumentation snippet as close to the top as possible. This allows you to take advantage of detailed information about browser's AJAX calls and JavaScript errors. For more information, see the instructions for your APM agent: C SDK Go Java .NET Node.js PHP Python Ruby Troubleshoot Browser agent installation When you enable browser Pro features for session traces, AJAX calls, or JavaScript errors, it may take approximately five minutes before information becomes available. If you have problems with your browser installation or if no data appears after five minutes, refer to the troubleshooting tips, and restart your agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.40524,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install the <em>browser</em> <em>monitoring</em> agent",
        "sections": "Install the <em>browser</em> <em>monitoring</em> agent",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " PHP Python Ruby <em>Troubleshoot</em> <em>Browser</em> agent installation When you enable <em>browser</em> Pro features for session traces, AJAX calls, or JavaScript errors, it may take approximately five minutes before information becomes available. If you have problems with your <em>browser</em> installation or if no data appears after five minutes, refer to the <em>troubleshooting</em> tips, and restart your agent."
      },
      "id": "604429e628ccbcb80b2c60d0"
    }
  ],
  "/docs/browser/index": [
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 75.92869,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em>",
        "body": "If you use <em>Browser</em> to monitor end-user <em>browser</em> activity, you can now see end-user-originating <em>browser</em>-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data"
      },
      "id": "6043fe6f196a6784f0960f53"
    },
    {
      "sections": [
        "Not seeing specific page or endpoint names in Browser data",
        "Problem",
        "Solution"
      ],
      "title": "Not seeing specific page or endpoint names in Browser data",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Troubleshooting"
      ],
      "external_id": "e91e38e0160cd95da45e928f462c70fde1457031",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/troubleshooting/not-seeing-specific-page-or-endpoint-names-browser-data/",
      "published_at": "2021-07-02T00:36:02Z",
      "updated_at": "2021-06-14T22:19:10Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You're looking for performance breakdowns for specific pages or endpoints on the browser monitoring Page views UI page or AJAX UI page. The UI doesn't show the URL group you're looking for, or it only shows / and /*. This behavior also appears in SPA data in BrowserInteraction events and applies to browserInteractionName, targetGroupedUrl, and previousGroupedUrl attributes. Solution Browser monitoring automatically \"learns\" to group your page views when your application is first deployed, and it adds that information to an allow list for URLs. Sometimes this grouping may not match your current page view information. To solve this problem, manage your application's URL segment list settings by editing existing rules or by adding the domains and URL segments that make up your site's URLs. After you add the necessary rules, you should see a useful breakdown of your information in the UI. Here are some useful tips: Adding segments to your allow list Tip Use constant URL segments. Only add the URL segments that remain constant across many page views. Do not add unique segments such as IDs or highly-specific categories, because this can lead to metric grouping issues. Enter exact matches. Enter any URL segments as exact matches, including case. Use existing rules. If a rule already appears for a domain: Go to one.newrelic.com > Browser > (select an app) > Settings > Segment allow lists. Rather than creating a new rule, edit the existing rule, and add the domain to the UI's Allow listed segments field. Group sub-domains. Group similar sub-domains such as foo.domain.com and bar.domain.com under *.domain.com. This grouping must occur just before the top-level domain name. Set up single-page apps. If your site is a single-page application and you only see / under page views, then your grouping is working correctly. New Relic records subsequent requests as AJAX loads, and your AJAX page will contain more detailed information. If it doesn't, then follow the tips in this document. Remove rules when appropriate. If you need to remove a rule, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 51.62215,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Not seeing specific page or endpoint names in <em>Browser</em> data",
        "sections": "Not seeing specific page or endpoint names in <em>Browser</em> data",
        "tags": "<em>Browser</em>",
        "body": "Problem You&#x27;re looking for performance breakdowns for specific pages or endpoints on the <em>browser</em> monitoring Page views UI page or AJAX UI page. The UI doesn&#x27;t show the URL group you&#x27;re looking for, or it only shows &#x2F; and &#x2F;*. This behavior also appears in SPA data in <em>Browser</em>Interaction events"
      },
      "id": "603e8fff28ccbc8813eba7a1"
    },
    {
      "sections": [
        "Install the browser monitoring agent",
        "Tip",
        "Select a deployment option",
        "Important",
        "Enable an APM-monitored app",
        "Enable with copy/paste",
        "Instrument webpages using the APM agent",
        "Troubleshoot Browser agent installation"
      ],
      "title": "Install the browser monitoring agent",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Installation"
      ],
      "external_id": "bc45bbc86cd4d8b81367ad0904907ddc735717f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/installation/install-browser-monitoring-agent/",
      "published_at": "2021-07-02T09:15:35Z",
      "updated_at": "2021-06-14T21:26:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser uses a JavaScript snippet (or \"agent\") to instrument your app's webpages. The JavaScript collects data for browser monitoring. To install the browser agent, you can choose from a number of deployment options. Tip To use Browser and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Select a deployment option No matter which option you use to deploy browser monitoring, the end result is to inject the browser agent's JavaScript snippet into your pages for browser monitoring. The method you select depends on your preferences and business needs. To view the procedure to install and enable the browser agent, click the link for the option you want to use. You can also use the Browser Application settings page to update settings. Important The following configuration options refer only to the browser monitoring agent. These are not the same as the New Relic user roles and editions. Browser deployment option Description Use the APM agent to inject the JavaScript You can use an APM agent to automatically inject the browser monitoring JavaScript snippet for you. This is the easiest way to install the agent for an app that already is being monitored by APM. (APM-monitored apps are listed on your APM Applications index.) Paste the JavaScript snippet into a webpage This allows you to control the exact placement of the JavaScript into your app's webpage(s) by copying and pasting the browser agent's JavaScript snippet. This is useful for: Standalone apps, static sites, and cached pages delivered by CDN APM apps that are not as closely coupled to the browser app as with a standard server-side app (for example, when your client-side app talks to a REST API back end) Enable single-page app (SPA) monitoring Enabling SPA requires a Pro + SPA browser agent subscription, and you may need to re-deploy the browser JavaScript agent. Use the REST API The REST API lets you manage deployment outside the browser UI. This is useful for large organizations deploying multiple apps. Use an APM agent API to manually instrument the JavaScript snippet For apps that are monitored by APM, you can use the APM agent's API to inject the JavaScript manually instead of automatically. Enable an APM-monitored app Use this procedure to automatically deploy the browser agent on an app that is monitored by APM: Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Enable via New Relic APM. In the Choose your instrumentation section, select Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Select your application section, type or use the search window to find an app's name. Click Enable. Important Node.js: To finish enabling the browser agent for a Node.js app, follow the additional procedure to insert the JavaScript header into the beginning of your HTML page's head tag. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. Enable with copy/paste Use this procedure to insert browser's JavaScript snippet for browser monitoring into your app's webpages yourself. This option is useful for monitoring static sites (such as Jekyll) or cached pages delivered by CDN. Tip Near the bottom of the generated JavaScript is your browser license key and application ID. This is useful with the REST API and API Explorer. Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Copy/Paste JavaScript Code. In the Choose your instrumentation section, select the type of agent: Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Name your app section, name your app: If your app is monitored by APM, select Yes, then type or use the search window to find the app's name. If you have a standalone app for Browser (not monitored by APM), select No, then type the app's name. Click Enable. A new section, Instrument the agent, opens on the page with JavaScript code for your project. Copy the code snippet, then paste it inline into your pages as close to the top of the <head> element as possible, but after any position-sensitive <meta> tags (for example, X-UA-Compatible or charset information). For more information on the inline head placement, see JavaScript placement requirements. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. If you use the copy/paste method, but don't finish the setup process, you can still view and copy the generated JavaScript snippet from your app's Browser Application settings page or by using the REST API (v2). Instrument webpages using the APM agent This information applies to apps that are also monitored by APM. New Relic's agents can instrument webpages with the required JavaScript for page load timing. If you use the APM agent to add the JavaScript snippet to your webpages, insert the instrumentation snippet as close to the top as possible. This allows you to take advantage of detailed information about browser's AJAX calls and JavaScript errors. For more information, see the instructions for your APM agent: C SDK Go Java .NET Node.js PHP Python Ruby Troubleshoot Browser agent installation When you enable browser Pro features for session traces, AJAX calls, or JavaScript errors, it may take approximately five minutes before information becomes available. If you have problems with your browser installation or if no data appears after five minutes, refer to the troubleshooting tips, and restart your agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 51.60228,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install the <em>browser</em> monitoring agent",
        "sections": "Install the <em>browser</em> monitoring agent",
        "tags": "<em>Browser</em>",
        "body": "<em>Browser</em> uses a JavaScript snippet (or &quot;agent&quot;) to instrument your app&#x27;s webpages. The JavaScript collects data for <em>browser</em> monitoring. To install the <em>browser</em> agent, you can choose from a number of deployment options. Tip To use <em>Browser</em> and the rest of our observability platform, join the New Relic"
      },
      "id": "604429e628ccbcb80b2c60d0"
    }
  ],
  "/docs/browser/new-relic-browser/additional-standard-features/browser-geography-webpage-performance-location": [
    {
      "sections": [
        "Browsers: Problem patterns by type or platform",
        "Viewing browsers by type",
        "Viewing specific browser details",
        "For more help"
      ],
      "title": "Browsers: Problem patterns by type or platform",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Additional standard features"
      ],
      "external_id": "275b49bb70dc8c016dd8d2cc03f5438f540780fe",
      "image": "https://docs.newrelic.com/static/28f8a0d40fe374ccd766b61d6b89e7a1/c1b63/browsers_overview.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/additional-standard-features/browsers-problem-patterns-type-or-platform/",
      "published_at": "2021-07-02T09:19:49Z",
      "updated_at": "2021-03-11T09:17:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Browsers page in Browser monitoring provides information about your end users' experience with your app based on which browser they use, such as Google Chrome, Mozilla Firefox, Microsoft Internet Explorer, and Apple Safari. This page includes: Top browsers by throughput (pages per minute or ppm) Average page load time by platform type (mobile, tablet, desktop) Drill-down charts also segment the selected browser type by version; for example, Chrome 31, 32, 33, etc. This helps you quickly determine whether problems with page load timing may be related to a specific browser type or platform, or whether the problem is more widespread. Viewing browsers by type To view browser information: Go to one.newrelic.com, click Browser > (select an app) > Browsers. one.newrelic.com > Browser > (select an app) > Browsers: This page provides information about throughput (pages per minute) and average page load time for your end users' browser types. Use any of our standard user interface functions and page functions to drill down into detailed information. Here is a summary of additional options with the Browsers page: If you want to... Do this... View summary browser information for a specific time Mouse over any area on the chart. Hide (or return) data on the chart Select the corresponding color or title on the chart's legend. View detailed information about the browser Select its name on the list or a place on the chart. Close the detail window and return to the Browsers page Select X (Close). Viewing specific browser details The drill-down details include a breakdown by version and the average page load time. one.newrelic.com > Browser > (select an app) > Browsers > (select a browser type): This example shows a specific browser type selected (Firefox). The largest number of users have version 42.0, so by hiding this label (or any others) in the legend, you can easily examine details about other versions. Color-coded segments for Average page load time include: Request queuing (black): Wait time between the web server and the application code. Large numbers indicate a busy application server. Web application (purple): Time spent in the application code. Network (brown): The network latency, or time it takes for a request to make a round trip over the Internet. DOM processing (yellow): In the browser, parsing and interpreting the HTML and retrieving assets. Measured by the browser's DOMContentLoaded event. Page rendering (blue): In the browser, displaying the HTML, running in-line JavaScript, and loading images. Measured by the browser's Load event. Note: For apps that have been deployed using the copy/paste method, Browser includes web app and queue time in Network time. For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 187.38918,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browsers</em>: Problem patterns by type or platform",
        "sections": "<em>Browsers</em>: Problem patterns by type or platform",
        "tags": "<em>Additional</em> <em>standard</em> <em>features</em>",
        "body": ") and average page load time for your end users&#x27; <em>browser</em> types. Use any of our <em>standard</em> user interface functions and page functions to drill down into detailed information. Here is a summary of <em>additional</em> options with the Browsers page: If you want to... Do this... View summary <em>browser</em> information"
      },
      "id": "6043f968e7b9d2bd425799d3"
    },
    {
      "sections": [
        "Page views: Examine page performance",
        "View summary information",
        "Examine timing details for page loads",
        "Examine page view details",
        "Use additional APM-monitored app options"
      ],
      "title": "Page views: Examine page performance",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Additional standard features"
      ],
      "external_id": "33b21f9b95742470a1dec53a56bc8d702a4be066",
      "image": "https://docs.newrelic.com/static/b772b5dac2873a9aa26c4f0848285b19/c1b63/pageview01_overview_1.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/additional-standard-features/page-views-examine-page-performance/",
      "published_at": "2021-07-02T09:18:39Z",
      "updated_at": "2021-03-11T09:16:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Page views page in Browser monitoring provides insight into the performance of your site's pages. Sort options allow you to view details by percentage of page load time, average page load time, or throughput. Detailed information about the top webpages viewed, timing and throughput details, and links to browser traces or session traces also are available as applicable. Browser also offers single-page app (SPA) monitoring. If you have opted in to SPA monitoring, your SPA Page views page will be different. View summary information Browser monitoring lists page views as URLs. This makes it easy to identify specific front-end page views; for example, /browse/plans. In addition: For browser apps that are also monitored by APM, you can view the back-end transactions associated with the page view; for example, ApplicationsController#Show. For URLs that are also monitored by Synthetics, you can use New Relic's comparative charting feature. This provides a direct page load time comparison between real user (Browser) interactions and trends appearing in Synthetics monitors. one.newrelic.com > Browser > (select an app) > Page views: This page provides detailed information about page load time, throughput, top transactions, and traces. To view detailed information about which pages the end users are viewing for your app: Go to one.newrelic.com > Browser > (select an app) > Page views. Select the time period or sort order, or keep the defaults. If available, select the type of view for page load timing information as a chart (default), histogram, or percentile. To view summary information about a specific transaction, mouse over the transaction's name on the list. To compare page load time between real user (Browser) interactions and trends appearing in Synthetic monitors, select a page monitored by Synthetics, then examine additional comparative charting details. Examine timing details for page loads The Browser page load time chart view shows the average page load time broken down into segments. This chart also appears on the Browser Summary page and Browsers detail page. one.newrelic.com > Browser > (select an app) > Page views: The Browser page load time chart shows the average page load time broken down into segments indicating the end users' experience (sometimes referred to as real user monitoring or RUM). The page load timing process shows colored-coded details: Page load timing process Description Request queuing (black) Wait time between the web server and the application code. Large numbers indicate a busy application server. Web application (purple) Time spent in the application code. Network (brown) The network latency, or the time it takes for a request to make a round trip over the Internet. For apps that have been deployed using the copy/paste method, Browser includes web app and queue time in Network time. DOM processing (yellow) In the browser, parsing and interpreting the HTML. Measured by the browser's DOMContent event. Page rendering (blue) In the browser, the time to display the HTML, run the inline JavaScript, and load images. Measured by the browser's Load event. \"Additional\" timing data If you are using the JavaScript API, your \"additional\" timing data appears in this chart. Examine page view details Use any of New Relic's standard user interface functions to drill down into detailed information. In addition, to view details about a specific page view, select its name from the list. To close an individual page view and return to the Page views page, select X (Close). Each page view listed in the list may include links to additional drill-down details: Page view details Comments Page load performance This includes page load timing breakdown data, throughput, session traces, and browser traces (if available). Historical performance This shows response time, Apdex comparisons, and throughput for the last selected time period, yesterday, and last week. AJAX calls Table with links to detailed information about endpoints, as well as sortable columns by endpoint, average response time, throughput, and total calls. APM transactions For Browser apps that are also monitored by APM, this table shows the total call time, average response time, call count, and link to the APM Transactions page. one.newrelic.com > Browser > (select an app) > Page views > (select a transaction): Depending on the app, individual transactions may have links to additional drill-down details, including Page load performance, Historical performance, AJAX calls, and APM transactions. Use additional APM-monitored app options Browser apps that are also monitored by APM may have access to additional functions. To use these functions (if available): From the selected transaction's APM Transactions tab, select an APM transaction from the list. Then select any of these options (from APM): Track as key transaction (create a new key transaction) Key transaction (view existing) Transaction traces > (selected trace) (view)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 187.38905,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use <em>additional</em> APM-<em>monitored</em> app options",
        "tags": "<em>Additional</em> <em>standard</em> <em>features</em>",
        "body": "The Page views page in <em>Browser</em> <em>monitoring</em> provides insight into the performance of your site&#x27;s pages. Sort options allow you to view details by percentage of page load time, average page load time, or throughput. Detailed information about the top webpages viewed, timing and throughput details"
      },
      "id": "6044280d28ccbc697e2c60bb"
    },
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.32051,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "If you use <em>Browser</em> to <em>monitor</em> end-user <em>browser</em> activity, you can now see end-user-originating <em>browser</em>-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data"
      },
      "id": "6043fe6f196a6784f0960f53"
    }
  ],
  "/docs/browser/new-relic-browser/additional-standard-features/browsers-problem-patterns-type-or-platform": [
    {
      "sections": [
        "Page views: Examine page performance",
        "View summary information",
        "Examine timing details for page loads",
        "Examine page view details",
        "Use additional APM-monitored app options"
      ],
      "title": "Page views: Examine page performance",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Additional standard features"
      ],
      "external_id": "33b21f9b95742470a1dec53a56bc8d702a4be066",
      "image": "https://docs.newrelic.com/static/b772b5dac2873a9aa26c4f0848285b19/c1b63/pageview01_overview_1.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/additional-standard-features/page-views-examine-page-performance/",
      "published_at": "2021-07-02T09:18:39Z",
      "updated_at": "2021-03-11T09:16:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Page views page in Browser monitoring provides insight into the performance of your site's pages. Sort options allow you to view details by percentage of page load time, average page load time, or throughput. Detailed information about the top webpages viewed, timing and throughput details, and links to browser traces or session traces also are available as applicable. Browser also offers single-page app (SPA) monitoring. If you have opted in to SPA monitoring, your SPA Page views page will be different. View summary information Browser monitoring lists page views as URLs. This makes it easy to identify specific front-end page views; for example, /browse/plans. In addition: For browser apps that are also monitored by APM, you can view the back-end transactions associated with the page view; for example, ApplicationsController#Show. For URLs that are also monitored by Synthetics, you can use New Relic's comparative charting feature. This provides a direct page load time comparison between real user (Browser) interactions and trends appearing in Synthetics monitors. one.newrelic.com > Browser > (select an app) > Page views: This page provides detailed information about page load time, throughput, top transactions, and traces. To view detailed information about which pages the end users are viewing for your app: Go to one.newrelic.com > Browser > (select an app) > Page views. Select the time period or sort order, or keep the defaults. If available, select the type of view for page load timing information as a chart (default), histogram, or percentile. To view summary information about a specific transaction, mouse over the transaction's name on the list. To compare page load time between real user (Browser) interactions and trends appearing in Synthetic monitors, select a page monitored by Synthetics, then examine additional comparative charting details. Examine timing details for page loads The Browser page load time chart view shows the average page load time broken down into segments. This chart also appears on the Browser Summary page and Browsers detail page. one.newrelic.com > Browser > (select an app) > Page views: The Browser page load time chart shows the average page load time broken down into segments indicating the end users' experience (sometimes referred to as real user monitoring or RUM). The page load timing process shows colored-coded details: Page load timing process Description Request queuing (black) Wait time between the web server and the application code. Large numbers indicate a busy application server. Web application (purple) Time spent in the application code. Network (brown) The network latency, or the time it takes for a request to make a round trip over the Internet. For apps that have been deployed using the copy/paste method, Browser includes web app and queue time in Network time. DOM processing (yellow) In the browser, parsing and interpreting the HTML. Measured by the browser's DOMContent event. Page rendering (blue) In the browser, the time to display the HTML, run the inline JavaScript, and load images. Measured by the browser's Load event. \"Additional\" timing data If you are using the JavaScript API, your \"additional\" timing data appears in this chart. Examine page view details Use any of New Relic's standard user interface functions to drill down into detailed information. In addition, to view details about a specific page view, select its name from the list. To close an individual page view and return to the Page views page, select X (Close). Each page view listed in the list may include links to additional drill-down details: Page view details Comments Page load performance This includes page load timing breakdown data, throughput, session traces, and browser traces (if available). Historical performance This shows response time, Apdex comparisons, and throughput for the last selected time period, yesterday, and last week. AJAX calls Table with links to detailed information about endpoints, as well as sortable columns by endpoint, average response time, throughput, and total calls. APM transactions For Browser apps that are also monitored by APM, this table shows the total call time, average response time, call count, and link to the APM Transactions page. one.newrelic.com > Browser > (select an app) > Page views > (select a transaction): Depending on the app, individual transactions may have links to additional drill-down details, including Page load performance, Historical performance, AJAX calls, and APM transactions. Use additional APM-monitored app options Browser apps that are also monitored by APM may have access to additional functions. To use these functions (if available): From the selected transaction's APM Transactions tab, select an APM transaction from the list. Then select any of these options (from APM): Track as key transaction (create a new key transaction) Key transaction (view existing) Transaction traces > (selected trace) (view)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 187.38905,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use <em>additional</em> APM-<em>monitored</em> app options",
        "tags": "<em>Additional</em> <em>standard</em> <em>features</em>",
        "body": "The Page views page in <em>Browser</em> <em>monitoring</em> provides insight into the performance of your site&#x27;s pages. Sort options allow you to view details by percentage of page load time, average page load time, or throughput. Detailed information about the top webpages viewed, timing and throughput details"
      },
      "id": "6044280d28ccbc697e2c60bb"
    },
    {
      "sections": [
        "Browser Geography: Webpage performance by location",
        "Contents",
        "View performance data by region",
        "Important",
        "Use page functions",
        "View drill-down details",
        "For more help"
      ],
      "title": "Browser Geography: Webpage performance by location",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Additional standard features"
      ],
      "external_id": "7b26e484a4645be8c580650fd7d71a159114bf50",
      "image": "https://docs.newrelic.com/static/793341e63f8e5b444d7cc98a1f5a7d90/c1b63/geo_overview.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/additional-standard-features/browser-geography-webpage-performance-location/",
      "published_at": "2021-07-02T09:18:39Z",
      "updated_at": "2021-03-11T07:31:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's Geography page provides a world view with color-coded Apdex scores and other performance information about your end users' experience. You can select specific geographic regions, such as countries or states, and then you can drill down to detailed information about page load performance and historical performance. Contents View performance data by region Important Firewalls may have an impact on the geographical data collected about your end users. To view or sort the performance information by location: one.newrelic.com > Browser > (select an app) > Geo: This page provides a world view and drill-down details of color-coded performance information for geographic locations. Go to one.newrelic.com > Browser > (select an app) > Geo > Global (for a world view). OR Go to one.newrelic.com > Browser > (select an app) > Geo > (select a location) (for a specific location you identified in the Browser application settings). To drill down to a specific area, select a location from the list, or select any area on the geographical map. To view additional details about the selected location, select the Page load performance or Historical performance links. To return to the main Geography page, select X (Close). one.newrelic.com > B * *rowser > (select an app) > Geo > (select a location): If you selected specific locations from Settings > Application settings * * , the Geography page includes tabs to view their performance data directly. Use page functions Use any of our standard user interface functions and page functions to drill down into detailed information. Here is a summary of additional options with the Geography page: If you want to... Do this... Change how the performance data appears Select your choice from the Sort by menu. Adjust the amount of information that appears Select or clear the Hide < % throughput checkbox ( < 1% for global view, < 2% for selected locations). View a map of a specific location Do any of these as applicable: Select the location's name from the Geo > Global list. Select its physical location on the map. If you have pre-selected the location from Application settings, select its tab. View summary performance information about a specific location Mouse over any colored area. View drill-down details After you select a specific location, the Page load performance page shows: Average page load time in seconds Number of page views and active sessions as pages per minute (ppm) Recent browser traces if applicable one.newrelic.com > Browser > (select an app) > Geo > (select a location): After you select a specific location, you can view specific details about Page load performance and Historical performance. In addition, the Historical performance page shows comparison data for the selected time period, yesterday, and last week for the selected location. This includes: Response time Apdex Throughput in pages per minute (ppm) For more help Additional documentation resources include the Page views page (details about end users' overall experience with your site).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 187.38002,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> Geography: Webpage performance by location",
        "sections": "<em>Browser</em> Geography: Webpage performance by location",
        "tags": "<em>Additional</em> <em>standard</em> <em>features</em>",
        "body": "<em>Browser</em> <em>monitoring</em>&#x27;s Geography page provides a world view with color-coded Apdex scores and other performance information about your end users&#x27; experience. You can select specific geographic regions, such as countries or states, and then you can drill down to detailed information about page load"
      },
      "id": "604429e7196a67193d960f75"
    },
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.32051,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "If you use <em>Browser</em> to <em>monitor</em> end-user <em>browser</em> activity, you can now see end-user-originating <em>browser</em>-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data"
      },
      "id": "6043fe6f196a6784f0960f53"
    }
  ],
  "/docs/browser/new-relic-browser/additional-standard-features/page-views-examine-page-performance": [
    {
      "sections": [
        "Browsers: Problem patterns by type or platform",
        "Viewing browsers by type",
        "Viewing specific browser details",
        "For more help"
      ],
      "title": "Browsers: Problem patterns by type or platform",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Additional standard features"
      ],
      "external_id": "275b49bb70dc8c016dd8d2cc03f5438f540780fe",
      "image": "https://docs.newrelic.com/static/28f8a0d40fe374ccd766b61d6b89e7a1/c1b63/browsers_overview.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/additional-standard-features/browsers-problem-patterns-type-or-platform/",
      "published_at": "2021-07-02T09:19:49Z",
      "updated_at": "2021-03-11T09:17:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Browsers page in Browser monitoring provides information about your end users' experience with your app based on which browser they use, such as Google Chrome, Mozilla Firefox, Microsoft Internet Explorer, and Apple Safari. This page includes: Top browsers by throughput (pages per minute or ppm) Average page load time by platform type (mobile, tablet, desktop) Drill-down charts also segment the selected browser type by version; for example, Chrome 31, 32, 33, etc. This helps you quickly determine whether problems with page load timing may be related to a specific browser type or platform, or whether the problem is more widespread. Viewing browsers by type To view browser information: Go to one.newrelic.com, click Browser > (select an app) > Browsers. one.newrelic.com > Browser > (select an app) > Browsers: This page provides information about throughput (pages per minute) and average page load time for your end users' browser types. Use any of our standard user interface functions and page functions to drill down into detailed information. Here is a summary of additional options with the Browsers page: If you want to... Do this... View summary browser information for a specific time Mouse over any area on the chart. Hide (or return) data on the chart Select the corresponding color or title on the chart's legend. View detailed information about the browser Select its name on the list or a place on the chart. Close the detail window and return to the Browsers page Select X (Close). Viewing specific browser details The drill-down details include a breakdown by version and the average page load time. one.newrelic.com > Browser > (select an app) > Browsers > (select a browser type): This example shows a specific browser type selected (Firefox). The largest number of users have version 42.0, so by hiding this label (or any others) in the legend, you can easily examine details about other versions. Color-coded segments for Average page load time include: Request queuing (black): Wait time between the web server and the application code. Large numbers indicate a busy application server. Web application (purple): Time spent in the application code. Network (brown): The network latency, or time it takes for a request to make a round trip over the Internet. DOM processing (yellow): In the browser, parsing and interpreting the HTML and retrieving assets. Measured by the browser's DOMContentLoaded event. Page rendering (blue): In the browser, displaying the HTML, running in-line JavaScript, and loading images. Measured by the browser's Load event. Note: For apps that have been deployed using the copy/paste method, Browser includes web app and queue time in Network time. For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 187.38918,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browsers</em>: Problem patterns by type or platform",
        "sections": "<em>Browsers</em>: Problem patterns by type or platform",
        "tags": "<em>Additional</em> <em>standard</em> <em>features</em>",
        "body": ") and average page load time for your end users&#x27; <em>browser</em> types. Use any of our <em>standard</em> user interface functions and page functions to drill down into detailed information. Here is a summary of <em>additional</em> options with the Browsers page: If you want to... Do this... View summary <em>browser</em> information"
      },
      "id": "6043f968e7b9d2bd425799d3"
    },
    {
      "sections": [
        "Browser Geography: Webpage performance by location",
        "Contents",
        "View performance data by region",
        "Important",
        "Use page functions",
        "View drill-down details",
        "For more help"
      ],
      "title": "Browser Geography: Webpage performance by location",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Additional standard features"
      ],
      "external_id": "7b26e484a4645be8c580650fd7d71a159114bf50",
      "image": "https://docs.newrelic.com/static/793341e63f8e5b444d7cc98a1f5a7d90/c1b63/geo_overview.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/additional-standard-features/browser-geography-webpage-performance-location/",
      "published_at": "2021-07-02T09:18:39Z",
      "updated_at": "2021-03-11T07:31:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's Geography page provides a world view with color-coded Apdex scores and other performance information about your end users' experience. You can select specific geographic regions, such as countries or states, and then you can drill down to detailed information about page load performance and historical performance. Contents View performance data by region Important Firewalls may have an impact on the geographical data collected about your end users. To view or sort the performance information by location: one.newrelic.com > Browser > (select an app) > Geo: This page provides a world view and drill-down details of color-coded performance information for geographic locations. Go to one.newrelic.com > Browser > (select an app) > Geo > Global (for a world view). OR Go to one.newrelic.com > Browser > (select an app) > Geo > (select a location) (for a specific location you identified in the Browser application settings). To drill down to a specific area, select a location from the list, or select any area on the geographical map. To view additional details about the selected location, select the Page load performance or Historical performance links. To return to the main Geography page, select X (Close). one.newrelic.com > B * *rowser > (select an app) > Geo > (select a location): If you selected specific locations from Settings > Application settings * * , the Geography page includes tabs to view their performance data directly. Use page functions Use any of our standard user interface functions and page functions to drill down into detailed information. Here is a summary of additional options with the Geography page: If you want to... Do this... Change how the performance data appears Select your choice from the Sort by menu. Adjust the amount of information that appears Select or clear the Hide < % throughput checkbox ( < 1% for global view, < 2% for selected locations). View a map of a specific location Do any of these as applicable: Select the location's name from the Geo > Global list. Select its physical location on the map. If you have pre-selected the location from Application settings, select its tab. View summary performance information about a specific location Mouse over any colored area. View drill-down details After you select a specific location, the Page load performance page shows: Average page load time in seconds Number of page views and active sessions as pages per minute (ppm) Recent browser traces if applicable one.newrelic.com > Browser > (select an app) > Geo > (select a location): After you select a specific location, you can view specific details about Page load performance and Historical performance. In addition, the Historical performance page shows comparison data for the selected time period, yesterday, and last week for the selected location. This includes: Response time Apdex Throughput in pages per minute (ppm) For more help Additional documentation resources include the Page views page (details about end users' overall experience with your site).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 187.38002,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> Geography: Webpage performance by location",
        "sections": "<em>Browser</em> Geography: Webpage performance by location",
        "tags": "<em>Additional</em> <em>standard</em> <em>features</em>",
        "body": "<em>Browser</em> <em>monitoring</em>&#x27;s Geography page provides a world view with color-coded Apdex scores and other performance information about your end users&#x27; experience. You can select specific geographic regions, such as countries or states, and then you can drill down to detailed information about page load"
      },
      "id": "604429e7196a67193d960f75"
    },
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.32042,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "If you use <em>Browser</em> to <em>monitor</em> end-user <em>browser</em> activity, you can now see end-user-originating <em>browser</em>-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data"
      },
      "id": "6043fe6f196a6784f0960f53"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/actiontext-browser-spa-api": [
    {
      "sections": [
        "addPageAction (Browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record link clicks (JavaScript)",
        "Record link clicks (jQuery)",
        "Capture form input"
      ],
      "title": "addPageAction (Browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "051774181e5be11026841b52aeb04a693ffad434",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/add-page-action/",
      "published_at": "2021-07-02T08:58:02Z",
      "updated_at": "2021-06-14T23:24:03Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addPageAction(string $name[, JSON object $attributes]) Copy Reports a Browser PageAction event to New Relic One along with a name and optional attributes. Requirements Agent version nr-593 or higher. Description This API call sends a Browser PageAction event with your user-defined name and optional attributes to dashboards, along with several default attributes. This is useful to track any event that is not already tracked automatically by the Browser agent, such as clicking a Subscribe button or accessing a tutorial. PageAction events are sent to New Relic One every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that harvest cycle. Parameters Parameter Description $name string Required. Name or category of the action. Reports to New Relic One as the actionName attribute. Avoid using reserved NRQL words when you name the attribute or value. $attributes JSON object Optional. JSON object with one or more key/value pairs. For example: {key:\"value\"}. The key will report to New Relic One as its own PageAction attribute with the specified values. Avoid using reserved NRQL words when you name the attribute/value. Examples Record link clicks (JavaScript) This example records a PageAction event whenever a user selects the Try Me link. The event is recorded with an actionName of clickedTryMe: < a href=\"/demo\" id=\"try-me\" >Try Me!< /a> <script> document.getElementById('try-me').addEventListener('click',function (e) { newrelic.addPageAction('clickedTryMe'); }) </script> Copy You can then query the number of times the Try Me button was clicked with the following NRQL query: SELECT count(*) FROM PageAction WHERE actionName='clickedTryMe' SINCE 1 hour ago Copy Record link clicks (jQuery) This example sends a PageAction event when a user clicks on an element with the class copy-text. The actionName is copy-text-button and the value is reported as another attribute called Result that corresponds to methods named success and error that handle the outcome. $('.copy-text').click(function (){ var clipboard = new Clipboard ('.copy-text'); clipboard.on('success', function(event) { // Do stuff // Report data to New Relic One if (typeof newrelic == 'object') { newrelic.addPageAction('copy-text-button', {result: 'success'}); } }); clipboard.on('error', function(event) { // Do stuff // Report data to New Relic One if (typeof newrelic == 'object') { newrelic.addPageAction('copy-text-button', {result: 'error'}); } }); }); Copy Then in the query builder, you can create a pie chart to see the breakdown of how many button clicks resulted in success versus error over the past 30 days: SELECT count(*) AS 'Clicks' FROM PageAction WHERE actionName = 'copy-text-button' FACET result SINCE 30 days ago Copy Or you can create a query to see what pages have the most copy button clicks in the last 30 days: SELECT count(*) AS 'Clicks' FROM PageAction WHERE actionName = 'copy-text-button' FACET currentUrl SINCE 30 days ago Copy Capture form input This example captures user input (email addresses) from a form called Signup. The event is recorded with an actionName of userSignup: <form action=\"/signup\" id=\"myform\"> <input id=\"email\" name=\"email\"> <input type=\"submit\" value=\"Signup\"> </form> <script type=\"text/javascript\"> document.getElementById('myform').addEventListener('submit', function (e) { var email = e.target.elements['email'].value; newrelic.addPageAction('userSignup', {email: email}); }) </script> Copy You can then see the emails that you gathered with the following NRQL query: SELECT uniques(email) FROM PageAction WHERE actionName='userSignup' SINCE 1 hour ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 267.33633,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addPageAction (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "sections": "addPageAction (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.addPageAction(string $name[, JSON object $attributes]) Copy Reports a <em>Browser</em> PageAction event to New Relic One along with a name and optional attributes. Requirements <em>Agent</em> version nr-593 or higher. Description This <em>API</em> call sends a <em>Browser</em> PageAction event with your user-defined"
      },
      "id": "60440d4628ccbc14742c60cb"
    },
    {
      "sections": [
        "save (Browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Return values",
        "Examples"
      ],
      "title": "save (Browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "033ab644ae53188525caa08a438d834b01005189",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/save-browser-spa-api/",
      "published_at": "2021-07-02T09:05:00Z",
      "updated_at": "2021-04-22T09:50:52Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction().save() Copy Ensures a SPA browser interaction will be saved when it ends. Requirements Agent version nr-963 or higher. Description This SPA method ensures a browser interaction will be saved when it ends. Normally an interaction is only saved and sent to New Relic if it is an initial page load or if it results in a URL or hash change. You must call this method to override this behavior and guarantee the interaction will be recorded. Return values This method returns the same API object created by interaction(), which is associated with a BrowserInteraction event. Examples /* window.addEventListener('scroll', () => { if (atBottomOfPage()) { newrelic.interaction() // Start monitoring this interaction. .setName('loadNextPage') // Set name of interaction. .save(); // Ensure that this interaction will be saved as a BrowserInteraction event when it ends. loadNextPage() // Start loading the next page. } }) */ Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 216.62386,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "save (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "save (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction().save() Copy Ensures a <em>SPA</em> <em>browser</em> interaction will be saved when it ends. Requirements <em>Agent</em> version nr-963 or higher. Description This <em>SPA</em> method ensures a <em>browser</em> interaction will be saved when it ends. Normally an interaction is only saved and sent to New Relic"
      },
      "id": "603eb491e7b9d257f92a07f4"
    },
    {
      "sections": [
        "interaction (Browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Return values",
        "Examples"
      ],
      "title": "interaction (Browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "6656dfeb99f4d3559511a001f951c3c3865129c5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/interaction-browser-spa-api/",
      "published_at": "2021-07-02T09:03:53Z",
      "updated_at": "2021-03-16T08:25:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction() Copy Returns a new API object that is bound to the current SPA interaction. Requirements Agent version nr-963 or higher. Description The SPA monitoring interaction() call returns a new API object that is bound to the current interaction. New interaction: If the API calls it when New Relic is not currently monitoring an interaction, a new interaction is created. New object: If the API calls it again within the same interaction, a new object referencing the current interaction is created. Parameters The parameters depend on the specific SPA interaction API call. Return values This method returns an API object that is bound to a specific BrowserInteraction event. Each time this method is called for the same BrowserInteraction, a new object is created, but it still references the same interaction. Examples SPA API methods can be used on newrelic.interaction(). The methods can also be used on a handle you assign with a variable. For example: myInteraction = newrelic.interaction() myInteraction.save() Copy The named handle can be saved and used from outside an interaction, but methods will have no effect after the interaction has ended.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 208.48874,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "interaction (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "interaction (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction() Copy Returns a new <em>API</em> object that is bound to the current <em>SPA</em> interaction. Requirements <em>Agent</em> version nr-963 or higher. Description The <em>SPA</em> <em>monitoring</em> interaction() call returns a new <em>API</em> object that is bound to the current interaction. New interaction: If the <em>API</em>"
      },
      "id": "603eb45728ccbc8e2feba779"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/add-page-action": [
    {
      "sections": [
        "save (Browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Return values",
        "Examples"
      ],
      "title": "save (Browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "033ab644ae53188525caa08a438d834b01005189",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/save-browser-spa-api/",
      "published_at": "2021-07-02T09:05:00Z",
      "updated_at": "2021-04-22T09:50:52Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction().save() Copy Ensures a SPA browser interaction will be saved when it ends. Requirements Agent version nr-963 or higher. Description This SPA method ensures a browser interaction will be saved when it ends. Normally an interaction is only saved and sent to New Relic if it is an initial page load or if it results in a URL or hash change. You must call this method to override this behavior and guarantee the interaction will be recorded. Return values This method returns the same API object created by interaction(), which is associated with a BrowserInteraction event. Examples /* window.addEventListener('scroll', () => { if (atBottomOfPage()) { newrelic.interaction() // Start monitoring this interaction. .setName('loadNextPage') // Set name of interaction. .save(); // Ensure that this interaction will be saved as a BrowserInteraction event when it ends. loadNextPage() // Start loading the next page. } }) */ Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 216.62386,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "save (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "save (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction().save() Copy Ensures a <em>SPA</em> <em>browser</em> interaction will be saved when it ends. Requirements <em>Agent</em> version nr-963 or higher. Description This <em>SPA</em> method ensures a <em>browser</em> interaction will be saved when it ends. Normally an interaction is only saved and sent to New Relic"
      },
      "id": "603eb491e7b9d257f92a07f4"
    },
    {
      "sections": [
        "interaction (Browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Return values",
        "Examples"
      ],
      "title": "interaction (Browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "6656dfeb99f4d3559511a001f951c3c3865129c5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/interaction-browser-spa-api/",
      "published_at": "2021-07-02T09:03:53Z",
      "updated_at": "2021-03-16T08:25:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction() Copy Returns a new API object that is bound to the current SPA interaction. Requirements Agent version nr-963 or higher. Description The SPA monitoring interaction() call returns a new API object that is bound to the current interaction. New interaction: If the API calls it when New Relic is not currently monitoring an interaction, a new interaction is created. New object: If the API calls it again within the same interaction, a new object referencing the current interaction is created. Parameters The parameters depend on the specific SPA interaction API call. Return values This method returns an API object that is bound to a specific BrowserInteraction event. Each time this method is called for the same BrowserInteraction, a new object is created, but it still references the same interaction. Examples SPA API methods can be used on newrelic.interaction(). The methods can also be used on a handle you assign with a variable. For example: myInteraction = newrelic.interaction() myInteraction.save() Copy The named handle can be saved and used from outside an interaction, but methods will have no effect after the interaction has ended.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 208.48874,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "interaction (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "interaction (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction() Copy Returns a new <em>API</em> object that is bound to the current <em>SPA</em> interaction. Requirements <em>Agent</em> version nr-963 or higher. Description The <em>SPA</em> <em>monitoring</em> interaction() call returns a new <em>API</em> object that is bound to the current interaction. New interaction: If the <em>API</em>"
      },
      "id": "603eb45728ccbc8e2feba779"
    },
    {
      "sections": [
        "setCustomAttribute (Browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Get JavaScript/jQuery for HTML elements"
      ],
      "title": "setCustomAttribute (Browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "45236cf5e08fcdc6cc62c2e1807a0ae25b3b1045",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setcustomattribute-browser-agent-api/",
      "published_at": "2021-07-02T09:06:17Z",
      "updated_at": "2021-03-16T08:25:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setCustomAttribute(string $name, string OR number $value) Copy Adds a user-defined attribute name and value to subsequent events on the page. Requirements Agent version nr-593 or higher. Description The Browser API call adds a user-defined attribute name and value to subsequent events on the page. Make this call before the window load event fires (when that data is transmitted) in order for the attributes to be included in the PageView event. Once an attribute is set, New Relic One records it with all PageAction events until the page is reloaded or the attribute is manually unset. If you are using SPA monitoring with a compatible agent version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the SPA API will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page. To view or log errors for a custom attribute via API, use the Browser API's noticeError call. Parameters Parameter Description $name string Required. Name of the attribute. Appears as column in the PageView event. It will also appear as a column in the PageAction event if you are using it. Avoid using reserved NRQL words when you name the attribute/value. $value string OR integer Required. Value of the attribute. Appears as the value in the named attribute column in the PageView event. It will appear as a column in the PageAction event if you are using it. Custom attribute values cannot be complex objects, only simple types such as Strings and Integers. Avoid using reserved NRQL words when you name the attribute/value. Examples Get JavaScript/jQuery for HTML elements This example uses JavaScript/jQuery to get the values of the following HTML elements on the Drupal-generated pages for New Relic's Docs site: <link rel=\"shortlink\" href=\"/node/1111\" /> <h1>Using NRQL</h1> New Relic reports them as custom attributes. This is useful to query PageView and PageAction events in New Relic One. var node_id = ''; node_id= jQuery(\"link[rel='shortlink']\").attr(\"href\"); var node_title = ''; node_title= jQuery('h1').text(); if (typeof newrelic == 'object') { newrelic.setCustomAttribute('nodeId', node_id); newrelic.setCustomAttribute('title', node_title); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 208.48874,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setCustomAttribute (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setCustomAttribute (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " unset. If you are using <em>SPA</em> <em>monitoring</em> with a compatible <em>agent</em> version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the <em>SPA</em> <em>API</em> will take precedence over these attributes. Errors for custom attributes will be included in events"
      },
      "id": "6043fe01e7b9d28aff5799e0"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/add-release": [
    {
      "sections": [
        "addPageAction (Browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record link clicks (JavaScript)",
        "Record link clicks (jQuery)",
        "Capture form input"
      ],
      "title": "addPageAction (Browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "051774181e5be11026841b52aeb04a693ffad434",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/add-page-action/",
      "published_at": "2021-07-02T08:58:02Z",
      "updated_at": "2021-06-14T23:24:03Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addPageAction(string $name[, JSON object $attributes]) Copy Reports a Browser PageAction event to New Relic One along with a name and optional attributes. Requirements Agent version nr-593 or higher. Description This API call sends a Browser PageAction event with your user-defined name and optional attributes to dashboards, along with several default attributes. This is useful to track any event that is not already tracked automatically by the Browser agent, such as clicking a Subscribe button or accessing a tutorial. PageAction events are sent to New Relic One every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that harvest cycle. Parameters Parameter Description $name string Required. Name or category of the action. Reports to New Relic One as the actionName attribute. Avoid using reserved NRQL words when you name the attribute or value. $attributes JSON object Optional. JSON object with one or more key/value pairs. For example: {key:\"value\"}. The key will report to New Relic One as its own PageAction attribute with the specified values. Avoid using reserved NRQL words when you name the attribute/value. Examples Record link clicks (JavaScript) This example records a PageAction event whenever a user selects the Try Me link. The event is recorded with an actionName of clickedTryMe: < a href=\"/demo\" id=\"try-me\" >Try Me!< /a> <script> document.getElementById('try-me').addEventListener('click',function (e) { newrelic.addPageAction('clickedTryMe'); }) </script> Copy You can then query the number of times the Try Me button was clicked with the following NRQL query: SELECT count(*) FROM PageAction WHERE actionName='clickedTryMe' SINCE 1 hour ago Copy Record link clicks (jQuery) This example sends a PageAction event when a user clicks on an element with the class copy-text. The actionName is copy-text-button and the value is reported as another attribute called Result that corresponds to methods named success and error that handle the outcome. $('.copy-text').click(function (){ var clipboard = new Clipboard ('.copy-text'); clipboard.on('success', function(event) { // Do stuff // Report data to New Relic One if (typeof newrelic == 'object') { newrelic.addPageAction('copy-text-button', {result: 'success'}); } }); clipboard.on('error', function(event) { // Do stuff // Report data to New Relic One if (typeof newrelic == 'object') { newrelic.addPageAction('copy-text-button', {result: 'error'}); } }); }); Copy Then in the query builder, you can create a pie chart to see the breakdown of how many button clicks resulted in success versus error over the past 30 days: SELECT count(*) AS 'Clicks' FROM PageAction WHERE actionName = 'copy-text-button' FACET result SINCE 30 days ago Copy Or you can create a query to see what pages have the most copy button clicks in the last 30 days: SELECT count(*) AS 'Clicks' FROM PageAction WHERE actionName = 'copy-text-button' FACET currentUrl SINCE 30 days ago Copy Capture form input This example captures user input (email addresses) from a form called Signup. The event is recorded with an actionName of userSignup: <form action=\"/signup\" id=\"myform\"> <input id=\"email\" name=\"email\"> <input type=\"submit\" value=\"Signup\"> </form> <script type=\"text/javascript\"> document.getElementById('myform').addEventListener('submit', function (e) { var email = e.target.elements['email'].value; newrelic.addPageAction('userSignup', {email: email}); }) </script> Copy You can then see the emails that you gathered with the following NRQL query: SELECT uniques(email) FROM PageAction WHERE actionName='userSignup' SINCE 1 hour ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 267.3363,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addPageAction (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "sections": "addPageAction (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.addPageAction(string $name[, JSON object $attributes]) Copy Reports a <em>Browser</em> PageAction event to New Relic One along with a name and optional attributes. Requirements <em>Agent</em> version nr-593 or higher. Description This <em>API</em> call sends a <em>Browser</em> PageAction event with your user-defined"
      },
      "id": "60440d4628ccbc14742c60cb"
    },
    {
      "sections": [
        "save (Browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Return values",
        "Examples"
      ],
      "title": "save (Browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "033ab644ae53188525caa08a438d834b01005189",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/save-browser-spa-api/",
      "published_at": "2021-07-02T09:05:00Z",
      "updated_at": "2021-04-22T09:50:52Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction().save() Copy Ensures a SPA browser interaction will be saved when it ends. Requirements Agent version nr-963 or higher. Description This SPA method ensures a browser interaction will be saved when it ends. Normally an interaction is only saved and sent to New Relic if it is an initial page load or if it results in a URL or hash change. You must call this method to override this behavior and guarantee the interaction will be recorded. Return values This method returns the same API object created by interaction(), which is associated with a BrowserInteraction event. Examples /* window.addEventListener('scroll', () => { if (atBottomOfPage()) { newrelic.interaction() // Start monitoring this interaction. .setName('loadNextPage') // Set name of interaction. .save(); // Ensure that this interaction will be saved as a BrowserInteraction event when it ends. loadNextPage() // Start loading the next page. } }) */ Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 216.62386,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "save (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "save (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction().save() Copy Ensures a <em>SPA</em> <em>browser</em> interaction will be saved when it ends. Requirements <em>Agent</em> version nr-963 or higher. Description This <em>SPA</em> method ensures a <em>browser</em> interaction will be saved when it ends. Normally an interaction is only saved and sent to New Relic"
      },
      "id": "603eb491e7b9d257f92a07f4"
    },
    {
      "sections": [
        "interaction (Browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Return values",
        "Examples"
      ],
      "title": "interaction (Browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "6656dfeb99f4d3559511a001f951c3c3865129c5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/interaction-browser-spa-api/",
      "published_at": "2021-07-02T09:03:53Z",
      "updated_at": "2021-03-16T08:25:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction() Copy Returns a new API object that is bound to the current SPA interaction. Requirements Agent version nr-963 or higher. Description The SPA monitoring interaction() call returns a new API object that is bound to the current interaction. New interaction: If the API calls it when New Relic is not currently monitoring an interaction, a new interaction is created. New object: If the API calls it again within the same interaction, a new object referencing the current interaction is created. Parameters The parameters depend on the specific SPA interaction API call. Return values This method returns an API object that is bound to a specific BrowserInteraction event. Each time this method is called for the same BrowserInteraction, a new object is created, but it still references the same interaction. Examples SPA API methods can be used on newrelic.interaction(). The methods can also be used on a handle you assign with a variable. For example: myInteraction = newrelic.interaction() myInteraction.save() Copy The named handle can be saved and used from outside an interaction, but methods will have no effect after the interaction has ended.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 208.48874,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "interaction (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "interaction (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction() Copy Returns a new <em>API</em> object that is bound to the current <em>SPA</em> interaction. Requirements <em>Agent</em> version nr-963 or higher. Description The <em>SPA</em> <em>monitoring</em> interaction() call returns a new <em>API</em> object that is bound to the current interaction. New interaction: If the <em>API</em>"
      },
      "id": "603eb45728ccbc8e2feba779"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/addtotrace-browser-agent-api": [
    {
      "sections": [
        "addPageAction (Browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record link clicks (JavaScript)",
        "Record link clicks (jQuery)",
        "Capture form input"
      ],
      "title": "addPageAction (Browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "051774181e5be11026841b52aeb04a693ffad434",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/add-page-action/",
      "published_at": "2021-07-02T08:58:02Z",
      "updated_at": "2021-06-14T23:24:03Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addPageAction(string $name[, JSON object $attributes]) Copy Reports a Browser PageAction event to New Relic One along with a name and optional attributes. Requirements Agent version nr-593 or higher. Description This API call sends a Browser PageAction event with your user-defined name and optional attributes to dashboards, along with several default attributes. This is useful to track any event that is not already tracked automatically by the Browser agent, such as clicking a Subscribe button or accessing a tutorial. PageAction events are sent to New Relic One every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that harvest cycle. Parameters Parameter Description $name string Required. Name or category of the action. Reports to New Relic One as the actionName attribute. Avoid using reserved NRQL words when you name the attribute or value. $attributes JSON object Optional. JSON object with one or more key/value pairs. For example: {key:\"value\"}. The key will report to New Relic One as its own PageAction attribute with the specified values. Avoid using reserved NRQL words when you name the attribute/value. Examples Record link clicks (JavaScript) This example records a PageAction event whenever a user selects the Try Me link. The event is recorded with an actionName of clickedTryMe: < a href=\"/demo\" id=\"try-me\" >Try Me!< /a> <script> document.getElementById('try-me').addEventListener('click',function (e) { newrelic.addPageAction('clickedTryMe'); }) </script> Copy You can then query the number of times the Try Me button was clicked with the following NRQL query: SELECT count(*) FROM PageAction WHERE actionName='clickedTryMe' SINCE 1 hour ago Copy Record link clicks (jQuery) This example sends a PageAction event when a user clicks on an element with the class copy-text. The actionName is copy-text-button and the value is reported as another attribute called Result that corresponds to methods named success and error that handle the outcome. $('.copy-text').click(function (){ var clipboard = new Clipboard ('.copy-text'); clipboard.on('success', function(event) { // Do stuff // Report data to New Relic One if (typeof newrelic == 'object') { newrelic.addPageAction('copy-text-button', {result: 'success'}); } }); clipboard.on('error', function(event) { // Do stuff // Report data to New Relic One if (typeof newrelic == 'object') { newrelic.addPageAction('copy-text-button', {result: 'error'}); } }); }); Copy Then in the query builder, you can create a pie chart to see the breakdown of how many button clicks resulted in success versus error over the past 30 days: SELECT count(*) AS 'Clicks' FROM PageAction WHERE actionName = 'copy-text-button' FACET result SINCE 30 days ago Copy Or you can create a query to see what pages have the most copy button clicks in the last 30 days: SELECT count(*) AS 'Clicks' FROM PageAction WHERE actionName = 'copy-text-button' FACET currentUrl SINCE 30 days ago Copy Capture form input This example captures user input (email addresses) from a form called Signup. The event is recorded with an actionName of userSignup: <form action=\"/signup\" id=\"myform\"> <input id=\"email\" name=\"email\"> <input type=\"submit\" value=\"Signup\"> </form> <script type=\"text/javascript\"> document.getElementById('myform').addEventListener('submit', function (e) { var email = e.target.elements['email'].value; newrelic.addPageAction('userSignup', {email: email}); }) </script> Copy You can then see the emails that you gathered with the following NRQL query: SELECT uniques(email) FROM PageAction WHERE actionName='userSignup' SINCE 1 hour ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 267.33627,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addPageAction (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "sections": "addPageAction (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.addPageAction(string $name[, JSON object $attributes]) Copy Reports a <em>Browser</em> PageAction event to New Relic One along with a name and optional attributes. Requirements <em>Agent</em> version nr-593 or higher. Description This <em>API</em> call sends a <em>Browser</em> PageAction event with your user-defined"
      },
      "id": "60440d4628ccbc14742c60cb"
    },
    {
      "sections": [
        "save (Browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Return values",
        "Examples"
      ],
      "title": "save (Browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "033ab644ae53188525caa08a438d834b01005189",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/save-browser-spa-api/",
      "published_at": "2021-07-02T09:05:00Z",
      "updated_at": "2021-04-22T09:50:52Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction().save() Copy Ensures a SPA browser interaction will be saved when it ends. Requirements Agent version nr-963 or higher. Description This SPA method ensures a browser interaction will be saved when it ends. Normally an interaction is only saved and sent to New Relic if it is an initial page load or if it results in a URL or hash change. You must call this method to override this behavior and guarantee the interaction will be recorded. Return values This method returns the same API object created by interaction(), which is associated with a BrowserInteraction event. Examples /* window.addEventListener('scroll', () => { if (atBottomOfPage()) { newrelic.interaction() // Start monitoring this interaction. .setName('loadNextPage') // Set name of interaction. .save(); // Ensure that this interaction will be saved as a BrowserInteraction event when it ends. loadNextPage() // Start loading the next page. } }) */ Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 216.62386,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "save (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "save (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction().save() Copy Ensures a <em>SPA</em> <em>browser</em> interaction will be saved when it ends. Requirements <em>Agent</em> version nr-963 or higher. Description This <em>SPA</em> method ensures a <em>browser</em> interaction will be saved when it ends. Normally an interaction is only saved and sent to New Relic"
      },
      "id": "603eb491e7b9d257f92a07f4"
    },
    {
      "sections": [
        "interaction (Browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Return values",
        "Examples"
      ],
      "title": "interaction (Browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "6656dfeb99f4d3559511a001f951c3c3865129c5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/interaction-browser-spa-api/",
      "published_at": "2021-07-02T09:03:53Z",
      "updated_at": "2021-03-16T08:25:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction() Copy Returns a new API object that is bound to the current SPA interaction. Requirements Agent version nr-963 or higher. Description The SPA monitoring interaction() call returns a new API object that is bound to the current interaction. New interaction: If the API calls it when New Relic is not currently monitoring an interaction, a new interaction is created. New object: If the API calls it again within the same interaction, a new object referencing the current interaction is created. Parameters The parameters depend on the specific SPA interaction API call. Return values This method returns an API object that is bound to a specific BrowserInteraction event. Each time this method is called for the same BrowserInteraction, a new object is created, but it still references the same interaction. Examples SPA API methods can be used on newrelic.interaction(). The methods can also be used on a handle you assign with a variable. For example: myInteraction = newrelic.interaction() myInteraction.save() Copy The named handle can be saved and used from outside an interaction, but methods will have no effect after the interaction has ended.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 208.48872,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "interaction (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "interaction (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction() Copy Returns a new <em>API</em> object that is bound to the current <em>SPA</em> interaction. Requirements <em>Agent</em> version nr-963 or higher. Description The <em>SPA</em> <em>monitoring</em> interaction() call returns a new <em>API</em> object that is bound to the current interaction. New interaction: If the <em>API</em>"
      },
      "id": "603eb45728ccbc8e2feba779"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/createtracer-browser-spa-api": [
    {
      "sections": [
        "addPageAction (Browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record link clicks (JavaScript)",
        "Record link clicks (jQuery)",
        "Capture form input"
      ],
      "title": "addPageAction (Browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "051774181e5be11026841b52aeb04a693ffad434",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/add-page-action/",
      "published_at": "2021-07-02T08:58:02Z",
      "updated_at": "2021-06-14T23:24:03Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addPageAction(string $name[, JSON object $attributes]) Copy Reports a Browser PageAction event to New Relic One along with a name and optional attributes. Requirements Agent version nr-593 or higher. Description This API call sends a Browser PageAction event with your user-defined name and optional attributes to dashboards, along with several default attributes. This is useful to track any event that is not already tracked automatically by the Browser agent, such as clicking a Subscribe button or accessing a tutorial. PageAction events are sent to New Relic One every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that harvest cycle. Parameters Parameter Description $name string Required. Name or category of the action. Reports to New Relic One as the actionName attribute. Avoid using reserved NRQL words when you name the attribute or value. $attributes JSON object Optional. JSON object with one or more key/value pairs. For example: {key:\"value\"}. The key will report to New Relic One as its own PageAction attribute with the specified values. Avoid using reserved NRQL words when you name the attribute/value. Examples Record link clicks (JavaScript) This example records a PageAction event whenever a user selects the Try Me link. The event is recorded with an actionName of clickedTryMe: < a href=\"/demo\" id=\"try-me\" >Try Me!< /a> <script> document.getElementById('try-me').addEventListener('click',function (e) { newrelic.addPageAction('clickedTryMe'); }) </script> Copy You can then query the number of times the Try Me button was clicked with the following NRQL query: SELECT count(*) FROM PageAction WHERE actionName='clickedTryMe' SINCE 1 hour ago Copy Record link clicks (jQuery) This example sends a PageAction event when a user clicks on an element with the class copy-text. The actionName is copy-text-button and the value is reported as another attribute called Result that corresponds to methods named success and error that handle the outcome. $('.copy-text').click(function (){ var clipboard = new Clipboard ('.copy-text'); clipboard.on('success', function(event) { // Do stuff // Report data to New Relic One if (typeof newrelic == 'object') { newrelic.addPageAction('copy-text-button', {result: 'success'}); } }); clipboard.on('error', function(event) { // Do stuff // Report data to New Relic One if (typeof newrelic == 'object') { newrelic.addPageAction('copy-text-button', {result: 'error'}); } }); }); Copy Then in the query builder, you can create a pie chart to see the breakdown of how many button clicks resulted in success versus error over the past 30 days: SELECT count(*) AS 'Clicks' FROM PageAction WHERE actionName = 'copy-text-button' FACET result SINCE 30 days ago Copy Or you can create a query to see what pages have the most copy button clicks in the last 30 days: SELECT count(*) AS 'Clicks' FROM PageAction WHERE actionName = 'copy-text-button' FACET currentUrl SINCE 30 days ago Copy Capture form input This example captures user input (email addresses) from a form called Signup. The event is recorded with an actionName of userSignup: <form action=\"/signup\" id=\"myform\"> <input id=\"email\" name=\"email\"> <input type=\"submit\" value=\"Signup\"> </form> <script type=\"text/javascript\"> document.getElementById('myform').addEventListener('submit', function (e) { var email = e.target.elements['email'].value; newrelic.addPageAction('userSignup', {email: email}); }) </script> Copy You can then see the emails that you gathered with the following NRQL query: SELECT uniques(email) FROM PageAction WHERE actionName='userSignup' SINCE 1 hour ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 267.33627,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addPageAction (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "sections": "addPageAction (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.addPageAction(string $name[, JSON object $attributes]) Copy Reports a <em>Browser</em> PageAction event to New Relic One along with a name and optional attributes. Requirements <em>Agent</em> version nr-593 or higher. Description This <em>API</em> call sends a <em>Browser</em> PageAction event with your user-defined"
      },
      "id": "60440d4628ccbc14742c60cb"
    },
    {
      "sections": [
        "save (Browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Return values",
        "Examples"
      ],
      "title": "save (Browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "033ab644ae53188525caa08a438d834b01005189",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/save-browser-spa-api/",
      "published_at": "2021-07-02T09:05:00Z",
      "updated_at": "2021-04-22T09:50:52Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction().save() Copy Ensures a SPA browser interaction will be saved when it ends. Requirements Agent version nr-963 or higher. Description This SPA method ensures a browser interaction will be saved when it ends. Normally an interaction is only saved and sent to New Relic if it is an initial page load or if it results in a URL or hash change. You must call this method to override this behavior and guarantee the interaction will be recorded. Return values This method returns the same API object created by interaction(), which is associated with a BrowserInteraction event. Examples /* window.addEventListener('scroll', () => { if (atBottomOfPage()) { newrelic.interaction() // Start monitoring this interaction. .setName('loadNextPage') // Set name of interaction. .save(); // Ensure that this interaction will be saved as a BrowserInteraction event when it ends. loadNextPage() // Start loading the next page. } }) */ Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 216.62386,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "save (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "save (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction().save() Copy Ensures a <em>SPA</em> <em>browser</em> interaction will be saved when it ends. Requirements <em>Agent</em> version nr-963 or higher. Description This <em>SPA</em> method ensures a <em>browser</em> interaction will be saved when it ends. Normally an interaction is only saved and sent to New Relic"
      },
      "id": "603eb491e7b9d257f92a07f4"
    },
    {
      "sections": [
        "interaction (Browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Return values",
        "Examples"
      ],
      "title": "interaction (Browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "6656dfeb99f4d3559511a001f951c3c3865129c5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/interaction-browser-spa-api/",
      "published_at": "2021-07-02T09:03:53Z",
      "updated_at": "2021-03-16T08:25:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction() Copy Returns a new API object that is bound to the current SPA interaction. Requirements Agent version nr-963 or higher. Description The SPA monitoring interaction() call returns a new API object that is bound to the current interaction. New interaction: If the API calls it when New Relic is not currently monitoring an interaction, a new interaction is created. New object: If the API calls it again within the same interaction, a new object referencing the current interaction is created. Parameters The parameters depend on the specific SPA interaction API call. Return values This method returns an API object that is bound to a specific BrowserInteraction event. Each time this method is called for the same BrowserInteraction, a new object is created, but it still references the same interaction. Examples SPA API methods can be used on newrelic.interaction(). The methods can also be used on a handle you assign with a variable. For example: myInteraction = newrelic.interaction() myInteraction.save() Copy The named handle can be saved and used from outside an interaction, but methods will have no effect after the interaction has ended.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 208.48872,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "interaction (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "interaction (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction() Copy Returns a new <em>API</em> object that is bound to the current <em>SPA</em> interaction. Requirements <em>Agent</em> version nr-963 or higher. Description The <em>SPA</em> <em>monitoring</em> interaction() call returns a new <em>API</em> object that is bound to the current interaction. New interaction: If the <em>API</em>"
      },
      "id": "603eb45728ccbc8e2feba779"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/end-browser-spa-api": [
    {
      "sections": [
        "addPageAction (Browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record link clicks (JavaScript)",
        "Record link clicks (jQuery)",
        "Capture form input"
      ],
      "title": "addPageAction (Browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "051774181e5be11026841b52aeb04a693ffad434",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/add-page-action/",
      "published_at": "2021-07-02T08:58:02Z",
      "updated_at": "2021-06-14T23:24:03Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addPageAction(string $name[, JSON object $attributes]) Copy Reports a Browser PageAction event to New Relic One along with a name and optional attributes. Requirements Agent version nr-593 or higher. Description This API call sends a Browser PageAction event with your user-defined name and optional attributes to dashboards, along with several default attributes. This is useful to track any event that is not already tracked automatically by the Browser agent, such as clicking a Subscribe button or accessing a tutorial. PageAction events are sent to New Relic One every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that harvest cycle. Parameters Parameter Description $name string Required. Name or category of the action. Reports to New Relic One as the actionName attribute. Avoid using reserved NRQL words when you name the attribute or value. $attributes JSON object Optional. JSON object with one or more key/value pairs. For example: {key:\"value\"}. The key will report to New Relic One as its own PageAction attribute with the specified values. Avoid using reserved NRQL words when you name the attribute/value. Examples Record link clicks (JavaScript) This example records a PageAction event whenever a user selects the Try Me link. The event is recorded with an actionName of clickedTryMe: < a href=\"/demo\" id=\"try-me\" >Try Me!< /a> <script> document.getElementById('try-me').addEventListener('click',function (e) { newrelic.addPageAction('clickedTryMe'); }) </script> Copy You can then query the number of times the Try Me button was clicked with the following NRQL query: SELECT count(*) FROM PageAction WHERE actionName='clickedTryMe' SINCE 1 hour ago Copy Record link clicks (jQuery) This example sends a PageAction event when a user clicks on an element with the class copy-text. The actionName is copy-text-button and the value is reported as another attribute called Result that corresponds to methods named success and error that handle the outcome. $('.copy-text').click(function (){ var clipboard = new Clipboard ('.copy-text'); clipboard.on('success', function(event) { // Do stuff // Report data to New Relic One if (typeof newrelic == 'object') { newrelic.addPageAction('copy-text-button', {result: 'success'}); } }); clipboard.on('error', function(event) { // Do stuff // Report data to New Relic One if (typeof newrelic == 'object') { newrelic.addPageAction('copy-text-button', {result: 'error'}); } }); }); Copy Then in the query builder, you can create a pie chart to see the breakdown of how many button clicks resulted in success versus error over the past 30 days: SELECT count(*) AS 'Clicks' FROM PageAction WHERE actionName = 'copy-text-button' FACET result SINCE 30 days ago Copy Or you can create a query to see what pages have the most copy button clicks in the last 30 days: SELECT count(*) AS 'Clicks' FROM PageAction WHERE actionName = 'copy-text-button' FACET currentUrl SINCE 30 days ago Copy Capture form input This example captures user input (email addresses) from a form called Signup. The event is recorded with an actionName of userSignup: <form action=\"/signup\" id=\"myform\"> <input id=\"email\" name=\"email\"> <input type=\"submit\" value=\"Signup\"> </form> <script type=\"text/javascript\"> document.getElementById('myform').addEventListener('submit', function (e) { var email = e.target.elements['email'].value; newrelic.addPageAction('userSignup', {email: email}); }) </script> Copy You can then see the emails that you gathered with the following NRQL query: SELECT uniques(email) FROM PageAction WHERE actionName='userSignup' SINCE 1 hour ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 267.33624,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addPageAction (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "sections": "addPageAction (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.addPageAction(string $name[, JSON object $attributes]) Copy Reports a <em>Browser</em> PageAction event to New Relic One along with a name and optional attributes. Requirements <em>Agent</em> version nr-593 or higher. Description This <em>API</em> call sends a <em>Browser</em> PageAction event with your user-defined"
      },
      "id": "60440d4628ccbc14742c60cb"
    },
    {
      "sections": [
        "save (Browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Return values",
        "Examples"
      ],
      "title": "save (Browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "033ab644ae53188525caa08a438d834b01005189",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/save-browser-spa-api/",
      "published_at": "2021-07-02T09:05:00Z",
      "updated_at": "2021-04-22T09:50:52Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction().save() Copy Ensures a SPA browser interaction will be saved when it ends. Requirements Agent version nr-963 or higher. Description This SPA method ensures a browser interaction will be saved when it ends. Normally an interaction is only saved and sent to New Relic if it is an initial page load or if it results in a URL or hash change. You must call this method to override this behavior and guarantee the interaction will be recorded. Return values This method returns the same API object created by interaction(), which is associated with a BrowserInteraction event. Examples /* window.addEventListener('scroll', () => { if (atBottomOfPage()) { newrelic.interaction() // Start monitoring this interaction. .setName('loadNextPage') // Set name of interaction. .save(); // Ensure that this interaction will be saved as a BrowserInteraction event when it ends. loadNextPage() // Start loading the next page. } }) */ Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 216.62386,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "save (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "save (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction().save() Copy Ensures a <em>SPA</em> <em>browser</em> interaction will be saved when it ends. Requirements <em>Agent</em> version nr-963 or higher. Description This <em>SPA</em> method ensures a <em>browser</em> interaction will be saved when it ends. Normally an interaction is only saved and sent to New Relic"
      },
      "id": "603eb491e7b9d257f92a07f4"
    },
    {
      "sections": [
        "interaction (Browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Return values",
        "Examples"
      ],
      "title": "interaction (Browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "6656dfeb99f4d3559511a001f951c3c3865129c5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/interaction-browser-spa-api/",
      "published_at": "2021-07-02T09:03:53Z",
      "updated_at": "2021-03-16T08:25:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction() Copy Returns a new API object that is bound to the current SPA interaction. Requirements Agent version nr-963 or higher. Description The SPA monitoring interaction() call returns a new API object that is bound to the current interaction. New interaction: If the API calls it when New Relic is not currently monitoring an interaction, a new interaction is created. New object: If the API calls it again within the same interaction, a new object referencing the current interaction is created. Parameters The parameters depend on the specific SPA interaction API call. Return values This method returns an API object that is bound to a specific BrowserInteraction event. Each time this method is called for the same BrowserInteraction, a new object is created, but it still references the same interaction. Examples SPA API methods can be used on newrelic.interaction(). The methods can also be used on a handle you assign with a variable. For example: myInteraction = newrelic.interaction() myInteraction.save() Copy The named handle can be saved and used from outside an interaction, but methods will have no effect after the interaction has ended.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 208.48872,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "interaction (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "interaction (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction() Copy Returns a new <em>API</em> object that is bound to the current <em>SPA</em> interaction. Requirements <em>Agent</em> version nr-963 or higher. Description The <em>SPA</em> <em>monitoring</em> interaction() call returns a new <em>API</em> object that is bound to the current interaction. New interaction: If the <em>API</em>"
      },
      "id": "603eb45728ccbc8e2feba779"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/finished": [
    {
      "sections": [
        "addPageAction (Browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record link clicks (JavaScript)",
        "Record link clicks (jQuery)",
        "Capture form input"
      ],
      "title": "addPageAction (Browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "051774181e5be11026841b52aeb04a693ffad434",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/add-page-action/",
      "published_at": "2021-07-02T08:58:02Z",
      "updated_at": "2021-06-14T23:24:03Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addPageAction(string $name[, JSON object $attributes]) Copy Reports a Browser PageAction event to New Relic One along with a name and optional attributes. Requirements Agent version nr-593 or higher. Description This API call sends a Browser PageAction event with your user-defined name and optional attributes to dashboards, along with several default attributes. This is useful to track any event that is not already tracked automatically by the Browser agent, such as clicking a Subscribe button or accessing a tutorial. PageAction events are sent to New Relic One every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that harvest cycle. Parameters Parameter Description $name string Required. Name or category of the action. Reports to New Relic One as the actionName attribute. Avoid using reserved NRQL words when you name the attribute or value. $attributes JSON object Optional. JSON object with one or more key/value pairs. For example: {key:\"value\"}. The key will report to New Relic One as its own PageAction attribute with the specified values. Avoid using reserved NRQL words when you name the attribute/value. Examples Record link clicks (JavaScript) This example records a PageAction event whenever a user selects the Try Me link. The event is recorded with an actionName of clickedTryMe: < a href=\"/demo\" id=\"try-me\" >Try Me!< /a> <script> document.getElementById('try-me').addEventListener('click',function (e) { newrelic.addPageAction('clickedTryMe'); }) </script> Copy You can then query the number of times the Try Me button was clicked with the following NRQL query: SELECT count(*) FROM PageAction WHERE actionName='clickedTryMe' SINCE 1 hour ago Copy Record link clicks (jQuery) This example sends a PageAction event when a user clicks on an element with the class copy-text. The actionName is copy-text-button and the value is reported as another attribute called Result that corresponds to methods named success and error that handle the outcome. $('.copy-text').click(function (){ var clipboard = new Clipboard ('.copy-text'); clipboard.on('success', function(event) { // Do stuff // Report data to New Relic One if (typeof newrelic == 'object') { newrelic.addPageAction('copy-text-button', {result: 'success'}); } }); clipboard.on('error', function(event) { // Do stuff // Report data to New Relic One if (typeof newrelic == 'object') { newrelic.addPageAction('copy-text-button', {result: 'error'}); } }); }); Copy Then in the query builder, you can create a pie chart to see the breakdown of how many button clicks resulted in success versus error over the past 30 days: SELECT count(*) AS 'Clicks' FROM PageAction WHERE actionName = 'copy-text-button' FACET result SINCE 30 days ago Copy Or you can create a query to see what pages have the most copy button clicks in the last 30 days: SELECT count(*) AS 'Clicks' FROM PageAction WHERE actionName = 'copy-text-button' FACET currentUrl SINCE 30 days ago Copy Capture form input This example captures user input (email addresses) from a form called Signup. The event is recorded with an actionName of userSignup: <form action=\"/signup\" id=\"myform\"> <input id=\"email\" name=\"email\"> <input type=\"submit\" value=\"Signup\"> </form> <script type=\"text/javascript\"> document.getElementById('myform').addEventListener('submit', function (e) { var email = e.target.elements['email'].value; newrelic.addPageAction('userSignup', {email: email}); }) </script> Copy You can then see the emails that you gathered with the following NRQL query: SELECT uniques(email) FROM PageAction WHERE actionName='userSignup' SINCE 1 hour ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 267.33624,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addPageAction (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "sections": "addPageAction (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.addPageAction(string $name[, JSON object $attributes]) Copy Reports a <em>Browser</em> PageAction event to New Relic One along with a name and optional attributes. Requirements <em>Agent</em> version nr-593 or higher. Description This <em>API</em> call sends a <em>Browser</em> PageAction event with your user-defined"
      },
      "id": "60440d4628ccbc14742c60cb"
    },
    {
      "sections": [
        "save (Browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Return values",
        "Examples"
      ],
      "title": "save (Browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "033ab644ae53188525caa08a438d834b01005189",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/save-browser-spa-api/",
      "published_at": "2021-07-02T09:05:00Z",
      "updated_at": "2021-04-22T09:50:52Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction().save() Copy Ensures a SPA browser interaction will be saved when it ends. Requirements Agent version nr-963 or higher. Description This SPA method ensures a browser interaction will be saved when it ends. Normally an interaction is only saved and sent to New Relic if it is an initial page load or if it results in a URL or hash change. You must call this method to override this behavior and guarantee the interaction will be recorded. Return values This method returns the same API object created by interaction(), which is associated with a BrowserInteraction event. Examples /* window.addEventListener('scroll', () => { if (atBottomOfPage()) { newrelic.interaction() // Start monitoring this interaction. .setName('loadNextPage') // Set name of interaction. .save(); // Ensure that this interaction will be saved as a BrowserInteraction event when it ends. loadNextPage() // Start loading the next page. } }) */ Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 216.62386,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "save (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "save (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction().save() Copy Ensures a <em>SPA</em> <em>browser</em> interaction will be saved when it ends. Requirements <em>Agent</em> version nr-963 or higher. Description This <em>SPA</em> method ensures a <em>browser</em> interaction will be saved when it ends. Normally an interaction is only saved and sent to New Relic"
      },
      "id": "603eb491e7b9d257f92a07f4"
    },
    {
      "sections": [
        "interaction (Browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Return values",
        "Examples"
      ],
      "title": "interaction (Browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "6656dfeb99f4d3559511a001f951c3c3865129c5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/interaction-browser-spa-api/",
      "published_at": "2021-07-02T09:03:53Z",
      "updated_at": "2021-03-16T08:25:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction() Copy Returns a new API object that is bound to the current SPA interaction. Requirements Agent version nr-963 or higher. Description The SPA monitoring interaction() call returns a new API object that is bound to the current interaction. New interaction: If the API calls it when New Relic is not currently monitoring an interaction, a new interaction is created. New object: If the API calls it again within the same interaction, a new object referencing the current interaction is created. Parameters The parameters depend on the specific SPA interaction API call. Return values This method returns an API object that is bound to a specific BrowserInteraction event. Each time this method is called for the same BrowserInteraction, a new object is created, but it still references the same interaction. Examples SPA API methods can be used on newrelic.interaction(). The methods can also be used on a handle you assign with a variable. For example: myInteraction = newrelic.interaction() myInteraction.save() Copy The named handle can be saved and used from outside an interaction, but methods will have no effect after the interaction has ended.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 208.48872,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "interaction (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "interaction (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction() Copy Returns a new <em>API</em> object that is bound to the current <em>SPA</em> interaction. Requirements <em>Agent</em> version nr-963 or higher. Description The <em>SPA</em> <em>monitoring</em> interaction() call returns a new <em>API</em> object that is bound to the current interaction. New interaction: If the <em>API</em>"
      },
      "id": "603eb45728ccbc8e2feba779"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/getcontext-browser-spa-api": [
    {
      "sections": [
        "addPageAction (Browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record link clicks (JavaScript)",
        "Record link clicks (jQuery)",
        "Capture form input"
      ],
      "title": "addPageAction (Browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "051774181e5be11026841b52aeb04a693ffad434",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/add-page-action/",
      "published_at": "2021-07-02T08:58:02Z",
      "updated_at": "2021-06-14T23:24:03Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addPageAction(string $name[, JSON object $attributes]) Copy Reports a Browser PageAction event to New Relic One along with a name and optional attributes. Requirements Agent version nr-593 or higher. Description This API call sends a Browser PageAction event with your user-defined name and optional attributes to dashboards, along with several default attributes. This is useful to track any event that is not already tracked automatically by the Browser agent, such as clicking a Subscribe button or accessing a tutorial. PageAction events are sent to New Relic One every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that harvest cycle. Parameters Parameter Description $name string Required. Name or category of the action. Reports to New Relic One as the actionName attribute. Avoid using reserved NRQL words when you name the attribute or value. $attributes JSON object Optional. JSON object with one or more key/value pairs. For example: {key:\"value\"}. The key will report to New Relic One as its own PageAction attribute with the specified values. Avoid using reserved NRQL words when you name the attribute/value. Examples Record link clicks (JavaScript) This example records a PageAction event whenever a user selects the Try Me link. The event is recorded with an actionName of clickedTryMe: < a href=\"/demo\" id=\"try-me\" >Try Me!< /a> <script> document.getElementById('try-me').addEventListener('click',function (e) { newrelic.addPageAction('clickedTryMe'); }) </script> Copy You can then query the number of times the Try Me button was clicked with the following NRQL query: SELECT count(*) FROM PageAction WHERE actionName='clickedTryMe' SINCE 1 hour ago Copy Record link clicks (jQuery) This example sends a PageAction event when a user clicks on an element with the class copy-text. The actionName is copy-text-button and the value is reported as another attribute called Result that corresponds to methods named success and error that handle the outcome. $('.copy-text').click(function (){ var clipboard = new Clipboard ('.copy-text'); clipboard.on('success', function(event) { // Do stuff // Report data to New Relic One if (typeof newrelic == 'object') { newrelic.addPageAction('copy-text-button', {result: 'success'}); } }); clipboard.on('error', function(event) { // Do stuff // Report data to New Relic One if (typeof newrelic == 'object') { newrelic.addPageAction('copy-text-button', {result: 'error'}); } }); }); Copy Then in the query builder, you can create a pie chart to see the breakdown of how many button clicks resulted in success versus error over the past 30 days: SELECT count(*) AS 'Clicks' FROM PageAction WHERE actionName = 'copy-text-button' FACET result SINCE 30 days ago Copy Or you can create a query to see what pages have the most copy button clicks in the last 30 days: SELECT count(*) AS 'Clicks' FROM PageAction WHERE actionName = 'copy-text-button' FACET currentUrl SINCE 30 days ago Copy Capture form input This example captures user input (email addresses) from a form called Signup. The event is recorded with an actionName of userSignup: <form action=\"/signup\" id=\"myform\"> <input id=\"email\" name=\"email\"> <input type=\"submit\" value=\"Signup\"> </form> <script type=\"text/javascript\"> document.getElementById('myform').addEventListener('submit', function (e) { var email = e.target.elements['email'].value; newrelic.addPageAction('userSignup', {email: email}); }) </script> Copy You can then see the emails that you gathered with the following NRQL query: SELECT uniques(email) FROM PageAction WHERE actionName='userSignup' SINCE 1 hour ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 267.33624,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addPageAction (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "sections": "addPageAction (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.addPageAction(string $name[, JSON object $attributes]) Copy Reports a <em>Browser</em> PageAction event to New Relic One along with a name and optional attributes. Requirements <em>Agent</em> version nr-593 or higher. Description This <em>API</em> call sends a <em>Browser</em> PageAction event with your user-defined"
      },
      "id": "60440d4628ccbc14742c60cb"
    },
    {
      "sections": [
        "save (Browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Return values",
        "Examples"
      ],
      "title": "save (Browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "033ab644ae53188525caa08a438d834b01005189",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/save-browser-spa-api/",
      "published_at": "2021-07-02T09:05:00Z",
      "updated_at": "2021-04-22T09:50:52Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction().save() Copy Ensures a SPA browser interaction will be saved when it ends. Requirements Agent version nr-963 or higher. Description This SPA method ensures a browser interaction will be saved when it ends. Normally an interaction is only saved and sent to New Relic if it is an initial page load or if it results in a URL or hash change. You must call this method to override this behavior and guarantee the interaction will be recorded. Return values This method returns the same API object created by interaction(), which is associated with a BrowserInteraction event. Examples /* window.addEventListener('scroll', () => { if (atBottomOfPage()) { newrelic.interaction() // Start monitoring this interaction. .setName('loadNextPage') // Set name of interaction. .save(); // Ensure that this interaction will be saved as a BrowserInteraction event when it ends. loadNextPage() // Start loading the next page. } }) */ Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 216.62386,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "save (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "save (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction().save() Copy Ensures a <em>SPA</em> <em>browser</em> interaction will be saved when it ends. Requirements <em>Agent</em> version nr-963 or higher. Description This <em>SPA</em> method ensures a <em>browser</em> interaction will be saved when it ends. Normally an interaction is only saved and sent to New Relic"
      },
      "id": "603eb491e7b9d257f92a07f4"
    },
    {
      "sections": [
        "interaction (Browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Return values",
        "Examples"
      ],
      "title": "interaction (Browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "6656dfeb99f4d3559511a001f951c3c3865129c5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/interaction-browser-spa-api/",
      "published_at": "2021-07-02T09:03:53Z",
      "updated_at": "2021-03-16T08:25:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction() Copy Returns a new API object that is bound to the current SPA interaction. Requirements Agent version nr-963 or higher. Description The SPA monitoring interaction() call returns a new API object that is bound to the current interaction. New interaction: If the API calls it when New Relic is not currently monitoring an interaction, a new interaction is created. New object: If the API calls it again within the same interaction, a new object referencing the current interaction is created. Parameters The parameters depend on the specific SPA interaction API call. Return values This method returns an API object that is bound to a specific BrowserInteraction event. Each time this method is called for the same BrowserInteraction, a new object is created, but it still references the same interaction. Examples SPA API methods can be used on newrelic.interaction(). The methods can also be used on a handle you assign with a variable. For example: myInteraction = newrelic.interaction() myInteraction.save() Copy The named handle can be saved and used from outside an interaction, but methods will have no effect after the interaction has ended.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 208.48872,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "interaction (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "interaction (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction() Copy Returns a new <em>API</em> object that is bound to the current <em>SPA</em> interaction. Requirements <em>Agent</em> version nr-963 or higher. Description The <em>SPA</em> <em>monitoring</em> interaction() call returns a new <em>API</em> object that is bound to the current interaction. New interaction: If the <em>API</em>"
      },
      "id": "603eb45728ccbc8e2feba779"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/ignore-browser-spa-api": [
    {
      "sections": [
        "addPageAction (Browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record link clicks (JavaScript)",
        "Record link clicks (jQuery)",
        "Capture form input"
      ],
      "title": "addPageAction (Browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "051774181e5be11026841b52aeb04a693ffad434",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/add-page-action/",
      "published_at": "2021-07-02T08:58:02Z",
      "updated_at": "2021-06-14T23:24:03Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addPageAction(string $name[, JSON object $attributes]) Copy Reports a Browser PageAction event to New Relic One along with a name and optional attributes. Requirements Agent version nr-593 or higher. Description This API call sends a Browser PageAction event with your user-defined name and optional attributes to dashboards, along with several default attributes. This is useful to track any event that is not already tracked automatically by the Browser agent, such as clicking a Subscribe button or accessing a tutorial. PageAction events are sent to New Relic One every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that harvest cycle. Parameters Parameter Description $name string Required. Name or category of the action. Reports to New Relic One as the actionName attribute. Avoid using reserved NRQL words when you name the attribute or value. $attributes JSON object Optional. JSON object with one or more key/value pairs. For example: {key:\"value\"}. The key will report to New Relic One as its own PageAction attribute with the specified values. Avoid using reserved NRQL words when you name the attribute/value. Examples Record link clicks (JavaScript) This example records a PageAction event whenever a user selects the Try Me link. The event is recorded with an actionName of clickedTryMe: < a href=\"/demo\" id=\"try-me\" >Try Me!< /a> <script> document.getElementById('try-me').addEventListener('click',function (e) { newrelic.addPageAction('clickedTryMe'); }) </script> Copy You can then query the number of times the Try Me button was clicked with the following NRQL query: SELECT count(*) FROM PageAction WHERE actionName='clickedTryMe' SINCE 1 hour ago Copy Record link clicks (jQuery) This example sends a PageAction event when a user clicks on an element with the class copy-text. The actionName is copy-text-button and the value is reported as another attribute called Result that corresponds to methods named success and error that handle the outcome. $('.copy-text').click(function (){ var clipboard = new Clipboard ('.copy-text'); clipboard.on('success', function(event) { // Do stuff // Report data to New Relic One if (typeof newrelic == 'object') { newrelic.addPageAction('copy-text-button', {result: 'success'}); } }); clipboard.on('error', function(event) { // Do stuff // Report data to New Relic One if (typeof newrelic == 'object') { newrelic.addPageAction('copy-text-button', {result: 'error'}); } }); }); Copy Then in the query builder, you can create a pie chart to see the breakdown of how many button clicks resulted in success versus error over the past 30 days: SELECT count(*) AS 'Clicks' FROM PageAction WHERE actionName = 'copy-text-button' FACET result SINCE 30 days ago Copy Or you can create a query to see what pages have the most copy button clicks in the last 30 days: SELECT count(*) AS 'Clicks' FROM PageAction WHERE actionName = 'copy-text-button' FACET currentUrl SINCE 30 days ago Copy Capture form input This example captures user input (email addresses) from a form called Signup. The event is recorded with an actionName of userSignup: <form action=\"/signup\" id=\"myform\"> <input id=\"email\" name=\"email\"> <input type=\"submit\" value=\"Signup\"> </form> <script type=\"text/javascript\"> document.getElementById('myform').addEventListener('submit', function (e) { var email = e.target.elements['email'].value; newrelic.addPageAction('userSignup', {email: email}); }) </script> Copy You can then see the emails that you gathered with the following NRQL query: SELECT uniques(email) FROM PageAction WHERE actionName='userSignup' SINCE 1 hour ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 267.3362,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addPageAction (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "sections": "addPageAction (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.addPageAction(string $name[, JSON object $attributes]) Copy Reports a <em>Browser</em> PageAction event to New Relic One along with a name and optional attributes. Requirements <em>Agent</em> version nr-593 or higher. Description This <em>API</em> call sends a <em>Browser</em> PageAction event with your user-defined"
      },
      "id": "60440d4628ccbc14742c60cb"
    },
    {
      "sections": [
        "save (Browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Return values",
        "Examples"
      ],
      "title": "save (Browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "033ab644ae53188525caa08a438d834b01005189",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/save-browser-spa-api/",
      "published_at": "2021-07-02T09:05:00Z",
      "updated_at": "2021-04-22T09:50:52Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction().save() Copy Ensures a SPA browser interaction will be saved when it ends. Requirements Agent version nr-963 or higher. Description This SPA method ensures a browser interaction will be saved when it ends. Normally an interaction is only saved and sent to New Relic if it is an initial page load or if it results in a URL or hash change. You must call this method to override this behavior and guarantee the interaction will be recorded. Return values This method returns the same API object created by interaction(), which is associated with a BrowserInteraction event. Examples /* window.addEventListener('scroll', () => { if (atBottomOfPage()) { newrelic.interaction() // Start monitoring this interaction. .setName('loadNextPage') // Set name of interaction. .save(); // Ensure that this interaction will be saved as a BrowserInteraction event when it ends. loadNextPage() // Start loading the next page. } }) */ Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 216.62384,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "save (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "save (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction().save() Copy Ensures a <em>SPA</em> <em>browser</em> interaction will be saved when it ends. Requirements <em>Agent</em> version nr-963 or higher. Description This <em>SPA</em> method ensures a <em>browser</em> interaction will be saved when it ends. Normally an interaction is only saved and sent to New Relic"
      },
      "id": "603eb491e7b9d257f92a07f4"
    },
    {
      "sections": [
        "interaction (Browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Return values",
        "Examples"
      ],
      "title": "interaction (Browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "6656dfeb99f4d3559511a001f951c3c3865129c5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/interaction-browser-spa-api/",
      "published_at": "2021-07-02T09:03:53Z",
      "updated_at": "2021-03-16T08:25:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction() Copy Returns a new API object that is bound to the current SPA interaction. Requirements Agent version nr-963 or higher. Description The SPA monitoring interaction() call returns a new API object that is bound to the current interaction. New interaction: If the API calls it when New Relic is not currently monitoring an interaction, a new interaction is created. New object: If the API calls it again within the same interaction, a new object referencing the current interaction is created. Parameters The parameters depend on the specific SPA interaction API call. Return values This method returns an API object that is bound to a specific BrowserInteraction event. Each time this method is called for the same BrowserInteraction, a new object is created, but it still references the same interaction. Examples SPA API methods can be used on newrelic.interaction(). The methods can also be used on a handle you assign with a variable. For example: myInteraction = newrelic.interaction() myInteraction.save() Copy The named handle can be saved and used from outside an interaction, but methods will have no effect after the interaction has ended.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 208.48872,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "interaction (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "interaction (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction() Copy Returns a new <em>API</em> object that is bound to the current <em>SPA</em> interaction. Requirements <em>Agent</em> version nr-963 or higher. Description The <em>SPA</em> <em>monitoring</em> interaction() call returns a new <em>API</em> object that is bound to the current interaction. New interaction: If the <em>API</em>"
      },
      "id": "603eb45728ccbc8e2feba779"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/index": [
    {
      "sections": [
        "addPageAction (Browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record link clicks (JavaScript)",
        "Record link clicks (jQuery)",
        "Capture form input"
      ],
      "title": "addPageAction (Browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "051774181e5be11026841b52aeb04a693ffad434",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/add-page-action/",
      "published_at": "2021-07-02T08:58:02Z",
      "updated_at": "2021-06-14T23:24:03Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addPageAction(string $name[, JSON object $attributes]) Copy Reports a Browser PageAction event to New Relic One along with a name and optional attributes. Requirements Agent version nr-593 or higher. Description This API call sends a Browser PageAction event with your user-defined name and optional attributes to dashboards, along with several default attributes. This is useful to track any event that is not already tracked automatically by the Browser agent, such as clicking a Subscribe button or accessing a tutorial. PageAction events are sent to New Relic One every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that harvest cycle. Parameters Parameter Description $name string Required. Name or category of the action. Reports to New Relic One as the actionName attribute. Avoid using reserved NRQL words when you name the attribute or value. $attributes JSON object Optional. JSON object with one or more key/value pairs. For example: {key:\"value\"}. The key will report to New Relic One as its own PageAction attribute with the specified values. Avoid using reserved NRQL words when you name the attribute/value. Examples Record link clicks (JavaScript) This example records a PageAction event whenever a user selects the Try Me link. The event is recorded with an actionName of clickedTryMe: < a href=\"/demo\" id=\"try-me\" >Try Me!< /a> <script> document.getElementById('try-me').addEventListener('click',function (e) { newrelic.addPageAction('clickedTryMe'); }) </script> Copy You can then query the number of times the Try Me button was clicked with the following NRQL query: SELECT count(*) FROM PageAction WHERE actionName='clickedTryMe' SINCE 1 hour ago Copy Record link clicks (jQuery) This example sends a PageAction event when a user clicks on an element with the class copy-text. The actionName is copy-text-button and the value is reported as another attribute called Result that corresponds to methods named success and error that handle the outcome. $('.copy-text').click(function (){ var clipboard = new Clipboard ('.copy-text'); clipboard.on('success', function(event) { // Do stuff // Report data to New Relic One if (typeof newrelic == 'object') { newrelic.addPageAction('copy-text-button', {result: 'success'}); } }); clipboard.on('error', function(event) { // Do stuff // Report data to New Relic One if (typeof newrelic == 'object') { newrelic.addPageAction('copy-text-button', {result: 'error'}); } }); }); Copy Then in the query builder, you can create a pie chart to see the breakdown of how many button clicks resulted in success versus error over the past 30 days: SELECT count(*) AS 'Clicks' FROM PageAction WHERE actionName = 'copy-text-button' FACET result SINCE 30 days ago Copy Or you can create a query to see what pages have the most copy button clicks in the last 30 days: SELECT count(*) AS 'Clicks' FROM PageAction WHERE actionName = 'copy-text-button' FACET currentUrl SINCE 30 days ago Copy Capture form input This example captures user input (email addresses) from a form called Signup. The event is recorded with an actionName of userSignup: <form action=\"/signup\" id=\"myform\"> <input id=\"email\" name=\"email\"> <input type=\"submit\" value=\"Signup\"> </form> <script type=\"text/javascript\"> document.getElementById('myform').addEventListener('submit', function (e) { var email = e.target.elements['email'].value; newrelic.addPageAction('userSignup', {email: email}); }) </script> Copy You can then see the emails that you gathered with the following NRQL query: SELECT uniques(email) FROM PageAction WHERE actionName='userSignup' SINCE 1 hour ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 2628.2883,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addPageAction (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "sections": "addPageAction (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.addPageAction(string $name[, JSON object $attributes]) Copy Reports a <em>Browser</em> PageAction event to New Relic One along with a name and optional attributes. Requirements <em>Agent</em> version nr-593 or higher. Description This <em>API</em> call sends a <em>Browser</em> PageAction event with your user-defined"
      },
      "id": "60440d4628ccbc14742c60cb"
    },
    {
      "sections": [
        "save (Browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Return values",
        "Examples"
      ],
      "title": "save (Browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "033ab644ae53188525caa08a438d834b01005189",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/save-browser-spa-api/",
      "published_at": "2021-07-02T09:05:00Z",
      "updated_at": "2021-04-22T09:50:52Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction().save() Copy Ensures a SPA browser interaction will be saved when it ends. Requirements Agent version nr-963 or higher. Description This SPA method ensures a browser interaction will be saved when it ends. Normally an interaction is only saved and sent to New Relic if it is an initial page load or if it results in a URL or hash change. You must call this method to override this behavior and guarantee the interaction will be recorded. Return values This method returns the same API object created by interaction(), which is associated with a BrowserInteraction event. Examples /* window.addEventListener('scroll', () => { if (atBottomOfPage()) { newrelic.interaction() // Start monitoring this interaction. .setName('loadNextPage') // Set name of interaction. .save(); // Ensure that this interaction will be saved as a BrowserInteraction event when it ends. loadNextPage() // Start loading the next page. } }) */ Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 2129.7148,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "save (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "save (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction().save() Copy Ensures a <em>SPA</em> <em>browser</em> interaction will be saved when it ends. Requirements <em>Agent</em> version nr-963 or higher. Description This <em>SPA</em> method ensures a <em>browser</em> interaction will be saved when it ends. Normally an interaction is only saved and sent to New Relic"
      },
      "id": "603eb491e7b9d257f92a07f4"
    },
    {
      "sections": [
        "interaction (Browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Return values",
        "Examples"
      ],
      "title": "interaction (Browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "6656dfeb99f4d3559511a001f951c3c3865129c5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/interaction-browser-spa-api/",
      "published_at": "2021-07-02T09:03:53Z",
      "updated_at": "2021-03-16T08:25:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction() Copy Returns a new API object that is bound to the current SPA interaction. Requirements Agent version nr-963 or higher. Description The SPA monitoring interaction() call returns a new API object that is bound to the current interaction. New interaction: If the API calls it when New Relic is not currently monitoring an interaction, a new interaction is created. New object: If the API calls it again within the same interaction, a new object referencing the current interaction is created. Parameters The parameters depend on the specific SPA interaction API call. Return values This method returns an API object that is bound to a specific BrowserInteraction event. Each time this method is called for the same BrowserInteraction, a new object is created, but it still references the same interaction. Examples SPA API methods can be used on newrelic.interaction(). The methods can also be used on a handle you assign with a variable. For example: myInteraction = newrelic.interaction() myInteraction.save() Copy The named handle can be saved and used from outside an interaction, but methods will have no effect after the interaction has ended.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 2049.7354,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "interaction (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "interaction (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction() Copy Returns a new <em>API</em> object that is bound to the current <em>SPA</em> interaction. Requirements <em>Agent</em> version nr-963 or higher. Description The <em>SPA</em> monitoring interaction() call returns a new <em>API</em> object that is bound to the current interaction. New interaction: If the <em>API</em>"
      },
      "id": "603eb45728ccbc8e2feba779"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/interaction-browser-spa-api": [
    {
      "sections": [
        "addPageAction (Browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record link clicks (JavaScript)",
        "Record link clicks (jQuery)",
        "Capture form input"
      ],
      "title": "addPageAction (Browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "051774181e5be11026841b52aeb04a693ffad434",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/add-page-action/",
      "published_at": "2021-07-02T08:58:02Z",
      "updated_at": "2021-06-14T23:24:03Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addPageAction(string $name[, JSON object $attributes]) Copy Reports a Browser PageAction event to New Relic One along with a name and optional attributes. Requirements Agent version nr-593 or higher. Description This API call sends a Browser PageAction event with your user-defined name and optional attributes to dashboards, along with several default attributes. This is useful to track any event that is not already tracked automatically by the Browser agent, such as clicking a Subscribe button or accessing a tutorial. PageAction events are sent to New Relic One every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that harvest cycle. Parameters Parameter Description $name string Required. Name or category of the action. Reports to New Relic One as the actionName attribute. Avoid using reserved NRQL words when you name the attribute or value. $attributes JSON object Optional. JSON object with one or more key/value pairs. For example: {key:\"value\"}. The key will report to New Relic One as its own PageAction attribute with the specified values. Avoid using reserved NRQL words when you name the attribute/value. Examples Record link clicks (JavaScript) This example records a PageAction event whenever a user selects the Try Me link. The event is recorded with an actionName of clickedTryMe: < a href=\"/demo\" id=\"try-me\" >Try Me!< /a> <script> document.getElementById('try-me').addEventListener('click',function (e) { newrelic.addPageAction('clickedTryMe'); }) </script> Copy You can then query the number of times the Try Me button was clicked with the following NRQL query: SELECT count(*) FROM PageAction WHERE actionName='clickedTryMe' SINCE 1 hour ago Copy Record link clicks (jQuery) This example sends a PageAction event when a user clicks on an element with the class copy-text. The actionName is copy-text-button and the value is reported as another attribute called Result that corresponds to methods named success and error that handle the outcome. $('.copy-text').click(function (){ var clipboard = new Clipboard ('.copy-text'); clipboard.on('success', function(event) { // Do stuff // Report data to New Relic One if (typeof newrelic == 'object') { newrelic.addPageAction('copy-text-button', {result: 'success'}); } }); clipboard.on('error', function(event) { // Do stuff // Report data to New Relic One if (typeof newrelic == 'object') { newrelic.addPageAction('copy-text-button', {result: 'error'}); } }); }); Copy Then in the query builder, you can create a pie chart to see the breakdown of how many button clicks resulted in success versus error over the past 30 days: SELECT count(*) AS 'Clicks' FROM PageAction WHERE actionName = 'copy-text-button' FACET result SINCE 30 days ago Copy Or you can create a query to see what pages have the most copy button clicks in the last 30 days: SELECT count(*) AS 'Clicks' FROM PageAction WHERE actionName = 'copy-text-button' FACET currentUrl SINCE 30 days ago Copy Capture form input This example captures user input (email addresses) from a form called Signup. The event is recorded with an actionName of userSignup: <form action=\"/signup\" id=\"myform\"> <input id=\"email\" name=\"email\"> <input type=\"submit\" value=\"Signup\"> </form> <script type=\"text/javascript\"> document.getElementById('myform').addEventListener('submit', function (e) { var email = e.target.elements['email'].value; newrelic.addPageAction('userSignup', {email: email}); }) </script> Copy You can then see the emails that you gathered with the following NRQL query: SELECT uniques(email) FROM PageAction WHERE actionName='userSignup' SINCE 1 hour ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 267.33618,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addPageAction (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "sections": "addPageAction (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.addPageAction(string $name[, JSON object $attributes]) Copy Reports a <em>Browser</em> PageAction event to New Relic One along with a name and optional attributes. Requirements <em>Agent</em> version nr-593 or higher. Description This <em>API</em> call sends a <em>Browser</em> PageAction event with your user-defined"
      },
      "id": "60440d4628ccbc14742c60cb"
    },
    {
      "sections": [
        "save (Browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Return values",
        "Examples"
      ],
      "title": "save (Browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "033ab644ae53188525caa08a438d834b01005189",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/save-browser-spa-api/",
      "published_at": "2021-07-02T09:05:00Z",
      "updated_at": "2021-04-22T09:50:52Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction().save() Copy Ensures a SPA browser interaction will be saved when it ends. Requirements Agent version nr-963 or higher. Description This SPA method ensures a browser interaction will be saved when it ends. Normally an interaction is only saved and sent to New Relic if it is an initial page load or if it results in a URL or hash change. You must call this method to override this behavior and guarantee the interaction will be recorded. Return values This method returns the same API object created by interaction(), which is associated with a BrowserInteraction event. Examples /* window.addEventListener('scroll', () => { if (atBottomOfPage()) { newrelic.interaction() // Start monitoring this interaction. .setName('loadNextPage') // Set name of interaction. .save(); // Ensure that this interaction will be saved as a BrowserInteraction event when it ends. loadNextPage() // Start loading the next page. } }) */ Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 216.62384,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "save (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "save (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction().save() Copy Ensures a <em>SPA</em> <em>browser</em> interaction will be saved when it ends. Requirements <em>Agent</em> version nr-963 or higher. Description This <em>SPA</em> method ensures a <em>browser</em> interaction will be saved when it ends. Normally an interaction is only saved and sent to New Relic"
      },
      "id": "603eb491e7b9d257f92a07f4"
    },
    {
      "sections": [
        "setCustomAttribute (Browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Get JavaScript/jQuery for HTML elements"
      ],
      "title": "setCustomAttribute (Browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "45236cf5e08fcdc6cc62c2e1807a0ae25b3b1045",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setcustomattribute-browser-agent-api/",
      "published_at": "2021-07-02T09:06:17Z",
      "updated_at": "2021-03-16T08:25:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setCustomAttribute(string $name, string OR number $value) Copy Adds a user-defined attribute name and value to subsequent events on the page. Requirements Agent version nr-593 or higher. Description The Browser API call adds a user-defined attribute name and value to subsequent events on the page. Make this call before the window load event fires (when that data is transmitted) in order for the attributes to be included in the PageView event. Once an attribute is set, New Relic One records it with all PageAction events until the page is reloaded or the attribute is manually unset. If you are using SPA monitoring with a compatible agent version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the SPA API will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page. To view or log errors for a custom attribute via API, use the Browser API's noticeError call. Parameters Parameter Description $name string Required. Name of the attribute. Appears as column in the PageView event. It will also appear as a column in the PageAction event if you are using it. Avoid using reserved NRQL words when you name the attribute/value. $value string OR integer Required. Value of the attribute. Appears as the value in the named attribute column in the PageView event. It will appear as a column in the PageAction event if you are using it. Custom attribute values cannot be complex objects, only simple types such as Strings and Integers. Avoid using reserved NRQL words when you name the attribute/value. Examples Get JavaScript/jQuery for HTML elements This example uses JavaScript/jQuery to get the values of the following HTML elements on the Drupal-generated pages for New Relic's Docs site: <link rel=\"shortlink\" href=\"/node/1111\" /> <h1>Using NRQL</h1> New Relic reports them as custom attributes. This is useful to query PageView and PageAction events in New Relic One. var node_id = ''; node_id= jQuery(\"link[rel='shortlink']\").attr(\"href\"); var node_title = ''; node_title= jQuery('h1').text(); if (typeof newrelic == 'object') { newrelic.setCustomAttribute('nodeId', node_id); newrelic.setCustomAttribute('title', node_title); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 208.48872,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setCustomAttribute (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setCustomAttribute (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " unset. If you are using <em>SPA</em> <em>monitoring</em> with a compatible <em>agent</em> version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the <em>SPA</em> <em>API</em> will take precedence over these attributes. Errors for custom attributes will be included in events"
      },
      "id": "6043fe01e7b9d28aff5799e0"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/noticeerror-browser-agent-api": [
    {
      "sections": [
        "addPageAction (Browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record link clicks (JavaScript)",
        "Record link clicks (jQuery)",
        "Capture form input"
      ],
      "title": "addPageAction (Browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "051774181e5be11026841b52aeb04a693ffad434",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/add-page-action/",
      "published_at": "2021-07-02T08:58:02Z",
      "updated_at": "2021-06-14T23:24:03Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addPageAction(string $name[, JSON object $attributes]) Copy Reports a Browser PageAction event to New Relic One along with a name and optional attributes. Requirements Agent version nr-593 or higher. Description This API call sends a Browser PageAction event with your user-defined name and optional attributes to dashboards, along with several default attributes. This is useful to track any event that is not already tracked automatically by the Browser agent, such as clicking a Subscribe button or accessing a tutorial. PageAction events are sent to New Relic One every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that harvest cycle. Parameters Parameter Description $name string Required. Name or category of the action. Reports to New Relic One as the actionName attribute. Avoid using reserved NRQL words when you name the attribute or value. $attributes JSON object Optional. JSON object with one or more key/value pairs. For example: {key:\"value\"}. The key will report to New Relic One as its own PageAction attribute with the specified values. Avoid using reserved NRQL words when you name the attribute/value. Examples Record link clicks (JavaScript) This example records a PageAction event whenever a user selects the Try Me link. The event is recorded with an actionName of clickedTryMe: < a href=\"/demo\" id=\"try-me\" >Try Me!< /a> <script> document.getElementById('try-me').addEventListener('click',function (e) { newrelic.addPageAction('clickedTryMe'); }) </script> Copy You can then query the number of times the Try Me button was clicked with the following NRQL query: SELECT count(*) FROM PageAction WHERE actionName='clickedTryMe' SINCE 1 hour ago Copy Record link clicks (jQuery) This example sends a PageAction event when a user clicks on an element with the class copy-text. The actionName is copy-text-button and the value is reported as another attribute called Result that corresponds to methods named success and error that handle the outcome. $('.copy-text').click(function (){ var clipboard = new Clipboard ('.copy-text'); clipboard.on('success', function(event) { // Do stuff // Report data to New Relic One if (typeof newrelic == 'object') { newrelic.addPageAction('copy-text-button', {result: 'success'}); } }); clipboard.on('error', function(event) { // Do stuff // Report data to New Relic One if (typeof newrelic == 'object') { newrelic.addPageAction('copy-text-button', {result: 'error'}); } }); }); Copy Then in the query builder, you can create a pie chart to see the breakdown of how many button clicks resulted in success versus error over the past 30 days: SELECT count(*) AS 'Clicks' FROM PageAction WHERE actionName = 'copy-text-button' FACET result SINCE 30 days ago Copy Or you can create a query to see what pages have the most copy button clicks in the last 30 days: SELECT count(*) AS 'Clicks' FROM PageAction WHERE actionName = 'copy-text-button' FACET currentUrl SINCE 30 days ago Copy Capture form input This example captures user input (email addresses) from a form called Signup. The event is recorded with an actionName of userSignup: <form action=\"/signup\" id=\"myform\"> <input id=\"email\" name=\"email\"> <input type=\"submit\" value=\"Signup\"> </form> <script type=\"text/javascript\"> document.getElementById('myform').addEventListener('submit', function (e) { var email = e.target.elements['email'].value; newrelic.addPageAction('userSignup', {email: email}); }) </script> Copy You can then see the emails that you gathered with the following NRQL query: SELECT uniques(email) FROM PageAction WHERE actionName='userSignup' SINCE 1 hour ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 267.33618,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addPageAction (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "sections": "addPageAction (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.addPageAction(string $name[, JSON object $attributes]) Copy Reports a <em>Browser</em> PageAction event to New Relic One along with a name and optional attributes. Requirements <em>Agent</em> version nr-593 or higher. Description This <em>API</em> call sends a <em>Browser</em> PageAction event with your user-defined"
      },
      "id": "60440d4628ccbc14742c60cb"
    },
    {
      "sections": [
        "save (Browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Return values",
        "Examples"
      ],
      "title": "save (Browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "033ab644ae53188525caa08a438d834b01005189",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/save-browser-spa-api/",
      "published_at": "2021-07-02T09:05:00Z",
      "updated_at": "2021-04-22T09:50:52Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction().save() Copy Ensures a SPA browser interaction will be saved when it ends. Requirements Agent version nr-963 or higher. Description This SPA method ensures a browser interaction will be saved when it ends. Normally an interaction is only saved and sent to New Relic if it is an initial page load or if it results in a URL or hash change. You must call this method to override this behavior and guarantee the interaction will be recorded. Return values This method returns the same API object created by interaction(), which is associated with a BrowserInteraction event. Examples /* window.addEventListener('scroll', () => { if (atBottomOfPage()) { newrelic.interaction() // Start monitoring this interaction. .setName('loadNextPage') // Set name of interaction. .save(); // Ensure that this interaction will be saved as a BrowserInteraction event when it ends. loadNextPage() // Start loading the next page. } }) */ Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 216.62384,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "save (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "save (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction().save() Copy Ensures a <em>SPA</em> <em>browser</em> interaction will be saved when it ends. Requirements <em>Agent</em> version nr-963 or higher. Description This <em>SPA</em> method ensures a <em>browser</em> interaction will be saved when it ends. Normally an interaction is only saved and sent to New Relic"
      },
      "id": "603eb491e7b9d257f92a07f4"
    },
    {
      "sections": [
        "interaction (Browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Return values",
        "Examples"
      ],
      "title": "interaction (Browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "6656dfeb99f4d3559511a001f951c3c3865129c5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/interaction-browser-spa-api/",
      "published_at": "2021-07-02T09:03:53Z",
      "updated_at": "2021-03-16T08:25:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction() Copy Returns a new API object that is bound to the current SPA interaction. Requirements Agent version nr-963 or higher. Description The SPA monitoring interaction() call returns a new API object that is bound to the current interaction. New interaction: If the API calls it when New Relic is not currently monitoring an interaction, a new interaction is created. New object: If the API calls it again within the same interaction, a new object referencing the current interaction is created. Parameters The parameters depend on the specific SPA interaction API call. Return values This method returns an API object that is bound to a specific BrowserInteraction event. Each time this method is called for the same BrowserInteraction, a new object is created, but it still references the same interaction. Examples SPA API methods can be used on newrelic.interaction(). The methods can also be used on a handle you assign with a variable. For example: myInteraction = newrelic.interaction() myInteraction.save() Copy The named handle can be saved and used from outside an interaction, but methods will have no effect after the interaction has ended.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 208.48872,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "interaction (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "interaction (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction() Copy Returns a new <em>API</em> object that is bound to the current <em>SPA</em> interaction. Requirements <em>Agent</em> version nr-963 or higher. Description The <em>SPA</em> <em>monitoring</em> interaction() call returns a new <em>API</em> object that is bound to the current interaction. New interaction: If the <em>API</em>"
      },
      "id": "603eb45728ccbc8e2feba779"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/save-browser-spa-api": [
    {
      "sections": [
        "addPageAction (Browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record link clicks (JavaScript)",
        "Record link clicks (jQuery)",
        "Capture form input"
      ],
      "title": "addPageAction (Browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "051774181e5be11026841b52aeb04a693ffad434",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/add-page-action/",
      "published_at": "2021-07-02T08:58:02Z",
      "updated_at": "2021-06-14T23:24:03Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addPageAction(string $name[, JSON object $attributes]) Copy Reports a Browser PageAction event to New Relic One along with a name and optional attributes. Requirements Agent version nr-593 or higher. Description This API call sends a Browser PageAction event with your user-defined name and optional attributes to dashboards, along with several default attributes. This is useful to track any event that is not already tracked automatically by the Browser agent, such as clicking a Subscribe button or accessing a tutorial. PageAction events are sent to New Relic One every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that harvest cycle. Parameters Parameter Description $name string Required. Name or category of the action. Reports to New Relic One as the actionName attribute. Avoid using reserved NRQL words when you name the attribute or value. $attributes JSON object Optional. JSON object with one or more key/value pairs. For example: {key:\"value\"}. The key will report to New Relic One as its own PageAction attribute with the specified values. Avoid using reserved NRQL words when you name the attribute/value. Examples Record link clicks (JavaScript) This example records a PageAction event whenever a user selects the Try Me link. The event is recorded with an actionName of clickedTryMe: < a href=\"/demo\" id=\"try-me\" >Try Me!< /a> <script> document.getElementById('try-me').addEventListener('click',function (e) { newrelic.addPageAction('clickedTryMe'); }) </script> Copy You can then query the number of times the Try Me button was clicked with the following NRQL query: SELECT count(*) FROM PageAction WHERE actionName='clickedTryMe' SINCE 1 hour ago Copy Record link clicks (jQuery) This example sends a PageAction event when a user clicks on an element with the class copy-text. The actionName is copy-text-button and the value is reported as another attribute called Result that corresponds to methods named success and error that handle the outcome. $('.copy-text').click(function (){ var clipboard = new Clipboard ('.copy-text'); clipboard.on('success', function(event) { // Do stuff // Report data to New Relic One if (typeof newrelic == 'object') { newrelic.addPageAction('copy-text-button', {result: 'success'}); } }); clipboard.on('error', function(event) { // Do stuff // Report data to New Relic One if (typeof newrelic == 'object') { newrelic.addPageAction('copy-text-button', {result: 'error'}); } }); }); Copy Then in the query builder, you can create a pie chart to see the breakdown of how many button clicks resulted in success versus error over the past 30 days: SELECT count(*) AS 'Clicks' FROM PageAction WHERE actionName = 'copy-text-button' FACET result SINCE 30 days ago Copy Or you can create a query to see what pages have the most copy button clicks in the last 30 days: SELECT count(*) AS 'Clicks' FROM PageAction WHERE actionName = 'copy-text-button' FACET currentUrl SINCE 30 days ago Copy Capture form input This example captures user input (email addresses) from a form called Signup. The event is recorded with an actionName of userSignup: <form action=\"/signup\" id=\"myform\"> <input id=\"email\" name=\"email\"> <input type=\"submit\" value=\"Signup\"> </form> <script type=\"text/javascript\"> document.getElementById('myform').addEventListener('submit', function (e) { var email = e.target.elements['email'].value; newrelic.addPageAction('userSignup', {email: email}); }) </script> Copy You can then see the emails that you gathered with the following NRQL query: SELECT uniques(email) FROM PageAction WHERE actionName='userSignup' SINCE 1 hour ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 267.33615,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addPageAction (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "sections": "addPageAction (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.addPageAction(string $name[, JSON object $attributes]) Copy Reports a <em>Browser</em> PageAction event to New Relic One along with a name and optional attributes. Requirements <em>Agent</em> version nr-593 or higher. Description This <em>API</em> call sends a <em>Browser</em> PageAction event with your user-defined"
      },
      "id": "60440d4628ccbc14742c60cb"
    },
    {
      "sections": [
        "interaction (Browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Return values",
        "Examples"
      ],
      "title": "interaction (Browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "6656dfeb99f4d3559511a001f951c3c3865129c5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/interaction-browser-spa-api/",
      "published_at": "2021-07-02T09:03:53Z",
      "updated_at": "2021-03-16T08:25:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction() Copy Returns a new API object that is bound to the current SPA interaction. Requirements Agent version nr-963 or higher. Description The SPA monitoring interaction() call returns a new API object that is bound to the current interaction. New interaction: If the API calls it when New Relic is not currently monitoring an interaction, a new interaction is created. New object: If the API calls it again within the same interaction, a new object referencing the current interaction is created. Parameters The parameters depend on the specific SPA interaction API call. Return values This method returns an API object that is bound to a specific BrowserInteraction event. Each time this method is called for the same BrowserInteraction, a new object is created, but it still references the same interaction. Examples SPA API methods can be used on newrelic.interaction(). The methods can also be used on a handle you assign with a variable. For example: myInteraction = newrelic.interaction() myInteraction.save() Copy The named handle can be saved and used from outside an interaction, but methods will have no effect after the interaction has ended.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 208.48872,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "interaction (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "interaction (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction() Copy Returns a new <em>API</em> object that is bound to the current <em>SPA</em> interaction. Requirements <em>Agent</em> version nr-963 or higher. Description The <em>SPA</em> <em>monitoring</em> interaction() call returns a new <em>API</em> object that is bound to the current interaction. New interaction: If the <em>API</em>"
      },
      "id": "603eb45728ccbc8e2feba779"
    },
    {
      "sections": [
        "setCustomAttribute (Browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Get JavaScript/jQuery for HTML elements"
      ],
      "title": "setCustomAttribute (Browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "45236cf5e08fcdc6cc62c2e1807a0ae25b3b1045",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/setcustomattribute-browser-agent-api/",
      "published_at": "2021-07-02T09:06:17Z",
      "updated_at": "2021-03-16T08:25:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.setCustomAttribute(string $name, string OR number $value) Copy Adds a user-defined attribute name and value to subsequent events on the page. Requirements Agent version nr-593 or higher. Description The Browser API call adds a user-defined attribute name and value to subsequent events on the page. Make this call before the window load event fires (when that data is transmitted) in order for the attributes to be included in the PageView event. Once an attribute is set, New Relic One records it with all PageAction events until the page is reloaded or the attribute is manually unset. If you are using SPA monitoring with a compatible agent version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the SPA API will take precedence over these attributes. Errors for custom attributes will be included in events on the JS Errors page. To view or log errors for a custom attribute via API, use the Browser API's noticeError call. Parameters Parameter Description $name string Required. Name of the attribute. Appears as column in the PageView event. It will also appear as a column in the PageAction event if you are using it. Avoid using reserved NRQL words when you name the attribute/value. $value string OR integer Required. Value of the attribute. Appears as the value in the named attribute column in the PageView event. It will appear as a column in the PageAction event if you are using it. Custom attribute values cannot be complex objects, only simple types such as Strings and Integers. Avoid using reserved NRQL words when you name the attribute/value. Examples Get JavaScript/jQuery for HTML elements This example uses JavaScript/jQuery to get the values of the following HTML elements on the Drupal-generated pages for New Relic's Docs site: <link rel=\"shortlink\" href=\"/node/1111\" /> <h1>Using NRQL</h1> New Relic reports them as custom attributes. This is useful to query PageView and PageAction events in New Relic One. var node_id = ''; node_id= jQuery(\"link[rel='shortlink']\").attr(\"href\"); var node_title = ''; node_title= jQuery('h1').text(); if (typeof newrelic == 'object') { newrelic.setCustomAttribute('nodeId', node_id); newrelic.setCustomAttribute('title', node_title); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 208.48872,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "setCustomAttribute (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "sections": "setCustomAttribute (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": " unset. If you are using <em>SPA</em> <em>monitoring</em> with a compatible <em>agent</em> version, attributes set with this call will also be included in newrelic.interaction events. However, attributes set using the <em>SPA</em> <em>API</em> will take precedence over these attributes. Errors for custom attributes will be included in events"
      },
      "id": "6043fe01e7b9d28aff5799e0"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/set-error-handler": [
    {
      "sections": [
        "addPageAction (Browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record link clicks (JavaScript)",
        "Record link clicks (jQuery)",
        "Capture form input"
      ],
      "title": "addPageAction (Browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "051774181e5be11026841b52aeb04a693ffad434",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/add-page-action/",
      "published_at": "2021-07-02T08:58:02Z",
      "updated_at": "2021-06-14T23:24:03Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addPageAction(string $name[, JSON object $attributes]) Copy Reports a Browser PageAction event to New Relic One along with a name and optional attributes. Requirements Agent version nr-593 or higher. Description This API call sends a Browser PageAction event with your user-defined name and optional attributes to dashboards, along with several default attributes. This is useful to track any event that is not already tracked automatically by the Browser agent, such as clicking a Subscribe button or accessing a tutorial. PageAction events are sent to New Relic One every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that harvest cycle. Parameters Parameter Description $name string Required. Name or category of the action. Reports to New Relic One as the actionName attribute. Avoid using reserved NRQL words when you name the attribute or value. $attributes JSON object Optional. JSON object with one or more key/value pairs. For example: {key:\"value\"}. The key will report to New Relic One as its own PageAction attribute with the specified values. Avoid using reserved NRQL words when you name the attribute/value. Examples Record link clicks (JavaScript) This example records a PageAction event whenever a user selects the Try Me link. The event is recorded with an actionName of clickedTryMe: < a href=\"/demo\" id=\"try-me\" >Try Me!< /a> <script> document.getElementById('try-me').addEventListener('click',function (e) { newrelic.addPageAction('clickedTryMe'); }) </script> Copy You can then query the number of times the Try Me button was clicked with the following NRQL query: SELECT count(*) FROM PageAction WHERE actionName='clickedTryMe' SINCE 1 hour ago Copy Record link clicks (jQuery) This example sends a PageAction event when a user clicks on an element with the class copy-text. The actionName is copy-text-button and the value is reported as another attribute called Result that corresponds to methods named success and error that handle the outcome. $('.copy-text').click(function (){ var clipboard = new Clipboard ('.copy-text'); clipboard.on('success', function(event) { // Do stuff // Report data to New Relic One if (typeof newrelic == 'object') { newrelic.addPageAction('copy-text-button', {result: 'success'}); } }); clipboard.on('error', function(event) { // Do stuff // Report data to New Relic One if (typeof newrelic == 'object') { newrelic.addPageAction('copy-text-button', {result: 'error'}); } }); }); Copy Then in the query builder, you can create a pie chart to see the breakdown of how many button clicks resulted in success versus error over the past 30 days: SELECT count(*) AS 'Clicks' FROM PageAction WHERE actionName = 'copy-text-button' FACET result SINCE 30 days ago Copy Or you can create a query to see what pages have the most copy button clicks in the last 30 days: SELECT count(*) AS 'Clicks' FROM PageAction WHERE actionName = 'copy-text-button' FACET currentUrl SINCE 30 days ago Copy Capture form input This example captures user input (email addresses) from a form called Signup. The event is recorded with an actionName of userSignup: <form action=\"/signup\" id=\"myform\"> <input id=\"email\" name=\"email\"> <input type=\"submit\" value=\"Signup\"> </form> <script type=\"text/javascript\"> document.getElementById('myform').addEventListener('submit', function (e) { var email = e.target.elements['email'].value; newrelic.addPageAction('userSignup', {email: email}); }) </script> Copy You can then see the emails that you gathered with the following NRQL query: SELECT uniques(email) FROM PageAction WHERE actionName='userSignup' SINCE 1 hour ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 267.33615,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addPageAction (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "sections": "addPageAction (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.addPageAction(string $name[, JSON object $attributes]) Copy Reports a <em>Browser</em> PageAction event to New Relic One along with a name and optional attributes. Requirements <em>Agent</em> version nr-593 or higher. Description This <em>API</em> call sends a <em>Browser</em> PageAction event with your user-defined"
      },
      "id": "60440d4628ccbc14742c60cb"
    },
    {
      "sections": [
        "save (Browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Return values",
        "Examples"
      ],
      "title": "save (Browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "033ab644ae53188525caa08a438d834b01005189",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/save-browser-spa-api/",
      "published_at": "2021-07-02T09:05:00Z",
      "updated_at": "2021-04-22T09:50:52Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction().save() Copy Ensures a SPA browser interaction will be saved when it ends. Requirements Agent version nr-963 or higher. Description This SPA method ensures a browser interaction will be saved when it ends. Normally an interaction is only saved and sent to New Relic if it is an initial page load or if it results in a URL or hash change. You must call this method to override this behavior and guarantee the interaction will be recorded. Return values This method returns the same API object created by interaction(), which is associated with a BrowserInteraction event. Examples /* window.addEventListener('scroll', () => { if (atBottomOfPage()) { newrelic.interaction() // Start monitoring this interaction. .setName('loadNextPage') // Set name of interaction. .save(); // Ensure that this interaction will be saved as a BrowserInteraction event when it ends. loadNextPage() // Start loading the next page. } }) */ Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 216.62384,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "save (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "save (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction().save() Copy Ensures a <em>SPA</em> <em>browser</em> interaction will be saved when it ends. Requirements <em>Agent</em> version nr-963 or higher. Description This <em>SPA</em> method ensures a <em>browser</em> interaction will be saved when it ends. Normally an interaction is only saved and sent to New Relic"
      },
      "id": "603eb491e7b9d257f92a07f4"
    },
    {
      "sections": [
        "interaction (Browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Return values",
        "Examples"
      ],
      "title": "interaction (Browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "6656dfeb99f4d3559511a001f951c3c3865129c5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/interaction-browser-spa-api/",
      "published_at": "2021-07-02T09:03:53Z",
      "updated_at": "2021-03-16T08:25:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction() Copy Returns a new API object that is bound to the current SPA interaction. Requirements Agent version nr-963 or higher. Description The SPA monitoring interaction() call returns a new API object that is bound to the current interaction. New interaction: If the API calls it when New Relic is not currently monitoring an interaction, a new interaction is created. New object: If the API calls it again within the same interaction, a new object referencing the current interaction is created. Parameters The parameters depend on the specific SPA interaction API call. Return values This method returns an API object that is bound to a specific BrowserInteraction event. Each time this method is called for the same BrowserInteraction, a new object is created, but it still references the same interaction. Examples SPA API methods can be used on newrelic.interaction(). The methods can also be used on a handle you assign with a variable. For example: myInteraction = newrelic.interaction() myInteraction.save() Copy The named handle can be saved and used from outside an interaction, but methods will have no effect after the interaction has ended.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 208.48872,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "interaction (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "interaction (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction() Copy Returns a new <em>API</em> object that is bound to the current <em>SPA</em> interaction. Requirements <em>Agent</em> version nr-963 or higher. Description The <em>SPA</em> <em>monitoring</em> interaction() call returns a new <em>API</em> object that is bound to the current interaction. New interaction: If the <em>API</em>"
      },
      "id": "603eb45728ccbc8e2feba779"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/setattribute-browser-spa-api": [
    {
      "sections": [
        "addPageAction (Browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record link clicks (JavaScript)",
        "Record link clicks (jQuery)",
        "Capture form input"
      ],
      "title": "addPageAction (Browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "051774181e5be11026841b52aeb04a693ffad434",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/add-page-action/",
      "published_at": "2021-07-02T08:58:02Z",
      "updated_at": "2021-06-14T23:24:03Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addPageAction(string $name[, JSON object $attributes]) Copy Reports a Browser PageAction event to New Relic One along with a name and optional attributes. Requirements Agent version nr-593 or higher. Description This API call sends a Browser PageAction event with your user-defined name and optional attributes to dashboards, along with several default attributes. This is useful to track any event that is not already tracked automatically by the Browser agent, such as clicking a Subscribe button or accessing a tutorial. PageAction events are sent to New Relic One every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that harvest cycle. Parameters Parameter Description $name string Required. Name or category of the action. Reports to New Relic One as the actionName attribute. Avoid using reserved NRQL words when you name the attribute or value. $attributes JSON object Optional. JSON object with one or more key/value pairs. For example: {key:\"value\"}. The key will report to New Relic One as its own PageAction attribute with the specified values. Avoid using reserved NRQL words when you name the attribute/value. Examples Record link clicks (JavaScript) This example records a PageAction event whenever a user selects the Try Me link. The event is recorded with an actionName of clickedTryMe: < a href=\"/demo\" id=\"try-me\" >Try Me!< /a> <script> document.getElementById('try-me').addEventListener('click',function (e) { newrelic.addPageAction('clickedTryMe'); }) </script> Copy You can then query the number of times the Try Me button was clicked with the following NRQL query: SELECT count(*) FROM PageAction WHERE actionName='clickedTryMe' SINCE 1 hour ago Copy Record link clicks (jQuery) This example sends a PageAction event when a user clicks on an element with the class copy-text. The actionName is copy-text-button and the value is reported as another attribute called Result that corresponds to methods named success and error that handle the outcome. $('.copy-text').click(function (){ var clipboard = new Clipboard ('.copy-text'); clipboard.on('success', function(event) { // Do stuff // Report data to New Relic One if (typeof newrelic == 'object') { newrelic.addPageAction('copy-text-button', {result: 'success'}); } }); clipboard.on('error', function(event) { // Do stuff // Report data to New Relic One if (typeof newrelic == 'object') { newrelic.addPageAction('copy-text-button', {result: 'error'}); } }); }); Copy Then in the query builder, you can create a pie chart to see the breakdown of how many button clicks resulted in success versus error over the past 30 days: SELECT count(*) AS 'Clicks' FROM PageAction WHERE actionName = 'copy-text-button' FACET result SINCE 30 days ago Copy Or you can create a query to see what pages have the most copy button clicks in the last 30 days: SELECT count(*) AS 'Clicks' FROM PageAction WHERE actionName = 'copy-text-button' FACET currentUrl SINCE 30 days ago Copy Capture form input This example captures user input (email addresses) from a form called Signup. The event is recorded with an actionName of userSignup: <form action=\"/signup\" id=\"myform\"> <input id=\"email\" name=\"email\"> <input type=\"submit\" value=\"Signup\"> </form> <script type=\"text/javascript\"> document.getElementById('myform').addEventListener('submit', function (e) { var email = e.target.elements['email'].value; newrelic.addPageAction('userSignup', {email: email}); }) </script> Copy You can then see the emails that you gathered with the following NRQL query: SELECT uniques(email) FROM PageAction WHERE actionName='userSignup' SINCE 1 hour ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 267.33615,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addPageAction (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "sections": "addPageAction (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.addPageAction(string $name[, JSON object $attributes]) Copy Reports a <em>Browser</em> PageAction event to New Relic One along with a name and optional attributes. Requirements <em>Agent</em> version nr-593 or higher. Description This <em>API</em> call sends a <em>Browser</em> PageAction event with your user-defined"
      },
      "id": "60440d4628ccbc14742c60cb"
    },
    {
      "sections": [
        "save (Browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Return values",
        "Examples"
      ],
      "title": "save (Browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "033ab644ae53188525caa08a438d834b01005189",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/save-browser-spa-api/",
      "published_at": "2021-07-02T09:05:00Z",
      "updated_at": "2021-04-22T09:50:52Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction().save() Copy Ensures a SPA browser interaction will be saved when it ends. Requirements Agent version nr-963 or higher. Description This SPA method ensures a browser interaction will be saved when it ends. Normally an interaction is only saved and sent to New Relic if it is an initial page load or if it results in a URL or hash change. You must call this method to override this behavior and guarantee the interaction will be recorded. Return values This method returns the same API object created by interaction(), which is associated with a BrowserInteraction event. Examples /* window.addEventListener('scroll', () => { if (atBottomOfPage()) { newrelic.interaction() // Start monitoring this interaction. .setName('loadNextPage') // Set name of interaction. .save(); // Ensure that this interaction will be saved as a BrowserInteraction event when it ends. loadNextPage() // Start loading the next page. } }) */ Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 216.62384,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "save (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "save (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction().save() Copy Ensures a <em>SPA</em> <em>browser</em> interaction will be saved when it ends. Requirements <em>Agent</em> version nr-963 or higher. Description This <em>SPA</em> method ensures a <em>browser</em> interaction will be saved when it ends. Normally an interaction is only saved and sent to New Relic"
      },
      "id": "603eb491e7b9d257f92a07f4"
    },
    {
      "sections": [
        "interaction (Browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Return values",
        "Examples"
      ],
      "title": "interaction (Browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "6656dfeb99f4d3559511a001f951c3c3865129c5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/interaction-browser-spa-api/",
      "published_at": "2021-07-02T09:03:53Z",
      "updated_at": "2021-03-16T08:25:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction() Copy Returns a new API object that is bound to the current SPA interaction. Requirements Agent version nr-963 or higher. Description The SPA monitoring interaction() call returns a new API object that is bound to the current interaction. New interaction: If the API calls it when New Relic is not currently monitoring an interaction, a new interaction is created. New object: If the API calls it again within the same interaction, a new object referencing the current interaction is created. Parameters The parameters depend on the specific SPA interaction API call. Return values This method returns an API object that is bound to a specific BrowserInteraction event. Each time this method is called for the same BrowserInteraction, a new object is created, but it still references the same interaction. Examples SPA API methods can be used on newrelic.interaction(). The methods can also be used on a handle you assign with a variable. For example: myInteraction = newrelic.interaction() myInteraction.save() Copy The named handle can be saved and used from outside an interaction, but methods will have no effect after the interaction has ended.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 208.48872,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "interaction (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "interaction (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction() Copy Returns a new <em>API</em> object that is bound to the current <em>SPA</em> interaction. Requirements <em>Agent</em> version nr-963 or higher. Description The <em>SPA</em> <em>monitoring</em> interaction() call returns a new <em>API</em> object that is bound to the current interaction. New interaction: If the <em>API</em>"
      },
      "id": "603eb45728ccbc8e2feba779"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/setcurrentroutename-browser-spa-api": [
    {
      "sections": [
        "addPageAction (Browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record link clicks (JavaScript)",
        "Record link clicks (jQuery)",
        "Capture form input"
      ],
      "title": "addPageAction (Browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "051774181e5be11026841b52aeb04a693ffad434",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/add-page-action/",
      "published_at": "2021-07-02T08:58:02Z",
      "updated_at": "2021-06-14T23:24:03Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addPageAction(string $name[, JSON object $attributes]) Copy Reports a Browser PageAction event to New Relic One along with a name and optional attributes. Requirements Agent version nr-593 or higher. Description This API call sends a Browser PageAction event with your user-defined name and optional attributes to dashboards, along with several default attributes. This is useful to track any event that is not already tracked automatically by the Browser agent, such as clicking a Subscribe button or accessing a tutorial. PageAction events are sent to New Relic One every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that harvest cycle. Parameters Parameter Description $name string Required. Name or category of the action. Reports to New Relic One as the actionName attribute. Avoid using reserved NRQL words when you name the attribute or value. $attributes JSON object Optional. JSON object with one or more key/value pairs. For example: {key:\"value\"}. The key will report to New Relic One as its own PageAction attribute with the specified values. Avoid using reserved NRQL words when you name the attribute/value. Examples Record link clicks (JavaScript) This example records a PageAction event whenever a user selects the Try Me link. The event is recorded with an actionName of clickedTryMe: < a href=\"/demo\" id=\"try-me\" >Try Me!< /a> <script> document.getElementById('try-me').addEventListener('click',function (e) { newrelic.addPageAction('clickedTryMe'); }) </script> Copy You can then query the number of times the Try Me button was clicked with the following NRQL query: SELECT count(*) FROM PageAction WHERE actionName='clickedTryMe' SINCE 1 hour ago Copy Record link clicks (jQuery) This example sends a PageAction event when a user clicks on an element with the class copy-text. The actionName is copy-text-button and the value is reported as another attribute called Result that corresponds to methods named success and error that handle the outcome. $('.copy-text').click(function (){ var clipboard = new Clipboard ('.copy-text'); clipboard.on('success', function(event) { // Do stuff // Report data to New Relic One if (typeof newrelic == 'object') { newrelic.addPageAction('copy-text-button', {result: 'success'}); } }); clipboard.on('error', function(event) { // Do stuff // Report data to New Relic One if (typeof newrelic == 'object') { newrelic.addPageAction('copy-text-button', {result: 'error'}); } }); }); Copy Then in the query builder, you can create a pie chart to see the breakdown of how many button clicks resulted in success versus error over the past 30 days: SELECT count(*) AS 'Clicks' FROM PageAction WHERE actionName = 'copy-text-button' FACET result SINCE 30 days ago Copy Or you can create a query to see what pages have the most copy button clicks in the last 30 days: SELECT count(*) AS 'Clicks' FROM PageAction WHERE actionName = 'copy-text-button' FACET currentUrl SINCE 30 days ago Copy Capture form input This example captures user input (email addresses) from a form called Signup. The event is recorded with an actionName of userSignup: <form action=\"/signup\" id=\"myform\"> <input id=\"email\" name=\"email\"> <input type=\"submit\" value=\"Signup\"> </form> <script type=\"text/javascript\"> document.getElementById('myform').addEventListener('submit', function (e) { var email = e.target.elements['email'].value; newrelic.addPageAction('userSignup', {email: email}); }) </script> Copy You can then see the emails that you gathered with the following NRQL query: SELECT uniques(email) FROM PageAction WHERE actionName='userSignup' SINCE 1 hour ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 267.33612,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addPageAction (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "sections": "addPageAction (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.addPageAction(string $name[, JSON object $attributes]) Copy Reports a <em>Browser</em> PageAction event to New Relic One along with a name and optional attributes. Requirements <em>Agent</em> version nr-593 or higher. Description This <em>API</em> call sends a <em>Browser</em> PageAction event with your user-defined"
      },
      "id": "60440d4628ccbc14742c60cb"
    },
    {
      "sections": [
        "save (Browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Return values",
        "Examples"
      ],
      "title": "save (Browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "033ab644ae53188525caa08a438d834b01005189",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/save-browser-spa-api/",
      "published_at": "2021-07-02T09:05:00Z",
      "updated_at": "2021-04-22T09:50:52Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction().save() Copy Ensures a SPA browser interaction will be saved when it ends. Requirements Agent version nr-963 or higher. Description This SPA method ensures a browser interaction will be saved when it ends. Normally an interaction is only saved and sent to New Relic if it is an initial page load or if it results in a URL or hash change. You must call this method to override this behavior and guarantee the interaction will be recorded. Return values This method returns the same API object created by interaction(), which is associated with a BrowserInteraction event. Examples /* window.addEventListener('scroll', () => { if (atBottomOfPage()) { newrelic.interaction() // Start monitoring this interaction. .setName('loadNextPage') // Set name of interaction. .save(); // Ensure that this interaction will be saved as a BrowserInteraction event when it ends. loadNextPage() // Start loading the next page. } }) */ Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 216.62384,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "save (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "save (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction().save() Copy Ensures a <em>SPA</em> <em>browser</em> interaction will be saved when it ends. Requirements <em>Agent</em> version nr-963 or higher. Description This <em>SPA</em> method ensures a <em>browser</em> interaction will be saved when it ends. Normally an interaction is only saved and sent to New Relic"
      },
      "id": "603eb491e7b9d257f92a07f4"
    },
    {
      "sections": [
        "interaction (Browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Return values",
        "Examples"
      ],
      "title": "interaction (Browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "6656dfeb99f4d3559511a001f951c3c3865129c5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/interaction-browser-spa-api/",
      "published_at": "2021-07-02T09:03:53Z",
      "updated_at": "2021-03-16T08:25:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction() Copy Returns a new API object that is bound to the current SPA interaction. Requirements Agent version nr-963 or higher. Description The SPA monitoring interaction() call returns a new API object that is bound to the current interaction. New interaction: If the API calls it when New Relic is not currently monitoring an interaction, a new interaction is created. New object: If the API calls it again within the same interaction, a new object referencing the current interaction is created. Parameters The parameters depend on the specific SPA interaction API call. Return values This method returns an API object that is bound to a specific BrowserInteraction event. Each time this method is called for the same BrowserInteraction, a new object is created, but it still references the same interaction. Examples SPA API methods can be used on newrelic.interaction(). The methods can also be used on a handle you assign with a variable. For example: myInteraction = newrelic.interaction() myInteraction.save() Copy The named handle can be saved and used from outside an interaction, but methods will have no effect after the interaction has ended.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 208.48872,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "interaction (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "interaction (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction() Copy Returns a new <em>API</em> object that is bound to the current <em>SPA</em> interaction. Requirements <em>Agent</em> version nr-963 or higher. Description The <em>SPA</em> <em>monitoring</em> interaction() call returns a new <em>API</em> object that is bound to the current interaction. New interaction: If the <em>API</em>"
      },
      "id": "603eb45728ccbc8e2feba779"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/setcustomattribute-browser-agent-api": [
    {
      "sections": [
        "addPageAction (Browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record link clicks (JavaScript)",
        "Record link clicks (jQuery)",
        "Capture form input"
      ],
      "title": "addPageAction (Browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "051774181e5be11026841b52aeb04a693ffad434",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/add-page-action/",
      "published_at": "2021-07-02T08:58:02Z",
      "updated_at": "2021-06-14T23:24:03Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addPageAction(string $name[, JSON object $attributes]) Copy Reports a Browser PageAction event to New Relic One along with a name and optional attributes. Requirements Agent version nr-593 or higher. Description This API call sends a Browser PageAction event with your user-defined name and optional attributes to dashboards, along with several default attributes. This is useful to track any event that is not already tracked automatically by the Browser agent, such as clicking a Subscribe button or accessing a tutorial. PageAction events are sent to New Relic One every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that harvest cycle. Parameters Parameter Description $name string Required. Name or category of the action. Reports to New Relic One as the actionName attribute. Avoid using reserved NRQL words when you name the attribute or value. $attributes JSON object Optional. JSON object with one or more key/value pairs. For example: {key:\"value\"}. The key will report to New Relic One as its own PageAction attribute with the specified values. Avoid using reserved NRQL words when you name the attribute/value. Examples Record link clicks (JavaScript) This example records a PageAction event whenever a user selects the Try Me link. The event is recorded with an actionName of clickedTryMe: < a href=\"/demo\" id=\"try-me\" >Try Me!< /a> <script> document.getElementById('try-me').addEventListener('click',function (e) { newrelic.addPageAction('clickedTryMe'); }) </script> Copy You can then query the number of times the Try Me button was clicked with the following NRQL query: SELECT count(*) FROM PageAction WHERE actionName='clickedTryMe' SINCE 1 hour ago Copy Record link clicks (jQuery) This example sends a PageAction event when a user clicks on an element with the class copy-text. The actionName is copy-text-button and the value is reported as another attribute called Result that corresponds to methods named success and error that handle the outcome. $('.copy-text').click(function (){ var clipboard = new Clipboard ('.copy-text'); clipboard.on('success', function(event) { // Do stuff // Report data to New Relic One if (typeof newrelic == 'object') { newrelic.addPageAction('copy-text-button', {result: 'success'}); } }); clipboard.on('error', function(event) { // Do stuff // Report data to New Relic One if (typeof newrelic == 'object') { newrelic.addPageAction('copy-text-button', {result: 'error'}); } }); }); Copy Then in the query builder, you can create a pie chart to see the breakdown of how many button clicks resulted in success versus error over the past 30 days: SELECT count(*) AS 'Clicks' FROM PageAction WHERE actionName = 'copy-text-button' FACET result SINCE 30 days ago Copy Or you can create a query to see what pages have the most copy button clicks in the last 30 days: SELECT count(*) AS 'Clicks' FROM PageAction WHERE actionName = 'copy-text-button' FACET currentUrl SINCE 30 days ago Copy Capture form input This example captures user input (email addresses) from a form called Signup. The event is recorded with an actionName of userSignup: <form action=\"/signup\" id=\"myform\"> <input id=\"email\" name=\"email\"> <input type=\"submit\" value=\"Signup\"> </form> <script type=\"text/javascript\"> document.getElementById('myform').addEventListener('submit', function (e) { var email = e.target.elements['email'].value; newrelic.addPageAction('userSignup', {email: email}); }) </script> Copy You can then see the emails that you gathered with the following NRQL query: SELECT uniques(email) FROM PageAction WHERE actionName='userSignup' SINCE 1 hour ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 267.33612,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addPageAction (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "sections": "addPageAction (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.addPageAction(string $name[, JSON object $attributes]) Copy Reports a <em>Browser</em> PageAction event to New Relic One along with a name and optional attributes. Requirements <em>Agent</em> version nr-593 or higher. Description This <em>API</em> call sends a <em>Browser</em> PageAction event with your user-defined"
      },
      "id": "60440d4628ccbc14742c60cb"
    },
    {
      "sections": [
        "save (Browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Return values",
        "Examples"
      ],
      "title": "save (Browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "033ab644ae53188525caa08a438d834b01005189",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/save-browser-spa-api/",
      "published_at": "2021-07-02T09:05:00Z",
      "updated_at": "2021-04-22T09:50:52Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction().save() Copy Ensures a SPA browser interaction will be saved when it ends. Requirements Agent version nr-963 or higher. Description This SPA method ensures a browser interaction will be saved when it ends. Normally an interaction is only saved and sent to New Relic if it is an initial page load or if it results in a URL or hash change. You must call this method to override this behavior and guarantee the interaction will be recorded. Return values This method returns the same API object created by interaction(), which is associated with a BrowserInteraction event. Examples /* window.addEventListener('scroll', () => { if (atBottomOfPage()) { newrelic.interaction() // Start monitoring this interaction. .setName('loadNextPage') // Set name of interaction. .save(); // Ensure that this interaction will be saved as a BrowserInteraction event when it ends. loadNextPage() // Start loading the next page. } }) */ Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 216.62384,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "save (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "save (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction().save() Copy Ensures a <em>SPA</em> <em>browser</em> interaction will be saved when it ends. Requirements <em>Agent</em> version nr-963 or higher. Description This <em>SPA</em> method ensures a <em>browser</em> interaction will be saved when it ends. Normally an interaction is only saved and sent to New Relic"
      },
      "id": "603eb491e7b9d257f92a07f4"
    },
    {
      "sections": [
        "interaction (Browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Return values",
        "Examples"
      ],
      "title": "interaction (Browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "6656dfeb99f4d3559511a001f951c3c3865129c5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/interaction-browser-spa-api/",
      "published_at": "2021-07-02T09:03:53Z",
      "updated_at": "2021-03-16T08:25:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction() Copy Returns a new API object that is bound to the current SPA interaction. Requirements Agent version nr-963 or higher. Description The SPA monitoring interaction() call returns a new API object that is bound to the current interaction. New interaction: If the API calls it when New Relic is not currently monitoring an interaction, a new interaction is created. New object: If the API calls it again within the same interaction, a new object referencing the current interaction is created. Parameters The parameters depend on the specific SPA interaction API call. Return values This method returns an API object that is bound to a specific BrowserInteraction event. Each time this method is called for the same BrowserInteraction, a new object is created, but it still references the same interaction. Examples SPA API methods can be used on newrelic.interaction(). The methods can also be used on a handle you assign with a variable. For example: myInteraction = newrelic.interaction() myInteraction.save() Copy The named handle can be saved and used from outside an interaction, but methods will have no effect after the interaction has ended.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 208.48872,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "interaction (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "interaction (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction() Copy Returns a new <em>API</em> object that is bound to the current <em>SPA</em> interaction. Requirements <em>Agent</em> version nr-963 or higher. Description The <em>SPA</em> <em>monitoring</em> interaction() call returns a new <em>API</em> object that is bound to the current interaction. New interaction: If the <em>API</em>"
      },
      "id": "603eb45728ccbc8e2feba779"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/setname-browser-spa-api": [
    {
      "sections": [
        "addPageAction (Browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record link clicks (JavaScript)",
        "Record link clicks (jQuery)",
        "Capture form input"
      ],
      "title": "addPageAction (Browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "051774181e5be11026841b52aeb04a693ffad434",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/add-page-action/",
      "published_at": "2021-07-02T08:58:02Z",
      "updated_at": "2021-06-14T23:24:03Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addPageAction(string $name[, JSON object $attributes]) Copy Reports a Browser PageAction event to New Relic One along with a name and optional attributes. Requirements Agent version nr-593 or higher. Description This API call sends a Browser PageAction event with your user-defined name and optional attributes to dashboards, along with several default attributes. This is useful to track any event that is not already tracked automatically by the Browser agent, such as clicking a Subscribe button or accessing a tutorial. PageAction events are sent to New Relic One every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that harvest cycle. Parameters Parameter Description $name string Required. Name or category of the action. Reports to New Relic One as the actionName attribute. Avoid using reserved NRQL words when you name the attribute or value. $attributes JSON object Optional. JSON object with one or more key/value pairs. For example: {key:\"value\"}. The key will report to New Relic One as its own PageAction attribute with the specified values. Avoid using reserved NRQL words when you name the attribute/value. Examples Record link clicks (JavaScript) This example records a PageAction event whenever a user selects the Try Me link. The event is recorded with an actionName of clickedTryMe: < a href=\"/demo\" id=\"try-me\" >Try Me!< /a> <script> document.getElementById('try-me').addEventListener('click',function (e) { newrelic.addPageAction('clickedTryMe'); }) </script> Copy You can then query the number of times the Try Me button was clicked with the following NRQL query: SELECT count(*) FROM PageAction WHERE actionName='clickedTryMe' SINCE 1 hour ago Copy Record link clicks (jQuery) This example sends a PageAction event when a user clicks on an element with the class copy-text. The actionName is copy-text-button and the value is reported as another attribute called Result that corresponds to methods named success and error that handle the outcome. $('.copy-text').click(function (){ var clipboard = new Clipboard ('.copy-text'); clipboard.on('success', function(event) { // Do stuff // Report data to New Relic One if (typeof newrelic == 'object') { newrelic.addPageAction('copy-text-button', {result: 'success'}); } }); clipboard.on('error', function(event) { // Do stuff // Report data to New Relic One if (typeof newrelic == 'object') { newrelic.addPageAction('copy-text-button', {result: 'error'}); } }); }); Copy Then in the query builder, you can create a pie chart to see the breakdown of how many button clicks resulted in success versus error over the past 30 days: SELECT count(*) AS 'Clicks' FROM PageAction WHERE actionName = 'copy-text-button' FACET result SINCE 30 days ago Copy Or you can create a query to see what pages have the most copy button clicks in the last 30 days: SELECT count(*) AS 'Clicks' FROM PageAction WHERE actionName = 'copy-text-button' FACET currentUrl SINCE 30 days ago Copy Capture form input This example captures user input (email addresses) from a form called Signup. The event is recorded with an actionName of userSignup: <form action=\"/signup\" id=\"myform\"> <input id=\"email\" name=\"email\"> <input type=\"submit\" value=\"Signup\"> </form> <script type=\"text/javascript\"> document.getElementById('myform').addEventListener('submit', function (e) { var email = e.target.elements['email'].value; newrelic.addPageAction('userSignup', {email: email}); }) </script> Copy You can then see the emails that you gathered with the following NRQL query: SELECT uniques(email) FROM PageAction WHERE actionName='userSignup' SINCE 1 hour ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 267.3361,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addPageAction (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "sections": "addPageAction (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.addPageAction(string $name[, JSON object $attributes]) Copy Reports a <em>Browser</em> PageAction event to New Relic One along with a name and optional attributes. Requirements <em>Agent</em> version nr-593 or higher. Description This <em>API</em> call sends a <em>Browser</em> PageAction event with your user-defined"
      },
      "id": "60440d4628ccbc14742c60cb"
    },
    {
      "sections": [
        "save (Browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Return values",
        "Examples"
      ],
      "title": "save (Browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "033ab644ae53188525caa08a438d834b01005189",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/save-browser-spa-api/",
      "published_at": "2021-07-02T09:05:00Z",
      "updated_at": "2021-04-22T09:50:52Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction().save() Copy Ensures a SPA browser interaction will be saved when it ends. Requirements Agent version nr-963 or higher. Description This SPA method ensures a browser interaction will be saved when it ends. Normally an interaction is only saved and sent to New Relic if it is an initial page load or if it results in a URL or hash change. You must call this method to override this behavior and guarantee the interaction will be recorded. Return values This method returns the same API object created by interaction(), which is associated with a BrowserInteraction event. Examples /* window.addEventListener('scroll', () => { if (atBottomOfPage()) { newrelic.interaction() // Start monitoring this interaction. .setName('loadNextPage') // Set name of interaction. .save(); // Ensure that this interaction will be saved as a BrowserInteraction event when it ends. loadNextPage() // Start loading the next page. } }) */ Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 216.62383,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "save (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "save (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction().save() Copy Ensures a <em>SPA</em> <em>browser</em> interaction will be saved when it ends. Requirements <em>Agent</em> version nr-963 or higher. Description This <em>SPA</em> method ensures a <em>browser</em> interaction will be saved when it ends. Normally an interaction is only saved and sent to New Relic"
      },
      "id": "603eb491e7b9d257f92a07f4"
    },
    {
      "sections": [
        "interaction (Browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Return values",
        "Examples"
      ],
      "title": "interaction (Browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "6656dfeb99f4d3559511a001f951c3c3865129c5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/interaction-browser-spa-api/",
      "published_at": "2021-07-02T09:03:53Z",
      "updated_at": "2021-03-16T08:25:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction() Copy Returns a new API object that is bound to the current SPA interaction. Requirements Agent version nr-963 or higher. Description The SPA monitoring interaction() call returns a new API object that is bound to the current interaction. New interaction: If the API calls it when New Relic is not currently monitoring an interaction, a new interaction is created. New object: If the API calls it again within the same interaction, a new object referencing the current interaction is created. Parameters The parameters depend on the specific SPA interaction API call. Return values This method returns an API object that is bound to a specific BrowserInteraction event. Each time this method is called for the same BrowserInteraction, a new object is created, but it still references the same interaction. Examples SPA API methods can be used on newrelic.interaction(). The methods can also be used on a handle you assign with a variable. For example: myInteraction = newrelic.interaction() myInteraction.save() Copy The named handle can be saved and used from outside an interaction, but methods will have no effect after the interaction has ended.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 208.48872,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "interaction (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "interaction (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction() Copy Returns a new <em>API</em> object that is bound to the current <em>SPA</em> interaction. Requirements <em>Agent</em> version nr-963 or higher. Description The <em>SPA</em> <em>monitoring</em> interaction() call returns a new <em>API</em> object that is bound to the current interaction. New interaction: If the <em>API</em>"
      },
      "id": "603eb45728ccbc8e2feba779"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/setpageviewname-browser-agent-api": [
    {
      "sections": [
        "addPageAction (Browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record link clicks (JavaScript)",
        "Record link clicks (jQuery)",
        "Capture form input"
      ],
      "title": "addPageAction (Browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "051774181e5be11026841b52aeb04a693ffad434",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/add-page-action/",
      "published_at": "2021-07-02T08:58:02Z",
      "updated_at": "2021-06-14T23:24:03Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addPageAction(string $name[, JSON object $attributes]) Copy Reports a Browser PageAction event to New Relic One along with a name and optional attributes. Requirements Agent version nr-593 or higher. Description This API call sends a Browser PageAction event with your user-defined name and optional attributes to dashboards, along with several default attributes. This is useful to track any event that is not already tracked automatically by the Browser agent, such as clicking a Subscribe button or accessing a tutorial. PageAction events are sent to New Relic One every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that harvest cycle. Parameters Parameter Description $name string Required. Name or category of the action. Reports to New Relic One as the actionName attribute. Avoid using reserved NRQL words when you name the attribute or value. $attributes JSON object Optional. JSON object with one or more key/value pairs. For example: {key:\"value\"}. The key will report to New Relic One as its own PageAction attribute with the specified values. Avoid using reserved NRQL words when you name the attribute/value. Examples Record link clicks (JavaScript) This example records a PageAction event whenever a user selects the Try Me link. The event is recorded with an actionName of clickedTryMe: < a href=\"/demo\" id=\"try-me\" >Try Me!< /a> <script> document.getElementById('try-me').addEventListener('click',function (e) { newrelic.addPageAction('clickedTryMe'); }) </script> Copy You can then query the number of times the Try Me button was clicked with the following NRQL query: SELECT count(*) FROM PageAction WHERE actionName='clickedTryMe' SINCE 1 hour ago Copy Record link clicks (jQuery) This example sends a PageAction event when a user clicks on an element with the class copy-text. The actionName is copy-text-button and the value is reported as another attribute called Result that corresponds to methods named success and error that handle the outcome. $('.copy-text').click(function (){ var clipboard = new Clipboard ('.copy-text'); clipboard.on('success', function(event) { // Do stuff // Report data to New Relic One if (typeof newrelic == 'object') { newrelic.addPageAction('copy-text-button', {result: 'success'}); } }); clipboard.on('error', function(event) { // Do stuff // Report data to New Relic One if (typeof newrelic == 'object') { newrelic.addPageAction('copy-text-button', {result: 'error'}); } }); }); Copy Then in the query builder, you can create a pie chart to see the breakdown of how many button clicks resulted in success versus error over the past 30 days: SELECT count(*) AS 'Clicks' FROM PageAction WHERE actionName = 'copy-text-button' FACET result SINCE 30 days ago Copy Or you can create a query to see what pages have the most copy button clicks in the last 30 days: SELECT count(*) AS 'Clicks' FROM PageAction WHERE actionName = 'copy-text-button' FACET currentUrl SINCE 30 days ago Copy Capture form input This example captures user input (email addresses) from a form called Signup. The event is recorded with an actionName of userSignup: <form action=\"/signup\" id=\"myform\"> <input id=\"email\" name=\"email\"> <input type=\"submit\" value=\"Signup\"> </form> <script type=\"text/javascript\"> document.getElementById('myform').addEventListener('submit', function (e) { var email = e.target.elements['email'].value; newrelic.addPageAction('userSignup', {email: email}); }) </script> Copy You can then see the emails that you gathered with the following NRQL query: SELECT uniques(email) FROM PageAction WHERE actionName='userSignup' SINCE 1 hour ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 267.3361,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addPageAction (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "sections": "addPageAction (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.addPageAction(string $name[, JSON object $attributes]) Copy Reports a <em>Browser</em> PageAction event to New Relic One along with a name and optional attributes. Requirements <em>Agent</em> version nr-593 or higher. Description This <em>API</em> call sends a <em>Browser</em> PageAction event with your user-defined"
      },
      "id": "60440d4628ccbc14742c60cb"
    },
    {
      "sections": [
        "save (Browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Return values",
        "Examples"
      ],
      "title": "save (Browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "033ab644ae53188525caa08a438d834b01005189",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/save-browser-spa-api/",
      "published_at": "2021-07-02T09:05:00Z",
      "updated_at": "2021-04-22T09:50:52Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction().save() Copy Ensures a SPA browser interaction will be saved when it ends. Requirements Agent version nr-963 or higher. Description This SPA method ensures a browser interaction will be saved when it ends. Normally an interaction is only saved and sent to New Relic if it is an initial page load or if it results in a URL or hash change. You must call this method to override this behavior and guarantee the interaction will be recorded. Return values This method returns the same API object created by interaction(), which is associated with a BrowserInteraction event. Examples /* window.addEventListener('scroll', () => { if (atBottomOfPage()) { newrelic.interaction() // Start monitoring this interaction. .setName('loadNextPage') // Set name of interaction. .save(); // Ensure that this interaction will be saved as a BrowserInteraction event when it ends. loadNextPage() // Start loading the next page. } }) */ Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 216.62383,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "save (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "save (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction().save() Copy Ensures a <em>SPA</em> <em>browser</em> interaction will be saved when it ends. Requirements <em>Agent</em> version nr-963 or higher. Description This <em>SPA</em> method ensures a <em>browser</em> interaction will be saved when it ends. Normally an interaction is only saved and sent to New Relic"
      },
      "id": "603eb491e7b9d257f92a07f4"
    },
    {
      "sections": [
        "interaction (Browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Return values",
        "Examples"
      ],
      "title": "interaction (Browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "6656dfeb99f4d3559511a001f951c3c3865129c5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/interaction-browser-spa-api/",
      "published_at": "2021-07-02T09:03:53Z",
      "updated_at": "2021-03-16T08:25:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction() Copy Returns a new API object that is bound to the current SPA interaction. Requirements Agent version nr-963 or higher. Description The SPA monitoring interaction() call returns a new API object that is bound to the current interaction. New interaction: If the API calls it when New Relic is not currently monitoring an interaction, a new interaction is created. New object: If the API calls it again within the same interaction, a new object referencing the current interaction is created. Parameters The parameters depend on the specific SPA interaction API call. Return values This method returns an API object that is bound to a specific BrowserInteraction event. Each time this method is called for the same BrowserInteraction, a new object is created, but it still references the same interaction. Examples SPA API methods can be used on newrelic.interaction(). The methods can also be used on a handle you assign with a variable. For example: myInteraction = newrelic.interaction() myInteraction.save() Copy The named handle can be saved and used from outside an interaction, but methods will have no effect after the interaction has ended.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 208.48872,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "interaction (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "interaction (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction() Copy Returns a new <em>API</em> object that is bound to the current <em>SPA</em> interaction. Requirements <em>Agent</em> version nr-963 or higher. Description The <em>SPA</em> <em>monitoring</em> interaction() call returns a new <em>API</em> object that is bound to the current interaction. New interaction: If the <em>API</em>"
      },
      "id": "603eb45728ccbc8e2feba779"
    }
  ],
  "/docs/browser/new-relic-browser/browser-agent-spa-api/spa-on-end": [
    {
      "sections": [
        "addPageAction (Browser agent API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Examples",
        "Record link clicks (JavaScript)",
        "Record link clicks (jQuery)",
        "Capture form input"
      ],
      "title": "addPageAction (Browser agent API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "051774181e5be11026841b52aeb04a693ffad434",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/add-page-action/",
      "published_at": "2021-07-02T08:58:02Z",
      "updated_at": "2021-06-14T23:24:03Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.addPageAction(string $name[, JSON object $attributes]) Copy Reports a Browser PageAction event to New Relic One along with a name and optional attributes. Requirements Agent version nr-593 or higher. Description This API call sends a Browser PageAction event with your user-defined name and optional attributes to dashboards, along with several default attributes. This is useful to track any event that is not already tracked automatically by the Browser agent, such as clicking a Subscribe button or accessing a tutorial. PageAction events are sent to New Relic One every 30 seconds, with a maximum of 120 events per 30-second harvest cycle, per browser. After the 120-event limit is reached, additional events are not captured for that harvest cycle. Parameters Parameter Description $name string Required. Name or category of the action. Reports to New Relic One as the actionName attribute. Avoid using reserved NRQL words when you name the attribute or value. $attributes JSON object Optional. JSON object with one or more key/value pairs. For example: {key:\"value\"}. The key will report to New Relic One as its own PageAction attribute with the specified values. Avoid using reserved NRQL words when you name the attribute/value. Examples Record link clicks (JavaScript) This example records a PageAction event whenever a user selects the Try Me link. The event is recorded with an actionName of clickedTryMe: < a href=\"/demo\" id=\"try-me\" >Try Me!< /a> <script> document.getElementById('try-me').addEventListener('click',function (e) { newrelic.addPageAction('clickedTryMe'); }) </script> Copy You can then query the number of times the Try Me button was clicked with the following NRQL query: SELECT count(*) FROM PageAction WHERE actionName='clickedTryMe' SINCE 1 hour ago Copy Record link clicks (jQuery) This example sends a PageAction event when a user clicks on an element with the class copy-text. The actionName is copy-text-button and the value is reported as another attribute called Result that corresponds to methods named success and error that handle the outcome. $('.copy-text').click(function (){ var clipboard = new Clipboard ('.copy-text'); clipboard.on('success', function(event) { // Do stuff // Report data to New Relic One if (typeof newrelic == 'object') { newrelic.addPageAction('copy-text-button', {result: 'success'}); } }); clipboard.on('error', function(event) { // Do stuff // Report data to New Relic One if (typeof newrelic == 'object') { newrelic.addPageAction('copy-text-button', {result: 'error'}); } }); }); Copy Then in the query builder, you can create a pie chart to see the breakdown of how many button clicks resulted in success versus error over the past 30 days: SELECT count(*) AS 'Clicks' FROM PageAction WHERE actionName = 'copy-text-button' FACET result SINCE 30 days ago Copy Or you can create a query to see what pages have the most copy button clicks in the last 30 days: SELECT count(*) AS 'Clicks' FROM PageAction WHERE actionName = 'copy-text-button' FACET currentUrl SINCE 30 days ago Copy Capture form input This example captures user input (email addresses) from a form called Signup. The event is recorded with an actionName of userSignup: <form action=\"/signup\" id=\"myform\"> <input id=\"email\" name=\"email\"> <input type=\"submit\" value=\"Signup\"> </form> <script type=\"text/javascript\"> document.getElementById('myform').addEventListener('submit', function (e) { var email = e.target.elements['email'].value; newrelic.addPageAction('userSignup', {email: email}); }) </script> Copy You can then see the emails that you gathered with the following NRQL query: SELECT uniques(email) FROM PageAction WHERE actionName='userSignup' SINCE 1 hour ago Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 267.33606,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "addPageAction (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "sections": "addPageAction (<em>Browser</em> <em>agent</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.addPageAction(string $name[, JSON object $attributes]) Copy Reports a <em>Browser</em> PageAction event to New Relic One along with a name and optional attributes. Requirements <em>Agent</em> version nr-593 or higher. Description This <em>API</em> call sends a <em>Browser</em> PageAction event with your user-defined"
      },
      "id": "60440d4628ccbc14742c60cb"
    },
    {
      "sections": [
        "save (Browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Return values",
        "Examples"
      ],
      "title": "save (Browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "033ab644ae53188525caa08a438d834b01005189",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/save-browser-spa-api/",
      "published_at": "2021-07-02T09:05:00Z",
      "updated_at": "2021-04-22T09:50:52Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction().save() Copy Ensures a SPA browser interaction will be saved when it ends. Requirements Agent version nr-963 or higher. Description This SPA method ensures a browser interaction will be saved when it ends. Normally an interaction is only saved and sent to New Relic if it is an initial page load or if it results in a URL or hash change. You must call this method to override this behavior and guarantee the interaction will be recorded. Return values This method returns the same API object created by interaction(), which is associated with a BrowserInteraction event. Examples /* window.addEventListener('scroll', () => { if (atBottomOfPage()) { newrelic.interaction() // Start monitoring this interaction. .setName('loadNextPage') // Set name of interaction. .save(); // Ensure that this interaction will be saved as a BrowserInteraction event when it ends. loadNextPage() // Start loading the next page. } }) */ Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 216.62383,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "save (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "save (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction().save() Copy Ensures a <em>SPA</em> <em>browser</em> interaction will be saved when it ends. Requirements <em>Agent</em> version nr-963 or higher. Description This <em>SPA</em> method ensures a <em>browser</em> interaction will be saved when it ends. Normally an interaction is only saved and sent to New Relic"
      },
      "id": "603eb491e7b9d257f92a07f4"
    },
    {
      "sections": [
        "interaction (Browser SPA API)",
        "Syntax",
        "Requirements",
        "Description",
        "Parameters",
        "Return values",
        "Examples"
      ],
      "title": "interaction (Browser SPA API)",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser agent and SPA API"
      ],
      "external_id": "6656dfeb99f4d3559511a001f951c3c3865129c5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-agent-spa-api/interaction-browser-spa-api/",
      "published_at": "2021-07-02T09:03:53Z",
      "updated_at": "2021-03-16T08:25:49Z",
      "document_type": "api_doc",
      "popularity": 1,
      "body": "Syntax newrelic.interaction() Copy Returns a new API object that is bound to the current SPA interaction. Requirements Agent version nr-963 or higher. Description The SPA monitoring interaction() call returns a new API object that is bound to the current interaction. New interaction: If the API calls it when New Relic is not currently monitoring an interaction, a new interaction is created. New object: If the API calls it again within the same interaction, a new object referencing the current interaction is created. Parameters The parameters depend on the specific SPA interaction API call. Return values This method returns an API object that is bound to a specific BrowserInteraction event. Each time this method is called for the same BrowserInteraction, a new object is created, but it still references the same interaction. Examples SPA API methods can be used on newrelic.interaction(). The methods can also be used on a handle you assign with a variable. For example: myInteraction = newrelic.interaction() myInteraction.save() Copy The named handle can be saved and used from outside an interaction, but methods will have no effect after the interaction has ended.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 208.48871,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "interaction (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "sections": "interaction (<em>Browser</em> <em>SPA</em> <em>API</em>)",
        "tags": "<em>Browser</em> <em>agent</em> <em>and</em> <em>SPA</em> <em>API</em>",
        "body": "Syntax newrelic.interaction() Copy Returns a new <em>API</em> object that is bound to the current <em>SPA</em> interaction. Requirements <em>Agent</em> version nr-963 or higher. Description The <em>SPA</em> <em>monitoring</em> interaction() call returns a new <em>API</em> object that is bound to the current interaction. New interaction: If the <em>API</em>"
      },
      "id": "603eb45728ccbc8e2feba779"
    }
  ],
  "/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing": [
    {
      "sections": [
        "Filterable Geography: Webpage metrics by location",
        "Contents",
        "Requirements",
        "Factors affecting collected data",
        "View performance data by location",
        "Use map functions",
        "Tip",
        "Examine heat map details",
        "Filter performance metrics",
        "Unsatisfactory network performance by ASN",
        "Page rendering performance during sales promotion",
        "View comparative performance details",
        "Available metrics",
        "Performance and usage ranges",
        "Performance color ranges",
        "Usage color ranges",
        "For more help"
      ],
      "title": "Filterable Geography: Webpage metrics by location",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "6d8527b8a2ead507b7cfa95a87a7c75c567c1ee6",
      "image": "https://docs.newrelic.com/static/01bcd89f3ae221d22e388d936cede641/8c557/screen-browser-filter-geography.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/filterable-geography-webpage-metrics-location/",
      "published_at": "2021-07-02T00:24:05Z",
      "updated_at": "2021-05-16T09:50:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Browser's Filterable Geography page provides a world view with color-coded performance information about cities, regions, and countries anywhere around the world. You can filter and drill down into detailed information, or use your mouse to select or zoom in and out of any location on the map. The enhanced attributes provide deep visibility not only about your end users' experience with page load timing, but also with network performance anywhere around the world. This level of visual detail is especially useful for professionals in IT and Operations to make business decisions about peering agreements and CDN usage. Contents Requirements Your New Relic Browser subscription level and your time picker settings determine what data you can view: Pro or higher: As of January 2016, the Filterable Geography feature automatically appears in your New Relic Browser user interface. No special setup is required. You can view up to eight days of data. Your application must be enabled to send PageView data to New Relic Insights in order to use Filterable Geography. Lite: The Filterable Geography feature appears in your New Relic Browser's UI menu but currently is not available for use. Any subscription level: If you need to use New Relic Browser's legacy Geography feature, you can still view it from your selected browser app. Factors affecting collected data To capture page load timing information, New Relic Browser uses the Navigation Timing API, which most (but not all) browsers support. If the browsers do not support the Navigation Timing API, then New Relic Browser charts and data points can only show the network data they receive for DNS lookup, connection, secure handshake, etc. This may not be 100% of the app's overall traffic. Also, firewalls may have an impact on the geographical data collected about your end users. View performance data by location one.newrelic.com > Browser > (select an app) > Browser app > Filterable Geography: Here is an example of the map before drilling down into detailed information about London, England. To view or sort the performance information by location: Go to one.newrelic.com > Browser > (select an app) > Filterable Geography. Select the type of performance data to view from the dropdown, or use the default Average page load time. To drill down to a specific area, mouse over or select any area on the geographical map, or select any of the ten worst performing locations from the list to the right of the map. To view specific performance metrics, select any of the attributes below the funnel icon. To view comparison data, select the Page load performance or Historical performance chart below the selected location's geographical map. Use map functions Use any of New Relic's standard user interface functions and page functions to drill down into detailed information. Here is a summary of additional options with the Filterable Geography page. If you want to... Do this... Change what kind of performance data appears Select your choice from the dropdown. Default performance indicator is Average page load time. The map's legend lists the ten best or worst performing areas (depending on the selected performance indicator) for the selected time period. For example: If you select Count, the map's legend shows the top ten locations with the highest number of page loads, as well as the average page load time for each. If you select Connection setup, New Relic Browser first filters out areas with low throughput. Then the map's legend shows the top ten locations where average connection time is the slowest, as well as the average page load time and count for each. View summary performance information about a specific location Mouse over any colored area on the map, select a location from the list, or zoom in and out of any area on the map. View detailed data for a location Select any area of the map. For example: If you select Canada, the map and legend show color-coded performance data for each province and territory. The list to the right of the map shows the top ten worst performing areas. If you select a specific province or territory, the map shows color-coded performance data for the top ten cities. The map includes circled locations which you can mouse over or select to view detailed information. In addition, the Page load performance and Historical performance charts below the map automatically update with each location you select. Hide the list of available attributes Select the funnel icon. Return to a larger world view Select another location on the map, or clear the filter labels above the map. Tip To return to the original map view of the world, select any area on an ocean. Examine heat map details one.newrelic.com > Browser > (select an app) > Browser app > Filterable Geography: Here is an example of the map as you use filter and zoom tools to drill down into detailed information about London, England. Athough overall throughput for the area is good (green), the nearby yellow areas, and the smaller red and orange circles indicate nearby cities with varying levels of throughput problems, not the size of those cities. The Filterable Geography heat map identifies performance quality with color and with the size of circles. Heat map Description Color scale Performance quality ranges from green (the best) to yellow, orange, and then red (the worst). When selecting indicators of usage rather than performance, the heat map shows shades of purple, with the darkest shades indicating the highest usage. The color scale adapts to your app's specific performance. Each area is a percentile range. To view the range for each color segment, mouse over the heat map's legend. Thresholds Different thresholds are dynamically applied to the colors based on the type of performance indicator you select from the dropdown and the maximum value your app has reported. For example, green for Average page load time may indicate 0 to 3.3 seconds, while green for Average network time may indicate 0 to 256 milliseconds. Circles The map's colored circles help you identify areas with performance problems at a glance. Each circle's radius is based on throughput reported for the city it represents, not the size of the city itself. You may see many circles overlapping each other. This usually indicates a grouping of metropolitan areas which represent a geographic area of heavy traffic. Filter performance metrics The Filter feature allows you to select and group data by attributes in various categories, including: Page view Geography Browser Identity Custom The filtered results appear on the geographical map, where you can use any of the standard map functions to explore additional details. Here are some examples. Unsatisfactory network performance by ASN In this example, your organization is preparing to renew a peering agreement with the owner of an autonomous system, called \"My-ASN.\" You are concerned that continued outages and other connection issues are affecting customer satisfaction with your site, and you want to compare its performance with other ASNs. You have a New Relic Browser Pro account. Go to one.newrelic.com > Browser > (select an app) > Filterable Geography. From the performance type dropdown, select Connection setup. Select the funnel icon. To view the specific ASN's performance: From the search window, type My-ASN, and then select this name from the Filter by results. OR To compare performance with other ASNs: From Geography attributes > ASN organizations, review the performance data for each organization on the list, and then select Back to groupings list. To close the filter list, select the funnel icon. Follow standard procedures to use the map functions and view comparative performance details. To clear the filter, select the attribute name. Page rendering performance during sales promotion In this example, your organization has a special three-day sales promotion for an upcoming holiday. Your holiday-merchandise page has undergone major changes, including dozens of new images. You want to look for performance problems with page rendering on Android mobile devices during this sales period. You have a New Relic Browser Pro account. Go to one.newrelic.com > Browser > (select an app) > Filterable Geography. Use the time picker to change the date range to the promotion period. From the performance type dropdown, select Page rendering. Select the funnel icon. From Page view attributes > Page Url, select your site's holiday-merchandise page, and then select Back to groupings list. From Browser attributes > User agent OS, select Android, and then select Back to groupings list. To close the filter list, select the funnel icon. Follow standard procedures to use the map functions and view comparative performance details. To clear the filters, select their attribute names. View comparative performance details Charts on the Page load performance and Historical performance tabs automatically refresh with comparative performance details for the selected location. one.newrelic.com > Browser > (select an app) > Browser app > Filterable Geography: Charts on the Page load performance and Historical performance tabs automatically refresh with details for the selected location. The Page load performance tab shows two charts. The Average page load time chart includes: Average page load time for each segment of the page load timing process in seconds Request queuing information (the time after a request enters your production systems and before it reaches your application) if applicable The Average network time chart shows key elements, including how long it takes for DNS lookup, connection establishment, and secure handshake, in seconds. Tip Sometimes areas on the charts may appear to be zero or near zero. This is because some apps use existing TCP connections, and they do not need to establish new connections. The Historical performance tab shows comparison data for the selected time period, yesterday, and last week for the selected location. This includes: Average response time Throughput in pages per minute (ppm) Available metrics You can filter and group geographical performance data in New Relic Browser and in New Relic Insights. Available metrics include: Performance Metrics Webpage Page load time Throughput (pages per minute or ppm) Network time Connection time Secure connection time Network Autonomous system number and name (ASN) via IP mapping SSL negotiation timing DNS timing Time to first byte ASN latitude and longitude for Internet service providers (ISPs) To ensure end user security, New Relic Browser collects GeoIP information for the end user's ISP. New Relic Browser does not collect GeoIP information for the specific end user. For example, if an end user in Portland, Oregon uses an ISP located in Beaverton, Oregon, New Relic Browser collects the GeoIP information for the ISP in Beaverton. User agents Operating systems Browser names or types Browser versions Device types Performance and usage ranges The color-coded legend shows performance and usage as percentile ranges. Performance color ranges Percentile colors for performance range from green (the best) to red (the worst). Performance percentile ranges (best to worst) Green Yellow Orange Red Back-end duration 0-74.9 75-86.9 87-94.9 95+ Connection setup duration 0-96.9 97-97.9 98-98.9 99+ DNS lookup duration 0-96.9 97-97.9 98-98.9 99+ DOM processing duration 0-74.9 75-86.9 87-94.9 95+ Network duration 0-74.9 75-86.9 87-94.9 95+ Page load duration 0-74.9 75-86.9 87-94.9 95+ Page rendering duration 0-74.9 75-86.9 87-94.9 95+ Queue duration 0-74.9 75-86.9 87-94.9 95+ Secure handshake duration 0-96.9 97-97.9 98-98.9 99+ Web app duration 0-74.9 75-86.9 87-94.9 95+ Usage color ranges Percentile colors for usage counts appear as shades of purple, from lightest (lowest usage) to darkest (highest usage). Usage percentile ranges (lowest to highest) Lightest purple Light purple Darker purple Darkest purple Page load count 0-79.9 80-89.9 90-99.9 100 Unique sessions count 0-79.9 80-89.9 90-99.9 100 For more help Additional documentation resources include: Browser Geography (legacy Geography page with Apdex scores and performance information by location) Page views (details about end users' overall experience with your site)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.88419,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Page rendering performance during sales <em>promotion</em>",
        "tags": "<em>Browser</em> <em>Pro</em> <em>features</em>",
        "body": " peering agreements and CDN usage. Contents Requirements Your New Relic <em>Browser</em> subscription level and your time picker settings determine what data you can view: <em>Pro</em> or higher: As of January 2016, the Filterable Geography feature automatically appears in your New Relic <em>Browser</em> user interface"
      },
      "id": "6043fe6f28ccbc910c2c606a"
    },
    {
      "sections": [
        "Session traces: Explore a webpage's life cycle",
        "Identify problems and solutions",
        "Requirements",
        "Select a session trace",
        "Tip",
        "View session trace details",
        "Session segment definitions",
        "Slow JavaScript execution and repainting"
      ],
      "title": "Session traces: Explore a webpage's life cycle",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "2d34d77c7661be3ebd3f04a8188fe36d7233895f",
      "image": "https://docs.newrelic.com/static/a7f12a1603efe1412d15b9a51a312548/c1b63/browser_sessiontraces_overview.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/browser-pro-features/session-traces-explore-webpages-life-cycle/",
      "published_at": "2021-07-02T09:13:21Z",
      "updated_at": "2021-03-16T08:23:46Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's session traces provide a detailed timeline of the load and interaction events during a webpage's full life cycle, for as long as ten minutes. Page load timing, individual asset loads, user interactions, AJAX requests, callbacks, errors, and other events appear in an interactive timeline which includes a detailed waterfall visualization, a heat map overview, and highlighted metrics and problems related to that session. Identify problems and solutions Session traces help you understand: How users experience your page load, including time to DOM load, time waiting for AJAX requests to complete, and the user's interactions with the page How the New Relic metrics reflect your end users' experiences What is the sequence of JavaScript and browser events, which take longer than others, and when each event occurs Where bottlenecks occur, and what may be causing them Why one page load may be slower than others, by providing the context for individual events during a session By connecting performance to user experience and interactions to performance, this detailed and intuitive visualization of all events in the user's session can help pinpoint problem areas and easily identify solutions. Requirements To use Browser monitoring's session traces feature, make sure you meet these requirements: Your agent version must support Browser monitoring. If you're using multiple names for an app, session traces will only report to the most specific application. For accounts older than October 2014, you must enable Browser monitoring and the enhanced Pro features. Browser randomly captures traces only from browsers that support the Resource Timing API. Select a session trace The Session traces index lists the most recent traces based on the time picker selection for the selected app. Session traces are randomly sampled and stored at a rate of 90/hour. You can page through up to 500 traces at a time. Additionally, you can sort and search the list by attributes, including: Full URL, with query string parameters removed Browser type Started at date/time Page load time one.newrelic.com > Browser > (select an app) > Session traces: You can select a session trace from the Browser index. You can also select a session trace directly from the Browser Summary, Page views, JS errors, and AJAX pages. To select a specific session trace: Go to one.newrelic.com and click Browser > (select an app) > Session traces. To locate a session trace from a different date or time period, use the time picker. To limit the index to a specific type of trace, use the search window. To view detailed information, select the session trace's link. Tip You can also select a session trace directly from the Browser Summary, Page views, JS errors and AJAX pages. View session trace details The Session trace details page provides summary information about the trace, a heat map with timing details, and a waterfall of events that you can explore. The color-coded legend identifies the page load events during the webpage's life cycle. For apps that have been deployed using the copy/paste method, Browser monitoring includes web app and queue time in Network time as part of the page load timing process. This is because Browser relies on the server-side agent to pass the application values to the Browser agent through auto-injection. You can view detailed information about how this \"back end\" time breaks down from the browser's point of view. The session traces report on all the network related events available, so you can see on a case-by-case basis how the browser spends time on DNS lookups and other network events. one.newrelic.com > Browser > (select an app) > Session traces > (select a trace): Use Browser's session trace details to examine events and identify problems during the end user's webpage session. To navigate through a session trace, explore the waterfall chart by scrolling vertically through the event stack, or select individual events to view their details. If you want to... Do this... View the web page for this session trace Select the trace link. Jump to a specific time Select the time indicator or event on the heat map. View details about individual events Select any event in the waterfall chart. From there, select View full details if applicable. Change the location on the session trace Click on the heat map, or scroll vertically through the waterfall chart. Zoom in or out of the overall trace Select the plus or minus icons below the heat map. Share the session trace information Create a permalink to paste into a form, ticket, email, etc. Session segment definitions Important session trace measurements are displayed in the upper right corner of the Session traces page. The first four measurements represent how long into a session that the segment ended. For example, if Page Load is 0.202s, that means that the page load event completed 0.202 seconds after the request began. Session segment Description Backend The time from when the request began to when backend activity finished and DOM loading began. DOM processing The time from when the request began to when DOM processing finished. Page load The time from when the request began to when the page load event fired. Waiting on AJAX The time from when the request began to when AJAX activity ended. First interaction The time from when the request began to when the first user activity, like a mouse click or a scroll, was recorded. Duration The total duration of the session. Slow JavaScript execution and repainting Session traces help you identify callbacks in your JavaScript code that execute slowly and block the execution of subsequent calls on the browser's main thread. These calls should execute quickly in order to allow the browser to quickly repaint the page in response to user actions. Session traces highlight any callbacks longer than 33ms. If called in rapid succession (such as inside a requestAnimationFrame loop), callbacks longer than 33ms reduce the frame rate below 30 frames per second. This speed seems sluggish to users.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.56416,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Identify <em>problems</em> and solutions",
        "tags": "<em>Browser</em> <em>Pro</em> <em>features</em>",
        "body": " older than October 2014, you must enable <em>Browser</em> <em>monitoring</em> and the enhanced <em>Pro</em> <em>features</em>. <em>Browser</em> randomly captures traces only from browsers that support the Resource Timing API. Select a session trace The Session traces index lists the most recent traces based on the time picker selection"
      },
      "id": "603ecc4de7b9d2843d2a0806"
    },
    {
      "sections": [
        "Browser error profiles: Find error causes",
        "View error profiles",
        "What are error profiles?",
        "Filter error profile data",
        "Example error profile explanation"
      ],
      "title": "Browser error profiles: Find error causes",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "57a8d5e43d7a661fa9062f4a8bba5eb9fb010c26",
      "image": "https://docs.newrelic.com/static/8cfa0de9d5cab457d02eded9473ee786/d7ab4/Browser-error-profile-example.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-error-profiles-find-error-causes/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-03-16T06:49:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "On Browser monitoring's JS errors UI page, error profiles give you insight about potential causes of your JavaScript errors. View error profiles To view Browser monitoring error profiles: Go to one.newrelic.com and click Browser > (select an app) > JS errors. To see error profile details: At the bottom of the JS errors UI page, select an error profile to expand it. What are error profiles? In Browser monitoring, an error profile is a potentially meaningful correlation New Relic has found between your JavaScript error attribute values when compared to normal PageView events. These correlations help you investigate the causes and contributing factors behind your errors. The screenshot below shows an example of an error profile. This error profile shows that the distribution of the userAgentOS attribute values varies significantly when JS error events are compared to normal (non-error) page view events. To investigate further, you could use the filter to display only Windows errors and see if there are other correlations. You can also filter the data used to generate error profiles to help you narrow down potential causes. For an analysis of a specific error profile, see the example error profile explanation. Filter error profile data To further filter the data used to generate error profiles and their comparison page views, use these JS errors page features: Time picker: select a time range used to generate the data. Filter: use the filter to display only error profiles and page views that have the attribute values you choose. You can select multiple attribute values. Example error profile explanation To help you better understand your own error profile data, this is an explanation of an example error profile's data. This error profile example has had a filter of userAgentName = Chrome applied, so it is only showing error data from Chrome browsers. This example profile has had a filter applied so that it is only showing error data from Chrome browsers. Column explanations: The first column is the attribute column. It shows the attribute values with the most deviation when compared to non-error page views. Less significant attribute values are aggregated in the Other category. In this example, the Chrome versions 36, 64, and 65 make up 100% of the errors for Chrome users. The JS errors column shows what percentage of JavaScriptError events have the attribute values from the first column. This column adds up to 100%, representing all errors from the chosen time range and filter set. In this example, a large percentage of Chrome errors are coming from Chrome version 36. If we wanted to investigate this further, we could filter to only show version 36 data. The Page views column shows what percentage of PageView events have the attribute values from the first column. In this example, less than 1% of Chrome users use Chrome version 36, but 55% of errors are generated by users with that version. The Difference column shows you the difference in percentage between the JS errors column and the Page views column. In this example, the 54% indicates that attribute is 54 percentage points higher for error events than for page views.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.55576,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> error <em>profiles</em>: Find error causes",
        "sections": "<em>Browser</em> error <em>profiles</em>: Find error causes",
        "tags": "<em>Browser</em> <em>Pro</em> <em>features</em>",
        "body": "On <em>Browser</em> <em>monitoring</em>&#x27;s JS errors UI page, error profiles give you insight about potential causes of your JavaScript errors. View error profiles To view <em>Browser</em> <em>monitoring</em> error profiles: Go to one.newrelic.com and click <em>Browser</em> &gt; (select an app) &gt; JS errors. To see error profile details"
      },
      "id": "603e884ce7b9d22e2e2a0815"
    }
  ],
  "/docs/browser/new-relic-browser/browser-pro-features/browser-error-profiles-find-error-causes": [
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 337.36835,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>Pro</em> <em>features</em>",
        "body": " support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for <em>Browser</em> <em>monitoring</em>: Make sure you meet requirements, including having: Full-Stack Observability <em>Browser</em> <em>Pro</em>"
      },
      "id": "6043fe6f196a6784f0960f53"
    },
    {
      "sections": [
        "Filterable Geography: Webpage metrics by location",
        "Contents",
        "Requirements",
        "Factors affecting collected data",
        "View performance data by location",
        "Use map functions",
        "Tip",
        "Examine heat map details",
        "Filter performance metrics",
        "Unsatisfactory network performance by ASN",
        "Page rendering performance during sales promotion",
        "View comparative performance details",
        "Available metrics",
        "Performance and usage ranges",
        "Performance color ranges",
        "Usage color ranges",
        "For more help"
      ],
      "title": "Filterable Geography: Webpage metrics by location",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "6d8527b8a2ead507b7cfa95a87a7c75c567c1ee6",
      "image": "https://docs.newrelic.com/static/01bcd89f3ae221d22e388d936cede641/8c557/screen-browser-filter-geography.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/filterable-geography-webpage-metrics-location/",
      "published_at": "2021-07-02T00:24:05Z",
      "updated_at": "2021-05-16T09:50:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Browser's Filterable Geography page provides a world view with color-coded performance information about cities, regions, and countries anywhere around the world. You can filter and drill down into detailed information, or use your mouse to select or zoom in and out of any location on the map. The enhanced attributes provide deep visibility not only about your end users' experience with page load timing, but also with network performance anywhere around the world. This level of visual detail is especially useful for professionals in IT and Operations to make business decisions about peering agreements and CDN usage. Contents Requirements Your New Relic Browser subscription level and your time picker settings determine what data you can view: Pro or higher: As of January 2016, the Filterable Geography feature automatically appears in your New Relic Browser user interface. No special setup is required. You can view up to eight days of data. Your application must be enabled to send PageView data to New Relic Insights in order to use Filterable Geography. Lite: The Filterable Geography feature appears in your New Relic Browser's UI menu but currently is not available for use. Any subscription level: If you need to use New Relic Browser's legacy Geography feature, you can still view it from your selected browser app. Factors affecting collected data To capture page load timing information, New Relic Browser uses the Navigation Timing API, which most (but not all) browsers support. If the browsers do not support the Navigation Timing API, then New Relic Browser charts and data points can only show the network data they receive for DNS lookup, connection, secure handshake, etc. This may not be 100% of the app's overall traffic. Also, firewalls may have an impact on the geographical data collected about your end users. View performance data by location one.newrelic.com > Browser > (select an app) > Browser app > Filterable Geography: Here is an example of the map before drilling down into detailed information about London, England. To view or sort the performance information by location: Go to one.newrelic.com > Browser > (select an app) > Filterable Geography. Select the type of performance data to view from the dropdown, or use the default Average page load time. To drill down to a specific area, mouse over or select any area on the geographical map, or select any of the ten worst performing locations from the list to the right of the map. To view specific performance metrics, select any of the attributes below the funnel icon. To view comparison data, select the Page load performance or Historical performance chart below the selected location's geographical map. Use map functions Use any of New Relic's standard user interface functions and page functions to drill down into detailed information. Here is a summary of additional options with the Filterable Geography page. If you want to... Do this... Change what kind of performance data appears Select your choice from the dropdown. Default performance indicator is Average page load time. The map's legend lists the ten best or worst performing areas (depending on the selected performance indicator) for the selected time period. For example: If you select Count, the map's legend shows the top ten locations with the highest number of page loads, as well as the average page load time for each. If you select Connection setup, New Relic Browser first filters out areas with low throughput. Then the map's legend shows the top ten locations where average connection time is the slowest, as well as the average page load time and count for each. View summary performance information about a specific location Mouse over any colored area on the map, select a location from the list, or zoom in and out of any area on the map. View detailed data for a location Select any area of the map. For example: If you select Canada, the map and legend show color-coded performance data for each province and territory. The list to the right of the map shows the top ten worst performing areas. If you select a specific province or territory, the map shows color-coded performance data for the top ten cities. The map includes circled locations which you can mouse over or select to view detailed information. In addition, the Page load performance and Historical performance charts below the map automatically update with each location you select. Hide the list of available attributes Select the funnel icon. Return to a larger world view Select another location on the map, or clear the filter labels above the map. Tip To return to the original map view of the world, select any area on an ocean. Examine heat map details one.newrelic.com > Browser > (select an app) > Browser app > Filterable Geography: Here is an example of the map as you use filter and zoom tools to drill down into detailed information about London, England. Athough overall throughput for the area is good (green), the nearby yellow areas, and the smaller red and orange circles indicate nearby cities with varying levels of throughput problems, not the size of those cities. The Filterable Geography heat map identifies performance quality with color and with the size of circles. Heat map Description Color scale Performance quality ranges from green (the best) to yellow, orange, and then red (the worst). When selecting indicators of usage rather than performance, the heat map shows shades of purple, with the darkest shades indicating the highest usage. The color scale adapts to your app's specific performance. Each area is a percentile range. To view the range for each color segment, mouse over the heat map's legend. Thresholds Different thresholds are dynamically applied to the colors based on the type of performance indicator you select from the dropdown and the maximum value your app has reported. For example, green for Average page load time may indicate 0 to 3.3 seconds, while green for Average network time may indicate 0 to 256 milliseconds. Circles The map's colored circles help you identify areas with performance problems at a glance. Each circle's radius is based on throughput reported for the city it represents, not the size of the city itself. You may see many circles overlapping each other. This usually indicates a grouping of metropolitan areas which represent a geographic area of heavy traffic. Filter performance metrics The Filter feature allows you to select and group data by attributes in various categories, including: Page view Geography Browser Identity Custom The filtered results appear on the geographical map, where you can use any of the standard map functions to explore additional details. Here are some examples. Unsatisfactory network performance by ASN In this example, your organization is preparing to renew a peering agreement with the owner of an autonomous system, called \"My-ASN.\" You are concerned that continued outages and other connection issues are affecting customer satisfaction with your site, and you want to compare its performance with other ASNs. You have a New Relic Browser Pro account. Go to one.newrelic.com > Browser > (select an app) > Filterable Geography. From the performance type dropdown, select Connection setup. Select the funnel icon. To view the specific ASN's performance: From the search window, type My-ASN, and then select this name from the Filter by results. OR To compare performance with other ASNs: From Geography attributes > ASN organizations, review the performance data for each organization on the list, and then select Back to groupings list. To close the filter list, select the funnel icon. Follow standard procedures to use the map functions and view comparative performance details. To clear the filter, select the attribute name. Page rendering performance during sales promotion In this example, your organization has a special three-day sales promotion for an upcoming holiday. Your holiday-merchandise page has undergone major changes, including dozens of new images. You want to look for performance problems with page rendering on Android mobile devices during this sales period. You have a New Relic Browser Pro account. Go to one.newrelic.com > Browser > (select an app) > Filterable Geography. Use the time picker to change the date range to the promotion period. From the performance type dropdown, select Page rendering. Select the funnel icon. From Page view attributes > Page Url, select your site's holiday-merchandise page, and then select Back to groupings list. From Browser attributes > User agent OS, select Android, and then select Back to groupings list. To close the filter list, select the funnel icon. Follow standard procedures to use the map functions and view comparative performance details. To clear the filters, select their attribute names. View comparative performance details Charts on the Page load performance and Historical performance tabs automatically refresh with comparative performance details for the selected location. one.newrelic.com > Browser > (select an app) > Browser app > Filterable Geography: Charts on the Page load performance and Historical performance tabs automatically refresh with details for the selected location. The Page load performance tab shows two charts. The Average page load time chart includes: Average page load time for each segment of the page load timing process in seconds Request queuing information (the time after a request enters your production systems and before it reaches your application) if applicable The Average network time chart shows key elements, including how long it takes for DNS lookup, connection establishment, and secure handshake, in seconds. Tip Sometimes areas on the charts may appear to be zero or near zero. This is because some apps use existing TCP connections, and they do not need to establish new connections. The Historical performance tab shows comparison data for the selected time period, yesterday, and last week for the selected location. This includes: Average response time Throughput in pages per minute (ppm) Available metrics You can filter and group geographical performance data in New Relic Browser and in New Relic Insights. Available metrics include: Performance Metrics Webpage Page load time Throughput (pages per minute or ppm) Network time Connection time Secure connection time Network Autonomous system number and name (ASN) via IP mapping SSL negotiation timing DNS timing Time to first byte ASN latitude and longitude for Internet service providers (ISPs) To ensure end user security, New Relic Browser collects GeoIP information for the end user's ISP. New Relic Browser does not collect GeoIP information for the specific end user. For example, if an end user in Portland, Oregon uses an ISP located in Beaverton, Oregon, New Relic Browser collects the GeoIP information for the ISP in Beaverton. User agents Operating systems Browser names or types Browser versions Device types Performance and usage ranges The color-coded legend shows performance and usage as percentile ranges. Performance color ranges Percentile colors for performance range from green (the best) to red (the worst). Performance percentile ranges (best to worst) Green Yellow Orange Red Back-end duration 0-74.9 75-86.9 87-94.9 95+ Connection setup duration 0-96.9 97-97.9 98-98.9 99+ DNS lookup duration 0-96.9 97-97.9 98-98.9 99+ DOM processing duration 0-74.9 75-86.9 87-94.9 95+ Network duration 0-74.9 75-86.9 87-94.9 95+ Page load duration 0-74.9 75-86.9 87-94.9 95+ Page rendering duration 0-74.9 75-86.9 87-94.9 95+ Queue duration 0-74.9 75-86.9 87-94.9 95+ Secure handshake duration 0-96.9 97-97.9 98-98.9 99+ Web app duration 0-74.9 75-86.9 87-94.9 95+ Usage color ranges Percentile colors for usage counts appear as shades of purple, from lightest (lowest usage) to darkest (highest usage). Usage percentile ranges (lowest to highest) Lightest purple Light purple Darker purple Darkest purple Page load count 0-79.9 80-89.9 90-99.9 100 Unique sessions count 0-79.9 80-89.9 90-99.9 100 For more help Additional documentation resources include: Browser Geography (legacy Geography page with Apdex scores and performance information by location) Page views (details about end users' overall experience with your site)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.88419,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Page rendering performance during sales <em>promotion</em>",
        "tags": "<em>Browser</em> <em>Pro</em> <em>features</em>",
        "body": " peering agreements and CDN usage. Contents Requirements Your New Relic <em>Browser</em> subscription level and your time picker settings determine what data you can view: <em>Pro</em> or higher: As of January 2016, the Filterable Geography feature automatically appears in your New Relic <em>Browser</em> user interface"
      },
      "id": "6043fe6f28ccbc910c2c606a"
    },
    {
      "sections": [
        "Session traces: Explore a webpage's life cycle",
        "Identify problems and solutions",
        "Requirements",
        "Select a session trace",
        "Tip",
        "View session trace details",
        "Session segment definitions",
        "Slow JavaScript execution and repainting"
      ],
      "title": "Session traces: Explore a webpage's life cycle",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "2d34d77c7661be3ebd3f04a8188fe36d7233895f",
      "image": "https://docs.newrelic.com/static/a7f12a1603efe1412d15b9a51a312548/c1b63/browser_sessiontraces_overview.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/browser-pro-features/session-traces-explore-webpages-life-cycle/",
      "published_at": "2021-07-02T09:13:21Z",
      "updated_at": "2021-03-16T08:23:46Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's session traces provide a detailed timeline of the load and interaction events during a webpage's full life cycle, for as long as ten minutes. Page load timing, individual asset loads, user interactions, AJAX requests, callbacks, errors, and other events appear in an interactive timeline which includes a detailed waterfall visualization, a heat map overview, and highlighted metrics and problems related to that session. Identify problems and solutions Session traces help you understand: How users experience your page load, including time to DOM load, time waiting for AJAX requests to complete, and the user's interactions with the page How the New Relic metrics reflect your end users' experiences What is the sequence of JavaScript and browser events, which take longer than others, and when each event occurs Where bottlenecks occur, and what may be causing them Why one page load may be slower than others, by providing the context for individual events during a session By connecting performance to user experience and interactions to performance, this detailed and intuitive visualization of all events in the user's session can help pinpoint problem areas and easily identify solutions. Requirements To use Browser monitoring's session traces feature, make sure you meet these requirements: Your agent version must support Browser monitoring. If you're using multiple names for an app, session traces will only report to the most specific application. For accounts older than October 2014, you must enable Browser monitoring and the enhanced Pro features. Browser randomly captures traces only from browsers that support the Resource Timing API. Select a session trace The Session traces index lists the most recent traces based on the time picker selection for the selected app. Session traces are randomly sampled and stored at a rate of 90/hour. You can page through up to 500 traces at a time. Additionally, you can sort and search the list by attributes, including: Full URL, with query string parameters removed Browser type Started at date/time Page load time one.newrelic.com > Browser > (select an app) > Session traces: You can select a session trace from the Browser index. You can also select a session trace directly from the Browser Summary, Page views, JS errors, and AJAX pages. To select a specific session trace: Go to one.newrelic.com and click Browser > (select an app) > Session traces. To locate a session trace from a different date or time period, use the time picker. To limit the index to a specific type of trace, use the search window. To view detailed information, select the session trace's link. Tip You can also select a session trace directly from the Browser Summary, Page views, JS errors and AJAX pages. View session trace details The Session trace details page provides summary information about the trace, a heat map with timing details, and a waterfall of events that you can explore. The color-coded legend identifies the page load events during the webpage's life cycle. For apps that have been deployed using the copy/paste method, Browser monitoring includes web app and queue time in Network time as part of the page load timing process. This is because Browser relies on the server-side agent to pass the application values to the Browser agent through auto-injection. You can view detailed information about how this \"back end\" time breaks down from the browser's point of view. The session traces report on all the network related events available, so you can see on a case-by-case basis how the browser spends time on DNS lookups and other network events. one.newrelic.com > Browser > (select an app) > Session traces > (select a trace): Use Browser's session trace details to examine events and identify problems during the end user's webpage session. To navigate through a session trace, explore the waterfall chart by scrolling vertically through the event stack, or select individual events to view their details. If you want to... Do this... View the web page for this session trace Select the trace link. Jump to a specific time Select the time indicator or event on the heat map. View details about individual events Select any event in the waterfall chart. From there, select View full details if applicable. Change the location on the session trace Click on the heat map, or scroll vertically through the waterfall chart. Zoom in or out of the overall trace Select the plus or minus icons below the heat map. Share the session trace information Create a permalink to paste into a form, ticket, email, etc. Session segment definitions Important session trace measurements are displayed in the upper right corner of the Session traces page. The first four measurements represent how long into a session that the segment ended. For example, if Page Load is 0.202s, that means that the page load event completed 0.202 seconds after the request began. Session segment Description Backend The time from when the request began to when backend activity finished and DOM loading began. DOM processing The time from when the request began to when DOM processing finished. Page load The time from when the request began to when the page load event fired. Waiting on AJAX The time from when the request began to when AJAX activity ended. First interaction The time from when the request began to when the first user activity, like a mouse click or a scroll, was recorded. Duration The total duration of the session. Slow JavaScript execution and repainting Session traces help you identify callbacks in your JavaScript code that execute slowly and block the execution of subsequent calls on the browser's main thread. These calls should execute quickly in order to allow the browser to quickly repaint the page in response to user actions. Session traces highlight any callbacks longer than 33ms. If called in rapid succession (such as inside a requestAnimationFrame loop), callbacks longer than 33ms reduce the frame rate below 30 frames per second. This speed seems sluggish to users.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.56416,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Identify <em>problems</em> and solutions",
        "tags": "<em>Browser</em> <em>Pro</em> <em>features</em>",
        "body": " older than October 2014, you must enable <em>Browser</em> <em>monitoring</em> and the enhanced <em>Pro</em> <em>features</em>. <em>Browser</em> randomly captures traces only from browsers that support the Resource Timing API. Select a session trace The Session traces index lists the most recent traces based on the time picker selection"
      },
      "id": "603ecc4de7b9d2843d2a0806"
    }
  ],
  "/docs/browser/new-relic-browser/browser-pro-features/filterable-geography-webpage-metrics-location": [
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 337.36835,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>Pro</em> <em>features</em>",
        "body": " support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for <em>Browser</em> <em>monitoring</em>: Make sure you meet requirements, including having: Full-Stack Observability <em>Browser</em> <em>Pro</em>"
      },
      "id": "6043fe6f196a6784f0960f53"
    },
    {
      "sections": [
        "Session traces: Explore a webpage's life cycle",
        "Identify problems and solutions",
        "Requirements",
        "Select a session trace",
        "Tip",
        "View session trace details",
        "Session segment definitions",
        "Slow JavaScript execution and repainting"
      ],
      "title": "Session traces: Explore a webpage's life cycle",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "2d34d77c7661be3ebd3f04a8188fe36d7233895f",
      "image": "https://docs.newrelic.com/static/a7f12a1603efe1412d15b9a51a312548/c1b63/browser_sessiontraces_overview.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/browser-pro-features/session-traces-explore-webpages-life-cycle/",
      "published_at": "2021-07-02T09:13:21Z",
      "updated_at": "2021-03-16T08:23:46Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's session traces provide a detailed timeline of the load and interaction events during a webpage's full life cycle, for as long as ten minutes. Page load timing, individual asset loads, user interactions, AJAX requests, callbacks, errors, and other events appear in an interactive timeline which includes a detailed waterfall visualization, a heat map overview, and highlighted metrics and problems related to that session. Identify problems and solutions Session traces help you understand: How users experience your page load, including time to DOM load, time waiting for AJAX requests to complete, and the user's interactions with the page How the New Relic metrics reflect your end users' experiences What is the sequence of JavaScript and browser events, which take longer than others, and when each event occurs Where bottlenecks occur, and what may be causing them Why one page load may be slower than others, by providing the context for individual events during a session By connecting performance to user experience and interactions to performance, this detailed and intuitive visualization of all events in the user's session can help pinpoint problem areas and easily identify solutions. Requirements To use Browser monitoring's session traces feature, make sure you meet these requirements: Your agent version must support Browser monitoring. If you're using multiple names for an app, session traces will only report to the most specific application. For accounts older than October 2014, you must enable Browser monitoring and the enhanced Pro features. Browser randomly captures traces only from browsers that support the Resource Timing API. Select a session trace The Session traces index lists the most recent traces based on the time picker selection for the selected app. Session traces are randomly sampled and stored at a rate of 90/hour. You can page through up to 500 traces at a time. Additionally, you can sort and search the list by attributes, including: Full URL, with query string parameters removed Browser type Started at date/time Page load time one.newrelic.com > Browser > (select an app) > Session traces: You can select a session trace from the Browser index. You can also select a session trace directly from the Browser Summary, Page views, JS errors, and AJAX pages. To select a specific session trace: Go to one.newrelic.com and click Browser > (select an app) > Session traces. To locate a session trace from a different date or time period, use the time picker. To limit the index to a specific type of trace, use the search window. To view detailed information, select the session trace's link. Tip You can also select a session trace directly from the Browser Summary, Page views, JS errors and AJAX pages. View session trace details The Session trace details page provides summary information about the trace, a heat map with timing details, and a waterfall of events that you can explore. The color-coded legend identifies the page load events during the webpage's life cycle. For apps that have been deployed using the copy/paste method, Browser monitoring includes web app and queue time in Network time as part of the page load timing process. This is because Browser relies on the server-side agent to pass the application values to the Browser agent through auto-injection. You can view detailed information about how this \"back end\" time breaks down from the browser's point of view. The session traces report on all the network related events available, so you can see on a case-by-case basis how the browser spends time on DNS lookups and other network events. one.newrelic.com > Browser > (select an app) > Session traces > (select a trace): Use Browser's session trace details to examine events and identify problems during the end user's webpage session. To navigate through a session trace, explore the waterfall chart by scrolling vertically through the event stack, or select individual events to view their details. If you want to... Do this... View the web page for this session trace Select the trace link. Jump to a specific time Select the time indicator or event on the heat map. View details about individual events Select any event in the waterfall chart. From there, select View full details if applicable. Change the location on the session trace Click on the heat map, or scroll vertically through the waterfall chart. Zoom in or out of the overall trace Select the plus or minus icons below the heat map. Share the session trace information Create a permalink to paste into a form, ticket, email, etc. Session segment definitions Important session trace measurements are displayed in the upper right corner of the Session traces page. The first four measurements represent how long into a session that the segment ended. For example, if Page Load is 0.202s, that means that the page load event completed 0.202 seconds after the request began. Session segment Description Backend The time from when the request began to when backend activity finished and DOM loading began. DOM processing The time from when the request began to when DOM processing finished. Page load The time from when the request began to when the page load event fired. Waiting on AJAX The time from when the request began to when AJAX activity ended. First interaction The time from when the request began to when the first user activity, like a mouse click or a scroll, was recorded. Duration The total duration of the session. Slow JavaScript execution and repainting Session traces help you identify callbacks in your JavaScript code that execute slowly and block the execution of subsequent calls on the browser's main thread. These calls should execute quickly in order to allow the browser to quickly repaint the page in response to user actions. Session traces highlight any callbacks longer than 33ms. If called in rapid succession (such as inside a requestAnimationFrame loop), callbacks longer than 33ms reduce the frame rate below 30 frames per second. This speed seems sluggish to users.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.56416,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Identify <em>problems</em> and solutions",
        "tags": "<em>Browser</em> <em>Pro</em> <em>features</em>",
        "body": " older than October 2014, you must enable <em>Browser</em> <em>monitoring</em> and the enhanced <em>Pro</em> <em>features</em>. <em>Browser</em> randomly captures traces only from browsers that support the Resource Timing API. Select a session trace The Session traces index lists the most recent traces based on the time picker selection"
      },
      "id": "603ecc4de7b9d2843d2a0806"
    },
    {
      "sections": [
        "Browser error profiles: Find error causes",
        "View error profiles",
        "What are error profiles?",
        "Filter error profile data",
        "Example error profile explanation"
      ],
      "title": "Browser error profiles: Find error causes",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "57a8d5e43d7a661fa9062f4a8bba5eb9fb010c26",
      "image": "https://docs.newrelic.com/static/8cfa0de9d5cab457d02eded9473ee786/d7ab4/Browser-error-profile-example.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-error-profiles-find-error-causes/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-03-16T06:49:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "On Browser monitoring's JS errors UI page, error profiles give you insight about potential causes of your JavaScript errors. View error profiles To view Browser monitoring error profiles: Go to one.newrelic.com and click Browser > (select an app) > JS errors. To see error profile details: At the bottom of the JS errors UI page, select an error profile to expand it. What are error profiles? In Browser monitoring, an error profile is a potentially meaningful correlation New Relic has found between your JavaScript error attribute values when compared to normal PageView events. These correlations help you investigate the causes and contributing factors behind your errors. The screenshot below shows an example of an error profile. This error profile shows that the distribution of the userAgentOS attribute values varies significantly when JS error events are compared to normal (non-error) page view events. To investigate further, you could use the filter to display only Windows errors and see if there are other correlations. You can also filter the data used to generate error profiles to help you narrow down potential causes. For an analysis of a specific error profile, see the example error profile explanation. Filter error profile data To further filter the data used to generate error profiles and their comparison page views, use these JS errors page features: Time picker: select a time range used to generate the data. Filter: use the filter to display only error profiles and page views that have the attribute values you choose. You can select multiple attribute values. Example error profile explanation To help you better understand your own error profile data, this is an explanation of an example error profile's data. This error profile example has had a filter of userAgentName = Chrome applied, so it is only showing error data from Chrome browsers. This example profile has had a filter applied so that it is only showing error data from Chrome browsers. Column explanations: The first column is the attribute column. It shows the attribute values with the most deviation when compared to non-error page views. Less significant attribute values are aggregated in the Other category. In this example, the Chrome versions 36, 64, and 65 make up 100% of the errors for Chrome users. The JS errors column shows what percentage of JavaScriptError events have the attribute values from the first column. This column adds up to 100%, representing all errors from the chosen time range and filter set. In this example, a large percentage of Chrome errors are coming from Chrome version 36. If we wanted to investigate this further, we could filter to only show version 36 data. The Page views column shows what percentage of PageView events have the attribute values from the first column. In this example, less than 1% of Chrome users use Chrome version 36, but 55% of errors are generated by users with that version. The Difference column shows you the difference in percentage between the JS errors column and the Page views column. In this example, the 54% indicates that attribute is 54 percentage points higher for error events than for page views.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.55576,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> error <em>profiles</em>: Find error causes",
        "sections": "<em>Browser</em> error <em>profiles</em>: Find error causes",
        "tags": "<em>Browser</em> <em>Pro</em> <em>features</em>",
        "body": "On <em>Browser</em> <em>monitoring</em>&#x27;s JS errors UI page, error profiles give you insight about potential causes of your JavaScript errors. View error profiles To view <em>Browser</em> <em>monitoring</em> error profiles: Go to one.newrelic.com and click <em>Browser</em> &gt; (select an app) &gt; JS errors. To see error profile details"
      },
      "id": "603e884ce7b9d22e2e2a0815"
    }
  ],
  "/docs/browser/new-relic-browser/browser-pro-features/javascript-errors-page-detect-analyze-errors": [
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 337.36816,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>Pro</em> <em>features</em>",
        "body": " support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for <em>Browser</em> <em>monitoring</em>: Make sure you meet requirements, including having: Full-Stack Observability <em>Browser</em> <em>Pro</em>"
      },
      "id": "6043fe6f196a6784f0960f53"
    },
    {
      "sections": [
        "Filterable Geography: Webpage metrics by location",
        "Contents",
        "Requirements",
        "Factors affecting collected data",
        "View performance data by location",
        "Use map functions",
        "Tip",
        "Examine heat map details",
        "Filter performance metrics",
        "Unsatisfactory network performance by ASN",
        "Page rendering performance during sales promotion",
        "View comparative performance details",
        "Available metrics",
        "Performance and usage ranges",
        "Performance color ranges",
        "Usage color ranges",
        "For more help"
      ],
      "title": "Filterable Geography: Webpage metrics by location",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "6d8527b8a2ead507b7cfa95a87a7c75c567c1ee6",
      "image": "https://docs.newrelic.com/static/01bcd89f3ae221d22e388d936cede641/8c557/screen-browser-filter-geography.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/filterable-geography-webpage-metrics-location/",
      "published_at": "2021-07-02T00:24:05Z",
      "updated_at": "2021-05-16T09:50:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Browser's Filterable Geography page provides a world view with color-coded performance information about cities, regions, and countries anywhere around the world. You can filter and drill down into detailed information, or use your mouse to select or zoom in and out of any location on the map. The enhanced attributes provide deep visibility not only about your end users' experience with page load timing, but also with network performance anywhere around the world. This level of visual detail is especially useful for professionals in IT and Operations to make business decisions about peering agreements and CDN usage. Contents Requirements Your New Relic Browser subscription level and your time picker settings determine what data you can view: Pro or higher: As of January 2016, the Filterable Geography feature automatically appears in your New Relic Browser user interface. No special setup is required. You can view up to eight days of data. Your application must be enabled to send PageView data to New Relic Insights in order to use Filterable Geography. Lite: The Filterable Geography feature appears in your New Relic Browser's UI menu but currently is not available for use. Any subscription level: If you need to use New Relic Browser's legacy Geography feature, you can still view it from your selected browser app. Factors affecting collected data To capture page load timing information, New Relic Browser uses the Navigation Timing API, which most (but not all) browsers support. If the browsers do not support the Navigation Timing API, then New Relic Browser charts and data points can only show the network data they receive for DNS lookup, connection, secure handshake, etc. This may not be 100% of the app's overall traffic. Also, firewalls may have an impact on the geographical data collected about your end users. View performance data by location one.newrelic.com > Browser > (select an app) > Browser app > Filterable Geography: Here is an example of the map before drilling down into detailed information about London, England. To view or sort the performance information by location: Go to one.newrelic.com > Browser > (select an app) > Filterable Geography. Select the type of performance data to view from the dropdown, or use the default Average page load time. To drill down to a specific area, mouse over or select any area on the geographical map, or select any of the ten worst performing locations from the list to the right of the map. To view specific performance metrics, select any of the attributes below the funnel icon. To view comparison data, select the Page load performance or Historical performance chart below the selected location's geographical map. Use map functions Use any of New Relic's standard user interface functions and page functions to drill down into detailed information. Here is a summary of additional options with the Filterable Geography page. If you want to... Do this... Change what kind of performance data appears Select your choice from the dropdown. Default performance indicator is Average page load time. The map's legend lists the ten best or worst performing areas (depending on the selected performance indicator) for the selected time period. For example: If you select Count, the map's legend shows the top ten locations with the highest number of page loads, as well as the average page load time for each. If you select Connection setup, New Relic Browser first filters out areas with low throughput. Then the map's legend shows the top ten locations where average connection time is the slowest, as well as the average page load time and count for each. View summary performance information about a specific location Mouse over any colored area on the map, select a location from the list, or zoom in and out of any area on the map. View detailed data for a location Select any area of the map. For example: If you select Canada, the map and legend show color-coded performance data for each province and territory. The list to the right of the map shows the top ten worst performing areas. If you select a specific province or territory, the map shows color-coded performance data for the top ten cities. The map includes circled locations which you can mouse over or select to view detailed information. In addition, the Page load performance and Historical performance charts below the map automatically update with each location you select. Hide the list of available attributes Select the funnel icon. Return to a larger world view Select another location on the map, or clear the filter labels above the map. Tip To return to the original map view of the world, select any area on an ocean. Examine heat map details one.newrelic.com > Browser > (select an app) > Browser app > Filterable Geography: Here is an example of the map as you use filter and zoom tools to drill down into detailed information about London, England. Athough overall throughput for the area is good (green), the nearby yellow areas, and the smaller red and orange circles indicate nearby cities with varying levels of throughput problems, not the size of those cities. The Filterable Geography heat map identifies performance quality with color and with the size of circles. Heat map Description Color scale Performance quality ranges from green (the best) to yellow, orange, and then red (the worst). When selecting indicators of usage rather than performance, the heat map shows shades of purple, with the darkest shades indicating the highest usage. The color scale adapts to your app's specific performance. Each area is a percentile range. To view the range for each color segment, mouse over the heat map's legend. Thresholds Different thresholds are dynamically applied to the colors based on the type of performance indicator you select from the dropdown and the maximum value your app has reported. For example, green for Average page load time may indicate 0 to 3.3 seconds, while green for Average network time may indicate 0 to 256 milliseconds. Circles The map's colored circles help you identify areas with performance problems at a glance. Each circle's radius is based on throughput reported for the city it represents, not the size of the city itself. You may see many circles overlapping each other. This usually indicates a grouping of metropolitan areas which represent a geographic area of heavy traffic. Filter performance metrics The Filter feature allows you to select and group data by attributes in various categories, including: Page view Geography Browser Identity Custom The filtered results appear on the geographical map, where you can use any of the standard map functions to explore additional details. Here are some examples. Unsatisfactory network performance by ASN In this example, your organization is preparing to renew a peering agreement with the owner of an autonomous system, called \"My-ASN.\" You are concerned that continued outages and other connection issues are affecting customer satisfaction with your site, and you want to compare its performance with other ASNs. You have a New Relic Browser Pro account. Go to one.newrelic.com > Browser > (select an app) > Filterable Geography. From the performance type dropdown, select Connection setup. Select the funnel icon. To view the specific ASN's performance: From the search window, type My-ASN, and then select this name from the Filter by results. OR To compare performance with other ASNs: From Geography attributes > ASN organizations, review the performance data for each organization on the list, and then select Back to groupings list. To close the filter list, select the funnel icon. Follow standard procedures to use the map functions and view comparative performance details. To clear the filter, select the attribute name. Page rendering performance during sales promotion In this example, your organization has a special three-day sales promotion for an upcoming holiday. Your holiday-merchandise page has undergone major changes, including dozens of new images. You want to look for performance problems with page rendering on Android mobile devices during this sales period. You have a New Relic Browser Pro account. Go to one.newrelic.com > Browser > (select an app) > Filterable Geography. Use the time picker to change the date range to the promotion period. From the performance type dropdown, select Page rendering. Select the funnel icon. From Page view attributes > Page Url, select your site's holiday-merchandise page, and then select Back to groupings list. From Browser attributes > User agent OS, select Android, and then select Back to groupings list. To close the filter list, select the funnel icon. Follow standard procedures to use the map functions and view comparative performance details. To clear the filters, select their attribute names. View comparative performance details Charts on the Page load performance and Historical performance tabs automatically refresh with comparative performance details for the selected location. one.newrelic.com > Browser > (select an app) > Browser app > Filterable Geography: Charts on the Page load performance and Historical performance tabs automatically refresh with details for the selected location. The Page load performance tab shows two charts. The Average page load time chart includes: Average page load time for each segment of the page load timing process in seconds Request queuing information (the time after a request enters your production systems and before it reaches your application) if applicable The Average network time chart shows key elements, including how long it takes for DNS lookup, connection establishment, and secure handshake, in seconds. Tip Sometimes areas on the charts may appear to be zero or near zero. This is because some apps use existing TCP connections, and they do not need to establish new connections. The Historical performance tab shows comparison data for the selected time period, yesterday, and last week for the selected location. This includes: Average response time Throughput in pages per minute (ppm) Available metrics You can filter and group geographical performance data in New Relic Browser and in New Relic Insights. Available metrics include: Performance Metrics Webpage Page load time Throughput (pages per minute or ppm) Network time Connection time Secure connection time Network Autonomous system number and name (ASN) via IP mapping SSL negotiation timing DNS timing Time to first byte ASN latitude and longitude for Internet service providers (ISPs) To ensure end user security, New Relic Browser collects GeoIP information for the end user's ISP. New Relic Browser does not collect GeoIP information for the specific end user. For example, if an end user in Portland, Oregon uses an ISP located in Beaverton, Oregon, New Relic Browser collects the GeoIP information for the ISP in Beaverton. User agents Operating systems Browser names or types Browser versions Device types Performance and usage ranges The color-coded legend shows performance and usage as percentile ranges. Performance color ranges Percentile colors for performance range from green (the best) to red (the worst). Performance percentile ranges (best to worst) Green Yellow Orange Red Back-end duration 0-74.9 75-86.9 87-94.9 95+ Connection setup duration 0-96.9 97-97.9 98-98.9 99+ DNS lookup duration 0-96.9 97-97.9 98-98.9 99+ DOM processing duration 0-74.9 75-86.9 87-94.9 95+ Network duration 0-74.9 75-86.9 87-94.9 95+ Page load duration 0-74.9 75-86.9 87-94.9 95+ Page rendering duration 0-74.9 75-86.9 87-94.9 95+ Queue duration 0-74.9 75-86.9 87-94.9 95+ Secure handshake duration 0-96.9 97-97.9 98-98.9 99+ Web app duration 0-74.9 75-86.9 87-94.9 95+ Usage color ranges Percentile colors for usage counts appear as shades of purple, from lightest (lowest usage) to darkest (highest usage). Usage percentile ranges (lowest to highest) Lightest purple Light purple Darker purple Darkest purple Page load count 0-79.9 80-89.9 90-99.9 100 Unique sessions count 0-79.9 80-89.9 90-99.9 100 For more help Additional documentation resources include: Browser Geography (legacy Geography page with Apdex scores and performance information by location) Page views (details about end users' overall experience with your site)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.88419,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Page rendering performance during sales <em>promotion</em>",
        "tags": "<em>Browser</em> <em>Pro</em> <em>features</em>",
        "body": " peering agreements and CDN usage. Contents Requirements Your New Relic <em>Browser</em> subscription level and your time picker settings determine what data you can view: <em>Pro</em> or higher: As of January 2016, the Filterable Geography feature automatically appears in your New Relic <em>Browser</em> user interface"
      },
      "id": "6043fe6f28ccbc910c2c606a"
    },
    {
      "sections": [
        "Session traces: Explore a webpage's life cycle",
        "Identify problems and solutions",
        "Requirements",
        "Select a session trace",
        "Tip",
        "View session trace details",
        "Session segment definitions",
        "Slow JavaScript execution and repainting"
      ],
      "title": "Session traces: Explore a webpage's life cycle",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "2d34d77c7661be3ebd3f04a8188fe36d7233895f",
      "image": "https://docs.newrelic.com/static/a7f12a1603efe1412d15b9a51a312548/c1b63/browser_sessiontraces_overview.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/browser-pro-features/session-traces-explore-webpages-life-cycle/",
      "published_at": "2021-07-02T09:13:21Z",
      "updated_at": "2021-03-16T08:23:46Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's session traces provide a detailed timeline of the load and interaction events during a webpage's full life cycle, for as long as ten minutes. Page load timing, individual asset loads, user interactions, AJAX requests, callbacks, errors, and other events appear in an interactive timeline which includes a detailed waterfall visualization, a heat map overview, and highlighted metrics and problems related to that session. Identify problems and solutions Session traces help you understand: How users experience your page load, including time to DOM load, time waiting for AJAX requests to complete, and the user's interactions with the page How the New Relic metrics reflect your end users' experiences What is the sequence of JavaScript and browser events, which take longer than others, and when each event occurs Where bottlenecks occur, and what may be causing them Why one page load may be slower than others, by providing the context for individual events during a session By connecting performance to user experience and interactions to performance, this detailed and intuitive visualization of all events in the user's session can help pinpoint problem areas and easily identify solutions. Requirements To use Browser monitoring's session traces feature, make sure you meet these requirements: Your agent version must support Browser monitoring. If you're using multiple names for an app, session traces will only report to the most specific application. For accounts older than October 2014, you must enable Browser monitoring and the enhanced Pro features. Browser randomly captures traces only from browsers that support the Resource Timing API. Select a session trace The Session traces index lists the most recent traces based on the time picker selection for the selected app. Session traces are randomly sampled and stored at a rate of 90/hour. You can page through up to 500 traces at a time. Additionally, you can sort and search the list by attributes, including: Full URL, with query string parameters removed Browser type Started at date/time Page load time one.newrelic.com > Browser > (select an app) > Session traces: You can select a session trace from the Browser index. You can also select a session trace directly from the Browser Summary, Page views, JS errors, and AJAX pages. To select a specific session trace: Go to one.newrelic.com and click Browser > (select an app) > Session traces. To locate a session trace from a different date or time period, use the time picker. To limit the index to a specific type of trace, use the search window. To view detailed information, select the session trace's link. Tip You can also select a session trace directly from the Browser Summary, Page views, JS errors and AJAX pages. View session trace details The Session trace details page provides summary information about the trace, a heat map with timing details, and a waterfall of events that you can explore. The color-coded legend identifies the page load events during the webpage's life cycle. For apps that have been deployed using the copy/paste method, Browser monitoring includes web app and queue time in Network time as part of the page load timing process. This is because Browser relies on the server-side agent to pass the application values to the Browser agent through auto-injection. You can view detailed information about how this \"back end\" time breaks down from the browser's point of view. The session traces report on all the network related events available, so you can see on a case-by-case basis how the browser spends time on DNS lookups and other network events. one.newrelic.com > Browser > (select an app) > Session traces > (select a trace): Use Browser's session trace details to examine events and identify problems during the end user's webpage session. To navigate through a session trace, explore the waterfall chart by scrolling vertically through the event stack, or select individual events to view their details. If you want to... Do this... View the web page for this session trace Select the trace link. Jump to a specific time Select the time indicator or event on the heat map. View details about individual events Select any event in the waterfall chart. From there, select View full details if applicable. Change the location on the session trace Click on the heat map, or scroll vertically through the waterfall chart. Zoom in or out of the overall trace Select the plus or minus icons below the heat map. Share the session trace information Create a permalink to paste into a form, ticket, email, etc. Session segment definitions Important session trace measurements are displayed in the upper right corner of the Session traces page. The first four measurements represent how long into a session that the segment ended. For example, if Page Load is 0.202s, that means that the page load event completed 0.202 seconds after the request began. Session segment Description Backend The time from when the request began to when backend activity finished and DOM loading began. DOM processing The time from when the request began to when DOM processing finished. Page load The time from when the request began to when the page load event fired. Waiting on AJAX The time from when the request began to when AJAX activity ended. First interaction The time from when the request began to when the first user activity, like a mouse click or a scroll, was recorded. Duration The total duration of the session. Slow JavaScript execution and repainting Session traces help you identify callbacks in your JavaScript code that execute slowly and block the execution of subsequent calls on the browser's main thread. These calls should execute quickly in order to allow the browser to quickly repaint the page in response to user actions. Session traces highlight any callbacks longer than 33ms. If called in rapid succession (such as inside a requestAnimationFrame loop), callbacks longer than 33ms reduce the frame rate below 30 frames per second. This speed seems sluggish to users.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.56416,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Identify <em>problems</em> and solutions",
        "tags": "<em>Browser</em> <em>Pro</em> <em>features</em>",
        "body": " older than October 2014, you must enable <em>Browser</em> <em>monitoring</em> and the enhanced <em>Pro</em> <em>features</em>. <em>Browser</em> randomly captures traces only from browsers that support the Resource Timing API. Select a session trace The Session traces index lists the most recent traces based on the time picker selection"
      },
      "id": "603ecc4de7b9d2843d2a0806"
    }
  ],
  "/docs/browser/new-relic-browser/browser-pro-features/upload-source-maps-api": [
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 337.36816,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>Pro</em> <em>features</em>",
        "body": " support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for <em>Browser</em> <em>monitoring</em>: Make sure you meet requirements, including having: Full-Stack Observability <em>Browser</em> <em>Pro</em>"
      },
      "id": "6043fe6f196a6784f0960f53"
    },
    {
      "sections": [
        "Filterable Geography: Webpage metrics by location",
        "Contents",
        "Requirements",
        "Factors affecting collected data",
        "View performance data by location",
        "Use map functions",
        "Tip",
        "Examine heat map details",
        "Filter performance metrics",
        "Unsatisfactory network performance by ASN",
        "Page rendering performance during sales promotion",
        "View comparative performance details",
        "Available metrics",
        "Performance and usage ranges",
        "Performance color ranges",
        "Usage color ranges",
        "For more help"
      ],
      "title": "Filterable Geography: Webpage metrics by location",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "6d8527b8a2ead507b7cfa95a87a7c75c567c1ee6",
      "image": "https://docs.newrelic.com/static/01bcd89f3ae221d22e388d936cede641/8c557/screen-browser-filter-geography.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/filterable-geography-webpage-metrics-location/",
      "published_at": "2021-07-02T00:24:05Z",
      "updated_at": "2021-05-16T09:50:14Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic Browser's Filterable Geography page provides a world view with color-coded performance information about cities, regions, and countries anywhere around the world. You can filter and drill down into detailed information, or use your mouse to select or zoom in and out of any location on the map. The enhanced attributes provide deep visibility not only about your end users' experience with page load timing, but also with network performance anywhere around the world. This level of visual detail is especially useful for professionals in IT and Operations to make business decisions about peering agreements and CDN usage. Contents Requirements Your New Relic Browser subscription level and your time picker settings determine what data you can view: Pro or higher: As of January 2016, the Filterable Geography feature automatically appears in your New Relic Browser user interface. No special setup is required. You can view up to eight days of data. Your application must be enabled to send PageView data to New Relic Insights in order to use Filterable Geography. Lite: The Filterable Geography feature appears in your New Relic Browser's UI menu but currently is not available for use. Any subscription level: If you need to use New Relic Browser's legacy Geography feature, you can still view it from your selected browser app. Factors affecting collected data To capture page load timing information, New Relic Browser uses the Navigation Timing API, which most (but not all) browsers support. If the browsers do not support the Navigation Timing API, then New Relic Browser charts and data points can only show the network data they receive for DNS lookup, connection, secure handshake, etc. This may not be 100% of the app's overall traffic. Also, firewalls may have an impact on the geographical data collected about your end users. View performance data by location one.newrelic.com > Browser > (select an app) > Browser app > Filterable Geography: Here is an example of the map before drilling down into detailed information about London, England. To view or sort the performance information by location: Go to one.newrelic.com > Browser > (select an app) > Filterable Geography. Select the type of performance data to view from the dropdown, or use the default Average page load time. To drill down to a specific area, mouse over or select any area on the geographical map, or select any of the ten worst performing locations from the list to the right of the map. To view specific performance metrics, select any of the attributes below the funnel icon. To view comparison data, select the Page load performance or Historical performance chart below the selected location's geographical map. Use map functions Use any of New Relic's standard user interface functions and page functions to drill down into detailed information. Here is a summary of additional options with the Filterable Geography page. If you want to... Do this... Change what kind of performance data appears Select your choice from the dropdown. Default performance indicator is Average page load time. The map's legend lists the ten best or worst performing areas (depending on the selected performance indicator) for the selected time period. For example: If you select Count, the map's legend shows the top ten locations with the highest number of page loads, as well as the average page load time for each. If you select Connection setup, New Relic Browser first filters out areas with low throughput. Then the map's legend shows the top ten locations where average connection time is the slowest, as well as the average page load time and count for each. View summary performance information about a specific location Mouse over any colored area on the map, select a location from the list, or zoom in and out of any area on the map. View detailed data for a location Select any area of the map. For example: If you select Canada, the map and legend show color-coded performance data for each province and territory. The list to the right of the map shows the top ten worst performing areas. If you select a specific province or territory, the map shows color-coded performance data for the top ten cities. The map includes circled locations which you can mouse over or select to view detailed information. In addition, the Page load performance and Historical performance charts below the map automatically update with each location you select. Hide the list of available attributes Select the funnel icon. Return to a larger world view Select another location on the map, or clear the filter labels above the map. Tip To return to the original map view of the world, select any area on an ocean. Examine heat map details one.newrelic.com > Browser > (select an app) > Browser app > Filterable Geography: Here is an example of the map as you use filter and zoom tools to drill down into detailed information about London, England. Athough overall throughput for the area is good (green), the nearby yellow areas, and the smaller red and orange circles indicate nearby cities with varying levels of throughput problems, not the size of those cities. The Filterable Geography heat map identifies performance quality with color and with the size of circles. Heat map Description Color scale Performance quality ranges from green (the best) to yellow, orange, and then red (the worst). When selecting indicators of usage rather than performance, the heat map shows shades of purple, with the darkest shades indicating the highest usage. The color scale adapts to your app's specific performance. Each area is a percentile range. To view the range for each color segment, mouse over the heat map's legend. Thresholds Different thresholds are dynamically applied to the colors based on the type of performance indicator you select from the dropdown and the maximum value your app has reported. For example, green for Average page load time may indicate 0 to 3.3 seconds, while green for Average network time may indicate 0 to 256 milliseconds. Circles The map's colored circles help you identify areas with performance problems at a glance. Each circle's radius is based on throughput reported for the city it represents, not the size of the city itself. You may see many circles overlapping each other. This usually indicates a grouping of metropolitan areas which represent a geographic area of heavy traffic. Filter performance metrics The Filter feature allows you to select and group data by attributes in various categories, including: Page view Geography Browser Identity Custom The filtered results appear on the geographical map, where you can use any of the standard map functions to explore additional details. Here are some examples. Unsatisfactory network performance by ASN In this example, your organization is preparing to renew a peering agreement with the owner of an autonomous system, called \"My-ASN.\" You are concerned that continued outages and other connection issues are affecting customer satisfaction with your site, and you want to compare its performance with other ASNs. You have a New Relic Browser Pro account. Go to one.newrelic.com > Browser > (select an app) > Filterable Geography. From the performance type dropdown, select Connection setup. Select the funnel icon. To view the specific ASN's performance: From the search window, type My-ASN, and then select this name from the Filter by results. OR To compare performance with other ASNs: From Geography attributes > ASN organizations, review the performance data for each organization on the list, and then select Back to groupings list. To close the filter list, select the funnel icon. Follow standard procedures to use the map functions and view comparative performance details. To clear the filter, select the attribute name. Page rendering performance during sales promotion In this example, your organization has a special three-day sales promotion for an upcoming holiday. Your holiday-merchandise page has undergone major changes, including dozens of new images. You want to look for performance problems with page rendering on Android mobile devices during this sales period. You have a New Relic Browser Pro account. Go to one.newrelic.com > Browser > (select an app) > Filterable Geography. Use the time picker to change the date range to the promotion period. From the performance type dropdown, select Page rendering. Select the funnel icon. From Page view attributes > Page Url, select your site's holiday-merchandise page, and then select Back to groupings list. From Browser attributes > User agent OS, select Android, and then select Back to groupings list. To close the filter list, select the funnel icon. Follow standard procedures to use the map functions and view comparative performance details. To clear the filters, select their attribute names. View comparative performance details Charts on the Page load performance and Historical performance tabs automatically refresh with comparative performance details for the selected location. one.newrelic.com > Browser > (select an app) > Browser app > Filterable Geography: Charts on the Page load performance and Historical performance tabs automatically refresh with details for the selected location. The Page load performance tab shows two charts. The Average page load time chart includes: Average page load time for each segment of the page load timing process in seconds Request queuing information (the time after a request enters your production systems and before it reaches your application) if applicable The Average network time chart shows key elements, including how long it takes for DNS lookup, connection establishment, and secure handshake, in seconds. Tip Sometimes areas on the charts may appear to be zero or near zero. This is because some apps use existing TCP connections, and they do not need to establish new connections. The Historical performance tab shows comparison data for the selected time period, yesterday, and last week for the selected location. This includes: Average response time Throughput in pages per minute (ppm) Available metrics You can filter and group geographical performance data in New Relic Browser and in New Relic Insights. Available metrics include: Performance Metrics Webpage Page load time Throughput (pages per minute or ppm) Network time Connection time Secure connection time Network Autonomous system number and name (ASN) via IP mapping SSL negotiation timing DNS timing Time to first byte ASN latitude and longitude for Internet service providers (ISPs) To ensure end user security, New Relic Browser collects GeoIP information for the end user's ISP. New Relic Browser does not collect GeoIP information for the specific end user. For example, if an end user in Portland, Oregon uses an ISP located in Beaverton, Oregon, New Relic Browser collects the GeoIP information for the ISP in Beaverton. User agents Operating systems Browser names or types Browser versions Device types Performance and usage ranges The color-coded legend shows performance and usage as percentile ranges. Performance color ranges Percentile colors for performance range from green (the best) to red (the worst). Performance percentile ranges (best to worst) Green Yellow Orange Red Back-end duration 0-74.9 75-86.9 87-94.9 95+ Connection setup duration 0-96.9 97-97.9 98-98.9 99+ DNS lookup duration 0-96.9 97-97.9 98-98.9 99+ DOM processing duration 0-74.9 75-86.9 87-94.9 95+ Network duration 0-74.9 75-86.9 87-94.9 95+ Page load duration 0-74.9 75-86.9 87-94.9 95+ Page rendering duration 0-74.9 75-86.9 87-94.9 95+ Queue duration 0-74.9 75-86.9 87-94.9 95+ Secure handshake duration 0-96.9 97-97.9 98-98.9 99+ Web app duration 0-74.9 75-86.9 87-94.9 95+ Usage color ranges Percentile colors for usage counts appear as shades of purple, from lightest (lowest usage) to darkest (highest usage). Usage percentile ranges (lowest to highest) Lightest purple Light purple Darker purple Darkest purple Page load count 0-79.9 80-89.9 90-99.9 100 Unique sessions count 0-79.9 80-89.9 90-99.9 100 For more help Additional documentation resources include: Browser Geography (legacy Geography page with Apdex scores and performance information by location) Page views (details about end users' overall experience with your site)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 194.88419,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Page rendering performance during sales <em>promotion</em>",
        "tags": "<em>Browser</em> <em>Pro</em> <em>features</em>",
        "body": " peering agreements and CDN usage. Contents Requirements Your New Relic <em>Browser</em> subscription level and your time picker settings determine what data you can view: <em>Pro</em> or higher: As of January 2016, the Filterable Geography feature automatically appears in your New Relic <em>Browser</em> user interface"
      },
      "id": "6043fe6f28ccbc910c2c606a"
    },
    {
      "sections": [
        "Session traces: Explore a webpage's life cycle",
        "Identify problems and solutions",
        "Requirements",
        "Select a session trace",
        "Tip",
        "View session trace details",
        "Session segment definitions",
        "Slow JavaScript execution and repainting"
      ],
      "title": "Session traces: Explore a webpage's life cycle",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "2d34d77c7661be3ebd3f04a8188fe36d7233895f",
      "image": "https://docs.newrelic.com/static/a7f12a1603efe1412d15b9a51a312548/c1b63/browser_sessiontraces_overview.png",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/browser-pro-features/session-traces-explore-webpages-life-cycle/",
      "published_at": "2021-07-02T09:13:21Z",
      "updated_at": "2021-03-16T08:23:46Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's session traces provide a detailed timeline of the load and interaction events during a webpage's full life cycle, for as long as ten minutes. Page load timing, individual asset loads, user interactions, AJAX requests, callbacks, errors, and other events appear in an interactive timeline which includes a detailed waterfall visualization, a heat map overview, and highlighted metrics and problems related to that session. Identify problems and solutions Session traces help you understand: How users experience your page load, including time to DOM load, time waiting for AJAX requests to complete, and the user's interactions with the page How the New Relic metrics reflect your end users' experiences What is the sequence of JavaScript and browser events, which take longer than others, and when each event occurs Where bottlenecks occur, and what may be causing them Why one page load may be slower than others, by providing the context for individual events during a session By connecting performance to user experience and interactions to performance, this detailed and intuitive visualization of all events in the user's session can help pinpoint problem areas and easily identify solutions. Requirements To use Browser monitoring's session traces feature, make sure you meet these requirements: Your agent version must support Browser monitoring. If you're using multiple names for an app, session traces will only report to the most specific application. For accounts older than October 2014, you must enable Browser monitoring and the enhanced Pro features. Browser randomly captures traces only from browsers that support the Resource Timing API. Select a session trace The Session traces index lists the most recent traces based on the time picker selection for the selected app. Session traces are randomly sampled and stored at a rate of 90/hour. You can page through up to 500 traces at a time. Additionally, you can sort and search the list by attributes, including: Full URL, with query string parameters removed Browser type Started at date/time Page load time one.newrelic.com > Browser > (select an app) > Session traces: You can select a session trace from the Browser index. You can also select a session trace directly from the Browser Summary, Page views, JS errors, and AJAX pages. To select a specific session trace: Go to one.newrelic.com and click Browser > (select an app) > Session traces. To locate a session trace from a different date or time period, use the time picker. To limit the index to a specific type of trace, use the search window. To view detailed information, select the session trace's link. Tip You can also select a session trace directly from the Browser Summary, Page views, JS errors and AJAX pages. View session trace details The Session trace details page provides summary information about the trace, a heat map with timing details, and a waterfall of events that you can explore. The color-coded legend identifies the page load events during the webpage's life cycle. For apps that have been deployed using the copy/paste method, Browser monitoring includes web app and queue time in Network time as part of the page load timing process. This is because Browser relies on the server-side agent to pass the application values to the Browser agent through auto-injection. You can view detailed information about how this \"back end\" time breaks down from the browser's point of view. The session traces report on all the network related events available, so you can see on a case-by-case basis how the browser spends time on DNS lookups and other network events. one.newrelic.com > Browser > (select an app) > Session traces > (select a trace): Use Browser's session trace details to examine events and identify problems during the end user's webpage session. To navigate through a session trace, explore the waterfall chart by scrolling vertically through the event stack, or select individual events to view their details. If you want to... Do this... View the web page for this session trace Select the trace link. Jump to a specific time Select the time indicator or event on the heat map. View details about individual events Select any event in the waterfall chart. From there, select View full details if applicable. Change the location on the session trace Click on the heat map, or scroll vertically through the waterfall chart. Zoom in or out of the overall trace Select the plus or minus icons below the heat map. Share the session trace information Create a permalink to paste into a form, ticket, email, etc. Session segment definitions Important session trace measurements are displayed in the upper right corner of the Session traces page. The first four measurements represent how long into a session that the segment ended. For example, if Page Load is 0.202s, that means that the page load event completed 0.202 seconds after the request began. Session segment Description Backend The time from when the request began to when backend activity finished and DOM loading began. DOM processing The time from when the request began to when DOM processing finished. Page load The time from when the request began to when the page load event fired. Waiting on AJAX The time from when the request began to when AJAX activity ended. First interaction The time from when the request began to when the first user activity, like a mouse click or a scroll, was recorded. Duration The total duration of the session. Slow JavaScript execution and repainting Session traces help you identify callbacks in your JavaScript code that execute slowly and block the execution of subsequent calls on the browser's main thread. These calls should execute quickly in order to allow the browser to quickly repaint the page in response to user actions. Session traces highlight any callbacks longer than 33ms. If called in rapid succession (such as inside a requestAnimationFrame loop), callbacks longer than 33ms reduce the frame rate below 30 frames per second. This speed seems sluggish to users.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.56416,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Identify <em>problems</em> and solutions",
        "tags": "<em>Browser</em> <em>Pro</em> <em>features</em>",
        "body": " older than October 2014, you must enable <em>Browser</em> <em>monitoring</em> and the enhanced <em>Pro</em> <em>features</em>. <em>Browser</em> randomly captures traces only from browsers that support the Resource Timing API. Select a session trace The Session traces index lists the most recent traces based on the time picker selection"
      },
      "id": "603ecc4de7b9d2843d2a0806"
    }
  ],
  "/docs/browser/new-relic-browser/configuration/browser-settings-ui-options-apdex-geography": [
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 177.84988,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "If you use <em>Browser</em> to <em>monitor</em> end-user <em>browser</em> activity, you can now see end-user-originating <em>browser</em>-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data"
      },
      "id": "6043fe6f196a6784f0960f53"
    },
    {
      "sections": [
        "Collect custom attributes",
        "Requirements",
        "APM: Record custom attributes",
        "Important",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "Browser monitoring: Record custom attributes",
        "Infrastructure monitoring: Record custom attributes",
        "Mobile monitoring: Record custom attributes",
        "For more help"
      ],
      "title": "Collect custom attributes",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Install and configure"
      ],
      "external_id": "ad362b1a5cf3a5661eb416584fd9c79db064f539",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/data/customize-data/collect-custom-attributes/",
      "published_at": "2021-07-02T19:49:53Z",
      "updated_at": "2021-07-02T19:49:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some New Relic solutions, one way to report custom data to New Relic is to use custom attributes. For example, for New Relic browser monitoring, you might create a custom attribute to track the user name associated with a slow or failing request. Requirements Custom attributes are available for these New Relic solutions: APM Browser monitoring Mobile monitoring Infrastructure monitoring For other custom data solutions, see Intro to custom data. APM: Record custom attributes Important Review the list of reserved terms used by NRQL. Using reserved terms can cause issues. To enable and use custom attributes for APM, follow the procedure for your APM agent: C SDK To add custom attributes to applications monitored by the C SDK, call one of the attribute functions; for example, newrelic_add_attribute_double(). The key name for your custom attribute depends on what you specify when you call the function. Go Custom attribute collection is enabled by default in the Go agent. However, you can disable custom attribute collection. Java Custom attribute collection is enabled by default in Java. You can collect custom attributes using XML and the Java agent APIs. These two methods can be used in conjunction with each other. Method How to do it Specify attributes in XML XML allows you to specify custom attributes without changing any of your source code. You can have multiple XML files for custom attributes that are grouped by some logical facet. To set custom attributes for your Java app via XML: Review the New Relic Java agent's documentation about XML file format, methods and classes, and examples. From your Extensions directory within the New Relic Java agent, create a single XML file. Define the methods you want New Relic to monitor by editing your XML file directly. Define an XML instrumentation file using the New Relic UI. This may require additional config in the common: block of your newrelic.yml. See Report custom attributes under Instrumentation options for more detail. Call the agent's API Example 1: Adding custom attributes to transactions To collect custom attributes using the agent's API, call the relevant methods: For each method you want to record an attribute for, call NewRelic.addCustomParameter(...). Optional: Include or exclude certain attributes with attributes.include and attributes.exclude. For example, to record a variable named userId, include this code in the parent method: NewRelic.addCustomParameter(\"userId\", userId); Copy Example 2: Adding custom attributes to spans in distributed traces To collect custom attributes using the agent's API, call the relevant methods: For each span (currently executing method) that you want to record an attribute for, call NewRelic.getAgent().getTracedMethod().addCustomAttribute(...). Optional: Include or exclude certain attributes with span_events.attributes.include and span_events.attributes.exclude. For example, to record a variable named userId on the current span, include this code in the associated method: NewRelic.getAgent().getTracedMethod().addCustomAttribute(\"userId\", userId); Copy Collect user attributes The Java agent also includes a built-in mechanism to enable user attributes and collect user information from HttpServletRequest.getUserPrincipal() as custom attributes. .NET Custom attribute collection is enabled by default in .NET. To collect custom attributes, call the relevant API methods: For each method for which you want to record an attribute, call AddCustomAttribute. Optional: Include or exclude attributes with the include and exclude configuration options. For example, to record attributes for a coupon code (string) and an item ID code (number), you could include this code in the parent method: IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction .AddCustomAttribute(\"Discount Code\", \"Summer Super Sale\") .AddCustomAttribute(\"Item Code\", 31456); Copy Node.js Custom attribute collection is enabled by default in Node.js. To collect custom attributes, call the relevant API method: For each attribute you want to record, call newrelic.addCustomAttribute. To record multiple attributes using a single call, use newrelic.addCustomAttributes. For example, to record attributes for a coupon code and an item ID code, you could include this in the parent method: newrelic.addCustomAttributes({ \"Discount Code\": \"Summer Super Sale\", \"Item Code\": 31456 }); Copy PHP Custom attribute collection is enabled by default in PHP. To collect custom attributes, call the relevant API method for each method that you want to record an attribute; newrelic_add_custom_parameter for transaction events and spans newrelic_add_custom_span_parameter for only spans For example, to record a variable named $userId, include this code in the parent method: newrelic_add_custom_parameter ('userID', $userId) Copy Python Custom attribute collection is enabled by default in Python. To collect custom attributes, call add_custom_parameter for each method that you want to record an attribute. For example, to record a variable named user_id, include this code in the parent method: newrelic.agent.add_custom_parameter('user_id', user_id) Copy Ruby Custom attribute collection is enabled by default in Ruby. To collect custom attributes, call the relevant API methods: For Ruby agent version 3.12.0 or higher, use the add_custom_attributes method. For example, to record a variable named @user_id, include this code in the parent method: ::NewRelic::Agent.add_custom_attributes({ user_id: @user.id }) Copy For Ruby agent version 3.11.2 or lower, use the add_custom_parameters method. For example, to record a variable named @user_id, include this code in the parent method: ::NewRelic::Agent.add_custom_parameters({ user_id: @user.id }) Copy Browser monitoring: Record custom attributes The browser agent provides an API to specify extra details associated with a page view or browser interaction, either by forwarding attributes from APM to browser monitoring or by specifying custom attributes through JavaScript. Values forwarded from the APM agent are encoded and injected into browser attributes by our browser agent. Infrastructure monitoring: Record custom attributes Our Infrastructure monitoring lets you create custom attributes that are used to annotate the data from the infrastructure agent. You can use this metadata to build filter sets, group your results, and annotate your data. Mobile monitoring: Record custom attributes Mobile agents include API calls to record custom attributes: For an overview of mobile monitoring custom data, see Insert custom events and attributes Android method: setAttribute iOS method: setAttribute For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.55345,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Browser</em> <em>monitoring</em>: Record custom attributes",
        "tags": "Install and <em>configure</em>",
        "body": "For some New Relic solutions, one way to report custom data to New Relic is to use custom attributes. For example, for New Relic <em>browser</em> <em>monitoring</em>, you might create a custom attribute to track the user name associated with a slow or failing request. Requirements Custom attributes are available"
      },
      "id": "603eb9a3196a67a990a83da5"
    },
    {
      "sections": [
        "Install the browser monitoring agent",
        "Tip",
        "Select a deployment option",
        "Important",
        "Enable an APM-monitored app",
        "Enable with copy/paste",
        "Instrument webpages using the APM agent",
        "Troubleshoot Browser agent installation"
      ],
      "title": "Install the browser monitoring agent",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Installation"
      ],
      "external_id": "bc45bbc86cd4d8b81367ad0904907ddc735717f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/installation/install-browser-monitoring-agent/",
      "published_at": "2021-07-02T09:15:35Z",
      "updated_at": "2021-06-14T21:26:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser uses a JavaScript snippet (or \"agent\") to instrument your app's webpages. The JavaScript collects data for browser monitoring. To install the browser agent, you can choose from a number of deployment options. Tip To use Browser and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Select a deployment option No matter which option you use to deploy browser monitoring, the end result is to inject the browser agent's JavaScript snippet into your pages for browser monitoring. The method you select depends on your preferences and business needs. To view the procedure to install and enable the browser agent, click the link for the option you want to use. You can also use the Browser Application settings page to update settings. Important The following configuration options refer only to the browser monitoring agent. These are not the same as the New Relic user roles and editions. Browser deployment option Description Use the APM agent to inject the JavaScript You can use an APM agent to automatically inject the browser monitoring JavaScript snippet for you. This is the easiest way to install the agent for an app that already is being monitored by APM. (APM-monitored apps are listed on your APM Applications index.) Paste the JavaScript snippet into a webpage This allows you to control the exact placement of the JavaScript into your app's webpage(s) by copying and pasting the browser agent's JavaScript snippet. This is useful for: Standalone apps, static sites, and cached pages delivered by CDN APM apps that are not as closely coupled to the browser app as with a standard server-side app (for example, when your client-side app talks to a REST API back end) Enable single-page app (SPA) monitoring Enabling SPA requires a Pro + SPA browser agent subscription, and you may need to re-deploy the browser JavaScript agent. Use the REST API The REST API lets you manage deployment outside the browser UI. This is useful for large organizations deploying multiple apps. Use an APM agent API to manually instrument the JavaScript snippet For apps that are monitored by APM, you can use the APM agent's API to inject the JavaScript manually instead of automatically. Enable an APM-monitored app Use this procedure to automatically deploy the browser agent on an app that is monitored by APM: Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Enable via New Relic APM. In the Choose your instrumentation section, select Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Select your application section, type or use the search window to find an app's name. Click Enable. Important Node.js: To finish enabling the browser agent for a Node.js app, follow the additional procedure to insert the JavaScript header into the beginning of your HTML page's head tag. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. Enable with copy/paste Use this procedure to insert browser's JavaScript snippet for browser monitoring into your app's webpages yourself. This option is useful for monitoring static sites (such as Jekyll) or cached pages delivered by CDN. Tip Near the bottom of the generated JavaScript is your browser license key and application ID. This is useful with the REST API and API Explorer. Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Copy/Paste JavaScript Code. In the Choose your instrumentation section, select the type of agent: Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Name your app section, name your app: If your app is monitored by APM, select Yes, then type or use the search window to find the app's name. If you have a standalone app for Browser (not monitored by APM), select No, then type the app's name. Click Enable. A new section, Instrument the agent, opens on the page with JavaScript code for your project. Copy the code snippet, then paste it inline into your pages as close to the top of the <head> element as possible, but after any position-sensitive <meta> tags (for example, X-UA-Compatible or charset information). For more information on the inline head placement, see JavaScript placement requirements. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. If you use the copy/paste method, but don't finish the setup process, you can still view and copy the generated JavaScript snippet from your app's Browser Application settings page or by using the REST API (v2). Instrument webpages using the APM agent This information applies to apps that are also monitored by APM. New Relic's agents can instrument webpages with the required JavaScript for page load timing. If you use the APM agent to add the JavaScript snippet to your webpages, insert the instrumentation snippet as close to the top as possible. This allows you to take advantage of detailed information about browser's AJAX calls and JavaScript errors. For more information, see the instructions for your APM agent: C SDK Go Java .NET Node.js PHP Python Ruby Troubleshoot Browser agent installation When you enable browser Pro features for session traces, AJAX calls, or JavaScript errors, it may take approximately five minutes before information becomes available. If you have problems with your browser installation or if no data appears after five minutes, refer to the troubleshooting tips, and restart your agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.36885,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install the <em>browser</em> <em>monitoring</em> agent",
        "sections": "Install the <em>browser</em> <em>monitoring</em> agent",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " The following <em>configuration</em> options refer only to the <em>browser</em> <em>monitoring</em> agent. These are not the same as the New Relic user roles and editions. <em>Browser</em> deployment option Description Use the APM agent to inject the JavaScript You can use an APM agent to automatically inject the <em>browser</em> <em>monitoring</em> JavaScript"
      },
      "id": "604429e628ccbcb80b2c60d0"
    }
  ],
  "/docs/browser/new-relic-browser/configuration/group-browser-metrics-urls": [
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 177.8498,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "If you use <em>Browser</em> to <em>monitor</em> end-user <em>browser</em> activity, you can now see end-user-originating <em>browser</em>-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data"
      },
      "id": "6043fe6f196a6784f0960f53"
    },
    {
      "sections": [
        "Collect custom attributes",
        "Requirements",
        "APM: Record custom attributes",
        "Important",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "Browser monitoring: Record custom attributes",
        "Infrastructure monitoring: Record custom attributes",
        "Mobile monitoring: Record custom attributes",
        "For more help"
      ],
      "title": "Collect custom attributes",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Install and configure"
      ],
      "external_id": "ad362b1a5cf3a5661eb416584fd9c79db064f539",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/data/customize-data/collect-custom-attributes/",
      "published_at": "2021-07-02T19:49:53Z",
      "updated_at": "2021-07-02T19:49:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some New Relic solutions, one way to report custom data to New Relic is to use custom attributes. For example, for New Relic browser monitoring, you might create a custom attribute to track the user name associated with a slow or failing request. Requirements Custom attributes are available for these New Relic solutions: APM Browser monitoring Mobile monitoring Infrastructure monitoring For other custom data solutions, see Intro to custom data. APM: Record custom attributes Important Review the list of reserved terms used by NRQL. Using reserved terms can cause issues. To enable and use custom attributes for APM, follow the procedure for your APM agent: C SDK To add custom attributes to applications monitored by the C SDK, call one of the attribute functions; for example, newrelic_add_attribute_double(). The key name for your custom attribute depends on what you specify when you call the function. Go Custom attribute collection is enabled by default in the Go agent. However, you can disable custom attribute collection. Java Custom attribute collection is enabled by default in Java. You can collect custom attributes using XML and the Java agent APIs. These two methods can be used in conjunction with each other. Method How to do it Specify attributes in XML XML allows you to specify custom attributes without changing any of your source code. You can have multiple XML files for custom attributes that are grouped by some logical facet. To set custom attributes for your Java app via XML: Review the New Relic Java agent's documentation about XML file format, methods and classes, and examples. From your Extensions directory within the New Relic Java agent, create a single XML file. Define the methods you want New Relic to monitor by editing your XML file directly. Define an XML instrumentation file using the New Relic UI. This may require additional config in the common: block of your newrelic.yml. See Report custom attributes under Instrumentation options for more detail. Call the agent's API Example 1: Adding custom attributes to transactions To collect custom attributes using the agent's API, call the relevant methods: For each method you want to record an attribute for, call NewRelic.addCustomParameter(...). Optional: Include or exclude certain attributes with attributes.include and attributes.exclude. For example, to record a variable named userId, include this code in the parent method: NewRelic.addCustomParameter(\"userId\", userId); Copy Example 2: Adding custom attributes to spans in distributed traces To collect custom attributes using the agent's API, call the relevant methods: For each span (currently executing method) that you want to record an attribute for, call NewRelic.getAgent().getTracedMethod().addCustomAttribute(...). Optional: Include or exclude certain attributes with span_events.attributes.include and span_events.attributes.exclude. For example, to record a variable named userId on the current span, include this code in the associated method: NewRelic.getAgent().getTracedMethod().addCustomAttribute(\"userId\", userId); Copy Collect user attributes The Java agent also includes a built-in mechanism to enable user attributes and collect user information from HttpServletRequest.getUserPrincipal() as custom attributes. .NET Custom attribute collection is enabled by default in .NET. To collect custom attributes, call the relevant API methods: For each method for which you want to record an attribute, call AddCustomAttribute. Optional: Include or exclude attributes with the include and exclude configuration options. For example, to record attributes for a coupon code (string) and an item ID code (number), you could include this code in the parent method: IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction .AddCustomAttribute(\"Discount Code\", \"Summer Super Sale\") .AddCustomAttribute(\"Item Code\", 31456); Copy Node.js Custom attribute collection is enabled by default in Node.js. To collect custom attributes, call the relevant API method: For each attribute you want to record, call newrelic.addCustomAttribute. To record multiple attributes using a single call, use newrelic.addCustomAttributes. For example, to record attributes for a coupon code and an item ID code, you could include this in the parent method: newrelic.addCustomAttributes({ \"Discount Code\": \"Summer Super Sale\", \"Item Code\": 31456 }); Copy PHP Custom attribute collection is enabled by default in PHP. To collect custom attributes, call the relevant API method for each method that you want to record an attribute; newrelic_add_custom_parameter for transaction events and spans newrelic_add_custom_span_parameter for only spans For example, to record a variable named $userId, include this code in the parent method: newrelic_add_custom_parameter ('userID', $userId) Copy Python Custom attribute collection is enabled by default in Python. To collect custom attributes, call add_custom_parameter for each method that you want to record an attribute. For example, to record a variable named user_id, include this code in the parent method: newrelic.agent.add_custom_parameter('user_id', user_id) Copy Ruby Custom attribute collection is enabled by default in Ruby. To collect custom attributes, call the relevant API methods: For Ruby agent version 3.12.0 or higher, use the add_custom_attributes method. For example, to record a variable named @user_id, include this code in the parent method: ::NewRelic::Agent.add_custom_attributes({ user_id: @user.id }) Copy For Ruby agent version 3.11.2 or lower, use the add_custom_parameters method. For example, to record a variable named @user_id, include this code in the parent method: ::NewRelic::Agent.add_custom_parameters({ user_id: @user.id }) Copy Browser monitoring: Record custom attributes The browser agent provides an API to specify extra details associated with a page view or browser interaction, either by forwarding attributes from APM to browser monitoring or by specifying custom attributes through JavaScript. Values forwarded from the APM agent are encoded and injected into browser attributes by our browser agent. Infrastructure monitoring: Record custom attributes Our Infrastructure monitoring lets you create custom attributes that are used to annotate the data from the infrastructure agent. You can use this metadata to build filter sets, group your results, and annotate your data. Mobile monitoring: Record custom attributes Mobile agents include API calls to record custom attributes: For an overview of mobile monitoring custom data, see Insert custom events and attributes Android method: setAttribute iOS method: setAttribute For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.55336,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Browser</em> <em>monitoring</em>: Record custom attributes",
        "tags": "Install and <em>configure</em>",
        "body": "For some New Relic solutions, one way to report custom data to New Relic is to use custom attributes. For example, for New Relic <em>browser</em> <em>monitoring</em>, you might create a custom attribute to track the user name associated with a slow or failing request. Requirements Custom attributes are available"
      },
      "id": "603eb9a3196a67a990a83da5"
    },
    {
      "sections": [
        "Install the browser monitoring agent",
        "Tip",
        "Select a deployment option",
        "Important",
        "Enable an APM-monitored app",
        "Enable with copy/paste",
        "Instrument webpages using the APM agent",
        "Troubleshoot Browser agent installation"
      ],
      "title": "Install the browser monitoring agent",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Installation"
      ],
      "external_id": "bc45bbc86cd4d8b81367ad0904907ddc735717f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/installation/install-browser-monitoring-agent/",
      "published_at": "2021-07-02T09:15:35Z",
      "updated_at": "2021-06-14T21:26:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser uses a JavaScript snippet (or \"agent\") to instrument your app's webpages. The JavaScript collects data for browser monitoring. To install the browser agent, you can choose from a number of deployment options. Tip To use Browser and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Select a deployment option No matter which option you use to deploy browser monitoring, the end result is to inject the browser agent's JavaScript snippet into your pages for browser monitoring. The method you select depends on your preferences and business needs. To view the procedure to install and enable the browser agent, click the link for the option you want to use. You can also use the Browser Application settings page to update settings. Important The following configuration options refer only to the browser monitoring agent. These are not the same as the New Relic user roles and editions. Browser deployment option Description Use the APM agent to inject the JavaScript You can use an APM agent to automatically inject the browser monitoring JavaScript snippet for you. This is the easiest way to install the agent for an app that already is being monitored by APM. (APM-monitored apps are listed on your APM Applications index.) Paste the JavaScript snippet into a webpage This allows you to control the exact placement of the JavaScript into your app's webpage(s) by copying and pasting the browser agent's JavaScript snippet. This is useful for: Standalone apps, static sites, and cached pages delivered by CDN APM apps that are not as closely coupled to the browser app as with a standard server-side app (for example, when your client-side app talks to a REST API back end) Enable single-page app (SPA) monitoring Enabling SPA requires a Pro + SPA browser agent subscription, and you may need to re-deploy the browser JavaScript agent. Use the REST API The REST API lets you manage deployment outside the browser UI. This is useful for large organizations deploying multiple apps. Use an APM agent API to manually instrument the JavaScript snippet For apps that are monitored by APM, you can use the APM agent's API to inject the JavaScript manually instead of automatically. Enable an APM-monitored app Use this procedure to automatically deploy the browser agent on an app that is monitored by APM: Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Enable via New Relic APM. In the Choose your instrumentation section, select Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Select your application section, type or use the search window to find an app's name. Click Enable. Important Node.js: To finish enabling the browser agent for a Node.js app, follow the additional procedure to insert the JavaScript header into the beginning of your HTML page's head tag. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. Enable with copy/paste Use this procedure to insert browser's JavaScript snippet for browser monitoring into your app's webpages yourself. This option is useful for monitoring static sites (such as Jekyll) or cached pages delivered by CDN. Tip Near the bottom of the generated JavaScript is your browser license key and application ID. This is useful with the REST API and API Explorer. Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Copy/Paste JavaScript Code. In the Choose your instrumentation section, select the type of agent: Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Name your app section, name your app: If your app is monitored by APM, select Yes, then type or use the search window to find the app's name. If you have a standalone app for Browser (not monitored by APM), select No, then type the app's name. Click Enable. A new section, Instrument the agent, opens on the page with JavaScript code for your project. Copy the code snippet, then paste it inline into your pages as close to the top of the <head> element as possible, but after any position-sensitive <meta> tags (for example, X-UA-Compatible or charset information). For more information on the inline head placement, see JavaScript placement requirements. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. If you use the copy/paste method, but don't finish the setup process, you can still view and copy the generated JavaScript snippet from your app's Browser Application settings page or by using the REST API (v2). Instrument webpages using the APM agent This information applies to apps that are also monitored by APM. New Relic's agents can instrument webpages with the required JavaScript for page load timing. If you use the APM agent to add the JavaScript snippet to your webpages, insert the instrumentation snippet as close to the top as possible. This allows you to take advantage of detailed information about browser's AJAX calls and JavaScript errors. For more information, see the instructions for your APM agent: C SDK Go Java .NET Node.js PHP Python Ruby Troubleshoot Browser agent installation When you enable browser Pro features for session traces, AJAX calls, or JavaScript errors, it may take approximately five minutes before information becomes available. If you have problems with your browser installation or if no data appears after five minutes, refer to the troubleshooting tips, and restart your agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.368835,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install the <em>browser</em> <em>monitoring</em> agent",
        "sections": "Install the <em>browser</em> <em>monitoring</em> agent",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " The following <em>configuration</em> options refer only to the <em>browser</em> <em>monitoring</em> agent. These are not the same as the New Relic user roles and editions. <em>Browser</em> deployment option Description Use the APM agent to inject the JavaScript You can use an APM agent to automatically inject the <em>browser</em> <em>monitoring</em> JavaScript"
      },
      "id": "604429e628ccbcb80b2c60d0"
    }
  ],
  "/docs/browser/new-relic-browser/configuration/monitor-or-block-specific-domains-subdomains": [
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 177.8498,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "If you use <em>Browser</em> to <em>monitor</em> end-user <em>browser</em> activity, you can now see end-user-originating <em>browser</em>-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data"
      },
      "id": "6043fe6f196a6784f0960f53"
    },
    {
      "sections": [
        "Collect custom attributes",
        "Requirements",
        "APM: Record custom attributes",
        "Important",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "Browser monitoring: Record custom attributes",
        "Infrastructure monitoring: Record custom attributes",
        "Mobile monitoring: Record custom attributes",
        "For more help"
      ],
      "title": "Collect custom attributes",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Install and configure"
      ],
      "external_id": "ad362b1a5cf3a5661eb416584fd9c79db064f539",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/data/customize-data/collect-custom-attributes/",
      "published_at": "2021-07-02T19:49:53Z",
      "updated_at": "2021-07-02T19:49:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some New Relic solutions, one way to report custom data to New Relic is to use custom attributes. For example, for New Relic browser monitoring, you might create a custom attribute to track the user name associated with a slow or failing request. Requirements Custom attributes are available for these New Relic solutions: APM Browser monitoring Mobile monitoring Infrastructure monitoring For other custom data solutions, see Intro to custom data. APM: Record custom attributes Important Review the list of reserved terms used by NRQL. Using reserved terms can cause issues. To enable and use custom attributes for APM, follow the procedure for your APM agent: C SDK To add custom attributes to applications monitored by the C SDK, call one of the attribute functions; for example, newrelic_add_attribute_double(). The key name for your custom attribute depends on what you specify when you call the function. Go Custom attribute collection is enabled by default in the Go agent. However, you can disable custom attribute collection. Java Custom attribute collection is enabled by default in Java. You can collect custom attributes using XML and the Java agent APIs. These two methods can be used in conjunction with each other. Method How to do it Specify attributes in XML XML allows you to specify custom attributes without changing any of your source code. You can have multiple XML files for custom attributes that are grouped by some logical facet. To set custom attributes for your Java app via XML: Review the New Relic Java agent's documentation about XML file format, methods and classes, and examples. From your Extensions directory within the New Relic Java agent, create a single XML file. Define the methods you want New Relic to monitor by editing your XML file directly. Define an XML instrumentation file using the New Relic UI. This may require additional config in the common: block of your newrelic.yml. See Report custom attributes under Instrumentation options for more detail. Call the agent's API Example 1: Adding custom attributes to transactions To collect custom attributes using the agent's API, call the relevant methods: For each method you want to record an attribute for, call NewRelic.addCustomParameter(...). Optional: Include or exclude certain attributes with attributes.include and attributes.exclude. For example, to record a variable named userId, include this code in the parent method: NewRelic.addCustomParameter(\"userId\", userId); Copy Example 2: Adding custom attributes to spans in distributed traces To collect custom attributes using the agent's API, call the relevant methods: For each span (currently executing method) that you want to record an attribute for, call NewRelic.getAgent().getTracedMethod().addCustomAttribute(...). Optional: Include or exclude certain attributes with span_events.attributes.include and span_events.attributes.exclude. For example, to record a variable named userId on the current span, include this code in the associated method: NewRelic.getAgent().getTracedMethod().addCustomAttribute(\"userId\", userId); Copy Collect user attributes The Java agent also includes a built-in mechanism to enable user attributes and collect user information from HttpServletRequest.getUserPrincipal() as custom attributes. .NET Custom attribute collection is enabled by default in .NET. To collect custom attributes, call the relevant API methods: For each method for which you want to record an attribute, call AddCustomAttribute. Optional: Include or exclude attributes with the include and exclude configuration options. For example, to record attributes for a coupon code (string) and an item ID code (number), you could include this code in the parent method: IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction .AddCustomAttribute(\"Discount Code\", \"Summer Super Sale\") .AddCustomAttribute(\"Item Code\", 31456); Copy Node.js Custom attribute collection is enabled by default in Node.js. To collect custom attributes, call the relevant API method: For each attribute you want to record, call newrelic.addCustomAttribute. To record multiple attributes using a single call, use newrelic.addCustomAttributes. For example, to record attributes for a coupon code and an item ID code, you could include this in the parent method: newrelic.addCustomAttributes({ \"Discount Code\": \"Summer Super Sale\", \"Item Code\": 31456 }); Copy PHP Custom attribute collection is enabled by default in PHP. To collect custom attributes, call the relevant API method for each method that you want to record an attribute; newrelic_add_custom_parameter for transaction events and spans newrelic_add_custom_span_parameter for only spans For example, to record a variable named $userId, include this code in the parent method: newrelic_add_custom_parameter ('userID', $userId) Copy Python Custom attribute collection is enabled by default in Python. To collect custom attributes, call add_custom_parameter for each method that you want to record an attribute. For example, to record a variable named user_id, include this code in the parent method: newrelic.agent.add_custom_parameter('user_id', user_id) Copy Ruby Custom attribute collection is enabled by default in Ruby. To collect custom attributes, call the relevant API methods: For Ruby agent version 3.12.0 or higher, use the add_custom_attributes method. For example, to record a variable named @user_id, include this code in the parent method: ::NewRelic::Agent.add_custom_attributes({ user_id: @user.id }) Copy For Ruby agent version 3.11.2 or lower, use the add_custom_parameters method. For example, to record a variable named @user_id, include this code in the parent method: ::NewRelic::Agent.add_custom_parameters({ user_id: @user.id }) Copy Browser monitoring: Record custom attributes The browser agent provides an API to specify extra details associated with a page view or browser interaction, either by forwarding attributes from APM to browser monitoring or by specifying custom attributes through JavaScript. Values forwarded from the APM agent are encoded and injected into browser attributes by our browser agent. Infrastructure monitoring: Record custom attributes Our Infrastructure monitoring lets you create custom attributes that are used to annotate the data from the infrastructure agent. You can use this metadata to build filter sets, group your results, and annotate your data. Mobile monitoring: Record custom attributes Mobile agents include API calls to record custom attributes: For an overview of mobile monitoring custom data, see Insert custom events and attributes Android method: setAttribute iOS method: setAttribute For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.55336,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Browser</em> <em>monitoring</em>: Record custom attributes",
        "tags": "Install and <em>configure</em>",
        "body": "For some New Relic solutions, one way to report custom data to New Relic is to use custom attributes. For example, for New Relic <em>browser</em> <em>monitoring</em>, you might create a custom attribute to track the user name associated with a slow or failing request. Requirements Custom attributes are available"
      },
      "id": "603eb9a3196a67a990a83da5"
    },
    {
      "sections": [
        "Install the browser monitoring agent",
        "Tip",
        "Select a deployment option",
        "Important",
        "Enable an APM-monitored app",
        "Enable with copy/paste",
        "Instrument webpages using the APM agent",
        "Troubleshoot Browser agent installation"
      ],
      "title": "Install the browser monitoring agent",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Installation"
      ],
      "external_id": "bc45bbc86cd4d8b81367ad0904907ddc735717f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/installation/install-browser-monitoring-agent/",
      "published_at": "2021-07-02T09:15:35Z",
      "updated_at": "2021-06-14T21:26:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser uses a JavaScript snippet (or \"agent\") to instrument your app's webpages. The JavaScript collects data for browser monitoring. To install the browser agent, you can choose from a number of deployment options. Tip To use Browser and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Select a deployment option No matter which option you use to deploy browser monitoring, the end result is to inject the browser agent's JavaScript snippet into your pages for browser monitoring. The method you select depends on your preferences and business needs. To view the procedure to install and enable the browser agent, click the link for the option you want to use. You can also use the Browser Application settings page to update settings. Important The following configuration options refer only to the browser monitoring agent. These are not the same as the New Relic user roles and editions. Browser deployment option Description Use the APM agent to inject the JavaScript You can use an APM agent to automatically inject the browser monitoring JavaScript snippet for you. This is the easiest way to install the agent for an app that already is being monitored by APM. (APM-monitored apps are listed on your APM Applications index.) Paste the JavaScript snippet into a webpage This allows you to control the exact placement of the JavaScript into your app's webpage(s) by copying and pasting the browser agent's JavaScript snippet. This is useful for: Standalone apps, static sites, and cached pages delivered by CDN APM apps that are not as closely coupled to the browser app as with a standard server-side app (for example, when your client-side app talks to a REST API back end) Enable single-page app (SPA) monitoring Enabling SPA requires a Pro + SPA browser agent subscription, and you may need to re-deploy the browser JavaScript agent. Use the REST API The REST API lets you manage deployment outside the browser UI. This is useful for large organizations deploying multiple apps. Use an APM agent API to manually instrument the JavaScript snippet For apps that are monitored by APM, you can use the APM agent's API to inject the JavaScript manually instead of automatically. Enable an APM-monitored app Use this procedure to automatically deploy the browser agent on an app that is monitored by APM: Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Enable via New Relic APM. In the Choose your instrumentation section, select Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Select your application section, type or use the search window to find an app's name. Click Enable. Important Node.js: To finish enabling the browser agent for a Node.js app, follow the additional procedure to insert the JavaScript header into the beginning of your HTML page's head tag. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. Enable with copy/paste Use this procedure to insert browser's JavaScript snippet for browser monitoring into your app's webpages yourself. This option is useful for monitoring static sites (such as Jekyll) or cached pages delivered by CDN. Tip Near the bottom of the generated JavaScript is your browser license key and application ID. This is useful with the REST API and API Explorer. Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Copy/Paste JavaScript Code. In the Choose your instrumentation section, select the type of agent: Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Name your app section, name your app: If your app is monitored by APM, select Yes, then type or use the search window to find the app's name. If you have a standalone app for Browser (not monitored by APM), select No, then type the app's name. Click Enable. A new section, Instrument the agent, opens on the page with JavaScript code for your project. Copy the code snippet, then paste it inline into your pages as close to the top of the <head> element as possible, but after any position-sensitive <meta> tags (for example, X-UA-Compatible or charset information). For more information on the inline head placement, see JavaScript placement requirements. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. If you use the copy/paste method, but don't finish the setup process, you can still view and copy the generated JavaScript snippet from your app's Browser Application settings page or by using the REST API (v2). Instrument webpages using the APM agent This information applies to apps that are also monitored by APM. New Relic's agents can instrument webpages with the required JavaScript for page load timing. If you use the APM agent to add the JavaScript snippet to your webpages, insert the instrumentation snippet as close to the top as possible. This allows you to take advantage of detailed information about browser's AJAX calls and JavaScript errors. For more information, see the instructions for your APM agent: C SDK Go Java .NET Node.js PHP Python Ruby Troubleshoot Browser agent installation When you enable browser Pro features for session traces, AJAX calls, or JavaScript errors, it may take approximately five minutes before information becomes available. If you have problems with your browser installation or if no data appears after five minutes, refer to the troubleshooting tips, and restart your agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.368835,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install the <em>browser</em> <em>monitoring</em> agent",
        "sections": "Install the <em>browser</em> <em>monitoring</em> agent",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " The following <em>configuration</em> options refer only to the <em>browser</em> <em>monitoring</em> agent. These are not the same as the New Relic user roles and editions. <em>Browser</em> deployment option Description Use the APM agent to inject the JavaScript You can use an APM agent to automatically inject the <em>browser</em> <em>monitoring</em> JavaScript"
      },
      "id": "604429e628ccbcb80b2c60d0"
    }
  ],
  "/docs/browser/new-relic-browser/configuration/rename-browser-apps": [
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 177.84967,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "If you use <em>Browser</em> to <em>monitor</em> end-user <em>browser</em> activity, you can now see end-user-originating <em>browser</em>-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data"
      },
      "id": "6043fe6f196a6784f0960f53"
    },
    {
      "sections": [
        "Collect custom attributes",
        "Requirements",
        "APM: Record custom attributes",
        "Important",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "Browser monitoring: Record custom attributes",
        "Infrastructure monitoring: Record custom attributes",
        "Mobile monitoring: Record custom attributes",
        "For more help"
      ],
      "title": "Collect custom attributes",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Install and configure"
      ],
      "external_id": "ad362b1a5cf3a5661eb416584fd9c79db064f539",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/data/customize-data/collect-custom-attributes/",
      "published_at": "2021-07-02T19:49:53Z",
      "updated_at": "2021-07-02T19:49:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some New Relic solutions, one way to report custom data to New Relic is to use custom attributes. For example, for New Relic browser monitoring, you might create a custom attribute to track the user name associated with a slow or failing request. Requirements Custom attributes are available for these New Relic solutions: APM Browser monitoring Mobile monitoring Infrastructure monitoring For other custom data solutions, see Intro to custom data. APM: Record custom attributes Important Review the list of reserved terms used by NRQL. Using reserved terms can cause issues. To enable and use custom attributes for APM, follow the procedure for your APM agent: C SDK To add custom attributes to applications monitored by the C SDK, call one of the attribute functions; for example, newrelic_add_attribute_double(). The key name for your custom attribute depends on what you specify when you call the function. Go Custom attribute collection is enabled by default in the Go agent. However, you can disable custom attribute collection. Java Custom attribute collection is enabled by default in Java. You can collect custom attributes using XML and the Java agent APIs. These two methods can be used in conjunction with each other. Method How to do it Specify attributes in XML XML allows you to specify custom attributes without changing any of your source code. You can have multiple XML files for custom attributes that are grouped by some logical facet. To set custom attributes for your Java app via XML: Review the New Relic Java agent's documentation about XML file format, methods and classes, and examples. From your Extensions directory within the New Relic Java agent, create a single XML file. Define the methods you want New Relic to monitor by editing your XML file directly. Define an XML instrumentation file using the New Relic UI. This may require additional config in the common: block of your newrelic.yml. See Report custom attributes under Instrumentation options for more detail. Call the agent's API Example 1: Adding custom attributes to transactions To collect custom attributes using the agent's API, call the relevant methods: For each method you want to record an attribute for, call NewRelic.addCustomParameter(...). Optional: Include or exclude certain attributes with attributes.include and attributes.exclude. For example, to record a variable named userId, include this code in the parent method: NewRelic.addCustomParameter(\"userId\", userId); Copy Example 2: Adding custom attributes to spans in distributed traces To collect custom attributes using the agent's API, call the relevant methods: For each span (currently executing method) that you want to record an attribute for, call NewRelic.getAgent().getTracedMethod().addCustomAttribute(...). Optional: Include or exclude certain attributes with span_events.attributes.include and span_events.attributes.exclude. For example, to record a variable named userId on the current span, include this code in the associated method: NewRelic.getAgent().getTracedMethod().addCustomAttribute(\"userId\", userId); Copy Collect user attributes The Java agent also includes a built-in mechanism to enable user attributes and collect user information from HttpServletRequest.getUserPrincipal() as custom attributes. .NET Custom attribute collection is enabled by default in .NET. To collect custom attributes, call the relevant API methods: For each method for which you want to record an attribute, call AddCustomAttribute. Optional: Include or exclude attributes with the include and exclude configuration options. For example, to record attributes for a coupon code (string) and an item ID code (number), you could include this code in the parent method: IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction .AddCustomAttribute(\"Discount Code\", \"Summer Super Sale\") .AddCustomAttribute(\"Item Code\", 31456); Copy Node.js Custom attribute collection is enabled by default in Node.js. To collect custom attributes, call the relevant API method: For each attribute you want to record, call newrelic.addCustomAttribute. To record multiple attributes using a single call, use newrelic.addCustomAttributes. For example, to record attributes for a coupon code and an item ID code, you could include this in the parent method: newrelic.addCustomAttributes({ \"Discount Code\": \"Summer Super Sale\", \"Item Code\": 31456 }); Copy PHP Custom attribute collection is enabled by default in PHP. To collect custom attributes, call the relevant API method for each method that you want to record an attribute; newrelic_add_custom_parameter for transaction events and spans newrelic_add_custom_span_parameter for only spans For example, to record a variable named $userId, include this code in the parent method: newrelic_add_custom_parameter ('userID', $userId) Copy Python Custom attribute collection is enabled by default in Python. To collect custom attributes, call add_custom_parameter for each method that you want to record an attribute. For example, to record a variable named user_id, include this code in the parent method: newrelic.agent.add_custom_parameter('user_id', user_id) Copy Ruby Custom attribute collection is enabled by default in Ruby. To collect custom attributes, call the relevant API methods: For Ruby agent version 3.12.0 or higher, use the add_custom_attributes method. For example, to record a variable named @user_id, include this code in the parent method: ::NewRelic::Agent.add_custom_attributes({ user_id: @user.id }) Copy For Ruby agent version 3.11.2 or lower, use the add_custom_parameters method. For example, to record a variable named @user_id, include this code in the parent method: ::NewRelic::Agent.add_custom_parameters({ user_id: @user.id }) Copy Browser monitoring: Record custom attributes The browser agent provides an API to specify extra details associated with a page view or browser interaction, either by forwarding attributes from APM to browser monitoring or by specifying custom attributes through JavaScript. Values forwarded from the APM agent are encoded and injected into browser attributes by our browser agent. Infrastructure monitoring: Record custom attributes Our Infrastructure monitoring lets you create custom attributes that are used to annotate the data from the infrastructure agent. You can use this metadata to build filter sets, group your results, and annotate your data. Mobile monitoring: Record custom attributes Mobile agents include API calls to record custom attributes: For an overview of mobile monitoring custom data, see Insert custom events and attributes Android method: setAttribute iOS method: setAttribute For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.55327,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Browser</em> <em>monitoring</em>: Record custom attributes",
        "tags": "Install and <em>configure</em>",
        "body": "For some New Relic solutions, one way to report custom data to New Relic is to use custom attributes. For example, for New Relic <em>browser</em> <em>monitoring</em>, you might create a custom attribute to track the user name associated with a slow or failing request. Requirements Custom attributes are available"
      },
      "id": "603eb9a3196a67a990a83da5"
    },
    {
      "sections": [
        "Install the browser monitoring agent",
        "Tip",
        "Select a deployment option",
        "Important",
        "Enable an APM-monitored app",
        "Enable with copy/paste",
        "Instrument webpages using the APM agent",
        "Troubleshoot Browser agent installation"
      ],
      "title": "Install the browser monitoring agent",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Installation"
      ],
      "external_id": "bc45bbc86cd4d8b81367ad0904907ddc735717f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/installation/install-browser-monitoring-agent/",
      "published_at": "2021-07-02T09:15:35Z",
      "updated_at": "2021-06-14T21:26:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser uses a JavaScript snippet (or \"agent\") to instrument your app's webpages. The JavaScript collects data for browser monitoring. To install the browser agent, you can choose from a number of deployment options. Tip To use Browser and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Select a deployment option No matter which option you use to deploy browser monitoring, the end result is to inject the browser agent's JavaScript snippet into your pages for browser monitoring. The method you select depends on your preferences and business needs. To view the procedure to install and enable the browser agent, click the link for the option you want to use. You can also use the Browser Application settings page to update settings. Important The following configuration options refer only to the browser monitoring agent. These are not the same as the New Relic user roles and editions. Browser deployment option Description Use the APM agent to inject the JavaScript You can use an APM agent to automatically inject the browser monitoring JavaScript snippet for you. This is the easiest way to install the agent for an app that already is being monitored by APM. (APM-monitored apps are listed on your APM Applications index.) Paste the JavaScript snippet into a webpage This allows you to control the exact placement of the JavaScript into your app's webpage(s) by copying and pasting the browser agent's JavaScript snippet. This is useful for: Standalone apps, static sites, and cached pages delivered by CDN APM apps that are not as closely coupled to the browser app as with a standard server-side app (for example, when your client-side app talks to a REST API back end) Enable single-page app (SPA) monitoring Enabling SPA requires a Pro + SPA browser agent subscription, and you may need to re-deploy the browser JavaScript agent. Use the REST API The REST API lets you manage deployment outside the browser UI. This is useful for large organizations deploying multiple apps. Use an APM agent API to manually instrument the JavaScript snippet For apps that are monitored by APM, you can use the APM agent's API to inject the JavaScript manually instead of automatically. Enable an APM-monitored app Use this procedure to automatically deploy the browser agent on an app that is monitored by APM: Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Enable via New Relic APM. In the Choose your instrumentation section, select Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Select your application section, type or use the search window to find an app's name. Click Enable. Important Node.js: To finish enabling the browser agent for a Node.js app, follow the additional procedure to insert the JavaScript header into the beginning of your HTML page's head tag. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. Enable with copy/paste Use this procedure to insert browser's JavaScript snippet for browser monitoring into your app's webpages yourself. This option is useful for monitoring static sites (such as Jekyll) or cached pages delivered by CDN. Tip Near the bottom of the generated JavaScript is your browser license key and application ID. This is useful with the REST API and API Explorer. Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Copy/Paste JavaScript Code. In the Choose your instrumentation section, select the type of agent: Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Name your app section, name your app: If your app is monitored by APM, select Yes, then type or use the search window to find the app's name. If you have a standalone app for Browser (not monitored by APM), select No, then type the app's name. Click Enable. A new section, Instrument the agent, opens on the page with JavaScript code for your project. Copy the code snippet, then paste it inline into your pages as close to the top of the <head> element as possible, but after any position-sensitive <meta> tags (for example, X-UA-Compatible or charset information). For more information on the inline head placement, see JavaScript placement requirements. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. If you use the copy/paste method, but don't finish the setup process, you can still view and copy the generated JavaScript snippet from your app's Browser Application settings page or by using the REST API (v2). Instrument webpages using the APM agent This information applies to apps that are also monitored by APM. New Relic's agents can instrument webpages with the required JavaScript for page load timing. If you use the APM agent to add the JavaScript snippet to your webpages, insert the instrumentation snippet as close to the top as possible. This allows you to take advantage of detailed information about browser's AJAX calls and JavaScript errors. For more information, see the instructions for your APM agent: C SDK Go Java .NET Node.js PHP Python Ruby Troubleshoot Browser agent installation When you enable browser Pro features for session traces, AJAX calls, or JavaScript errors, it may take approximately five minutes before information becomes available. If you have problems with your browser installation or if no data appears after five minutes, refer to the troubleshooting tips, and restart your agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.36882,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install the <em>browser</em> <em>monitoring</em> agent",
        "sections": "Install the <em>browser</em> <em>monitoring</em> agent",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " The following <em>configuration</em> options refer only to the <em>browser</em> <em>monitoring</em> agent. These are not the same as the New Relic user roles and editions. <em>Browser</em> deployment option Description Use the APM agent to inject the JavaScript You can use an APM agent to automatically inject the <em>browser</em> <em>monitoring</em> JavaScript"
      },
      "id": "604429e628ccbcb80b2c60d0"
    }
  ],
  "/docs/browser/new-relic-browser/configuration/view-browser-apps-alert-information": [
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 177.84967,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "If you use <em>Browser</em> to <em>monitor</em> end-user <em>browser</em> activity, you can now see end-user-originating <em>browser</em>-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data"
      },
      "id": "6043fe6f196a6784f0960f53"
    },
    {
      "sections": [
        "Collect custom attributes",
        "Requirements",
        "APM: Record custom attributes",
        "Important",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "Browser monitoring: Record custom attributes",
        "Infrastructure monitoring: Record custom attributes",
        "Mobile monitoring: Record custom attributes",
        "For more help"
      ],
      "title": "Collect custom attributes",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Install and configure"
      ],
      "external_id": "ad362b1a5cf3a5661eb416584fd9c79db064f539",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/data/customize-data/collect-custom-attributes/",
      "published_at": "2021-07-02T19:49:53Z",
      "updated_at": "2021-07-02T19:49:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some New Relic solutions, one way to report custom data to New Relic is to use custom attributes. For example, for New Relic browser monitoring, you might create a custom attribute to track the user name associated with a slow or failing request. Requirements Custom attributes are available for these New Relic solutions: APM Browser monitoring Mobile monitoring Infrastructure monitoring For other custom data solutions, see Intro to custom data. APM: Record custom attributes Important Review the list of reserved terms used by NRQL. Using reserved terms can cause issues. To enable and use custom attributes for APM, follow the procedure for your APM agent: C SDK To add custom attributes to applications monitored by the C SDK, call one of the attribute functions; for example, newrelic_add_attribute_double(). The key name for your custom attribute depends on what you specify when you call the function. Go Custom attribute collection is enabled by default in the Go agent. However, you can disable custom attribute collection. Java Custom attribute collection is enabled by default in Java. You can collect custom attributes using XML and the Java agent APIs. These two methods can be used in conjunction with each other. Method How to do it Specify attributes in XML XML allows you to specify custom attributes without changing any of your source code. You can have multiple XML files for custom attributes that are grouped by some logical facet. To set custom attributes for your Java app via XML: Review the New Relic Java agent's documentation about XML file format, methods and classes, and examples. From your Extensions directory within the New Relic Java agent, create a single XML file. Define the methods you want New Relic to monitor by editing your XML file directly. Define an XML instrumentation file using the New Relic UI. This may require additional config in the common: block of your newrelic.yml. See Report custom attributes under Instrumentation options for more detail. Call the agent's API Example 1: Adding custom attributes to transactions To collect custom attributes using the agent's API, call the relevant methods: For each method you want to record an attribute for, call NewRelic.addCustomParameter(...). Optional: Include or exclude certain attributes with attributes.include and attributes.exclude. For example, to record a variable named userId, include this code in the parent method: NewRelic.addCustomParameter(\"userId\", userId); Copy Example 2: Adding custom attributes to spans in distributed traces To collect custom attributes using the agent's API, call the relevant methods: For each span (currently executing method) that you want to record an attribute for, call NewRelic.getAgent().getTracedMethod().addCustomAttribute(...). Optional: Include or exclude certain attributes with span_events.attributes.include and span_events.attributes.exclude. For example, to record a variable named userId on the current span, include this code in the associated method: NewRelic.getAgent().getTracedMethod().addCustomAttribute(\"userId\", userId); Copy Collect user attributes The Java agent also includes a built-in mechanism to enable user attributes and collect user information from HttpServletRequest.getUserPrincipal() as custom attributes. .NET Custom attribute collection is enabled by default in .NET. To collect custom attributes, call the relevant API methods: For each method for which you want to record an attribute, call AddCustomAttribute. Optional: Include or exclude attributes with the include and exclude configuration options. For example, to record attributes for a coupon code (string) and an item ID code (number), you could include this code in the parent method: IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction .AddCustomAttribute(\"Discount Code\", \"Summer Super Sale\") .AddCustomAttribute(\"Item Code\", 31456); Copy Node.js Custom attribute collection is enabled by default in Node.js. To collect custom attributes, call the relevant API method: For each attribute you want to record, call newrelic.addCustomAttribute. To record multiple attributes using a single call, use newrelic.addCustomAttributes. For example, to record attributes for a coupon code and an item ID code, you could include this in the parent method: newrelic.addCustomAttributes({ \"Discount Code\": \"Summer Super Sale\", \"Item Code\": 31456 }); Copy PHP Custom attribute collection is enabled by default in PHP. To collect custom attributes, call the relevant API method for each method that you want to record an attribute; newrelic_add_custom_parameter for transaction events and spans newrelic_add_custom_span_parameter for only spans For example, to record a variable named $userId, include this code in the parent method: newrelic_add_custom_parameter ('userID', $userId) Copy Python Custom attribute collection is enabled by default in Python. To collect custom attributes, call add_custom_parameter for each method that you want to record an attribute. For example, to record a variable named user_id, include this code in the parent method: newrelic.agent.add_custom_parameter('user_id', user_id) Copy Ruby Custom attribute collection is enabled by default in Ruby. To collect custom attributes, call the relevant API methods: For Ruby agent version 3.12.0 or higher, use the add_custom_attributes method. For example, to record a variable named @user_id, include this code in the parent method: ::NewRelic::Agent.add_custom_attributes({ user_id: @user.id }) Copy For Ruby agent version 3.11.2 or lower, use the add_custom_parameters method. For example, to record a variable named @user_id, include this code in the parent method: ::NewRelic::Agent.add_custom_parameters({ user_id: @user.id }) Copy Browser monitoring: Record custom attributes The browser agent provides an API to specify extra details associated with a page view or browser interaction, either by forwarding attributes from APM to browser monitoring or by specifying custom attributes through JavaScript. Values forwarded from the APM agent are encoded and injected into browser attributes by our browser agent. Infrastructure monitoring: Record custom attributes Our Infrastructure monitoring lets you create custom attributes that are used to annotate the data from the infrastructure agent. You can use this metadata to build filter sets, group your results, and annotate your data. Mobile monitoring: Record custom attributes Mobile agents include API calls to record custom attributes: For an overview of mobile monitoring custom data, see Insert custom events and attributes Android method: setAttribute iOS method: setAttribute For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 139.55327,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Browser</em> <em>monitoring</em>: Record custom attributes",
        "tags": "Install and <em>configure</em>",
        "body": "For some New Relic solutions, one way to report custom data to New Relic is to use custom attributes. For example, for New Relic <em>browser</em> <em>monitoring</em>, you might create a custom attribute to track the user name associated with a slow or failing request. Requirements Custom attributes are available"
      },
      "id": "603eb9a3196a67a990a83da5"
    },
    {
      "sections": [
        "Install the browser monitoring agent",
        "Tip",
        "Select a deployment option",
        "Important",
        "Enable an APM-monitored app",
        "Enable with copy/paste",
        "Instrument webpages using the APM agent",
        "Troubleshoot Browser agent installation"
      ],
      "title": "Install the browser monitoring agent",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Installation"
      ],
      "external_id": "bc45bbc86cd4d8b81367ad0904907ddc735717f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/installation/install-browser-monitoring-agent/",
      "published_at": "2021-07-02T09:15:35Z",
      "updated_at": "2021-06-14T21:26:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser uses a JavaScript snippet (or \"agent\") to instrument your app's webpages. The JavaScript collects data for browser monitoring. To install the browser agent, you can choose from a number of deployment options. Tip To use Browser and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Select a deployment option No matter which option you use to deploy browser monitoring, the end result is to inject the browser agent's JavaScript snippet into your pages for browser monitoring. The method you select depends on your preferences and business needs. To view the procedure to install and enable the browser agent, click the link for the option you want to use. You can also use the Browser Application settings page to update settings. Important The following configuration options refer only to the browser monitoring agent. These are not the same as the New Relic user roles and editions. Browser deployment option Description Use the APM agent to inject the JavaScript You can use an APM agent to automatically inject the browser monitoring JavaScript snippet for you. This is the easiest way to install the agent for an app that already is being monitored by APM. (APM-monitored apps are listed on your APM Applications index.) Paste the JavaScript snippet into a webpage This allows you to control the exact placement of the JavaScript into your app's webpage(s) by copying and pasting the browser agent's JavaScript snippet. This is useful for: Standalone apps, static sites, and cached pages delivered by CDN APM apps that are not as closely coupled to the browser app as with a standard server-side app (for example, when your client-side app talks to a REST API back end) Enable single-page app (SPA) monitoring Enabling SPA requires a Pro + SPA browser agent subscription, and you may need to re-deploy the browser JavaScript agent. Use the REST API The REST API lets you manage deployment outside the browser UI. This is useful for large organizations deploying multiple apps. Use an APM agent API to manually instrument the JavaScript snippet For apps that are monitored by APM, you can use the APM agent's API to inject the JavaScript manually instead of automatically. Enable an APM-monitored app Use this procedure to automatically deploy the browser agent on an app that is monitored by APM: Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Enable via New Relic APM. In the Choose your instrumentation section, select Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Select your application section, type or use the search window to find an app's name. Click Enable. Important Node.js: To finish enabling the browser agent for a Node.js app, follow the additional procedure to insert the JavaScript header into the beginning of your HTML page's head tag. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. Enable with copy/paste Use this procedure to insert browser's JavaScript snippet for browser monitoring into your app's webpages yourself. This option is useful for monitoring static sites (such as Jekyll) or cached pages delivered by CDN. Tip Near the bottom of the generated JavaScript is your browser license key and application ID. This is useful with the REST API and API Explorer. Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Copy/Paste JavaScript Code. In the Choose your instrumentation section, select the type of agent: Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Name your app section, name your app: If your app is monitored by APM, select Yes, then type or use the search window to find the app's name. If you have a standalone app for Browser (not monitored by APM), select No, then type the app's name. Click Enable. A new section, Instrument the agent, opens on the page with JavaScript code for your project. Copy the code snippet, then paste it inline into your pages as close to the top of the <head> element as possible, but after any position-sensitive <meta> tags (for example, X-UA-Compatible or charset information). For more information on the inline head placement, see JavaScript placement requirements. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. If you use the copy/paste method, but don't finish the setup process, you can still view and copy the generated JavaScript snippet from your app's Browser Application settings page or by using the REST API (v2). Instrument webpages using the APM agent This information applies to apps that are also monitored by APM. New Relic's agents can instrument webpages with the required JavaScript for page load timing. If you use the APM agent to add the JavaScript snippet to your webpages, insert the instrumentation snippet as close to the top as possible. This allows you to take advantage of detailed information about browser's AJAX calls and JavaScript errors. For more information, see the instructions for your APM agent: C SDK Go Java .NET Node.js PHP Python Ruby Troubleshoot Browser agent installation When you enable browser Pro features for session traces, AJAX calls, or JavaScript errors, it may take approximately five minutes before information becomes available. If you have problems with your browser installation or if no data appears after five minutes, refer to the troubleshooting tips, and restart your agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.36882,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install the <em>browser</em> <em>monitoring</em> agent",
        "sections": "Install the <em>browser</em> <em>monitoring</em> agent",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " The following <em>configuration</em> options refer only to the <em>browser</em> <em>monitoring</em> agent. These are not the same as the New Relic user roles and editions. <em>Browser</em> deployment option Description Use the APM agent to inject the JavaScript You can use an APM agent to automatically inject the <em>browser</em> <em>monitoring</em> JavaScript"
      },
      "id": "604429e628ccbcb80b2c60d0"
    }
  ],
  "/docs/browser/new-relic-browser/getting-started/browser-apps-index": [
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.3192,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "If you use <em>Browser</em> to <em>monitor</em> end-user <em>browser</em> activity, you can now see end-user-originating <em>browser</em>-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data"
      },
      "id": "6043fe6f196a6784f0960f53"
    },
    {
      "sections": [
        "Get data into New Relic",
        "New Relic-built agents and integrations",
        "Report custom data"
      ],
      "title": "Get data into New Relic",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Get started"
      ],
      "external_id": "1b20f81fa22784c5d22e4e51eb7c0bf26cbdb0b6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/get-started/introduction-new-relic-data-ingest-apis-sdks/",
      "published_at": "2021-07-01T17:17:17Z",
      "updated_at": "2021-07-01T17:17:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are many ways to get data into your New Relic account. Any New Relic user can use any of our data ingest methods to report data to our Telemetry Data Platform. New Relic-built agents and integrations When you enable New Relic solutions like APM, browser monitoring, mobile monitoring, infrastructure monitoring, or any of our wide array of integrations, by default you'll receive data from your monitored applications, hosts, services, or other entities. Some options for getting started: Log into one.newrelic.com and click Add more data to get some guidance on setting up New Relic solutions. To browse our solutions, see New Relic integrations. Report custom data If you need to report data that our agents and integrations don't provide, we have tools that will allow you to bring in any type of data you need. To learn more, see Intro to custom data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 148.89941,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Get</em> data into New Relic",
        "sections": "<em>Get</em> data into New Relic",
        "tags": "<em>Get</em> <em>started</em>",
        "body": ", infrastructure <em>monitoring</em>, or any of our wide array of integrations, by default you&#x27;ll receive data from your monitored applications, hosts, services, or other entities. Some options for <em>getting</em> <em>started</em>: Log into one.newrelic.com and click Add more data to <em>get</em> some guidance on setting up New Relic solutions"
      },
      "id": "603eae7b196a671ea3a83dc7"
    },
    {
      "sections": [
        "Compatibility and requirements for Browser Monitoring",
        "Basic requirements",
        "Important",
        "Browser types",
        "APM agents",
        "Supported frameworks",
        "Content Security Policy (CSP) considerations"
      ],
      "title": "Compatibility and requirements for Browser Monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Getting started"
      ],
      "external_id": "538a44c0c5def08c38b57c43fff73aa1002e2a5f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/getting-started/compatibility-requirements-browser-monitoring/",
      "published_at": "2021-07-02T00:27:15Z",
      "updated_at": "2021-05-21T20:47:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring includes strict security measures to provide a robust, standalone product with browser monitoring features. Before you install the Browser agent, make sure your system meets these requirements. Basic requirements To report data to Browser, your application must at a minimum meet two basic requirements: The traffic to the application must be from clients able to load and execute Browser JavaScript code and set cookies. Clients accessing the application must be able to send data to New Relic through HTTP requests. HTTPS is required for Browser Pro features. Important Browsers that subscribe to a disconnect list or that use content filtering extensions such as AdBlock may not be able to send data to New Relic. For example, if you are using the Enhanced Tracking Prevention disconnect list for Mozilla Firefox 69.0 or higher, you will need to change the default configuration. Most typical browser applications meet these requirements. However, browser applications in restricted environments may have difficulty reporting data to New Relic; for example: Hybrid mobile applications Applications installed on unusual hardware, such as point-of-sale terminals or consumer appliances For more information, review the instrumentation for browser monitoring documentation, and verify end-user network access. Browser types Instrumentation is compatible with every browser type, including Google Chrome, Mozilla Firefox, Microsoft Internet Explorer and Edge, and Apple Safari. The user interface is compatible with New Relic's supported browser versions. Exceptions Comments Paint timings The firstPaint and firstContentfulPaint attributes in BrowserInteraction, PageView, and PageViewTiming events are only compatible with: Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile AJAX AJAX timing features are not available with: Chrome for iPhone and iPad IE 7 and 8 PageAction events PageAction events require a browser that fully supports cross-domain XMLHttpRequests. Internet Explorer versions 9 and lower cannot record PageAction events. Learn more on querying your data. Session traces Session traces are reported only from browsers that support the Resource Timing Specification. SHA-256 New Relic can only monitor browsers that are compatible with SHA-256. APM agents You can deploy the Browser agent for apps monitored by APM, or you can deploy the Browser agent for your standalone apps. For more information, see the installation procedures. If you are deploying Browser for an app using APM, make sure your agent supports Browser monitoring: C SDK: Version 1.0.0 or higher Go: Version 2.5.0 or higher Java: Version 3.4.0 or higher .NET: Version 2.20.25.0 or higher Node.js: Version 1.4.0 or higher PHP: Version 4.4.5.35 or higher Python: Version 2.10.1.9 or higher Ruby: Version 3.7.0.177 or higher Supported frameworks The Browser agent collects data on all front-end frameworks. However, the monitoring occurs on lower-level \"primitives\" that JavaScript frameworks use, so the level of detail collected by the instrumentation may vary depending on your specific framework. Exceptions Comments Zone.js If you're using AngularJS and you want to use Browser's SPA monitoring capabilities, note that Zone.js versions 0.6.18 to 0.6.24 are not compatible with Browser. In all cases, the Browser agent must be loaded before Zone.js to avoid errors. Cypress.io Browser is unable to properly instrument the open and send methods of requests when tests are run in Cypress. This will cause the following error to be thrown: Cannot set property 'status' of undefined Copy This will only affect customers running tests with the Browser agent present in their code. Production applications should not be affected. html2pdf.js This library is not compatible with our SPA-enabled Browser agent due to the way this library wraps promises. If you're using this library, we recommend the Browser Pro agent. Content Security Policy (CSP) considerations In order to obtain accurate browser performance metrics, Browser requires the use of a small, inline JavaScript snippet. New Relic carefully reviews the inline JavaScript to prevent Cross-Site Scripting (XSS) and other potential vulnerabilities. Content Security Policy Level 2 adds restrictions to the types of JavaScript allowed, such as inline scripts. It also limits which domains can load scripts during page load. Important If your website does not allow any third-party hosted JavaScript to run, you must request a CSP exception via your organizationâ€™s standard procedures in order to install the Browser monitoring agent. When requesting a CSP exception, follow your organization's standard procedures to contact your web or security team. The Browser JavaScript agent requires the following CSP exceptions in order to run properly. Alternatively, you can add all of these exceptions to the fallback default-src directive (instead of script-src and connect-src). CSP exception Comments unsafe-inline Add to the script-src directive or to the fallback default-src directive. This is required because the agent is installed by including an inline script. https://js-agent.newrelic.com Add to the script-src directive or to the fallback default-src directive. This is where additional script files that the agent requires are hosted. https://bam.nr-data.net https://bam-cell.nr-data.net Important Add https://gov-bam.nr-data.net if you're using FedRAMP-compliant endpoints. Add to the script-src directive or to the fallback default-src directive. This is where the agent sends its collected data. One of the calls to this URL is a JSONP call, which means that the URL must be allowed as a script source. Add to the connect-src directive or to the fallback default-src directive. The connect-src directive affects the URLs that scripts can call (for example, using the XMLHttpRequest interface). If you have CSP restrictions specifically around this directive, then add this URL as an exception.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.53786,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for <em>Browser</em> <em>Monitoring</em>",
        "sections": "Compatibility and requirements for <em>Browser</em> <em>Monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em> includes strict security measures to provide a robust, standalone product with <em>browser</em> <em>monitoring</em> features. Before you install the <em>Browser</em> agent, make sure your system meets these requirements. Basic requirements To report data to <em>Browser</em>, your application must at a minimum meet"
      },
      "id": "603ed6b664441f4a784e883f"
    }
  ],
  "/docs/browser/new-relic-browser/getting-started/compatibility-requirements-browser-monitoring": [
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.3192,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "If you use <em>Browser</em> to <em>monitor</em> end-user <em>browser</em> activity, you can now see end-user-originating <em>browser</em>-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data"
      },
      "id": "6043fe6f196a6784f0960f53"
    },
    {
      "sections": [
        "Get data into New Relic",
        "New Relic-built agents and integrations",
        "Report custom data"
      ],
      "title": "Get data into New Relic",
      "type": "docs",
      "tags": [
        "Telemetry Data Platform",
        "Ingest and manage data",
        "Get started"
      ],
      "external_id": "1b20f81fa22784c5d22e4e51eb7c0bf26cbdb0b6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/telemetry-data-platform/get-started/introduction-new-relic-data-ingest-apis-sdks/",
      "published_at": "2021-07-01T17:17:17Z",
      "updated_at": "2021-07-01T17:17:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "There are many ways to get data into your New Relic account. Any New Relic user can use any of our data ingest methods to report data to our Telemetry Data Platform. New Relic-built agents and integrations When you enable New Relic solutions like APM, browser monitoring, mobile monitoring, infrastructure monitoring, or any of our wide array of integrations, by default you'll receive data from your monitored applications, hosts, services, or other entities. Some options for getting started: Log into one.newrelic.com and click Add more data to get some guidance on setting up New Relic solutions. To browse our solutions, see New Relic integrations. Report custom data If you need to report data that our agents and integrations don't provide, we have tools that will allow you to bring in any type of data you need. To learn more, see Intro to custom data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 148.89941,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Get</em> data into New Relic",
        "sections": "<em>Get</em> data into New Relic",
        "tags": "<em>Get</em> <em>started</em>",
        "body": ", infrastructure <em>monitoring</em>, or any of our wide array of integrations, by default you&#x27;ll receive data from your monitored applications, hosts, services, or other entities. Some options for <em>getting</em> <em>started</em>: Log into one.newrelic.com and click Add more data to <em>get</em> some guidance on setting up New Relic solutions"
      },
      "id": "603eae7b196a671ea3a83dc7"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-07-01T21:42:46Z",
      "updated_at": "2021-07-01T21:42:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Compatible agent versions Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Compatible: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Compatible only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Compatible only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 137.04895,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Use of other <em>monitoring</em> software",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " New Relic products to give you end-to-end visibility: Product Integration <em>Browser</em> <em>monitoring</em> The Java agent automatically injects the <em>Browser</em> JavaScript agent when you enable auto-instrumentation. After enabling <em>Browser</em> injection, you can view <em>Browser</em> data in the APM Summary page and quickly switch"
      },
      "id": "6043b8f6196a6771a9960f87"
    }
  ],
  "/docs/browser/new-relic-browser/guides/guide-using-browser-spa-apis": [
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.31912,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "If you use <em>Browser</em> to <em>monitor</em> end-user <em>browser</em> activity, you can now see end-user-originating <em>browser</em>-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data"
      },
      "id": "6043fe6f196a6784f0960f53"
    },
    {
      "sections": [
        "Not seeing specific page or endpoint names in Browser data",
        "Problem",
        "Solution"
      ],
      "title": "Not seeing specific page or endpoint names in Browser data",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Troubleshooting"
      ],
      "external_id": "e91e38e0160cd95da45e928f462c70fde1457031",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/troubleshooting/not-seeing-specific-page-or-endpoint-names-browser-data/",
      "published_at": "2021-07-02T00:36:02Z",
      "updated_at": "2021-06-14T22:19:10Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You're looking for performance breakdowns for specific pages or endpoints on the browser monitoring Page views UI page or AJAX UI page. The UI doesn't show the URL group you're looking for, or it only shows / and /*. This behavior also appears in SPA data in BrowserInteraction events and applies to browserInteractionName, targetGroupedUrl, and previousGroupedUrl attributes. Solution Browser monitoring automatically \"learns\" to group your page views when your application is first deployed, and it adds that information to an allow list for URLs. Sometimes this grouping may not match your current page view information. To solve this problem, manage your application's URL segment list settings by editing existing rules or by adding the domains and URL segments that make up your site's URLs. After you add the necessary rules, you should see a useful breakdown of your information in the UI. Here are some useful tips: Adding segments to your allow list Tip Use constant URL segments. Only add the URL segments that remain constant across many page views. Do not add unique segments such as IDs or highly-specific categories, because this can lead to metric grouping issues. Enter exact matches. Enter any URL segments as exact matches, including case. Use existing rules. If a rule already appears for a domain: Go to one.newrelic.com > Browser > (select an app) > Settings > Segment allow lists. Rather than creating a new rule, edit the existing rule, and add the domain to the UI's Allow listed segments field. Group sub-domains. Group similar sub-domains such as foo.domain.com and bar.domain.com under *.domain.com. This grouping must occur just before the top-level domain name. Set up single-page apps. If your site is a single-page application and you only see / under page views, then your grouping is working correctly. New Relic records subsequent requests as AJAX loads, and your AJAX page will contain more detailed information. If it doesn't, then follow the tips in this document. Remove rules when appropriate. If you need to remove a rule, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.11955,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Not seeing specific page or endpoint names in <em>Browser</em> data",
        "sections": "Not seeing specific page or endpoint names in <em>Browser</em> data",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "Problem You&#x27;re looking for performance breakdowns for specific pages or endpoints on the <em>browser</em> <em>monitoring</em> Page views UI page or AJAX UI page. The UI doesn&#x27;t show the URL group you&#x27;re looking for, or it only shows &#x2F; and &#x2F;*. This behavior also appears in SPA data in <em>Browser</em>Interaction events"
      },
      "id": "603e8fff28ccbc8813eba7a1"
    },
    {
      "sections": [
        "Install the browser monitoring agent",
        "Tip",
        "Select a deployment option",
        "Important",
        "Enable an APM-monitored app",
        "Enable with copy/paste",
        "Instrument webpages using the APM agent",
        "Troubleshoot Browser agent installation"
      ],
      "title": "Install the browser monitoring agent",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Installation"
      ],
      "external_id": "bc45bbc86cd4d8b81367ad0904907ddc735717f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/installation/install-browser-monitoring-agent/",
      "published_at": "2021-07-02T09:15:35Z",
      "updated_at": "2021-06-14T21:26:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser uses a JavaScript snippet (or \"agent\") to instrument your app's webpages. The JavaScript collects data for browser monitoring. To install the browser agent, you can choose from a number of deployment options. Tip To use Browser and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Select a deployment option No matter which option you use to deploy browser monitoring, the end result is to inject the browser agent's JavaScript snippet into your pages for browser monitoring. The method you select depends on your preferences and business needs. To view the procedure to install and enable the browser agent, click the link for the option you want to use. You can also use the Browser Application settings page to update settings. Important The following configuration options refer only to the browser monitoring agent. These are not the same as the New Relic user roles and editions. Browser deployment option Description Use the APM agent to inject the JavaScript You can use an APM agent to automatically inject the browser monitoring JavaScript snippet for you. This is the easiest way to install the agent for an app that already is being monitored by APM. (APM-monitored apps are listed on your APM Applications index.) Paste the JavaScript snippet into a webpage This allows you to control the exact placement of the JavaScript into your app's webpage(s) by copying and pasting the browser agent's JavaScript snippet. This is useful for: Standalone apps, static sites, and cached pages delivered by CDN APM apps that are not as closely coupled to the browser app as with a standard server-side app (for example, when your client-side app talks to a REST API back end) Enable single-page app (SPA) monitoring Enabling SPA requires a Pro + SPA browser agent subscription, and you may need to re-deploy the browser JavaScript agent. Use the REST API The REST API lets you manage deployment outside the browser UI. This is useful for large organizations deploying multiple apps. Use an APM agent API to manually instrument the JavaScript snippet For apps that are monitored by APM, you can use the APM agent's API to inject the JavaScript manually instead of automatically. Enable an APM-monitored app Use this procedure to automatically deploy the browser agent on an app that is monitored by APM: Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Enable via New Relic APM. In the Choose your instrumentation section, select Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Select your application section, type or use the search window to find an app's name. Click Enable. Important Node.js: To finish enabling the browser agent for a Node.js app, follow the additional procedure to insert the JavaScript header into the beginning of your HTML page's head tag. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. Enable with copy/paste Use this procedure to insert browser's JavaScript snippet for browser monitoring into your app's webpages yourself. This option is useful for monitoring static sites (such as Jekyll) or cached pages delivered by CDN. Tip Near the bottom of the generated JavaScript is your browser license key and application ID. This is useful with the REST API and API Explorer. Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Copy/Paste JavaScript Code. In the Choose your instrumentation section, select the type of agent: Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Name your app section, name your app: If your app is monitored by APM, select Yes, then type or use the search window to find the app's name. If you have a standalone app for Browser (not monitored by APM), select No, then type the app's name. Click Enable. A new section, Instrument the agent, opens on the page with JavaScript code for your project. Copy the code snippet, then paste it inline into your pages as close to the top of the <head> element as possible, but after any position-sensitive <meta> tags (for example, X-UA-Compatible or charset information). For more information on the inline head placement, see JavaScript placement requirements. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. If you use the copy/paste method, but don't finish the setup process, you can still view and copy the generated JavaScript snippet from your app's Browser Application settings page or by using the REST API (v2). Instrument webpages using the APM agent This information applies to apps that are also monitored by APM. New Relic's agents can instrument webpages with the required JavaScript for page load timing. If you use the APM agent to add the JavaScript snippet to your webpages, insert the instrumentation snippet as close to the top as possible. This allows you to take advantage of detailed information about browser's AJAX calls and JavaScript errors. For more information, see the instructions for your APM agent: C SDK Go Java .NET Node.js PHP Python Ruby Troubleshoot Browser agent installation When you enable browser Pro features for session traces, AJAX calls, or JavaScript errors, it may take approximately five minutes before information becomes available. If you have problems with your browser installation or if no data appears after five minutes, refer to the troubleshooting tips, and restart your agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.07562,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install the <em>browser</em> <em>monitoring</em> agent",
        "sections": "Install the <em>browser</em> <em>monitoring</em> agent",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> uses a JavaScript snippet (or &quot;agent&quot;) to instrument your app&#x27;s webpages. The JavaScript collects data for <em>browser</em> <em>monitoring</em>. To install the <em>browser</em> agent, you can choose from a number of deployment options. Tip To use <em>Browser</em> and the rest of our observability platform, join the New Relic"
      },
      "id": "604429e628ccbcb80b2c60d0"
    }
  ],
  "/docs/browser/new-relic-browser/installation/disable-browser-monitoring": [
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.74414,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "If you use <em>Browser</em> to <em>monitor</em> end-user <em>browser</em> activity, you can now see end-user-originating <em>browser</em>-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data"
      },
      "id": "6043fe6f196a6784f0960f53"
    },
    {
      "sections": [
        "Install the browser monitoring agent",
        "Tip",
        "Select a deployment option",
        "Important",
        "Enable an APM-monitored app",
        "Enable with copy/paste",
        "Instrument webpages using the APM agent",
        "Troubleshoot Browser agent installation"
      ],
      "title": "Install the browser monitoring agent",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Installation"
      ],
      "external_id": "bc45bbc86cd4d8b81367ad0904907ddc735717f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/installation/install-browser-monitoring-agent/",
      "published_at": "2021-07-02T09:15:35Z",
      "updated_at": "2021-06-14T21:26:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser uses a JavaScript snippet (or \"agent\") to instrument your app's webpages. The JavaScript collects data for browser monitoring. To install the browser agent, you can choose from a number of deployment options. Tip To use Browser and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Select a deployment option No matter which option you use to deploy browser monitoring, the end result is to inject the browser agent's JavaScript snippet into your pages for browser monitoring. The method you select depends on your preferences and business needs. To view the procedure to install and enable the browser agent, click the link for the option you want to use. You can also use the Browser Application settings page to update settings. Important The following configuration options refer only to the browser monitoring agent. These are not the same as the New Relic user roles and editions. Browser deployment option Description Use the APM agent to inject the JavaScript You can use an APM agent to automatically inject the browser monitoring JavaScript snippet for you. This is the easiest way to install the agent for an app that already is being monitored by APM. (APM-monitored apps are listed on your APM Applications index.) Paste the JavaScript snippet into a webpage This allows you to control the exact placement of the JavaScript into your app's webpage(s) by copying and pasting the browser agent's JavaScript snippet. This is useful for: Standalone apps, static sites, and cached pages delivered by CDN APM apps that are not as closely coupled to the browser app as with a standard server-side app (for example, when your client-side app talks to a REST API back end) Enable single-page app (SPA) monitoring Enabling SPA requires a Pro + SPA browser agent subscription, and you may need to re-deploy the browser JavaScript agent. Use the REST API The REST API lets you manage deployment outside the browser UI. This is useful for large organizations deploying multiple apps. Use an APM agent API to manually instrument the JavaScript snippet For apps that are monitored by APM, you can use the APM agent's API to inject the JavaScript manually instead of automatically. Enable an APM-monitored app Use this procedure to automatically deploy the browser agent on an app that is monitored by APM: Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Enable via New Relic APM. In the Choose your instrumentation section, select Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Select your application section, type or use the search window to find an app's name. Click Enable. Important Node.js: To finish enabling the browser agent for a Node.js app, follow the additional procedure to insert the JavaScript header into the beginning of your HTML page's head tag. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. Enable with copy/paste Use this procedure to insert browser's JavaScript snippet for browser monitoring into your app's webpages yourself. This option is useful for monitoring static sites (such as Jekyll) or cached pages delivered by CDN. Tip Near the bottom of the generated JavaScript is your browser license key and application ID. This is useful with the REST API and API Explorer. Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Copy/Paste JavaScript Code. In the Choose your instrumentation section, select the type of agent: Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Name your app section, name your app: If your app is monitored by APM, select Yes, then type or use the search window to find the app's name. If you have a standalone app for Browser (not monitored by APM), select No, then type the app's name. Click Enable. A new section, Instrument the agent, opens on the page with JavaScript code for your project. Copy the code snippet, then paste it inline into your pages as close to the top of the <head> element as possible, but after any position-sensitive <meta> tags (for example, X-UA-Compatible or charset information). For more information on the inline head placement, see JavaScript placement requirements. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. If you use the copy/paste method, but don't finish the setup process, you can still view and copy the generated JavaScript snippet from your app's Browser Application settings page or by using the REST API (v2). Instrument webpages using the APM agent This information applies to apps that are also monitored by APM. New Relic's agents can instrument webpages with the required JavaScript for page load timing. If you use the APM agent to add the JavaScript snippet to your webpages, insert the instrumentation snippet as close to the top as possible. This allows you to take advantage of detailed information about browser's AJAX calls and JavaScript errors. For more information, see the instructions for your APM agent: C SDK Go Java .NET Node.js PHP Python Ruby Troubleshoot Browser agent installation When you enable browser Pro features for session traces, AJAX calls, or JavaScript errors, it may take approximately five minutes before information becomes available. If you have problems with your browser installation or if no data appears after five minutes, refer to the troubleshooting tips, and restart your agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.10666,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the <em>browser</em> <em>monitoring</em> agent",
        "sections": "<em>Install</em> the <em>browser</em> <em>monitoring</em> agent",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> uses a JavaScript snippet (or &quot;agent&quot;) to instrument your app&#x27;s webpages. The JavaScript collects data for <em>browser</em> <em>monitoring</em>. To install the <em>browser</em> agent, you can choose from a number of deployment options. Tip To use <em>Browser</em> and the rest of our observability platform, join the New Relic"
      },
      "id": "604429e628ccbcb80b2c60d0"
    },
    {
      "sections": [
        "Collect custom attributes",
        "Requirements",
        "APM: Record custom attributes",
        "Important",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "Browser monitoring: Record custom attributes",
        "Infrastructure monitoring: Record custom attributes",
        "Mobile monitoring: Record custom attributes",
        "For more help"
      ],
      "title": "Collect custom attributes",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Install and configure"
      ],
      "external_id": "ad362b1a5cf3a5661eb416584fd9c79db064f539",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/data/customize-data/collect-custom-attributes/",
      "published_at": "2021-07-02T19:49:53Z",
      "updated_at": "2021-07-02T19:49:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some New Relic solutions, one way to report custom data to New Relic is to use custom attributes. For example, for New Relic browser monitoring, you might create a custom attribute to track the user name associated with a slow or failing request. Requirements Custom attributes are available for these New Relic solutions: APM Browser monitoring Mobile monitoring Infrastructure monitoring For other custom data solutions, see Intro to custom data. APM: Record custom attributes Important Review the list of reserved terms used by NRQL. Using reserved terms can cause issues. To enable and use custom attributes for APM, follow the procedure for your APM agent: C SDK To add custom attributes to applications monitored by the C SDK, call one of the attribute functions; for example, newrelic_add_attribute_double(). The key name for your custom attribute depends on what you specify when you call the function. Go Custom attribute collection is enabled by default in the Go agent. However, you can disable custom attribute collection. Java Custom attribute collection is enabled by default in Java. You can collect custom attributes using XML and the Java agent APIs. These two methods can be used in conjunction with each other. Method How to do it Specify attributes in XML XML allows you to specify custom attributes without changing any of your source code. You can have multiple XML files for custom attributes that are grouped by some logical facet. To set custom attributes for your Java app via XML: Review the New Relic Java agent's documentation about XML file format, methods and classes, and examples. From your Extensions directory within the New Relic Java agent, create a single XML file. Define the methods you want New Relic to monitor by editing your XML file directly. Define an XML instrumentation file using the New Relic UI. This may require additional config in the common: block of your newrelic.yml. See Report custom attributes under Instrumentation options for more detail. Call the agent's API Example 1: Adding custom attributes to transactions To collect custom attributes using the agent's API, call the relevant methods: For each method you want to record an attribute for, call NewRelic.addCustomParameter(...). Optional: Include or exclude certain attributes with attributes.include and attributes.exclude. For example, to record a variable named userId, include this code in the parent method: NewRelic.addCustomParameter(\"userId\", userId); Copy Example 2: Adding custom attributes to spans in distributed traces To collect custom attributes using the agent's API, call the relevant methods: For each span (currently executing method) that you want to record an attribute for, call NewRelic.getAgent().getTracedMethod().addCustomAttribute(...). Optional: Include or exclude certain attributes with span_events.attributes.include and span_events.attributes.exclude. For example, to record a variable named userId on the current span, include this code in the associated method: NewRelic.getAgent().getTracedMethod().addCustomAttribute(\"userId\", userId); Copy Collect user attributes The Java agent also includes a built-in mechanism to enable user attributes and collect user information from HttpServletRequest.getUserPrincipal() as custom attributes. .NET Custom attribute collection is enabled by default in .NET. To collect custom attributes, call the relevant API methods: For each method for which you want to record an attribute, call AddCustomAttribute. Optional: Include or exclude attributes with the include and exclude configuration options. For example, to record attributes for a coupon code (string) and an item ID code (number), you could include this code in the parent method: IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction .AddCustomAttribute(\"Discount Code\", \"Summer Super Sale\") .AddCustomAttribute(\"Item Code\", 31456); Copy Node.js Custom attribute collection is enabled by default in Node.js. To collect custom attributes, call the relevant API method: For each attribute you want to record, call newrelic.addCustomAttribute. To record multiple attributes using a single call, use newrelic.addCustomAttributes. For example, to record attributes for a coupon code and an item ID code, you could include this in the parent method: newrelic.addCustomAttributes({ \"Discount Code\": \"Summer Super Sale\", \"Item Code\": 31456 }); Copy PHP Custom attribute collection is enabled by default in PHP. To collect custom attributes, call the relevant API method for each method that you want to record an attribute; newrelic_add_custom_parameter for transaction events and spans newrelic_add_custom_span_parameter for only spans For example, to record a variable named $userId, include this code in the parent method: newrelic_add_custom_parameter ('userID', $userId) Copy Python Custom attribute collection is enabled by default in Python. To collect custom attributes, call add_custom_parameter for each method that you want to record an attribute. For example, to record a variable named user_id, include this code in the parent method: newrelic.agent.add_custom_parameter('user_id', user_id) Copy Ruby Custom attribute collection is enabled by default in Ruby. To collect custom attributes, call the relevant API methods: For Ruby agent version 3.12.0 or higher, use the add_custom_attributes method. For example, to record a variable named @user_id, include this code in the parent method: ::NewRelic::Agent.add_custom_attributes({ user_id: @user.id }) Copy For Ruby agent version 3.11.2 or lower, use the add_custom_parameters method. For example, to record a variable named @user_id, include this code in the parent method: ::NewRelic::Agent.add_custom_parameters({ user_id: @user.id }) Copy Browser monitoring: Record custom attributes The browser agent provides an API to specify extra details associated with a page view or browser interaction, either by forwarding attributes from APM to browser monitoring or by specifying custom attributes through JavaScript. Values forwarded from the APM agent are encoded and injected into browser attributes by our browser agent. Infrastructure monitoring: Record custom attributes Our Infrastructure monitoring lets you create custom attributes that are used to annotate the data from the infrastructure agent. You can use this metadata to build filter sets, group your results, and annotate your data. Mobile monitoring: Record custom attributes Mobile agents include API calls to record custom attributes: For an overview of mobile monitoring custom data, see Insert custom events and attributes Android method: setAttribute iOS method: setAttribute For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.80661,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Browser</em> <em>monitoring</em>: Record custom attributes",
        "tags": "<em>Install</em> and configure",
        "body": "For some New Relic solutions, one way to report custom data to New Relic is to use custom attributes. For example, for New Relic <em>browser</em> <em>monitoring</em>, you might create a custom attribute to track the user name associated with a slow or failing request. Requirements Custom attributes are available"
      },
      "id": "603eb9a3196a67a990a83da5"
    }
  ],
  "/docs/browser/new-relic-browser/installation/monitor-amp-pages-new-relic-browser": [
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.74402,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "If you use <em>Browser</em> to <em>monitor</em> end-user <em>browser</em> activity, you can now see end-user-originating <em>browser</em>-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data"
      },
      "id": "6043fe6f196a6784f0960f53"
    },
    {
      "sections": [
        "Install the browser monitoring agent",
        "Tip",
        "Select a deployment option",
        "Important",
        "Enable an APM-monitored app",
        "Enable with copy/paste",
        "Instrument webpages using the APM agent",
        "Troubleshoot Browser agent installation"
      ],
      "title": "Install the browser monitoring agent",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Installation"
      ],
      "external_id": "bc45bbc86cd4d8b81367ad0904907ddc735717f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/installation/install-browser-monitoring-agent/",
      "published_at": "2021-07-02T09:15:35Z",
      "updated_at": "2021-06-14T21:26:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser uses a JavaScript snippet (or \"agent\") to instrument your app's webpages. The JavaScript collects data for browser monitoring. To install the browser agent, you can choose from a number of deployment options. Tip To use Browser and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Select a deployment option No matter which option you use to deploy browser monitoring, the end result is to inject the browser agent's JavaScript snippet into your pages for browser monitoring. The method you select depends on your preferences and business needs. To view the procedure to install and enable the browser agent, click the link for the option you want to use. You can also use the Browser Application settings page to update settings. Important The following configuration options refer only to the browser monitoring agent. These are not the same as the New Relic user roles and editions. Browser deployment option Description Use the APM agent to inject the JavaScript You can use an APM agent to automatically inject the browser monitoring JavaScript snippet for you. This is the easiest way to install the agent for an app that already is being monitored by APM. (APM-monitored apps are listed on your APM Applications index.) Paste the JavaScript snippet into a webpage This allows you to control the exact placement of the JavaScript into your app's webpage(s) by copying and pasting the browser agent's JavaScript snippet. This is useful for: Standalone apps, static sites, and cached pages delivered by CDN APM apps that are not as closely coupled to the browser app as with a standard server-side app (for example, when your client-side app talks to a REST API back end) Enable single-page app (SPA) monitoring Enabling SPA requires a Pro + SPA browser agent subscription, and you may need to re-deploy the browser JavaScript agent. Use the REST API The REST API lets you manage deployment outside the browser UI. This is useful for large organizations deploying multiple apps. Use an APM agent API to manually instrument the JavaScript snippet For apps that are monitored by APM, you can use the APM agent's API to inject the JavaScript manually instead of automatically. Enable an APM-monitored app Use this procedure to automatically deploy the browser agent on an app that is monitored by APM: Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Enable via New Relic APM. In the Choose your instrumentation section, select Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Select your application section, type or use the search window to find an app's name. Click Enable. Important Node.js: To finish enabling the browser agent for a Node.js app, follow the additional procedure to insert the JavaScript header into the beginning of your HTML page's head tag. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. Enable with copy/paste Use this procedure to insert browser's JavaScript snippet for browser monitoring into your app's webpages yourself. This option is useful for monitoring static sites (such as Jekyll) or cached pages delivered by CDN. Tip Near the bottom of the generated JavaScript is your browser license key and application ID. This is useful with the REST API and API Explorer. Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Copy/Paste JavaScript Code. In the Choose your instrumentation section, select the type of agent: Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Name your app section, name your app: If your app is monitored by APM, select Yes, then type or use the search window to find the app's name. If you have a standalone app for Browser (not monitored by APM), select No, then type the app's name. Click Enable. A new section, Instrument the agent, opens on the page with JavaScript code for your project. Copy the code snippet, then paste it inline into your pages as close to the top of the <head> element as possible, but after any position-sensitive <meta> tags (for example, X-UA-Compatible or charset information). For more information on the inline head placement, see JavaScript placement requirements. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. If you use the copy/paste method, but don't finish the setup process, you can still view and copy the generated JavaScript snippet from your app's Browser Application settings page or by using the REST API (v2). Instrument webpages using the APM agent This information applies to apps that are also monitored by APM. New Relic's agents can instrument webpages with the required JavaScript for page load timing. If you use the APM agent to add the JavaScript snippet to your webpages, insert the instrumentation snippet as close to the top as possible. This allows you to take advantage of detailed information about browser's AJAX calls and JavaScript errors. For more information, see the instructions for your APM agent: C SDK Go Java .NET Node.js PHP Python Ruby Troubleshoot Browser agent installation When you enable browser Pro features for session traces, AJAX calls, or JavaScript errors, it may take approximately five minutes before information becomes available. If you have problems with your browser installation or if no data appears after five minutes, refer to the troubleshooting tips, and restart your agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.10663,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the <em>browser</em> <em>monitoring</em> agent",
        "sections": "<em>Install</em> the <em>browser</em> <em>monitoring</em> agent",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> uses a JavaScript snippet (or &quot;agent&quot;) to instrument your app&#x27;s webpages. The JavaScript collects data for <em>browser</em> <em>monitoring</em>. To install the <em>browser</em> agent, you can choose from a number of deployment options. Tip To use <em>Browser</em> and the rest of our observability platform, join the New Relic"
      },
      "id": "604429e628ccbcb80b2c60d0"
    },
    {
      "sections": [
        "Collect custom attributes",
        "Requirements",
        "APM: Record custom attributes",
        "Important",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "Browser monitoring: Record custom attributes",
        "Infrastructure monitoring: Record custom attributes",
        "Mobile monitoring: Record custom attributes",
        "For more help"
      ],
      "title": "Collect custom attributes",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Install and configure"
      ],
      "external_id": "ad362b1a5cf3a5661eb416584fd9c79db064f539",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/data/customize-data/collect-custom-attributes/",
      "published_at": "2021-07-02T19:49:53Z",
      "updated_at": "2021-07-02T19:49:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some New Relic solutions, one way to report custom data to New Relic is to use custom attributes. For example, for New Relic browser monitoring, you might create a custom attribute to track the user name associated with a slow or failing request. Requirements Custom attributes are available for these New Relic solutions: APM Browser monitoring Mobile monitoring Infrastructure monitoring For other custom data solutions, see Intro to custom data. APM: Record custom attributes Important Review the list of reserved terms used by NRQL. Using reserved terms can cause issues. To enable and use custom attributes for APM, follow the procedure for your APM agent: C SDK To add custom attributes to applications monitored by the C SDK, call one of the attribute functions; for example, newrelic_add_attribute_double(). The key name for your custom attribute depends on what you specify when you call the function. Go Custom attribute collection is enabled by default in the Go agent. However, you can disable custom attribute collection. Java Custom attribute collection is enabled by default in Java. You can collect custom attributes using XML and the Java agent APIs. These two methods can be used in conjunction with each other. Method How to do it Specify attributes in XML XML allows you to specify custom attributes without changing any of your source code. You can have multiple XML files for custom attributes that are grouped by some logical facet. To set custom attributes for your Java app via XML: Review the New Relic Java agent's documentation about XML file format, methods and classes, and examples. From your Extensions directory within the New Relic Java agent, create a single XML file. Define the methods you want New Relic to monitor by editing your XML file directly. Define an XML instrumentation file using the New Relic UI. This may require additional config in the common: block of your newrelic.yml. See Report custom attributes under Instrumentation options for more detail. Call the agent's API Example 1: Adding custom attributes to transactions To collect custom attributes using the agent's API, call the relevant methods: For each method you want to record an attribute for, call NewRelic.addCustomParameter(...). Optional: Include or exclude certain attributes with attributes.include and attributes.exclude. For example, to record a variable named userId, include this code in the parent method: NewRelic.addCustomParameter(\"userId\", userId); Copy Example 2: Adding custom attributes to spans in distributed traces To collect custom attributes using the agent's API, call the relevant methods: For each span (currently executing method) that you want to record an attribute for, call NewRelic.getAgent().getTracedMethod().addCustomAttribute(...). Optional: Include or exclude certain attributes with span_events.attributes.include and span_events.attributes.exclude. For example, to record a variable named userId on the current span, include this code in the associated method: NewRelic.getAgent().getTracedMethod().addCustomAttribute(\"userId\", userId); Copy Collect user attributes The Java agent also includes a built-in mechanism to enable user attributes and collect user information from HttpServletRequest.getUserPrincipal() as custom attributes. .NET Custom attribute collection is enabled by default in .NET. To collect custom attributes, call the relevant API methods: For each method for which you want to record an attribute, call AddCustomAttribute. Optional: Include or exclude attributes with the include and exclude configuration options. For example, to record attributes for a coupon code (string) and an item ID code (number), you could include this code in the parent method: IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction .AddCustomAttribute(\"Discount Code\", \"Summer Super Sale\") .AddCustomAttribute(\"Item Code\", 31456); Copy Node.js Custom attribute collection is enabled by default in Node.js. To collect custom attributes, call the relevant API method: For each attribute you want to record, call newrelic.addCustomAttribute. To record multiple attributes using a single call, use newrelic.addCustomAttributes. For example, to record attributes for a coupon code and an item ID code, you could include this in the parent method: newrelic.addCustomAttributes({ \"Discount Code\": \"Summer Super Sale\", \"Item Code\": 31456 }); Copy PHP Custom attribute collection is enabled by default in PHP. To collect custom attributes, call the relevant API method for each method that you want to record an attribute; newrelic_add_custom_parameter for transaction events and spans newrelic_add_custom_span_parameter for only spans For example, to record a variable named $userId, include this code in the parent method: newrelic_add_custom_parameter ('userID', $userId) Copy Python Custom attribute collection is enabled by default in Python. To collect custom attributes, call add_custom_parameter for each method that you want to record an attribute. For example, to record a variable named user_id, include this code in the parent method: newrelic.agent.add_custom_parameter('user_id', user_id) Copy Ruby Custom attribute collection is enabled by default in Ruby. To collect custom attributes, call the relevant API methods: For Ruby agent version 3.12.0 or higher, use the add_custom_attributes method. For example, to record a variable named @user_id, include this code in the parent method: ::NewRelic::Agent.add_custom_attributes({ user_id: @user.id }) Copy For Ruby agent version 3.11.2 or lower, use the add_custom_parameters method. For example, to record a variable named @user_id, include this code in the parent method: ::NewRelic::Agent.add_custom_parameters({ user_id: @user.id }) Copy Browser monitoring: Record custom attributes The browser agent provides an API to specify extra details associated with a page view or browser interaction, either by forwarding attributes from APM to browser monitoring or by specifying custom attributes through JavaScript. Values forwarded from the APM agent are encoded and injected into browser attributes by our browser agent. Infrastructure monitoring: Record custom attributes Our Infrastructure monitoring lets you create custom attributes that are used to annotate the data from the infrastructure agent. You can use this metadata to build filter sets, group your results, and annotate your data. Mobile monitoring: Record custom attributes Mobile agents include API calls to record custom attributes: For an overview of mobile monitoring custom data, see Insert custom events and attributes Android method: setAttribute iOS method: setAttribute For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.80652,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Browser</em> <em>monitoring</em>: Record custom attributes",
        "tags": "<em>Install</em> and configure",
        "body": "For some New Relic solutions, one way to report custom data to New Relic is to use custom attributes. For example, for New Relic <em>browser</em> <em>monitoring</em>, you might create a custom attribute to track the user name associated with a slow or failing request. Requirements Custom attributes are available"
      },
      "id": "603eb9a3196a67a990a83da5"
    }
  ],
  "/docs/browser/new-relic-browser/installation/update-browser-agent": [
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.74402,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "If you use <em>Browser</em> to <em>monitor</em> end-user <em>browser</em> activity, you can now see end-user-originating <em>browser</em>-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data"
      },
      "id": "6043fe6f196a6784f0960f53"
    },
    {
      "sections": [
        "Install the browser monitoring agent",
        "Tip",
        "Select a deployment option",
        "Important",
        "Enable an APM-monitored app",
        "Enable with copy/paste",
        "Instrument webpages using the APM agent",
        "Troubleshoot Browser agent installation"
      ],
      "title": "Install the browser monitoring agent",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Installation"
      ],
      "external_id": "bc45bbc86cd4d8b81367ad0904907ddc735717f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/installation/install-browser-monitoring-agent/",
      "published_at": "2021-07-02T09:15:35Z",
      "updated_at": "2021-06-14T21:26:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser uses a JavaScript snippet (or \"agent\") to instrument your app's webpages. The JavaScript collects data for browser monitoring. To install the browser agent, you can choose from a number of deployment options. Tip To use Browser and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Select a deployment option No matter which option you use to deploy browser monitoring, the end result is to inject the browser agent's JavaScript snippet into your pages for browser monitoring. The method you select depends on your preferences and business needs. To view the procedure to install and enable the browser agent, click the link for the option you want to use. You can also use the Browser Application settings page to update settings. Important The following configuration options refer only to the browser monitoring agent. These are not the same as the New Relic user roles and editions. Browser deployment option Description Use the APM agent to inject the JavaScript You can use an APM agent to automatically inject the browser monitoring JavaScript snippet for you. This is the easiest way to install the agent for an app that already is being monitored by APM. (APM-monitored apps are listed on your APM Applications index.) Paste the JavaScript snippet into a webpage This allows you to control the exact placement of the JavaScript into your app's webpage(s) by copying and pasting the browser agent's JavaScript snippet. This is useful for: Standalone apps, static sites, and cached pages delivered by CDN APM apps that are not as closely coupled to the browser app as with a standard server-side app (for example, when your client-side app talks to a REST API back end) Enable single-page app (SPA) monitoring Enabling SPA requires a Pro + SPA browser agent subscription, and you may need to re-deploy the browser JavaScript agent. Use the REST API The REST API lets you manage deployment outside the browser UI. This is useful for large organizations deploying multiple apps. Use an APM agent API to manually instrument the JavaScript snippet For apps that are monitored by APM, you can use the APM agent's API to inject the JavaScript manually instead of automatically. Enable an APM-monitored app Use this procedure to automatically deploy the browser agent on an app that is monitored by APM: Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Enable via New Relic APM. In the Choose your instrumentation section, select Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Select your application section, type or use the search window to find an app's name. Click Enable. Important Node.js: To finish enabling the browser agent for a Node.js app, follow the additional procedure to insert the JavaScript header into the beginning of your HTML page's head tag. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. Enable with copy/paste Use this procedure to insert browser's JavaScript snippet for browser monitoring into your app's webpages yourself. This option is useful for monitoring static sites (such as Jekyll) or cached pages delivered by CDN. Tip Near the bottom of the generated JavaScript is your browser license key and application ID. This is useful with the REST API and API Explorer. Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Copy/Paste JavaScript Code. In the Choose your instrumentation section, select the type of agent: Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Name your app section, name your app: If your app is monitored by APM, select Yes, then type or use the search window to find the app's name. If you have a standalone app for Browser (not monitored by APM), select No, then type the app's name. Click Enable. A new section, Instrument the agent, opens on the page with JavaScript code for your project. Copy the code snippet, then paste it inline into your pages as close to the top of the <head> element as possible, but after any position-sensitive <meta> tags (for example, X-UA-Compatible or charset information). For more information on the inline head placement, see JavaScript placement requirements. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. If you use the copy/paste method, but don't finish the setup process, you can still view and copy the generated JavaScript snippet from your app's Browser Application settings page or by using the REST API (v2). Instrument webpages using the APM agent This information applies to apps that are also monitored by APM. New Relic's agents can instrument webpages with the required JavaScript for page load timing. If you use the APM agent to add the JavaScript snippet to your webpages, insert the instrumentation snippet as close to the top as possible. This allows you to take advantage of detailed information about browser's AJAX calls and JavaScript errors. For more information, see the instructions for your APM agent: C SDK Go Java .NET Node.js PHP Python Ruby Troubleshoot Browser agent installation When you enable browser Pro features for session traces, AJAX calls, or JavaScript errors, it may take approximately five minutes before information becomes available. If you have problems with your browser installation or if no data appears after five minutes, refer to the troubleshooting tips, and restart your agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 154.10663,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the <em>browser</em> <em>monitoring</em> agent",
        "sections": "<em>Install</em> the <em>browser</em> <em>monitoring</em> agent",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> uses a JavaScript snippet (or &quot;agent&quot;) to instrument your app&#x27;s webpages. The JavaScript collects data for <em>browser</em> <em>monitoring</em>. To install the <em>browser</em> agent, you can choose from a number of deployment options. Tip To use <em>Browser</em> and the rest of our observability platform, join the New Relic"
      },
      "id": "604429e628ccbcb80b2c60d0"
    },
    {
      "sections": [
        "Collect custom attributes",
        "Requirements",
        "APM: Record custom attributes",
        "Important",
        "C SDK",
        "Go",
        "Java",
        ".NET",
        "Node.js",
        "PHP",
        "Python",
        "Ruby",
        "Browser monitoring: Record custom attributes",
        "Infrastructure monitoring: Record custom attributes",
        "Mobile monitoring: Record custom attributes",
        "For more help"
      ],
      "title": "Collect custom attributes",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Cross-product functions",
        "Install and configure"
      ],
      "external_id": "ad362b1a5cf3a5661eb416584fd9c79db064f539",
      "image": "",
      "url": "https://docs.newrelic.com/docs/using-new-relic/data/customize-data/collect-custom-attributes/",
      "published_at": "2021-07-02T19:49:53Z",
      "updated_at": "2021-07-02T19:49:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For some New Relic solutions, one way to report custom data to New Relic is to use custom attributes. For example, for New Relic browser monitoring, you might create a custom attribute to track the user name associated with a slow or failing request. Requirements Custom attributes are available for these New Relic solutions: APM Browser monitoring Mobile monitoring Infrastructure monitoring For other custom data solutions, see Intro to custom data. APM: Record custom attributes Important Review the list of reserved terms used by NRQL. Using reserved terms can cause issues. To enable and use custom attributes for APM, follow the procedure for your APM agent: C SDK To add custom attributes to applications monitored by the C SDK, call one of the attribute functions; for example, newrelic_add_attribute_double(). The key name for your custom attribute depends on what you specify when you call the function. Go Custom attribute collection is enabled by default in the Go agent. However, you can disable custom attribute collection. Java Custom attribute collection is enabled by default in Java. You can collect custom attributes using XML and the Java agent APIs. These two methods can be used in conjunction with each other. Method How to do it Specify attributes in XML XML allows you to specify custom attributes without changing any of your source code. You can have multiple XML files for custom attributes that are grouped by some logical facet. To set custom attributes for your Java app via XML: Review the New Relic Java agent's documentation about XML file format, methods and classes, and examples. From your Extensions directory within the New Relic Java agent, create a single XML file. Define the methods you want New Relic to monitor by editing your XML file directly. Define an XML instrumentation file using the New Relic UI. This may require additional config in the common: block of your newrelic.yml. See Report custom attributes under Instrumentation options for more detail. Call the agent's API Example 1: Adding custom attributes to transactions To collect custom attributes using the agent's API, call the relevant methods: For each method you want to record an attribute for, call NewRelic.addCustomParameter(...). Optional: Include or exclude certain attributes with attributes.include and attributes.exclude. For example, to record a variable named userId, include this code in the parent method: NewRelic.addCustomParameter(\"userId\", userId); Copy Example 2: Adding custom attributes to spans in distributed traces To collect custom attributes using the agent's API, call the relevant methods: For each span (currently executing method) that you want to record an attribute for, call NewRelic.getAgent().getTracedMethod().addCustomAttribute(...). Optional: Include or exclude certain attributes with span_events.attributes.include and span_events.attributes.exclude. For example, to record a variable named userId on the current span, include this code in the associated method: NewRelic.getAgent().getTracedMethod().addCustomAttribute(\"userId\", userId); Copy Collect user attributes The Java agent also includes a built-in mechanism to enable user attributes and collect user information from HttpServletRequest.getUserPrincipal() as custom attributes. .NET Custom attribute collection is enabled by default in .NET. To collect custom attributes, call the relevant API methods: For each method for which you want to record an attribute, call AddCustomAttribute. Optional: Include or exclude attributes with the include and exclude configuration options. For example, to record attributes for a coupon code (string) and an item ID code (number), you could include this code in the parent method: IAgent agent = NewRelic.Api.Agent.NewRelic.GetAgent(); ITransaction transaction = agent.CurrentTransaction; transaction .AddCustomAttribute(\"Discount Code\", \"Summer Super Sale\") .AddCustomAttribute(\"Item Code\", 31456); Copy Node.js Custom attribute collection is enabled by default in Node.js. To collect custom attributes, call the relevant API method: For each attribute you want to record, call newrelic.addCustomAttribute. To record multiple attributes using a single call, use newrelic.addCustomAttributes. For example, to record attributes for a coupon code and an item ID code, you could include this in the parent method: newrelic.addCustomAttributes({ \"Discount Code\": \"Summer Super Sale\", \"Item Code\": 31456 }); Copy PHP Custom attribute collection is enabled by default in PHP. To collect custom attributes, call the relevant API method for each method that you want to record an attribute; newrelic_add_custom_parameter for transaction events and spans newrelic_add_custom_span_parameter for only spans For example, to record a variable named $userId, include this code in the parent method: newrelic_add_custom_parameter ('userID', $userId) Copy Python Custom attribute collection is enabled by default in Python. To collect custom attributes, call add_custom_parameter for each method that you want to record an attribute. For example, to record a variable named user_id, include this code in the parent method: newrelic.agent.add_custom_parameter('user_id', user_id) Copy Ruby Custom attribute collection is enabled by default in Ruby. To collect custom attributes, call the relevant API methods: For Ruby agent version 3.12.0 or higher, use the add_custom_attributes method. For example, to record a variable named @user_id, include this code in the parent method: ::NewRelic::Agent.add_custom_attributes({ user_id: @user.id }) Copy For Ruby agent version 3.11.2 or lower, use the add_custom_parameters method. For example, to record a variable named @user_id, include this code in the parent method: ::NewRelic::Agent.add_custom_parameters({ user_id: @user.id }) Copy Browser monitoring: Record custom attributes The browser agent provides an API to specify extra details associated with a page view or browser interaction, either by forwarding attributes from APM to browser monitoring or by specifying custom attributes through JavaScript. Values forwarded from the APM agent are encoded and injected into browser attributes by our browser agent. Infrastructure monitoring: Record custom attributes Our Infrastructure monitoring lets you create custom attributes that are used to annotate the data from the infrastructure agent. You can use this metadata to build filter sets, group your results, and annotate your data. Mobile monitoring: Record custom attributes Mobile agents include API calls to record custom attributes: For an overview of mobile monitoring custom data, see Insert custom events and attributes Android method: setAttribute iOS method: setAttribute For more help",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.80652,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Browser</em> <em>monitoring</em>: Record custom attributes",
        "tags": "<em>Install</em> and configure",
        "body": "For some New Relic solutions, one way to report custom data to New Relic is to use custom attributes. For example, for New Relic <em>browser</em> <em>monitoring</em>, you might create a custom attribute to track the user name associated with a slow or failing request. Requirements Custom attributes are available"
      },
      "id": "603eb9a3196a67a990a83da5"
    }
  ],
  "/docs/browser/new-relic-browser/page-load-timing-resources/cached-pages": [
    {
      "sections": [
        "PageViewTiming: Async or dynamic page details",
        "Why use PageViewTiming?",
        "Support for Google's Core Web Vitals",
        "Detailed visual, interactivity, and responsiveness metrics",
        "Compatibility and requirements",
        "Query your event data",
        "Percentile over timeseries",
        "Percentile by transaction and interaction",
        "Histogram of delay timings"
      ],
      "title": "PageViewTiming: Async or dynamic page details",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "069f311598f5df27ee46006693b077f7f8b8d146",
      "image": "https://docs.newrelic.com/static/e19694ae33f749d66a346968f23bfb5a/c1b63/core-web-vitals_0.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details/",
      "published_at": "2021-07-02T00:31:09Z",
      "updated_at": "2021-03-16T07:25:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its attributes to query data about your site, component loading, and user performance metrics, both from visual and responsiveness standpoints. Why use PageViewTiming? If your application uses asynchronous or dynamic pages, you may need additional details about site or component loading. But pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the Browser agent. For example, users may become impatient and begin clicking as soon as content is on the webpage. Or, they may wait to use the page until long after content is loaded. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. The additional metrics can help you understand how users experience your site, both from visual and responsiveness standpoints. Support for Google's Core Web Vitals We now, with the release of agent version 1177, have full support for Google's Core Web Vitals for 2020. The metrics that make up Core Web Vitals will evolve over time. The current set for 2020 focuses on three aspects of the user experienceâ€”loading, interactivity, and visual stabilityâ€”and includes the following metrics (and their respective thresholds): Core Web Vitals metrics include loading, interactivity, and visual stability. Largest Contentful Paint (LCP): measures loading performance. To provide a good user experience, LCP should occur within 2.5 seconds of when the page first starts loading. First Input Delay (FID): measures interactivity. To provide a good user experience, pages should have a FID of less than 100 milliseconds. Cumulative Layout Shift (CLS): measures visual stability. To provide a good user experience, pages should maintain a CLS of less than 0.1. For each of the above metrics, to ensure you're hitting the recommended target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices. To learn more, watch our Nerd Days talk on perceived performance. Detailed visual, interactivity, and responsiveness metrics The BrowserInteraction and PageView events end their reporting when they receive the page window load (or window load and AJAX) timing. However, paint and interactivity metrics can happen at any time. PageViewTiming delivers these metrics as a separate event to: Account for the variability in this timing. Avoid setting an arbitrary timeout. Prevent holding BrowserInteraction and PageView events indefinitely. Additional data Comments firstPaint and firstContentfulPaint The firstPaint and firstContentfulPaint attributes already are available with BrowserInteraction and PageView events. However, they are not always reliably captured before the window onload event fires. Using PageViewTiming gives you a way to capture these metrics even if they happen after the original page load time. This gives you a better understanding of the correlation between responsiveness of that load event and the visual rendering of your content. largestContentfulPaint This new metric, available with agent version 1163, largestContentfulPaint, reports the render time of the largest content element visible in the viewport. Google's research found looking at when the largest element was rendered was a more accurate way to measure when the main content of a page is loaded and useful. Details on this metric, including limitations and considerations can be found in the w3c draft. In addition, we now report the cumulative layout shift (CLS) score attribute with LCP. This attribute is reported as cumulativeLayoutShift. Largest Contentful Paint is one of three metrics identified by Google as the Core Web Vitals. LCP values up to 2.5 secs are considered \"Good\", between 2.5-4.0 secs considered \"Needs Improvement\", and above 4.0 secs considered \"Poor.\" firstInteraction and firstInputDelay With the addition of firstInteraction and firstInputDelay, you can quickly determine the ways that your users are interacting with that visual content. These metrics tell you not only when they interacted, but what type of interaction (mousedown, pointerdown, etc.) and how long it took for them to receive a response from your site. The firstInputDelay metric lies in the middle of FirstContentfulPaint and Time to Interactive (TTI) metrics, measuring the time between when a first input can be made and when the browser's main thread is able to respond to any interactions. In addition, we now report the cumulative layout shift (CLS) score attribute at the moment of the user's first interaction. This attribute is reported as cumulativeLayoutShift. First Input Delay is one of three metrics identified by Google as the Core Web Vitals. FID values up to 100 ms are considered \"Good\", between 100-300 ms considered \"Needs Improvement\", and above 300 ms considered \"Poor.\" For a more detailed explanation, see the Browser release notes. cumulativeLayoutShift Cumulative Layout Shift (CLS), available with agent v1177, is an important, user-centric metric for measuring visual stability because it helps quantify how often users experience unexpected layout shiftsâ€”a low CLS helps ensure that the page is delightful. This is one of three metrics identified by Google as the Core Web Vitals. Cumulative Layout Shift is one of three metrics identified by Google as the Core Web Vitals. CLS scores up to 0.1 are considered \"Good\", between 0.1-0.25 considered \"Needs Improvement\", and above 0.25 considered \"Poor.\" timingName You can review different types of activities with the timingName attribute, such as firstPaint, firstContentfulPaint, firstInteraction, largestContentfulPaint, pageHide and windowUnload. For example, a PageViewTiming event may have a timingName of firstPaint and a firstPaint value of .03. The event will also include all default attributes included with the standard BrowserInteraction and PageView events. elementId This is the Id, if specified, of the largestContentfulPaint element. This value will only be reported with the LCP metric. This value can be null. elementSize This is the reported size of the largestContentfulPaint element. This value will only be reported with the LCP metric. pageHide The pageHide event, available with agent v1177, is sent when the browser hides the current page in the process of presenting a different page from the session's history. For example, when the user clicks the browser's Back button, the current page receives a pageHide event before the previous page is shown. Supporting documentation and browser compatibility for the pageHide event can be found in MDN docs. In addition, we now report the cumulative layout shift (CLS) score attribute with pageHide. This attribute is reported as cumulativeLayoutShift. windowLoad The windowLoad event, available with agent v1177, is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. Supporting documentation and browser compatibility for the Window Load event can be found in MDN docs. In addition, we now report the cumulative layout shift (CLS) score attribute with windowLoad. This attribute is reported as cumulativeLayoutShift. windowUnload The windowUnload event, available with agent v1163, is fired when a document or child resource is being unloaded. Supporting documentation and browser compatibility for the Window Unload event can be found in MDN docs. In addition, we now report the cumulative layout shift (CLS) score attribute with windowUnload. This attribute is reported as cumulativeLayoutShift. Compatibility and requirements In addition to Browser's installation requirements, the PageViewTiming event requires Browser agent version 1153 or higher and a Browser Pro subscription. Follow our Browser agent release notes to find out when new metrics are released. These metrics are supported by the following browser versions. For unsupported browsers, no PageViewTiming events will be recorded. Metrics Supported browser versions cumulativeLayoutShift Chrome 79 Metric is elevated to stable; changes in metric definition will be reported in this log. Chrome 77 Metric exposed via API: Cumulative Layout Shift available via Layout Instability API firstPaint firstContentfulPaint Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile largestContentfulPaint Chrome 77 or higher for desktop and mobile firstInteraction firstInputDelay These metrics require the addEventListener Browser API. This API is available in all modern browsers, including: Apple Safari Google Chrome Microsoft Internet Explorer (IE) versions 9 or higher Mozilla Firefox pageHide This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowLoad This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowUnload This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. Query your event data Here are some sample queries for the event data to help you get started. Percentile over timeseries Show the 95th percentile of first paint and first contentful paint over a time series: SELECT FILTER(percentile(firstPaint, 95), where(timingName = ' firstPaint ')) as 'fp', FILTER(percentile( firstContentfulPaint , 95), where(timingName = 'firstContentfulPaint')) as 'fcp' FROM PageViewTiming TIMESERIES 1 minute SINCE 1 hour ago Copy Percentile by transaction and interaction Show the 95th percentile of first input delay over a time series, faceted by transaction name and interaction type: SELECT percentile( firstInputDelay , 95) as 'fid' FROM PageViewTiming WHERE timingName = 'firstInteraction' TIMESERIES 1 minute FACET browserTransactionName, interactionType SINCE 3 hours ago Copy Histogram of delay timings Show a histogram of first input delay timings faceted by first interaction time ranges: FROM PageViewTiming SELECT histogram( firstInputDelay , 1000, 10) SINCE 3 hours ago WHERE timingName = 'firstInteraction' FACET CASES (WHERE firstInteraction < 1, WHERE firstInteraction >= 1 AND firstInteraction < 5, WHERE firstInteraction >= 5) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.11304,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>PageViewTiming</em>: Async or dynamic <em>page</em> details",
        "sections": "<em>PageViewTiming</em>: Async or dynamic <em>page</em> details",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": " and firstContentfulPaint attributes already are available with <em>Browser</em>Interaction and <em>Page</em>View events. However, they are not always reliably captured before the window onload event fires. Using <em>PageViewTiming</em> gives you a way to capture these metrics even if they happen after the original <em>page</em> <em>load</em> <em>time</em>"
      },
      "id": "603ea90a64441f02614e88a4"
    },
    {
      "sections": [
        "New Relic cookies used by Browser",
        "Tip",
        "Data privacy and legal compliance",
        "JSESSIONID",
        "NREUM",
        "NRAGENT"
      ],
      "title": "New Relic cookies used by Browser",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "fe0f7b83aafd52fce5ffff3176545910ed9cbb54",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/page-load-timing-resources/new-relic-cookies-used-browser/",
      "published_at": "2021-07-02T09:17:12Z",
      "updated_at": "2021-03-11T05:02:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes data privacy related to Browser monitoring and cookies, and details about the cookies themselves. Page load timing (sometimes referred to as real user monitoring or RUM) creates the following cookies that Browser monitoring uses when session tracking in end-user browsers. Tip These cookies are related to Browser app monitoring. For more information about data privacy and requesting data to be deleted, see New Relic personal data requests. Data privacy and legal compliance The default Browser agent configuration does not retain any personal data as defined by common privacy laws such as the EU General Data Protection Regulation (GDPR) and California Consumer Privacy Act (CCPA). New Relic has taken steps to enable our customers who elect to process personal data in our products to do so in accordance with applicable privacy laws. Use the additional information below to help enable your compliance with such laws: Data Description IP addresses New Relic briefly collects and leverages the IP address from the end-user as part of the data collection process. The IP is captured when a connection is made between the end user's browser and the New Relic data collector. The IP address is included in the web request, much like a caller ID. New Relic uses the IP, much like you see a phone number when somebody calls you. The IP address is used as a lookup value that maps to additional details, allowing New Relic customers to diagnose performance issues. IP address lookup values include: countryCode regionCode city asn (Autonomous System Number) asnOrganization (ISP/Business/Institution) asnLatitude asnLongitude The mapping process for the IP address lookup value is typically complete within minutes, but in some extreme cases may take up to 24 hours to process. Once the mapping process is complete, New Relic no longer retains the IP address. Default cookies The Browser monitoring agent sets cookies by default. Cookies are placed by the Browser agent and the New Relic collector. The New Relic collector places a cookie when the Browser agent makes a connection and transmits data. A cookie consent manager that uses a conditional script loader that only loads tags/snippets when a visitor agrees to a specific type of cookies can be used. By choosing this option there is a risk that page performance will not be captured until the visitor has agreed and the Browser agent is running. With the release of Browser agent v1169, you can turn off cookie collection (JSESSIONID and NREUM) for your Browser app by using the Application settings page in the New Relic UI. Once this configuration value is set to false (OFF), you will no longer see the session information in your event data. By default, the value is set to true (ON) for all existing Browser apps as well as newly created ones. For more information, see our documentation about cookie collection and session tracking. Personal data through custom Browser configuration New Relic offers the option to manually configure your agent through the Browser monitoring API. This could be used to capture personal data, subject to the restrictions set forth in the Terms of Service with New Relic. (For example, no credit card numbers or sensitive categories of personal data, which are contractually prohibited.) New Relic responds to the instructions specified by the agents, including collecting personal data that may be custom configured. If you (as the data controller) receive a request from one of your own customers and determine that personal data sent to New Relic for processing must be deleted, see New Relic personal data requests. JSESSIONID The JSESSIONID cookie is used to store a session identifier so that New Relic can monitor session counts for an application. The cookie value is generated by Jetty. Components Description Session identifier This is used by New Relic to monitor session counts for an application. Domain The JSESSIONID cookie is associated with the New Relic domain. Expiration JSESSIONID is a session cookie that is deleted when the browser closes. NREUM This cookie is only created in browsers that do not support the Navigation Timing API. When a browser supports the Navigation Timing API, a native interface can be used to determine navigation start time. Mozilla Firefox versions 7 or higher support the Navigation Timing API. However, a bug exists in Firefox's early implementations of the Navigation Timing API that Browser monitoring works around by using this cookie. Components Description Navigation start time Navigation start time is required to measure end user response time. The cookie is written when the current page unloads (as the next navigation begins). Document location Stored as a hash. The document location is used with the referring page URL to validate that the start time refers to the page that was previously being viewed or refreshed (to avoid using an invalid start time from a different navigation). Referring page URLs Stored as a hash. The referring page URL is used with the document location to validate that the start time refers to the page that was previously being viewed or refreshed (to avoid using an invalid start time from a different navigation). Domain The NREUM cookie is associated with the root path of the domain in which the New Relic agent executes. Expiration NREUM is a session cookie that is deleted when the browser closes. NRAGENT The NRAGENT cookie is set only if you use Browser agent version v443 or lower. It is created when a token is handed out to an end user by the New Relic collector. End-user metrics are communicated to New Relic collectors via a JSONP request from the browser (script retrieval). The returned JavaScript contains a call to set the token identifier which is written to the cookie on the next navigation (when the page unloads). This achieves a cross-domain communication between the New Relic collector and the New Relic agent. This cookie is used to communicate between the New Relic collector aggregating end user metrics and the agent(s) running in the associated web application. A token identifies and correlates application tier transaction traces with corresponding browser traces. Components Description Token identifier The 16-character token identifier helps with cross-domain communication between the New Relic collector and the New Relic agent. Domain The NRAGENT cookie is associated with the root path of the domain in which the New Relic agent executes. Expiration NRAGENT is a session cookie that is deleted when the browser closes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 219.33653,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic cookies used by <em>Browser</em>",
        "sections": "New Relic cookies used by <em>Browser</em>",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "This document describes data privacy related to <em>Browser</em> <em>monitoring</em> and cookies, and details about the cookies themselves. <em>Page</em> <em>load</em> <em>timing</em> (sometimes referred to as real user <em>monitoring</em> or RUM) creates the following cookies that <em>Browser</em> <em>monitoring</em> uses when session tracking in end-user browsers"
      },
      "id": "60442a2f196a673c3e960f2f"
    },
    {
      "sections": [
        "Cookie collection and session tracking",
        "How it works",
        "Enable or disable cookie collection"
      ],
      "title": "Cookie collection and session tracking",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "4ad3150808fab2f68a2f944a8966ab9b60ee684b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/page-load-timing-resources/cookie-collection-session-tracking/",
      "published_at": "2021-07-02T09:17:12Z",
      "updated_at": "2021-03-11T05:02:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's page load timing feature can track sessions by using cookies that contain a simple session identifier. How it works Here is the basic process for session tracking: A session begins when a user visits a website where New Relic's browser monitoring is installed and cookie collection is enabled. After the user's browser is opened, our browser monitoring script sets a simple cookie identifying the session. The script then reads the cookie on subsequent page loads. The same session will continue until the user's browser is closed. Session tracking will not work properly in these situations: If users have cookies disabled in their browser If the browser is configured to not allow information associated with the New Relic cookie to be sent with the request from the monitored site Enable or disable cookie collection At New Relic, we take data privacy seriously. By default, we do not retain any personal data collected by our Browser agent, and you can control session tracking. To turn cookie collection on or off for your app: Go to one.newrelic.com > Browser > (select an app) > Settings > Application settings. In your app's Privacy settings, toggle Cookie collection.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 219.33653,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "<em>Browser</em> <em>monitoring</em>&#x27;s <em>page</em> <em>load</em> <em>timing</em> feature can track sessions by using cookies that contain a simple session identifier. How it works Here is the basic process for session tracking: A session begins when a user visits a website where New Relic&#x27;s <em>browser</em> <em>monitoring</em> is installed and cookie"
      },
      "id": "60442a2f28ccbc1bfe2c60a7"
    }
  ],
  "/docs/browser/new-relic-browser/page-load-timing-resources/instrumentation-browser-monitoring": [
    {
      "sections": [
        "PageViewTiming: Async or dynamic page details",
        "Why use PageViewTiming?",
        "Support for Google's Core Web Vitals",
        "Detailed visual, interactivity, and responsiveness metrics",
        "Compatibility and requirements",
        "Query your event data",
        "Percentile over timeseries",
        "Percentile by transaction and interaction",
        "Histogram of delay timings"
      ],
      "title": "PageViewTiming: Async or dynamic page details",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "069f311598f5df27ee46006693b077f7f8b8d146",
      "image": "https://docs.newrelic.com/static/e19694ae33f749d66a346968f23bfb5a/c1b63/core-web-vitals_0.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details/",
      "published_at": "2021-07-02T00:31:09Z",
      "updated_at": "2021-03-16T07:25:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its attributes to query data about your site, component loading, and user performance metrics, both from visual and responsiveness standpoints. Why use PageViewTiming? If your application uses asynchronous or dynamic pages, you may need additional details about site or component loading. But pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the Browser agent. For example, users may become impatient and begin clicking as soon as content is on the webpage. Or, they may wait to use the page until long after content is loaded. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. The additional metrics can help you understand how users experience your site, both from visual and responsiveness standpoints. Support for Google's Core Web Vitals We now, with the release of agent version 1177, have full support for Google's Core Web Vitals for 2020. The metrics that make up Core Web Vitals will evolve over time. The current set for 2020 focuses on three aspects of the user experienceâ€”loading, interactivity, and visual stabilityâ€”and includes the following metrics (and their respective thresholds): Core Web Vitals metrics include loading, interactivity, and visual stability. Largest Contentful Paint (LCP): measures loading performance. To provide a good user experience, LCP should occur within 2.5 seconds of when the page first starts loading. First Input Delay (FID): measures interactivity. To provide a good user experience, pages should have a FID of less than 100 milliseconds. Cumulative Layout Shift (CLS): measures visual stability. To provide a good user experience, pages should maintain a CLS of less than 0.1. For each of the above metrics, to ensure you're hitting the recommended target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices. To learn more, watch our Nerd Days talk on perceived performance. Detailed visual, interactivity, and responsiveness metrics The BrowserInteraction and PageView events end their reporting when they receive the page window load (or window load and AJAX) timing. However, paint and interactivity metrics can happen at any time. PageViewTiming delivers these metrics as a separate event to: Account for the variability in this timing. Avoid setting an arbitrary timeout. Prevent holding BrowserInteraction and PageView events indefinitely. Additional data Comments firstPaint and firstContentfulPaint The firstPaint and firstContentfulPaint attributes already are available with BrowserInteraction and PageView events. However, they are not always reliably captured before the window onload event fires. Using PageViewTiming gives you a way to capture these metrics even if they happen after the original page load time. This gives you a better understanding of the correlation between responsiveness of that load event and the visual rendering of your content. largestContentfulPaint This new metric, available with agent version 1163, largestContentfulPaint, reports the render time of the largest content element visible in the viewport. Google's research found looking at when the largest element was rendered was a more accurate way to measure when the main content of a page is loaded and useful. Details on this metric, including limitations and considerations can be found in the w3c draft. In addition, we now report the cumulative layout shift (CLS) score attribute with LCP. This attribute is reported as cumulativeLayoutShift. Largest Contentful Paint is one of three metrics identified by Google as the Core Web Vitals. LCP values up to 2.5 secs are considered \"Good\", between 2.5-4.0 secs considered \"Needs Improvement\", and above 4.0 secs considered \"Poor.\" firstInteraction and firstInputDelay With the addition of firstInteraction and firstInputDelay, you can quickly determine the ways that your users are interacting with that visual content. These metrics tell you not only when they interacted, but what type of interaction (mousedown, pointerdown, etc.) and how long it took for them to receive a response from your site. The firstInputDelay metric lies in the middle of FirstContentfulPaint and Time to Interactive (TTI) metrics, measuring the time between when a first input can be made and when the browser's main thread is able to respond to any interactions. In addition, we now report the cumulative layout shift (CLS) score attribute at the moment of the user's first interaction. This attribute is reported as cumulativeLayoutShift. First Input Delay is one of three metrics identified by Google as the Core Web Vitals. FID values up to 100 ms are considered \"Good\", between 100-300 ms considered \"Needs Improvement\", and above 300 ms considered \"Poor.\" For a more detailed explanation, see the Browser release notes. cumulativeLayoutShift Cumulative Layout Shift (CLS), available with agent v1177, is an important, user-centric metric for measuring visual stability because it helps quantify how often users experience unexpected layout shiftsâ€”a low CLS helps ensure that the page is delightful. This is one of three metrics identified by Google as the Core Web Vitals. Cumulative Layout Shift is one of three metrics identified by Google as the Core Web Vitals. CLS scores up to 0.1 are considered \"Good\", between 0.1-0.25 considered \"Needs Improvement\", and above 0.25 considered \"Poor.\" timingName You can review different types of activities with the timingName attribute, such as firstPaint, firstContentfulPaint, firstInteraction, largestContentfulPaint, pageHide and windowUnload. For example, a PageViewTiming event may have a timingName of firstPaint and a firstPaint value of .03. The event will also include all default attributes included with the standard BrowserInteraction and PageView events. elementId This is the Id, if specified, of the largestContentfulPaint element. This value will only be reported with the LCP metric. This value can be null. elementSize This is the reported size of the largestContentfulPaint element. This value will only be reported with the LCP metric. pageHide The pageHide event, available with agent v1177, is sent when the browser hides the current page in the process of presenting a different page from the session's history. For example, when the user clicks the browser's Back button, the current page receives a pageHide event before the previous page is shown. Supporting documentation and browser compatibility for the pageHide event can be found in MDN docs. In addition, we now report the cumulative layout shift (CLS) score attribute with pageHide. This attribute is reported as cumulativeLayoutShift. windowLoad The windowLoad event, available with agent v1177, is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. Supporting documentation and browser compatibility for the Window Load event can be found in MDN docs. In addition, we now report the cumulative layout shift (CLS) score attribute with windowLoad. This attribute is reported as cumulativeLayoutShift. windowUnload The windowUnload event, available with agent v1163, is fired when a document or child resource is being unloaded. Supporting documentation and browser compatibility for the Window Unload event can be found in MDN docs. In addition, we now report the cumulative layout shift (CLS) score attribute with windowUnload. This attribute is reported as cumulativeLayoutShift. Compatibility and requirements In addition to Browser's installation requirements, the PageViewTiming event requires Browser agent version 1153 or higher and a Browser Pro subscription. Follow our Browser agent release notes to find out when new metrics are released. These metrics are supported by the following browser versions. For unsupported browsers, no PageViewTiming events will be recorded. Metrics Supported browser versions cumulativeLayoutShift Chrome 79 Metric is elevated to stable; changes in metric definition will be reported in this log. Chrome 77 Metric exposed via API: Cumulative Layout Shift available via Layout Instability API firstPaint firstContentfulPaint Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile largestContentfulPaint Chrome 77 or higher for desktop and mobile firstInteraction firstInputDelay These metrics require the addEventListener Browser API. This API is available in all modern browsers, including: Apple Safari Google Chrome Microsoft Internet Explorer (IE) versions 9 or higher Mozilla Firefox pageHide This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowLoad This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowUnload This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. Query your event data Here are some sample queries for the event data to help you get started. Percentile over timeseries Show the 95th percentile of first paint and first contentful paint over a time series: SELECT FILTER(percentile(firstPaint, 95), where(timingName = ' firstPaint ')) as 'fp', FILTER(percentile( firstContentfulPaint , 95), where(timingName = 'firstContentfulPaint')) as 'fcp' FROM PageViewTiming TIMESERIES 1 minute SINCE 1 hour ago Copy Percentile by transaction and interaction Show the 95th percentile of first input delay over a time series, faceted by transaction name and interaction type: SELECT percentile( firstInputDelay , 95) as 'fid' FROM PageViewTiming WHERE timingName = 'firstInteraction' TIMESERIES 1 minute FACET browserTransactionName, interactionType SINCE 3 hours ago Copy Histogram of delay timings Show a histogram of first input delay timings faceted by first interaction time ranges: FROM PageViewTiming SELECT histogram( firstInputDelay , 1000, 10) SINCE 3 hours ago WHERE timingName = 'firstInteraction' FACET CASES (WHERE firstInteraction < 1, WHERE firstInteraction >= 1 AND firstInteraction < 5, WHERE firstInteraction >= 5) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.11304,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>PageViewTiming</em>: Async or dynamic <em>page</em> details",
        "sections": "<em>PageViewTiming</em>: Async or dynamic <em>page</em> details",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": " and firstContentfulPaint attributes already are available with <em>Browser</em>Interaction and <em>Page</em>View events. However, they are not always reliably captured before the window onload event fires. Using <em>PageViewTiming</em> gives you a way to capture these metrics even if they happen after the original <em>page</em> <em>load</em> <em>time</em>"
      },
      "id": "603ea90a64441f02614e88a4"
    },
    {
      "sections": [
        "New Relic cookies used by Browser",
        "Tip",
        "Data privacy and legal compliance",
        "JSESSIONID",
        "NREUM",
        "NRAGENT"
      ],
      "title": "New Relic cookies used by Browser",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "fe0f7b83aafd52fce5ffff3176545910ed9cbb54",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/page-load-timing-resources/new-relic-cookies-used-browser/",
      "published_at": "2021-07-02T09:17:12Z",
      "updated_at": "2021-03-11T05:02:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes data privacy related to Browser monitoring and cookies, and details about the cookies themselves. Page load timing (sometimes referred to as real user monitoring or RUM) creates the following cookies that Browser monitoring uses when session tracking in end-user browsers. Tip These cookies are related to Browser app monitoring. For more information about data privacy and requesting data to be deleted, see New Relic personal data requests. Data privacy and legal compliance The default Browser agent configuration does not retain any personal data as defined by common privacy laws such as the EU General Data Protection Regulation (GDPR) and California Consumer Privacy Act (CCPA). New Relic has taken steps to enable our customers who elect to process personal data in our products to do so in accordance with applicable privacy laws. Use the additional information below to help enable your compliance with such laws: Data Description IP addresses New Relic briefly collects and leverages the IP address from the end-user as part of the data collection process. The IP is captured when a connection is made between the end user's browser and the New Relic data collector. The IP address is included in the web request, much like a caller ID. New Relic uses the IP, much like you see a phone number when somebody calls you. The IP address is used as a lookup value that maps to additional details, allowing New Relic customers to diagnose performance issues. IP address lookup values include: countryCode regionCode city asn (Autonomous System Number) asnOrganization (ISP/Business/Institution) asnLatitude asnLongitude The mapping process for the IP address lookup value is typically complete within minutes, but in some extreme cases may take up to 24 hours to process. Once the mapping process is complete, New Relic no longer retains the IP address. Default cookies The Browser monitoring agent sets cookies by default. Cookies are placed by the Browser agent and the New Relic collector. The New Relic collector places a cookie when the Browser agent makes a connection and transmits data. A cookie consent manager that uses a conditional script loader that only loads tags/snippets when a visitor agrees to a specific type of cookies can be used. By choosing this option there is a risk that page performance will not be captured until the visitor has agreed and the Browser agent is running. With the release of Browser agent v1169, you can turn off cookie collection (JSESSIONID and NREUM) for your Browser app by using the Application settings page in the New Relic UI. Once this configuration value is set to false (OFF), you will no longer see the session information in your event data. By default, the value is set to true (ON) for all existing Browser apps as well as newly created ones. For more information, see our documentation about cookie collection and session tracking. Personal data through custom Browser configuration New Relic offers the option to manually configure your agent through the Browser monitoring API. This could be used to capture personal data, subject to the restrictions set forth in the Terms of Service with New Relic. (For example, no credit card numbers or sensitive categories of personal data, which are contractually prohibited.) New Relic responds to the instructions specified by the agents, including collecting personal data that may be custom configured. If you (as the data controller) receive a request from one of your own customers and determine that personal data sent to New Relic for processing must be deleted, see New Relic personal data requests. JSESSIONID The JSESSIONID cookie is used to store a session identifier so that New Relic can monitor session counts for an application. The cookie value is generated by Jetty. Components Description Session identifier This is used by New Relic to monitor session counts for an application. Domain The JSESSIONID cookie is associated with the New Relic domain. Expiration JSESSIONID is a session cookie that is deleted when the browser closes. NREUM This cookie is only created in browsers that do not support the Navigation Timing API. When a browser supports the Navigation Timing API, a native interface can be used to determine navigation start time. Mozilla Firefox versions 7 or higher support the Navigation Timing API. However, a bug exists in Firefox's early implementations of the Navigation Timing API that Browser monitoring works around by using this cookie. Components Description Navigation start time Navigation start time is required to measure end user response time. The cookie is written when the current page unloads (as the next navigation begins). Document location Stored as a hash. The document location is used with the referring page URL to validate that the start time refers to the page that was previously being viewed or refreshed (to avoid using an invalid start time from a different navigation). Referring page URLs Stored as a hash. The referring page URL is used with the document location to validate that the start time refers to the page that was previously being viewed or refreshed (to avoid using an invalid start time from a different navigation). Domain The NREUM cookie is associated with the root path of the domain in which the New Relic agent executes. Expiration NREUM is a session cookie that is deleted when the browser closes. NRAGENT The NRAGENT cookie is set only if you use Browser agent version v443 or lower. It is created when a token is handed out to an end user by the New Relic collector. End-user metrics are communicated to New Relic collectors via a JSONP request from the browser (script retrieval). The returned JavaScript contains a call to set the token identifier which is written to the cookie on the next navigation (when the page unloads). This achieves a cross-domain communication between the New Relic collector and the New Relic agent. This cookie is used to communicate between the New Relic collector aggregating end user metrics and the agent(s) running in the associated web application. A token identifies and correlates application tier transaction traces with corresponding browser traces. Components Description Token identifier The 16-character token identifier helps with cross-domain communication between the New Relic collector and the New Relic agent. Domain The NRAGENT cookie is associated with the root path of the domain in which the New Relic agent executes. Expiration NRAGENT is a session cookie that is deleted when the browser closes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 219.33653,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic cookies used by <em>Browser</em>",
        "sections": "New Relic cookies used by <em>Browser</em>",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "This document describes data privacy related to <em>Browser</em> <em>monitoring</em> and cookies, and details about the cookies themselves. <em>Page</em> <em>load</em> <em>timing</em> (sometimes referred to as real user <em>monitoring</em> or RUM) creates the following cookies that <em>Browser</em> <em>monitoring</em> uses when session tracking in end-user browsers"
      },
      "id": "60442a2f196a673c3e960f2f"
    },
    {
      "sections": [
        "Cookie collection and session tracking",
        "How it works",
        "Enable or disable cookie collection"
      ],
      "title": "Cookie collection and session tracking",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "4ad3150808fab2f68a2f944a8966ab9b60ee684b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/page-load-timing-resources/cookie-collection-session-tracking/",
      "published_at": "2021-07-02T09:17:12Z",
      "updated_at": "2021-03-11T05:02:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's page load timing feature can track sessions by using cookies that contain a simple session identifier. How it works Here is the basic process for session tracking: A session begins when a user visits a website where New Relic's browser monitoring is installed and cookie collection is enabled. After the user's browser is opened, our browser monitoring script sets a simple cookie identifying the session. The script then reads the cookie on subsequent page loads. The same session will continue until the user's browser is closed. Session tracking will not work properly in these situations: If users have cookies disabled in their browser If the browser is configured to not allow information associated with the New Relic cookie to be sent with the request from the monitored site Enable or disable cookie collection At New Relic, we take data privacy seriously. By default, we do not retain any personal data collected by our Browser agent, and you can control session tracking. To turn cookie collection on or off for your app: Go to one.newrelic.com > Browser > (select an app) > Settings > Application settings. In your app's Privacy settings, toggle Cookie collection.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 219.33653,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "<em>Browser</em> <em>monitoring</em>&#x27;s <em>page</em> <em>load</em> <em>timing</em> feature can track sessions by using cookies that contain a simple session identifier. How it works Here is the basic process for session tracking: A session begins when a user visits a website where New Relic&#x27;s <em>browser</em> <em>monitoring</em> is installed and cookie"
      },
      "id": "60442a2f28ccbc1bfe2c60a7"
    }
  ],
  "/docs/browser/new-relic-browser/page-load-timing-resources/navigation-start-time-unknown": [
    {
      "sections": [
        "PageViewTiming: Async or dynamic page details",
        "Why use PageViewTiming?",
        "Support for Google's Core Web Vitals",
        "Detailed visual, interactivity, and responsiveness metrics",
        "Compatibility and requirements",
        "Query your event data",
        "Percentile over timeseries",
        "Percentile by transaction and interaction",
        "Histogram of delay timings"
      ],
      "title": "PageViewTiming: Async or dynamic page details",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "069f311598f5df27ee46006693b077f7f8b8d146",
      "image": "https://docs.newrelic.com/static/e19694ae33f749d66a346968f23bfb5a/c1b63/core-web-vitals_0.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details/",
      "published_at": "2021-07-02T00:31:09Z",
      "updated_at": "2021-03-16T07:25:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its attributes to query data about your site, component loading, and user performance metrics, both from visual and responsiveness standpoints. Why use PageViewTiming? If your application uses asynchronous or dynamic pages, you may need additional details about site or component loading. But pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the Browser agent. For example, users may become impatient and begin clicking as soon as content is on the webpage. Or, they may wait to use the page until long after content is loaded. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. The additional metrics can help you understand how users experience your site, both from visual and responsiveness standpoints. Support for Google's Core Web Vitals We now, with the release of agent version 1177, have full support for Google's Core Web Vitals for 2020. The metrics that make up Core Web Vitals will evolve over time. The current set for 2020 focuses on three aspects of the user experienceâ€”loading, interactivity, and visual stabilityâ€”and includes the following metrics (and their respective thresholds): Core Web Vitals metrics include loading, interactivity, and visual stability. Largest Contentful Paint (LCP): measures loading performance. To provide a good user experience, LCP should occur within 2.5 seconds of when the page first starts loading. First Input Delay (FID): measures interactivity. To provide a good user experience, pages should have a FID of less than 100 milliseconds. Cumulative Layout Shift (CLS): measures visual stability. To provide a good user experience, pages should maintain a CLS of less than 0.1. For each of the above metrics, to ensure you're hitting the recommended target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices. To learn more, watch our Nerd Days talk on perceived performance. Detailed visual, interactivity, and responsiveness metrics The BrowserInteraction and PageView events end their reporting when they receive the page window load (or window load and AJAX) timing. However, paint and interactivity metrics can happen at any time. PageViewTiming delivers these metrics as a separate event to: Account for the variability in this timing. Avoid setting an arbitrary timeout. Prevent holding BrowserInteraction and PageView events indefinitely. Additional data Comments firstPaint and firstContentfulPaint The firstPaint and firstContentfulPaint attributes already are available with BrowserInteraction and PageView events. However, they are not always reliably captured before the window onload event fires. Using PageViewTiming gives you a way to capture these metrics even if they happen after the original page load time. This gives you a better understanding of the correlation between responsiveness of that load event and the visual rendering of your content. largestContentfulPaint This new metric, available with agent version 1163, largestContentfulPaint, reports the render time of the largest content element visible in the viewport. Google's research found looking at when the largest element was rendered was a more accurate way to measure when the main content of a page is loaded and useful. Details on this metric, including limitations and considerations can be found in the w3c draft. In addition, we now report the cumulative layout shift (CLS) score attribute with LCP. This attribute is reported as cumulativeLayoutShift. Largest Contentful Paint is one of three metrics identified by Google as the Core Web Vitals. LCP values up to 2.5 secs are considered \"Good\", between 2.5-4.0 secs considered \"Needs Improvement\", and above 4.0 secs considered \"Poor.\" firstInteraction and firstInputDelay With the addition of firstInteraction and firstInputDelay, you can quickly determine the ways that your users are interacting with that visual content. These metrics tell you not only when they interacted, but what type of interaction (mousedown, pointerdown, etc.) and how long it took for them to receive a response from your site. The firstInputDelay metric lies in the middle of FirstContentfulPaint and Time to Interactive (TTI) metrics, measuring the time between when a first input can be made and when the browser's main thread is able to respond to any interactions. In addition, we now report the cumulative layout shift (CLS) score attribute at the moment of the user's first interaction. This attribute is reported as cumulativeLayoutShift. First Input Delay is one of three metrics identified by Google as the Core Web Vitals. FID values up to 100 ms are considered \"Good\", between 100-300 ms considered \"Needs Improvement\", and above 300 ms considered \"Poor.\" For a more detailed explanation, see the Browser release notes. cumulativeLayoutShift Cumulative Layout Shift (CLS), available with agent v1177, is an important, user-centric metric for measuring visual stability because it helps quantify how often users experience unexpected layout shiftsâ€”a low CLS helps ensure that the page is delightful. This is one of three metrics identified by Google as the Core Web Vitals. Cumulative Layout Shift is one of three metrics identified by Google as the Core Web Vitals. CLS scores up to 0.1 are considered \"Good\", between 0.1-0.25 considered \"Needs Improvement\", and above 0.25 considered \"Poor.\" timingName You can review different types of activities with the timingName attribute, such as firstPaint, firstContentfulPaint, firstInteraction, largestContentfulPaint, pageHide and windowUnload. For example, a PageViewTiming event may have a timingName of firstPaint and a firstPaint value of .03. The event will also include all default attributes included with the standard BrowserInteraction and PageView events. elementId This is the Id, if specified, of the largestContentfulPaint element. This value will only be reported with the LCP metric. This value can be null. elementSize This is the reported size of the largestContentfulPaint element. This value will only be reported with the LCP metric. pageHide The pageHide event, available with agent v1177, is sent when the browser hides the current page in the process of presenting a different page from the session's history. For example, when the user clicks the browser's Back button, the current page receives a pageHide event before the previous page is shown. Supporting documentation and browser compatibility for the pageHide event can be found in MDN docs. In addition, we now report the cumulative layout shift (CLS) score attribute with pageHide. This attribute is reported as cumulativeLayoutShift. windowLoad The windowLoad event, available with agent v1177, is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. Supporting documentation and browser compatibility for the Window Load event can be found in MDN docs. In addition, we now report the cumulative layout shift (CLS) score attribute with windowLoad. This attribute is reported as cumulativeLayoutShift. windowUnload The windowUnload event, available with agent v1163, is fired when a document or child resource is being unloaded. Supporting documentation and browser compatibility for the Window Unload event can be found in MDN docs. In addition, we now report the cumulative layout shift (CLS) score attribute with windowUnload. This attribute is reported as cumulativeLayoutShift. Compatibility and requirements In addition to Browser's installation requirements, the PageViewTiming event requires Browser agent version 1153 or higher and a Browser Pro subscription. Follow our Browser agent release notes to find out when new metrics are released. These metrics are supported by the following browser versions. For unsupported browsers, no PageViewTiming events will be recorded. Metrics Supported browser versions cumulativeLayoutShift Chrome 79 Metric is elevated to stable; changes in metric definition will be reported in this log. Chrome 77 Metric exposed via API: Cumulative Layout Shift available via Layout Instability API firstPaint firstContentfulPaint Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile largestContentfulPaint Chrome 77 or higher for desktop and mobile firstInteraction firstInputDelay These metrics require the addEventListener Browser API. This API is available in all modern browsers, including: Apple Safari Google Chrome Microsoft Internet Explorer (IE) versions 9 or higher Mozilla Firefox pageHide This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowLoad This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowUnload This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. Query your event data Here are some sample queries for the event data to help you get started. Percentile over timeseries Show the 95th percentile of first paint and first contentful paint over a time series: SELECT FILTER(percentile(firstPaint, 95), where(timingName = ' firstPaint ')) as 'fp', FILTER(percentile( firstContentfulPaint , 95), where(timingName = 'firstContentfulPaint')) as 'fcp' FROM PageViewTiming TIMESERIES 1 minute SINCE 1 hour ago Copy Percentile by transaction and interaction Show the 95th percentile of first input delay over a time series, faceted by transaction name and interaction type: SELECT percentile( firstInputDelay , 95) as 'fid' FROM PageViewTiming WHERE timingName = 'firstInteraction' TIMESERIES 1 minute FACET browserTransactionName, interactionType SINCE 3 hours ago Copy Histogram of delay timings Show a histogram of first input delay timings faceted by first interaction time ranges: FROM PageViewTiming SELECT histogram( firstInputDelay , 1000, 10) SINCE 3 hours ago WHERE timingName = 'firstInteraction' FACET CASES (WHERE firstInteraction < 1, WHERE firstInteraction >= 1 AND firstInteraction < 5, WHERE firstInteraction >= 5) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.11304,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>PageViewTiming</em>: Async or dynamic <em>page</em> details",
        "sections": "<em>PageViewTiming</em>: Async or dynamic <em>page</em> details",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": " and firstContentfulPaint attributes already are available with <em>Browser</em>Interaction and <em>Page</em>View events. However, they are not always reliably captured before the window onload event fires. Using <em>PageViewTiming</em> gives you a way to capture these metrics even if they happen after the original <em>page</em> <em>load</em> <em>time</em>"
      },
      "id": "603ea90a64441f02614e88a4"
    },
    {
      "sections": [
        "New Relic cookies used by Browser",
        "Tip",
        "Data privacy and legal compliance",
        "JSESSIONID",
        "NREUM",
        "NRAGENT"
      ],
      "title": "New Relic cookies used by Browser",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "fe0f7b83aafd52fce5ffff3176545910ed9cbb54",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/page-load-timing-resources/new-relic-cookies-used-browser/",
      "published_at": "2021-07-02T09:17:12Z",
      "updated_at": "2021-03-11T05:02:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes data privacy related to Browser monitoring and cookies, and details about the cookies themselves. Page load timing (sometimes referred to as real user monitoring or RUM) creates the following cookies that Browser monitoring uses when session tracking in end-user browsers. Tip These cookies are related to Browser app monitoring. For more information about data privacy and requesting data to be deleted, see New Relic personal data requests. Data privacy and legal compliance The default Browser agent configuration does not retain any personal data as defined by common privacy laws such as the EU General Data Protection Regulation (GDPR) and California Consumer Privacy Act (CCPA). New Relic has taken steps to enable our customers who elect to process personal data in our products to do so in accordance with applicable privacy laws. Use the additional information below to help enable your compliance with such laws: Data Description IP addresses New Relic briefly collects and leverages the IP address from the end-user as part of the data collection process. The IP is captured when a connection is made between the end user's browser and the New Relic data collector. The IP address is included in the web request, much like a caller ID. New Relic uses the IP, much like you see a phone number when somebody calls you. The IP address is used as a lookup value that maps to additional details, allowing New Relic customers to diagnose performance issues. IP address lookup values include: countryCode regionCode city asn (Autonomous System Number) asnOrganization (ISP/Business/Institution) asnLatitude asnLongitude The mapping process for the IP address lookup value is typically complete within minutes, but in some extreme cases may take up to 24 hours to process. Once the mapping process is complete, New Relic no longer retains the IP address. Default cookies The Browser monitoring agent sets cookies by default. Cookies are placed by the Browser agent and the New Relic collector. The New Relic collector places a cookie when the Browser agent makes a connection and transmits data. A cookie consent manager that uses a conditional script loader that only loads tags/snippets when a visitor agrees to a specific type of cookies can be used. By choosing this option there is a risk that page performance will not be captured until the visitor has agreed and the Browser agent is running. With the release of Browser agent v1169, you can turn off cookie collection (JSESSIONID and NREUM) for your Browser app by using the Application settings page in the New Relic UI. Once this configuration value is set to false (OFF), you will no longer see the session information in your event data. By default, the value is set to true (ON) for all existing Browser apps as well as newly created ones. For more information, see our documentation about cookie collection and session tracking. Personal data through custom Browser configuration New Relic offers the option to manually configure your agent through the Browser monitoring API. This could be used to capture personal data, subject to the restrictions set forth in the Terms of Service with New Relic. (For example, no credit card numbers or sensitive categories of personal data, which are contractually prohibited.) New Relic responds to the instructions specified by the agents, including collecting personal data that may be custom configured. If you (as the data controller) receive a request from one of your own customers and determine that personal data sent to New Relic for processing must be deleted, see New Relic personal data requests. JSESSIONID The JSESSIONID cookie is used to store a session identifier so that New Relic can monitor session counts for an application. The cookie value is generated by Jetty. Components Description Session identifier This is used by New Relic to monitor session counts for an application. Domain The JSESSIONID cookie is associated with the New Relic domain. Expiration JSESSIONID is a session cookie that is deleted when the browser closes. NREUM This cookie is only created in browsers that do not support the Navigation Timing API. When a browser supports the Navigation Timing API, a native interface can be used to determine navigation start time. Mozilla Firefox versions 7 or higher support the Navigation Timing API. However, a bug exists in Firefox's early implementations of the Navigation Timing API that Browser monitoring works around by using this cookie. Components Description Navigation start time Navigation start time is required to measure end user response time. The cookie is written when the current page unloads (as the next navigation begins). Document location Stored as a hash. The document location is used with the referring page URL to validate that the start time refers to the page that was previously being viewed or refreshed (to avoid using an invalid start time from a different navigation). Referring page URLs Stored as a hash. The referring page URL is used with the document location to validate that the start time refers to the page that was previously being viewed or refreshed (to avoid using an invalid start time from a different navigation). Domain The NREUM cookie is associated with the root path of the domain in which the New Relic agent executes. Expiration NREUM is a session cookie that is deleted when the browser closes. NRAGENT The NRAGENT cookie is set only if you use Browser agent version v443 or lower. It is created when a token is handed out to an end user by the New Relic collector. End-user metrics are communicated to New Relic collectors via a JSONP request from the browser (script retrieval). The returned JavaScript contains a call to set the token identifier which is written to the cookie on the next navigation (when the page unloads). This achieves a cross-domain communication between the New Relic collector and the New Relic agent. This cookie is used to communicate between the New Relic collector aggregating end user metrics and the agent(s) running in the associated web application. A token identifies and correlates application tier transaction traces with corresponding browser traces. Components Description Token identifier The 16-character token identifier helps with cross-domain communication between the New Relic collector and the New Relic agent. Domain The NRAGENT cookie is associated with the root path of the domain in which the New Relic agent executes. Expiration NRAGENT is a session cookie that is deleted when the browser closes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 219.33653,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic cookies used by <em>Browser</em>",
        "sections": "New Relic cookies used by <em>Browser</em>",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "This document describes data privacy related to <em>Browser</em> <em>monitoring</em> and cookies, and details about the cookies themselves. <em>Page</em> <em>load</em> <em>timing</em> (sometimes referred to as real user <em>monitoring</em> or RUM) creates the following cookies that <em>Browser</em> <em>monitoring</em> uses when session tracking in end-user browsers"
      },
      "id": "60442a2f196a673c3e960f2f"
    },
    {
      "sections": [
        "Cookie collection and session tracking",
        "How it works",
        "Enable or disable cookie collection"
      ],
      "title": "Cookie collection and session tracking",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "4ad3150808fab2f68a2f944a8966ab9b60ee684b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/page-load-timing-resources/cookie-collection-session-tracking/",
      "published_at": "2021-07-02T09:17:12Z",
      "updated_at": "2021-03-11T05:02:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's page load timing feature can track sessions by using cookies that contain a simple session identifier. How it works Here is the basic process for session tracking: A session begins when a user visits a website where New Relic's browser monitoring is installed and cookie collection is enabled. After the user's browser is opened, our browser monitoring script sets a simple cookie identifying the session. The script then reads the cookie on subsequent page loads. The same session will continue until the user's browser is closed. Session tracking will not work properly in these situations: If users have cookies disabled in their browser If the browser is configured to not allow information associated with the New Relic cookie to be sent with the request from the monitored site Enable or disable cookie collection At New Relic, we take data privacy seriously. By default, we do not retain any personal data collected by our Browser agent, and you can control session tracking. To turn cookie collection on or off for your app: Go to one.newrelic.com > Browser > (select an app) > Settings > Application settings. In your app's Privacy settings, toggle Cookie collection.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 219.33653,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "<em>Browser</em> <em>monitoring</em>&#x27;s <em>page</em> <em>load</em> <em>timing</em> feature can track sessions by using cookies that contain a simple session identifier. How it works Here is the basic process for session tracking: A session begins when a user visits a website where New Relic&#x27;s <em>browser</em> <em>monitoring</em> is installed and cookie"
      },
      "id": "60442a2f28ccbc1bfe2c60a7"
    }
  ],
  "/docs/browser/new-relic-browser/page-load-timing-resources/page-load-timing-process": [
    {
      "sections": [
        "PageViewTiming: Async or dynamic page details",
        "Why use PageViewTiming?",
        "Support for Google's Core Web Vitals",
        "Detailed visual, interactivity, and responsiveness metrics",
        "Compatibility and requirements",
        "Query your event data",
        "Percentile over timeseries",
        "Percentile by transaction and interaction",
        "Histogram of delay timings"
      ],
      "title": "PageViewTiming: Async or dynamic page details",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "069f311598f5df27ee46006693b077f7f8b8d146",
      "image": "https://docs.newrelic.com/static/e19694ae33f749d66a346968f23bfb5a/c1b63/core-web-vitals_0.png",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details/",
      "published_at": "2021-07-02T00:31:09Z",
      "updated_at": "2021-03-16T07:25:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's PageViewTiming event sends each data point as a separate event as soon as it is available. Because we do not restrict the timing, you can receive first paint or first interaction data regardless of when it fires. This document describes why and how to use PageViewTiming and its attributes to query data about your site, component loading, and user performance metrics, both from visual and responsiveness standpoints. Why use PageViewTiming? If your application uses asynchronous or dynamic pages, you may need additional details about site or component loading. But pages can load content in many different ways, and users control when they interact with that content. This is why some user-centric performance metrics happen outside the standard window onload (page load time) in the Browser agent. For example, users may become impatient and begin clicking as soon as content is on the webpage. Or, they may wait to use the page until long after content is loaded. The PageViewTiming event provides a more real-time delivery mechanism that does not have a dependency on any other event. The additional metrics can help you understand how users experience your site, both from visual and responsiveness standpoints. Support for Google's Core Web Vitals We now, with the release of agent version 1177, have full support for Google's Core Web Vitals for 2020. The metrics that make up Core Web Vitals will evolve over time. The current set for 2020 focuses on three aspects of the user experienceâ€”loading, interactivity, and visual stabilityâ€”and includes the following metrics (and their respective thresholds): Core Web Vitals metrics include loading, interactivity, and visual stability. Largest Contentful Paint (LCP): measures loading performance. To provide a good user experience, LCP should occur within 2.5 seconds of when the page first starts loading. First Input Delay (FID): measures interactivity. To provide a good user experience, pages should have a FID of less than 100 milliseconds. Cumulative Layout Shift (CLS): measures visual stability. To provide a good user experience, pages should maintain a CLS of less than 0.1. For each of the above metrics, to ensure you're hitting the recommended target for most of your users, a good threshold to measure is the 75th percentile of page loads, segmented across mobile and desktop devices. To learn more, watch our Nerd Days talk on perceived performance. Detailed visual, interactivity, and responsiveness metrics The BrowserInteraction and PageView events end their reporting when they receive the page window load (or window load and AJAX) timing. However, paint and interactivity metrics can happen at any time. PageViewTiming delivers these metrics as a separate event to: Account for the variability in this timing. Avoid setting an arbitrary timeout. Prevent holding BrowserInteraction and PageView events indefinitely. Additional data Comments firstPaint and firstContentfulPaint The firstPaint and firstContentfulPaint attributes already are available with BrowserInteraction and PageView events. However, they are not always reliably captured before the window onload event fires. Using PageViewTiming gives you a way to capture these metrics even if they happen after the original page load time. This gives you a better understanding of the correlation between responsiveness of that load event and the visual rendering of your content. largestContentfulPaint This new metric, available with agent version 1163, largestContentfulPaint, reports the render time of the largest content element visible in the viewport. Google's research found looking at when the largest element was rendered was a more accurate way to measure when the main content of a page is loaded and useful. Details on this metric, including limitations and considerations can be found in the w3c draft. In addition, we now report the cumulative layout shift (CLS) score attribute with LCP. This attribute is reported as cumulativeLayoutShift. Largest Contentful Paint is one of three metrics identified by Google as the Core Web Vitals. LCP values up to 2.5 secs are considered \"Good\", between 2.5-4.0 secs considered \"Needs Improvement\", and above 4.0 secs considered \"Poor.\" firstInteraction and firstInputDelay With the addition of firstInteraction and firstInputDelay, you can quickly determine the ways that your users are interacting with that visual content. These metrics tell you not only when they interacted, but what type of interaction (mousedown, pointerdown, etc.) and how long it took for them to receive a response from your site. The firstInputDelay metric lies in the middle of FirstContentfulPaint and Time to Interactive (TTI) metrics, measuring the time between when a first input can be made and when the browser's main thread is able to respond to any interactions. In addition, we now report the cumulative layout shift (CLS) score attribute at the moment of the user's first interaction. This attribute is reported as cumulativeLayoutShift. First Input Delay is one of three metrics identified by Google as the Core Web Vitals. FID values up to 100 ms are considered \"Good\", between 100-300 ms considered \"Needs Improvement\", and above 300 ms considered \"Poor.\" For a more detailed explanation, see the Browser release notes. cumulativeLayoutShift Cumulative Layout Shift (CLS), available with agent v1177, is an important, user-centric metric for measuring visual stability because it helps quantify how often users experience unexpected layout shiftsâ€”a low CLS helps ensure that the page is delightful. This is one of three metrics identified by Google as the Core Web Vitals. Cumulative Layout Shift is one of three metrics identified by Google as the Core Web Vitals. CLS scores up to 0.1 are considered \"Good\", between 0.1-0.25 considered \"Needs Improvement\", and above 0.25 considered \"Poor.\" timingName You can review different types of activities with the timingName attribute, such as firstPaint, firstContentfulPaint, firstInteraction, largestContentfulPaint, pageHide and windowUnload. For example, a PageViewTiming event may have a timingName of firstPaint and a firstPaint value of .03. The event will also include all default attributes included with the standard BrowserInteraction and PageView events. elementId This is the Id, if specified, of the largestContentfulPaint element. This value will only be reported with the LCP metric. This value can be null. elementSize This is the reported size of the largestContentfulPaint element. This value will only be reported with the LCP metric. pageHide The pageHide event, available with agent v1177, is sent when the browser hides the current page in the process of presenting a different page from the session's history. For example, when the user clicks the browser's Back button, the current page receives a pageHide event before the previous page is shown. Supporting documentation and browser compatibility for the pageHide event can be found in MDN docs. In addition, we now report the cumulative layout shift (CLS) score attribute with pageHide. This attribute is reported as cumulativeLayoutShift. windowLoad The windowLoad event, available with agent v1177, is fired when the whole page has loaded, including all dependent resources such as stylesheets and images. Supporting documentation and browser compatibility for the Window Load event can be found in MDN docs. In addition, we now report the cumulative layout shift (CLS) score attribute with windowLoad. This attribute is reported as cumulativeLayoutShift. windowUnload The windowUnload event, available with agent v1163, is fired when a document or child resource is being unloaded. Supporting documentation and browser compatibility for the Window Unload event can be found in MDN docs. In addition, we now report the cumulative layout shift (CLS) score attribute with windowUnload. This attribute is reported as cumulativeLayoutShift. Compatibility and requirements In addition to Browser's installation requirements, the PageViewTiming event requires Browser agent version 1153 or higher and a Browser Pro subscription. Follow our Browser agent release notes to find out when new metrics are released. These metrics are supported by the following browser versions. For unsupported browsers, no PageViewTiming events will be recorded. Metrics Supported browser versions cumulativeLayoutShift Chrome 79 Metric is elevated to stable; changes in metric definition will be reported in this log. Chrome 77 Metric exposed via API: Cumulative Layout Shift available via Layout Instability API firstPaint firstContentfulPaint Chrome 60 or higher for desktop and mobile (Android webview and Chrome for Android) Opera 47 or higher for desktop Opera 44 or higher for Android mobile Samsung Internet for mobile largestContentfulPaint Chrome 77 or higher for desktop and mobile firstInteraction firstInputDelay These metrics require the addEventListener Browser API. This API is available in all modern browsers, including: Apple Safari Google Chrome Microsoft Internet Explorer (IE) versions 9 or higher Mozilla Firefox pageHide This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowLoad This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. windowUnload This metric is currently supported by all browsers on desktop and mobile. Compatibility matrix via MDN documentation. Query your event data Here are some sample queries for the event data to help you get started. Percentile over timeseries Show the 95th percentile of first paint and first contentful paint over a time series: SELECT FILTER(percentile(firstPaint, 95), where(timingName = ' firstPaint ')) as 'fp', FILTER(percentile( firstContentfulPaint , 95), where(timingName = 'firstContentfulPaint')) as 'fcp' FROM PageViewTiming TIMESERIES 1 minute SINCE 1 hour ago Copy Percentile by transaction and interaction Show the 95th percentile of first input delay over a time series, faceted by transaction name and interaction type: SELECT percentile( firstInputDelay , 95) as 'fid' FROM PageViewTiming WHERE timingName = 'firstInteraction' TIMESERIES 1 minute FACET browserTransactionName, interactionType SINCE 3 hours ago Copy Histogram of delay timings Show a histogram of first input delay timings faceted by first interaction time ranges: FROM PageViewTiming SELECT histogram( firstInputDelay , 1000, 10) SINCE 3 hours ago WHERE timingName = 'firstInteraction' FACET CASES (WHERE firstInteraction < 1, WHERE firstInteraction >= 1 AND firstInteraction < 5, WHERE firstInteraction >= 5) Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 220.11304,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>PageViewTiming</em>: Async or dynamic <em>page</em> details",
        "sections": "<em>PageViewTiming</em>: Async or dynamic <em>page</em> details",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": " and firstContentfulPaint attributes already are available with <em>Browser</em>Interaction and <em>Page</em>View events. However, they are not always reliably captured before the window onload event fires. Using <em>PageViewTiming</em> gives you a way to capture these metrics even if they happen after the original <em>page</em> <em>load</em> <em>time</em>"
      },
      "id": "603ea90a64441f02614e88a4"
    },
    {
      "sections": [
        "Navigation start time unknown",
        "Contents",
        "Network estimate",
        "Network estimate unavailable",
        "For more help"
      ],
      "title": "Navigation start time unknown",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "e0c839e445b4309c62704afd01702e6588232b45",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/navigation-start-time-unknown/",
      "published_at": "2021-07-02T00:30:05Z",
      "updated_at": "2021-03-11T05:02:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If a browser does not use the Navigation timing API for page load timing (sometimes referred to as real user monitoring or RUM), the browser uses a cookie to determine the navigation start time. If a user navigates from a site without page load timing to a site with page load timing (for example, to the first page on your page load timing-enabled site), special considerations for navigation start time arise. Contents Network estimate The page load timing JavaScript utility file creates a cookie with the navigation start time when a user leaves a page (by hooking an event, beforeunload, or pagehide, depending on the browser). However, when navigating away from a site without page load timing enabled, the JavaScript code will not be present, and the cookie will not be created. Then, when the user hits the first page of a site, the navigation start time cannot be determined, because there is no cookie. In this case Browser monitoring has all the data (queue time, app time, DOM content and rendering time) except network time. Navigation start time is required to compute network time. Rather than toss the data, the page load timing feature estimates the network time based on recently accumulated averages for your application, regionally. This way the page load timing feature provides a more accurate throughput measurement, and the rest of the data is retained. This is especially important for sites with a high bounce rate (when users visit only one page). The more visitors you have from different regions, the more accurate the network estimate will be. Network estimate unavailable If a network estimate is not available for your application and for the region where the hit originated, the page load timing process reverts to a network estimate across all reporting apps for the region. Failing that, the data is tossed. Note: For browsers that have the Navigation Timing API, this is not an issue, as the navigation start time can be determined without using a cookie. For more help Additional documentation resources include: Instrumentation for page load timing (JavaScript elements, data transmission) Page load timing process (overview including time segments and colors, differences between app server requests and page load timing, outliers)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 219.33653,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Navigation start <em>time</em> unknown",
        "sections": "Navigation start <em>time</em> unknown",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "If a <em>browser</em> does not use the Navigation <em>timing</em> API for <em>page</em> <em>load</em> <em>timing</em> (sometimes referred to as real user <em>monitoring</em> or RUM), the <em>browser</em> uses a cookie to determine the navigation start <em>time</em>. If a user navigates from a site without <em>page</em> <em>load</em> <em>timing</em> to a site with <em>page</em> <em>load</em> <em>timing</em> (for example"
      },
      "id": "6043ec3ae7b9d2b8d95799be"
    },
    {
      "sections": [
        "New Relic cookies used by Browser",
        "Tip",
        "Data privacy and legal compliance",
        "JSESSIONID",
        "NREUM",
        "NRAGENT"
      ],
      "title": "New Relic cookies used by Browser",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "fe0f7b83aafd52fce5ffff3176545910ed9cbb54",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/page-load-timing-resources/new-relic-cookies-used-browser/",
      "published_at": "2021-07-02T09:17:12Z",
      "updated_at": "2021-03-11T05:02:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes data privacy related to Browser monitoring and cookies, and details about the cookies themselves. Page load timing (sometimes referred to as real user monitoring or RUM) creates the following cookies that Browser monitoring uses when session tracking in end-user browsers. Tip These cookies are related to Browser app monitoring. For more information about data privacy and requesting data to be deleted, see New Relic personal data requests. Data privacy and legal compliance The default Browser agent configuration does not retain any personal data as defined by common privacy laws such as the EU General Data Protection Regulation (GDPR) and California Consumer Privacy Act (CCPA). New Relic has taken steps to enable our customers who elect to process personal data in our products to do so in accordance with applicable privacy laws. Use the additional information below to help enable your compliance with such laws: Data Description IP addresses New Relic briefly collects and leverages the IP address from the end-user as part of the data collection process. The IP is captured when a connection is made between the end user's browser and the New Relic data collector. The IP address is included in the web request, much like a caller ID. New Relic uses the IP, much like you see a phone number when somebody calls you. The IP address is used as a lookup value that maps to additional details, allowing New Relic customers to diagnose performance issues. IP address lookup values include: countryCode regionCode city asn (Autonomous System Number) asnOrganization (ISP/Business/Institution) asnLatitude asnLongitude The mapping process for the IP address lookup value is typically complete within minutes, but in some extreme cases may take up to 24 hours to process. Once the mapping process is complete, New Relic no longer retains the IP address. Default cookies The Browser monitoring agent sets cookies by default. Cookies are placed by the Browser agent and the New Relic collector. The New Relic collector places a cookie when the Browser agent makes a connection and transmits data. A cookie consent manager that uses a conditional script loader that only loads tags/snippets when a visitor agrees to a specific type of cookies can be used. By choosing this option there is a risk that page performance will not be captured until the visitor has agreed and the Browser agent is running. With the release of Browser agent v1169, you can turn off cookie collection (JSESSIONID and NREUM) for your Browser app by using the Application settings page in the New Relic UI. Once this configuration value is set to false (OFF), you will no longer see the session information in your event data. By default, the value is set to true (ON) for all existing Browser apps as well as newly created ones. For more information, see our documentation about cookie collection and session tracking. Personal data through custom Browser configuration New Relic offers the option to manually configure your agent through the Browser monitoring API. This could be used to capture personal data, subject to the restrictions set forth in the Terms of Service with New Relic. (For example, no credit card numbers or sensitive categories of personal data, which are contractually prohibited.) New Relic responds to the instructions specified by the agents, including collecting personal data that may be custom configured. If you (as the data controller) receive a request from one of your own customers and determine that personal data sent to New Relic for processing must be deleted, see New Relic personal data requests. JSESSIONID The JSESSIONID cookie is used to store a session identifier so that New Relic can monitor session counts for an application. The cookie value is generated by Jetty. Components Description Session identifier This is used by New Relic to monitor session counts for an application. Domain The JSESSIONID cookie is associated with the New Relic domain. Expiration JSESSIONID is a session cookie that is deleted when the browser closes. NREUM This cookie is only created in browsers that do not support the Navigation Timing API. When a browser supports the Navigation Timing API, a native interface can be used to determine navigation start time. Mozilla Firefox versions 7 or higher support the Navigation Timing API. However, a bug exists in Firefox's early implementations of the Navigation Timing API that Browser monitoring works around by using this cookie. Components Description Navigation start time Navigation start time is required to measure end user response time. The cookie is written when the current page unloads (as the next navigation begins). Document location Stored as a hash. The document location is used with the referring page URL to validate that the start time refers to the page that was previously being viewed or refreshed (to avoid using an invalid start time from a different navigation). Referring page URLs Stored as a hash. The referring page URL is used with the document location to validate that the start time refers to the page that was previously being viewed or refreshed (to avoid using an invalid start time from a different navigation). Domain The NREUM cookie is associated with the root path of the domain in which the New Relic agent executes. Expiration NREUM is a session cookie that is deleted when the browser closes. NRAGENT The NRAGENT cookie is set only if you use Browser agent version v443 or lower. It is created when a token is handed out to an end user by the New Relic collector. End-user metrics are communicated to New Relic collectors via a JSONP request from the browser (script retrieval). The returned JavaScript contains a call to set the token identifier which is written to the cookie on the next navigation (when the page unloads). This achieves a cross-domain communication between the New Relic collector and the New Relic agent. This cookie is used to communicate between the New Relic collector aggregating end user metrics and the agent(s) running in the associated web application. A token identifies and correlates application tier transaction traces with corresponding browser traces. Components Description Token identifier The 16-character token identifier helps with cross-domain communication between the New Relic collector and the New Relic agent. Domain The NRAGENT cookie is associated with the root path of the domain in which the New Relic agent executes. Expiration NRAGENT is a session cookie that is deleted when the browser closes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 219.33652,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic cookies used by <em>Browser</em>",
        "sections": "New Relic cookies used by <em>Browser</em>",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "This document describes data privacy related to <em>Browser</em> <em>monitoring</em> and cookies, and details about the cookies themselves. <em>Page</em> <em>load</em> <em>timing</em> (sometimes referred to as real user <em>monitoring</em> or RUM) creates the following cookies that <em>Browser</em> <em>monitoring</em> uses when session tracking in end-user browsers"
      },
      "id": "60442a2f196a673c3e960f2f"
    }
  ],
  "/docs/browser/new-relic-browser/page-load-timing-resources/pageviewtiming-async-or-dynamic-page-details": [
    {
      "sections": [
        "Navigation start time unknown",
        "Contents",
        "Network estimate",
        "Network estimate unavailable",
        "For more help"
      ],
      "title": "Navigation start time unknown",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "e0c839e445b4309c62704afd01702e6588232b45",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/page-load-timing-resources/navigation-start-time-unknown/",
      "published_at": "2021-07-02T00:30:05Z",
      "updated_at": "2021-03-11T05:02:27Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If a browser does not use the Navigation timing API for page load timing (sometimes referred to as real user monitoring or RUM), the browser uses a cookie to determine the navigation start time. If a user navigates from a site without page load timing to a site with page load timing (for example, to the first page on your page load timing-enabled site), special considerations for navigation start time arise. Contents Network estimate The page load timing JavaScript utility file creates a cookie with the navigation start time when a user leaves a page (by hooking an event, beforeunload, or pagehide, depending on the browser). However, when navigating away from a site without page load timing enabled, the JavaScript code will not be present, and the cookie will not be created. Then, when the user hits the first page of a site, the navigation start time cannot be determined, because there is no cookie. In this case Browser monitoring has all the data (queue time, app time, DOM content and rendering time) except network time. Navigation start time is required to compute network time. Rather than toss the data, the page load timing feature estimates the network time based on recently accumulated averages for your application, regionally. This way the page load timing feature provides a more accurate throughput measurement, and the rest of the data is retained. This is especially important for sites with a high bounce rate (when users visit only one page). The more visitors you have from different regions, the more accurate the network estimate will be. Network estimate unavailable If a network estimate is not available for your application and for the region where the hit originated, the page load timing process reverts to a network estimate across all reporting apps for the region. Failing that, the data is tossed. Note: For browsers that have the Navigation Timing API, this is not an issue, as the navigation start time can be determined without using a cookie. For more help Additional documentation resources include: Instrumentation for page load timing (JavaScript elements, data transmission) Page load timing process (overview including time segments and colors, differences between app server requests and page load timing, outliers)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 219.33653,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Navigation start <em>time</em> unknown",
        "sections": "Navigation start <em>time</em> unknown",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "If a <em>browser</em> does not use the Navigation <em>timing</em> API for <em>page</em> <em>load</em> <em>timing</em> (sometimes referred to as real user <em>monitoring</em> or RUM), the <em>browser</em> uses a cookie to determine the navigation start <em>time</em>. If a user navigates from a site without <em>page</em> <em>load</em> <em>timing</em> to a site with <em>page</em> <em>load</em> <em>timing</em> (for example"
      },
      "id": "6043ec3ae7b9d2b8d95799be"
    },
    {
      "sections": [
        "New Relic cookies used by Browser",
        "Tip",
        "Data privacy and legal compliance",
        "JSESSIONID",
        "NREUM",
        "NRAGENT"
      ],
      "title": "New Relic cookies used by Browser",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "fe0f7b83aafd52fce5ffff3176545910ed9cbb54",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/page-load-timing-resources/new-relic-cookies-used-browser/",
      "published_at": "2021-07-02T09:17:12Z",
      "updated_at": "2021-03-11T05:02:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes data privacy related to Browser monitoring and cookies, and details about the cookies themselves. Page load timing (sometimes referred to as real user monitoring or RUM) creates the following cookies that Browser monitoring uses when session tracking in end-user browsers. Tip These cookies are related to Browser app monitoring. For more information about data privacy and requesting data to be deleted, see New Relic personal data requests. Data privacy and legal compliance The default Browser agent configuration does not retain any personal data as defined by common privacy laws such as the EU General Data Protection Regulation (GDPR) and California Consumer Privacy Act (CCPA). New Relic has taken steps to enable our customers who elect to process personal data in our products to do so in accordance with applicable privacy laws. Use the additional information below to help enable your compliance with such laws: Data Description IP addresses New Relic briefly collects and leverages the IP address from the end-user as part of the data collection process. The IP is captured when a connection is made between the end user's browser and the New Relic data collector. The IP address is included in the web request, much like a caller ID. New Relic uses the IP, much like you see a phone number when somebody calls you. The IP address is used as a lookup value that maps to additional details, allowing New Relic customers to diagnose performance issues. IP address lookup values include: countryCode regionCode city asn (Autonomous System Number) asnOrganization (ISP/Business/Institution) asnLatitude asnLongitude The mapping process for the IP address lookup value is typically complete within minutes, but in some extreme cases may take up to 24 hours to process. Once the mapping process is complete, New Relic no longer retains the IP address. Default cookies The Browser monitoring agent sets cookies by default. Cookies are placed by the Browser agent and the New Relic collector. The New Relic collector places a cookie when the Browser agent makes a connection and transmits data. A cookie consent manager that uses a conditional script loader that only loads tags/snippets when a visitor agrees to a specific type of cookies can be used. By choosing this option there is a risk that page performance will not be captured until the visitor has agreed and the Browser agent is running. With the release of Browser agent v1169, you can turn off cookie collection (JSESSIONID and NREUM) for your Browser app by using the Application settings page in the New Relic UI. Once this configuration value is set to false (OFF), you will no longer see the session information in your event data. By default, the value is set to true (ON) for all existing Browser apps as well as newly created ones. For more information, see our documentation about cookie collection and session tracking. Personal data through custom Browser configuration New Relic offers the option to manually configure your agent through the Browser monitoring API. This could be used to capture personal data, subject to the restrictions set forth in the Terms of Service with New Relic. (For example, no credit card numbers or sensitive categories of personal data, which are contractually prohibited.) New Relic responds to the instructions specified by the agents, including collecting personal data that may be custom configured. If you (as the data controller) receive a request from one of your own customers and determine that personal data sent to New Relic for processing must be deleted, see New Relic personal data requests. JSESSIONID The JSESSIONID cookie is used to store a session identifier so that New Relic can monitor session counts for an application. The cookie value is generated by Jetty. Components Description Session identifier This is used by New Relic to monitor session counts for an application. Domain The JSESSIONID cookie is associated with the New Relic domain. Expiration JSESSIONID is a session cookie that is deleted when the browser closes. NREUM This cookie is only created in browsers that do not support the Navigation Timing API. When a browser supports the Navigation Timing API, a native interface can be used to determine navigation start time. Mozilla Firefox versions 7 or higher support the Navigation Timing API. However, a bug exists in Firefox's early implementations of the Navigation Timing API that Browser monitoring works around by using this cookie. Components Description Navigation start time Navigation start time is required to measure end user response time. The cookie is written when the current page unloads (as the next navigation begins). Document location Stored as a hash. The document location is used with the referring page URL to validate that the start time refers to the page that was previously being viewed or refreshed (to avoid using an invalid start time from a different navigation). Referring page URLs Stored as a hash. The referring page URL is used with the document location to validate that the start time refers to the page that was previously being viewed or refreshed (to avoid using an invalid start time from a different navigation). Domain The NREUM cookie is associated with the root path of the domain in which the New Relic agent executes. Expiration NREUM is a session cookie that is deleted when the browser closes. NRAGENT The NRAGENT cookie is set only if you use Browser agent version v443 or lower. It is created when a token is handed out to an end user by the New Relic collector. End-user metrics are communicated to New Relic collectors via a JSONP request from the browser (script retrieval). The returned JavaScript contains a call to set the token identifier which is written to the cookie on the next navigation (when the page unloads). This achieves a cross-domain communication between the New Relic collector and the New Relic agent. This cookie is used to communicate between the New Relic collector aggregating end user metrics and the agent(s) running in the associated web application. A token identifies and correlates application tier transaction traces with corresponding browser traces. Components Description Token identifier The 16-character token identifier helps with cross-domain communication between the New Relic collector and the New Relic agent. Domain The NRAGENT cookie is associated with the root path of the domain in which the New Relic agent executes. Expiration NRAGENT is a session cookie that is deleted when the browser closes.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 219.33652,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic cookies used by <em>Browser</em>",
        "sections": "New Relic cookies used by <em>Browser</em>",
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "This document describes data privacy related to <em>Browser</em> <em>monitoring</em> and cookies, and details about the cookies themselves. <em>Page</em> <em>load</em> <em>timing</em> (sometimes referred to as real user <em>monitoring</em> or RUM) creates the following cookies that <em>Browser</em> <em>monitoring</em> uses when session tracking in end-user browsers"
      },
      "id": "60442a2f196a673c3e960f2f"
    },
    {
      "sections": [
        "Cookie collection and session tracking",
        "How it works",
        "Enable or disable cookie collection"
      ],
      "title": "Cookie collection and session tracking",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Page load timing resources"
      ],
      "external_id": "4ad3150808fab2f68a2f944a8966ab9b60ee684b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/page-load-timing-resources/cookie-collection-session-tracking/",
      "published_at": "2021-07-02T09:17:12Z",
      "updated_at": "2021-03-11T05:02:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's page load timing feature can track sessions by using cookies that contain a simple session identifier. How it works Here is the basic process for session tracking: A session begins when a user visits a website where New Relic's browser monitoring is installed and cookie collection is enabled. After the user's browser is opened, our browser monitoring script sets a simple cookie identifying the session. The script then reads the cookie on subsequent page loads. The same session will continue until the user's browser is closed. Session tracking will not work properly in these situations: If users have cookies disabled in their browser If the browser is configured to not allow information associated with the New Relic cookie to be sent with the request from the monitored site Enable or disable cookie collection At New Relic, we take data privacy seriously. By default, we do not retain any personal data collected by our Browser agent, and you can control session tracking. To turn cookie collection on or off for your app: Go to one.newrelic.com > Browser > (select an app) > Settings > Application settings. In your app's Privacy settings, toggle Cookie collection.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 219.33652,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Page</em> <em>load</em> <em>timing</em> <em>resources</em>",
        "body": "<em>Browser</em> <em>monitoring</em>&#x27;s <em>page</em> <em>load</em> <em>timing</em> feature can track sessions by using cookies that contain a simple session identifier. How it works Here is the basic process for session tracking: A session begins when a user visits a website where New Relic&#x27;s <em>browser</em> <em>monitoring</em> is installed and cookie"
      },
      "id": "60442a2f28ccbc1bfe2c60a7"
    }
  ],
  "/docs/browser/new-relic-browser/performance-quality/browser-monitoring-performance-impact": [
    {
      "sections": [
        "Browser monitoring and search engine optimization",
        "Contents",
        "Efficiency of inline JavaScript",
        "Impact on SEO",
        "For more help"
      ],
      "title": "Browser monitoring and search engine optimization",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Performance quality"
      ],
      "external_id": "1f3f91b4e13af6b49f484d7ba08f338e7f4344f0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/performance-quality/browser-monitoring-search-engine-optimization/",
      "published_at": "2021-07-02T00:32:07Z",
      "updated_at": "2021-03-13T01:34:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring places a small \"loader\" script into the head section of each page on a monitored site. This JavaScript instrumentation has been designed to: Provide maximum visibility into front-end performance, accurately time how long it takes for pages to load in all browsers, and to report details for JavaScript errors and AJAX calls. Have minimal impact on overall page load time and search engine optimization (SEO), including search engine ranking, indexing, crawl efficiency, or other SEO-related concerns. Contents Efficiency of inline JavaScript The most effective method for Browser monitoring is to include a minimal amount of JavaScript instrumentation code inline in the head of the monitored page. This code then retrieves the remainder of the necessary code after the page finishes loading. Other Browser monitoring methods include JavaScript code at the end of the page body or exclusively using an external script. However, these methods can limit visibility into the end users' experience. Impact on SEO Performance testing results indicate that using Browser monitoring's JavaScript has a negligible effect on page load time. In addition, it has no negative impact on how users or search engines interact with your site. Google's consistent recommendation to website owners is to build a site that is valuable to users and accessible to search engine crawlers. Google rankings favor sites that provide the most relevant information and the best user experience. Browser monitoring can help you improve user experience by identifying performance bottlenecks, including: Slow page loads Problematic JavaScript errors Long AJAX calls Identifying Javascript errors is especially helpful because Google's bots are increasingly running the JavaScript code on websites they crawl in order to access content provided by AJAX-heavy web applications. A JavaScript error that previously was only visible to human users (for example, a broken button) could affect whether the Google bots can successfully interact with your site. We understand that SEO and traffic referred by search engines are critically important to many businesses. When used effectively, Browser monitoring can even increase a site's ranking in Google and other search engines by improving performance and user experience. For more help Additional documentation resources include: Instrumentation for page load timing (JavaScript elements, data transmission) Page load timing process (overview including time segments and colors, differences between app server requests and page load timing, outliers) How Browser monitoring can boost SEO (2014 blog post with SEO tips)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.82434,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> <em>monitoring</em> and search engine optimization",
        "sections": "<em>Browser</em> <em>monitoring</em> and search engine optimization",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em> places a small &quot;loader&quot; script into the head section of each page on a monitored site. This JavaScript instrumentation has been designed to: Provide maximum visibility into front-end <em>performance</em>, accurately time how long it takes for pages to load in all browsers, and to report"
      },
      "id": "6043fa33196a675d7b960f85"
    },
    {
      "sections": [
        "Security for Browser monitoring",
        "Reported data",
        "Page view data",
        "AJAX timing data",
        "JavaScript error data",
        "Session trace data",
        "SPA data",
        "URL query strings",
        "Visitor's IP address",
        "Browser types",
        "CDN access",
        "Important",
        "Cookies",
        "JSONP requests"
      ],
      "title": "Security for Browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Performance quality"
      ],
      "external_id": "99cd4023fc519082ebe94082e3a6affd1cc2344f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/performance-quality/security-browser-monitoring/",
      "published_at": "2021-07-02T00:32:08Z",
      "updated_at": "2021-03-13T01:18:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring provides insights into how your application or site behaves when it is loaded in a web browser. Browser only records performance data, as explained in this document. It does not record any data used or stored by the monitored application unless you explicitly configure it to do so. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Reported data Browser reports many different types of data to help you analyze your website's performance. It only reports page view data, unless you have subscribed to Pro features. You can also enable functionality for AJAX requests, JavaScript errors, and session traces. For most data types, Browser transmits the data securely using HTTPS encryption. The Browser agent transmits data to New Relic's collectors by using either of the domains bam.nr-data.net or bam-cell.nr-data.net. Here is a summary of the types of data reported by Browser monitoring. Page view data This data is reported once per page view and consists of: Page load timing data Name of the server-side app controller that served the page, if available (obfuscated in the page and during transmission) Additional custom parameters set by the server-side app controller, if available (obfuscated in the page and during transmission) Additional custom parameters set by the Browser agent API, if set prior to page load This information appears on the Page views page. For data security reasons, Browser does not record or collect URL query strings. Server-side data can only be collected when the host is also instrumented by New Relic and the browser monitoring instrumentation is injected by the agent. For more information about how we collect and present this data, see Instrumentation for page load timing. AJAX timing data When enabled, Browser periodically reports AJAX timing data until the user navigates away from or closes the page. (New Relic automatically filters out all AJAX requests that take longer than two minutes.) Data includes: Hostnames, ports, and paths (but not search/query parameters) of AJAX request URLs HTTP status code of responses Byte size of request message bodies Name of the server-side app controller servicing the AJAX request and server-side timing data (obfuscated in the page and during transmission), when the browser instrumentation is injected by the New Relic agent Timing data for the AJAX transaction Timing data for the AJAX callbacks This information appears on the AJAX page. JavaScript error data When enabled, Browser periodically reports data about every error that occurs on the page until the user navigates away from or closes the page. This information appears on the JavaScript errors page. For each error, the data includes: Exception class of the error Error message containing arbitrary text Stack trace of the error, which may contain function names and URLs of scripts causing the error Error messages typically do not contain any confidential or sensitive information. However, it is possible for messages to be purposefully constructed with sensitive information. Before enabling JavaScript error reporting, ensure that your website does not expose any sensitive information in error messages. Session trace data When enabled, Browser periodically reports data on the details of the a single page's life cycle, including user interactions, AJAX loads, and JavaScript errors, until the user navigates away from or closes the page. New Relic automatically stops recording further data after ten minutes. Data includes: Asset load timing details User interactions such as scrolling, mousing, and clicking JavaScript error timing and other JavaScript error information Triggered Javascript events Session traces are captured randomly at a fixed rate from among the monitored page views. Session trace information appears on the Session traces page. SPA data If you use Browser's single-page app (SPA) monitoring, New Relic reports the following data once per page load or route change. Browser data for page views, AJAX timing, JavaScript errors, and session traces Hash fragments associated with SPA route changes Additional custom parameters added from the SPA API When SPA monitoring has been enabled, this information appears on the Page views page. Server-side data can only be collected when the host is also instrumented by New Relic, and the Browser monitoring instrumentation is injected by the agent. For more information about how we collect and present this data, see Instrumentation for page load timing. URL query strings The Browser agent uses the HTTP referer attribute to track page URLs. URLs can sometimes contain potentially sensitive user-entered query data (for example, a user's name). For data security reasons, Browser does not record or collect URL query strings. Visitor's IP address Browser uses the visitor's IP address to enrich data for additional visitor segmentation. Details such as the ASN and geoID are mapped to Browser data from the IP address. For data security reasons, Browser does not retain the visitor's IP address for reporting. The IP address is obtained in the HTTP header from the request to the New Relic collector. New Relic does not retain the visitor's IP address after the attributes have been mapped. The IP address value is overwritten within 24 hours of data being collected. Browser types Browser determines the browser type from the User-Agent header and the geographical location based on the browser's IP address. New Relic does not retain the IP address, only the country and region associated with the performance data. This information appears on the selected app's Geography page. Also, details about specific browser types appear on the selected app's Browsers page. CDN access Page load timing requires access to the content delivery network (CDN), where New Relic's utility JavaScript file (nr.js) is hosted. The domain name for the file (js-agent.newrelic.com) remains static, but the number in the path (version) may change periodically. A script tag is injected by the New Relic agent (or pasted into the webpage for standalone apps) that references the JavaScript on the CDN, which is then loaded by the browser. The loaded JavaScript collects and reports the metrics dynamically to either of the domains bam.nr-data.net or bam-cell.nr-data.net. Important If your end users are behind a firewall or proxy and do not have access to the CDN or to New Relic's networks (including bam.nr-data.net and bam-cell.nr-data.net), Browser monitoring will not work. Cookies Browser monitoring creates cookies in the end user's browser. If the user has cookies disabled, page load timing (sometimes referred to as real user monitoring or RUM) will not be able to track sessions properly. Also, if the user has an older browser that does not support the Navigation Timing Specification API, page load timing will not be able to track response times as accurately. New Relic's cookies generated by Browser agents older than version 995 may not contain the secure attribute. This is because page load timing data transmission in versions before version 995 use HTTP when the page is HTTP, but use HTTPS when the page is HTTPS. All Browser agent versions above version 995 will always use the secure flag for cookies and transmit over HTTPS. JavaScript and AJAX data may contain more sensitive information, so they are always transmitted over HTTPS. Transmission of these cookies using HTTP or access to them from JavaScript is not a significant security risk, because the cookies are not used to make security decisions or allow access to an account. They are used only to collect performance data, with any identifiable data obfuscated. For customers subject to special guidelines for cookie collection, such as those under the EU GDPR/PECR ICO Guidelines, we now provide the option to disable cookie collection for your application. Please see our Browser agent v1169 release notes for more information. Important If your site uses P3P, it must be configured to allow these cookies. JSONP requests Page load timing metrics are reported to New Relic using a Script GET, also known as a JSONP request. The Script GET returns a value that is subsequently stored in a cookie and used to trigger trace capturing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.82289,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Security for <em>Browser</em> <em>monitoring</em>",
        "sections": "Security for <em>Browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em> provides insights into how your application or site behaves when it is loaded in a web <em>browser</em>. <em>Browser</em> only records <em>performance</em> data, as explained in this document. It does not record any data used or stored by the monitored application unless you explicitly configure it to do"
      },
      "id": "6043efdf64441f772e378f12"
    },
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.31876,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "If you use <em>Browser</em> to <em>monitor</em> end-user <em>browser</em> activity, you can now see end-user-originating <em>browser</em>-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data"
      },
      "id": "6043fe6f196a6784f0960f53"
    }
  ],
  "/docs/browser/new-relic-browser/performance-quality/browser-monitoring-search-engine-optimization": [
    {
      "sections": [
        "Browser monitoring and performance impact",
        "Contents",
        "Overall impact",
        "Network impact",
        "For more help"
      ],
      "title": "Browser monitoring and performance impact",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Performance quality"
      ],
      "external_id": "5504ef3846f4bcdae0ff4f58e8c745079d9a5cb7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/performance-quality/browser-monitoring-performance-impact/",
      "published_at": "2021-07-02T00:31:08Z",
      "updated_at": "2021-03-16T08:27:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's JavaScript snippet introduces a nearly invisible impact on website performance and user perception of the time it takes a page to load. The JavaScript is included in a packet of webpage data that is sent anyway. In addition, it immediately begins monitoring for errors and events as the rest of the webpage executes. The negligible amount of overhead required to load the JavaScript results in a significant return of actionable data. Contents Overall impact The JavaScript's overhead takes into consideration both the impact on the user and the impact on your systems' performance: User perception: Typically users cannot detect performance degradations on a website of less than 200ms. Browser's JavaScript adds less than 15ms in aggregated time per page load. This is split up over time, so at no point would a user be able to perceive any performance impact due to the JavaScript. Webserver and systems: Browser App Monitoring occurs on the user's browser, not on the server. Processing time does not have an impact on your CPU consumption. In addition, we take additional steps to minimize any potential impact on the apps and webpages being monitored. For example, the \"loader\" script is loaded synchronously in the <HEAD> in order to ensure monitoring is enabled for the entire life cycle of the page. This script is included inline, which eliminates the need for another roundtrip network request to a content delivery network (CDN). The \"loader\" comes with the initial page load. Later in the life cycle of the page, New Relic loads an additional monitoring script asynchronously. This script should not have any perceivable effect to the user and is included in the overall overhead of less than 15ms per page. Network impact Browser monitoring also minimizes network traffic for the end user by aggregating data locally (in the client) and sending it back to New Relic on load, at periodic intervals, on unload, or when data has been collected. (During the browser session's idle periods, transmissions may not be required.) For more help Additional documentation resources include: Instrumentation for page load timing (JavaScript elements, data transmission) Browser monitoring and search engine optimization (how Browser ensures that the JavaScript has a negligible impact on SEO)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 186.25443,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> <em>monitoring</em> and <em>performance</em> impact",
        "sections": "<em>Browser</em> <em>monitoring</em> and <em>performance</em> impact",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em>&#x27;s JavaScript snippet introduces a nearly invisible impact on website <em>performance</em> and user perception of the time it takes a page to load. The JavaScript is included in a packet of webpage data that is sent anyway. In addition, it immediately begins <em>monitoring</em> for errors"
      },
      "id": "603ec318196a67a757a83dd1"
    },
    {
      "sections": [
        "Security for Browser monitoring",
        "Reported data",
        "Page view data",
        "AJAX timing data",
        "JavaScript error data",
        "Session trace data",
        "SPA data",
        "URL query strings",
        "Visitor's IP address",
        "Browser types",
        "CDN access",
        "Important",
        "Cookies",
        "JSONP requests"
      ],
      "title": "Security for Browser monitoring",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Performance quality"
      ],
      "external_id": "99cd4023fc519082ebe94082e3a6affd1cc2344f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/performance-quality/security-browser-monitoring/",
      "published_at": "2021-07-02T00:32:08Z",
      "updated_at": "2021-03-13T01:18:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring provides insights into how your application or site behaves when it is loaded in a web browser. Browser only records performance data, as explained in this document. It does not record any data used or stored by the monitored application unless you explicitly configure it to do so. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Reported data Browser reports many different types of data to help you analyze your website's performance. It only reports page view data, unless you have subscribed to Pro features. You can also enable functionality for AJAX requests, JavaScript errors, and session traces. For most data types, Browser transmits the data securely using HTTPS encryption. The Browser agent transmits data to New Relic's collectors by using either of the domains bam.nr-data.net or bam-cell.nr-data.net. Here is a summary of the types of data reported by Browser monitoring. Page view data This data is reported once per page view and consists of: Page load timing data Name of the server-side app controller that served the page, if available (obfuscated in the page and during transmission) Additional custom parameters set by the server-side app controller, if available (obfuscated in the page and during transmission) Additional custom parameters set by the Browser agent API, if set prior to page load This information appears on the Page views page. For data security reasons, Browser does not record or collect URL query strings. Server-side data can only be collected when the host is also instrumented by New Relic and the browser monitoring instrumentation is injected by the agent. For more information about how we collect and present this data, see Instrumentation for page load timing. AJAX timing data When enabled, Browser periodically reports AJAX timing data until the user navigates away from or closes the page. (New Relic automatically filters out all AJAX requests that take longer than two minutes.) Data includes: Hostnames, ports, and paths (but not search/query parameters) of AJAX request URLs HTTP status code of responses Byte size of request message bodies Name of the server-side app controller servicing the AJAX request and server-side timing data (obfuscated in the page and during transmission), when the browser instrumentation is injected by the New Relic agent Timing data for the AJAX transaction Timing data for the AJAX callbacks This information appears on the AJAX page. JavaScript error data When enabled, Browser periodically reports data about every error that occurs on the page until the user navigates away from or closes the page. This information appears on the JavaScript errors page. For each error, the data includes: Exception class of the error Error message containing arbitrary text Stack trace of the error, which may contain function names and URLs of scripts causing the error Error messages typically do not contain any confidential or sensitive information. However, it is possible for messages to be purposefully constructed with sensitive information. Before enabling JavaScript error reporting, ensure that your website does not expose any sensitive information in error messages. Session trace data When enabled, Browser periodically reports data on the details of the a single page's life cycle, including user interactions, AJAX loads, and JavaScript errors, until the user navigates away from or closes the page. New Relic automatically stops recording further data after ten minutes. Data includes: Asset load timing details User interactions such as scrolling, mousing, and clicking JavaScript error timing and other JavaScript error information Triggered Javascript events Session traces are captured randomly at a fixed rate from among the monitored page views. Session trace information appears on the Session traces page. SPA data If you use Browser's single-page app (SPA) monitoring, New Relic reports the following data once per page load or route change. Browser data for page views, AJAX timing, JavaScript errors, and session traces Hash fragments associated with SPA route changes Additional custom parameters added from the SPA API When SPA monitoring has been enabled, this information appears on the Page views page. Server-side data can only be collected when the host is also instrumented by New Relic, and the Browser monitoring instrumentation is injected by the agent. For more information about how we collect and present this data, see Instrumentation for page load timing. URL query strings The Browser agent uses the HTTP referer attribute to track page URLs. URLs can sometimes contain potentially sensitive user-entered query data (for example, a user's name). For data security reasons, Browser does not record or collect URL query strings. Visitor's IP address Browser uses the visitor's IP address to enrich data for additional visitor segmentation. Details such as the ASN and geoID are mapped to Browser data from the IP address. For data security reasons, Browser does not retain the visitor's IP address for reporting. The IP address is obtained in the HTTP header from the request to the New Relic collector. New Relic does not retain the visitor's IP address after the attributes have been mapped. The IP address value is overwritten within 24 hours of data being collected. Browser types Browser determines the browser type from the User-Agent header and the geographical location based on the browser's IP address. New Relic does not retain the IP address, only the country and region associated with the performance data. This information appears on the selected app's Geography page. Also, details about specific browser types appear on the selected app's Browsers page. CDN access Page load timing requires access to the content delivery network (CDN), where New Relic's utility JavaScript file (nr.js) is hosted. The domain name for the file (js-agent.newrelic.com) remains static, but the number in the path (version) may change periodically. A script tag is injected by the New Relic agent (or pasted into the webpage for standalone apps) that references the JavaScript on the CDN, which is then loaded by the browser. The loaded JavaScript collects and reports the metrics dynamically to either of the domains bam.nr-data.net or bam-cell.nr-data.net. Important If your end users are behind a firewall or proxy and do not have access to the CDN or to New Relic's networks (including bam.nr-data.net and bam-cell.nr-data.net), Browser monitoring will not work. Cookies Browser monitoring creates cookies in the end user's browser. If the user has cookies disabled, page load timing (sometimes referred to as real user monitoring or RUM) will not be able to track sessions properly. Also, if the user has an older browser that does not support the Navigation Timing Specification API, page load timing will not be able to track response times as accurately. New Relic's cookies generated by Browser agents older than version 995 may not contain the secure attribute. This is because page load timing data transmission in versions before version 995 use HTTP when the page is HTTP, but use HTTPS when the page is HTTPS. All Browser agent versions above version 995 will always use the secure flag for cookies and transmit over HTTPS. JavaScript and AJAX data may contain more sensitive information, so they are always transmitted over HTTPS. Transmission of these cookies using HTTP or access to them from JavaScript is not a significant security risk, because the cookies are not used to make security decisions or allow access to an account. They are used only to collect performance data, with any identifiable data obfuscated. For customers subject to special guidelines for cookie collection, such as those under the EU GDPR/PECR ICO Guidelines, we now provide the option to disable cookie collection for your application. Please see our Browser agent v1169 release notes for more information. Important If your site uses P3P, it must be configured to allow these cookies. JSONP requests Page load timing metrics are reported to New Relic using a Script GET, also known as a JSONP request. The Script GET returns a value that is subsequently stored in a cookie and used to trigger trace capturing.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.82289,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Security for <em>Browser</em> <em>monitoring</em>",
        "sections": "Security for <em>Browser</em> <em>monitoring</em>",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em> provides insights into how your application or site behaves when it is loaded in a web <em>browser</em>. <em>Browser</em> only records <em>performance</em> data, as explained in this document. It does not record any data used or stored by the monitored application unless you explicitly configure it to do"
      },
      "id": "6043efdf64441f772e378f12"
    },
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.31876,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "If you use <em>Browser</em> to <em>monitor</em> end-user <em>browser</em> activity, you can now see end-user-originating <em>browser</em>-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data"
      },
      "id": "6043fe6f196a6784f0960f53"
    }
  ],
  "/docs/browser/new-relic-browser/performance-quality/security-browser-monitoring": [
    {
      "sections": [
        "Browser monitoring and performance impact",
        "Contents",
        "Overall impact",
        "Network impact",
        "For more help"
      ],
      "title": "Browser monitoring and performance impact",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Performance quality"
      ],
      "external_id": "5504ef3846f4bcdae0ff4f58e8c745079d9a5cb7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/performance-quality/browser-monitoring-performance-impact/",
      "published_at": "2021-07-02T00:31:08Z",
      "updated_at": "2021-03-16T08:27:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring's JavaScript snippet introduces a nearly invisible impact on website performance and user perception of the time it takes a page to load. The JavaScript is included in a packet of webpage data that is sent anyway. In addition, it immediately begins monitoring for errors and events as the rest of the webpage executes. The negligible amount of overhead required to load the JavaScript results in a significant return of actionable data. Contents Overall impact The JavaScript's overhead takes into consideration both the impact on the user and the impact on your systems' performance: User perception: Typically users cannot detect performance degradations on a website of less than 200ms. Browser's JavaScript adds less than 15ms in aggregated time per page load. This is split up over time, so at no point would a user be able to perceive any performance impact due to the JavaScript. Webserver and systems: Browser App Monitoring occurs on the user's browser, not on the server. Processing time does not have an impact on your CPU consumption. In addition, we take additional steps to minimize any potential impact on the apps and webpages being monitored. For example, the \"loader\" script is loaded synchronously in the <HEAD> in order to ensure monitoring is enabled for the entire life cycle of the page. This script is included inline, which eliminates the need for another roundtrip network request to a content delivery network (CDN). The \"loader\" comes with the initial page load. Later in the life cycle of the page, New Relic loads an additional monitoring script asynchronously. This script should not have any perceivable effect to the user and is included in the overall overhead of less than 15ms per page. Network impact Browser monitoring also minimizes network traffic for the end user by aggregating data locally (in the client) and sending it back to New Relic on load, at periodic intervals, on unload, or when data has been collected. (During the browser session's idle periods, transmissions may not be required.) For more help Additional documentation resources include: Instrumentation for page load timing (JavaScript elements, data transmission) Browser monitoring and search engine optimization (how Browser ensures that the JavaScript has a negligible impact on SEO)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 186.25443,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> <em>monitoring</em> and <em>performance</em> impact",
        "sections": "<em>Browser</em> <em>monitoring</em> and <em>performance</em> impact",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em>&#x27;s JavaScript snippet introduces a nearly invisible impact on website <em>performance</em> and user perception of the time it takes a page to load. The JavaScript is included in a packet of webpage data that is sent anyway. In addition, it immediately begins <em>monitoring</em> for errors"
      },
      "id": "603ec318196a67a757a83dd1"
    },
    {
      "sections": [
        "Browser monitoring and search engine optimization",
        "Contents",
        "Efficiency of inline JavaScript",
        "Impact on SEO",
        "For more help"
      ],
      "title": "Browser monitoring and search engine optimization",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Performance quality"
      ],
      "external_id": "1f3f91b4e13af6b49f484d7ba08f338e7f4344f0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/performance-quality/browser-monitoring-search-engine-optimization/",
      "published_at": "2021-07-02T00:32:07Z",
      "updated_at": "2021-03-13T01:34:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser monitoring places a small \"loader\" script into the head section of each page on a monitored site. This JavaScript instrumentation has been designed to: Provide maximum visibility into front-end performance, accurately time how long it takes for pages to load in all browsers, and to report details for JavaScript errors and AJAX calls. Have minimal impact on overall page load time and search engine optimization (SEO), including search engine ranking, indexing, crawl efficiency, or other SEO-related concerns. Contents Efficiency of inline JavaScript The most effective method for Browser monitoring is to include a minimal amount of JavaScript instrumentation code inline in the head of the monitored page. This code then retrieves the remainder of the necessary code after the page finishes loading. Other Browser monitoring methods include JavaScript code at the end of the page body or exclusively using an external script. However, these methods can limit visibility into the end users' experience. Impact on SEO Performance testing results indicate that using Browser monitoring's JavaScript has a negligible effect on page load time. In addition, it has no negative impact on how users or search engines interact with your site. Google's consistent recommendation to website owners is to build a site that is valuable to users and accessible to search engine crawlers. Google rankings favor sites that provide the most relevant information and the best user experience. Browser monitoring can help you improve user experience by identifying performance bottlenecks, including: Slow page loads Problematic JavaScript errors Long AJAX calls Identifying Javascript errors is especially helpful because Google's bots are increasingly running the JavaScript code on websites they crawl in order to access content provided by AJAX-heavy web applications. A JavaScript error that previously was only visible to human users (for example, a broken button) could affect whether the Google bots can successfully interact with your site. We understand that SEO and traffic referred by search engines are critically important to many businesses. When used effectively, Browser monitoring can even increase a site's ranking in Google and other search engines by improving performance and user experience. For more help Additional documentation resources include: Instrumentation for page load timing (JavaScript elements, data transmission) Page load timing process (overview including time segments and colors, differences between app server requests and page load timing, outliers) How Browser monitoring can boost SEO (2014 blog post with SEO tips)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 185.82434,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> <em>monitoring</em> and search engine optimization",
        "sections": "<em>Browser</em> <em>monitoring</em> and search engine optimization",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "<em>Browser</em> <em>monitoring</em> places a small &quot;loader&quot; script into the head section of each page on a monitored site. This JavaScript instrumentation has been designed to: Provide maximum visibility into front-end <em>performance</em>, accurately time how long it takes for pages to load in all browsers, and to report"
      },
      "id": "6043fa33196a675d7b960f85"
    },
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 150.31868,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "If you use <em>Browser</em> to <em>monitor</em> end-user <em>browser</em> activity, you can now see end-user-originating <em>browser</em>-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data"
      },
      "id": "6043fe6f196a6784f0960f53"
    }
  ],
  "/docs/browser/new-relic-browser/troubleshooting/ajax-call-fails-cors-redirect-error-message": [
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.33371,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "If you use <em>Browser</em> to <em>monitor</em> end-user <em>browser</em> activity, you can now see end-user-originating <em>browser</em>-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data"
      },
      "id": "6043fe6f196a6784f0960f53"
    },
    {
      "sections": [
        "Not seeing specific page or endpoint names in Browser data",
        "Problem",
        "Solution"
      ],
      "title": "Not seeing specific page or endpoint names in Browser data",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Troubleshooting"
      ],
      "external_id": "e91e38e0160cd95da45e928f462c70fde1457031",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/troubleshooting/not-seeing-specific-page-or-endpoint-names-browser-data/",
      "published_at": "2021-07-02T00:36:02Z",
      "updated_at": "2021-06-14T22:19:10Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You're looking for performance breakdowns for specific pages or endpoints on the browser monitoring Page views UI page or AJAX UI page. The UI doesn't show the URL group you're looking for, or it only shows / and /*. This behavior also appears in SPA data in BrowserInteraction events and applies to browserInteractionName, targetGroupedUrl, and previousGroupedUrl attributes. Solution Browser monitoring automatically \"learns\" to group your page views when your application is first deployed, and it adds that information to an allow list for URLs. Sometimes this grouping may not match your current page view information. To solve this problem, manage your application's URL segment list settings by editing existing rules or by adding the domains and URL segments that make up your site's URLs. After you add the necessary rules, you should see a useful breakdown of your information in the UI. Here are some useful tips: Adding segments to your allow list Tip Use constant URL segments. Only add the URL segments that remain constant across many page views. Do not add unique segments such as IDs or highly-specific categories, because this can lead to metric grouping issues. Enter exact matches. Enter any URL segments as exact matches, including case. Use existing rules. If a rule already appears for a domain: Go to one.newrelic.com > Browser > (select an app) > Settings > Segment allow lists. Rather than creating a new rule, edit the existing rule, and add the domain to the UI's Allow listed segments field. Group sub-domains. Group similar sub-domains such as foo.domain.com and bar.domain.com under *.domain.com. This grouping must occur just before the top-level domain name. Set up single-page apps. If your site is a single-page application and you only see / under page views, then your grouping is working correctly. New Relic records subsequent requests as AJAX loads, and your AJAX page will contain more detailed information. If it doesn't, then follow the tips in this document. Remove rules when appropriate. If you need to remove a rule, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.281,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Not seeing specific page or endpoint names in <em>Browser</em> data",
        "sections": "Not seeing specific page or endpoint names in <em>Browser</em> data",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "Problem You&#x27;re looking for performance breakdowns for specific pages or endpoints on the <em>browser</em> <em>monitoring</em> Page views UI page or AJAX UI page. The UI doesn&#x27;t show the URL group you&#x27;re looking for, or it only shows &#x2F; and &#x2F;*. This behavior also appears in SPA data in <em>Browser</em>Interaction events"
      },
      "id": "603e8fff28ccbc8813eba7a1"
    },
    {
      "sections": [
        "Install the browser monitoring agent",
        "Tip",
        "Select a deployment option",
        "Important",
        "Enable an APM-monitored app",
        "Enable with copy/paste",
        "Instrument webpages using the APM agent",
        "Troubleshoot Browser agent installation"
      ],
      "title": "Install the browser monitoring agent",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Installation"
      ],
      "external_id": "bc45bbc86cd4d8b81367ad0904907ddc735717f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/installation/install-browser-monitoring-agent/",
      "published_at": "2021-07-02T09:15:35Z",
      "updated_at": "2021-06-14T21:26:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser uses a JavaScript snippet (or \"agent\") to instrument your app's webpages. The JavaScript collects data for browser monitoring. To install the browser agent, you can choose from a number of deployment options. Tip To use Browser and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Select a deployment option No matter which option you use to deploy browser monitoring, the end result is to inject the browser agent's JavaScript snippet into your pages for browser monitoring. The method you select depends on your preferences and business needs. To view the procedure to install and enable the browser agent, click the link for the option you want to use. You can also use the Browser Application settings page to update settings. Important The following configuration options refer only to the browser monitoring agent. These are not the same as the New Relic user roles and editions. Browser deployment option Description Use the APM agent to inject the JavaScript You can use an APM agent to automatically inject the browser monitoring JavaScript snippet for you. This is the easiest way to install the agent for an app that already is being monitored by APM. (APM-monitored apps are listed on your APM Applications index.) Paste the JavaScript snippet into a webpage This allows you to control the exact placement of the JavaScript into your app's webpage(s) by copying and pasting the browser agent's JavaScript snippet. This is useful for: Standalone apps, static sites, and cached pages delivered by CDN APM apps that are not as closely coupled to the browser app as with a standard server-side app (for example, when your client-side app talks to a REST API back end) Enable single-page app (SPA) monitoring Enabling SPA requires a Pro + SPA browser agent subscription, and you may need to re-deploy the browser JavaScript agent. Use the REST API The REST API lets you manage deployment outside the browser UI. This is useful for large organizations deploying multiple apps. Use an APM agent API to manually instrument the JavaScript snippet For apps that are monitored by APM, you can use the APM agent's API to inject the JavaScript manually instead of automatically. Enable an APM-monitored app Use this procedure to automatically deploy the browser agent on an app that is monitored by APM: Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Enable via New Relic APM. In the Choose your instrumentation section, select Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Select your application section, type or use the search window to find an app's name. Click Enable. Important Node.js: To finish enabling the browser agent for a Node.js app, follow the additional procedure to insert the JavaScript header into the beginning of your HTML page's head tag. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. Enable with copy/paste Use this procedure to insert browser's JavaScript snippet for browser monitoring into your app's webpages yourself. This option is useful for monitoring static sites (such as Jekyll) or cached pages delivered by CDN. Tip Near the bottom of the generated JavaScript is your browser license key and application ID. This is useful with the REST API and API Explorer. Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Copy/Paste JavaScript Code. In the Choose your instrumentation section, select the type of agent: Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Name your app section, name your app: If your app is monitored by APM, select Yes, then type or use the search window to find the app's name. If you have a standalone app for Browser (not monitored by APM), select No, then type the app's name. Click Enable. A new section, Instrument the agent, opens on the page with JavaScript code for your project. Copy the code snippet, then paste it inline into your pages as close to the top of the <head> element as possible, but after any position-sensitive <meta> tags (for example, X-UA-Compatible or charset information). For more information on the inline head placement, see JavaScript placement requirements. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. If you use the copy/paste method, but don't finish the setup process, you can still view and copy the generated JavaScript snippet from your app's Browser Application settings page or by using the REST API (v2). Instrument webpages using the APM agent This information applies to apps that are also monitored by APM. New Relic's agents can instrument webpages with the required JavaScript for page load timing. If you use the APM agent to add the JavaScript snippet to your webpages, insert the instrumentation snippet as close to the top as possible. This allows you to take advantage of detailed information about browser's AJAX calls and JavaScript errors. For more information, see the instructions for your APM agent: C SDK Go Java .NET Node.js PHP Python Ruby Troubleshoot Browser agent installation When you enable browser Pro features for session traces, AJAX calls, or JavaScript errors, it may take approximately five minutes before information becomes available. If you have problems with your browser installation or if no data appears after five minutes, refer to the troubleshooting tips, and restart your agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.4049,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install the <em>browser</em> <em>monitoring</em> agent",
        "sections": "Install the <em>browser</em> <em>monitoring</em> agent",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " PHP Python Ruby <em>Troubleshoot</em> <em>Browser</em> agent installation When you enable <em>browser</em> Pro features for session traces, AJAX calls, or JavaScript errors, it may take approximately five minutes before information becomes available. If you have problems with your <em>browser</em> installation or if no data appears after five minutes, refer to the <em>troubleshooting</em> tips, and restart your agent."
      },
      "id": "604429e628ccbcb80b2c60d0"
    }
  ],
  "/docs/browser/new-relic-browser/troubleshooting/angularjs-errors-do-not-appear": [
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.33359,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "If you use <em>Browser</em> to <em>monitor</em> end-user <em>browser</em> activity, you can now see end-user-originating <em>browser</em>-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data"
      },
      "id": "6043fe6f196a6784f0960f53"
    },
    {
      "sections": [
        "Not seeing specific page or endpoint names in Browser data",
        "Problem",
        "Solution"
      ],
      "title": "Not seeing specific page or endpoint names in Browser data",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Troubleshooting"
      ],
      "external_id": "e91e38e0160cd95da45e928f462c70fde1457031",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/troubleshooting/not-seeing-specific-page-or-endpoint-names-browser-data/",
      "published_at": "2021-07-02T00:36:02Z",
      "updated_at": "2021-06-14T22:19:10Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You're looking for performance breakdowns for specific pages or endpoints on the browser monitoring Page views UI page or AJAX UI page. The UI doesn't show the URL group you're looking for, or it only shows / and /*. This behavior also appears in SPA data in BrowserInteraction events and applies to browserInteractionName, targetGroupedUrl, and previousGroupedUrl attributes. Solution Browser monitoring automatically \"learns\" to group your page views when your application is first deployed, and it adds that information to an allow list for URLs. Sometimes this grouping may not match your current page view information. To solve this problem, manage your application's URL segment list settings by editing existing rules or by adding the domains and URL segments that make up your site's URLs. After you add the necessary rules, you should see a useful breakdown of your information in the UI. Here are some useful tips: Adding segments to your allow list Tip Use constant URL segments. Only add the URL segments that remain constant across many page views. Do not add unique segments such as IDs or highly-specific categories, because this can lead to metric grouping issues. Enter exact matches. Enter any URL segments as exact matches, including case. Use existing rules. If a rule already appears for a domain: Go to one.newrelic.com > Browser > (select an app) > Settings > Segment allow lists. Rather than creating a new rule, edit the existing rule, and add the domain to the UI's Allow listed segments field. Group sub-domains. Group similar sub-domains such as foo.domain.com and bar.domain.com under *.domain.com. This grouping must occur just before the top-level domain name. Set up single-page apps. If your site is a single-page application and you only see / under page views, then your grouping is working correctly. New Relic records subsequent requests as AJAX loads, and your AJAX page will contain more detailed information. If it doesn't, then follow the tips in this document. Remove rules when appropriate. If you need to remove a rule, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.28099,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Not seeing specific page or endpoint names in <em>Browser</em> data",
        "sections": "Not seeing specific page or endpoint names in <em>Browser</em> data",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "Problem You&#x27;re looking for performance breakdowns for specific pages or endpoints on the <em>browser</em> <em>monitoring</em> Page views UI page or AJAX UI page. The UI doesn&#x27;t show the URL group you&#x27;re looking for, or it only shows &#x2F; and &#x2F;*. This behavior also appears in SPA data in <em>Browser</em>Interaction events"
      },
      "id": "603e8fff28ccbc8813eba7a1"
    },
    {
      "sections": [
        "Install the browser monitoring agent",
        "Tip",
        "Select a deployment option",
        "Important",
        "Enable an APM-monitored app",
        "Enable with copy/paste",
        "Instrument webpages using the APM agent",
        "Troubleshoot Browser agent installation"
      ],
      "title": "Install the browser monitoring agent",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Installation"
      ],
      "external_id": "bc45bbc86cd4d8b81367ad0904907ddc735717f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/installation/install-browser-monitoring-agent/",
      "published_at": "2021-07-02T09:15:35Z",
      "updated_at": "2021-06-14T21:26:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser uses a JavaScript snippet (or \"agent\") to instrument your app's webpages. The JavaScript collects data for browser monitoring. To install the browser agent, you can choose from a number of deployment options. Tip To use Browser and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Select a deployment option No matter which option you use to deploy browser monitoring, the end result is to inject the browser agent's JavaScript snippet into your pages for browser monitoring. The method you select depends on your preferences and business needs. To view the procedure to install and enable the browser agent, click the link for the option you want to use. You can also use the Browser Application settings page to update settings. Important The following configuration options refer only to the browser monitoring agent. These are not the same as the New Relic user roles and editions. Browser deployment option Description Use the APM agent to inject the JavaScript You can use an APM agent to automatically inject the browser monitoring JavaScript snippet for you. This is the easiest way to install the agent for an app that already is being monitored by APM. (APM-monitored apps are listed on your APM Applications index.) Paste the JavaScript snippet into a webpage This allows you to control the exact placement of the JavaScript into your app's webpage(s) by copying and pasting the browser agent's JavaScript snippet. This is useful for: Standalone apps, static sites, and cached pages delivered by CDN APM apps that are not as closely coupled to the browser app as with a standard server-side app (for example, when your client-side app talks to a REST API back end) Enable single-page app (SPA) monitoring Enabling SPA requires a Pro + SPA browser agent subscription, and you may need to re-deploy the browser JavaScript agent. Use the REST API The REST API lets you manage deployment outside the browser UI. This is useful for large organizations deploying multiple apps. Use an APM agent API to manually instrument the JavaScript snippet For apps that are monitored by APM, you can use the APM agent's API to inject the JavaScript manually instead of automatically. Enable an APM-monitored app Use this procedure to automatically deploy the browser agent on an app that is monitored by APM: Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Enable via New Relic APM. In the Choose your instrumentation section, select Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Select your application section, type or use the search window to find an app's name. Click Enable. Important Node.js: To finish enabling the browser agent for a Node.js app, follow the additional procedure to insert the JavaScript header into the beginning of your HTML page's head tag. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. Enable with copy/paste Use this procedure to insert browser's JavaScript snippet for browser monitoring into your app's webpages yourself. This option is useful for monitoring static sites (such as Jekyll) or cached pages delivered by CDN. Tip Near the bottom of the generated JavaScript is your browser license key and application ID. This is useful with the REST API and API Explorer. Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Copy/Paste JavaScript Code. In the Choose your instrumentation section, select the type of agent: Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Name your app section, name your app: If your app is monitored by APM, select Yes, then type or use the search window to find the app's name. If you have a standalone app for Browser (not monitored by APM), select No, then type the app's name. Click Enable. A new section, Instrument the agent, opens on the page with JavaScript code for your project. Copy the code snippet, then paste it inline into your pages as close to the top of the <head> element as possible, but after any position-sensitive <meta> tags (for example, X-UA-Compatible or charset information). For more information on the inline head placement, see JavaScript placement requirements. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. If you use the copy/paste method, but don't finish the setup process, you can still view and copy the generated JavaScript snippet from your app's Browser Application settings page or by using the REST API (v2). Instrument webpages using the APM agent This information applies to apps that are also monitored by APM. New Relic's agents can instrument webpages with the required JavaScript for page load timing. If you use the APM agent to add the JavaScript snippet to your webpages, insert the instrumentation snippet as close to the top as possible. This allows you to take advantage of detailed information about browser's AJAX calls and JavaScript errors. For more information, see the instructions for your APM agent: C SDK Go Java .NET Node.js PHP Python Ruby Troubleshoot Browser agent installation When you enable browser Pro features for session traces, AJAX calls, or JavaScript errors, it may take approximately five minutes before information becomes available. If you have problems with your browser installation or if no data appears after five minutes, refer to the troubleshooting tips, and restart your agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.40489,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install the <em>browser</em> <em>monitoring</em> agent",
        "sections": "Install the <em>browser</em> <em>monitoring</em> agent",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " PHP Python Ruby <em>Troubleshoot</em> <em>Browser</em> agent installation When you enable <em>browser</em> Pro features for session traces, AJAX calls, or JavaScript errors, it may take approximately five minutes before information becomes available. If you have problems with your <em>browser</em> installation or if no data appears after five minutes, refer to the <em>troubleshooting</em> tips, and restart your agent."
      },
      "id": "604429e628ccbcb80b2c60d0"
    }
  ],
  "/docs/browser/new-relic-browser/troubleshooting/app-server-requests-greatly-outnumber-browser-pageview-transactions": [
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.33359,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "If you use <em>Browser</em> to <em>monitor</em> end-user <em>browser</em> activity, you can now see end-user-originating <em>browser</em>-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data"
      },
      "id": "6043fe6f196a6784f0960f53"
    },
    {
      "sections": [
        "Not seeing specific page or endpoint names in Browser data",
        "Problem",
        "Solution"
      ],
      "title": "Not seeing specific page or endpoint names in Browser data",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Troubleshooting"
      ],
      "external_id": "e91e38e0160cd95da45e928f462c70fde1457031",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/troubleshooting/not-seeing-specific-page-or-endpoint-names-browser-data/",
      "published_at": "2021-07-02T00:36:02Z",
      "updated_at": "2021-06-14T22:19:10Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You're looking for performance breakdowns for specific pages or endpoints on the browser monitoring Page views UI page or AJAX UI page. The UI doesn't show the URL group you're looking for, or it only shows / and /*. This behavior also appears in SPA data in BrowserInteraction events and applies to browserInteractionName, targetGroupedUrl, and previousGroupedUrl attributes. Solution Browser monitoring automatically \"learns\" to group your page views when your application is first deployed, and it adds that information to an allow list for URLs. Sometimes this grouping may not match your current page view information. To solve this problem, manage your application's URL segment list settings by editing existing rules or by adding the domains and URL segments that make up your site's URLs. After you add the necessary rules, you should see a useful breakdown of your information in the UI. Here are some useful tips: Adding segments to your allow list Tip Use constant URL segments. Only add the URL segments that remain constant across many page views. Do not add unique segments such as IDs or highly-specific categories, because this can lead to metric grouping issues. Enter exact matches. Enter any URL segments as exact matches, including case. Use existing rules. If a rule already appears for a domain: Go to one.newrelic.com > Browser > (select an app) > Settings > Segment allow lists. Rather than creating a new rule, edit the existing rule, and add the domain to the UI's Allow listed segments field. Group sub-domains. Group similar sub-domains such as foo.domain.com and bar.domain.com under *.domain.com. This grouping must occur just before the top-level domain name. Set up single-page apps. If your site is a single-page application and you only see / under page views, then your grouping is working correctly. New Relic records subsequent requests as AJAX loads, and your AJAX page will contain more detailed information. If it doesn't, then follow the tips in this document. Remove rules when appropriate. If you need to remove a rule, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.28099,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Not seeing specific page or endpoint names in <em>Browser</em> data",
        "sections": "Not seeing specific page or endpoint names in <em>Browser</em> data",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "Problem You&#x27;re looking for performance breakdowns for specific pages or endpoints on the <em>browser</em> <em>monitoring</em> Page views UI page or AJAX UI page. The UI doesn&#x27;t show the URL group you&#x27;re looking for, or it only shows &#x2F; and &#x2F;*. This behavior also appears in SPA data in <em>Browser</em>Interaction events"
      },
      "id": "603e8fff28ccbc8813eba7a1"
    },
    {
      "sections": [
        "Install the browser monitoring agent",
        "Tip",
        "Select a deployment option",
        "Important",
        "Enable an APM-monitored app",
        "Enable with copy/paste",
        "Instrument webpages using the APM agent",
        "Troubleshoot Browser agent installation"
      ],
      "title": "Install the browser monitoring agent",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Installation"
      ],
      "external_id": "bc45bbc86cd4d8b81367ad0904907ddc735717f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/installation/install-browser-monitoring-agent/",
      "published_at": "2021-07-02T09:15:35Z",
      "updated_at": "2021-06-14T21:26:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser uses a JavaScript snippet (or \"agent\") to instrument your app's webpages. The JavaScript collects data for browser monitoring. To install the browser agent, you can choose from a number of deployment options. Tip To use Browser and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Select a deployment option No matter which option you use to deploy browser monitoring, the end result is to inject the browser agent's JavaScript snippet into your pages for browser monitoring. The method you select depends on your preferences and business needs. To view the procedure to install and enable the browser agent, click the link for the option you want to use. You can also use the Browser Application settings page to update settings. Important The following configuration options refer only to the browser monitoring agent. These are not the same as the New Relic user roles and editions. Browser deployment option Description Use the APM agent to inject the JavaScript You can use an APM agent to automatically inject the browser monitoring JavaScript snippet for you. This is the easiest way to install the agent for an app that already is being monitored by APM. (APM-monitored apps are listed on your APM Applications index.) Paste the JavaScript snippet into a webpage This allows you to control the exact placement of the JavaScript into your app's webpage(s) by copying and pasting the browser agent's JavaScript snippet. This is useful for: Standalone apps, static sites, and cached pages delivered by CDN APM apps that are not as closely coupled to the browser app as with a standard server-side app (for example, when your client-side app talks to a REST API back end) Enable single-page app (SPA) monitoring Enabling SPA requires a Pro + SPA browser agent subscription, and you may need to re-deploy the browser JavaScript agent. Use the REST API The REST API lets you manage deployment outside the browser UI. This is useful for large organizations deploying multiple apps. Use an APM agent API to manually instrument the JavaScript snippet For apps that are monitored by APM, you can use the APM agent's API to inject the JavaScript manually instead of automatically. Enable an APM-monitored app Use this procedure to automatically deploy the browser agent on an app that is monitored by APM: Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Enable via New Relic APM. In the Choose your instrumentation section, select Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Select your application section, type or use the search window to find an app's name. Click Enable. Important Node.js: To finish enabling the browser agent for a Node.js app, follow the additional procedure to insert the JavaScript header into the beginning of your HTML page's head tag. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. Enable with copy/paste Use this procedure to insert browser's JavaScript snippet for browser monitoring into your app's webpages yourself. This option is useful for monitoring static sites (such as Jekyll) or cached pages delivered by CDN. Tip Near the bottom of the generated JavaScript is your browser license key and application ID. This is useful with the REST API and API Explorer. Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Copy/Paste JavaScript Code. In the Choose your instrumentation section, select the type of agent: Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Name your app section, name your app: If your app is monitored by APM, select Yes, then type or use the search window to find the app's name. If you have a standalone app for Browser (not monitored by APM), select No, then type the app's name. Click Enable. A new section, Instrument the agent, opens on the page with JavaScript code for your project. Copy the code snippet, then paste it inline into your pages as close to the top of the <head> element as possible, but after any position-sensitive <meta> tags (for example, X-UA-Compatible or charset information). For more information on the inline head placement, see JavaScript placement requirements. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. If you use the copy/paste method, but don't finish the setup process, you can still view and copy the generated JavaScript snippet from your app's Browser Application settings page or by using the REST API (v2). Instrument webpages using the APM agent This information applies to apps that are also monitored by APM. New Relic's agents can instrument webpages with the required JavaScript for page load timing. If you use the APM agent to add the JavaScript snippet to your webpages, insert the instrumentation snippet as close to the top as possible. This allows you to take advantage of detailed information about browser's AJAX calls and JavaScript errors. For more information, see the instructions for your APM agent: C SDK Go Java .NET Node.js PHP Python Ruby Troubleshoot Browser agent installation When you enable browser Pro features for session traces, AJAX calls, or JavaScript errors, it may take approximately five minutes before information becomes available. If you have problems with your browser installation or if no data appears after five minutes, refer to the troubleshooting tips, and restart your agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.40489,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install the <em>browser</em> <em>monitoring</em> agent",
        "sections": "Install the <em>browser</em> <em>monitoring</em> agent",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " PHP Python Ruby <em>Troubleshoot</em> <em>Browser</em> agent installation When you enable <em>browser</em> Pro features for session traces, AJAX calls, or JavaScript errors, it may take approximately five minutes before information becomes available. If you have problems with your <em>browser</em> installation or if no data appears after five minutes, refer to the <em>troubleshooting</em> tips, and restart your agent."
      },
      "id": "604429e628ccbcb80b2c60d0"
    }
  ],
  "/docs/browser/new-relic-browser/troubleshooting/browser-data-doesnt-match-other-analytics-tools": [
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.33359,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "If you use <em>Browser</em> to <em>monitor</em> end-user <em>browser</em> activity, you can now see end-user-originating <em>browser</em>-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data"
      },
      "id": "6043fe6f196a6784f0960f53"
    },
    {
      "sections": [
        "Not seeing specific page or endpoint names in Browser data",
        "Problem",
        "Solution"
      ],
      "title": "Not seeing specific page or endpoint names in Browser data",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Troubleshooting"
      ],
      "external_id": "e91e38e0160cd95da45e928f462c70fde1457031",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/troubleshooting/not-seeing-specific-page-or-endpoint-names-browser-data/",
      "published_at": "2021-07-02T00:36:02Z",
      "updated_at": "2021-06-14T22:19:10Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You're looking for performance breakdowns for specific pages or endpoints on the browser monitoring Page views UI page or AJAX UI page. The UI doesn't show the URL group you're looking for, or it only shows / and /*. This behavior also appears in SPA data in BrowserInteraction events and applies to browserInteractionName, targetGroupedUrl, and previousGroupedUrl attributes. Solution Browser monitoring automatically \"learns\" to group your page views when your application is first deployed, and it adds that information to an allow list for URLs. Sometimes this grouping may not match your current page view information. To solve this problem, manage your application's URL segment list settings by editing existing rules or by adding the domains and URL segments that make up your site's URLs. After you add the necessary rules, you should see a useful breakdown of your information in the UI. Here are some useful tips: Adding segments to your allow list Tip Use constant URL segments. Only add the URL segments that remain constant across many page views. Do not add unique segments such as IDs or highly-specific categories, because this can lead to metric grouping issues. Enter exact matches. Enter any URL segments as exact matches, including case. Use existing rules. If a rule already appears for a domain: Go to one.newrelic.com > Browser > (select an app) > Settings > Segment allow lists. Rather than creating a new rule, edit the existing rule, and add the domain to the UI's Allow listed segments field. Group sub-domains. Group similar sub-domains such as foo.domain.com and bar.domain.com under *.domain.com. This grouping must occur just before the top-level domain name. Set up single-page apps. If your site is a single-page application and you only see / under page views, then your grouping is working correctly. New Relic records subsequent requests as AJAX loads, and your AJAX page will contain more detailed information. If it doesn't, then follow the tips in this document. Remove rules when appropriate. If you need to remove a rule, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.28099,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Not seeing specific page or endpoint names in <em>Browser</em> data",
        "sections": "Not seeing specific page or endpoint names in <em>Browser</em> data",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "Problem You&#x27;re looking for performance breakdowns for specific pages or endpoints on the <em>browser</em> <em>monitoring</em> Page views UI page or AJAX UI page. The UI doesn&#x27;t show the URL group you&#x27;re looking for, or it only shows &#x2F; and &#x2F;*. This behavior also appears in SPA data in <em>Browser</em>Interaction events"
      },
      "id": "603e8fff28ccbc8813eba7a1"
    },
    {
      "sections": [
        "Install the browser monitoring agent",
        "Tip",
        "Select a deployment option",
        "Important",
        "Enable an APM-monitored app",
        "Enable with copy/paste",
        "Instrument webpages using the APM agent",
        "Troubleshoot Browser agent installation"
      ],
      "title": "Install the browser monitoring agent",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Installation"
      ],
      "external_id": "bc45bbc86cd4d8b81367ad0904907ddc735717f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/installation/install-browser-monitoring-agent/",
      "published_at": "2021-07-02T09:15:35Z",
      "updated_at": "2021-06-14T21:26:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser uses a JavaScript snippet (or \"agent\") to instrument your app's webpages. The JavaScript collects data for browser monitoring. To install the browser agent, you can choose from a number of deployment options. Tip To use Browser and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Select a deployment option No matter which option you use to deploy browser monitoring, the end result is to inject the browser agent's JavaScript snippet into your pages for browser monitoring. The method you select depends on your preferences and business needs. To view the procedure to install and enable the browser agent, click the link for the option you want to use. You can also use the Browser Application settings page to update settings. Important The following configuration options refer only to the browser monitoring agent. These are not the same as the New Relic user roles and editions. Browser deployment option Description Use the APM agent to inject the JavaScript You can use an APM agent to automatically inject the browser monitoring JavaScript snippet for you. This is the easiest way to install the agent for an app that already is being monitored by APM. (APM-monitored apps are listed on your APM Applications index.) Paste the JavaScript snippet into a webpage This allows you to control the exact placement of the JavaScript into your app's webpage(s) by copying and pasting the browser agent's JavaScript snippet. This is useful for: Standalone apps, static sites, and cached pages delivered by CDN APM apps that are not as closely coupled to the browser app as with a standard server-side app (for example, when your client-side app talks to a REST API back end) Enable single-page app (SPA) monitoring Enabling SPA requires a Pro + SPA browser agent subscription, and you may need to re-deploy the browser JavaScript agent. Use the REST API The REST API lets you manage deployment outside the browser UI. This is useful for large organizations deploying multiple apps. Use an APM agent API to manually instrument the JavaScript snippet For apps that are monitored by APM, you can use the APM agent's API to inject the JavaScript manually instead of automatically. Enable an APM-monitored app Use this procedure to automatically deploy the browser agent on an app that is monitored by APM: Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Enable via New Relic APM. In the Choose your instrumentation section, select Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Select your application section, type or use the search window to find an app's name. Click Enable. Important Node.js: To finish enabling the browser agent for a Node.js app, follow the additional procedure to insert the JavaScript header into the beginning of your HTML page's head tag. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. Enable with copy/paste Use this procedure to insert browser's JavaScript snippet for browser monitoring into your app's webpages yourself. This option is useful for monitoring static sites (such as Jekyll) or cached pages delivered by CDN. Tip Near the bottom of the generated JavaScript is your browser license key and application ID. This is useful with the REST API and API Explorer. Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Copy/Paste JavaScript Code. In the Choose your instrumentation section, select the type of agent: Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Name your app section, name your app: If your app is monitored by APM, select Yes, then type or use the search window to find the app's name. If you have a standalone app for Browser (not monitored by APM), select No, then type the app's name. Click Enable. A new section, Instrument the agent, opens on the page with JavaScript code for your project. Copy the code snippet, then paste it inline into your pages as close to the top of the <head> element as possible, but after any position-sensitive <meta> tags (for example, X-UA-Compatible or charset information). For more information on the inline head placement, see JavaScript placement requirements. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. If you use the copy/paste method, but don't finish the setup process, you can still view and copy the generated JavaScript snippet from your app's Browser Application settings page or by using the REST API (v2). Instrument webpages using the APM agent This information applies to apps that are also monitored by APM. New Relic's agents can instrument webpages with the required JavaScript for page load timing. If you use the APM agent to add the JavaScript snippet to your webpages, insert the instrumentation snippet as close to the top as possible. This allows you to take advantage of detailed information about browser's AJAX calls and JavaScript errors. For more information, see the instructions for your APM agent: C SDK Go Java .NET Node.js PHP Python Ruby Troubleshoot Browser agent installation When you enable browser Pro features for session traces, AJAX calls, or JavaScript errors, it may take approximately five minutes before information becomes available. If you have problems with your browser installation or if no data appears after five minutes, refer to the troubleshooting tips, and restart your agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.40489,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install the <em>browser</em> <em>monitoring</em> agent",
        "sections": "Install the <em>browser</em> <em>monitoring</em> agent",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " PHP Python Ruby <em>Troubleshoot</em> <em>Browser</em> agent installation When you enable <em>browser</em> Pro features for session traces, AJAX calls, or JavaScript errors, it may take approximately five minutes before information becomes available. If you have problems with your <em>browser</em> installation or if no data appears after five minutes, refer to the <em>troubleshooting</em> tips, and restart your agent."
      },
      "id": "604429e628ccbcb80b2c60d0"
    }
  ],
  "/docs/browser/new-relic-browser/troubleshooting/browser-javascript-injection-causes-problems-page": [
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.33348,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "If you use <em>Browser</em> to <em>monitor</em> end-user <em>browser</em> activity, you can now see end-user-originating <em>browser</em>-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data"
      },
      "id": "6043fe6f196a6784f0960f53"
    },
    {
      "sections": [
        "Not seeing specific page or endpoint names in Browser data",
        "Problem",
        "Solution"
      ],
      "title": "Not seeing specific page or endpoint names in Browser data",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Troubleshooting"
      ],
      "external_id": "e91e38e0160cd95da45e928f462c70fde1457031",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/troubleshooting/not-seeing-specific-page-or-endpoint-names-browser-data/",
      "published_at": "2021-07-02T00:36:02Z",
      "updated_at": "2021-06-14T22:19:10Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You're looking for performance breakdowns for specific pages or endpoints on the browser monitoring Page views UI page or AJAX UI page. The UI doesn't show the URL group you're looking for, or it only shows / and /*. This behavior also appears in SPA data in BrowserInteraction events and applies to browserInteractionName, targetGroupedUrl, and previousGroupedUrl attributes. Solution Browser monitoring automatically \"learns\" to group your page views when your application is first deployed, and it adds that information to an allow list for URLs. Sometimes this grouping may not match your current page view information. To solve this problem, manage your application's URL segment list settings by editing existing rules or by adding the domains and URL segments that make up your site's URLs. After you add the necessary rules, you should see a useful breakdown of your information in the UI. Here are some useful tips: Adding segments to your allow list Tip Use constant URL segments. Only add the URL segments that remain constant across many page views. Do not add unique segments such as IDs or highly-specific categories, because this can lead to metric grouping issues. Enter exact matches. Enter any URL segments as exact matches, including case. Use existing rules. If a rule already appears for a domain: Go to one.newrelic.com > Browser > (select an app) > Settings > Segment allow lists. Rather than creating a new rule, edit the existing rule, and add the domain to the UI's Allow listed segments field. Group sub-domains. Group similar sub-domains such as foo.domain.com and bar.domain.com under *.domain.com. This grouping must occur just before the top-level domain name. Set up single-page apps. If your site is a single-page application and you only see / under page views, then your grouping is working correctly. New Relic records subsequent requests as AJAX loads, and your AJAX page will contain more detailed information. If it doesn't, then follow the tips in this document. Remove rules when appropriate. If you need to remove a rule, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.28098,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Not seeing specific page or endpoint names in <em>Browser</em> data",
        "sections": "Not seeing specific page or endpoint names in <em>Browser</em> data",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "Problem You&#x27;re looking for performance breakdowns for specific pages or endpoints on the <em>browser</em> <em>monitoring</em> Page views UI page or AJAX UI page. The UI doesn&#x27;t show the URL group you&#x27;re looking for, or it only shows &#x2F; and &#x2F;*. This behavior also appears in SPA data in <em>Browser</em>Interaction events"
      },
      "id": "603e8fff28ccbc8813eba7a1"
    },
    {
      "sections": [
        "Install the browser monitoring agent",
        "Tip",
        "Select a deployment option",
        "Important",
        "Enable an APM-monitored app",
        "Enable with copy/paste",
        "Instrument webpages using the APM agent",
        "Troubleshoot Browser agent installation"
      ],
      "title": "Install the browser monitoring agent",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Installation"
      ],
      "external_id": "bc45bbc86cd4d8b81367ad0904907ddc735717f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/installation/install-browser-monitoring-agent/",
      "published_at": "2021-07-02T09:15:35Z",
      "updated_at": "2021-06-14T21:26:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser uses a JavaScript snippet (or \"agent\") to instrument your app's webpages. The JavaScript collects data for browser monitoring. To install the browser agent, you can choose from a number of deployment options. Tip To use Browser and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Select a deployment option No matter which option you use to deploy browser monitoring, the end result is to inject the browser agent's JavaScript snippet into your pages for browser monitoring. The method you select depends on your preferences and business needs. To view the procedure to install and enable the browser agent, click the link for the option you want to use. You can also use the Browser Application settings page to update settings. Important The following configuration options refer only to the browser monitoring agent. These are not the same as the New Relic user roles and editions. Browser deployment option Description Use the APM agent to inject the JavaScript You can use an APM agent to automatically inject the browser monitoring JavaScript snippet for you. This is the easiest way to install the agent for an app that already is being monitored by APM. (APM-monitored apps are listed on your APM Applications index.) Paste the JavaScript snippet into a webpage This allows you to control the exact placement of the JavaScript into your app's webpage(s) by copying and pasting the browser agent's JavaScript snippet. This is useful for: Standalone apps, static sites, and cached pages delivered by CDN APM apps that are not as closely coupled to the browser app as with a standard server-side app (for example, when your client-side app talks to a REST API back end) Enable single-page app (SPA) monitoring Enabling SPA requires a Pro + SPA browser agent subscription, and you may need to re-deploy the browser JavaScript agent. Use the REST API The REST API lets you manage deployment outside the browser UI. This is useful for large organizations deploying multiple apps. Use an APM agent API to manually instrument the JavaScript snippet For apps that are monitored by APM, you can use the APM agent's API to inject the JavaScript manually instead of automatically. Enable an APM-monitored app Use this procedure to automatically deploy the browser agent on an app that is monitored by APM: Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Enable via New Relic APM. In the Choose your instrumentation section, select Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Select your application section, type or use the search window to find an app's name. Click Enable. Important Node.js: To finish enabling the browser agent for a Node.js app, follow the additional procedure to insert the JavaScript header into the beginning of your HTML page's head tag. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. Enable with copy/paste Use this procedure to insert browser's JavaScript snippet for browser monitoring into your app's webpages yourself. This option is useful for monitoring static sites (such as Jekyll) or cached pages delivered by CDN. Tip Near the bottom of the generated JavaScript is your browser license key and application ID. This is useful with the REST API and API Explorer. Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Copy/Paste JavaScript Code. In the Choose your instrumentation section, select the type of agent: Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Name your app section, name your app: If your app is monitored by APM, select Yes, then type or use the search window to find the app's name. If you have a standalone app for Browser (not monitored by APM), select No, then type the app's name. Click Enable. A new section, Instrument the agent, opens on the page with JavaScript code for your project. Copy the code snippet, then paste it inline into your pages as close to the top of the <head> element as possible, but after any position-sensitive <meta> tags (for example, X-UA-Compatible or charset information). For more information on the inline head placement, see JavaScript placement requirements. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. If you use the copy/paste method, but don't finish the setup process, you can still view and copy the generated JavaScript snippet from your app's Browser Application settings page or by using the REST API (v2). Instrument webpages using the APM agent This information applies to apps that are also monitored by APM. New Relic's agents can instrument webpages with the required JavaScript for page load timing. If you use the APM agent to add the JavaScript snippet to your webpages, insert the instrumentation snippet as close to the top as possible. This allows you to take advantage of detailed information about browser's AJAX calls and JavaScript errors. For more information, see the instructions for your APM agent: C SDK Go Java .NET Node.js PHP Python Ruby Troubleshoot Browser agent installation When you enable browser Pro features for session traces, AJAX calls, or JavaScript errors, it may take approximately five minutes before information becomes available. If you have problems with your browser installation or if no data appears after five minutes, refer to the troubleshooting tips, and restart your agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.40488,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install the <em>browser</em> <em>monitoring</em> agent",
        "sections": "Install the <em>browser</em> <em>monitoring</em> agent",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " PHP Python Ruby <em>Troubleshoot</em> <em>Browser</em> agent installation When you enable <em>browser</em> Pro features for session traces, AJAX calls, or JavaScript errors, it may take approximately five minutes before information becomes available. If you have problems with your <em>browser</em> installation or if no data appears after five minutes, refer to the <em>troubleshooting</em> tips, and restart your agent."
      },
      "id": "604429e628ccbcb80b2c60d0"
    }
  ],
  "/docs/browser/new-relic-browser/troubleshooting/get-browser-side-troubleshooting-details-har-file": [
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.33348,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "If you use <em>Browser</em> to <em>monitor</em> end-user <em>browser</em> activity, you can now see end-user-originating <em>browser</em>-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data"
      },
      "id": "6043fe6f196a6784f0960f53"
    },
    {
      "sections": [
        "Not seeing specific page or endpoint names in Browser data",
        "Problem",
        "Solution"
      ],
      "title": "Not seeing specific page or endpoint names in Browser data",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Troubleshooting"
      ],
      "external_id": "e91e38e0160cd95da45e928f462c70fde1457031",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/troubleshooting/not-seeing-specific-page-or-endpoint-names-browser-data/",
      "published_at": "2021-07-02T00:36:02Z",
      "updated_at": "2021-06-14T22:19:10Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You're looking for performance breakdowns for specific pages or endpoints on the browser monitoring Page views UI page or AJAX UI page. The UI doesn't show the URL group you're looking for, or it only shows / and /*. This behavior also appears in SPA data in BrowserInteraction events and applies to browserInteractionName, targetGroupedUrl, and previousGroupedUrl attributes. Solution Browser monitoring automatically \"learns\" to group your page views when your application is first deployed, and it adds that information to an allow list for URLs. Sometimes this grouping may not match your current page view information. To solve this problem, manage your application's URL segment list settings by editing existing rules or by adding the domains and URL segments that make up your site's URLs. After you add the necessary rules, you should see a useful breakdown of your information in the UI. Here are some useful tips: Adding segments to your allow list Tip Use constant URL segments. Only add the URL segments that remain constant across many page views. Do not add unique segments such as IDs or highly-specific categories, because this can lead to metric grouping issues. Enter exact matches. Enter any URL segments as exact matches, including case. Use existing rules. If a rule already appears for a domain: Go to one.newrelic.com > Browser > (select an app) > Settings > Segment allow lists. Rather than creating a new rule, edit the existing rule, and add the domain to the UI's Allow listed segments field. Group sub-domains. Group similar sub-domains such as foo.domain.com and bar.domain.com under *.domain.com. This grouping must occur just before the top-level domain name. Set up single-page apps. If your site is a single-page application and you only see / under page views, then your grouping is working correctly. New Relic records subsequent requests as AJAX loads, and your AJAX page will contain more detailed information. If it doesn't, then follow the tips in this document. Remove rules when appropriate. If you need to remove a rule, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.28098,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Not seeing specific page or endpoint names in <em>Browser</em> data",
        "sections": "Not seeing specific page or endpoint names in <em>Browser</em> data",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "Problem You&#x27;re looking for performance breakdowns for specific pages or endpoints on the <em>browser</em> <em>monitoring</em> Page views UI page or AJAX UI page. The UI doesn&#x27;t show the URL group you&#x27;re looking for, or it only shows &#x2F; and &#x2F;*. This behavior also appears in SPA data in <em>Browser</em>Interaction events"
      },
      "id": "603e8fff28ccbc8813eba7a1"
    },
    {
      "sections": [
        "Install the browser monitoring agent",
        "Tip",
        "Select a deployment option",
        "Important",
        "Enable an APM-monitored app",
        "Enable with copy/paste",
        "Instrument webpages using the APM agent",
        "Troubleshoot Browser agent installation"
      ],
      "title": "Install the browser monitoring agent",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Installation"
      ],
      "external_id": "bc45bbc86cd4d8b81367ad0904907ddc735717f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/installation/install-browser-monitoring-agent/",
      "published_at": "2021-07-02T09:15:35Z",
      "updated_at": "2021-06-14T21:26:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser uses a JavaScript snippet (or \"agent\") to instrument your app's webpages. The JavaScript collects data for browser monitoring. To install the browser agent, you can choose from a number of deployment options. Tip To use Browser and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Select a deployment option No matter which option you use to deploy browser monitoring, the end result is to inject the browser agent's JavaScript snippet into your pages for browser monitoring. The method you select depends on your preferences and business needs. To view the procedure to install and enable the browser agent, click the link for the option you want to use. You can also use the Browser Application settings page to update settings. Important The following configuration options refer only to the browser monitoring agent. These are not the same as the New Relic user roles and editions. Browser deployment option Description Use the APM agent to inject the JavaScript You can use an APM agent to automatically inject the browser monitoring JavaScript snippet for you. This is the easiest way to install the agent for an app that already is being monitored by APM. (APM-monitored apps are listed on your APM Applications index.) Paste the JavaScript snippet into a webpage This allows you to control the exact placement of the JavaScript into your app's webpage(s) by copying and pasting the browser agent's JavaScript snippet. This is useful for: Standalone apps, static sites, and cached pages delivered by CDN APM apps that are not as closely coupled to the browser app as with a standard server-side app (for example, when your client-side app talks to a REST API back end) Enable single-page app (SPA) monitoring Enabling SPA requires a Pro + SPA browser agent subscription, and you may need to re-deploy the browser JavaScript agent. Use the REST API The REST API lets you manage deployment outside the browser UI. This is useful for large organizations deploying multiple apps. Use an APM agent API to manually instrument the JavaScript snippet For apps that are monitored by APM, you can use the APM agent's API to inject the JavaScript manually instead of automatically. Enable an APM-monitored app Use this procedure to automatically deploy the browser agent on an app that is monitored by APM: Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Enable via New Relic APM. In the Choose your instrumentation section, select Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Select your application section, type or use the search window to find an app's name. Click Enable. Important Node.js: To finish enabling the browser agent for a Node.js app, follow the additional procedure to insert the JavaScript header into the beginning of your HTML page's head tag. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. Enable with copy/paste Use this procedure to insert browser's JavaScript snippet for browser monitoring into your app's webpages yourself. This option is useful for monitoring static sites (such as Jekyll) or cached pages delivered by CDN. Tip Near the bottom of the generated JavaScript is your browser license key and application ID. This is useful with the REST API and API Explorer. Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Copy/Paste JavaScript Code. In the Choose your instrumentation section, select the type of agent: Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Name your app section, name your app: If your app is monitored by APM, select Yes, then type or use the search window to find the app's name. If you have a standalone app for Browser (not monitored by APM), select No, then type the app's name. Click Enable. A new section, Instrument the agent, opens on the page with JavaScript code for your project. Copy the code snippet, then paste it inline into your pages as close to the top of the <head> element as possible, but after any position-sensitive <meta> tags (for example, X-UA-Compatible or charset information). For more information on the inline head placement, see JavaScript placement requirements. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. If you use the copy/paste method, but don't finish the setup process, you can still view and copy the generated JavaScript snippet from your app's Browser Application settings page or by using the REST API (v2). Instrument webpages using the APM agent This information applies to apps that are also monitored by APM. New Relic's agents can instrument webpages with the required JavaScript for page load timing. If you use the APM agent to add the JavaScript snippet to your webpages, insert the instrumentation snippet as close to the top as possible. This allows you to take advantage of detailed information about browser's AJAX calls and JavaScript errors. For more information, see the instructions for your APM agent: C SDK Go Java .NET Node.js PHP Python Ruby Troubleshoot Browser agent installation When you enable browser Pro features for session traces, AJAX calls, or JavaScript errors, it may take approximately five minutes before information becomes available. If you have problems with your browser installation or if no data appears after five minutes, refer to the troubleshooting tips, and restart your agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.40488,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install the <em>browser</em> <em>monitoring</em> agent",
        "sections": "Install the <em>browser</em> <em>monitoring</em> agent",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " PHP Python Ruby <em>Troubleshoot</em> <em>Browser</em> agent installation When you enable <em>browser</em> Pro features for session traces, AJAX calls, or JavaScript errors, it may take approximately five minutes before information becomes available. If you have problems with your <em>browser</em> installation or if no data appears after five minutes, refer to the <em>troubleshooting</em> tips, and restart your agent."
      },
      "id": "604429e628ccbcb80b2c60d0"
    }
  ],
  "/docs/browser/new-relic-browser/troubleshooting/google-amp-validator-fails-due-3rd-party-script": [
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.33337,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "If you use <em>Browser</em> to <em>monitor</em> end-user <em>browser</em> activity, you can now see end-user-originating <em>browser</em>-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data"
      },
      "id": "6043fe6f196a6784f0960f53"
    },
    {
      "sections": [
        "Not seeing specific page or endpoint names in Browser data",
        "Problem",
        "Solution"
      ],
      "title": "Not seeing specific page or endpoint names in Browser data",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Troubleshooting"
      ],
      "external_id": "e91e38e0160cd95da45e928f462c70fde1457031",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/troubleshooting/not-seeing-specific-page-or-endpoint-names-browser-data/",
      "published_at": "2021-07-02T00:36:02Z",
      "updated_at": "2021-06-14T22:19:10Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You're looking for performance breakdowns for specific pages or endpoints on the browser monitoring Page views UI page or AJAX UI page. The UI doesn't show the URL group you're looking for, or it only shows / and /*. This behavior also appears in SPA data in BrowserInteraction events and applies to browserInteractionName, targetGroupedUrl, and previousGroupedUrl attributes. Solution Browser monitoring automatically \"learns\" to group your page views when your application is first deployed, and it adds that information to an allow list for URLs. Sometimes this grouping may not match your current page view information. To solve this problem, manage your application's URL segment list settings by editing existing rules or by adding the domains and URL segments that make up your site's URLs. After you add the necessary rules, you should see a useful breakdown of your information in the UI. Here are some useful tips: Adding segments to your allow list Tip Use constant URL segments. Only add the URL segments that remain constant across many page views. Do not add unique segments such as IDs or highly-specific categories, because this can lead to metric grouping issues. Enter exact matches. Enter any URL segments as exact matches, including case. Use existing rules. If a rule already appears for a domain: Go to one.newrelic.com > Browser > (select an app) > Settings > Segment allow lists. Rather than creating a new rule, edit the existing rule, and add the domain to the UI's Allow listed segments field. Group sub-domains. Group similar sub-domains such as foo.domain.com and bar.domain.com under *.domain.com. This grouping must occur just before the top-level domain name. Set up single-page apps. If your site is a single-page application and you only see / under page views, then your grouping is working correctly. New Relic records subsequent requests as AJAX loads, and your AJAX page will contain more detailed information. If it doesn't, then follow the tips in this document. Remove rules when appropriate. If you need to remove a rule, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.28096,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Not seeing specific page or endpoint names in <em>Browser</em> data",
        "sections": "Not seeing specific page or endpoint names in <em>Browser</em> data",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "Problem You&#x27;re looking for performance breakdowns for specific pages or endpoints on the <em>browser</em> <em>monitoring</em> Page views UI page or AJAX UI page. The UI doesn&#x27;t show the URL group you&#x27;re looking for, or it only shows &#x2F; and &#x2F;*. This behavior also appears in SPA data in <em>Browser</em>Interaction events"
      },
      "id": "603e8fff28ccbc8813eba7a1"
    },
    {
      "sections": [
        "Install the browser monitoring agent",
        "Tip",
        "Select a deployment option",
        "Important",
        "Enable an APM-monitored app",
        "Enable with copy/paste",
        "Instrument webpages using the APM agent",
        "Troubleshoot Browser agent installation"
      ],
      "title": "Install the browser monitoring agent",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Installation"
      ],
      "external_id": "bc45bbc86cd4d8b81367ad0904907ddc735717f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/installation/install-browser-monitoring-agent/",
      "published_at": "2021-07-02T09:15:35Z",
      "updated_at": "2021-06-14T21:26:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser uses a JavaScript snippet (or \"agent\") to instrument your app's webpages. The JavaScript collects data for browser monitoring. To install the browser agent, you can choose from a number of deployment options. Tip To use Browser and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Select a deployment option No matter which option you use to deploy browser monitoring, the end result is to inject the browser agent's JavaScript snippet into your pages for browser monitoring. The method you select depends on your preferences and business needs. To view the procedure to install and enable the browser agent, click the link for the option you want to use. You can also use the Browser Application settings page to update settings. Important The following configuration options refer only to the browser monitoring agent. These are not the same as the New Relic user roles and editions. Browser deployment option Description Use the APM agent to inject the JavaScript You can use an APM agent to automatically inject the browser monitoring JavaScript snippet for you. This is the easiest way to install the agent for an app that already is being monitored by APM. (APM-monitored apps are listed on your APM Applications index.) Paste the JavaScript snippet into a webpage This allows you to control the exact placement of the JavaScript into your app's webpage(s) by copying and pasting the browser agent's JavaScript snippet. This is useful for: Standalone apps, static sites, and cached pages delivered by CDN APM apps that are not as closely coupled to the browser app as with a standard server-side app (for example, when your client-side app talks to a REST API back end) Enable single-page app (SPA) monitoring Enabling SPA requires a Pro + SPA browser agent subscription, and you may need to re-deploy the browser JavaScript agent. Use the REST API The REST API lets you manage deployment outside the browser UI. This is useful for large organizations deploying multiple apps. Use an APM agent API to manually instrument the JavaScript snippet For apps that are monitored by APM, you can use the APM agent's API to inject the JavaScript manually instead of automatically. Enable an APM-monitored app Use this procedure to automatically deploy the browser agent on an app that is monitored by APM: Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Enable via New Relic APM. In the Choose your instrumentation section, select Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Select your application section, type or use the search window to find an app's name. Click Enable. Important Node.js: To finish enabling the browser agent for a Node.js app, follow the additional procedure to insert the JavaScript header into the beginning of your HTML page's head tag. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. Enable with copy/paste Use this procedure to insert browser's JavaScript snippet for browser monitoring into your app's webpages yourself. This option is useful for monitoring static sites (such as Jekyll) or cached pages delivered by CDN. Tip Near the bottom of the generated JavaScript is your browser license key and application ID. This is useful with the REST API and API Explorer. Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Copy/Paste JavaScript Code. In the Choose your instrumentation section, select the type of agent: Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Name your app section, name your app: If your app is monitored by APM, select Yes, then type or use the search window to find the app's name. If you have a standalone app for Browser (not monitored by APM), select No, then type the app's name. Click Enable. A new section, Instrument the agent, opens on the page with JavaScript code for your project. Copy the code snippet, then paste it inline into your pages as close to the top of the <head> element as possible, but after any position-sensitive <meta> tags (for example, X-UA-Compatible or charset information). For more information on the inline head placement, see JavaScript placement requirements. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. If you use the copy/paste method, but don't finish the setup process, you can still view and copy the generated JavaScript snippet from your app's Browser Application settings page or by using the REST API (v2). Instrument webpages using the APM agent This information applies to apps that are also monitored by APM. New Relic's agents can instrument webpages with the required JavaScript for page load timing. If you use the APM agent to add the JavaScript snippet to your webpages, insert the instrumentation snippet as close to the top as possible. This allows you to take advantage of detailed information about browser's AJAX calls and JavaScript errors. For more information, see the instructions for your APM agent: C SDK Go Java .NET Node.js PHP Python Ruby Troubleshoot Browser agent installation When you enable browser Pro features for session traces, AJAX calls, or JavaScript errors, it may take approximately five minutes before information becomes available. If you have problems with your browser installation or if no data appears after five minutes, refer to the troubleshooting tips, and restart your agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.40486,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install the <em>browser</em> <em>monitoring</em> agent",
        "sections": "Install the <em>browser</em> <em>monitoring</em> agent",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " PHP Python Ruby <em>Troubleshoot</em> <em>Browser</em> agent installation When you enable <em>browser</em> Pro features for session traces, AJAX calls, or JavaScript errors, it may take approximately five minutes before information becomes available. If you have problems with your <em>browser</em> installation or if no data appears after five minutes, refer to the <em>troubleshooting</em> tips, and restart your agent."
      },
      "id": "604429e628ccbcb80b2c60d0"
    }
  ],
  "/docs/browser/new-relic-browser/troubleshooting/not-seeing-specific-page-or-endpoint-names-browser-data": [
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.33337,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "If you use <em>Browser</em> to <em>monitor</em> end-user <em>browser</em> activity, you can now see end-user-originating <em>browser</em>-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data"
      },
      "id": "6043fe6f196a6784f0960f53"
    },
    {
      "sections": [
        "Install the browser monitoring agent",
        "Tip",
        "Select a deployment option",
        "Important",
        "Enable an APM-monitored app",
        "Enable with copy/paste",
        "Instrument webpages using the APM agent",
        "Troubleshoot Browser agent installation"
      ],
      "title": "Install the browser monitoring agent",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Installation"
      ],
      "external_id": "bc45bbc86cd4d8b81367ad0904907ddc735717f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/installation/install-browser-monitoring-agent/",
      "published_at": "2021-07-02T09:15:35Z",
      "updated_at": "2021-06-14T21:26:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser uses a JavaScript snippet (or \"agent\") to instrument your app's webpages. The JavaScript collects data for browser monitoring. To install the browser agent, you can choose from a number of deployment options. Tip To use Browser and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Select a deployment option No matter which option you use to deploy browser monitoring, the end result is to inject the browser agent's JavaScript snippet into your pages for browser monitoring. The method you select depends on your preferences and business needs. To view the procedure to install and enable the browser agent, click the link for the option you want to use. You can also use the Browser Application settings page to update settings. Important The following configuration options refer only to the browser monitoring agent. These are not the same as the New Relic user roles and editions. Browser deployment option Description Use the APM agent to inject the JavaScript You can use an APM agent to automatically inject the browser monitoring JavaScript snippet for you. This is the easiest way to install the agent for an app that already is being monitored by APM. (APM-monitored apps are listed on your APM Applications index.) Paste the JavaScript snippet into a webpage This allows you to control the exact placement of the JavaScript into your app's webpage(s) by copying and pasting the browser agent's JavaScript snippet. This is useful for: Standalone apps, static sites, and cached pages delivered by CDN APM apps that are not as closely coupled to the browser app as with a standard server-side app (for example, when your client-side app talks to a REST API back end) Enable single-page app (SPA) monitoring Enabling SPA requires a Pro + SPA browser agent subscription, and you may need to re-deploy the browser JavaScript agent. Use the REST API The REST API lets you manage deployment outside the browser UI. This is useful for large organizations deploying multiple apps. Use an APM agent API to manually instrument the JavaScript snippet For apps that are monitored by APM, you can use the APM agent's API to inject the JavaScript manually instead of automatically. Enable an APM-monitored app Use this procedure to automatically deploy the browser agent on an app that is monitored by APM: Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Enable via New Relic APM. In the Choose your instrumentation section, select Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Select your application section, type or use the search window to find an app's name. Click Enable. Important Node.js: To finish enabling the browser agent for a Node.js app, follow the additional procedure to insert the JavaScript header into the beginning of your HTML page's head tag. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. Enable with copy/paste Use this procedure to insert browser's JavaScript snippet for browser monitoring into your app's webpages yourself. This option is useful for monitoring static sites (such as Jekyll) or cached pages delivered by CDN. Tip Near the bottom of the generated JavaScript is your browser license key and application ID. This is useful with the REST API and API Explorer. Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Copy/Paste JavaScript Code. In the Choose your instrumentation section, select the type of agent: Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Name your app section, name your app: If your app is monitored by APM, select Yes, then type or use the search window to find the app's name. If you have a standalone app for Browser (not monitored by APM), select No, then type the app's name. Click Enable. A new section, Instrument the agent, opens on the page with JavaScript code for your project. Copy the code snippet, then paste it inline into your pages as close to the top of the <head> element as possible, but after any position-sensitive <meta> tags (for example, X-UA-Compatible or charset information). For more information on the inline head placement, see JavaScript placement requirements. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. If you use the copy/paste method, but don't finish the setup process, you can still view and copy the generated JavaScript snippet from your app's Browser Application settings page or by using the REST API (v2). Instrument webpages using the APM agent This information applies to apps that are also monitored by APM. New Relic's agents can instrument webpages with the required JavaScript for page load timing. If you use the APM agent to add the JavaScript snippet to your webpages, insert the instrumentation snippet as close to the top as possible. This allows you to take advantage of detailed information about browser's AJAX calls and JavaScript errors. For more information, see the instructions for your APM agent: C SDK Go Java .NET Node.js PHP Python Ruby Troubleshoot Browser agent installation When you enable browser Pro features for session traces, AJAX calls, or JavaScript errors, it may take approximately five minutes before information becomes available. If you have problems with your browser installation or if no data appears after five minutes, refer to the troubleshooting tips, and restart your agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.40486,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install the <em>browser</em> <em>monitoring</em> agent",
        "sections": "Install the <em>browser</em> <em>monitoring</em> agent",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " PHP Python Ruby <em>Troubleshoot</em> <em>Browser</em> agent installation When you enable <em>browser</em> Pro features for session traces, AJAX calls, or JavaScript errors, it may take approximately five minutes before information becomes available. If you have problems with your <em>browser</em> installation or if no data appears after five minutes, refer to the <em>troubleshooting</em> tips, and restart your agent."
      },
      "id": "604429e628ccbcb80b2c60d0"
    },
    {
      "sections": [
        "Troubleshoot your browser monitoring installation",
        "Problem",
        "Tip",
        "Solution",
        "Deployment via APM agent",
        "Enable your app",
        "Update your APM agent",
        "Verify the JavaScript snippets",
        "Check other JavaScript error monitors",
        "Configure auto-instrumentation",
        "Important",
        "Verify manual API instrumentation",
        "Restart your APM app",
        "Checkpoint: Verify JavaScript on page",
        "Verify end-user network access",
        "Deployment via JavaScript copy/paste",
        "Clear any cached versions of your pages",
        "Check the JavaScript placement and completeness",
        "Razor framework: Check for a parser error message"
      ],
      "title": "Troubleshoot your browser monitoring installation",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Troubleshooting"
      ],
      "external_id": "38dd3206f05a9dda3e4561843c1488ecb0f3c276",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/troubleshooting/troubleshoot-your-browser-monitoring-installation/",
      "published_at": "2021-07-02T09:17:12Z",
      "updated_at": "2021-03-16T06:48:46Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem If you have just configured your application with browser monitoring, wait a few minutes for data to appear. If you have already waited a few minutes and you still do not see any data, try these troubleshooting tips. Some of these tips depend on whether you deployed your app by allowing browser monitoring to automatically insert the JavaScript snippet into your APM-monitored app or by inserting the JavaScript snippet yourself. Tip To use APM and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Solution Recommendation: Before following specific troubleshooting procedures, run the Diagnostics browser checks. Once Diagnostics CLI is downloaded, target the Browser checks by running the command-line options: /nrdiag -browser-url YOUR-WEBSITE-URL -suites browser. The information returned from Diagnostics CLI can be used when communicating with New Relic Support. If your browser monitoring agent was deployed for an account monitored with an APM agent, see APM deployments. If your browser monitoring agent was deployed using the JavaScript copy/paste method, see Copy/paste deployment. If you are unsure which you have, the Diagnostics tool will return the deployment method. You can also troubleshoot situations where you are missing only AJAX or session trace data. Deployment via APM agent These troubleshooting steps apply to problems when the browser monitoring agent is installed on an app already being monitored by an APM agent: Enable your app Verify that browser monitoring has been enabled in your application's Browser settings: Go to one.newrelic.com > Browser > (select an app) > Settings. Follow standard procedures to enable browser settings for each app. Flush your webserver cache. Wait a few more minutes for data to arrive. Try the next steps if you still do not see any data. Update your APM agent More recent APM agents place the page load timing scripts more accurately. Before continuing with these troubleshooting tips, make sure you have the most recent release for your APM agent. Tip For agent version requirements for page load timing, see Compatibility and requirements. Verify the JavaScript snippets Check your page's source for the two script elements required to capture metrics and send them to New Relic. In a browser, view the source of your page, and look for a script element near the beginning like this: <script type=\"text/javascript\"> (window.NREUM||(NREUM={})).loader_config={xpid:\"VRUGVVJS\";window.NREUM||(NREUM={}),__nr_require=function a(b,c,d){ ... Copy OR like this: <script type=\"text/javascript\"> window.NREUM||(NREUM={}),__nr_require=function a (b,c,d){ ... Copy Also verify that a second script element exists in one of two locations, depending on the app server agent language. C SDK: n/a Go: n/a Java: Before the </body> tag (which must be added to the page if missing) .NET: Immediately before the first script element Node.js: Immediately before the first script element PHP: At the end of the body element Python: In the head element or at the end of the body element Ruby: Immediately before the first script element The second tag contains configuration and timing data, and looks like this: <script type=\"text/javascript\"> window.NREUM||(NREUM={});NREUM.info={\"beacon\":\"bam.nr-data.net\",\"errorBeacon\":\"bam.nr-data.net\"... Copy If either script element is missing, continue troubleshooting with the following steps. If the script elements are present and data does not appear after several minutes, get support at support.newrelic.com. Check other JavaScript error monitors If you see JavaScript errors on your webpage, or if you do not see any data on your JavaScript errors page in the New Relic UI, check if any other JavaScript error monitoring frameworks have been enabled for your app. Some JavaScript error monitors may interfere with functionality for browser monitoring. Configure auto-instrumentation If you are using New Relic's automatic instrumentation feature, ensure your agent is configured properly. Each agent has a configuration file setting and specific instructions to turn auto-instrumentation on or off: C SDK: n/a Go: n/a Java .NET Node.js agent: Currently not supported; see manual instrumentation procedures PHP Python Ruby Important If you modify your agent's configuration file, be sure to restart your app. Verify manual API instrumentation If you are manually calling the New Relic agent API to generate and insert the JavaScript, verify that the calls are actually being made. The APIs and how to use them are specific to your agent: C SDK: n/a Go: n/a Java agent .NET agent Node.js agent (see also the Node.js troubleshooting procedures) PHP agent Python agent Ruby agent Restart your APM app If you modified your APM agent's configuration file, be sure to restart your application so that it picks up the modified settings. Java agent: Flush the app serverâ€™s \"work\" cache. This forces the app server to recompile. .NET agent: Make sure your asp.net cache directory is clean by using the command flush_dotnet_temp.cmd. This forces the app server to recompile ASPs with page load timing instrumentation. Checkpoint: Verify JavaScript on page Verify that the JavaScript is on the page as detailed in the previous step Verify the JavaScript snippets. If it is not on the page, use the manual instrumentation as detailed in Verify manual API instrumentation. The Javascript must be present on your page before you can proceed to the next step. Verify end-user network access If your application is loaded primarily within a secured local network, ensure that your users can reach the necessary network endpoints to report browser data. This includes New Relic's CDNs and beacon. Deployment via JavaScript copy/paste These troubleshooting steps apply to problems when New Relic's browser monitoring agent was deployed using the HTML copy/paste method: Enable your app Verify that browser monitoring has been enabled in your application's Browser settings: Go to one.newrelic.com > Browser > (select an app) > Settings. Follow standard procedures to enable browser settings for each app. Flush your webserver cache. Wait a few more minutes for data to arrive. Try the next steps if you still do not see any data. Verify the JavaScript snippets Check your page's source for the script element required to capture metrics and send them to New Relic. In a browser, view the source of your page, and look for a script element near the beginning like this: <script type=\"text/javascript\"> window.NREUM||(NREUM={}),__nr_require=function a (b,c,d){ ... Copy If the script element is missing, make sure that you have pasted it in and deployed your new code. If you have not yet pasted in the JavaScript snippet, you can copy it again from your browser app's Settings page. If applicable, restart the application serving these pages. If you still don't see the script, continue troubleshooting with the following steps. Clear any cached versions of your pages For the Javascript snippets to appear in pages served by your application, ensure that any cached versions of the pages from before you added the code have been cleared. Check any CDN caches. Flush your webserver cache. Check the JavaScript placement and completeness Insert the JavaScript as close to the top of the HEAD as possible, but after any position-sensitive META tags (X-UA-Compatible and charset). It must be outside any comments. Here is an example of the general format: <!DOCTYPE html> <html> <head> <meta tags> {PLACE NEW RELIC SCRIPT TAG HERE} <script and link tags> </head> <body> ... </body> </html> Copy If the Javascript is correctly placed, compare it with the original snippet you generated to ensure it is complete and identical. Incomplete or modified snippets may not report correctly. Check other JavaScript error monitors If you see JavaScript errors on your webpage, or if you do not see any data on your JavaScript errors page in the New Relic UI, check if any other JavaScript error monitoring frameworks have been enabled for your app. Some JavaScript error monitors may interfere with functionality for browser monitoring. Verify end-user network access If your application is loaded primarily within a secured local network, ensure that your users can reach the necessary network endpoints to report browser data. This includes New Relic's CDNs and beacon. Razor framework: Check for a parser error message If you use the copy/paste installation method in a .NET app that uses the Razor Framework, this may result in the following error: Parser Error Message: \"\").pop().split(\"\" is not valid at the start of a code block. Only identifiers, keywords, comments, \"(\" and \"{\" are valid. Copy The error is caused by an @ symbol in theJavaScript snippet for browser monitoring . The @ symbol represents the beginning of a code block in Razor. The line that causes the problem is: .split(\"@\").pop().split(\":\") Copy To fix this issue, use one of these workarounds: Wrap the Browser JavaScript snippet in <text></text> tags to force it to be interpreted as content. OR Add another @ to the line to escape it. Check that the line looks like this: .split(\"@@\").pop().split(\":\") Copy Use only one of the workarounds. Using both will break the code again.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.59559,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Troubleshoot</em> your <em>browser</em> <em>monitoring</em> installation",
        "sections": "<em>Troubleshoot</em> your <em>browser</em> <em>monitoring</em> installation",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "Problem If you have just configured your application with <em>browser</em> <em>monitoring</em>, wait a few minutes for data to appear. If you have already waited a few minutes and you still do not see any data, try these <em>troubleshooting</em> tips. Some of these tips depend on whether you deployed your app by allowing"
      },
      "id": "603e8f2864441fa5024e8877"
    }
  ],
  "/docs/browser/new-relic-browser/troubleshooting/third-party-js-errors-missing-stack-traces": [
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.33327,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "If you use <em>Browser</em> to <em>monitor</em> end-user <em>browser</em> activity, you can now see end-user-originating <em>browser</em>-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data"
      },
      "id": "6043fe6f196a6784f0960f53"
    },
    {
      "sections": [
        "Not seeing specific page or endpoint names in Browser data",
        "Problem",
        "Solution"
      ],
      "title": "Not seeing specific page or endpoint names in Browser data",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Troubleshooting"
      ],
      "external_id": "e91e38e0160cd95da45e928f462c70fde1457031",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/troubleshooting/not-seeing-specific-page-or-endpoint-names-browser-data/",
      "published_at": "2021-07-02T00:36:02Z",
      "updated_at": "2021-06-14T22:19:10Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You're looking for performance breakdowns for specific pages or endpoints on the browser monitoring Page views UI page or AJAX UI page. The UI doesn't show the URL group you're looking for, or it only shows / and /*. This behavior also appears in SPA data in BrowserInteraction events and applies to browserInteractionName, targetGroupedUrl, and previousGroupedUrl attributes. Solution Browser monitoring automatically \"learns\" to group your page views when your application is first deployed, and it adds that information to an allow list for URLs. Sometimes this grouping may not match your current page view information. To solve this problem, manage your application's URL segment list settings by editing existing rules or by adding the domains and URL segments that make up your site's URLs. After you add the necessary rules, you should see a useful breakdown of your information in the UI. Here are some useful tips: Adding segments to your allow list Tip Use constant URL segments. Only add the URL segments that remain constant across many page views. Do not add unique segments such as IDs or highly-specific categories, because this can lead to metric grouping issues. Enter exact matches. Enter any URL segments as exact matches, including case. Use existing rules. If a rule already appears for a domain: Go to one.newrelic.com > Browser > (select an app) > Settings > Segment allow lists. Rather than creating a new rule, edit the existing rule, and add the domain to the UI's Allow listed segments field. Group sub-domains. Group similar sub-domains such as foo.domain.com and bar.domain.com under *.domain.com. This grouping must occur just before the top-level domain name. Set up single-page apps. If your site is a single-page application and you only see / under page views, then your grouping is working correctly. New Relic records subsequent requests as AJAX loads, and your AJAX page will contain more detailed information. If it doesn't, then follow the tips in this document. Remove rules when appropriate. If you need to remove a rule, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.28094,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Not seeing specific page or endpoint names in <em>Browser</em> data",
        "sections": "Not seeing specific page or endpoint names in <em>Browser</em> data",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "Problem You&#x27;re looking for performance breakdowns for specific pages or endpoints on the <em>browser</em> <em>monitoring</em> Page views UI page or AJAX UI page. The UI doesn&#x27;t show the URL group you&#x27;re looking for, or it only shows &#x2F; and &#x2F;*. This behavior also appears in SPA data in <em>Browser</em>Interaction events"
      },
      "id": "603e8fff28ccbc8813eba7a1"
    },
    {
      "sections": [
        "Install the browser monitoring agent",
        "Tip",
        "Select a deployment option",
        "Important",
        "Enable an APM-monitored app",
        "Enable with copy/paste",
        "Instrument webpages using the APM agent",
        "Troubleshoot Browser agent installation"
      ],
      "title": "Install the browser monitoring agent",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Installation"
      ],
      "external_id": "bc45bbc86cd4d8b81367ad0904907ddc735717f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/installation/install-browser-monitoring-agent/",
      "published_at": "2021-07-02T09:15:35Z",
      "updated_at": "2021-06-14T21:26:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser uses a JavaScript snippet (or \"agent\") to instrument your app's webpages. The JavaScript collects data for browser monitoring. To install the browser agent, you can choose from a number of deployment options. Tip To use Browser and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Select a deployment option No matter which option you use to deploy browser monitoring, the end result is to inject the browser agent's JavaScript snippet into your pages for browser monitoring. The method you select depends on your preferences and business needs. To view the procedure to install and enable the browser agent, click the link for the option you want to use. You can also use the Browser Application settings page to update settings. Important The following configuration options refer only to the browser monitoring agent. These are not the same as the New Relic user roles and editions. Browser deployment option Description Use the APM agent to inject the JavaScript You can use an APM agent to automatically inject the browser monitoring JavaScript snippet for you. This is the easiest way to install the agent for an app that already is being monitored by APM. (APM-monitored apps are listed on your APM Applications index.) Paste the JavaScript snippet into a webpage This allows you to control the exact placement of the JavaScript into your app's webpage(s) by copying and pasting the browser agent's JavaScript snippet. This is useful for: Standalone apps, static sites, and cached pages delivered by CDN APM apps that are not as closely coupled to the browser app as with a standard server-side app (for example, when your client-side app talks to a REST API back end) Enable single-page app (SPA) monitoring Enabling SPA requires a Pro + SPA browser agent subscription, and you may need to re-deploy the browser JavaScript agent. Use the REST API The REST API lets you manage deployment outside the browser UI. This is useful for large organizations deploying multiple apps. Use an APM agent API to manually instrument the JavaScript snippet For apps that are monitored by APM, you can use the APM agent's API to inject the JavaScript manually instead of automatically. Enable an APM-monitored app Use this procedure to automatically deploy the browser agent on an app that is monitored by APM: Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Enable via New Relic APM. In the Choose your instrumentation section, select Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Select your application section, type or use the search window to find an app's name. Click Enable. Important Node.js: To finish enabling the browser agent for a Node.js app, follow the additional procedure to insert the JavaScript header into the beginning of your HTML page's head tag. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. Enable with copy/paste Use this procedure to insert browser's JavaScript snippet for browser monitoring into your app's webpages yourself. This option is useful for monitoring static sites (such as Jekyll) or cached pages delivered by CDN. Tip Near the bottom of the generated JavaScript is your browser license key and application ID. This is useful with the REST API and API Explorer. Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Copy/Paste JavaScript Code. In the Choose your instrumentation section, select the type of agent: Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Name your app section, name your app: If your app is monitored by APM, select Yes, then type or use the search window to find the app's name. If you have a standalone app for Browser (not monitored by APM), select No, then type the app's name. Click Enable. A new section, Instrument the agent, opens on the page with JavaScript code for your project. Copy the code snippet, then paste it inline into your pages as close to the top of the <head> element as possible, but after any position-sensitive <meta> tags (for example, X-UA-Compatible or charset information). For more information on the inline head placement, see JavaScript placement requirements. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. If you use the copy/paste method, but don't finish the setup process, you can still view and copy the generated JavaScript snippet from your app's Browser Application settings page or by using the REST API (v2). Instrument webpages using the APM agent This information applies to apps that are also monitored by APM. New Relic's agents can instrument webpages with the required JavaScript for page load timing. If you use the APM agent to add the JavaScript snippet to your webpages, insert the instrumentation snippet as close to the top as possible. This allows you to take advantage of detailed information about browser's AJAX calls and JavaScript errors. For more information, see the instructions for your APM agent: C SDK Go Java .NET Node.js PHP Python Ruby Troubleshoot Browser agent installation When you enable browser Pro features for session traces, AJAX calls, or JavaScript errors, it may take approximately five minutes before information becomes available. If you have problems with your browser installation or if no data appears after five minutes, refer to the troubleshooting tips, and restart your agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.40485,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install the <em>browser</em> <em>monitoring</em> agent",
        "sections": "Install the <em>browser</em> <em>monitoring</em> agent",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " PHP Python Ruby <em>Troubleshoot</em> <em>Browser</em> agent installation When you enable <em>browser</em> Pro features for session traces, AJAX calls, or JavaScript errors, it may take approximately five minutes before information becomes available. If you have problems with your <em>browser</em> installation or if no data appears after five minutes, refer to the <em>troubleshooting</em> tips, and restart your agent."
      },
      "id": "604429e628ccbcb80b2c60d0"
    }
  ],
  "/docs/browser/new-relic-browser/troubleshooting/troubleshoot-ajax-data-collection": [
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.33327,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "If you use <em>Browser</em> to <em>monitor</em> end-user <em>browser</em> activity, you can now see end-user-originating <em>browser</em>-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data"
      },
      "id": "6043fe6f196a6784f0960f53"
    },
    {
      "sections": [
        "Not seeing specific page or endpoint names in Browser data",
        "Problem",
        "Solution"
      ],
      "title": "Not seeing specific page or endpoint names in Browser data",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Troubleshooting"
      ],
      "external_id": "e91e38e0160cd95da45e928f462c70fde1457031",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/troubleshooting/not-seeing-specific-page-or-endpoint-names-browser-data/",
      "published_at": "2021-07-02T00:36:02Z",
      "updated_at": "2021-06-14T22:19:10Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You're looking for performance breakdowns for specific pages or endpoints on the browser monitoring Page views UI page or AJAX UI page. The UI doesn't show the URL group you're looking for, or it only shows / and /*. This behavior also appears in SPA data in BrowserInteraction events and applies to browserInteractionName, targetGroupedUrl, and previousGroupedUrl attributes. Solution Browser monitoring automatically \"learns\" to group your page views when your application is first deployed, and it adds that information to an allow list for URLs. Sometimes this grouping may not match your current page view information. To solve this problem, manage your application's URL segment list settings by editing existing rules or by adding the domains and URL segments that make up your site's URLs. After you add the necessary rules, you should see a useful breakdown of your information in the UI. Here are some useful tips: Adding segments to your allow list Tip Use constant URL segments. Only add the URL segments that remain constant across many page views. Do not add unique segments such as IDs or highly-specific categories, because this can lead to metric grouping issues. Enter exact matches. Enter any URL segments as exact matches, including case. Use existing rules. If a rule already appears for a domain: Go to one.newrelic.com > Browser > (select an app) > Settings > Segment allow lists. Rather than creating a new rule, edit the existing rule, and add the domain to the UI's Allow listed segments field. Group sub-domains. Group similar sub-domains such as foo.domain.com and bar.domain.com under *.domain.com. This grouping must occur just before the top-level domain name. Set up single-page apps. If your site is a single-page application and you only see / under page views, then your grouping is working correctly. New Relic records subsequent requests as AJAX loads, and your AJAX page will contain more detailed information. If it doesn't, then follow the tips in this document. Remove rules when appropriate. If you need to remove a rule, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.28094,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Not seeing specific page or endpoint names in <em>Browser</em> data",
        "sections": "Not seeing specific page or endpoint names in <em>Browser</em> data",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "Problem You&#x27;re looking for performance breakdowns for specific pages or endpoints on the <em>browser</em> <em>monitoring</em> Page views UI page or AJAX UI page. The UI doesn&#x27;t show the URL group you&#x27;re looking for, or it only shows &#x2F; and &#x2F;*. This behavior also appears in SPA data in <em>Browser</em>Interaction events"
      },
      "id": "603e8fff28ccbc8813eba7a1"
    },
    {
      "sections": [
        "Install the browser monitoring agent",
        "Tip",
        "Select a deployment option",
        "Important",
        "Enable an APM-monitored app",
        "Enable with copy/paste",
        "Instrument webpages using the APM agent",
        "Troubleshoot Browser agent installation"
      ],
      "title": "Install the browser monitoring agent",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Installation"
      ],
      "external_id": "bc45bbc86cd4d8b81367ad0904907ddc735717f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/installation/install-browser-monitoring-agent/",
      "published_at": "2021-07-02T09:15:35Z",
      "updated_at": "2021-06-14T21:26:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser uses a JavaScript snippet (or \"agent\") to instrument your app's webpages. The JavaScript collects data for browser monitoring. To install the browser agent, you can choose from a number of deployment options. Tip To use Browser and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Select a deployment option No matter which option you use to deploy browser monitoring, the end result is to inject the browser agent's JavaScript snippet into your pages for browser monitoring. The method you select depends on your preferences and business needs. To view the procedure to install and enable the browser agent, click the link for the option you want to use. You can also use the Browser Application settings page to update settings. Important The following configuration options refer only to the browser monitoring agent. These are not the same as the New Relic user roles and editions. Browser deployment option Description Use the APM agent to inject the JavaScript You can use an APM agent to automatically inject the browser monitoring JavaScript snippet for you. This is the easiest way to install the agent for an app that already is being monitored by APM. (APM-monitored apps are listed on your APM Applications index.) Paste the JavaScript snippet into a webpage This allows you to control the exact placement of the JavaScript into your app's webpage(s) by copying and pasting the browser agent's JavaScript snippet. This is useful for: Standalone apps, static sites, and cached pages delivered by CDN APM apps that are not as closely coupled to the browser app as with a standard server-side app (for example, when your client-side app talks to a REST API back end) Enable single-page app (SPA) monitoring Enabling SPA requires a Pro + SPA browser agent subscription, and you may need to re-deploy the browser JavaScript agent. Use the REST API The REST API lets you manage deployment outside the browser UI. This is useful for large organizations deploying multiple apps. Use an APM agent API to manually instrument the JavaScript snippet For apps that are monitored by APM, you can use the APM agent's API to inject the JavaScript manually instead of automatically. Enable an APM-monitored app Use this procedure to automatically deploy the browser agent on an app that is monitored by APM: Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Enable via New Relic APM. In the Choose your instrumentation section, select Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Select your application section, type or use the search window to find an app's name. Click Enable. Important Node.js: To finish enabling the browser agent for a Node.js app, follow the additional procedure to insert the JavaScript header into the beginning of your HTML page's head tag. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. Enable with copy/paste Use this procedure to insert browser's JavaScript snippet for browser monitoring into your app's webpages yourself. This option is useful for monitoring static sites (such as Jekyll) or cached pages delivered by CDN. Tip Near the bottom of the generated JavaScript is your browser license key and application ID. This is useful with the REST API and API Explorer. Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Copy/Paste JavaScript Code. In the Choose your instrumentation section, select the type of agent: Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Name your app section, name your app: If your app is monitored by APM, select Yes, then type or use the search window to find the app's name. If you have a standalone app for Browser (not monitored by APM), select No, then type the app's name. Click Enable. A new section, Instrument the agent, opens on the page with JavaScript code for your project. Copy the code snippet, then paste it inline into your pages as close to the top of the <head> element as possible, but after any position-sensitive <meta> tags (for example, X-UA-Compatible or charset information). For more information on the inline head placement, see JavaScript placement requirements. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. If you use the copy/paste method, but don't finish the setup process, you can still view and copy the generated JavaScript snippet from your app's Browser Application settings page or by using the REST API (v2). Instrument webpages using the APM agent This information applies to apps that are also monitored by APM. New Relic's agents can instrument webpages with the required JavaScript for page load timing. If you use the APM agent to add the JavaScript snippet to your webpages, insert the instrumentation snippet as close to the top as possible. This allows you to take advantage of detailed information about browser's AJAX calls and JavaScript errors. For more information, see the instructions for your APM agent: C SDK Go Java .NET Node.js PHP Python Ruby Troubleshoot Browser agent installation When you enable browser Pro features for session traces, AJAX calls, or JavaScript errors, it may take approximately five minutes before information becomes available. If you have problems with your browser installation or if no data appears after five minutes, refer to the troubleshooting tips, and restart your agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.40485,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install the <em>browser</em> <em>monitoring</em> agent",
        "sections": "Install the <em>browser</em> <em>monitoring</em> agent",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " PHP Python Ruby <em>Troubleshoot</em> <em>Browser</em> agent installation When you enable <em>browser</em> Pro features for session traces, AJAX calls, or JavaScript errors, it may take approximately five minutes before information becomes available. If you have problems with your <em>browser</em> installation or if no data appears after five minutes, refer to the <em>troubleshooting</em> tips, and restart your agent."
      },
      "id": "604429e628ccbcb80b2c60d0"
    }
  ],
  "/docs/browser/new-relic-browser/troubleshooting/troubleshooting-session-trace-collection": [
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.33316,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "If you use <em>Browser</em> to <em>monitor</em> end-user <em>browser</em> activity, you can now see end-user-originating <em>browser</em>-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data"
      },
      "id": "6043fe6f196a6784f0960f53"
    },
    {
      "sections": [
        "Not seeing specific page or endpoint names in Browser data",
        "Problem",
        "Solution"
      ],
      "title": "Not seeing specific page or endpoint names in Browser data",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Troubleshooting"
      ],
      "external_id": "e91e38e0160cd95da45e928f462c70fde1457031",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/troubleshooting/not-seeing-specific-page-or-endpoint-names-browser-data/",
      "published_at": "2021-07-02T00:36:02Z",
      "updated_at": "2021-06-14T22:19:10Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You're looking for performance breakdowns for specific pages or endpoints on the browser monitoring Page views UI page or AJAX UI page. The UI doesn't show the URL group you're looking for, or it only shows / and /*. This behavior also appears in SPA data in BrowserInteraction events and applies to browserInteractionName, targetGroupedUrl, and previousGroupedUrl attributes. Solution Browser monitoring automatically \"learns\" to group your page views when your application is first deployed, and it adds that information to an allow list for URLs. Sometimes this grouping may not match your current page view information. To solve this problem, manage your application's URL segment list settings by editing existing rules or by adding the domains and URL segments that make up your site's URLs. After you add the necessary rules, you should see a useful breakdown of your information in the UI. Here are some useful tips: Adding segments to your allow list Tip Use constant URL segments. Only add the URL segments that remain constant across many page views. Do not add unique segments such as IDs or highly-specific categories, because this can lead to metric grouping issues. Enter exact matches. Enter any URL segments as exact matches, including case. Use existing rules. If a rule already appears for a domain: Go to one.newrelic.com > Browser > (select an app) > Settings > Segment allow lists. Rather than creating a new rule, edit the existing rule, and add the domain to the UI's Allow listed segments field. Group sub-domains. Group similar sub-domains such as foo.domain.com and bar.domain.com under *.domain.com. This grouping must occur just before the top-level domain name. Set up single-page apps. If your site is a single-page application and you only see / under page views, then your grouping is working correctly. New Relic records subsequent requests as AJAX loads, and your AJAX page will contain more detailed information. If it doesn't, then follow the tips in this document. Remove rules when appropriate. If you need to remove a rule, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.28093,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Not seeing specific page or endpoint names in <em>Browser</em> data",
        "sections": "Not seeing specific page or endpoint names in <em>Browser</em> data",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "Problem You&#x27;re looking for performance breakdowns for specific pages or endpoints on the <em>browser</em> <em>monitoring</em> Page views UI page or AJAX UI page. The UI doesn&#x27;t show the URL group you&#x27;re looking for, or it only shows &#x2F; and &#x2F;*. This behavior also appears in SPA data in <em>Browser</em>Interaction events"
      },
      "id": "603e8fff28ccbc8813eba7a1"
    },
    {
      "sections": [
        "Install the browser monitoring agent",
        "Tip",
        "Select a deployment option",
        "Important",
        "Enable an APM-monitored app",
        "Enable with copy/paste",
        "Instrument webpages using the APM agent",
        "Troubleshoot Browser agent installation"
      ],
      "title": "Install the browser monitoring agent",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Installation"
      ],
      "external_id": "bc45bbc86cd4d8b81367ad0904907ddc735717f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/installation/install-browser-monitoring-agent/",
      "published_at": "2021-07-02T09:15:35Z",
      "updated_at": "2021-06-14T21:26:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser uses a JavaScript snippet (or \"agent\") to instrument your app's webpages. The JavaScript collects data for browser monitoring. To install the browser agent, you can choose from a number of deployment options. Tip To use Browser and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Select a deployment option No matter which option you use to deploy browser monitoring, the end result is to inject the browser agent's JavaScript snippet into your pages for browser monitoring. The method you select depends on your preferences and business needs. To view the procedure to install and enable the browser agent, click the link for the option you want to use. You can also use the Browser Application settings page to update settings. Important The following configuration options refer only to the browser monitoring agent. These are not the same as the New Relic user roles and editions. Browser deployment option Description Use the APM agent to inject the JavaScript You can use an APM agent to automatically inject the browser monitoring JavaScript snippet for you. This is the easiest way to install the agent for an app that already is being monitored by APM. (APM-monitored apps are listed on your APM Applications index.) Paste the JavaScript snippet into a webpage This allows you to control the exact placement of the JavaScript into your app's webpage(s) by copying and pasting the browser agent's JavaScript snippet. This is useful for: Standalone apps, static sites, and cached pages delivered by CDN APM apps that are not as closely coupled to the browser app as with a standard server-side app (for example, when your client-side app talks to a REST API back end) Enable single-page app (SPA) monitoring Enabling SPA requires a Pro + SPA browser agent subscription, and you may need to re-deploy the browser JavaScript agent. Use the REST API The REST API lets you manage deployment outside the browser UI. This is useful for large organizations deploying multiple apps. Use an APM agent API to manually instrument the JavaScript snippet For apps that are monitored by APM, you can use the APM agent's API to inject the JavaScript manually instead of automatically. Enable an APM-monitored app Use this procedure to automatically deploy the browser agent on an app that is monitored by APM: Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Enable via New Relic APM. In the Choose your instrumentation section, select Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Select your application section, type or use the search window to find an app's name. Click Enable. Important Node.js: To finish enabling the browser agent for a Node.js app, follow the additional procedure to insert the JavaScript header into the beginning of your HTML page's head tag. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. Enable with copy/paste Use this procedure to insert browser's JavaScript snippet for browser monitoring into your app's webpages yourself. This option is useful for monitoring static sites (such as Jekyll) or cached pages delivered by CDN. Tip Near the bottom of the generated JavaScript is your browser license key and application ID. This is useful with the REST API and API Explorer. Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Copy/Paste JavaScript Code. In the Choose your instrumentation section, select the type of agent: Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Name your app section, name your app: If your app is monitored by APM, select Yes, then type or use the search window to find the app's name. If you have a standalone app for Browser (not monitored by APM), select No, then type the app's name. Click Enable. A new section, Instrument the agent, opens on the page with JavaScript code for your project. Copy the code snippet, then paste it inline into your pages as close to the top of the <head> element as possible, but after any position-sensitive <meta> tags (for example, X-UA-Compatible or charset information). For more information on the inline head placement, see JavaScript placement requirements. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. If you use the copy/paste method, but don't finish the setup process, you can still view and copy the generated JavaScript snippet from your app's Browser Application settings page or by using the REST API (v2). Instrument webpages using the APM agent This information applies to apps that are also monitored by APM. New Relic's agents can instrument webpages with the required JavaScript for page load timing. If you use the APM agent to add the JavaScript snippet to your webpages, insert the instrumentation snippet as close to the top as possible. This allows you to take advantage of detailed information about browser's AJAX calls and JavaScript errors. For more information, see the instructions for your APM agent: C SDK Go Java .NET Node.js PHP Python Ruby Troubleshoot Browser agent installation When you enable browser Pro features for session traces, AJAX calls, or JavaScript errors, it may take approximately five minutes before information becomes available. If you have problems with your browser installation or if no data appears after five minutes, refer to the troubleshooting tips, and restart your agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.40483,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install the <em>browser</em> <em>monitoring</em> agent",
        "sections": "Install the <em>browser</em> <em>monitoring</em> agent",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " PHP Python Ruby <em>Troubleshoot</em> <em>Browser</em> agent installation When you enable <em>browser</em> Pro features for session traces, AJAX calls, or JavaScript errors, it may take approximately five minutes before information becomes available. If you have problems with your <em>browser</em> installation or if no data appears after five minutes, refer to the <em>troubleshooting</em> tips, and restart your agent."
      },
      "id": "604429e628ccbcb80b2c60d0"
    }
  ],
  "/docs/browser/new-relic-browser/troubleshooting/view-detailed-error-logs-browser": [
    {
      "sections": [
        "Browser data in distributed tracing",
        "Tip",
        "Benefits of browser data in distributed tracing",
        "Requirements and compatibility",
        "Enable distributed tracing",
        "Enable cross-origin resource sharing (CORS)",
        "Risks and mitigations",
        "Caution",
        "Important",
        "Enable cross-origin resource sharing",
        "Find data",
        "Troubleshooting"
      ],
      "title": "Browser data in distributed tracing",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Browser Pro features"
      ],
      "external_id": "fe29e64d44406955651c3644eabb3ddb6d2a66c0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/browser-pro-features/browser-data-distributed-tracing/",
      "published_at": "2021-07-02T00:22:42Z",
      "updated_at": "2021-07-02T00:22:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use Browser to monitor end-user browser activity, you can now see end-user-originating browser-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data Troubleshooting Tip Browser data is available in standard distributed tracing only, not Infinite Tracing. Benefits of browser data in distributed tracing By enabling New Relic to report browser data to distributed tracing, you can see the connection between front-end activity and back-end activity. You can see across a full transaction, from time spent by an end user in the web browser, to network activity, to associated back-end services. Benefits of this feature: Quickly spot latencies, errors, and anomalies in the browser or network Resolve customer-facing problems more quickly All the benefits of distributed tracing applied to your end-user monitoring Requirements and compatibility This feature reports AJAX requests (Fetch and XHR) that occur during a browser interaction. By default, only single-origin requests are monitored unless cross-origin resource sharing is enabled. Make sure you have the minimum versions for your Browser, APM, and APM agents: Browser Pro + SPA, with distributed tracing enabled Browser agent version 1153 or higher Browser agent version 1158 or higher (required for cross-origin resource sharing) Browser agent version 1173 or higher (required for w3c trace context support) APM agent version: C SDK 1.3 or higher Java 5.9.0 or higher PHP 9.4.0 or higher Other APM agent version requirements Enable distributed tracing To enable distributed tracing for Browser monitoring: Make sure you meet requirements, including having: Full-Stack Observability Browser Pro with SPA enabled Go to one.newrelic.com, and click Browser > (select an app) > Settings > Application settings. Turn on the Distributed tracing toggle. By default, for agent version 1173 and above, the newrelic, traceparent, and tracestate headers will be added to all same-origin AJAX requests. Optional: If all of your services are configured to use the w3c trace context headers, you can choose to exclude the newrelic, traceparent, and tracestate headers from requests. Optional: Enable cross-origin resource sharing. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Enable cross-origin resource sharing (CORS) If you have AJAX requests that need resources from different origins, you can enable cross-origin resource sharing (CORS). By default, distributed tracing for cross-origin requests is not enabled because of browser CORS security restrictions: Distributed tracing is implemented by adding a custom HTTP headers (newrelic, traceparent, and tracestate) to outgoing AJAX requests, and browsers typically do not allow custom headers on cross-origin requests. With the release of agent version 1173, we now support the w3c trace context headers (traceparent and tracestate) so these should also be allowed in your configuration. There are two separate configurations required to enable cross-origin distributed tracing: Configure the service on the different origin to accept the newrelic custom header Configure Browser monitoring to include the target origin in distributed tracing Our step-by-step instructions provide key concepts and steps to enable this feature, but if you need more background about how cross-origin resource sharing works, we recommend this Mozilla developer document. Risks and mitigations Caution Cross-origin resource sharing can expose you to a high level of risk if the services on the different origins are not configured correctly. The AJAX requests will likely return an error, resulting in a variety of failures, including: Resources failing to load (for example, images and key content) Login failures Entire site outages (depending on type of requests enabled) By enabling this cross-origin resource sharing feature, you are acknowledging the following: You understand that this feature is optional and not mandatory. You understand the steps you need to take in order to enable this feature for your services and your domains. You understand that if you do not properly configure your services prior to deployment (including but not limited to configuring your services on your domains to accept custom headers) portions or all of your website will likely malfunction. You understand that New Relic is neither responsible nor liable for errors or issues related to your misconfiguration of servers or services. You fully and solely accept the risks and wish to proceed. The best way to minimize your risk is to ensure you fully understand the process and to try it first in a test environment. Before reading the step-by-step instructions, it may help to first read this overview of the process: To use distributed tracing with cross-origin resources, you populate a list of approved cross-origin resources in New Relic, and then we automatically send the following custom headers to those resources: newrelic, traceparent, and tracestate. For this process to work, you must first ensure that someone has configured the services on the other origins to accept this custom header. Cross-origin resource sharing uses a variety of HTTP headers (both in the request and response). The header that specifically applies to New Relic is the Access-Control-Allow-Headers response header, which can include newrelic, traceparent, tracestate, or newrelic, traceparent, tracestate in its value depending on what tracing strategies you enabled in your APM-monitored application. You must configure your server to return this CORS header in its response. Example: Access-Control-Allow-Headers: newrelic, traceparent, tracestate Important New Relic cannot perform any validation to ensure the services on the other origins were configured correctly. If you're unsure about how to allow these headers, do not add cross-origin resources to the approved list in the New Relic UI. Enable cross-origin resource sharing Caution You should always try enabling CORS in a test environment before setting it up in production. To enable cross-origin resource sharing: Confirm that the services on the other origins are configured to accept the newrelic header using: Access-Control-Allow-Headers: newrelic, traceparent, tracestate (for details, see Risks and mitigations). Confirm that you meet the Browser monitoring requirements. Make sure you are in one.newrelic.com, and click Browser > (select an app) > Application settings. Turn on the Distributed tracing toggle if it's not already enabled. Turn on the Cross-origin resource sharing (CORS) toggle. Under Cross-origin resource sharing (CORS), add cross-origin resources to the approved list. Important Valid cross-origin resources must include: The prefix http:// or https:// The domain name The port number is not required unless it differs from the default for HTTP (port 80) or HTTPS (port 443). Select Save application settings to update the agent configuration. Redeploy the Browser agent (either restarting the associated APM agent or updating the copy/paste Browser installation). Find data Tips for finding and querying data: You can find end-user-originating traces in any New Relic One distributed tracing UI. In the distributed tracing UI, end-user spans are indicated with the icon. To see a span's attributes, select a span in the UI. Spans are reported as Span data, and can be queried in New Relic. Query tips: Query by browser app name by setting browserApp.name to the browser app name. Query for traces containing at least one browser app span with browserApp.name is not null. Query for traces containing at least one back-end app with appName is not null. Query for traces containing both browser and back-end spans by combining the two previous conditions. Troubleshooting If you don't see end-user spans, or are having other distributed tracing issues, see Troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 189.33316,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Browser</em> data in distributed tracing",
        "sections": "<em>Browser</em> data in distributed tracing",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "If you use <em>Browser</em> to <em>monitor</em> end-user <em>browser</em> activity, you can now see end-user-originating <em>browser</em>-side traces in distributed tracing. This document contains: Benefits of this feature Requirements Enable distributed tracing Enable cross-origin resource sharing (CORS) Find and query data"
      },
      "id": "6043fe6f196a6784f0960f53"
    },
    {
      "sections": [
        "Not seeing specific page or endpoint names in Browser data",
        "Problem",
        "Solution"
      ],
      "title": "Not seeing specific page or endpoint names in Browser data",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Troubleshooting"
      ],
      "external_id": "e91e38e0160cd95da45e928f462c70fde1457031",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/new-relic-browser/troubleshooting/not-seeing-specific-page-or-endpoint-names-browser-data/",
      "published_at": "2021-07-02T00:36:02Z",
      "updated_at": "2021-06-14T22:19:10Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You're looking for performance breakdowns for specific pages or endpoints on the browser monitoring Page views UI page or AJAX UI page. The UI doesn't show the URL group you're looking for, or it only shows / and /*. This behavior also appears in SPA data in BrowserInteraction events and applies to browserInteractionName, targetGroupedUrl, and previousGroupedUrl attributes. Solution Browser monitoring automatically \"learns\" to group your page views when your application is first deployed, and it adds that information to an allow list for URLs. Sometimes this grouping may not match your current page view information. To solve this problem, manage your application's URL segment list settings by editing existing rules or by adding the domains and URL segments that make up your site's URLs. After you add the necessary rules, you should see a useful breakdown of your information in the UI. Here are some useful tips: Adding segments to your allow list Tip Use constant URL segments. Only add the URL segments that remain constant across many page views. Do not add unique segments such as IDs or highly-specific categories, because this can lead to metric grouping issues. Enter exact matches. Enter any URL segments as exact matches, including case. Use existing rules. If a rule already appears for a domain: Go to one.newrelic.com > Browser > (select an app) > Settings > Segment allow lists. Rather than creating a new rule, edit the existing rule, and add the domain to the UI's Allow listed segments field. Group sub-domains. Group similar sub-domains such as foo.domain.com and bar.domain.com under *.domain.com. This grouping must occur just before the top-level domain name. Set up single-page apps. If your site is a single-page application and you only see / under page views, then your grouping is working correctly. New Relic records subsequent requests as AJAX loads, and your AJAX page will contain more detailed information. If it doesn't, then follow the tips in this document. Remove rules when appropriate. If you need to remove a rule, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 144.28093,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Not seeing specific page or endpoint names in <em>Browser</em> data",
        "sections": "Not seeing specific page or endpoint names in <em>Browser</em> data",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": "Problem You&#x27;re looking for performance breakdowns for specific pages or endpoints on the <em>browser</em> <em>monitoring</em> Page views UI page or AJAX UI page. The UI doesn&#x27;t show the URL group you&#x27;re looking for, or it only shows &#x2F; and &#x2F;*. This behavior also appears in SPA data in <em>Browser</em>Interaction events"
      },
      "id": "603e8fff28ccbc8813eba7a1"
    },
    {
      "sections": [
        "Install the browser monitoring agent",
        "Tip",
        "Select a deployment option",
        "Important",
        "Enable an APM-monitored app",
        "Enable with copy/paste",
        "Instrument webpages using the APM agent",
        "Troubleshoot Browser agent installation"
      ],
      "title": "Install the browser monitoring agent",
      "type": "docs",
      "tags": [
        "Browser",
        "Browser monitoring",
        "Installation"
      ],
      "external_id": "bc45bbc86cd4d8b81367ad0904907ddc735717f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/browser/browser-monitoring/installation/install-browser-monitoring-agent/",
      "published_at": "2021-07-02T09:15:35Z",
      "updated_at": "2021-06-14T21:26:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Browser uses a JavaScript snippet (or \"agent\") to instrument your app's webpages. The JavaScript collects data for browser monitoring. To install the browser agent, you can choose from a number of deployment options. Tip To use Browser and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Select a deployment option No matter which option you use to deploy browser monitoring, the end result is to inject the browser agent's JavaScript snippet into your pages for browser monitoring. The method you select depends on your preferences and business needs. To view the procedure to install and enable the browser agent, click the link for the option you want to use. You can also use the Browser Application settings page to update settings. Important The following configuration options refer only to the browser monitoring agent. These are not the same as the New Relic user roles and editions. Browser deployment option Description Use the APM agent to inject the JavaScript You can use an APM agent to automatically inject the browser monitoring JavaScript snippet for you. This is the easiest way to install the agent for an app that already is being monitored by APM. (APM-monitored apps are listed on your APM Applications index.) Paste the JavaScript snippet into a webpage This allows you to control the exact placement of the JavaScript into your app's webpage(s) by copying and pasting the browser agent's JavaScript snippet. This is useful for: Standalone apps, static sites, and cached pages delivered by CDN APM apps that are not as closely coupled to the browser app as with a standard server-side app (for example, when your client-side app talks to a REST API back end) Enable single-page app (SPA) monitoring Enabling SPA requires a Pro + SPA browser agent subscription, and you may need to re-deploy the browser JavaScript agent. Use the REST API The REST API lets you manage deployment outside the browser UI. This is useful for large organizations deploying multiple apps. Use an APM agent API to manually instrument the JavaScript snippet For apps that are monitored by APM, you can use the APM agent's API to inject the JavaScript manually instead of automatically. Enable an APM-monitored app Use this procedure to automatically deploy the browser agent on an app that is monitored by APM: Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Enable via New Relic APM. In the Choose your instrumentation section, select Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Select your application section, type or use the search window to find an app's name. Click Enable. Important Node.js: To finish enabling the browser agent for a Node.js app, follow the additional procedure to insert the JavaScript header into the beginning of your HTML page's head tag. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. Enable with copy/paste Use this procedure to insert browser's JavaScript snippet for browser monitoring into your app's webpages yourself. This option is useful for monitoring static sites (such as Jekyll) or cached pages delivered by CDN. Tip Near the bottom of the generated JavaScript is your browser license key and application ID. This is useful with the REST API and API Explorer. Go to one.newrelic.com, select Browser, and then select Add more data. In the Back-end, front-end, and mobile applications section, select the New Relic Browser tile. When prompted to select the account you want to add this instrumentation to, choose your account, and click Continue. From the Get started with New Relic Browser page, in the Choose a deployment method section, select Copy/Paste JavaScript Code. In the Choose your instrumentation section, select the type of agent: Lite, Pro, or Pro + SPA. In the Configure your instrumentation section, make the selections you want. In the Name your app section, name your app: If your app is monitored by APM, select Yes, then type or use the search window to find the app's name. If you have a standalone app for Browser (not monitored by APM), select No, then type the app's name. Click Enable. A new section, Instrument the agent, opens on the page with JavaScript code for your project. Copy the code snippet, then paste it inline into your pages as close to the top of the <head> element as possible, but after any position-sensitive <meta> tags (for example, X-UA-Compatible or charset information). For more information on the inline head placement, see JavaScript placement requirements. Generate some traffic for your app. Wait a few minutes for Browser to start collecting data, then select your app from the Browser applications index. If you use the copy/paste method, but don't finish the setup process, you can still view and copy the generated JavaScript snippet from your app's Browser Application settings page or by using the REST API (v2). Instrument webpages using the APM agent This information applies to apps that are also monitored by APM. New Relic's agents can instrument webpages with the required JavaScript for page load timing. If you use the APM agent to add the JavaScript snippet to your webpages, insert the instrumentation snippet as close to the top as possible. This allows you to take advantage of detailed information about browser's AJAX calls and JavaScript errors. For more information, see the instructions for your APM agent: C SDK Go Java .NET Node.js PHP Python Ruby Troubleshoot Browser agent installation When you enable browser Pro features for session traces, AJAX calls, or JavaScript errors, it may take approximately five minutes before information becomes available. If you have problems with your browser installation or if no data appears after five minutes, refer to the troubleshooting tips, and restart your agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 128.40483,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install the <em>browser</em> <em>monitoring</em> agent",
        "sections": "Install the <em>browser</em> <em>monitoring</em> agent",
        "tags": "<em>Browser</em> <em>monitoring</em>",
        "body": " PHP Python Ruby <em>Troubleshoot</em> <em>Browser</em> agent installation When you enable <em>browser</em> Pro features for session traces, AJAX calls, or JavaScript errors, it may take approximately five minutes before information becomes available. If you have problems with your <em>browser</em> installation or if no data appears after five minutes, refer to the <em>troubleshooting</em> tips, and restart your agent."
      },
      "id": "604429e628ccbcb80b2c60d0"
    }
  ]
}