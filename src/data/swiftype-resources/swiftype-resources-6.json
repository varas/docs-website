{
  "/docs/agents/ruby-agent/background-jobs/rake-instrumentation": [
    {
      "sections": [
        "Monitor Ruby background processes",
        "Supported frameworks",
        "Important",
        "Monitor custom background jobs",
        "Monitor custom background methods",
        "Monitor short-lived processes",
        "Configure newrelic.yml for background processes",
        "Non-Rails background application",
        "Background job environment monitored by New Relic",
        "Report to an alternate application name",
        "Ensure the agent starts",
        "Non-Rails standalone script",
        "Background tasks with daemons gem",
        "Monitor scripts",
        "For more help"
      ],
      "title": "Monitor Ruby background processes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Background jobs"
      ],
      "external_id": "72fb23aadf860f8618b7d775a5cb74e798d2fdcd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/background-jobs/monitor-ruby-background-processes/",
      "published_at": "2021-06-02T22:17:51Z",
      "updated_at": "2021-03-16T07:56:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Ruby agent automatically instruments several common background job frameworks. You can also customize it to trace any background tasks. Data from background jobs appears in the Transactions page in APM as Non-web transactions. Supported frameworks The following background job frameworks are supported by default in recent versions of the Ruby agent: Resque instrumentation (Ruby agent 3.4.0) Sidekiq instrumentation (Ruby agent 3.6.0) Delayed::Job instrumentation (Ruby agent 2.10) Important JRuby users may see issues with CPU metrics. If you are using these frameworks, monitoring background jobs typically doesn't require additional configuration. Monitor custom background jobs You can instrument custom background jobs to appear in the APM Transactions page as Non-web transactions. To monitor Non-web transactions while using an unsupported framework, you must add custom instrumentation. As an example, a background job periodically runs a task called SalesOrganization#find_new_leads. Add the ControllerInstrumentation module. Use the add_transaction_tracer directive below the method definition Add :category => :task to tell the agent this trace is a Non-web transaction. require 'newrelic_rpm' class SalesOrganization include ::NewRelic::Agent::Instrumentation::ControllerInstrumentation def find_new_leads ... end add_transaction_tracer :find_new_leads, :category => :task end Copy You can pass a string to the :category, but values will only appear on the APM Transactions page if the string begins with OtherTransaction/. Monitor custom background methods Using the Ruby agent API, you can designate specific methods to trace the Non-web transactions. This gathers traces for slow running jobs and associates captured errors to transactions. To instrument a class method, use the class singleton. As an example, a background job periodically runs a task called SalesOrganization#find_new_leads. Add the ControllerInstrumentation module below the method definition. Use the add_transaction_tracer directive Add :category => :task to tell the agent this trace is a Non-web transaction. require 'newrelic_rpm' class SalesOrganization def self.find_new_leads ... end class << self include ::NewRelic::Agent::Instrumentation::ControllerInstrumentation add_transaction_tracer :find_new_leads, :category => :task end end Copy For more information, see Ruby custom metrics. Monitor short-lived processes Make sure the process isn't running before the agent connects to the back-end servers. To do so, make the Ruby agent synchronously connect to New Relic, rather than the default asynchronous behavior. Use manual_start and pass in the :sync_startup => true option: require 'new_relic/agent' NewRelic::Agent.manual_start(:sync_startup => true) Copy Using require 'new_relic/agent' will require the agent's code, and it will make sure the agent doesn't run until you manually start it. If the process is shorter than the agent harvest cycle, you need to manually shut down the agent with ::NewRelic::Agents.shutdown to ensure all queued data is sent. Configure newrelic.yml for background processes Configuring your newrelic.yml depends on the context of the background application. Non-Rails background application If your background app is non-Rails application already running the Ruby agent, copy your newrelic.yml file to the directory where you launch the background job or in the config subdirectory. Make sure it includes your license key. Background jobs that do not run in a Rails context will examine the NEW_RELIC_ENV environment variable to determine which section of the configuration file to read, falling back to the RUBY_ENV, RAILS_ENV, and RACK_ENV environment variables in sequence, and finally defaulting to development if none of these environment variables are set. Background job environment monitored by New Relic If your background job runs in the context of an existing web application that is already monitored with New Relic, the Ruby agent will automatically pick up your existing newrelic.yml file. Background jobs that boot your application's Rails environment will use the RAILS_ENV environment variable in order to determine which section of the newrelic.yml file to read. Report to an alternate application name You can make jobs that run in the context of an existing New Relic web application appear under a different application name in the APM UI. Begin before newrelic_rpm gets required by your worker code. Set the NEW_RELIC_APP_NAME environment variable to the application name to use for your background jobs when starting your background worker processes. This will override the app_name setting in your newrelic.yml. $ NEW_RELIC_APP_NAME=\"My Background Jobs\" ./bin/my_background_worker.rb Copy Ensure the agent starts The Ruby agent will automatically start in most cases as soon as you require 'newrelic_rpm', unless the agent detects a blacklisted executable name, rake task name, or constant. This prevents it from starting during common rake tasks and interactive console sessions. Non-Rails standalone script Standalone scripts running without Rails generally will start the agent as soon as they require 'newrelic_rpm'. If you have a script that forks or daemonizes before it begins its main work, you may want to defer this require call until after the initial setup finishes. Background tasks with daemons gem If you use the daemons gem to start background tasks, the Ruby agent may fail to start and also not emit any logging. This happens because the daemons gem changes the working directory to / before executing your background code. The agent then attempts to resolve the paths to its configuration file and log file relative to the current working directory of the host process. To allow the agent to start in this situation, set environment variables with the locations of the agent configuration file and log file; for example: ENV['NRCONFIG'] ||= File.dirname(__FILE__) + '/../../config/newrelic.yml' ENV['NEW_RELIC_LOG'] ||= File.dirname(__FILE__) + '/../../log/newrelic_agent.log' Copy For more information, see the documentation about controlling agent startup Monitor scripts The agent startup instructions apply when running background jobs in a daemon. If a script executes a single background task and exits, manually shut down the agent with ::NewRelic::Agents.shutdown when the script finishes. This ensures the New Relic collector receives the data. For example: require 'newrelic_rpm' class SalesOrganization include ::NewRelic::Agent::Instrumentation::ControllerInstrumentation def find_new_leads ... end add_transaction_tracer :find_new_leads, :category => :task end SalesOrganization.new.find_new_leads ::NewRelic::Agent.shutdown Copy For more help Additional documentation resources include: Ruby custom metrics (method tracers, metric names, stats, examples Ruby agent API (public API methods for the New Relic Ruby agent)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.49524,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Monitor <em>Ruby</em> <em>background</em> processes",
        "sections": "Monitor custom <em>background</em> <em>jobs</em>",
        "tags": "<em>Background</em> <em>jobs</em>",
        "body": "Our <em>Ruby</em> <em>agent</em> automatically instruments several common <em>background</em> <em>job</em> frameworks. You can also customize it to trace any <em>background</em> tasks. Data from <em>background</em> <em>jobs</em> appears in the Transactions page in APM as Non-web transactions. Supported frameworks The following <em>background</em> <em>job</em> frameworks"
      },
      "id": "603ebccf28ccbca804eba7b4"
    },
    {
      "sections": [
        "Sidekiq instrumentation",
        "Capture job arguments",
        "Tip",
        "Troubleshoot Sidekiq jobs"
      ],
      "title": "Sidekiq instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Background jobs"
      ],
      "external_id": "731a708841b1a18ecb19a0e60bf39d16cc8824c5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/background-jobs/sidekiq-instrumentation/",
      "published_at": "2021-06-02T22:18:43Z",
      "updated_at": "2021-03-16T06:42:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In addition to your web application itself, the New Relic Ruby agent (version 3.6.0 or higher) can automatically instrument your Sidekiq jobs. You do not need to include an instrumentation library in your worker. The Ruby agent will instrument the perform method on all Sidekiq workers. Data for background jobs appears in APM's Transactions page, complete with transaction traces and errors, by selecting Non-web transactions as the transaction type. Capture job arguments Starting with Ruby agent version 3.6.9, you can optionally configure the Ruby agent to capture Sidekiq job arguments in transaction traces and traced errors. This can be especially useful in attempting to reproduce failed jobs. By default this feature is off in case your job arguments contain sensitive information. To enable this feature, edit your newrelic.yml as appropriate for your agent version: newrelic_rpm 3.12.0 or higher: attributes.include: job.sidekiq.args.* newrelic_rpm 3.6.9 to 3.11.x: sidekiq.capture_params: true Tip This feature is distinct from the generic capture_params top-level setting, which controls whether HTTP request parameters are captured on transaction traces and traced errors for web requests. You can configure these two settings independently. Troubleshoot Sidekiq jobs If it appears that jobs are not being monitored, review your newrelic_agent.log file generated when the worker starts. It should indicate whether the agent detects Sidekiq and communicates with the server. If you need support, note the exact command line that you used to start Sidekiq.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 158.42685,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Troubleshoot Sidekiq <em>jobs</em>",
        "tags": "<em>Background</em> <em>jobs</em>",
        "body": " for <em>background</em> <em>jobs</em> appears in APM&#x27;s Transactions page, complete with transaction traces and errors, by selecting Non-web transactions as the transaction type. Capture <em>job</em> arguments Starting with <em>Ruby</em> <em>agent</em> version 3.6.9, you can optionally configure the <em>Ruby</em> <em>agent</em> to capture Sidekiq <em>job</em> arguments"
      },
      "id": "603ebccf64441f81034e8852"
    },
    {
      "sections": [
        "Resque instrumentation",
        "Capturing job arguments",
        "Resque versions 1.23.1 or higher",
        "Alternate forking modes",
        "Old Resque versions (< 1.23.1)",
        "Deadlocking jobs"
      ],
      "title": "Resque instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Background jobs"
      ],
      "external_id": "c9fc14a5f737d8d9b07d1beae24aa8fd8d030268",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/background-jobs/resque-instrumentation/",
      "published_at": "2021-06-02T21:53:51Z",
      "updated_at": "2021-03-16T06:55:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In addition to your web application itself, the New Relic Ruby agent can also instrument your Resque jobs. Capturing job arguments Starting with Ruby agent version 3.6.9, you can optionally configure the Ruby agent to capture Resque job arguments in transaction traces and traced errors. This can be especially useful in attempting to reproduce failed jobs. By default this feature is off in case your job arguments contain sensitive information. To enable this feature, edit your newrelic.yml as appropriate for your agent version: For newrelic_rpm 3.12.0 or higher: attributes.include: job.resque.args.* For newrelic_rpm 3.6.9 to 3.11.X: resque.capture_params: true This feature is distinct from the generic capture_params top-level setting, which controls whether HTTP request parameters are captured on transaction traces and traced errors for web requests. You can configure these two settings independently. Resque versions 1.23.1 or higher If you are running Resque 1.23.1 or higher, you should not need to make any code changes outside of the normal agent installation procedures in order for New Relic's Resque instrumentation to work. Exception: If you have leftover calls to NewRelic::Agent methods from your Resque before_first_fork, before_fork, or after_fork hooks from when you were running an older version of Resque, be sure to remove those calls after upgrading to Resque 1.23.1 or higher. Alternate forking modes The resque-multi-job-forks or resque-jobs-per-fork gems change the forking behavior of Resque so that it will not fork for each individual job, but instead fork once per batch of jobs. Similarly, you can set the FORK_PER_JOB environment variable to false in order to completely disable forking in Resque. If you use any of these alternate forking modes in your application, make sure you are running Ruby agent version 3.9.7 or higher. Earlier versions of the Ruby agent do not work correctly with these alternate forking modes. If you are upgrading to 3.9.7 or higher, make sure to remove any direct calls to NewRelic::Agent methods such as manual_start or after_fork that you may have previously been using in order to get the agent to work in these environments. Old Resque versions ( < 1.23.1) It is possible to use New Relic's Ruby agent with Resque versions older than 1.23.1. However, New Relic recommends that you upgrade to Resque 1.23.1 or higher for best results. Many applications use the hooks exposed by Resque (before_fork, after_fork, etc.) in order to inject custom code at critical points during the lifetime of Resque jobs. The New Relic Ruby agent also must use these hooks in order to be able to place its instrumentation. Resque versions before 1.23.1 do not allow hooks to be defined multiple times; the last definition will take precedence. If you cannot upgrade to a Resque version >= 1.23.1 (which allows hooks to be defined multiple times without overwriting each other), you can modify your custom Resque hooks by adding the necessary New Relic code. Here is an example. Example: Modifying custom Resque hooks You may omit definitions for any hooks that you have no custom code for. They will be automatically installed by the agent in this case. Resque.before_first_fork do # ... your custom hook code ... NewRelic::Agent.manual_start(:dispatcher => :resque, :sync_startup => true, :start_channel_listener => true) end Resque.before_fork do |job| # ... your custom hook code ... NewRelic::Agent.register_report_channel(job.object_id) end Resque.after_fork do |job| # ... your custom hook code ... NewRelic::Agent.after_fork(:report_to_channel => job.object_id, :report_instance_busy => false) end Copy Deadlocking jobs Some customers (particularly those with very high job throughput) have reported intermittent deadlocks in their Resque worker processes with the Ruby agent enabled. These deadlocks are due to a bad interaction between the background thread that the Ruby agent uses to send data to New Relic servers and Resque's forking behavior. Use either of these options to resolve these issues: Disable Resque's forking behavior by setting the FORK_PER_JOB environment variable to false when spawning Resque processes. Use the resolv-replace library from Ruby's standard library to replace Ruby's native DNS resolution code with a pure Ruby version. The Ruby agent uses a background thread in the Resque master process to send data to the New Relic collector. In some environments, this thread will acquire a native lock during DNS resolution (when resolving the hostnames of New Relic collectors). If this native lock is held by the background thread while the main Resque master process's main thread calls fork to create a child process, it will still be marked as held in the forked child process. However, since fork only copies the calling thread, the background thread that was holding the native lock will not exist in the child process, and thus the native lock will never be released. If the child process attempts to do any DNS resolution, it will attempt to acquire the same native lock and deadlock. To avoid this Github issue, use resolv-replace instead of Ruby's default DNS resolution path.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.49734,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Deadlocking <em>jobs</em>",
        "tags": "<em>Background</em> <em>jobs</em>",
        "body": "In addition to your web application itself, the New Relic <em>Ruby</em> <em>agent</em> can also instrument your Resque <em>jobs</em>. Capturing <em>job</em> arguments Starting with <em>Ruby</em> <em>agent</em> version 3.6.9, you can optionally configure the <em>Ruby</em> <em>agent</em> to capture Resque <em>job</em> arguments in transaction traces and traced errors. This can"
      },
      "id": "603ebccf64441f10384e88b2"
    }
  ],
  "/docs/agents/ruby-agent/background-jobs/resque-instrumentation": [
    {
      "sections": [
        "Monitor Ruby background processes",
        "Supported frameworks",
        "Important",
        "Monitor custom background jobs",
        "Monitor custom background methods",
        "Monitor short-lived processes",
        "Configure newrelic.yml for background processes",
        "Non-Rails background application",
        "Background job environment monitored by New Relic",
        "Report to an alternate application name",
        "Ensure the agent starts",
        "Non-Rails standalone script",
        "Background tasks with daemons gem",
        "Monitor scripts",
        "For more help"
      ],
      "title": "Monitor Ruby background processes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Background jobs"
      ],
      "external_id": "72fb23aadf860f8618b7d775a5cb74e798d2fdcd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/background-jobs/monitor-ruby-background-processes/",
      "published_at": "2021-06-02T22:17:51Z",
      "updated_at": "2021-03-16T07:56:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Ruby agent automatically instruments several common background job frameworks. You can also customize it to trace any background tasks. Data from background jobs appears in the Transactions page in APM as Non-web transactions. Supported frameworks The following background job frameworks are supported by default in recent versions of the Ruby agent: Resque instrumentation (Ruby agent 3.4.0) Sidekiq instrumentation (Ruby agent 3.6.0) Delayed::Job instrumentation (Ruby agent 2.10) Important JRuby users may see issues with CPU metrics. If you are using these frameworks, monitoring background jobs typically doesn't require additional configuration. Monitor custom background jobs You can instrument custom background jobs to appear in the APM Transactions page as Non-web transactions. To monitor Non-web transactions while using an unsupported framework, you must add custom instrumentation. As an example, a background job periodically runs a task called SalesOrganization#find_new_leads. Add the ControllerInstrumentation module. Use the add_transaction_tracer directive below the method definition Add :category => :task to tell the agent this trace is a Non-web transaction. require 'newrelic_rpm' class SalesOrganization include ::NewRelic::Agent::Instrumentation::ControllerInstrumentation def find_new_leads ... end add_transaction_tracer :find_new_leads, :category => :task end Copy You can pass a string to the :category, but values will only appear on the APM Transactions page if the string begins with OtherTransaction/. Monitor custom background methods Using the Ruby agent API, you can designate specific methods to trace the Non-web transactions. This gathers traces for slow running jobs and associates captured errors to transactions. To instrument a class method, use the class singleton. As an example, a background job periodically runs a task called SalesOrganization#find_new_leads. Add the ControllerInstrumentation module below the method definition. Use the add_transaction_tracer directive Add :category => :task to tell the agent this trace is a Non-web transaction. require 'newrelic_rpm' class SalesOrganization def self.find_new_leads ... end class << self include ::NewRelic::Agent::Instrumentation::ControllerInstrumentation add_transaction_tracer :find_new_leads, :category => :task end end Copy For more information, see Ruby custom metrics. Monitor short-lived processes Make sure the process isn't running before the agent connects to the back-end servers. To do so, make the Ruby agent synchronously connect to New Relic, rather than the default asynchronous behavior. Use manual_start and pass in the :sync_startup => true option: require 'new_relic/agent' NewRelic::Agent.manual_start(:sync_startup => true) Copy Using require 'new_relic/agent' will require the agent's code, and it will make sure the agent doesn't run until you manually start it. If the process is shorter than the agent harvest cycle, you need to manually shut down the agent with ::NewRelic::Agents.shutdown to ensure all queued data is sent. Configure newrelic.yml for background processes Configuring your newrelic.yml depends on the context of the background application. Non-Rails background application If your background app is non-Rails application already running the Ruby agent, copy your newrelic.yml file to the directory where you launch the background job or in the config subdirectory. Make sure it includes your license key. Background jobs that do not run in a Rails context will examine the NEW_RELIC_ENV environment variable to determine which section of the configuration file to read, falling back to the RUBY_ENV, RAILS_ENV, and RACK_ENV environment variables in sequence, and finally defaulting to development if none of these environment variables are set. Background job environment monitored by New Relic If your background job runs in the context of an existing web application that is already monitored with New Relic, the Ruby agent will automatically pick up your existing newrelic.yml file. Background jobs that boot your application's Rails environment will use the RAILS_ENV environment variable in order to determine which section of the newrelic.yml file to read. Report to an alternate application name You can make jobs that run in the context of an existing New Relic web application appear under a different application name in the APM UI. Begin before newrelic_rpm gets required by your worker code. Set the NEW_RELIC_APP_NAME environment variable to the application name to use for your background jobs when starting your background worker processes. This will override the app_name setting in your newrelic.yml. $ NEW_RELIC_APP_NAME=\"My Background Jobs\" ./bin/my_background_worker.rb Copy Ensure the agent starts The Ruby agent will automatically start in most cases as soon as you require 'newrelic_rpm', unless the agent detects a blacklisted executable name, rake task name, or constant. This prevents it from starting during common rake tasks and interactive console sessions. Non-Rails standalone script Standalone scripts running without Rails generally will start the agent as soon as they require 'newrelic_rpm'. If you have a script that forks or daemonizes before it begins its main work, you may want to defer this require call until after the initial setup finishes. Background tasks with daemons gem If you use the daemons gem to start background tasks, the Ruby agent may fail to start and also not emit any logging. This happens because the daemons gem changes the working directory to / before executing your background code. The agent then attempts to resolve the paths to its configuration file and log file relative to the current working directory of the host process. To allow the agent to start in this situation, set environment variables with the locations of the agent configuration file and log file; for example: ENV['NRCONFIG'] ||= File.dirname(__FILE__) + '/../../config/newrelic.yml' ENV['NEW_RELIC_LOG'] ||= File.dirname(__FILE__) + '/../../log/newrelic_agent.log' Copy For more information, see the documentation about controlling agent startup Monitor scripts The agent startup instructions apply when running background jobs in a daemon. If a script executes a single background task and exits, manually shut down the agent with ::NewRelic::Agents.shutdown when the script finishes. This ensures the New Relic collector receives the data. For example: require 'newrelic_rpm' class SalesOrganization include ::NewRelic::Agent::Instrumentation::ControllerInstrumentation def find_new_leads ... end add_transaction_tracer :find_new_leads, :category => :task end SalesOrganization.new.find_new_leads ::NewRelic::Agent.shutdown Copy For more help Additional documentation resources include: Ruby custom metrics (method tracers, metric names, stats, examples Ruby agent API (public API methods for the New Relic Ruby agent)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.49524,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Monitor <em>Ruby</em> <em>background</em> processes",
        "sections": "Monitor custom <em>background</em> <em>jobs</em>",
        "tags": "<em>Background</em> <em>jobs</em>",
        "body": "Our <em>Ruby</em> <em>agent</em> automatically instruments several common <em>background</em> <em>job</em> frameworks. You can also customize it to trace any <em>background</em> tasks. Data from <em>background</em> <em>jobs</em> appears in the Transactions page in APM as Non-web transactions. Supported frameworks The following <em>background</em> <em>job</em> frameworks"
      },
      "id": "603ebccf28ccbca804eba7b4"
    },
    {
      "sections": [
        "Sidekiq instrumentation",
        "Capture job arguments",
        "Tip",
        "Troubleshoot Sidekiq jobs"
      ],
      "title": "Sidekiq instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Background jobs"
      ],
      "external_id": "731a708841b1a18ecb19a0e60bf39d16cc8824c5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/background-jobs/sidekiq-instrumentation/",
      "published_at": "2021-06-02T22:18:43Z",
      "updated_at": "2021-03-16T06:42:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In addition to your web application itself, the New Relic Ruby agent (version 3.6.0 or higher) can automatically instrument your Sidekiq jobs. You do not need to include an instrumentation library in your worker. The Ruby agent will instrument the perform method on all Sidekiq workers. Data for background jobs appears in APM's Transactions page, complete with transaction traces and errors, by selecting Non-web transactions as the transaction type. Capture job arguments Starting with Ruby agent version 3.6.9, you can optionally configure the Ruby agent to capture Sidekiq job arguments in transaction traces and traced errors. This can be especially useful in attempting to reproduce failed jobs. By default this feature is off in case your job arguments contain sensitive information. To enable this feature, edit your newrelic.yml as appropriate for your agent version: newrelic_rpm 3.12.0 or higher: attributes.include: job.sidekiq.args.* newrelic_rpm 3.6.9 to 3.11.x: sidekiq.capture_params: true Tip This feature is distinct from the generic capture_params top-level setting, which controls whether HTTP request parameters are captured on transaction traces and traced errors for web requests. You can configure these two settings independently. Troubleshoot Sidekiq jobs If it appears that jobs are not being monitored, review your newrelic_agent.log file generated when the worker starts. It should indicate whether the agent detects Sidekiq and communicates with the server. If you need support, note the exact command line that you used to start Sidekiq.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 158.42685,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Troubleshoot Sidekiq <em>jobs</em>",
        "tags": "<em>Background</em> <em>jobs</em>",
        "body": " for <em>background</em> <em>jobs</em> appears in APM&#x27;s Transactions page, complete with transaction traces and errors, by selecting Non-web transactions as the transaction type. Capture <em>job</em> arguments Starting with <em>Ruby</em> <em>agent</em> version 3.6.9, you can optionally configure the <em>Ruby</em> <em>agent</em> to capture Sidekiq <em>job</em> arguments"
      },
      "id": "603ebccf64441f81034e8852"
    },
    {
      "sections": [
        "Rake instrumentation",
        "Enable Rake support",
        "Remove newrelic-rake when appropriate",
        "Caution",
        "Capture Rake job arguments"
      ],
      "title": "Rake instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Background jobs"
      ],
      "external_id": "d9f92b20388116f3ad38161c58ea8238e6243c71",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/background-jobs/rake-instrumentation/",
      "published_at": "2021-06-02T22:17:50Z",
      "updated_at": "2021-03-16T07:58:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Ruby agent has opt-in support for instrumenting Rake tasks. This requires: Rake version 10.0.0 or higher Ruby agent version 3.13.0 or higher To instrument Rake tasks, specify the tasks by name in your newrelic.yml file. Enable Rake support To instrument your app's Rake tasks, add the names of the target tasks to the rake.tasks element in your newrelic.yml file. The Ruby agent matches these names against your active tasks using string regex. Example: Instrumenting two Rake tasks For example, to instrument the Rake tasks deploy and deploy:all, add the following to your newrelic.yml file: rake: tasks: [\"deploy\", \"deploy:all\"] Copy Since task name matching is with regex, you can instrument all of your app's Rake tasks by using a wildcard regex like [\".+\"]. However, this will not include Rake tasks that are in your deny list by default from the autostart.blacklisted_rake_tasks configuration setting, such as db:migrate. To include any Rake tasks that are in your deny list by default, include them in your customized deny list. To ensure the tasks are instrumented before they run if you are using Rails but your Rake task does not require the Rails environment, add require 'tasks/newrelic' to the top of the Rake tasks. Remove newrelic-rake when appropriate The newrelic-rake third-party gem provides Rake instrumentation support as an add-on to the Ruby agent. If the agent detects newrelic-rake, it will not install the built-in Rake instrumentation, but it will record a log message like this at startup: INFO : Not installing New Relic supported Rake instrumentation because the third party newrelic-rake gem is present Copy Caution Removing the newrelic-rake gem in favor of the built-in instrumentation will change your transaction names. To preserve your existing transaction names, ignore the log message and do not uninstall the gem. To switch to New Relic's built-in Rake instrumentation and change your transaction names: Remove the newrelic-rake gem. Specify the tasks you want to instrument in your config file. Capture Rake job arguments By default Rake job arguments are not captured. To capture Rake job arguments, use: attributes.include: job.rake.* Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.06483,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Capture Rake <em>job</em> arguments",
        "tags": "<em>Background</em> <em>jobs</em>",
        "body": "The New Relic <em>Ruby</em> <em>agent</em> has opt-in support for instrumenting Rake tasks. This requires: Rake version 10.0.0 or higher <em>Ruby</em> <em>agent</em> version 3.13.0 or higher To instrument Rake tasks, specify the tasks by name in your newrelic.yml file. Enable Rake support To instrument your app&#x27;s Rake tasks, add"
      },
      "id": "603e9fea64441f1e104e8841"
    }
  ],
  "/docs/agents/ruby-agent/background-jobs/sidekiq-instrumentation": [
    {
      "sections": [
        "Monitor Ruby background processes",
        "Supported frameworks",
        "Important",
        "Monitor custom background jobs",
        "Monitor custom background methods",
        "Monitor short-lived processes",
        "Configure newrelic.yml for background processes",
        "Non-Rails background application",
        "Background job environment monitored by New Relic",
        "Report to an alternate application name",
        "Ensure the agent starts",
        "Non-Rails standalone script",
        "Background tasks with daemons gem",
        "Monitor scripts",
        "For more help"
      ],
      "title": "Monitor Ruby background processes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Background jobs"
      ],
      "external_id": "72fb23aadf860f8618b7d775a5cb74e798d2fdcd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/background-jobs/monitor-ruby-background-processes/",
      "published_at": "2021-06-02T22:17:51Z",
      "updated_at": "2021-03-16T07:56:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Ruby agent automatically instruments several common background job frameworks. You can also customize it to trace any background tasks. Data from background jobs appears in the Transactions page in APM as Non-web transactions. Supported frameworks The following background job frameworks are supported by default in recent versions of the Ruby agent: Resque instrumentation (Ruby agent 3.4.0) Sidekiq instrumentation (Ruby agent 3.6.0) Delayed::Job instrumentation (Ruby agent 2.10) Important JRuby users may see issues with CPU metrics. If you are using these frameworks, monitoring background jobs typically doesn't require additional configuration. Monitor custom background jobs You can instrument custom background jobs to appear in the APM Transactions page as Non-web transactions. To monitor Non-web transactions while using an unsupported framework, you must add custom instrumentation. As an example, a background job periodically runs a task called SalesOrganization#find_new_leads. Add the ControllerInstrumentation module. Use the add_transaction_tracer directive below the method definition Add :category => :task to tell the agent this trace is a Non-web transaction. require 'newrelic_rpm' class SalesOrganization include ::NewRelic::Agent::Instrumentation::ControllerInstrumentation def find_new_leads ... end add_transaction_tracer :find_new_leads, :category => :task end Copy You can pass a string to the :category, but values will only appear on the APM Transactions page if the string begins with OtherTransaction/. Monitor custom background methods Using the Ruby agent API, you can designate specific methods to trace the Non-web transactions. This gathers traces for slow running jobs and associates captured errors to transactions. To instrument a class method, use the class singleton. As an example, a background job periodically runs a task called SalesOrganization#find_new_leads. Add the ControllerInstrumentation module below the method definition. Use the add_transaction_tracer directive Add :category => :task to tell the agent this trace is a Non-web transaction. require 'newrelic_rpm' class SalesOrganization def self.find_new_leads ... end class << self include ::NewRelic::Agent::Instrumentation::ControllerInstrumentation add_transaction_tracer :find_new_leads, :category => :task end end Copy For more information, see Ruby custom metrics. Monitor short-lived processes Make sure the process isn't running before the agent connects to the back-end servers. To do so, make the Ruby agent synchronously connect to New Relic, rather than the default asynchronous behavior. Use manual_start and pass in the :sync_startup => true option: require 'new_relic/agent' NewRelic::Agent.manual_start(:sync_startup => true) Copy Using require 'new_relic/agent' will require the agent's code, and it will make sure the agent doesn't run until you manually start it. If the process is shorter than the agent harvest cycle, you need to manually shut down the agent with ::NewRelic::Agents.shutdown to ensure all queued data is sent. Configure newrelic.yml for background processes Configuring your newrelic.yml depends on the context of the background application. Non-Rails background application If your background app is non-Rails application already running the Ruby agent, copy your newrelic.yml file to the directory where you launch the background job or in the config subdirectory. Make sure it includes your license key. Background jobs that do not run in a Rails context will examine the NEW_RELIC_ENV environment variable to determine which section of the configuration file to read, falling back to the RUBY_ENV, RAILS_ENV, and RACK_ENV environment variables in sequence, and finally defaulting to development if none of these environment variables are set. Background job environment monitored by New Relic If your background job runs in the context of an existing web application that is already monitored with New Relic, the Ruby agent will automatically pick up your existing newrelic.yml file. Background jobs that boot your application's Rails environment will use the RAILS_ENV environment variable in order to determine which section of the newrelic.yml file to read. Report to an alternate application name You can make jobs that run in the context of an existing New Relic web application appear under a different application name in the APM UI. Begin before newrelic_rpm gets required by your worker code. Set the NEW_RELIC_APP_NAME environment variable to the application name to use for your background jobs when starting your background worker processes. This will override the app_name setting in your newrelic.yml. $ NEW_RELIC_APP_NAME=\"My Background Jobs\" ./bin/my_background_worker.rb Copy Ensure the agent starts The Ruby agent will automatically start in most cases as soon as you require 'newrelic_rpm', unless the agent detects a blacklisted executable name, rake task name, or constant. This prevents it from starting during common rake tasks and interactive console sessions. Non-Rails standalone script Standalone scripts running without Rails generally will start the agent as soon as they require 'newrelic_rpm'. If you have a script that forks or daemonizes before it begins its main work, you may want to defer this require call until after the initial setup finishes. Background tasks with daemons gem If you use the daemons gem to start background tasks, the Ruby agent may fail to start and also not emit any logging. This happens because the daemons gem changes the working directory to / before executing your background code. The agent then attempts to resolve the paths to its configuration file and log file relative to the current working directory of the host process. To allow the agent to start in this situation, set environment variables with the locations of the agent configuration file and log file; for example: ENV['NRCONFIG'] ||= File.dirname(__FILE__) + '/../../config/newrelic.yml' ENV['NEW_RELIC_LOG'] ||= File.dirname(__FILE__) + '/../../log/newrelic_agent.log' Copy For more information, see the documentation about controlling agent startup Monitor scripts The agent startup instructions apply when running background jobs in a daemon. If a script executes a single background task and exits, manually shut down the agent with ::NewRelic::Agents.shutdown when the script finishes. This ensures the New Relic collector receives the data. For example: require 'newrelic_rpm' class SalesOrganization include ::NewRelic::Agent::Instrumentation::ControllerInstrumentation def find_new_leads ... end add_transaction_tracer :find_new_leads, :category => :task end SalesOrganization.new.find_new_leads ::NewRelic::Agent.shutdown Copy For more help Additional documentation resources include: Ruby custom metrics (method tracers, metric names, stats, examples Ruby agent API (public API methods for the New Relic Ruby agent)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 159.49524,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Monitor <em>Ruby</em> <em>background</em> processes",
        "sections": "Monitor custom <em>background</em> <em>jobs</em>",
        "tags": "<em>Background</em> <em>jobs</em>",
        "body": "Our <em>Ruby</em> <em>agent</em> automatically instruments several common <em>background</em> <em>job</em> frameworks. You can also customize it to trace any <em>background</em> tasks. Data from <em>background</em> <em>jobs</em> appears in the Transactions page in APM as Non-web transactions. Supported frameworks The following <em>background</em> <em>job</em> frameworks"
      },
      "id": "603ebccf28ccbca804eba7b4"
    },
    {
      "sections": [
        "Resque instrumentation",
        "Capturing job arguments",
        "Resque versions 1.23.1 or higher",
        "Alternate forking modes",
        "Old Resque versions (< 1.23.1)",
        "Deadlocking jobs"
      ],
      "title": "Resque instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Background jobs"
      ],
      "external_id": "c9fc14a5f737d8d9b07d1beae24aa8fd8d030268",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/background-jobs/resque-instrumentation/",
      "published_at": "2021-06-02T21:53:51Z",
      "updated_at": "2021-03-16T06:55:38Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In addition to your web application itself, the New Relic Ruby agent can also instrument your Resque jobs. Capturing job arguments Starting with Ruby agent version 3.6.9, you can optionally configure the Ruby agent to capture Resque job arguments in transaction traces and traced errors. This can be especially useful in attempting to reproduce failed jobs. By default this feature is off in case your job arguments contain sensitive information. To enable this feature, edit your newrelic.yml as appropriate for your agent version: For newrelic_rpm 3.12.0 or higher: attributes.include: job.resque.args.* For newrelic_rpm 3.6.9 to 3.11.X: resque.capture_params: true This feature is distinct from the generic capture_params top-level setting, which controls whether HTTP request parameters are captured on transaction traces and traced errors for web requests. You can configure these two settings independently. Resque versions 1.23.1 or higher If you are running Resque 1.23.1 or higher, you should not need to make any code changes outside of the normal agent installation procedures in order for New Relic's Resque instrumentation to work. Exception: If you have leftover calls to NewRelic::Agent methods from your Resque before_first_fork, before_fork, or after_fork hooks from when you were running an older version of Resque, be sure to remove those calls after upgrading to Resque 1.23.1 or higher. Alternate forking modes The resque-multi-job-forks or resque-jobs-per-fork gems change the forking behavior of Resque so that it will not fork for each individual job, but instead fork once per batch of jobs. Similarly, you can set the FORK_PER_JOB environment variable to false in order to completely disable forking in Resque. If you use any of these alternate forking modes in your application, make sure you are running Ruby agent version 3.9.7 or higher. Earlier versions of the Ruby agent do not work correctly with these alternate forking modes. If you are upgrading to 3.9.7 or higher, make sure to remove any direct calls to NewRelic::Agent methods such as manual_start or after_fork that you may have previously been using in order to get the agent to work in these environments. Old Resque versions ( < 1.23.1) It is possible to use New Relic's Ruby agent with Resque versions older than 1.23.1. However, New Relic recommends that you upgrade to Resque 1.23.1 or higher for best results. Many applications use the hooks exposed by Resque (before_fork, after_fork, etc.) in order to inject custom code at critical points during the lifetime of Resque jobs. The New Relic Ruby agent also must use these hooks in order to be able to place its instrumentation. Resque versions before 1.23.1 do not allow hooks to be defined multiple times; the last definition will take precedence. If you cannot upgrade to a Resque version >= 1.23.1 (which allows hooks to be defined multiple times without overwriting each other), you can modify your custom Resque hooks by adding the necessary New Relic code. Here is an example. Example: Modifying custom Resque hooks You may omit definitions for any hooks that you have no custom code for. They will be automatically installed by the agent in this case. Resque.before_first_fork do # ... your custom hook code ... NewRelic::Agent.manual_start(:dispatcher => :resque, :sync_startup => true, :start_channel_listener => true) end Resque.before_fork do |job| # ... your custom hook code ... NewRelic::Agent.register_report_channel(job.object_id) end Resque.after_fork do |job| # ... your custom hook code ... NewRelic::Agent.after_fork(:report_to_channel => job.object_id, :report_instance_busy => false) end Copy Deadlocking jobs Some customers (particularly those with very high job throughput) have reported intermittent deadlocks in their Resque worker processes with the Ruby agent enabled. These deadlocks are due to a bad interaction between the background thread that the Ruby agent uses to send data to New Relic servers and Resque's forking behavior. Use either of these options to resolve these issues: Disable Resque's forking behavior by setting the FORK_PER_JOB environment variable to false when spawning Resque processes. Use the resolv-replace library from Ruby's standard library to replace Ruby's native DNS resolution code with a pure Ruby version. The Ruby agent uses a background thread in the Resque master process to send data to the New Relic collector. In some environments, this thread will acquire a native lock during DNS resolution (when resolving the hostnames of New Relic collectors). If this native lock is held by the background thread while the main Resque master process's main thread calls fork to create a child process, it will still be marked as held in the forked child process. However, since fork only copies the calling thread, the background thread that was holding the native lock will not exist in the child process, and thus the native lock will never be released. If the child process attempts to do any DNS resolution, it will attempt to acquire the same native lock and deadlock. To avoid this Github issue, use resolv-replace instead of Ruby's default DNS resolution path.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.49734,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Deadlocking <em>jobs</em>",
        "tags": "<em>Background</em> <em>jobs</em>",
        "body": "In addition to your web application itself, the New Relic <em>Ruby</em> <em>agent</em> can also instrument your Resque <em>jobs</em>. Capturing <em>job</em> arguments Starting with <em>Ruby</em> <em>agent</em> version 3.6.9, you can optionally configure the <em>Ruby</em> <em>agent</em> to capture Resque <em>job</em> arguments in transaction traces and traced errors. This can"
      },
      "id": "603ebccf64441f10384e88b2"
    },
    {
      "sections": [
        "Rake instrumentation",
        "Enable Rake support",
        "Remove newrelic-rake when appropriate",
        "Caution",
        "Capture Rake job arguments"
      ],
      "title": "Rake instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Background jobs"
      ],
      "external_id": "d9f92b20388116f3ad38161c58ea8238e6243c71",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/background-jobs/rake-instrumentation/",
      "published_at": "2021-06-02T22:17:50Z",
      "updated_at": "2021-03-16T07:58:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Ruby agent has opt-in support for instrumenting Rake tasks. This requires: Rake version 10.0.0 or higher Ruby agent version 3.13.0 or higher To instrument Rake tasks, specify the tasks by name in your newrelic.yml file. Enable Rake support To instrument your app's Rake tasks, add the names of the target tasks to the rake.tasks element in your newrelic.yml file. The Ruby agent matches these names against your active tasks using string regex. Example: Instrumenting two Rake tasks For example, to instrument the Rake tasks deploy and deploy:all, add the following to your newrelic.yml file: rake: tasks: [\"deploy\", \"deploy:all\"] Copy Since task name matching is with regex, you can instrument all of your app's Rake tasks by using a wildcard regex like [\".+\"]. However, this will not include Rake tasks that are in your deny list by default from the autostart.blacklisted_rake_tasks configuration setting, such as db:migrate. To include any Rake tasks that are in your deny list by default, include them in your customized deny list. To ensure the tasks are instrumented before they run if you are using Rails but your Rake task does not require the Rails environment, add require 'tasks/newrelic' to the top of the Rake tasks. Remove newrelic-rake when appropriate The newrelic-rake third-party gem provides Rake instrumentation support as an add-on to the Ruby agent. If the agent detects newrelic-rake, it will not install the built-in Rake instrumentation, but it will record a log message like this at startup: INFO : Not installing New Relic supported Rake instrumentation because the third party newrelic-rake gem is present Copy Caution Removing the newrelic-rake gem in favor of the built-in instrumentation will change your transaction names. To preserve your existing transaction names, ignore the log message and do not uninstall the gem. To switch to New Relic's built-in Rake instrumentation and change your transaction names: Remove the newrelic-rake gem. Specify the tasks you want to instrument in your config file. Capture Rake job arguments By default Rake job arguments are not captured. To capture Rake job arguments, use: attributes.include: job.rake.* Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 157.06483,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Capture Rake <em>job</em> arguments",
        "tags": "<em>Background</em> <em>jobs</em>",
        "body": "The New Relic <em>Ruby</em> <em>agent</em> has opt-in support for instrumenting Rake tasks. This requires: Rake version 10.0.0 or higher <em>Ruby</em> <em>agent</em> version 3.13.0 or higher To instrument Rake tasks, specify the tasks by name in your newrelic.yml file. Enable Rake support To instrument your app&#x27;s Rake tasks, add"
      },
      "id": "603e9fea64441f1e104e8841"
    }
  ],
  "/docs/agents/ruby-agent/configuration/connect-hosts-your-account": [
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 165.32825,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Ruby</em> <em>agent</em> attributes",
        "sections": "<em>Ruby</em> <em>agent</em> attributes",
        "tags": "<em>Ruby</em> <em>agent</em>",
        "body": " Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the <em>Ruby</em> <em>agent</em> When upgrading to <em>Ruby</em> <em>agent</em> 3.12.0 or higher, upgrade your newrelic.yml <em>configuration</em>. For more help Additional documentation resources include: <em>Agent</em>"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.15546,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.13449,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Agents</em>",
        "body": " &gt; Transactions &gt; (select a transaction) &gt; (select a trace): Here is an example from the <em>Ruby</em> <em>agent</em> of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your <em>agent</em> and on your attribute <em>configuration</em>. Limits User attributes, request attributes, and message queue"
      },
      "id": "603eb9db28ccbc127aeba79e"
    }
  ],
  "/docs/agents/ruby-agent/configuration/custom-ssl-certificates-ruby": [
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 165.32825,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Ruby</em> <em>agent</em> attributes",
        "sections": "<em>Ruby</em> <em>agent</em> attributes",
        "tags": "<em>Ruby</em> <em>agent</em>",
        "body": " Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the <em>Ruby</em> <em>agent</em> When upgrading to <em>Ruby</em> <em>agent</em> 3.12.0 or higher, upgrade your newrelic.yml <em>configuration</em>. For more help Additional documentation resources include: <em>Agent</em>"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.15546,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.13449,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Agents</em>",
        "body": " &gt; Transactions &gt; (select a transaction) &gt; (select a trace): Here is an example from the <em>Ruby</em> <em>agent</em> of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your <em>agent</em> and on your attribute <em>configuration</em>. Limits User attributes, request attributes, and message queue"
      },
      "id": "603eb9db28ccbc127aeba79e"
    }
  ],
  "/docs/agents/ruby-agent/configuration/ruby-agent-configuration": [
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 165.32825,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Ruby</em> <em>agent</em> attributes",
        "sections": "<em>Ruby</em> <em>agent</em> attributes",
        "tags": "<em>Ruby</em> <em>agent</em>",
        "body": " Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the <em>Ruby</em> <em>agent</em> When upgrading to <em>Ruby</em> <em>agent</em> 3.12.0 or higher, upgrade your newrelic.yml <em>configuration</em>. For more help Additional documentation resources include: <em>Agent</em>"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.15546,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.13449,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Agents</em>",
        "body": " &gt; Transactions &gt; (select a transaction) &gt; (select a trace): Here is an example from the <em>Ruby</em> <em>agent</em> of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your <em>agent</em> and on your attribute <em>configuration</em>. Limits User attributes, request attributes, and message queue"
      },
      "id": "603eb9db28ccbc127aeba79e"
    }
  ],
  "/docs/agents/ruby-agent/features/cross-application-tracing-ruby": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.15533,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.36746,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Ruby</em> <em>agent</em> attributes",
        "sections": "<em>Ruby</em> <em>agent</em> attributes",
        "tags": "<em>Ruby</em> <em>agent</em>",
        "body": " attributes (types, destinations, and limits for attributes used by New Relic <em>agents</em>) Enabling and disabling attributes (properties, rules, and backwards compatibility information for <em>Ruby</em> <em>agent</em> attributes) Attribute examples (scenarios and results of enabling and disabling different <em>Ruby</em> <em>agent</em> attributes)"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.59277,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Agents</em>",
        "body": " an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by <em>agent</em>. (The properties in this diagram are specific to the PHP <em>agent</em>, but the general flow is the same for all <em>agents</em>. Property names and syntax vary by <em>agent</em>.) Types of attributes"
      },
      "id": "603eb9db28ccbc127aeba79e"
    }
  ],
  "/docs/agents/ruby-agent/features/developer-mode": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.15533,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.36746,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Ruby</em> <em>agent</em> attributes",
        "sections": "<em>Ruby</em> <em>agent</em> attributes",
        "tags": "<em>Ruby</em> <em>agent</em>",
        "body": " attributes (types, destinations, and limits for attributes used by New Relic <em>agents</em>) Enabling and disabling attributes (properties, rules, and backwards compatibility information for <em>Ruby</em> <em>agent</em> attributes) Attribute examples (scenarios and results of enabling and disabling different <em>Ruby</em> <em>agent</em> attributes)"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.59277,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Agents</em>",
        "body": " an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by <em>agent</em>. (The properties in this diagram are specific to the PHP <em>agent</em>, but the general flow is the same for all <em>agents</em>. Property names and syntax vary by <em>agent</em>.) Types of attributes"
      },
      "id": "603eb9db28ccbc127aeba79e"
    }
  ],
  "/docs/agents/ruby-agent/features/garbage-collection": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.15521,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.36734,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Ruby</em> <em>agent</em> attributes",
        "sections": "<em>Ruby</em> <em>agent</em> attributes",
        "tags": "<em>Ruby</em> <em>agent</em>",
        "body": " attributes (types, destinations, and limits for attributes used by New Relic <em>agents</em>) Enabling and disabling attributes (properties, rules, and backwards compatibility information for <em>Ruby</em> <em>agent</em> attributes) Attribute examples (scenarios and results of enabling and disabling different <em>Ruby</em> <em>agent</em> attributes)"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.59268,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Agents</em>",
        "body": " an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by <em>agent</em>. (The properties in this diagram are specific to the PHP <em>agent</em>, but the general flow is the same for all <em>agents</em>. Property names and syntax vary by <em>agent</em>.) Types of attributes"
      },
      "id": "603eb9db28ccbc127aeba79e"
    }
  ],
  "/docs/agents/ruby-agent/features/http-client-tracing-ruby": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.15521,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.36734,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Ruby</em> <em>agent</em> attributes",
        "sections": "<em>Ruby</em> <em>agent</em> attributes",
        "tags": "<em>Ruby</em> <em>agent</em>",
        "body": " attributes (types, destinations, and limits for attributes used by New Relic <em>agents</em>) Enabling and disabling attributes (properties, rules, and backwards compatibility information for <em>Ruby</em> <em>agent</em> attributes) Attribute examples (scenarios and results of enabling and disabling different <em>Ruby</em> <em>agent</em> attributes)"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.59268,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Agents</em>",
        "body": " an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by <em>agent</em>. (The properties in this diagram are specific to the PHP <em>agent</em>, but the general flow is the same for all <em>agents</em>. Property names and syntax vary by <em>agent</em>.) Types of attributes"
      },
      "id": "603eb9db28ccbc127aeba79e"
    }
  ],
  "/docs/agents/ruby-agent/features/message-queues": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.15509,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.3672,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Ruby</em> <em>agent</em> attributes",
        "sections": "<em>Ruby</em> <em>agent</em> attributes",
        "tags": "<em>Ruby</em> <em>agent</em>",
        "body": " attributes (types, destinations, and limits for attributes used by New Relic <em>agents</em>) Enabling and disabling attributes (properties, rules, and backwards compatibility information for <em>Ruby</em> <em>agent</em> attributes) Attribute examples (scenarios and results of enabling and disabling different <em>Ruby</em> <em>agent</em> attributes)"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.592575,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Agents</em>",
        "body": " an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by <em>agent</em>. (The properties in this diagram are specific to the PHP <em>agent</em>, but the general flow is the same for all <em>agents</em>. Property names and syntax vary by <em>agent</em>.) Types of attributes"
      },
      "id": "603eb9db28ccbc127aeba79e"
    }
  ],
  "/docs/agents/ruby-agent/features/new-relic-browser-ruby-agent": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.15509,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.3672,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Ruby</em> <em>agent</em> attributes",
        "sections": "<em>Ruby</em> <em>agent</em> attributes",
        "tags": "<em>Ruby</em> <em>agent</em>",
        "body": " attributes (types, destinations, and limits for attributes used by New Relic <em>agents</em>) Enabling and disabling attributes (properties, rules, and backwards compatibility information for <em>Ruby</em> <em>agent</em> attributes) Attribute examples (scenarios and results of enabling and disabling different <em>Ruby</em> <em>agent</em> attributes)"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.592575,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Agents</em>",
        "body": " an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by <em>agent</em>. (The properties in this diagram are specific to the PHP <em>agent</em>, but the general flow is the same for all <em>agents</em>. Property names and syntax vary by <em>agent</em>.) Types of attributes"
      },
      "id": "603eb9db28ccbc127aeba79e"
    }
  ],
  "/docs/agents/ruby-agent/features/record-deployments-ruby-agent": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.15497,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.36707,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Ruby</em> <em>agent</em> attributes",
        "sections": "<em>Ruby</em> <em>agent</em> attributes",
        "tags": "<em>Ruby</em> <em>agent</em>",
        "body": " attributes (types, destinations, and limits for attributes used by New Relic <em>agents</em>) Enabling and disabling attributes (properties, rules, and backwards compatibility information for <em>Ruby</em> <em>agent</em> attributes) Attribute examples (scenarios and results of enabling and disabling different <em>Ruby</em> <em>agent</em> attributes)"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.59248,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Agents</em>",
        "body": " an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by <em>agent</em>. (The properties in this diagram are specific to the PHP <em>agent</em>, but the general flow is the same for all <em>agents</em>. Property names and syntax vary by <em>agent</em>.) Types of attributes"
      },
      "id": "603eb9db28ccbc127aeba79e"
    }
  ],
  "/docs/agents/ruby-agent/features/ruby-vm-measurements": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.15497,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.36707,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Ruby</em> <em>agent</em> attributes",
        "sections": "<em>Ruby</em> <em>agent</em> attributes",
        "tags": "<em>Ruby</em> <em>agent</em>",
        "body": " attributes (types, destinations, and limits for attributes used by New Relic <em>agents</em>) Enabling and disabling attributes (properties, rules, and backwards compatibility information for <em>Ruby</em> <em>agent</em> attributes) Attribute examples (scenarios and results of enabling and disabling different <em>Ruby</em> <em>agent</em> attributes)"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.59248,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Agents</em>",
        "body": " an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by <em>agent</em>. (The properties in this diagram are specific to the PHP <em>agent</em>, but the general flow is the same for all <em>agents</em>. Property names and syntax vary by <em>agent</em>.) Types of attributes"
      },
      "id": "603eb9db28ccbc127aeba79e"
    }
  ],
  "/docs/agents/ruby-agent/frameworks/metal-controller-instrumentation": [
    {
      "sections": [
        "Rack middlewares",
        "Rack instrumentation",
        "Rack::Builder",
        "Rails middlewares",
        "Viewing middleware data",
        "In the APM Summary page",
        "In the APM Transactions page",
        "In APM transaction trace summary",
        "Disabling Rack instrumentation",
        "Installing Ruby agent middlewares manually",
        "Manual Rack instrumentation"
      ],
      "title": "Rack middlewares",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Instrumented gems"
      ],
      "external_id": "fa34ef9ebcf8904e3601568b15d53bfe825424f4",
      "image": "https://docs.newrelic.com/static/6a0f3d54778590afddb09dde98b4773e/c1b63/web_transactions.png",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/instrumented-gems/rack-middlewares/",
      "published_at": "2021-06-02T21:17:52Z",
      "updated_at": "2021-05-05T14:33:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Ruby agent automatically instruments Rack middlewares. If you are unfamiliar with the basics of Rack middlewares, review the resources linked by the Rails on Rack guide. Additionally, the Ruby agent provides some features via Rack middlewares: Cross application traces Auto-instrumentation for Browser monitoring New Relic automatically installs these middlewares for Rails and Sinatra. Rack instrumentation The two most common ways to configure Rack middlewares are the Rack::Builder API (most often from config.ru) and Rails' middleware stack configuration: Rack::Builder Middlewares in your config.ru file are configured using Rack::Builder. For the Ruby agent to instrument middlewares from Rack::Builder, your app must run version 1.1.0 or higher of the rack gem. This is the most common use of middlewares with Sinatra or pure-rack applications. Rails middlewares Rails uses its own class (ActionDispatch::MiddlewareStack) instead of Rack::Builder to configure middlewares. Even if you haven't explicitly added middlewares to your Rails application, many components of Rails itself are implemented as middleware, so middleware data will appear by default. The Ruby agent automatically instruments middlewares added via ActionDispatch::MiddlewareStack on Rails 3.0 or higher. For more information about configuring middlewares with Rails, see the Ruby on Rails guide. Viewing middleware data You can view middleware data in APM. In the APM Summary page The main chart on your app's APM Summary page includes a purple bar that shows average time per request spent in all Rack middlewares for your application. APM > (selected application) > Summary: Middleware time appears in purple on your app's main Overview chart. In the APM Transactions page You can also see time for individual middlewares for a specific transaction name from your app's APM Transactions page. APM > (selected application) > Monitor > Transactions > (selected transaction) > Trace details: Here is an example of middleware time for a selected transaction for your app. In APM transaction trace summary Transaction traces also capture detailed middleware call information. APM > (selected application) > Monitor > Transactions > (selected transaction trace): Here is an example of middleware details in a transaction trace. Disabling Rack instrumentation If you do not want to instrument Rack middlewares, you may disable Rack middleware instrumentation with the disable_middleware_instrumentation setting. You can also ignore specific transactions. Installing Ruby agent middlewares manually The Ruby agent's implementation of New Relic's Cross Application Tracing feature uses Rack middleware instrumentation to read and write HTTP headers that are necessary to pass information between monitored applications. If you have disabled middleware instrumentation as described above and want to use cross application tracing, you must manually add the NewRelic::Rack::AgentHooks middleware to your middleware stack. For more information, see Cross application tracing in Ruby. Manual Rack instrumentation Earlier versions of the Ruby agent supported manually instrumenting Rack middlewares via the NewRelic::Agent::Instrumentation::Rack module. This instrumentation is deprecated in Ruby agent versions 3.9.0 or higher, because it is unnecessary with automatic middleware instrumentation. New Relic recommends that you remove references to this module from your code after upgrading to 3.9.0 or higher.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 160.02763,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Installing <em>Ruby</em> <em>agent</em> middlewares manually",
        "tags": "<em>Instrumented</em> <em>gems</em>",
        "body": " config.ru file are configured using Rack::Builder. For the <em>Ruby</em> <em>agent</em> to <em>instrument</em> middlewares from Rack::Builder, your app must run version 1.1.0 or higher of the rack <em>gem</em>. This is the most common use of middlewares with Sinatra or pure-rack applications. Rails middlewares Rails uses its own class"
      },
      "id": "603ebc9ae7b9d2754a2a0810"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.20082,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Mongo instrumentation",
        "Contents",
        "Supported gems",
        "Third-party and rpm_contrib instrumentation",
        "Disabling instrumentation",
        "For more help"
      ],
      "title": "Mongo instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Instrumented gems"
      ],
      "external_id": "140273418eb46eab0e42622805c8585f81db9cd4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/frameworks/mongo-instrumentation/",
      "published_at": "2021-05-28T18:26:18Z",
      "updated_at": "2021-03-16T06:42:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Ruby agent has built-in instrumentation for MongoDB queries made via the mongo gem. Contents Supported gems This summarizes the Ruby agent's support for gems by version. Gem version Comments mongo 1.8 and 1.9 Supported by New Relic's Ruby agent 3.7.1 or higher mongo 2.0 Not supported mongo 2.1 or higher Requires New Relic's Ruby agent 3.13.1 or higher Other gems Support for Mongoid 2/3/4 and Moped currently is available only via third-party gems. For links to the relevant projects, see the plugin list on rpm_contrib. Third-party and rpm_contrib instrumentation The rpm_contrib and newrelic_mongo gems both provided basic instrumentation for mongo. New Relic does not recommend running Mongo instrumentation via these gems alongside the Ruby agent's built-in Mongo support. This might double-count metrics such as overall database time. Also, the rpm_contrib and newrelic_mongo gems both use a distinct setting that can be used to disable them if removing those gems entirely isn't possible in your environment. For those third party gems, set disable_mongodb: false in your newrelic.yml. Disabling instrumentation To disable Mongo instrumentation in the agent, add the following to your newrelic.yml: disable_mongo: true Copy For more help Additional documentation resources include: New Relic for Ruby (compatibility and requirements, general information about installation, configuration, troubleshooting, and known issues) Ruby agent installation (using the New Relic Ruby gem and configuration file)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.59413,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Mongo <em>instrumentation</em>",
        "sections": "Mongo <em>instrumentation</em>",
        "tags": "<em>Instrumented</em> <em>gems</em>",
        "body": "The <em>Ruby</em> <em>agent</em> has built-in instrumentation for MongoDB queries made via the mongo <em>gem</em>. Contents Supported <em>gems</em> This summarizes the <em>Ruby</em> <em>agent</em>&#x27;s support for <em>gems</em> by version. <em>Gem</em> version Comments mongo 1.8 and 1.9 Supported by New Relic&#x27;s <em>Ruby</em> <em>agent</em> 3.7.1 or higher mongo 2.0 Not supported mongo 2.1"
      },
      "id": "603ebcd0e7b9d2b7862a07e6"
    }
  ],
  "/docs/agents/ruby-agent/frameworks/mongo-instrumentation": [
    {
      "sections": [
        "Rack middlewares",
        "Rack instrumentation",
        "Rack::Builder",
        "Rails middlewares",
        "Viewing middleware data",
        "In the APM Summary page",
        "In the APM Transactions page",
        "In APM transaction trace summary",
        "Disabling Rack instrumentation",
        "Installing Ruby agent middlewares manually",
        "Manual Rack instrumentation"
      ],
      "title": "Rack middlewares",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Instrumented gems"
      ],
      "external_id": "fa34ef9ebcf8904e3601568b15d53bfe825424f4",
      "image": "https://docs.newrelic.com/static/6a0f3d54778590afddb09dde98b4773e/c1b63/web_transactions.png",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/instrumented-gems/rack-middlewares/",
      "published_at": "2021-06-02T21:17:52Z",
      "updated_at": "2021-05-05T14:33:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Ruby agent automatically instruments Rack middlewares. If you are unfamiliar with the basics of Rack middlewares, review the resources linked by the Rails on Rack guide. Additionally, the Ruby agent provides some features via Rack middlewares: Cross application traces Auto-instrumentation for Browser monitoring New Relic automatically installs these middlewares for Rails and Sinatra. Rack instrumentation The two most common ways to configure Rack middlewares are the Rack::Builder API (most often from config.ru) and Rails' middleware stack configuration: Rack::Builder Middlewares in your config.ru file are configured using Rack::Builder. For the Ruby agent to instrument middlewares from Rack::Builder, your app must run version 1.1.0 or higher of the rack gem. This is the most common use of middlewares with Sinatra or pure-rack applications. Rails middlewares Rails uses its own class (ActionDispatch::MiddlewareStack) instead of Rack::Builder to configure middlewares. Even if you haven't explicitly added middlewares to your Rails application, many components of Rails itself are implemented as middleware, so middleware data will appear by default. The Ruby agent automatically instruments middlewares added via ActionDispatch::MiddlewareStack on Rails 3.0 or higher. For more information about configuring middlewares with Rails, see the Ruby on Rails guide. Viewing middleware data You can view middleware data in APM. In the APM Summary page The main chart on your app's APM Summary page includes a purple bar that shows average time per request spent in all Rack middlewares for your application. APM > (selected application) > Summary: Middleware time appears in purple on your app's main Overview chart. In the APM Transactions page You can also see time for individual middlewares for a specific transaction name from your app's APM Transactions page. APM > (selected application) > Monitor > Transactions > (selected transaction) > Trace details: Here is an example of middleware time for a selected transaction for your app. In APM transaction trace summary Transaction traces also capture detailed middleware call information. APM > (selected application) > Monitor > Transactions > (selected transaction trace): Here is an example of middleware details in a transaction trace. Disabling Rack instrumentation If you do not want to instrument Rack middlewares, you may disable Rack middleware instrumentation with the disable_middleware_instrumentation setting. You can also ignore specific transactions. Installing Ruby agent middlewares manually The Ruby agent's implementation of New Relic's Cross Application Tracing feature uses Rack middleware instrumentation to read and write HTTP headers that are necessary to pass information between monitored applications. If you have disabled middleware instrumentation as described above and want to use cross application tracing, you must manually add the NewRelic::Rack::AgentHooks middleware to your middleware stack. For more information, see Cross application tracing in Ruby. Manual Rack instrumentation Earlier versions of the Ruby agent supported manually instrumenting Rack middlewares via the NewRelic::Agent::Instrumentation::Rack module. This instrumentation is deprecated in Ruby agent versions 3.9.0 or higher, because it is unnecessary with automatic middleware instrumentation. New Relic recommends that you remove references to this module from your code after upgrading to 3.9.0 or higher.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 160.02763,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Installing <em>Ruby</em> <em>agent</em> middlewares manually",
        "tags": "<em>Instrumented</em> <em>gems</em>",
        "body": " config.ru file are configured using Rack::Builder. For the <em>Ruby</em> <em>agent</em> to <em>instrument</em> middlewares from Rack::Builder, your app must run version 1.1.0 or higher of the rack <em>gem</em>. This is the most common use of middlewares with Sinatra or pure-rack applications. Rails middlewares Rails uses its own class"
      },
      "id": "603ebc9ae7b9d2754a2a0810"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.20082,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Sinatra instrumentation",
        "Contents",
        "Getting started",
        "Middleware installation",
        "Ignoring routes",
        "Padrino",
        "Shotgun (not supported)",
        "For more help"
      ],
      "title": "Sinatra instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Instrumented gems"
      ],
      "external_id": "97ce5f5307e5c41049d2daf7c08d9eb741f27f47",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/instrumented-gems/sinatra-instrumentation/",
      "published_at": "2021-06-02T21:18:19Z",
      "updated_at": "2021-03-16T06:43:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Ruby agent works with Sinatra 1.2.x or higher. In the New Relic UI, the Sinatra actions appear similar to controller actions. The actions in the UI correspond to the pattern expression used to match them. HTTP operations are not distinguished. Multiple matches are all tracked as separate actions. Contents Getting started To set up Sinatra: Install the latest newrelic_rpm gem. In your Sinatra app, immediately below the Sinatra require directive, add: require 'newrelic_rpm' Copy Set RACK_ENV to the environment corresponding to the configuration definitions in your newrelic.yml file; for example, development, staging, production, etc. Note: Developer mode only works with Rails. Middleware installation Ruby agent versions prior to 3.6.3 required manual addition of New Relic middlewares to enable certain features, such as cross application tracing and browser monitoring. For more information about required middlewares, see Rack middlewares, or upgrade to the most recent Ruby agent. Ignoring routes Ruby agent versions 3.6.3 or higher support ignoring certain routes, similar to what was previously available in Rails controller instrumentation. To specify these values, use the same style of routes that you use to define your Sinatra application. For example, to ignore a ping route in a Sinatra app, include the following code in the app: newrelic_ignore '/ping' get '/ping' do # ... end Copy If you want an entire application to be ignored (for example, in a mounted application), call newrelic_ignore without parameters: newrelic_ignore Copy Additionally, newrelic_ignore_apdex and newrelic_ignore_enduser are supported. The newrelic_ignore_apdex call will exclude a given route from consideration in overall Apdex calculations. The newrelic_ignore_enduser call will prevent automatic injection of the page load timing JavaScript when a route is rendered. Padrino Padrino is a framework built on top of Sinatra. Starting with Ruby agent version 3.6.3, New Relic's Sinatra instrumentation works with Padrino versions 0.10.x or higher. Shotgun (not supported) The New Relic Ruby agent will not work with shotgun. It cannot make a connection before the dispatcher process exits. Neither Developer mode nor Monitor mode will work. For more help Additional documentation resources include Browser monitoring and the Ruby agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.50595,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Sinatra <em>instrumentation</em>",
        "sections": "Sinatra <em>instrumentation</em>",
        "tags": "<em>Instrumented</em> <em>gems</em>",
        "body": "New Relic&#x27;s <em>Ruby</em> <em>agent</em> works with Sinatra 1.2.x or higher. In the New Relic UI, the Sinatra actions appear similar to controller actions. The actions in the UI correspond to the pattern expression used to match them. HTTP operations are not distinguished. Multiple matches are all tracked"
      },
      "id": "603ebc9928ccbc1046eba786"
    }
  ],
  "/docs/agents/ruby-agent/frameworks/rack-metal-support": [
    {
      "sections": [
        "Rack middlewares",
        "Rack instrumentation",
        "Rack::Builder",
        "Rails middlewares",
        "Viewing middleware data",
        "In the APM Summary page",
        "In the APM Transactions page",
        "In APM transaction trace summary",
        "Disabling Rack instrumentation",
        "Installing Ruby agent middlewares manually",
        "Manual Rack instrumentation"
      ],
      "title": "Rack middlewares",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Instrumented gems"
      ],
      "external_id": "fa34ef9ebcf8904e3601568b15d53bfe825424f4",
      "image": "https://docs.newrelic.com/static/6a0f3d54778590afddb09dde98b4773e/c1b63/web_transactions.png",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/instrumented-gems/rack-middlewares/",
      "published_at": "2021-06-02T21:17:52Z",
      "updated_at": "2021-05-05T14:33:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Ruby agent automatically instruments Rack middlewares. If you are unfamiliar with the basics of Rack middlewares, review the resources linked by the Rails on Rack guide. Additionally, the Ruby agent provides some features via Rack middlewares: Cross application traces Auto-instrumentation for Browser monitoring New Relic automatically installs these middlewares for Rails and Sinatra. Rack instrumentation The two most common ways to configure Rack middlewares are the Rack::Builder API (most often from config.ru) and Rails' middleware stack configuration: Rack::Builder Middlewares in your config.ru file are configured using Rack::Builder. For the Ruby agent to instrument middlewares from Rack::Builder, your app must run version 1.1.0 or higher of the rack gem. This is the most common use of middlewares with Sinatra or pure-rack applications. Rails middlewares Rails uses its own class (ActionDispatch::MiddlewareStack) instead of Rack::Builder to configure middlewares. Even if you haven't explicitly added middlewares to your Rails application, many components of Rails itself are implemented as middleware, so middleware data will appear by default. The Ruby agent automatically instruments middlewares added via ActionDispatch::MiddlewareStack on Rails 3.0 or higher. For more information about configuring middlewares with Rails, see the Ruby on Rails guide. Viewing middleware data You can view middleware data in APM. In the APM Summary page The main chart on your app's APM Summary page includes a purple bar that shows average time per request spent in all Rack middlewares for your application. APM > (selected application) > Summary: Middleware time appears in purple on your app's main Overview chart. In the APM Transactions page You can also see time for individual middlewares for a specific transaction name from your app's APM Transactions page. APM > (selected application) > Monitor > Transactions > (selected transaction) > Trace details: Here is an example of middleware time for a selected transaction for your app. In APM transaction trace summary Transaction traces also capture detailed middleware call information. APM > (selected application) > Monitor > Transactions > (selected transaction trace): Here is an example of middleware details in a transaction trace. Disabling Rack instrumentation If you do not want to instrument Rack middlewares, you may disable Rack middleware instrumentation with the disable_middleware_instrumentation setting. You can also ignore specific transactions. Installing Ruby agent middlewares manually The Ruby agent's implementation of New Relic's Cross Application Tracing feature uses Rack middleware instrumentation to read and write HTTP headers that are necessary to pass information between monitored applications. If you have disabled middleware instrumentation as described above and want to use cross application tracing, you must manually add the NewRelic::Rack::AgentHooks middleware to your middleware stack. For more information, see Cross application tracing in Ruby. Manual Rack instrumentation Earlier versions of the Ruby agent supported manually instrumenting Rack middlewares via the NewRelic::Agent::Instrumentation::Rack module. This instrumentation is deprecated in Ruby agent versions 3.9.0 or higher, because it is unnecessary with automatic middleware instrumentation. New Relic recommends that you remove references to this module from your code after upgrading to 3.9.0 or higher.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 160.02762,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Installing <em>Ruby</em> <em>agent</em> middlewares manually",
        "tags": "<em>Instrumented</em> <em>gems</em>",
        "body": " config.ru file are configured using Rack::Builder. For the <em>Ruby</em> <em>agent</em> to <em>instrument</em> middlewares from Rack::Builder, your app must run version 1.1.0 or higher of the rack <em>gem</em>. This is the most common use of middlewares with Sinatra or pure-rack applications. Rails middlewares Rails uses its own class"
      },
      "id": "603ebc9ae7b9d2754a2a0810"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.2007,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Mongo instrumentation",
        "Contents",
        "Supported gems",
        "Third-party and rpm_contrib instrumentation",
        "Disabling instrumentation",
        "For more help"
      ],
      "title": "Mongo instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Instrumented gems"
      ],
      "external_id": "140273418eb46eab0e42622805c8585f81db9cd4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/frameworks/mongo-instrumentation/",
      "published_at": "2021-05-28T18:26:18Z",
      "updated_at": "2021-03-16T06:42:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Ruby agent has built-in instrumentation for MongoDB queries made via the mongo gem. Contents Supported gems This summarizes the Ruby agent's support for gems by version. Gem version Comments mongo 1.8 and 1.9 Supported by New Relic's Ruby agent 3.7.1 or higher mongo 2.0 Not supported mongo 2.1 or higher Requires New Relic's Ruby agent 3.13.1 or higher Other gems Support for Mongoid 2/3/4 and Moped currently is available only via third-party gems. For links to the relevant projects, see the plugin list on rpm_contrib. Third-party and rpm_contrib instrumentation The rpm_contrib and newrelic_mongo gems both provided basic instrumentation for mongo. New Relic does not recommend running Mongo instrumentation via these gems alongside the Ruby agent's built-in Mongo support. This might double-count metrics such as overall database time. Also, the rpm_contrib and newrelic_mongo gems both use a distinct setting that can be used to disable them if removing those gems entirely isn't possible in your environment. For those third party gems, set disable_mongodb: false in your newrelic.yml. Disabling instrumentation To disable Mongo instrumentation in the agent, add the following to your newrelic.yml: disable_mongo: true Copy For more help Additional documentation resources include: New Relic for Ruby (compatibility and requirements, general information about installation, configuration, troubleshooting, and known issues) Ruby agent installation (using the New Relic Ruby gem and configuration file)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.59413,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Mongo <em>instrumentation</em>",
        "sections": "Mongo <em>instrumentation</em>",
        "tags": "<em>Instrumented</em> <em>gems</em>",
        "body": "The <em>Ruby</em> <em>agent</em> has built-in instrumentation for MongoDB queries made via the mongo <em>gem</em>. Contents Supported <em>gems</em> This summarizes the <em>Ruby</em> <em>agent</em>&#x27;s support for <em>gems</em> by version. <em>Gem</em> version Comments mongo 1.8 and 1.9 Supported by New Relic&#x27;s <em>Ruby</em> <em>agent</em> 3.7.1 or higher mongo 2.0 Not supported mongo 2.1"
      },
      "id": "603ebcd0e7b9d2b7862a07e6"
    }
  ],
  "/docs/agents/ruby-agent/frameworks/sequel-instrumentation": [
    {
      "sections": [
        "Rack middlewares",
        "Rack instrumentation",
        "Rack::Builder",
        "Rails middlewares",
        "Viewing middleware data",
        "In the APM Summary page",
        "In the APM Transactions page",
        "In APM transaction trace summary",
        "Disabling Rack instrumentation",
        "Installing Ruby agent middlewares manually",
        "Manual Rack instrumentation"
      ],
      "title": "Rack middlewares",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Instrumented gems"
      ],
      "external_id": "fa34ef9ebcf8904e3601568b15d53bfe825424f4",
      "image": "https://docs.newrelic.com/static/6a0f3d54778590afddb09dde98b4773e/c1b63/web_transactions.png",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/instrumented-gems/rack-middlewares/",
      "published_at": "2021-06-02T21:17:52Z",
      "updated_at": "2021-05-05T14:33:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Ruby agent automatically instruments Rack middlewares. If you are unfamiliar with the basics of Rack middlewares, review the resources linked by the Rails on Rack guide. Additionally, the Ruby agent provides some features via Rack middlewares: Cross application traces Auto-instrumentation for Browser monitoring New Relic automatically installs these middlewares for Rails and Sinatra. Rack instrumentation The two most common ways to configure Rack middlewares are the Rack::Builder API (most often from config.ru) and Rails' middleware stack configuration: Rack::Builder Middlewares in your config.ru file are configured using Rack::Builder. For the Ruby agent to instrument middlewares from Rack::Builder, your app must run version 1.1.0 or higher of the rack gem. This is the most common use of middlewares with Sinatra or pure-rack applications. Rails middlewares Rails uses its own class (ActionDispatch::MiddlewareStack) instead of Rack::Builder to configure middlewares. Even if you haven't explicitly added middlewares to your Rails application, many components of Rails itself are implemented as middleware, so middleware data will appear by default. The Ruby agent automatically instruments middlewares added via ActionDispatch::MiddlewareStack on Rails 3.0 or higher. For more information about configuring middlewares with Rails, see the Ruby on Rails guide. Viewing middleware data You can view middleware data in APM. In the APM Summary page The main chart on your app's APM Summary page includes a purple bar that shows average time per request spent in all Rack middlewares for your application. APM > (selected application) > Summary: Middleware time appears in purple on your app's main Overview chart. In the APM Transactions page You can also see time for individual middlewares for a specific transaction name from your app's APM Transactions page. APM > (selected application) > Monitor > Transactions > (selected transaction) > Trace details: Here is an example of middleware time for a selected transaction for your app. In APM transaction trace summary Transaction traces also capture detailed middleware call information. APM > (selected application) > Monitor > Transactions > (selected transaction trace): Here is an example of middleware details in a transaction trace. Disabling Rack instrumentation If you do not want to instrument Rack middlewares, you may disable Rack middleware instrumentation with the disable_middleware_instrumentation setting. You can also ignore specific transactions. Installing Ruby agent middlewares manually The Ruby agent's implementation of New Relic's Cross Application Tracing feature uses Rack middleware instrumentation to read and write HTTP headers that are necessary to pass information between monitored applications. If you have disabled middleware instrumentation as described above and want to use cross application tracing, you must manually add the NewRelic::Rack::AgentHooks middleware to your middleware stack. For more information, see Cross application tracing in Ruby. Manual Rack instrumentation Earlier versions of the Ruby agent supported manually instrumenting Rack middlewares via the NewRelic::Agent::Instrumentation::Rack module. This instrumentation is deprecated in Ruby agent versions 3.9.0 or higher, because it is unnecessary with automatic middleware instrumentation. New Relic recommends that you remove references to this module from your code after upgrading to 3.9.0 or higher.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 160.02762,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Installing <em>Ruby</em> <em>agent</em> middlewares manually",
        "tags": "<em>Instrumented</em> <em>gems</em>",
        "body": " config.ru file are configured using Rack::Builder. For the <em>Ruby</em> <em>agent</em> to <em>instrument</em> middlewares from Rack::Builder, your app must run version 1.1.0 or higher of the rack <em>gem</em>. This is the most common use of middlewares with Sinatra or pure-rack applications. Rails middlewares Rails uses its own class"
      },
      "id": "603ebc9ae7b9d2754a2a0810"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.2007,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Mongo instrumentation",
        "Contents",
        "Supported gems",
        "Third-party and rpm_contrib instrumentation",
        "Disabling instrumentation",
        "For more help"
      ],
      "title": "Mongo instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Instrumented gems"
      ],
      "external_id": "140273418eb46eab0e42622805c8585f81db9cd4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/frameworks/mongo-instrumentation/",
      "published_at": "2021-05-28T18:26:18Z",
      "updated_at": "2021-03-16T06:42:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Ruby agent has built-in instrumentation for MongoDB queries made via the mongo gem. Contents Supported gems This summarizes the Ruby agent's support for gems by version. Gem version Comments mongo 1.8 and 1.9 Supported by New Relic's Ruby agent 3.7.1 or higher mongo 2.0 Not supported mongo 2.1 or higher Requires New Relic's Ruby agent 3.13.1 or higher Other gems Support for Mongoid 2/3/4 and Moped currently is available only via third-party gems. For links to the relevant projects, see the plugin list on rpm_contrib. Third-party and rpm_contrib instrumentation The rpm_contrib and newrelic_mongo gems both provided basic instrumentation for mongo. New Relic does not recommend running Mongo instrumentation via these gems alongside the Ruby agent's built-in Mongo support. This might double-count metrics such as overall database time. Also, the rpm_contrib and newrelic_mongo gems both use a distinct setting that can be used to disable them if removing those gems entirely isn't possible in your environment. For those third party gems, set disable_mongodb: false in your newrelic.yml. Disabling instrumentation To disable Mongo instrumentation in the agent, add the following to your newrelic.yml: disable_mongo: true Copy For more help Additional documentation resources include: New Relic for Ruby (compatibility and requirements, general information about installation, configuration, troubleshooting, and known issues) Ruby agent installation (using the New Relic Ruby gem and configuration file)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.59413,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Mongo <em>instrumentation</em>",
        "sections": "Mongo <em>instrumentation</em>",
        "tags": "<em>Instrumented</em> <em>gems</em>",
        "body": "The <em>Ruby</em> <em>agent</em> has built-in instrumentation for MongoDB queries made via the mongo <em>gem</em>. Contents Supported <em>gems</em> This summarizes the <em>Ruby</em> <em>agent</em>&#x27;s support for <em>gems</em> by version. <em>Gem</em> version Comments mongo 1.8 and 1.9 Supported by New Relic&#x27;s <em>Ruby</em> <em>agent</em> 3.7.1 or higher mongo 2.0 Not supported mongo 2.1"
      },
      "id": "603ebcd0e7b9d2b7862a07e6"
    }
  ],
  "/docs/agents/ruby-agent/getting-started/apm-agent-security-ruby": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.2007,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.47516,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Ruby</em> <em>agent</em> attributes",
        "sections": "<em>Ruby</em> <em>agent</em> attributes",
        "tags": "<em>Ruby</em> <em>agent</em>",
        "body": " attributes (types, destinations, and limits for attributes used by New Relic <em>agents</em>) Enabling and disabling attributes (properties, rules, and backwards compatibility information for <em>Ruby</em> <em>agent</em> attributes) Attribute examples (scenarios and results of enabling and disabling different <em>Ruby</em> <em>agent</em> attributes)"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "sections": [
        "Introduction to New Relic APIs",
        "Tip",
        "NerdGraph (GraphQL)",
        "REST APIs by capability",
        "Alerts",
        "APM",
        "Browser monitoring",
        "Infrastructure monitoring",
        "Mobile monitoring",
        "Synthetic monitoring",
        "Telemetry APIs for core data types",
        "Account management, admin, and usage APIs",
        "Other APIs",
        "Insights",
        "Plugins",
        "See APIs in action"
      ],
      "title": "Introduction to New Relic APIs",
      "type": "docs",
      "tags": [
        "APIs",
        "Get started",
        "Intro to APIs"
      ],
      "external_id": "01e9799a214baad5de04de6146483f6dbbc198aa",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/intro-apis/introduction-new-relic-apis/",
      "published_at": "2021-06-02T16:33:26Z",
      "updated_at": "2021-06-02T16:33:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers a variety of APIs and SDKs you can use to: Retrieve data from New Relic. Send data to New Relic. Adjust settings. This document provides examples and reference information for our API endpoints. For developer-focused content on how to use and customize New Relic, see developer.newrelic.com. Tip To use APIs and SDKs, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. NerdGraph (GraphQL) NerdGraph is New Relic's GraphQL-format API, an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph is the preferred API for querying New Relic data and making a range of feature configurations. To get started, see Introduction to NerdGraph. REST APIs by capability New Relic capabilities, like APM, infrastructure monitoring, or alerts, are often used together, and sometimes they overlap in functionality. This is why multiple APIs may be relevant to each area. Some API functionality will depend on your access to features and data. Tip To learn more about different API key types, see Understand New Relic API keys. Alerts Use the REST API for alerts and the API Explorer to: Create and manage policies, conditions, and notification channels. Create alert conditions based on NRQL queries. Create alert conditions based on data from other New Relic capabilities. APM API resources for application monitoring include: Resource Details REST API REST API features include: Retrieve APM data, including metrics, Apdex, error rates, and host data. Report deployments. Change the app name in the UI. Agent APIs Every APM language agent has an API that lets you customize the agent's default behavior, including reporting custom data. APM agent APIs include: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Python agent API Ruby agent API Query API To query APM data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Browser monitoring The Browser API resources include: Resource Details Browser agent API Use the Browser agent API for tasks such as: Report custom end user data to browser monitoring. Monitor asynchronous browser activity using SPA API calls. Insert custom data into New Relic dashboards . Manage source maps. REST API With the REST API you can: Retrieve page load timing data and throughput. Add or list apps monitored by browser monitoring. Manage alerts conditions for your browser data. Query API To retrieve browser monitoring data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Infrastructure monitoring The Infrastructure API resources include: Resource Details Query API To retrieve infrastructure data, use the Query API. This API can also be used to retrieve subscription usage data. Infrastructure alert API To manage your infrastructure alerts, use the Infrastructure alert API. Integrations SDK To make your own custom integrations for reporting data to infrastructure monitoring, use the Integrations SDK. NerdGraph You can use NerdGraph (our GraphQL API) to query your cloud integration data and make changes to cloud integration settings. Mobile monitoring Mobile API resources include: Resource Details Mobile agent APIs Mobile APIs let you custom instrument your own code and send events to New Relic. See the platform-specific documentation: iOS Android Unity REST API Use the REST API for such tasks as: Retrieve a list of monitored apps. Get subscription usage data. Get metric names and data. Get crash count and crash rate data. Manage New Relic alerts conditions for your mobile apps. Query API To retrieve Mobile data from New Relic, use the Query API. Account management APIs For account-related APIs, see Account APIs. Synthetic monitoring Synthetics API resources include: Resource Details Synthetics REST API The Synthetics REST API functionality includes: Create and manage synthetics monitors. Manage synthetics alert notifications. Add labels to monitors, and retrieve monitors with specific labels. Query API To retrieve synthetics event data, use the Query API. Alerts API To create and manage alert conditions that target synthetics monitors, use the Alerts API. Telemetry APIs for core data types We offer several APIs that allow you to get our core data types (metrics, logs, traces, and events) into New Relic without the use of an installed agent. Data type Description Trace API Send distributed tracing data to New Relic. Event API Send event data to New Relic. Metric API Send metrics to New Relic from any source (including other telemetry monitoring services). Log API Send your log data to New Relic. Account management, admin, and usage APIs Like any other New Relic product or service, you want to be confident that your APIs protect you and your customers' data privacy. The following are API resources related to New Relic account administration and usage. For more information about API capabilities, see the specific New Relic API. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Resource Details REST API REST API features include: Find your API keys, account ID, and information needed to use the REST API. Return a list of account users (original user model only). Get SLA report data for browser and application monitoring. Subscription usage You can use the Query API to retrieve subscription usage data. This can be helpful to see how usage compares to your current subscription level, or for doing departmental chargebacks. Partner API To retrieve information about your New Relic partner account, sub-accounts, and users, use the Partner API. Other APIs Insights New Relic Insights was the name of our original product that governed custom event reporting and querying. The features associated with Insights have been rolled into our New Relic One platform (learn more), but there are still some APIs and original pricing plans that use the term \"Insights\" for these historical reasons. Insights-related APIs include: Resource Details Event API To report custom events, use the Event API. Query API To query your data using NRQL-format queries, you can use the Query API. Note that this API is deprecated and NerdGraph is preferred for querying your data. Dashboard API See the Insights Dashboard API. Plugins Use the REST API for New Relic plugins and the API Explorer to: Get a list of plugins, including their names, IDs, and GUIDs. List one or more plugin components, their output, and their metric timeslice data. Developers and New Relic partners can also use New Relic's Plugin API to write an agent in any language that can work directly with the API for plugins. This allows you to send your own metric data to our plugins and view data received from the API in New Relic. See APIs in action For more on how you as a developer can optimize your ability to solve problems using New Relic, go to developer.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 129.99213,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Get</em> <em>started</em>",
        "body": ", an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph is the preferred API for querying New Relic data and making a range of feature configurations. To <em>get</em> <em>started</em>, see Introduction to NerdGraph. REST APIs"
      },
      "id": "609fa5cf196a67066022b194"
    }
  ],
  "/docs/agents/ruby-agent/getting-started/introduction-new-relic-ruby": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.20056,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.47504,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Ruby</em> <em>agent</em> attributes",
        "sections": "<em>Ruby</em> <em>agent</em> attributes",
        "tags": "<em>Ruby</em> <em>agent</em>",
        "body": " attributes (types, destinations, and limits for attributes used by New Relic <em>agents</em>) Enabling and disabling attributes (properties, rules, and backwards compatibility information for <em>Ruby</em> <em>agent</em> attributes) Attribute examples (scenarios and results of enabling and disabling different <em>Ruby</em> <em>agent</em> attributes)"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "sections": [
        "Introduction to New Relic APIs",
        "Tip",
        "NerdGraph (GraphQL)",
        "REST APIs by capability",
        "Alerts",
        "APM",
        "Browser monitoring",
        "Infrastructure monitoring",
        "Mobile monitoring",
        "Synthetic monitoring",
        "Telemetry APIs for core data types",
        "Account management, admin, and usage APIs",
        "Other APIs",
        "Insights",
        "Plugins",
        "See APIs in action"
      ],
      "title": "Introduction to New Relic APIs",
      "type": "docs",
      "tags": [
        "APIs",
        "Get started",
        "Intro to APIs"
      ],
      "external_id": "01e9799a214baad5de04de6146483f6dbbc198aa",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/intro-apis/introduction-new-relic-apis/",
      "published_at": "2021-06-02T16:33:26Z",
      "updated_at": "2021-06-02T16:33:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers a variety of APIs and SDKs you can use to: Retrieve data from New Relic. Send data to New Relic. Adjust settings. This document provides examples and reference information for our API endpoints. For developer-focused content on how to use and customize New Relic, see developer.newrelic.com. Tip To use APIs and SDKs, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. NerdGraph (GraphQL) NerdGraph is New Relic's GraphQL-format API, an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph is the preferred API for querying New Relic data and making a range of feature configurations. To get started, see Introduction to NerdGraph. REST APIs by capability New Relic capabilities, like APM, infrastructure monitoring, or alerts, are often used together, and sometimes they overlap in functionality. This is why multiple APIs may be relevant to each area. Some API functionality will depend on your access to features and data. Tip To learn more about different API key types, see Understand New Relic API keys. Alerts Use the REST API for alerts and the API Explorer to: Create and manage policies, conditions, and notification channels. Create alert conditions based on NRQL queries. Create alert conditions based on data from other New Relic capabilities. APM API resources for application monitoring include: Resource Details REST API REST API features include: Retrieve APM data, including metrics, Apdex, error rates, and host data. Report deployments. Change the app name in the UI. Agent APIs Every APM language agent has an API that lets you customize the agent's default behavior, including reporting custom data. APM agent APIs include: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Python agent API Ruby agent API Query API To query APM data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Browser monitoring The Browser API resources include: Resource Details Browser agent API Use the Browser agent API for tasks such as: Report custom end user data to browser monitoring. Monitor asynchronous browser activity using SPA API calls. Insert custom data into New Relic dashboards . Manage source maps. REST API With the REST API you can: Retrieve page load timing data and throughput. Add or list apps monitored by browser monitoring. Manage alerts conditions for your browser data. Query API To retrieve browser monitoring data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Infrastructure monitoring The Infrastructure API resources include: Resource Details Query API To retrieve infrastructure data, use the Query API. This API can also be used to retrieve subscription usage data. Infrastructure alert API To manage your infrastructure alerts, use the Infrastructure alert API. Integrations SDK To make your own custom integrations for reporting data to infrastructure monitoring, use the Integrations SDK. NerdGraph You can use NerdGraph (our GraphQL API) to query your cloud integration data and make changes to cloud integration settings. Mobile monitoring Mobile API resources include: Resource Details Mobile agent APIs Mobile APIs let you custom instrument your own code and send events to New Relic. See the platform-specific documentation: iOS Android Unity REST API Use the REST API for such tasks as: Retrieve a list of monitored apps. Get subscription usage data. Get metric names and data. Get crash count and crash rate data. Manage New Relic alerts conditions for your mobile apps. Query API To retrieve Mobile data from New Relic, use the Query API. Account management APIs For account-related APIs, see Account APIs. Synthetic monitoring Synthetics API resources include: Resource Details Synthetics REST API The Synthetics REST API functionality includes: Create and manage synthetics monitors. Manage synthetics alert notifications. Add labels to monitors, and retrieve monitors with specific labels. Query API To retrieve synthetics event data, use the Query API. Alerts API To create and manage alert conditions that target synthetics monitors, use the Alerts API. Telemetry APIs for core data types We offer several APIs that allow you to get our core data types (metrics, logs, traces, and events) into New Relic without the use of an installed agent. Data type Description Trace API Send distributed tracing data to New Relic. Event API Send event data to New Relic. Metric API Send metrics to New Relic from any source (including other telemetry monitoring services). Log API Send your log data to New Relic. Account management, admin, and usage APIs Like any other New Relic product or service, you want to be confident that your APIs protect you and your customers' data privacy. The following are API resources related to New Relic account administration and usage. For more information about API capabilities, see the specific New Relic API. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Resource Details REST API REST API features include: Find your API keys, account ID, and information needed to use the REST API. Return a list of account users (original user model only). Get SLA report data for browser and application monitoring. Subscription usage You can use the Query API to retrieve subscription usage data. This can be helpful to see how usage compares to your current subscription level, or for doing departmental chargebacks. Partner API To retrieve information about your New Relic partner account, sub-accounts, and users, use the Partner API. Other APIs Insights New Relic Insights was the name of our original product that governed custom event reporting and querying. The features associated with Insights have been rolled into our New Relic One platform (learn more), but there are still some APIs and original pricing plans that use the term \"Insights\" for these historical reasons. Insights-related APIs include: Resource Details Event API To report custom events, use the Event API. Query API To query your data using NRQL-format queries, you can use the Query API. Note that this API is deprecated and NerdGraph is preferred for querying your data. Dashboard API See the Insights Dashboard API. Plugins Use the REST API for New Relic plugins and the API Explorer to: Get a list of plugins, including their names, IDs, and GUIDs. List one or more plugin components, their output, and their metric timeslice data. Developers and New Relic partners can also use New Relic's Plugin API to write an agent in any language that can work directly with the API for plugins. This allows you to send your own metric data to our plugins and view data received from the API in New Relic. See APIs in action For more on how you as a developer can optimize your ability to solve problems using New Relic, go to developer.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 129.992,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Get</em> <em>started</em>",
        "body": ", an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph is the preferred API for querying New Relic data and making a range of feature configurations. To <em>get</em> <em>started</em>, see Introduction to NerdGraph. REST APIs"
      },
      "id": "609fa5cf196a67066022b194"
    }
  ],
  "/docs/agents/ruby-agent/getting-started/migration-7x-guide": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.20056,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.47504,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Ruby</em> <em>agent</em> attributes",
        "sections": "<em>Ruby</em> <em>agent</em> attributes",
        "tags": "<em>Ruby</em> <em>agent</em>",
        "body": " attributes (types, destinations, and limits for attributes used by New Relic <em>agents</em>) Enabling and disabling attributes (properties, rules, and backwards compatibility information for <em>Ruby</em> <em>agent</em> attributes) Attribute examples (scenarios and results of enabling and disabling different <em>Ruby</em> <em>agent</em> attributes)"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "sections": [
        "Introduction to New Relic APIs",
        "Tip",
        "NerdGraph (GraphQL)",
        "REST APIs by capability",
        "Alerts",
        "APM",
        "Browser monitoring",
        "Infrastructure monitoring",
        "Mobile monitoring",
        "Synthetic monitoring",
        "Telemetry APIs for core data types",
        "Account management, admin, and usage APIs",
        "Other APIs",
        "Insights",
        "Plugins",
        "See APIs in action"
      ],
      "title": "Introduction to New Relic APIs",
      "type": "docs",
      "tags": [
        "APIs",
        "Get started",
        "Intro to APIs"
      ],
      "external_id": "01e9799a214baad5de04de6146483f6dbbc198aa",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/intro-apis/introduction-new-relic-apis/",
      "published_at": "2021-06-02T16:33:26Z",
      "updated_at": "2021-06-02T16:33:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers a variety of APIs and SDKs you can use to: Retrieve data from New Relic. Send data to New Relic. Adjust settings. This document provides examples and reference information for our API endpoints. For developer-focused content on how to use and customize New Relic, see developer.newrelic.com. Tip To use APIs and SDKs, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. NerdGraph (GraphQL) NerdGraph is New Relic's GraphQL-format API, an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph is the preferred API for querying New Relic data and making a range of feature configurations. To get started, see Introduction to NerdGraph. REST APIs by capability New Relic capabilities, like APM, infrastructure monitoring, or alerts, are often used together, and sometimes they overlap in functionality. This is why multiple APIs may be relevant to each area. Some API functionality will depend on your access to features and data. Tip To learn more about different API key types, see Understand New Relic API keys. Alerts Use the REST API for alerts and the API Explorer to: Create and manage policies, conditions, and notification channels. Create alert conditions based on NRQL queries. Create alert conditions based on data from other New Relic capabilities. APM API resources for application monitoring include: Resource Details REST API REST API features include: Retrieve APM data, including metrics, Apdex, error rates, and host data. Report deployments. Change the app name in the UI. Agent APIs Every APM language agent has an API that lets you customize the agent's default behavior, including reporting custom data. APM agent APIs include: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Python agent API Ruby agent API Query API To query APM data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Browser monitoring The Browser API resources include: Resource Details Browser agent API Use the Browser agent API for tasks such as: Report custom end user data to browser monitoring. Monitor asynchronous browser activity using SPA API calls. Insert custom data into New Relic dashboards . Manage source maps. REST API With the REST API you can: Retrieve page load timing data and throughput. Add or list apps monitored by browser monitoring. Manage alerts conditions for your browser data. Query API To retrieve browser monitoring data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Infrastructure monitoring The Infrastructure API resources include: Resource Details Query API To retrieve infrastructure data, use the Query API. This API can also be used to retrieve subscription usage data. Infrastructure alert API To manage your infrastructure alerts, use the Infrastructure alert API. Integrations SDK To make your own custom integrations for reporting data to infrastructure monitoring, use the Integrations SDK. NerdGraph You can use NerdGraph (our GraphQL API) to query your cloud integration data and make changes to cloud integration settings. Mobile monitoring Mobile API resources include: Resource Details Mobile agent APIs Mobile APIs let you custom instrument your own code and send events to New Relic. See the platform-specific documentation: iOS Android Unity REST API Use the REST API for such tasks as: Retrieve a list of monitored apps. Get subscription usage data. Get metric names and data. Get crash count and crash rate data. Manage New Relic alerts conditions for your mobile apps. Query API To retrieve Mobile data from New Relic, use the Query API. Account management APIs For account-related APIs, see Account APIs. Synthetic monitoring Synthetics API resources include: Resource Details Synthetics REST API The Synthetics REST API functionality includes: Create and manage synthetics monitors. Manage synthetics alert notifications. Add labels to monitors, and retrieve monitors with specific labels. Query API To retrieve synthetics event data, use the Query API. Alerts API To create and manage alert conditions that target synthetics monitors, use the Alerts API. Telemetry APIs for core data types We offer several APIs that allow you to get our core data types (metrics, logs, traces, and events) into New Relic without the use of an installed agent. Data type Description Trace API Send distributed tracing data to New Relic. Event API Send event data to New Relic. Metric API Send metrics to New Relic from any source (including other telemetry monitoring services). Log API Send your log data to New Relic. Account management, admin, and usage APIs Like any other New Relic product or service, you want to be confident that your APIs protect you and your customers' data privacy. The following are API resources related to New Relic account administration and usage. For more information about API capabilities, see the specific New Relic API. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Resource Details REST API REST API features include: Find your API keys, account ID, and information needed to use the REST API. Return a list of account users (original user model only). Get SLA report data for browser and application monitoring. Subscription usage You can use the Query API to retrieve subscription usage data. This can be helpful to see how usage compares to your current subscription level, or for doing departmental chargebacks. Partner API To retrieve information about your New Relic partner account, sub-accounts, and users, use the Partner API. Other APIs Insights New Relic Insights was the name of our original product that governed custom event reporting and querying. The features associated with Insights have been rolled into our New Relic One platform (learn more), but there are still some APIs and original pricing plans that use the term \"Insights\" for these historical reasons. Insights-related APIs include: Resource Details Event API To report custom events, use the Event API. Query API To query your data using NRQL-format queries, you can use the Query API. Note that this API is deprecated and NerdGraph is preferred for querying your data. Dashboard API See the Insights Dashboard API. Plugins Use the REST API for New Relic plugins and the API Explorer to: Get a list of plugins, including their names, IDs, and GUIDs. List one or more plugin components, their output, and their metric timeslice data. Developers and New Relic partners can also use New Relic's Plugin API to write an agent in any language that can work directly with the API for plugins. This allows you to send your own metric data to our plugins and view data received from the API in New Relic. See APIs in action For more on how you as a developer can optimize your ability to solve problems using New Relic, go to developer.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 129.992,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Get</em> <em>started</em>",
        "body": ", an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph is the preferred API for querying New Relic data and making a range of feature configurations. To <em>get</em> <em>started</em>, see Introduction to NerdGraph. REST APIs"
      },
      "id": "609fa5cf196a67066022b194"
    }
  ],
  "/docs/agents/ruby-agent/getting-started/new-relics-github-repository": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.20044,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.4749,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Ruby</em> <em>agent</em> attributes",
        "sections": "<em>Ruby</em> <em>agent</em> attributes",
        "tags": "<em>Ruby</em> <em>agent</em>",
        "body": " attributes (types, destinations, and limits for attributes used by New Relic <em>agents</em>) Enabling and disabling attributes (properties, rules, and backwards compatibility information for <em>Ruby</em> <em>agent</em> attributes) Attribute examples (scenarios and results of enabling and disabling different <em>Ruby</em> <em>agent</em> attributes)"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "sections": [
        "Introduction to New Relic APIs",
        "Tip",
        "NerdGraph (GraphQL)",
        "REST APIs by capability",
        "Alerts",
        "APM",
        "Browser monitoring",
        "Infrastructure monitoring",
        "Mobile monitoring",
        "Synthetic monitoring",
        "Telemetry APIs for core data types",
        "Account management, admin, and usage APIs",
        "Other APIs",
        "Insights",
        "Plugins",
        "See APIs in action"
      ],
      "title": "Introduction to New Relic APIs",
      "type": "docs",
      "tags": [
        "APIs",
        "Get started",
        "Intro to APIs"
      ],
      "external_id": "01e9799a214baad5de04de6146483f6dbbc198aa",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/intro-apis/introduction-new-relic-apis/",
      "published_at": "2021-06-02T16:33:26Z",
      "updated_at": "2021-06-02T16:33:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers a variety of APIs and SDKs you can use to: Retrieve data from New Relic. Send data to New Relic. Adjust settings. This document provides examples and reference information for our API endpoints. For developer-focused content on how to use and customize New Relic, see developer.newrelic.com. Tip To use APIs and SDKs, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. NerdGraph (GraphQL) NerdGraph is New Relic's GraphQL-format API, an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph is the preferred API for querying New Relic data and making a range of feature configurations. To get started, see Introduction to NerdGraph. REST APIs by capability New Relic capabilities, like APM, infrastructure monitoring, or alerts, are often used together, and sometimes they overlap in functionality. This is why multiple APIs may be relevant to each area. Some API functionality will depend on your access to features and data. Tip To learn more about different API key types, see Understand New Relic API keys. Alerts Use the REST API for alerts and the API Explorer to: Create and manage policies, conditions, and notification channels. Create alert conditions based on NRQL queries. Create alert conditions based on data from other New Relic capabilities. APM API resources for application monitoring include: Resource Details REST API REST API features include: Retrieve APM data, including metrics, Apdex, error rates, and host data. Report deployments. Change the app name in the UI. Agent APIs Every APM language agent has an API that lets you customize the agent's default behavior, including reporting custom data. APM agent APIs include: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Python agent API Ruby agent API Query API To query APM data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Browser monitoring The Browser API resources include: Resource Details Browser agent API Use the Browser agent API for tasks such as: Report custom end user data to browser monitoring. Monitor asynchronous browser activity using SPA API calls. Insert custom data into New Relic dashboards . Manage source maps. REST API With the REST API you can: Retrieve page load timing data and throughput. Add or list apps monitored by browser monitoring. Manage alerts conditions for your browser data. Query API To retrieve browser monitoring data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Infrastructure monitoring The Infrastructure API resources include: Resource Details Query API To retrieve infrastructure data, use the Query API. This API can also be used to retrieve subscription usage data. Infrastructure alert API To manage your infrastructure alerts, use the Infrastructure alert API. Integrations SDK To make your own custom integrations for reporting data to infrastructure monitoring, use the Integrations SDK. NerdGraph You can use NerdGraph (our GraphQL API) to query your cloud integration data and make changes to cloud integration settings. Mobile monitoring Mobile API resources include: Resource Details Mobile agent APIs Mobile APIs let you custom instrument your own code and send events to New Relic. See the platform-specific documentation: iOS Android Unity REST API Use the REST API for such tasks as: Retrieve a list of monitored apps. Get subscription usage data. Get metric names and data. Get crash count and crash rate data. Manage New Relic alerts conditions for your mobile apps. Query API To retrieve Mobile data from New Relic, use the Query API. Account management APIs For account-related APIs, see Account APIs. Synthetic monitoring Synthetics API resources include: Resource Details Synthetics REST API The Synthetics REST API functionality includes: Create and manage synthetics monitors. Manage synthetics alert notifications. Add labels to monitors, and retrieve monitors with specific labels. Query API To retrieve synthetics event data, use the Query API. Alerts API To create and manage alert conditions that target synthetics monitors, use the Alerts API. Telemetry APIs for core data types We offer several APIs that allow you to get our core data types (metrics, logs, traces, and events) into New Relic without the use of an installed agent. Data type Description Trace API Send distributed tracing data to New Relic. Event API Send event data to New Relic. Metric API Send metrics to New Relic from any source (including other telemetry monitoring services). Log API Send your log data to New Relic. Account management, admin, and usage APIs Like any other New Relic product or service, you want to be confident that your APIs protect you and your customers' data privacy. The following are API resources related to New Relic account administration and usage. For more information about API capabilities, see the specific New Relic API. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Resource Details REST API REST API features include: Find your API keys, account ID, and information needed to use the REST API. Return a list of account users (original user model only). Get SLA report data for browser and application monitoring. Subscription usage You can use the Query API to retrieve subscription usage data. This can be helpful to see how usage compares to your current subscription level, or for doing departmental chargebacks. Partner API To retrieve information about your New Relic partner account, sub-accounts, and users, use the Partner API. Other APIs Insights New Relic Insights was the name of our original product that governed custom event reporting and querying. The features associated with Insights have been rolled into our New Relic One platform (learn more), but there are still some APIs and original pricing plans that use the term \"Insights\" for these historical reasons. Insights-related APIs include: Resource Details Event API To report custom events, use the Event API. Query API To query your data using NRQL-format queries, you can use the Query API. Note that this API is deprecated and NerdGraph is preferred for querying your data. Dashboard API See the Insights Dashboard API. Plugins Use the REST API for New Relic plugins and the API Explorer to: Get a list of plugins, including their names, IDs, and GUIDs. List one or more plugin components, their output, and their metric timeslice data. Developers and New Relic partners can also use New Relic's Plugin API to write an agent in any language that can work directly with the API for plugins. This allows you to send your own metric data to our plugins and view data received from the API in New Relic. See APIs in action For more on how you as a developer can optimize your ability to solve problems using New Relic, go to developer.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 129.9919,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Get</em> <em>started</em>",
        "body": ", an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph is the preferred API for querying New Relic data and making a range of feature configurations. To <em>get</em> <em>started</em>, see Introduction to NerdGraph. REST APIs"
      },
      "id": "609fa5cf196a67066022b194"
    }
  ],
  "/docs/agents/ruby-agent/getting-started/ruby-agent-requirements-supported-frameworks": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.20044,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.4749,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Ruby</em> <em>agent</em> attributes",
        "sections": "<em>Ruby</em> <em>agent</em> attributes",
        "tags": "<em>Ruby</em> <em>agent</em>",
        "body": " attributes (types, destinations, and limits for attributes used by New Relic <em>agents</em>) Enabling and disabling attributes (properties, rules, and backwards compatibility information for <em>Ruby</em> <em>agent</em> attributes) Attribute examples (scenarios and results of enabling and disabling different <em>Ruby</em> <em>agent</em> attributes)"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "sections": [
        "Introduction to New Relic APIs",
        "Tip",
        "NerdGraph (GraphQL)",
        "REST APIs by capability",
        "Alerts",
        "APM",
        "Browser monitoring",
        "Infrastructure monitoring",
        "Mobile monitoring",
        "Synthetic monitoring",
        "Telemetry APIs for core data types",
        "Account management, admin, and usage APIs",
        "Other APIs",
        "Insights",
        "Plugins",
        "See APIs in action"
      ],
      "title": "Introduction to New Relic APIs",
      "type": "docs",
      "tags": [
        "APIs",
        "Get started",
        "Intro to APIs"
      ],
      "external_id": "01e9799a214baad5de04de6146483f6dbbc198aa",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/intro-apis/introduction-new-relic-apis/",
      "published_at": "2021-06-02T16:33:26Z",
      "updated_at": "2021-06-02T16:33:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers a variety of APIs and SDKs you can use to: Retrieve data from New Relic. Send data to New Relic. Adjust settings. This document provides examples and reference information for our API endpoints. For developer-focused content on how to use and customize New Relic, see developer.newrelic.com. Tip To use APIs and SDKs, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. NerdGraph (GraphQL) NerdGraph is New Relic's GraphQL-format API, an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph is the preferred API for querying New Relic data and making a range of feature configurations. To get started, see Introduction to NerdGraph. REST APIs by capability New Relic capabilities, like APM, infrastructure monitoring, or alerts, are often used together, and sometimes they overlap in functionality. This is why multiple APIs may be relevant to each area. Some API functionality will depend on your access to features and data. Tip To learn more about different API key types, see Understand New Relic API keys. Alerts Use the REST API for alerts and the API Explorer to: Create and manage policies, conditions, and notification channels. Create alert conditions based on NRQL queries. Create alert conditions based on data from other New Relic capabilities. APM API resources for application monitoring include: Resource Details REST API REST API features include: Retrieve APM data, including metrics, Apdex, error rates, and host data. Report deployments. Change the app name in the UI. Agent APIs Every APM language agent has an API that lets you customize the agent's default behavior, including reporting custom data. APM agent APIs include: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Python agent API Ruby agent API Query API To query APM data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Browser monitoring The Browser API resources include: Resource Details Browser agent API Use the Browser agent API for tasks such as: Report custom end user data to browser monitoring. Monitor asynchronous browser activity using SPA API calls. Insert custom data into New Relic dashboards . Manage source maps. REST API With the REST API you can: Retrieve page load timing data and throughput. Add or list apps monitored by browser monitoring. Manage alerts conditions for your browser data. Query API To retrieve browser monitoring data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Infrastructure monitoring The Infrastructure API resources include: Resource Details Query API To retrieve infrastructure data, use the Query API. This API can also be used to retrieve subscription usage data. Infrastructure alert API To manage your infrastructure alerts, use the Infrastructure alert API. Integrations SDK To make your own custom integrations for reporting data to infrastructure monitoring, use the Integrations SDK. NerdGraph You can use NerdGraph (our GraphQL API) to query your cloud integration data and make changes to cloud integration settings. Mobile monitoring Mobile API resources include: Resource Details Mobile agent APIs Mobile APIs let you custom instrument your own code and send events to New Relic. See the platform-specific documentation: iOS Android Unity REST API Use the REST API for such tasks as: Retrieve a list of monitored apps. Get subscription usage data. Get metric names and data. Get crash count and crash rate data. Manage New Relic alerts conditions for your mobile apps. Query API To retrieve Mobile data from New Relic, use the Query API. Account management APIs For account-related APIs, see Account APIs. Synthetic monitoring Synthetics API resources include: Resource Details Synthetics REST API The Synthetics REST API functionality includes: Create and manage synthetics monitors. Manage synthetics alert notifications. Add labels to monitors, and retrieve monitors with specific labels. Query API To retrieve synthetics event data, use the Query API. Alerts API To create and manage alert conditions that target synthetics monitors, use the Alerts API. Telemetry APIs for core data types We offer several APIs that allow you to get our core data types (metrics, logs, traces, and events) into New Relic without the use of an installed agent. Data type Description Trace API Send distributed tracing data to New Relic. Event API Send event data to New Relic. Metric API Send metrics to New Relic from any source (including other telemetry monitoring services). Log API Send your log data to New Relic. Account management, admin, and usage APIs Like any other New Relic product or service, you want to be confident that your APIs protect you and your customers' data privacy. The following are API resources related to New Relic account administration and usage. For more information about API capabilities, see the specific New Relic API. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Resource Details REST API REST API features include: Find your API keys, account ID, and information needed to use the REST API. Return a list of account users (original user model only). Get SLA report data for browser and application monitoring. Subscription usage You can use the Query API to retrieve subscription usage data. This can be helpful to see how usage compares to your current subscription level, or for doing departmental chargebacks. Partner API To retrieve information about your New Relic partner account, sub-accounts, and users, use the Partner API. Other APIs Insights New Relic Insights was the name of our original product that governed custom event reporting and querying. The features associated with Insights have been rolled into our New Relic One platform (learn more), but there are still some APIs and original pricing plans that use the term \"Insights\" for these historical reasons. Insights-related APIs include: Resource Details Event API To report custom events, use the Event API. Query API To query your data using NRQL-format queries, you can use the Query API. Note that this API is deprecated and NerdGraph is preferred for querying your data. Dashboard API See the Insights Dashboard API. Plugins Use the REST API for New Relic plugins and the API Explorer to: Get a list of plugins, including their names, IDs, and GUIDs. List one or more plugin components, their output, and their metric timeslice data. Developers and New Relic partners can also use New Relic's Plugin API to write an agent in any language that can work directly with the API for plugins. This allows you to send your own metric data to our plugins and view data received from the API in New Relic. See APIs in action For more on how you as a developer can optimize your ability to solve problems using New Relic, go to developer.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 129.9919,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Get</em> <em>started</em>",
        "body": ", an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph is the preferred API for querying New Relic data and making a range of feature configurations. To <em>get</em> <em>started</em>, see Introduction to NerdGraph. REST APIs"
      },
      "id": "609fa5cf196a67066022b194"
    }
  ],
  "/docs/agents/ruby-agent/index": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.15433,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.36644,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Ruby</em> <em>agent</em> attributes",
        "sections": "<em>Ruby</em> <em>agent</em> attributes",
        "tags": "<em>Ruby</em> <em>agent</em>",
        "body": " attributes (types, destinations, and limits for attributes used by New Relic <em>agents</em>) Enabling and disabling attributes (properties, rules, and backwards compatibility information for <em>Ruby</em> <em>agent</em> attributes) Attribute examples (scenarios and results of enabling and disabling different <em>Ruby</em> <em>agent</em> attributes)"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.591995,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Agents</em>",
        "body": " an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by <em>agent</em>. (The properties in this diagram are specific to the PHP <em>agent</em>, but the general flow is the same for all <em>agents</em>. Property names and syntax vary by <em>agent</em>.) Types of attributes"
      },
      "id": "603eb9db28ccbc127aeba79e"
    }
  ],
  "/docs/agents/ruby-agent/installation/install-new-relic-ruby-agent-gae-flexible-environment": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.3006,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> <em>installation</em> doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.36644,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Ruby</em> <em>agent</em> attributes",
        "sections": "<em>Ruby</em> <em>agent</em> attributes",
        "tags": "<em>Ruby</em> <em>agent</em>",
        "body": " attributes (types, destinations, and limits for attributes used by New Relic <em>agents</em>) Enabling and disabling attributes (properties, rules, and backwards compatibility information for <em>Ruby</em> <em>agent</em> attributes) Attribute examples (scenarios and results of enabling and disabling different <em>Ruby</em> <em>agent</em> attributes)"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.591995,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Agents</em>",
        "body": " an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by <em>agent</em>. (The properties in this diagram are specific to the PHP <em>agent</em>, but the general flow is the same for all <em>agents</em>. Property names and syntax vary by <em>agent</em>.) Types of attributes"
      },
      "id": "603eb9db28ccbc127aeba79e"
    }
  ],
  "/docs/agents/ruby-agent/installation/install-new-relic-ruby-agent": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.30042,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> <em>installation</em> doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.3663,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Ruby</em> <em>agent</em> attributes",
        "sections": "<em>Ruby</em> <em>agent</em> attributes",
        "tags": "<em>Ruby</em> <em>agent</em>",
        "body": " attributes (types, destinations, and limits for attributes used by New Relic <em>agents</em>) Enabling and disabling attributes (properties, rules, and backwards compatibility information for <em>Ruby</em> <em>agent</em> attributes) Attribute examples (scenarios and results of enabling and disabling different <em>Ruby</em> <em>agent</em> attributes)"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.5919,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Agents</em>",
        "body": " an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by <em>agent</em>. (The properties in this diagram are specific to the PHP <em>agent</em>, but the general flow is the same for all <em>agents</em>. Property names and syntax vary by <em>agent</em>.) Types of attributes"
      },
      "id": "603eb9db28ccbc127aeba79e"
    }
  ],
  "/docs/agents/ruby-agent/installation/ruby-agent-heroku": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.30042,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> <em>installation</em> doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.3663,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Ruby</em> <em>agent</em> attributes",
        "sections": "<em>Ruby</em> <em>agent</em> attributes",
        "tags": "<em>Ruby</em> <em>agent</em>",
        "body": " attributes (types, destinations, and limits for attributes used by New Relic <em>agents</em>) Enabling and disabling attributes (properties, rules, and backwards compatibility information for <em>Ruby</em> <em>agent</em> attributes) Attribute examples (scenarios and results of enabling and disabling different <em>Ruby</em> <em>agent</em> attributes)"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.5919,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Agents</em>",
        "body": " an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by <em>agent</em>. (The properties in this diagram are specific to the PHP <em>agent</em>, but the general flow is the same for all <em>agents</em>. Property names and syntax vary by <em>agent</em>.) Types of attributes"
      },
      "id": "603eb9db28ccbc127aeba79e"
    }
  ],
  "/docs/agents/ruby-agent/installation/ruby-agent-installation-rails-plugin": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.30023,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> <em>installation</em> doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.36618,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Ruby</em> <em>agent</em> attributes",
        "sections": "<em>Ruby</em> <em>agent</em> attributes",
        "tags": "<em>Ruby</em> <em>agent</em>",
        "body": " attributes (types, destinations, and limits for attributes used by New Relic <em>agents</em>) Enabling and disabling attributes (properties, rules, and backwards compatibility information for <em>Ruby</em> <em>agent</em> attributes) Attribute examples (scenarios and results of enabling and disabling different <em>Ruby</em> <em>agent</em> attributes)"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.591805,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Agents</em>",
        "body": " an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by <em>agent</em>. (The properties in this diagram are specific to the PHP <em>agent</em>, but the general flow is the same for all <em>agents</em>. Property names and syntax vary by <em>agent</em>.) Types of attributes"
      },
      "id": "603eb9db28ccbc127aeba79e"
    }
  ],
  "/docs/agents/ruby-agent/installation/uninstall-ruby-agent": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.30023,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> <em>installation</em> doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.36618,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Ruby</em> <em>agent</em> attributes",
        "sections": "<em>Ruby</em> <em>agent</em> attributes",
        "tags": "<em>Ruby</em> <em>agent</em>",
        "body": " attributes (types, destinations, and limits for attributes used by New Relic <em>agents</em>) Enabling and disabling attributes (properties, rules, and backwards compatibility information for <em>Ruby</em> <em>agent</em> attributes) Attribute examples (scenarios and results of enabling and disabling different <em>Ruby</em> <em>agent</em> attributes)"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.591805,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Agents</em>",
        "body": " an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by <em>agent</em>. (The properties in this diagram are specific to the PHP <em>agent</em>, but the general flow is the same for all <em>agents</em>. Property names and syntax vary by <em>agent</em>.) Types of attributes"
      },
      "id": "603eb9db28ccbc127aeba79e"
    }
  ],
  "/docs/agents/ruby-agent/installation/update-ruby-agent": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.30005,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> <em>installation</em> doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.36606,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Ruby</em> <em>agent</em> attributes",
        "sections": "<em>Ruby</em> <em>agent</em> attributes",
        "tags": "<em>Ruby</em> <em>agent</em>",
        "body": " attributes (types, destinations, and limits for attributes used by New Relic <em>agents</em>) Enabling and disabling attributes (properties, rules, and backwards compatibility information for <em>Ruby</em> <em>agent</em> attributes) Attribute examples (scenarios and results of enabling and disabling different <em>Ruby</em> <em>agent</em> attributes)"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.591705,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Agents</em>",
        "body": " an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by <em>agent</em>. (The properties in this diagram are specific to the PHP <em>agent</em>, but the general flow is the same for all <em>agents</em>. Property names and syntax vary by <em>agent</em>.) Types of attributes"
      },
      "id": "603eb9db28ccbc127aeba79e"
    }
  ],
  "/docs/agents/ruby-agent/instrumented-gems/rack-middlewares": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.19994,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Mongo instrumentation",
        "Contents",
        "Supported gems",
        "Third-party and rpm_contrib instrumentation",
        "Disabling instrumentation",
        "For more help"
      ],
      "title": "Mongo instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Instrumented gems"
      ],
      "external_id": "140273418eb46eab0e42622805c8585f81db9cd4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/frameworks/mongo-instrumentation/",
      "published_at": "2021-05-28T18:26:18Z",
      "updated_at": "2021-03-16T06:42:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Ruby agent has built-in instrumentation for MongoDB queries made via the mongo gem. Contents Supported gems This summarizes the Ruby agent's support for gems by version. Gem version Comments mongo 1.8 and 1.9 Supported by New Relic's Ruby agent 3.7.1 or higher mongo 2.0 Not supported mongo 2.1 or higher Requires New Relic's Ruby agent 3.13.1 or higher Other gems Support for Mongoid 2/3/4 and Moped currently is available only via third-party gems. For links to the relevant projects, see the plugin list on rpm_contrib. Third-party and rpm_contrib instrumentation The rpm_contrib and newrelic_mongo gems both provided basic instrumentation for mongo. New Relic does not recommend running Mongo instrumentation via these gems alongside the Ruby agent's built-in Mongo support. This might double-count metrics such as overall database time. Also, the rpm_contrib and newrelic_mongo gems both use a distinct setting that can be used to disable them if removing those gems entirely isn't possible in your environment. For those third party gems, set disable_mongodb: false in your newrelic.yml. Disabling instrumentation To disable Mongo instrumentation in the agent, add the following to your newrelic.yml: disable_mongo: true Copy For more help Additional documentation resources include: New Relic for Ruby (compatibility and requirements, general information about installation, configuration, troubleshooting, and known issues) Ruby agent installation (using the New Relic Ruby gem and configuration file)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.59412,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Mongo <em>instrumentation</em>",
        "sections": "Mongo <em>instrumentation</em>",
        "tags": "<em>Instrumented</em> <em>gems</em>",
        "body": "The <em>Ruby</em> <em>agent</em> has built-in instrumentation for MongoDB queries made via the mongo <em>gem</em>. Contents Supported <em>gems</em> This summarizes the <em>Ruby</em> <em>agent</em>&#x27;s support for <em>gems</em> by version. <em>Gem</em> version Comments mongo 1.8 and 1.9 Supported by New Relic&#x27;s <em>Ruby</em> <em>agent</em> 3.7.1 or higher mongo 2.0 Not supported mongo 2.1"
      },
      "id": "603ebcd0e7b9d2b7862a07e6"
    },
    {
      "sections": [
        "Sinatra instrumentation",
        "Contents",
        "Getting started",
        "Middleware installation",
        "Ignoring routes",
        "Padrino",
        "Shotgun (not supported)",
        "For more help"
      ],
      "title": "Sinatra instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Instrumented gems"
      ],
      "external_id": "97ce5f5307e5c41049d2daf7c08d9eb741f27f47",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/instrumented-gems/sinatra-instrumentation/",
      "published_at": "2021-06-02T21:18:19Z",
      "updated_at": "2021-03-16T06:43:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Ruby agent works with Sinatra 1.2.x or higher. In the New Relic UI, the Sinatra actions appear similar to controller actions. The actions in the UI correspond to the pattern expression used to match them. HTTP operations are not distinguished. Multiple matches are all tracked as separate actions. Contents Getting started To set up Sinatra: Install the latest newrelic_rpm gem. In your Sinatra app, immediately below the Sinatra require directive, add: require 'newrelic_rpm' Copy Set RACK_ENV to the environment corresponding to the configuration definitions in your newrelic.yml file; for example, development, staging, production, etc. Note: Developer mode only works with Rails. Middleware installation Ruby agent versions prior to 3.6.3 required manual addition of New Relic middlewares to enable certain features, such as cross application tracing and browser monitoring. For more information about required middlewares, see Rack middlewares, or upgrade to the most recent Ruby agent. Ignoring routes Ruby agent versions 3.6.3 or higher support ignoring certain routes, similar to what was previously available in Rails controller instrumentation. To specify these values, use the same style of routes that you use to define your Sinatra application. For example, to ignore a ping route in a Sinatra app, include the following code in the app: newrelic_ignore '/ping' get '/ping' do # ... end Copy If you want an entire application to be ignored (for example, in a mounted application), call newrelic_ignore without parameters: newrelic_ignore Copy Additionally, newrelic_ignore_apdex and newrelic_ignore_enduser are supported. The newrelic_ignore_apdex call will exclude a given route from consideration in overall Apdex calculations. The newrelic_ignore_enduser call will prevent automatic injection of the page load timing JavaScript when a route is rendered. Padrino Padrino is a framework built on top of Sinatra. Starting with Ruby agent version 3.6.3, New Relic's Sinatra instrumentation works with Padrino versions 0.10.x or higher. Shotgun (not supported) The New Relic Ruby agent will not work with shotgun. It cannot make a connection before the dispatcher process exits. Neither Developer mode nor Monitor mode will work. For more help Additional documentation resources include Browser monitoring and the Ruby agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.50594,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Sinatra <em>instrumentation</em>",
        "sections": "Sinatra <em>instrumentation</em>",
        "tags": "<em>Instrumented</em> <em>gems</em>",
        "body": "New Relic&#x27;s <em>Ruby</em> <em>agent</em> works with Sinatra 1.2.x or higher. In the New Relic UI, the Sinatra actions appear similar to controller actions. The actions in the UI correspond to the pattern expression used to match them. HTTP operations are not distinguished. Multiple matches are all tracked"
      },
      "id": "603ebc9928ccbc1046eba786"
    }
  ],
  "/docs/agents/ruby-agent/instrumented-gems/redis-instrumentation": [
    {
      "sections": [
        "Rack middlewares",
        "Rack instrumentation",
        "Rack::Builder",
        "Rails middlewares",
        "Viewing middleware data",
        "In the APM Summary page",
        "In the APM Transactions page",
        "In APM transaction trace summary",
        "Disabling Rack instrumentation",
        "Installing Ruby agent middlewares manually",
        "Manual Rack instrumentation"
      ],
      "title": "Rack middlewares",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Instrumented gems"
      ],
      "external_id": "fa34ef9ebcf8904e3601568b15d53bfe825424f4",
      "image": "https://docs.newrelic.com/static/6a0f3d54778590afddb09dde98b4773e/c1b63/web_transactions.png",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/instrumented-gems/rack-middlewares/",
      "published_at": "2021-06-02T21:17:52Z",
      "updated_at": "2021-05-05T14:33:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Ruby agent automatically instruments Rack middlewares. If you are unfamiliar with the basics of Rack middlewares, review the resources linked by the Rails on Rack guide. Additionally, the Ruby agent provides some features via Rack middlewares: Cross application traces Auto-instrumentation for Browser monitoring New Relic automatically installs these middlewares for Rails and Sinatra. Rack instrumentation The two most common ways to configure Rack middlewares are the Rack::Builder API (most often from config.ru) and Rails' middleware stack configuration: Rack::Builder Middlewares in your config.ru file are configured using Rack::Builder. For the Ruby agent to instrument middlewares from Rack::Builder, your app must run version 1.1.0 or higher of the rack gem. This is the most common use of middlewares with Sinatra or pure-rack applications. Rails middlewares Rails uses its own class (ActionDispatch::MiddlewareStack) instead of Rack::Builder to configure middlewares. Even if you haven't explicitly added middlewares to your Rails application, many components of Rails itself are implemented as middleware, so middleware data will appear by default. The Ruby agent automatically instruments middlewares added via ActionDispatch::MiddlewareStack on Rails 3.0 or higher. For more information about configuring middlewares with Rails, see the Ruby on Rails guide. Viewing middleware data You can view middleware data in APM. In the APM Summary page The main chart on your app's APM Summary page includes a purple bar that shows average time per request spent in all Rack middlewares for your application. APM > (selected application) > Summary: Middleware time appears in purple on your app's main Overview chart. In the APM Transactions page You can also see time for individual middlewares for a specific transaction name from your app's APM Transactions page. APM > (selected application) > Monitor > Transactions > (selected transaction) > Trace details: Here is an example of middleware time for a selected transaction for your app. In APM transaction trace summary Transaction traces also capture detailed middleware call information. APM > (selected application) > Monitor > Transactions > (selected transaction trace): Here is an example of middleware details in a transaction trace. Disabling Rack instrumentation If you do not want to instrument Rack middlewares, you may disable Rack middleware instrumentation with the disable_middleware_instrumentation setting. You can also ignore specific transactions. Installing Ruby agent middlewares manually The Ruby agent's implementation of New Relic's Cross Application Tracing feature uses Rack middleware instrumentation to read and write HTTP headers that are necessary to pass information between monitored applications. If you have disabled middleware instrumentation as described above and want to use cross application tracing, you must manually add the NewRelic::Rack::AgentHooks middleware to your middleware stack. For more information, see Cross application tracing in Ruby. Manual Rack instrumentation Earlier versions of the Ruby agent supported manually instrumenting Rack middlewares via the NewRelic::Agent::Instrumentation::Rack module. This instrumentation is deprecated in Ruby agent versions 3.9.0 or higher, because it is unnecessary with automatic middleware instrumentation. New Relic recommends that you remove references to this module from your code after upgrading to 3.9.0 or higher.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 160.02754,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Installing <em>Ruby</em> <em>agent</em> middlewares manually",
        "tags": "<em>Instrumented</em> <em>gems</em>",
        "body": " config.ru file are configured using Rack::Builder. For the <em>Ruby</em> <em>agent</em> to <em>instrument</em> middlewares from Rack::Builder, your app must run version 1.1.0 or higher of the rack <em>gem</em>. This is the most common use of middlewares with Sinatra or pure-rack applications. Rails middlewares Rails uses its own class"
      },
      "id": "603ebc9ae7b9d2754a2a0810"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.19994,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Mongo instrumentation",
        "Contents",
        "Supported gems",
        "Third-party and rpm_contrib instrumentation",
        "Disabling instrumentation",
        "For more help"
      ],
      "title": "Mongo instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Instrumented gems"
      ],
      "external_id": "140273418eb46eab0e42622805c8585f81db9cd4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/frameworks/mongo-instrumentation/",
      "published_at": "2021-05-28T18:26:18Z",
      "updated_at": "2021-03-16T06:42:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Ruby agent has built-in instrumentation for MongoDB queries made via the mongo gem. Contents Supported gems This summarizes the Ruby agent's support for gems by version. Gem version Comments mongo 1.8 and 1.9 Supported by New Relic's Ruby agent 3.7.1 or higher mongo 2.0 Not supported mongo 2.1 or higher Requires New Relic's Ruby agent 3.13.1 or higher Other gems Support for Mongoid 2/3/4 and Moped currently is available only via third-party gems. For links to the relevant projects, see the plugin list on rpm_contrib. Third-party and rpm_contrib instrumentation The rpm_contrib and newrelic_mongo gems both provided basic instrumentation for mongo. New Relic does not recommend running Mongo instrumentation via these gems alongside the Ruby agent's built-in Mongo support. This might double-count metrics such as overall database time. Also, the rpm_contrib and newrelic_mongo gems both use a distinct setting that can be used to disable them if removing those gems entirely isn't possible in your environment. For those third party gems, set disable_mongodb: false in your newrelic.yml. Disabling instrumentation To disable Mongo instrumentation in the agent, add the following to your newrelic.yml: disable_mongo: true Copy For more help Additional documentation resources include: New Relic for Ruby (compatibility and requirements, general information about installation, configuration, troubleshooting, and known issues) Ruby agent installation (using the New Relic Ruby gem and configuration file)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.59412,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Mongo <em>instrumentation</em>",
        "sections": "Mongo <em>instrumentation</em>",
        "tags": "<em>Instrumented</em> <em>gems</em>",
        "body": "The <em>Ruby</em> <em>agent</em> has built-in instrumentation for MongoDB queries made via the mongo <em>gem</em>. Contents Supported <em>gems</em> This summarizes the <em>Ruby</em> <em>agent</em>&#x27;s support for <em>gems</em> by version. <em>Gem</em> version Comments mongo 1.8 and 1.9 Supported by New Relic&#x27;s <em>Ruby</em> <em>agent</em> 3.7.1 or higher mongo 2.0 Not supported mongo 2.1"
      },
      "id": "603ebcd0e7b9d2b7862a07e6"
    }
  ],
  "/docs/agents/ruby-agent/instrumented-gems/sinatra-instrumentation": [
    {
      "sections": [
        "Rack middlewares",
        "Rack instrumentation",
        "Rack::Builder",
        "Rails middlewares",
        "Viewing middleware data",
        "In the APM Summary page",
        "In the APM Transactions page",
        "In APM transaction trace summary",
        "Disabling Rack instrumentation",
        "Installing Ruby agent middlewares manually",
        "Manual Rack instrumentation"
      ],
      "title": "Rack middlewares",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Instrumented gems"
      ],
      "external_id": "fa34ef9ebcf8904e3601568b15d53bfe825424f4",
      "image": "https://docs.newrelic.com/static/6a0f3d54778590afddb09dde98b4773e/c1b63/web_transactions.png",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/instrumented-gems/rack-middlewares/",
      "published_at": "2021-06-02T21:17:52Z",
      "updated_at": "2021-05-05T14:33:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Ruby agent automatically instruments Rack middlewares. If you are unfamiliar with the basics of Rack middlewares, review the resources linked by the Rails on Rack guide. Additionally, the Ruby agent provides some features via Rack middlewares: Cross application traces Auto-instrumentation for Browser monitoring New Relic automatically installs these middlewares for Rails and Sinatra. Rack instrumentation The two most common ways to configure Rack middlewares are the Rack::Builder API (most often from config.ru) and Rails' middleware stack configuration: Rack::Builder Middlewares in your config.ru file are configured using Rack::Builder. For the Ruby agent to instrument middlewares from Rack::Builder, your app must run version 1.1.0 or higher of the rack gem. This is the most common use of middlewares with Sinatra or pure-rack applications. Rails middlewares Rails uses its own class (ActionDispatch::MiddlewareStack) instead of Rack::Builder to configure middlewares. Even if you haven't explicitly added middlewares to your Rails application, many components of Rails itself are implemented as middleware, so middleware data will appear by default. The Ruby agent automatically instruments middlewares added via ActionDispatch::MiddlewareStack on Rails 3.0 or higher. For more information about configuring middlewares with Rails, see the Ruby on Rails guide. Viewing middleware data You can view middleware data in APM. In the APM Summary page The main chart on your app's APM Summary page includes a purple bar that shows average time per request spent in all Rack middlewares for your application. APM > (selected application) > Summary: Middleware time appears in purple on your app's main Overview chart. In the APM Transactions page You can also see time for individual middlewares for a specific transaction name from your app's APM Transactions page. APM > (selected application) > Monitor > Transactions > (selected transaction) > Trace details: Here is an example of middleware time for a selected transaction for your app. In APM transaction trace summary Transaction traces also capture detailed middleware call information. APM > (selected application) > Monitor > Transactions > (selected transaction trace): Here is an example of middleware details in a transaction trace. Disabling Rack instrumentation If you do not want to instrument Rack middlewares, you may disable Rack middleware instrumentation with the disable_middleware_instrumentation setting. You can also ignore specific transactions. Installing Ruby agent middlewares manually The Ruby agent's implementation of New Relic's Cross Application Tracing feature uses Rack middleware instrumentation to read and write HTTP headers that are necessary to pass information between monitored applications. If you have disabled middleware instrumentation as described above and want to use cross application tracing, you must manually add the NewRelic::Rack::AgentHooks middleware to your middleware stack. For more information, see Cross application tracing in Ruby. Manual Rack instrumentation Earlier versions of the Ruby agent supported manually instrumenting Rack middlewares via the NewRelic::Agent::Instrumentation::Rack module. This instrumentation is deprecated in Ruby agent versions 3.9.0 or higher, because it is unnecessary with automatic middleware instrumentation. New Relic recommends that you remove references to this module from your code after upgrading to 3.9.0 or higher.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 160.02753,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Installing <em>Ruby</em> <em>agent</em> middlewares manually",
        "tags": "<em>Instrumented</em> <em>gems</em>",
        "body": " config.ru file are configured using Rack::Builder. For the <em>Ruby</em> <em>agent</em> to <em>instrument</em> middlewares from Rack::Builder, your app must run version 1.1.0 or higher of the rack <em>gem</em>. This is the most common use of middlewares with Sinatra or pure-rack applications. Rails middlewares Rails uses its own class"
      },
      "id": "603ebc9ae7b9d2754a2a0810"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.19981,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Mongo instrumentation",
        "Contents",
        "Supported gems",
        "Third-party and rpm_contrib instrumentation",
        "Disabling instrumentation",
        "For more help"
      ],
      "title": "Mongo instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Instrumented gems"
      ],
      "external_id": "140273418eb46eab0e42622805c8585f81db9cd4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/frameworks/mongo-instrumentation/",
      "published_at": "2021-05-28T18:26:18Z",
      "updated_at": "2021-03-16T06:42:33Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Ruby agent has built-in instrumentation for MongoDB queries made via the mongo gem. Contents Supported gems This summarizes the Ruby agent's support for gems by version. Gem version Comments mongo 1.8 and 1.9 Supported by New Relic's Ruby agent 3.7.1 or higher mongo 2.0 Not supported mongo 2.1 or higher Requires New Relic's Ruby agent 3.13.1 or higher Other gems Support for Mongoid 2/3/4 and Moped currently is available only via third-party gems. For links to the relevant projects, see the plugin list on rpm_contrib. Third-party and rpm_contrib instrumentation The rpm_contrib and newrelic_mongo gems both provided basic instrumentation for mongo. New Relic does not recommend running Mongo instrumentation via these gems alongside the Ruby agent's built-in Mongo support. This might double-count metrics such as overall database time. Also, the rpm_contrib and newrelic_mongo gems both use a distinct setting that can be used to disable them if removing those gems entirely isn't possible in your environment. For those third party gems, set disable_mongodb: false in your newrelic.yml. Disabling instrumentation To disable Mongo instrumentation in the agent, add the following to your newrelic.yml: disable_mongo: true Copy For more help Additional documentation resources include: New Relic for Ruby (compatibility and requirements, general information about installation, configuration, troubleshooting, and known issues) Ruby agent installation (using the New Relic Ruby gem and configuration file)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.59412,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Mongo <em>instrumentation</em>",
        "sections": "Mongo <em>instrumentation</em>",
        "tags": "<em>Instrumented</em> <em>gems</em>",
        "body": "The <em>Ruby</em> <em>agent</em> has built-in instrumentation for MongoDB queries made via the mongo <em>gem</em>. Contents Supported <em>gems</em> This summarizes the <em>Ruby</em> <em>agent</em>&#x27;s support for <em>gems</em> by version. <em>Gem</em> version Comments mongo 1.8 and 1.9 Supported by New Relic&#x27;s <em>Ruby</em> <em>agent</em> 3.7.1 or higher mongo 2.0 Not supported mongo 2.1"
      },
      "id": "603ebcd0e7b9d2b7862a07e6"
    }
  ],
  "/docs/agents/ruby-agent/troubleshooting/control-when-ruby-agent-starts": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.19981,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.47427,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Ruby</em> <em>agent</em> attributes",
        "sections": "<em>Ruby</em> <em>agent</em> attributes",
        "tags": "<em>Ruby</em> <em>agent</em>",
        "body": " attributes (types, destinations, and limits for attributes used by New Relic <em>agents</em>) Enabling and disabling attributes (properties, rules, and backwards compatibility information for <em>Ruby</em> <em>agent</em> attributes) Attribute examples (scenarios and results of enabling and disabling different <em>Ruby</em> <em>agent</em> attributes)"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.60611,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Agents</em>",
        "body": " an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by <em>agent</em>. (The properties in this diagram are specific to the PHP <em>agent</em>, but the general flow is the same for all <em>agents</em>. Property names and syntax vary by <em>agent</em>.) Types of attributes"
      },
      "id": "603eb9db28ccbc127aeba79e"
    }
  ],
  "/docs/agents/ruby-agent/troubleshooting/generating-logs-troubleshooting-ruby": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.19968,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.47414,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Ruby</em> <em>agent</em> attributes",
        "sections": "<em>Ruby</em> <em>agent</em> attributes",
        "tags": "<em>Ruby</em> <em>agent</em>",
        "body": " attributes (types, destinations, and limits for attributes used by New Relic <em>agents</em>) Enabling and disabling attributes (properties, rules, and backwards compatibility information for <em>Ruby</em> <em>agent</em> attributes) Attribute examples (scenarios and results of enabling and disabling different <em>Ruby</em> <em>agent</em> attributes)"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.60602,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Agents</em>",
        "body": " an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by <em>agent</em>. (The properties in this diagram are specific to the PHP <em>agent</em>, but the general flow is the same for all <em>agents</em>. Property names and syntax vary by <em>agent</em>.) Types of attributes"
      },
      "id": "603eb9db28ccbc127aeba79e"
    }
  ],
  "/docs/agents/ruby-agent/troubleshooting/incompatible-gems": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.19968,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.47414,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Ruby</em> <em>agent</em> attributes",
        "sections": "<em>Ruby</em> <em>agent</em> attributes",
        "tags": "<em>Ruby</em> <em>agent</em>",
        "body": " attributes (types, destinations, and limits for attributes used by New Relic <em>agents</em>) Enabling and disabling attributes (properties, rules, and backwards compatibility information for <em>Ruby</em> <em>agent</em> attributes) Attribute examples (scenarios and results of enabling and disabling different <em>Ruby</em> <em>agent</em> attributes)"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.60602,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Agents</em>",
        "body": " an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by <em>agent</em>. (The properties in this diagram are specific to the PHP <em>agent</em>, but the general flow is the same for all <em>agents</em>. Property names and syntax vary by <em>agent</em>.) Types of attributes"
      },
      "id": "603eb9db28ccbc127aeba79e"
    }
  ],
  "/docs/agents/ruby-agent/troubleshooting/no-data-appears-ruby": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.19955,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.47401,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Ruby</em> <em>agent</em> attributes",
        "sections": "<em>Ruby</em> <em>agent</em> attributes",
        "tags": "<em>Ruby</em> <em>agent</em>",
        "body": " attributes (types, destinations, and limits for attributes used by New Relic <em>agents</em>) Enabling and disabling attributes (properties, rules, and backwards compatibility information for <em>Ruby</em> <em>agent</em> attributes) Attribute examples (scenarios and results of enabling and disabling different <em>Ruby</em> <em>agent</em> attributes)"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.60592,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Agents</em>",
        "body": " an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by <em>agent</em>. (The properties in this diagram are specific to the PHP <em>agent</em>, but the general flow is the same for all <em>agents</em>. Property names and syntax vary by <em>agent</em>.) Types of attributes"
      },
      "id": "603eb9db28ccbc127aeba79e"
    }
  ],
  "/docs/agents/ruby-agent/troubleshooting/no-data-unicorn": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.19955,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.47401,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Ruby</em> <em>agent</em> attributes",
        "sections": "<em>Ruby</em> <em>agent</em> attributes",
        "tags": "<em>Ruby</em> <em>agent</em>",
        "body": " attributes (types, destinations, and limits for attributes used by New Relic <em>agents</em>) Enabling and disabling attributes (properties, rules, and backwards compatibility information for <em>Ruby</em> <em>agent</em> attributes) Attribute examples (scenarios and results of enabling and disabling different <em>Ruby</em> <em>agent</em> attributes)"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.60592,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Agents</em>",
        "body": " an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by <em>agent</em>. (The properties in this diagram are specific to the PHP <em>agent</em>, but the general flow is the same for all <em>agents</em>. Property names and syntax vary by <em>agent</em>.) Types of attributes"
      },
      "id": "603eb9db28ccbc127aeba79e"
    }
  ],
  "/docs/agents/ruby-agent/troubleshooting/no-log-file-ruby": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.19943,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.47389,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Ruby</em> <em>agent</em> attributes",
        "sections": "<em>Ruby</em> <em>agent</em> attributes",
        "tags": "<em>Ruby</em> <em>agent</em>",
        "body": " attributes (types, destinations, and limits for attributes used by New Relic <em>agents</em>) Enabling and disabling attributes (properties, rules, and backwards compatibility information for <em>Ruby</em> <em>agent</em> attributes) Attribute examples (scenarios and results of enabling and disabling different <em>Ruby</em> <em>agent</em> attributes)"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.60582,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Agents</em>",
        "body": " an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by <em>agent</em>. (The properties in this diagram are specific to the PHP <em>agent</em>, but the general flow is the same for all <em>agents</em>. Property names and syntax vary by <em>agent</em>.) Types of attributes"
      },
      "id": "603eb9db28ccbc127aeba79e"
    }
  ],
  "/docs/agents/ruby-agent/troubleshooting/not-installing-new-relic-supported-grape": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.19943,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.47389,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Ruby</em> <em>agent</em> attributes",
        "sections": "<em>Ruby</em> <em>agent</em> attributes",
        "tags": "<em>Ruby</em> <em>agent</em>",
        "body": " attributes (types, destinations, and limits for attributes used by New Relic <em>agents</em>) Enabling and disabling attributes (properties, rules, and backwards compatibility information for <em>Ruby</em> <em>agent</em> attributes) Attribute examples (scenarios and results of enabling and disabling different <em>Ruby</em> <em>agent</em> attributes)"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.60582,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Agents</em>",
        "body": " an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by <em>agent</em>. (The properties in this diagram are specific to the PHP <em>agent</em>, but the general flow is the same for all <em>agents</em>. Property names and syntax vary by <em>agent</em>.) Types of attributes"
      },
      "id": "603eb9db28ccbc127aeba79e"
    }
  ],
  "/docs/agents/ruby-agent/troubleshooting/passenger-troubleshooting": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.19943,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.47389,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Ruby</em> <em>agent</em> attributes",
        "sections": "<em>Ruby</em> <em>agent</em> attributes",
        "tags": "<em>Ruby</em> <em>agent</em>",
        "body": " attributes (types, destinations, and limits for attributes used by New Relic <em>agents</em>) Enabling and disabling attributes (properties, rules, and backwards compatibility information for <em>Ruby</em> <em>agent</em> attributes) Attribute examples (scenarios and results of enabling and disabling different <em>Ruby</em> <em>agent</em> attributes)"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.60582,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Agents</em>",
        "body": " an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by <em>agent</em>. (The properties in this diagram are specific to the PHP <em>agent</em>, but the general flow is the same for all <em>agents</em>. Property names and syntax vary by <em>agent</em>.) Types of attributes"
      },
      "id": "603eb9db28ccbc127aeba79e"
    }
  ],
  "/docs/agents/ruby-agent/troubleshooting/ruby-agent-audit-log": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.19931,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.47375,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Ruby</em> <em>agent</em> attributes",
        "sections": "<em>Ruby</em> <em>agent</em> attributes",
        "tags": "<em>Ruby</em> <em>agent</em>",
        "body": " attributes (types, destinations, and limits for attributes used by New Relic <em>agents</em>) Enabling and disabling attributes (properties, rules, and backwards compatibility information for <em>Ruby</em> <em>agent</em> attributes) Attribute examples (scenarios and results of enabling and disabling different <em>Ruby</em> <em>agent</em> attributes)"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.60573,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Agents</em>",
        "body": " an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by <em>agent</em>. (The properties in this diagram are specific to the PHP <em>agent</em>, but the general flow is the same for all <em>agents</em>. Property names and syntax vary by <em>agent</em>.) Types of attributes"
      },
      "id": "603eb9db28ccbc127aeba79e"
    }
  ],
  "/docs/agents/ruby-agent/troubleshooting/systemstackerror-stack-level-too-deep": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.19931,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.47375,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Ruby</em> <em>agent</em> attributes",
        "sections": "<em>Ruby</em> <em>agent</em> attributes",
        "tags": "<em>Ruby</em> <em>agent</em>",
        "body": " attributes (types, destinations, and limits for attributes used by New Relic <em>agents</em>) Enabling and disabling attributes (properties, rules, and backwards compatibility information for <em>Ruby</em> <em>agent</em> attributes) Attribute examples (scenarios and results of enabling and disabling different <em>Ruby</em> <em>agent</em> attributes)"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.60573,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Agents</em>",
        "body": " an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by <em>agent</em>. (The properties in this diagram are specific to the PHP <em>agent</em>, but the general flow is the same for all <em>agents</em>. Property names and syntax vary by <em>agent</em>.) Types of attributes"
      },
      "id": "603eb9db28ccbc127aeba79e"
    }
  ],
  "/docs/agents/ruby-agent/troubleshooting/update-deprecated-api-calls": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.19736,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.47267,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Ruby</em> <em>agent</em> attributes",
        "sections": "<em>Ruby</em> <em>agent</em> attributes",
        "tags": "<em>Ruby</em> <em>agent</em>",
        "body": " attributes (types, destinations, and limits for attributes used by New Relic <em>agents</em>) Enabling and disabling attributes (properties, rules, and backwards compatibility information for <em>Ruby</em> <em>agent</em> attributes) Attribute examples (scenarios and results of enabling and disabling different <em>Ruby</em> <em>agent</em> attributes)"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.6044,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Agents</em>",
        "body": " an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by <em>agent</em>. (The properties in this diagram are specific to the PHP <em>agent</em>, but the general flow is the same for all <em>agents</em>. Property names and syntax vary by <em>agent</em>.) Types of attributes"
      },
      "id": "603eb9db28ccbc127aeba79e"
    }
  ],
  "/docs/agents/ruby-agent/troubleshooting/update-private-api-calls-public-tracer-api": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 141.19736,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the <em>Ruby</em> <em>agent</em> installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the <em>Ruby</em> <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 136.47267,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Ruby</em> <em>agent</em> attributes",
        "sections": "<em>Ruby</em> <em>agent</em> attributes",
        "tags": "<em>Ruby</em> <em>agent</em>",
        "body": " attributes (types, destinations, and limits for attributes used by New Relic <em>agents</em>) Enabling and disabling attributes (properties, rules, and backwards compatibility information for <em>Ruby</em> <em>agent</em> attributes) Attribute examples (scenarios and results of enabling and disabling different <em>Ruby</em> <em>agent</em> attributes)"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 107.6044,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Agents</em>",
        "body": " an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by <em>agent</em>. (The properties in this diagram are specific to the PHP <em>agent</em>, but the general flow is the same for all <em>agents</em>. Property names and syntax vary by <em>agent</em>.) Types of attributes"
      },
      "id": "603eb9db28ccbc127aeba79e"
    }
  ],
  "/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/change-applied-intelligence-correlation-logic-decisions": [
    {
      "sections": [
        "Incident Intelligence destination examples",
        "Destination template examples",
        "Suggested OpsGenie template example",
        "Suggested ServiceNow template example",
        "Suggested Slack template example",
        "Suggested VictorOps template example",
        "Webhook and JSON format examples",
        "Webhook format and JSON example",
        "Jinja2 Default Payload",
        "Jinja2 Useful Syntax",
        "JSON schema",
        "JSON schema template"
      ],
      "title": "Incident Intelligence destination examples",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "a516d04f8b75541a6dc9338fa3ce9645ba87d620",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/incident-intelligence-destination-examples/",
      "published_at": "2021-06-02T18:22:22Z",
      "updated_at": "2021-06-02T18:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Destinations are the data outputs to Applied Intelligence, where you can view your automatically correlated incidents. You can configure Incident Intelligence destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema. Destination template examples The following template example destinations are formatted in Jinja2. Suggested OpsGenie template example { \"alias\": {{ id }}, \"message\": {{ ui_name }}, \"source\": '{{ sources }}', \"priority\": {{ priority }}, \"details\": { \"self_url\": {{ url }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"is_correlated\": {{ is_correlated }} }, \"description\": \"\"\"Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]\"\"\" } Copy Suggested ServiceNow template example { \"short_description\": {{ ui_name }}, \"description\": 'Issue Id: {{ id }}, \\n Description: {{ description }}, \\n Sources: {{ sources }}, \\n Priority: {{ priority }}, \\n Details: { \\n self_url: {{ url }}, \\n state: {{ state }}, \\n is_correlated: {{ is_correlated }}, \\n created_on: {{ created_on }}, \\n modified_on: {{ modified_on }}, \\n activated_on: {{ active_since }}, \\n closed_on: {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \\n is_correlated: {{is_correlated}} }, \\n\\n incidents: {{ incidents }}, \\n\\n pathways: {{ pathways }}' } Copy Suggested Slack template example Go to Slack incoming WebHooks Choose the right Slack workspace and click \"Add to Slack\" Select the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In New Relic Applied Intelligence, under Incident Intelligence click Destinations Add a WebHook In the end point paste the WebHook url from slack. In the custom payload, paste the following JSON: { \"blocks\": [ { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*New Relic Incident Intelligence Alert*\" } }, { \"type\": \"divider\" }, { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*CUSTOM FIELDS*:\" }, \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue ID*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Issue Title*\" }, { \"type\": \"plain_text\", \"text\": {{ id }} }, { \"type\": \"plain_text\", \"text\": {{ ui_name }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue URL*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Description*\" }, { \"type\": \"mrkdwn\", \"text\": {{ url }} }, { \"type\": \"plain_text\", \"text\": {{ description }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*State*\" }, { \"type\": \"mrkdwn\", \"text\": \"*is_correlated*\" }, { \"type\": \"plain_text\", \"text\": {{ state }} }, { \"type\": \"plain_text\", \"text\": \"{{ is_correlated }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Created On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Modified On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ created_on }}\" }, { \"type\": \"plain_text\", \"text\": \"{{ modified_on }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Activated On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Closed On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ active_since }}\" }, { \"type\": \"plain_text\", \"text\": \"{% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Aggregated Incidents*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Monitoring Tool*\" }, { \"type\": \"plain_text\", \"text\": \"{{ incident_count }}\" }, { \"type\": \"plain_text\", \"text\": {{ sources|join(', ') }} } ] } ] } Copy Suggested VictorOps template example { \"monitoring_tool\": {{ sources }}, {% if state == 'closed' %} \"message_type\": \"OK\", {% else %} \"message_type\": {{ priority }}, {% endif %} \"custom_fields\": { \"issue_url\": {{ url }}, \"description\": {{ description }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"related_incidents\": [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %} {% endfor %} ] }, \"state_message\": {{ description }}, \"entity_id\": {{ id }}, \"entity_display_name\": {{ ui_name }}, \"vo_annotate.u.NRAI_Link\": {{ url }} } Copy Webhook and JSON format examples Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). If you use webhooks to configure Incident Intelligence destinations, use these examples of the webhook body format and JSON schema. Webhook format and JSON example Webhook format: Name Description url Href A link to the UI where the issue can be seen. id String Unique identifier for the issue. title String The issue title. description String The description of the issue. priority Enum The issue priority. Can be Critical, High, Medium, or Low. state Enum The issue status. Can be Active, Closed, or Acknowledged. is_correlated Boolean True if the issue is based on correlated data. created_on String The date and time the issue was created (in ISO format). modified_on String The date and time the issue was modified (in ISO format). active_since String The date and time the issue was activated (in ISO format). closed_on String The date and time the issue was closed (in ISO format). sources List(String) List of the different sources that were used to send the events into Applied Intelligence (for example: PagerDuty). pathways List(Pathways) List of pathways that are associated with the issue. Each pathway contains an id and name: [{“id”: “pathway id”, “name”: “pathway name”}]. pathways[].id String The pathway ID. pathways[].name String The pathway name. incidents List(Incident) List of incidents that are attached to the issue. The list contains only the latest 100 incidents. incidents[].id String The incident ID. incidents[].events_count Integer The number of events used to create the incident. incidents[].title String The incident title. incidents[].description String The incident description. incidents[].labels Dictionary (String) A string to string mapping of the incident labels. Labels represent the unique entities that are used to describe the incident. incidents[].priority Enum The incident priority. Can be Critical, High, Medium, or Low. incidents[].sources List(String) The incident source. incidents[].state Enum(open, closed) The incident state. incidents[].opened_on String The date and time the incident was opened (in ISO format). incidents[].closed_on String The date and time the incident was closed (in ISO format). ui_name String Issue title. accumulations['alert/signal'] String Issue analysis summary golden signal/s (if applicable). accumulations['alert/components'] String Issue analysis summary golden components (if applicable). Jinja2 Default Payload Applied Intelligence uses a templating framework called Jinja2 in the Webhook interface. Here is a default Jinja2 payload to use: { \"id\": {{ id }}, \"url\": {{ url }}, \"ui_name\": {{ ui_name }}, \"description\": {{ description }}, \"priority\": {{ priority }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"active_since\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"sources\": {{ sources }}, \"incidents\": {{ incidents }}, \"pathways\": {{ pathways }}, } Copy Jinja2 Useful Syntax Below are a few useful Jinja2 commands to help you format your output. Casting a value to integer Example: “severity”: {{ priority | int }} Copy If clause to check if an attribute’s value is set Example: \"golden_signals\": {% if accumulations['alert/signal'] is defined %} {{ accumulations['alert/signal'] }} {% else %} None {% endif %} Copy For loop to iterate of an array of values: Example: \"description\": 'Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]' Copy Check if an array attribute's value is set: Example: \"hostname_field\": {% if incidents[0].labels['newrelic/tag/hostname'] is defined %} {{ incidents[0].labels['newrelic/tag/hostname'] }} {% else %} None {% endif %} Copy JSON schema Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). JSON schema template JSON schema: { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"definitions\": { \"Labels\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"LabelsSet\": { \"type\": \"array\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"$ref\": \"#/definitions/Labels\" }, \"uniqueItems\": true }, }, \"Annotations\": { \"type\": \"object\", \"title\": \"Additional contextual information about the Entity\", \"description\": \"Fields like title, description and priority can be described as annotations since\\nthey represent some additional information about the Incident.\\nFor example, the rule that creates the entity can have some logic that will create a title annotation field.\\nThe title will change according to the latest event received by the entity and as more\\nevent will keep coming the field may change, all this as a decision by the rule.\\nA different rule may decide not to populate the title at all.\\nSince a title can also be produced from the labels themselves.\", \"properties\": { \"title\": { \"type\": \"string\", \"maxLength\": 10000 }, \"description\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"patternProperties\": { \".*\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"Accumulations\": { \"type\": \"object\", \"title\": \"Accumulated data about the Incident\", \"description\": \"For example an entity with the label: host_name: foo will include a accumulated list of the\\nrelevant process names that are relevant to the entity. Accumulations will be derived from the events\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"type\": \"string\", \"maxLength\": 10000 } } }, \"IssueState\": { \"type\": \"string\", \"enum\": [ \"created\", \"active\", \"acknowledged\", \"closed\" ], \"properties\": {}, \"additionalProperties\": false }, \"Priority\": { \"type\": \"string\", \"enum\": [ \"critical\", \"high\", \"medium\", \"low\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueClosingReason\": { \"type\": \"string\", \"enum\": [ \"nacked\", \"resolved\", \"system\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueAction\": { \"type\": \"string\", \"enum\": [ \"ack\", \"snooze\", \"nack\", \"end_snooze\", \"expire_snooze\", \"star\", \"un_snooze\", \"unstar\", \"archive\", \"unarchive\", \"resolve\", \"reopen\", \"open\", \"feedback\", \"feedback_file\", \"open_ticket\", \"merge_issues\", \"active\", \"create\", \"close\", \"incident_updated\", \"confidence_changed\", \"diagnoses_changed\", \"rule_properties_changed\", \"flapping\", \"notification\", \"incident_events_limit_reached\", \"follow\", \"unfollow\", \"priority_updated\", \"comment\", \"incident_appended\", \"diagnosis_feedback\", \"flapping_delay_close\" ], \"properties\": {}, \"additionalProperties\": false }, \"StringKeyValue\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\" } }, \"JavaOptionalUuid\": { \"type\": \"string\", \"properties\": {}, \"additionalProperties\": false, \"format\": \"string-uuid\" } }, \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"customer_id\": { \"type\": \"integer\" }, \"labels_set\": { \"$ref\": \"#/definitions/LabelsSet\" }, \"annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations_version\": { \"type\": \"integer\" }, \"accumulations\": { \"$ref\": \"#/definitions/Accumulations\" }, \"state\": { \"$ref\": \"#/definitions/IssueState\" }, \"previous_state\": { \"$ref\": \"#/definitions/IssueState\" }, \"priority\": { \"$ref\": \"#/definitions/Priority\" }, \"closing_reason\": { \"oneOf\": [ { \"$ref\": \"#/definitions/IssueClosingReason\" }, { \"type\": \"null\" } ] }, \"modified_on\": { \"type\": \"integer\" }, \"created_on\": { \"type\": \"integer\" }, \"closed_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"acknowledged_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"active_since\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"assigned_to\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"created_by\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"progress_report\": { \"type\": \"array\", \"default\": [], \"items\": { \"type\": \"object\", \"properties\": { \"origin_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1 }, { \"type\": \"null\" } ] }, \"timestamp\": { \"type\": \"integer\" }, \"action_timestamp\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"origin_type\": { \"type\": \"string\", \"enum\": [ \"user\", \"system\" ] }, \"event_type\": { \"$ref\": \"#/definitions/IssueAction\" }, \"issue_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"format\": \"string-uuid\" }, { \"type\": \"null\" } ] }, \"attributes\": { \"oneOf\": [ { \"$ref\": \"#/definitions/StringKeyValue\" }, { \"type\": \"null\" } ] }, \"team_id\": { \"$ref\": \"#/definitions/JavaOptionalUuid\" } }, \"required\": [ \"timestamp\", \"origin_type\", \"event_type\" ], \"additionalProperties\": false }, \"uniqueItems\": true }, \"rule_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"maxLength\": 255 }, { \"type\": \"null\" } ] }, \"incident_ids\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"confidence\": { \"type\": \"number\", \"default\": 1.0, \"minimum\": 0.0, \"maximum\": 1.0 } }, \"required\": [ \"id\", \"customer_id\", \"labels_set\", \"annotations\", \"priority\", \"modified_on\", \"created_on\", \"confidence\" ], \"additionalProperties\": true } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 235.00974,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Incident <em>Intelligence</em> destination examples",
        "sections": "Incident <em>Intelligence</em> destination examples",
        "tags": "Alerts and <em>Applied</em> <em>Intelligence</em>",
        "body": "Destinations are the data outputs to <em>Applied</em> <em>Intelligence</em>, where you can view your automatically correlated incidents. You can configure Incident <em>Intelligence</em> destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema"
      },
      "id": "6044280d64441f4af5378ed3"
    },
    {
      "sections": [
        "Expanded anomaly detection",
        "Requirements",
        "Why it matters",
        "Get started with anomaly detection",
        "Detect anomalies with a faceted NRQL query",
        "See your anomalies in one place",
        "Tip",
        "Query anomaly data",
        "Reduce the number of detected anomalies"
      ],
      "title": "Expanded anomaly detection",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Proactive detection"
      ],
      "external_id": "0b07c0b6ce27f39b5edb3e112a0f949835cbb8c6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/proactive-detection/expanded-anomaly-detection/",
      "published_at": "2021-06-02T18:27:12Z",
      "updated_at": "2021-05-31T16:43:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We’ve expanded anomaly detection coverage beyond your APM applications. Configure anomaly detection for your browser applications, mobile applications, infrastructure hosts, and nearly anything you want to monitor. Requirements Expanded anomaly detection is available as a limited beta. You can request access here. Why it matters When starting to configure alert conditions for a variety of applications and hosts, it can be difficult to know what you’ll want to be notified about ahead of time. Anomaly detection helps you distinguish between what’s typical performance in your system and where you’re starting to have trouble. Instead of creating your alert conditions manually, you can simply tell us what you want to monitor. Anomaly detection will help you identify baseline performance in your system and flags anomalous activity in your system. Get started with anomaly detection To get started with expanded anomaly detection: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Select the account you want to use to record anomaly data, then select the workload or entities you’d like to monitor. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name your configuration and save. Detect anomalies with a faceted NRQL query To detect anomalies with a faceted NRQL query: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Click Use a query instead. You may need to select an account, if you have more than one. Add one or more queries with a FACET clause. Name the query and confirm the facets you want to monitor for anomalies. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name the configuration and save. See your anomalies in one place When you set up anomaly detection, New Relic starts analyzing the golden signals of your entities and workloads. Anomalies appear in your activity feeds throughout New Relic One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL alert condition for the NrAiAnomaly event. To view anomalies, from one.newrelic.com, go to Alerts & AI > Issues & activity > Anomalies. Query anomaly data Detected anomalies are written to the NrAiAnomaly event in your NRDB account. You can learn more about this event and how to query it here. Reduce the number of detected anomalies If you’re seeing too many anomalies, the first step is to make sure your sensitivity level is set to Low. If it’s already set to Low, you can define specific thresholds to distinguish between normal and anomalous behavior. To define custom thresholds: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab and the configuration you want to modify. Select an entity or workload, and then change the sensitivity level. You can use custom sensitivity to define specific thresholds for different entity types.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 190.5931,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Get started <em>with</em> anomaly detection",
        "tags": "Alerts and <em>Applied</em> <em>Intelligence</em>",
        "body": " to Alerts &amp; AI &gt; Proactive Detection &gt; Settings. Click the Custom tab and the configuration you want to modify. Select an entity or workload, and then <em>change</em> the sensitivity level. You can use custom sensitivity to define specific thresholds for different entity types."
      },
      "id": "60b5124064441ff965e2cb01"
    },
    {
      "sections": [
        "Use Incident Intelligence",
        "Issue summary",
        "Impacted entities map",
        "Use suggested responders",
        "Important",
        "Tip",
        "Root cause analysis",
        "Issue timeline",
        "Related activity",
        "Use decisions"
      ],
      "title": "Use Incident Intelligence",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "f7b852fa406a6e9ff88b791e4cbccc2bd20a5962",
      "image": "https://docs.newrelic.com/static/6e37cc77304398121e1a0080a57e47bb/8c557/screenshot_incident_intelligence_timeline_event_detail.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/use-incident-intelligence/",
      "published_at": "2021-06-02T18:23:21Z",
      "updated_at": "2021-05-28T11:09:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you set up Incident Intelligence, our system will begin finding issues from your data sources. In the issue feed, you can find an overview of all your issues, along with helpful information about them. You can also click any individual issue for more detail, including its analysis summary, event log, and details about correlated issues. This screenshot shows an example issue feed, which describes your issues' statuses, correlations, and more. What's the difference between an issue, incident, and event? In short, these terms are like building blocks. Events are raw data from your sources. Incidents are made up of one or more events. Issues are composed of one or more incidents. In more detail: Events indicate a state change or trigger defined by your monitoring systems. An event contains information about the affected entity, and they are almost always triggered automatically by the system. Incidents are groups of events that describe the \"symptoms\" of your system over time. These symptoms are detected by your monitoring tools, which evaluate your data streams and events. Issues are groups of incidents that describe the underlying problem of your symptoms. When a new incident is created, Incident Intelligence opens an issue and evaluates other open issues for correlations. Issue summary The Issue page is built to provide you with bottom line insights first to understand the problem, and then to minimize the time you need to resolve it. The Issue page includes the following sections: Issue summary: This section has two machine learning modules, the golden signals and the related components. Suggested responders: This section will tell you who to potentially reach out to on your team to solve a specific problem. Label sets: Label sets are focused on incidents that come from 3rd party sources, such as PagerDuty, AWS Cloudwatch, REST APIs, etc., as well as for NRQL queries. They come in the form of key:value pairs. Impacted entities: An entity is anything that has data you can monitor. Specifically, these are focused on incidents from New Relic sources, extracting the entities and providing a summary. Each entity is unique. You can see your entities in a list or on a map. Depending on the data in an issue, all four of these sections can show up together for each issue or separately. If you hover over an impacted entity application, you’ll notice a few calls to action: relevant dashboards, anomaly overview, deployment events, and entity overview. Relevant dashboards helps users in your account look at and interact with dashboards you've created that are related to an entity. The queries you've run to power the various widgets are automatically mapped to entities whenever possible and are presented back to you here for quick access and discovery. Anomaly overview will open the application's anomalies page. This is only available for applications that are set up for Proactive Detection. There are two types of deployment events: deployments and related deployments. Click Show all deployments to see all your deployment events when they arrive, or click a specific deployment to see its APM deployments page. The APM deployment page lists recent deployments and their impact on your end user and app server's Apdex scores, response times, throughput, and errors. This section will only show up if New Relic has identified applications under the impacted entities that have deployments. Impacted entities map Hover over an entity to see more information about it. An impacted entities map is available for any issue involving two or more entities. The map shows not only the affected entities, but also the services and resources directly related to those entities. Use suggested responders If you’re using PagerDuty or New Relic alerts violations as your incident notification tools, Incident Intelligence suggests relevant team members that can help resolve your issues. Incident Intelligence learns from your PagerDuty and alerts violations data to provide suggestions for each new incident. Once you receive a suggestion, you can contact the responder or search for relevant documentation that person may have written. To get started, enable PagerDuty or alerts violations as a source for Incident Intelligence. Afterwards, you can view the suggestions in two places: The issue feed, where you can also provide feedback on the suggestions. Directly within PagerDuty (both UI and API.) If you’re also using PagerDuty as a destination, the suggestions will appear in your issue notifications payload. Important This feature doesn't account for on-call availability at the time of incident. Tip In order to train the model, we use the information PagerDuty provides about individuals. We ingest incident information only, not users’ contact details. Root cause analysis Root cause analysis automatically finds potential causes for an issue and its impacted entities. It shows you why open issues occurred, which deployments contributed, and relevant error logs and attributes. With this, you can investigate the problem and reduce your mean time to resolution (MTTR). Tip Note that root cause analysis is dependent on other New Relic data sources and features. This is why root cause analysis information may not always be present for every issue. When you select an issue, you may see Root cause analysis information. Root cause analysis includes three main UI sections: Deployment events: When you set up deployments, we provide the deployment nearest to the issue creation. Changes, such as deployments, account for a high percentage of the root causes of incidents and having that information at hand can help diagnose and resolve issues. Error logs: You can explore millions of log messages with a single click and use manual querying to help you find anomalous patterns and hard-to-find problems. Attributes to investigate: We scan the distribution of attributes and surface possible causes by finding significant changes in the distribution. This section also shows changes in database and external metrics. You can also query interesting attributes. Issue timeline The issue timeline, as presented below, shows you a breakdown of: Incidents The trends taking place What incidents are active What incidents are resolved What is correlated to each other Various milestones at different issue levels In addition, you’ll see a grey line at the top of the timeline. In comparison to the visual timeline that shows the changes to each incident, the grey line represents changes to the issue. Mouse over the grey line to see details of the event. Finally, mouse over the incident to see information on the location, timing, and level of importance of a specific incident. This figure shows a particular incident populated on January 11th with a level of Critical. To view the issues in a text format, in the right hand corner, click Switch to issue log view. Related activity The issue page includes a Related activity section, which is a table displaying activity related to the incident or anomally you are are trying to analyze. You can click each line item in the table to view a unique dashboard that displays data for the entity the incident or anomally came from. The related activity section aggregates a set of incidents into a single issue, according to a rule-based system. Use decisions To further reduce noise or get improved incident correlation, you can change or customize your decisions. Decisions determine how Incident Intelligence groups incidents together. To get started, see Decisions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 177.74109,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use Incident <em>Intelligence</em>",
        "sections": "Use Incident <em>Intelligence</em>",
        "tags": "Alerts and <em>Applied</em> <em>Intelligence</em>",
        "body": " or anomally came from. The related activity section aggregates a set of incidents into a single issue, according to a rule-based system. Use <em>decisions</em> To further reduce noise or get improved incident <em>correlation</em>, you can <em>change</em> or customize your <em>decisions</em>. <em>Decisions</em> determine how Incident <em>Intelligence</em> groups incidents together. To get started, see <em>Decisions</em>."
      },
      "id": "6080293564441fd0669d8580"
    }
  ],
  "/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/eu-us-datacenters-incident-intelligence": [
    {
      "sections": [
        "Incident Intelligence destination examples",
        "Destination template examples",
        "Suggested OpsGenie template example",
        "Suggested ServiceNow template example",
        "Suggested Slack template example",
        "Suggested VictorOps template example",
        "Webhook and JSON format examples",
        "Webhook format and JSON example",
        "Jinja2 Default Payload",
        "Jinja2 Useful Syntax",
        "JSON schema",
        "JSON schema template"
      ],
      "title": "Incident Intelligence destination examples",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "a516d04f8b75541a6dc9338fa3ce9645ba87d620",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/incident-intelligence-destination-examples/",
      "published_at": "2021-06-02T18:22:22Z",
      "updated_at": "2021-06-02T18:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Destinations are the data outputs to Applied Intelligence, where you can view your automatically correlated incidents. You can configure Incident Intelligence destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema. Destination template examples The following template example destinations are formatted in Jinja2. Suggested OpsGenie template example { \"alias\": {{ id }}, \"message\": {{ ui_name }}, \"source\": '{{ sources }}', \"priority\": {{ priority }}, \"details\": { \"self_url\": {{ url }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"is_correlated\": {{ is_correlated }} }, \"description\": \"\"\"Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]\"\"\" } Copy Suggested ServiceNow template example { \"short_description\": {{ ui_name }}, \"description\": 'Issue Id: {{ id }}, \\n Description: {{ description }}, \\n Sources: {{ sources }}, \\n Priority: {{ priority }}, \\n Details: { \\n self_url: {{ url }}, \\n state: {{ state }}, \\n is_correlated: {{ is_correlated }}, \\n created_on: {{ created_on }}, \\n modified_on: {{ modified_on }}, \\n activated_on: {{ active_since }}, \\n closed_on: {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \\n is_correlated: {{is_correlated}} }, \\n\\n incidents: {{ incidents }}, \\n\\n pathways: {{ pathways }}' } Copy Suggested Slack template example Go to Slack incoming WebHooks Choose the right Slack workspace and click \"Add to Slack\" Select the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In New Relic Applied Intelligence, under Incident Intelligence click Destinations Add a WebHook In the end point paste the WebHook url from slack. In the custom payload, paste the following JSON: { \"blocks\": [ { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*New Relic Incident Intelligence Alert*\" } }, { \"type\": \"divider\" }, { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*CUSTOM FIELDS*:\" }, \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue ID*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Issue Title*\" }, { \"type\": \"plain_text\", \"text\": {{ id }} }, { \"type\": \"plain_text\", \"text\": {{ ui_name }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue URL*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Description*\" }, { \"type\": \"mrkdwn\", \"text\": {{ url }} }, { \"type\": \"plain_text\", \"text\": {{ description }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*State*\" }, { \"type\": \"mrkdwn\", \"text\": \"*is_correlated*\" }, { \"type\": \"plain_text\", \"text\": {{ state }} }, { \"type\": \"plain_text\", \"text\": \"{{ is_correlated }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Created On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Modified On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ created_on }}\" }, { \"type\": \"plain_text\", \"text\": \"{{ modified_on }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Activated On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Closed On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ active_since }}\" }, { \"type\": \"plain_text\", \"text\": \"{% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Aggregated Incidents*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Monitoring Tool*\" }, { \"type\": \"plain_text\", \"text\": \"{{ incident_count }}\" }, { \"type\": \"plain_text\", \"text\": {{ sources|join(', ') }} } ] } ] } Copy Suggested VictorOps template example { \"monitoring_tool\": {{ sources }}, {% if state == 'closed' %} \"message_type\": \"OK\", {% else %} \"message_type\": {{ priority }}, {% endif %} \"custom_fields\": { \"issue_url\": {{ url }}, \"description\": {{ description }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"related_incidents\": [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %} {% endfor %} ] }, \"state_message\": {{ description }}, \"entity_id\": {{ id }}, \"entity_display_name\": {{ ui_name }}, \"vo_annotate.u.NRAI_Link\": {{ url }} } Copy Webhook and JSON format examples Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). If you use webhooks to configure Incident Intelligence destinations, use these examples of the webhook body format and JSON schema. Webhook format and JSON example Webhook format: Name Description url Href A link to the UI where the issue can be seen. id String Unique identifier for the issue. title String The issue title. description String The description of the issue. priority Enum The issue priority. Can be Critical, High, Medium, or Low. state Enum The issue status. Can be Active, Closed, or Acknowledged. is_correlated Boolean True if the issue is based on correlated data. created_on String The date and time the issue was created (in ISO format). modified_on String The date and time the issue was modified (in ISO format). active_since String The date and time the issue was activated (in ISO format). closed_on String The date and time the issue was closed (in ISO format). sources List(String) List of the different sources that were used to send the events into Applied Intelligence (for example: PagerDuty). pathways List(Pathways) List of pathways that are associated with the issue. Each pathway contains an id and name: [{“id”: “pathway id”, “name”: “pathway name”}]. pathways[].id String The pathway ID. pathways[].name String The pathway name. incidents List(Incident) List of incidents that are attached to the issue. The list contains only the latest 100 incidents. incidents[].id String The incident ID. incidents[].events_count Integer The number of events used to create the incident. incidents[].title String The incident title. incidents[].description String The incident description. incidents[].labels Dictionary (String) A string to string mapping of the incident labels. Labels represent the unique entities that are used to describe the incident. incidents[].priority Enum The incident priority. Can be Critical, High, Medium, or Low. incidents[].sources List(String) The incident source. incidents[].state Enum(open, closed) The incident state. incidents[].opened_on String The date and time the incident was opened (in ISO format). incidents[].closed_on String The date and time the incident was closed (in ISO format). ui_name String Issue title. accumulations['alert/signal'] String Issue analysis summary golden signal/s (if applicable). accumulations['alert/components'] String Issue analysis summary golden components (if applicable). Jinja2 Default Payload Applied Intelligence uses a templating framework called Jinja2 in the Webhook interface. Here is a default Jinja2 payload to use: { \"id\": {{ id }}, \"url\": {{ url }}, \"ui_name\": {{ ui_name }}, \"description\": {{ description }}, \"priority\": {{ priority }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"active_since\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"sources\": {{ sources }}, \"incidents\": {{ incidents }}, \"pathways\": {{ pathways }}, } Copy Jinja2 Useful Syntax Below are a few useful Jinja2 commands to help you format your output. Casting a value to integer Example: “severity”: {{ priority | int }} Copy If clause to check if an attribute’s value is set Example: \"golden_signals\": {% if accumulations['alert/signal'] is defined %} {{ accumulations['alert/signal'] }} {% else %} None {% endif %} Copy For loop to iterate of an array of values: Example: \"description\": 'Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]' Copy Check if an array attribute's value is set: Example: \"hostname_field\": {% if incidents[0].labels['newrelic/tag/hostname'] is defined %} {{ incidents[0].labels['newrelic/tag/hostname'] }} {% else %} None {% endif %} Copy JSON schema Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). JSON schema template JSON schema: { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"definitions\": { \"Labels\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"LabelsSet\": { \"type\": \"array\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"$ref\": \"#/definitions/Labels\" }, \"uniqueItems\": true }, }, \"Annotations\": { \"type\": \"object\", \"title\": \"Additional contextual information about the Entity\", \"description\": \"Fields like title, description and priority can be described as annotations since\\nthey represent some additional information about the Incident.\\nFor example, the rule that creates the entity can have some logic that will create a title annotation field.\\nThe title will change according to the latest event received by the entity and as more\\nevent will keep coming the field may change, all this as a decision by the rule.\\nA different rule may decide not to populate the title at all.\\nSince a title can also be produced from the labels themselves.\", \"properties\": { \"title\": { \"type\": \"string\", \"maxLength\": 10000 }, \"description\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"patternProperties\": { \".*\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"Accumulations\": { \"type\": \"object\", \"title\": \"Accumulated data about the Incident\", \"description\": \"For example an entity with the label: host_name: foo will include a accumulated list of the\\nrelevant process names that are relevant to the entity. Accumulations will be derived from the events\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"type\": \"string\", \"maxLength\": 10000 } } }, \"IssueState\": { \"type\": \"string\", \"enum\": [ \"created\", \"active\", \"acknowledged\", \"closed\" ], \"properties\": {}, \"additionalProperties\": false }, \"Priority\": { \"type\": \"string\", \"enum\": [ \"critical\", \"high\", \"medium\", \"low\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueClosingReason\": { \"type\": \"string\", \"enum\": [ \"nacked\", \"resolved\", \"system\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueAction\": { \"type\": \"string\", \"enum\": [ \"ack\", \"snooze\", \"nack\", \"end_snooze\", \"expire_snooze\", \"star\", \"un_snooze\", \"unstar\", \"archive\", \"unarchive\", \"resolve\", \"reopen\", \"open\", \"feedback\", \"feedback_file\", \"open_ticket\", \"merge_issues\", \"active\", \"create\", \"close\", \"incident_updated\", \"confidence_changed\", \"diagnoses_changed\", \"rule_properties_changed\", \"flapping\", \"notification\", \"incident_events_limit_reached\", \"follow\", \"unfollow\", \"priority_updated\", \"comment\", \"incident_appended\", \"diagnosis_feedback\", \"flapping_delay_close\" ], \"properties\": {}, \"additionalProperties\": false }, \"StringKeyValue\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\" } }, \"JavaOptionalUuid\": { \"type\": \"string\", \"properties\": {}, \"additionalProperties\": false, \"format\": \"string-uuid\" } }, \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"customer_id\": { \"type\": \"integer\" }, \"labels_set\": { \"$ref\": \"#/definitions/LabelsSet\" }, \"annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations_version\": { \"type\": \"integer\" }, \"accumulations\": { \"$ref\": \"#/definitions/Accumulations\" }, \"state\": { \"$ref\": \"#/definitions/IssueState\" }, \"previous_state\": { \"$ref\": \"#/definitions/IssueState\" }, \"priority\": { \"$ref\": \"#/definitions/Priority\" }, \"closing_reason\": { \"oneOf\": [ { \"$ref\": \"#/definitions/IssueClosingReason\" }, { \"type\": \"null\" } ] }, \"modified_on\": { \"type\": \"integer\" }, \"created_on\": { \"type\": \"integer\" }, \"closed_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"acknowledged_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"active_since\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"assigned_to\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"created_by\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"progress_report\": { \"type\": \"array\", \"default\": [], \"items\": { \"type\": \"object\", \"properties\": { \"origin_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1 }, { \"type\": \"null\" } ] }, \"timestamp\": { \"type\": \"integer\" }, \"action_timestamp\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"origin_type\": { \"type\": \"string\", \"enum\": [ \"user\", \"system\" ] }, \"event_type\": { \"$ref\": \"#/definitions/IssueAction\" }, \"issue_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"format\": \"string-uuid\" }, { \"type\": \"null\" } ] }, \"attributes\": { \"oneOf\": [ { \"$ref\": \"#/definitions/StringKeyValue\" }, { \"type\": \"null\" } ] }, \"team_id\": { \"$ref\": \"#/definitions/JavaOptionalUuid\" } }, \"required\": [ \"timestamp\", \"origin_type\", \"event_type\" ], \"additionalProperties\": false }, \"uniqueItems\": true }, \"rule_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"maxLength\": 255 }, { \"type\": \"null\" } ] }, \"incident_ids\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"confidence\": { \"type\": \"number\", \"default\": 1.0, \"minimum\": 0.0, \"maximum\": 1.0 } }, \"required\": [ \"id\", \"customer_id\", \"labels_set\", \"annotations\", \"priority\", \"modified_on\", \"created_on\", \"confidence\" ], \"additionalProperties\": true } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 474.29898,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Incident</em> <em>Intelligence</em> destination examples",
        "sections": "<em>Incident</em> <em>Intelligence</em> destination examples",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "Destinations are the data outputs to <em>Applied</em> <em>Intelligence</em>, where you can view your automatically correlated incidents. You can configure <em>Incident</em> <em>Intelligence</em> destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema"
      },
      "id": "6044280d64441f4af5378ed3"
    },
    {
      "sections": [
        "Use Incident Intelligence",
        "Issue summary",
        "Impacted entities map",
        "Use suggested responders",
        "Important",
        "Tip",
        "Root cause analysis",
        "Issue timeline",
        "Related activity",
        "Use decisions"
      ],
      "title": "Use Incident Intelligence",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "f7b852fa406a6e9ff88b791e4cbccc2bd20a5962",
      "image": "https://docs.newrelic.com/static/6e37cc77304398121e1a0080a57e47bb/8c557/screenshot_incident_intelligence_timeline_event_detail.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/use-incident-intelligence/",
      "published_at": "2021-06-02T18:23:21Z",
      "updated_at": "2021-05-28T11:09:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you set up Incident Intelligence, our system will begin finding issues from your data sources. In the issue feed, you can find an overview of all your issues, along with helpful information about them. You can also click any individual issue for more detail, including its analysis summary, event log, and details about correlated issues. This screenshot shows an example issue feed, which describes your issues' statuses, correlations, and more. What's the difference between an issue, incident, and event? In short, these terms are like building blocks. Events are raw data from your sources. Incidents are made up of one or more events. Issues are composed of one or more incidents. In more detail: Events indicate a state change or trigger defined by your monitoring systems. An event contains information about the affected entity, and they are almost always triggered automatically by the system. Incidents are groups of events that describe the \"symptoms\" of your system over time. These symptoms are detected by your monitoring tools, which evaluate your data streams and events. Issues are groups of incidents that describe the underlying problem of your symptoms. When a new incident is created, Incident Intelligence opens an issue and evaluates other open issues for correlations. Issue summary The Issue page is built to provide you with bottom line insights first to understand the problem, and then to minimize the time you need to resolve it. The Issue page includes the following sections: Issue summary: This section has two machine learning modules, the golden signals and the related components. Suggested responders: This section will tell you who to potentially reach out to on your team to solve a specific problem. Label sets: Label sets are focused on incidents that come from 3rd party sources, such as PagerDuty, AWS Cloudwatch, REST APIs, etc., as well as for NRQL queries. They come in the form of key:value pairs. Impacted entities: An entity is anything that has data you can monitor. Specifically, these are focused on incidents from New Relic sources, extracting the entities and providing a summary. Each entity is unique. You can see your entities in a list or on a map. Depending on the data in an issue, all four of these sections can show up together for each issue or separately. If you hover over an impacted entity application, you’ll notice a few calls to action: relevant dashboards, anomaly overview, deployment events, and entity overview. Relevant dashboards helps users in your account look at and interact with dashboards you've created that are related to an entity. The queries you've run to power the various widgets are automatically mapped to entities whenever possible and are presented back to you here for quick access and discovery. Anomaly overview will open the application's anomalies page. This is only available for applications that are set up for Proactive Detection. There are two types of deployment events: deployments and related deployments. Click Show all deployments to see all your deployment events when they arrive, or click a specific deployment to see its APM deployments page. The APM deployment page lists recent deployments and their impact on your end user and app server's Apdex scores, response times, throughput, and errors. This section will only show up if New Relic has identified applications under the impacted entities that have deployments. Impacted entities map Hover over an entity to see more information about it. An impacted entities map is available for any issue involving two or more entities. The map shows not only the affected entities, but also the services and resources directly related to those entities. Use suggested responders If you’re using PagerDuty or New Relic alerts violations as your incident notification tools, Incident Intelligence suggests relevant team members that can help resolve your issues. Incident Intelligence learns from your PagerDuty and alerts violations data to provide suggestions for each new incident. Once you receive a suggestion, you can contact the responder or search for relevant documentation that person may have written. To get started, enable PagerDuty or alerts violations as a source for Incident Intelligence. Afterwards, you can view the suggestions in two places: The issue feed, where you can also provide feedback on the suggestions. Directly within PagerDuty (both UI and API.) If you’re also using PagerDuty as a destination, the suggestions will appear in your issue notifications payload. Important This feature doesn't account for on-call availability at the time of incident. Tip In order to train the model, we use the information PagerDuty provides about individuals. We ingest incident information only, not users’ contact details. Root cause analysis Root cause analysis automatically finds potential causes for an issue and its impacted entities. It shows you why open issues occurred, which deployments contributed, and relevant error logs and attributes. With this, you can investigate the problem and reduce your mean time to resolution (MTTR). Tip Note that root cause analysis is dependent on other New Relic data sources and features. This is why root cause analysis information may not always be present for every issue. When you select an issue, you may see Root cause analysis information. Root cause analysis includes three main UI sections: Deployment events: When you set up deployments, we provide the deployment nearest to the issue creation. Changes, such as deployments, account for a high percentage of the root causes of incidents and having that information at hand can help diagnose and resolve issues. Error logs: You can explore millions of log messages with a single click and use manual querying to help you find anomalous patterns and hard-to-find problems. Attributes to investigate: We scan the distribution of attributes and surface possible causes by finding significant changes in the distribution. This section also shows changes in database and external metrics. You can also query interesting attributes. Issue timeline The issue timeline, as presented below, shows you a breakdown of: Incidents The trends taking place What incidents are active What incidents are resolved What is correlated to each other Various milestones at different issue levels In addition, you’ll see a grey line at the top of the timeline. In comparison to the visual timeline that shows the changes to each incident, the grey line represents changes to the issue. Mouse over the grey line to see details of the event. Finally, mouse over the incident to see information on the location, timing, and level of importance of a specific incident. This figure shows a particular incident populated on January 11th with a level of Critical. To view the issues in a text format, in the right hand corner, click Switch to issue log view. Related activity The issue page includes a Related activity section, which is a table displaying activity related to the incident or anomally you are are trying to analyze. You can click each line item in the table to view a unique dashboard that displays data for the entity the incident or anomally came from. The related activity section aggregates a set of incidents into a single issue, according to a rule-based system. Use decisions To further reduce noise or get improved incident correlation, you can change or customize your decisions. Decisions determine how Incident Intelligence groups incidents together. To get started, see Decisions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 358.7188,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use <em>Incident</em> <em>Intelligence</em>",
        "sections": "Use <em>Incident</em> <em>Intelligence</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": ". The map shows not only the affected entities, but also the services and resources directly related to those entities. Use suggested responders If you’re using PagerDuty or New Relic <em>alerts</em> violations as your <em>incident</em> notification tools, <em>Incident</em> <em>Intelligence</em> suggests relevant team members that can"
      },
      "id": "6080293564441fd0669d8580"
    },
    {
      "sections": [
        "Expanded anomaly detection",
        "Requirements",
        "Why it matters",
        "Get started with anomaly detection",
        "Detect anomalies with a faceted NRQL query",
        "See your anomalies in one place",
        "Tip",
        "Query anomaly data",
        "Reduce the number of detected anomalies"
      ],
      "title": "Expanded anomaly detection",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Proactive detection"
      ],
      "external_id": "0b07c0b6ce27f39b5edb3e112a0f949835cbb8c6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/proactive-detection/expanded-anomaly-detection/",
      "published_at": "2021-06-02T18:27:12Z",
      "updated_at": "2021-05-31T16:43:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We’ve expanded anomaly detection coverage beyond your APM applications. Configure anomaly detection for your browser applications, mobile applications, infrastructure hosts, and nearly anything you want to monitor. Requirements Expanded anomaly detection is available as a limited beta. You can request access here. Why it matters When starting to configure alert conditions for a variety of applications and hosts, it can be difficult to know what you’ll want to be notified about ahead of time. Anomaly detection helps you distinguish between what’s typical performance in your system and where you’re starting to have trouble. Instead of creating your alert conditions manually, you can simply tell us what you want to monitor. Anomaly detection will help you identify baseline performance in your system and flags anomalous activity in your system. Get started with anomaly detection To get started with expanded anomaly detection: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Select the account you want to use to record anomaly data, then select the workload or entities you’d like to monitor. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name your configuration and save. Detect anomalies with a faceted NRQL query To detect anomalies with a faceted NRQL query: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Click Use a query instead. You may need to select an account, if you have more than one. Add one or more queries with a FACET clause. Name the query and confirm the facets you want to monitor for anomalies. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name the configuration and save. See your anomalies in one place When you set up anomaly detection, New Relic starts analyzing the golden signals of your entities and workloads. Anomalies appear in your activity feeds throughout New Relic One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL alert condition for the NrAiAnomaly event. To view anomalies, from one.newrelic.com, go to Alerts & AI > Issues & activity > Anomalies. Query anomaly data Detected anomalies are written to the NrAiAnomaly event in your NRDB account. You can learn more about this event and how to query it here. Reduce the number of detected anomalies If you’re seeing too many anomalies, the first step is to make sure your sensitivity level is set to Low. If it’s already set to Low, you can define specific thresholds to distinguish between normal and anomalous behavior. To define custom thresholds: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab and the configuration you want to modify. Select an entity or workload, and then change the sensitivity level. You can use custom sensitivity to define specific thresholds for different entity types.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 290.3354,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " request access here. Why it matters When starting to configure <em>alert</em> conditions for a variety of applications and hosts, it can be difficult to know what you’ll want to be notified about ahead of time. Anomaly detection helps you distinguish between what’s typical performance in your system and where"
      },
      "id": "60b5124064441ff965e2cb01"
    }
  ],
  "/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/get-started-incident-intelligence": [
    {
      "sections": [
        "Incident Intelligence destination examples",
        "Destination template examples",
        "Suggested OpsGenie template example",
        "Suggested ServiceNow template example",
        "Suggested Slack template example",
        "Suggested VictorOps template example",
        "Webhook and JSON format examples",
        "Webhook format and JSON example",
        "Jinja2 Default Payload",
        "Jinja2 Useful Syntax",
        "JSON schema",
        "JSON schema template"
      ],
      "title": "Incident Intelligence destination examples",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "a516d04f8b75541a6dc9338fa3ce9645ba87d620",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/incident-intelligence-destination-examples/",
      "published_at": "2021-06-02T18:22:22Z",
      "updated_at": "2021-06-02T18:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Destinations are the data outputs to Applied Intelligence, where you can view your automatically correlated incidents. You can configure Incident Intelligence destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema. Destination template examples The following template example destinations are formatted in Jinja2. Suggested OpsGenie template example { \"alias\": {{ id }}, \"message\": {{ ui_name }}, \"source\": '{{ sources }}', \"priority\": {{ priority }}, \"details\": { \"self_url\": {{ url }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"is_correlated\": {{ is_correlated }} }, \"description\": \"\"\"Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]\"\"\" } Copy Suggested ServiceNow template example { \"short_description\": {{ ui_name }}, \"description\": 'Issue Id: {{ id }}, \\n Description: {{ description }}, \\n Sources: {{ sources }}, \\n Priority: {{ priority }}, \\n Details: { \\n self_url: {{ url }}, \\n state: {{ state }}, \\n is_correlated: {{ is_correlated }}, \\n created_on: {{ created_on }}, \\n modified_on: {{ modified_on }}, \\n activated_on: {{ active_since }}, \\n closed_on: {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \\n is_correlated: {{is_correlated}} }, \\n\\n incidents: {{ incidents }}, \\n\\n pathways: {{ pathways }}' } Copy Suggested Slack template example Go to Slack incoming WebHooks Choose the right Slack workspace and click \"Add to Slack\" Select the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In New Relic Applied Intelligence, under Incident Intelligence click Destinations Add a WebHook In the end point paste the WebHook url from slack. In the custom payload, paste the following JSON: { \"blocks\": [ { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*New Relic Incident Intelligence Alert*\" } }, { \"type\": \"divider\" }, { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*CUSTOM FIELDS*:\" }, \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue ID*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Issue Title*\" }, { \"type\": \"plain_text\", \"text\": {{ id }} }, { \"type\": \"plain_text\", \"text\": {{ ui_name }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue URL*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Description*\" }, { \"type\": \"mrkdwn\", \"text\": {{ url }} }, { \"type\": \"plain_text\", \"text\": {{ description }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*State*\" }, { \"type\": \"mrkdwn\", \"text\": \"*is_correlated*\" }, { \"type\": \"plain_text\", \"text\": {{ state }} }, { \"type\": \"plain_text\", \"text\": \"{{ is_correlated }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Created On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Modified On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ created_on }}\" }, { \"type\": \"plain_text\", \"text\": \"{{ modified_on }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Activated On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Closed On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ active_since }}\" }, { \"type\": \"plain_text\", \"text\": \"{% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Aggregated Incidents*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Monitoring Tool*\" }, { \"type\": \"plain_text\", \"text\": \"{{ incident_count }}\" }, { \"type\": \"plain_text\", \"text\": {{ sources|join(', ') }} } ] } ] } Copy Suggested VictorOps template example { \"monitoring_tool\": {{ sources }}, {% if state == 'closed' %} \"message_type\": \"OK\", {% else %} \"message_type\": {{ priority }}, {% endif %} \"custom_fields\": { \"issue_url\": {{ url }}, \"description\": {{ description }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"related_incidents\": [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %} {% endfor %} ] }, \"state_message\": {{ description }}, \"entity_id\": {{ id }}, \"entity_display_name\": {{ ui_name }}, \"vo_annotate.u.NRAI_Link\": {{ url }} } Copy Webhook and JSON format examples Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). If you use webhooks to configure Incident Intelligence destinations, use these examples of the webhook body format and JSON schema. Webhook format and JSON example Webhook format: Name Description url Href A link to the UI where the issue can be seen. id String Unique identifier for the issue. title String The issue title. description String The description of the issue. priority Enum The issue priority. Can be Critical, High, Medium, or Low. state Enum The issue status. Can be Active, Closed, or Acknowledged. is_correlated Boolean True if the issue is based on correlated data. created_on String The date and time the issue was created (in ISO format). modified_on String The date and time the issue was modified (in ISO format). active_since String The date and time the issue was activated (in ISO format). closed_on String The date and time the issue was closed (in ISO format). sources List(String) List of the different sources that were used to send the events into Applied Intelligence (for example: PagerDuty). pathways List(Pathways) List of pathways that are associated with the issue. Each pathway contains an id and name: [{“id”: “pathway id”, “name”: “pathway name”}]. pathways[].id String The pathway ID. pathways[].name String The pathway name. incidents List(Incident) List of incidents that are attached to the issue. The list contains only the latest 100 incidents. incidents[].id String The incident ID. incidents[].events_count Integer The number of events used to create the incident. incidents[].title String The incident title. incidents[].description String The incident description. incidents[].labels Dictionary (String) A string to string mapping of the incident labels. Labels represent the unique entities that are used to describe the incident. incidents[].priority Enum The incident priority. Can be Critical, High, Medium, or Low. incidents[].sources List(String) The incident source. incidents[].state Enum(open, closed) The incident state. incidents[].opened_on String The date and time the incident was opened (in ISO format). incidents[].closed_on String The date and time the incident was closed (in ISO format). ui_name String Issue title. accumulations['alert/signal'] String Issue analysis summary golden signal/s (if applicable). accumulations['alert/components'] String Issue analysis summary golden components (if applicable). Jinja2 Default Payload Applied Intelligence uses a templating framework called Jinja2 in the Webhook interface. Here is a default Jinja2 payload to use: { \"id\": {{ id }}, \"url\": {{ url }}, \"ui_name\": {{ ui_name }}, \"description\": {{ description }}, \"priority\": {{ priority }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"active_since\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"sources\": {{ sources }}, \"incidents\": {{ incidents }}, \"pathways\": {{ pathways }}, } Copy Jinja2 Useful Syntax Below are a few useful Jinja2 commands to help you format your output. Casting a value to integer Example: “severity”: {{ priority | int }} Copy If clause to check if an attribute’s value is set Example: \"golden_signals\": {% if accumulations['alert/signal'] is defined %} {{ accumulations['alert/signal'] }} {% else %} None {% endif %} Copy For loop to iterate of an array of values: Example: \"description\": 'Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]' Copy Check if an array attribute's value is set: Example: \"hostname_field\": {% if incidents[0].labels['newrelic/tag/hostname'] is defined %} {{ incidents[0].labels['newrelic/tag/hostname'] }} {% else %} None {% endif %} Copy JSON schema Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). JSON schema template JSON schema: { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"definitions\": { \"Labels\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"LabelsSet\": { \"type\": \"array\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"$ref\": \"#/definitions/Labels\" }, \"uniqueItems\": true }, }, \"Annotations\": { \"type\": \"object\", \"title\": \"Additional contextual information about the Entity\", \"description\": \"Fields like title, description and priority can be described as annotations since\\nthey represent some additional information about the Incident.\\nFor example, the rule that creates the entity can have some logic that will create a title annotation field.\\nThe title will change according to the latest event received by the entity and as more\\nevent will keep coming the field may change, all this as a decision by the rule.\\nA different rule may decide not to populate the title at all.\\nSince a title can also be produced from the labels themselves.\", \"properties\": { \"title\": { \"type\": \"string\", \"maxLength\": 10000 }, \"description\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"patternProperties\": { \".*\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"Accumulations\": { \"type\": \"object\", \"title\": \"Accumulated data about the Incident\", \"description\": \"For example an entity with the label: host_name: foo will include a accumulated list of the\\nrelevant process names that are relevant to the entity. Accumulations will be derived from the events\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"type\": \"string\", \"maxLength\": 10000 } } }, \"IssueState\": { \"type\": \"string\", \"enum\": [ \"created\", \"active\", \"acknowledged\", \"closed\" ], \"properties\": {}, \"additionalProperties\": false }, \"Priority\": { \"type\": \"string\", \"enum\": [ \"critical\", \"high\", \"medium\", \"low\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueClosingReason\": { \"type\": \"string\", \"enum\": [ \"nacked\", \"resolved\", \"system\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueAction\": { \"type\": \"string\", \"enum\": [ \"ack\", \"snooze\", \"nack\", \"end_snooze\", \"expire_snooze\", \"star\", \"un_snooze\", \"unstar\", \"archive\", \"unarchive\", \"resolve\", \"reopen\", \"open\", \"feedback\", \"feedback_file\", \"open_ticket\", \"merge_issues\", \"active\", \"create\", \"close\", \"incident_updated\", \"confidence_changed\", \"diagnoses_changed\", \"rule_properties_changed\", \"flapping\", \"notification\", \"incident_events_limit_reached\", \"follow\", \"unfollow\", \"priority_updated\", \"comment\", \"incident_appended\", \"diagnosis_feedback\", \"flapping_delay_close\" ], \"properties\": {}, \"additionalProperties\": false }, \"StringKeyValue\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\" } }, \"JavaOptionalUuid\": { \"type\": \"string\", \"properties\": {}, \"additionalProperties\": false, \"format\": \"string-uuid\" } }, \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"customer_id\": { \"type\": \"integer\" }, \"labels_set\": { \"$ref\": \"#/definitions/LabelsSet\" }, \"annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations_version\": { \"type\": \"integer\" }, \"accumulations\": { \"$ref\": \"#/definitions/Accumulations\" }, \"state\": { \"$ref\": \"#/definitions/IssueState\" }, \"previous_state\": { \"$ref\": \"#/definitions/IssueState\" }, \"priority\": { \"$ref\": \"#/definitions/Priority\" }, \"closing_reason\": { \"oneOf\": [ { \"$ref\": \"#/definitions/IssueClosingReason\" }, { \"type\": \"null\" } ] }, \"modified_on\": { \"type\": \"integer\" }, \"created_on\": { \"type\": \"integer\" }, \"closed_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"acknowledged_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"active_since\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"assigned_to\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"created_by\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"progress_report\": { \"type\": \"array\", \"default\": [], \"items\": { \"type\": \"object\", \"properties\": { \"origin_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1 }, { \"type\": \"null\" } ] }, \"timestamp\": { \"type\": \"integer\" }, \"action_timestamp\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"origin_type\": { \"type\": \"string\", \"enum\": [ \"user\", \"system\" ] }, \"event_type\": { \"$ref\": \"#/definitions/IssueAction\" }, \"issue_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"format\": \"string-uuid\" }, { \"type\": \"null\" } ] }, \"attributes\": { \"oneOf\": [ { \"$ref\": \"#/definitions/StringKeyValue\" }, { \"type\": \"null\" } ] }, \"team_id\": { \"$ref\": \"#/definitions/JavaOptionalUuid\" } }, \"required\": [ \"timestamp\", \"origin_type\", \"event_type\" ], \"additionalProperties\": false }, \"uniqueItems\": true }, \"rule_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"maxLength\": 255 }, { \"type\": \"null\" } ] }, \"incident_ids\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"confidence\": { \"type\": \"number\", \"default\": 1.0, \"minimum\": 0.0, \"maximum\": 1.0 } }, \"required\": [ \"id\", \"customer_id\", \"labels_set\", \"annotations\", \"priority\", \"modified_on\", \"created_on\", \"confidence\" ], \"additionalProperties\": true } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 474.29855,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Incident</em> <em>Intelligence</em> destination examples",
        "sections": "<em>Incident</em> <em>Intelligence</em> destination examples",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "Destinations are the data outputs to <em>Applied</em> <em>Intelligence</em>, where you can view your automatically correlated incidents. You can configure <em>Incident</em> <em>Intelligence</em> destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema"
      },
      "id": "6044280d64441f4af5378ed3"
    },
    {
      "sections": [
        "Use Incident Intelligence",
        "Issue summary",
        "Impacted entities map",
        "Use suggested responders",
        "Important",
        "Tip",
        "Root cause analysis",
        "Issue timeline",
        "Related activity",
        "Use decisions"
      ],
      "title": "Use Incident Intelligence",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "f7b852fa406a6e9ff88b791e4cbccc2bd20a5962",
      "image": "https://docs.newrelic.com/static/6e37cc77304398121e1a0080a57e47bb/8c557/screenshot_incident_intelligence_timeline_event_detail.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/use-incident-intelligence/",
      "published_at": "2021-06-02T18:23:21Z",
      "updated_at": "2021-05-28T11:09:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you set up Incident Intelligence, our system will begin finding issues from your data sources. In the issue feed, you can find an overview of all your issues, along with helpful information about them. You can also click any individual issue for more detail, including its analysis summary, event log, and details about correlated issues. This screenshot shows an example issue feed, which describes your issues' statuses, correlations, and more. What's the difference between an issue, incident, and event? In short, these terms are like building blocks. Events are raw data from your sources. Incidents are made up of one or more events. Issues are composed of one or more incidents. In more detail: Events indicate a state change or trigger defined by your monitoring systems. An event contains information about the affected entity, and they are almost always triggered automatically by the system. Incidents are groups of events that describe the \"symptoms\" of your system over time. These symptoms are detected by your monitoring tools, which evaluate your data streams and events. Issues are groups of incidents that describe the underlying problem of your symptoms. When a new incident is created, Incident Intelligence opens an issue and evaluates other open issues for correlations. Issue summary The Issue page is built to provide you with bottom line insights first to understand the problem, and then to minimize the time you need to resolve it. The Issue page includes the following sections: Issue summary: This section has two machine learning modules, the golden signals and the related components. Suggested responders: This section will tell you who to potentially reach out to on your team to solve a specific problem. Label sets: Label sets are focused on incidents that come from 3rd party sources, such as PagerDuty, AWS Cloudwatch, REST APIs, etc., as well as for NRQL queries. They come in the form of key:value pairs. Impacted entities: An entity is anything that has data you can monitor. Specifically, these are focused on incidents from New Relic sources, extracting the entities and providing a summary. Each entity is unique. You can see your entities in a list or on a map. Depending on the data in an issue, all four of these sections can show up together for each issue or separately. If you hover over an impacted entity application, you’ll notice a few calls to action: relevant dashboards, anomaly overview, deployment events, and entity overview. Relevant dashboards helps users in your account look at and interact with dashboards you've created that are related to an entity. The queries you've run to power the various widgets are automatically mapped to entities whenever possible and are presented back to you here for quick access and discovery. Anomaly overview will open the application's anomalies page. This is only available for applications that are set up for Proactive Detection. There are two types of deployment events: deployments and related deployments. Click Show all deployments to see all your deployment events when they arrive, or click a specific deployment to see its APM deployments page. The APM deployment page lists recent deployments and their impact on your end user and app server's Apdex scores, response times, throughput, and errors. This section will only show up if New Relic has identified applications under the impacted entities that have deployments. Impacted entities map Hover over an entity to see more information about it. An impacted entities map is available for any issue involving two or more entities. The map shows not only the affected entities, but also the services and resources directly related to those entities. Use suggested responders If you’re using PagerDuty or New Relic alerts violations as your incident notification tools, Incident Intelligence suggests relevant team members that can help resolve your issues. Incident Intelligence learns from your PagerDuty and alerts violations data to provide suggestions for each new incident. Once you receive a suggestion, you can contact the responder or search for relevant documentation that person may have written. To get started, enable PagerDuty or alerts violations as a source for Incident Intelligence. Afterwards, you can view the suggestions in two places: The issue feed, where you can also provide feedback on the suggestions. Directly within PagerDuty (both UI and API.) If you’re also using PagerDuty as a destination, the suggestions will appear in your issue notifications payload. Important This feature doesn't account for on-call availability at the time of incident. Tip In order to train the model, we use the information PagerDuty provides about individuals. We ingest incident information only, not users’ contact details. Root cause analysis Root cause analysis automatically finds potential causes for an issue and its impacted entities. It shows you why open issues occurred, which deployments contributed, and relevant error logs and attributes. With this, you can investigate the problem and reduce your mean time to resolution (MTTR). Tip Note that root cause analysis is dependent on other New Relic data sources and features. This is why root cause analysis information may not always be present for every issue. When you select an issue, you may see Root cause analysis information. Root cause analysis includes three main UI sections: Deployment events: When you set up deployments, we provide the deployment nearest to the issue creation. Changes, such as deployments, account for a high percentage of the root causes of incidents and having that information at hand can help diagnose and resolve issues. Error logs: You can explore millions of log messages with a single click and use manual querying to help you find anomalous patterns and hard-to-find problems. Attributes to investigate: We scan the distribution of attributes and surface possible causes by finding significant changes in the distribution. This section also shows changes in database and external metrics. You can also query interesting attributes. Issue timeline The issue timeline, as presented below, shows you a breakdown of: Incidents The trends taking place What incidents are active What incidents are resolved What is correlated to each other Various milestones at different issue levels In addition, you’ll see a grey line at the top of the timeline. In comparison to the visual timeline that shows the changes to each incident, the grey line represents changes to the issue. Mouse over the grey line to see details of the event. Finally, mouse over the incident to see information on the location, timing, and level of importance of a specific incident. This figure shows a particular incident populated on January 11th with a level of Critical. To view the issues in a text format, in the right hand corner, click Switch to issue log view. Related activity The issue page includes a Related activity section, which is a table displaying activity related to the incident or anomally you are are trying to analyze. You can click each line item in the table to view a unique dashboard that displays data for the entity the incident or anomally came from. The related activity section aggregates a set of incidents into a single issue, according to a rule-based system. Use decisions To further reduce noise or get improved incident correlation, you can change or customize your decisions. Decisions determine how Incident Intelligence groups incidents together. To get started, see Decisions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 358.71866,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use <em>Incident</em> <em>Intelligence</em>",
        "sections": "Use <em>Incident</em> <em>Intelligence</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": ". The map shows not only the affected entities, but also the services and resources directly related to those entities. Use suggested responders If you’re using PagerDuty or New Relic <em>alerts</em> violations as your <em>incident</em> notification tools, <em>Incident</em> <em>Intelligence</em> suggests relevant team members that can"
      },
      "id": "6080293564441fd0669d8580"
    },
    {
      "sections": [
        "Expanded anomaly detection",
        "Requirements",
        "Why it matters",
        "Get started with anomaly detection",
        "Detect anomalies with a faceted NRQL query",
        "See your anomalies in one place",
        "Tip",
        "Query anomaly data",
        "Reduce the number of detected anomalies"
      ],
      "title": "Expanded anomaly detection",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Proactive detection"
      ],
      "external_id": "0b07c0b6ce27f39b5edb3e112a0f949835cbb8c6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/proactive-detection/expanded-anomaly-detection/",
      "published_at": "2021-06-02T18:27:12Z",
      "updated_at": "2021-05-31T16:43:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We’ve expanded anomaly detection coverage beyond your APM applications. Configure anomaly detection for your browser applications, mobile applications, infrastructure hosts, and nearly anything you want to monitor. Requirements Expanded anomaly detection is available as a limited beta. You can request access here. Why it matters When starting to configure alert conditions for a variety of applications and hosts, it can be difficult to know what you’ll want to be notified about ahead of time. Anomaly detection helps you distinguish between what’s typical performance in your system and where you’re starting to have trouble. Instead of creating your alert conditions manually, you can simply tell us what you want to monitor. Anomaly detection will help you identify baseline performance in your system and flags anomalous activity in your system. Get started with anomaly detection To get started with expanded anomaly detection: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Select the account you want to use to record anomaly data, then select the workload or entities you’d like to monitor. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name your configuration and save. Detect anomalies with a faceted NRQL query To detect anomalies with a faceted NRQL query: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Click Use a query instead. You may need to select an account, if you have more than one. Add one or more queries with a FACET clause. Name the query and confirm the facets you want to monitor for anomalies. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name the configuration and save. See your anomalies in one place When you set up anomaly detection, New Relic starts analyzing the golden signals of your entities and workloads. Anomalies appear in your activity feeds throughout New Relic One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL alert condition for the NrAiAnomaly event. To view anomalies, from one.newrelic.com, go to Alerts & AI > Issues & activity > Anomalies. Query anomaly data Detected anomalies are written to the NrAiAnomaly event in your NRDB account. You can learn more about this event and how to query it here. Reduce the number of detected anomalies If you’re seeing too many anomalies, the first step is to make sure your sensitivity level is set to Low. If it’s already set to Low, you can define specific thresholds to distinguish between normal and anomalous behavior. To define custom thresholds: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab and the configuration you want to modify. Select an entity or workload, and then change the sensitivity level. You can use custom sensitivity to define specific thresholds for different entity types.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 290.3352,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " request access here. Why it matters When starting to configure <em>alert</em> conditions for a variety of applications and hosts, it can be difficult to know what you’ll want to be notified about ahead of time. Anomaly detection helps you distinguish between what’s typical performance in your system and where"
      },
      "id": "60b5124064441ff965e2cb01"
    }
  ],
  "/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/incident-intelligence-destination-examples": [
    {
      "sections": [
        "Use Incident Intelligence",
        "Issue summary",
        "Impacted entities map",
        "Use suggested responders",
        "Important",
        "Tip",
        "Root cause analysis",
        "Issue timeline",
        "Related activity",
        "Use decisions"
      ],
      "title": "Use Incident Intelligence",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "f7b852fa406a6e9ff88b791e4cbccc2bd20a5962",
      "image": "https://docs.newrelic.com/static/6e37cc77304398121e1a0080a57e47bb/8c557/screenshot_incident_intelligence_timeline_event_detail.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/use-incident-intelligence/",
      "published_at": "2021-06-02T18:23:21Z",
      "updated_at": "2021-05-28T11:09:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you set up Incident Intelligence, our system will begin finding issues from your data sources. In the issue feed, you can find an overview of all your issues, along with helpful information about them. You can also click any individual issue for more detail, including its analysis summary, event log, and details about correlated issues. This screenshot shows an example issue feed, which describes your issues' statuses, correlations, and more. What's the difference between an issue, incident, and event? In short, these terms are like building blocks. Events are raw data from your sources. Incidents are made up of one or more events. Issues are composed of one or more incidents. In more detail: Events indicate a state change or trigger defined by your monitoring systems. An event contains information about the affected entity, and they are almost always triggered automatically by the system. Incidents are groups of events that describe the \"symptoms\" of your system over time. These symptoms are detected by your monitoring tools, which evaluate your data streams and events. Issues are groups of incidents that describe the underlying problem of your symptoms. When a new incident is created, Incident Intelligence opens an issue and evaluates other open issues for correlations. Issue summary The Issue page is built to provide you with bottom line insights first to understand the problem, and then to minimize the time you need to resolve it. The Issue page includes the following sections: Issue summary: This section has two machine learning modules, the golden signals and the related components. Suggested responders: This section will tell you who to potentially reach out to on your team to solve a specific problem. Label sets: Label sets are focused on incidents that come from 3rd party sources, such as PagerDuty, AWS Cloudwatch, REST APIs, etc., as well as for NRQL queries. They come in the form of key:value pairs. Impacted entities: An entity is anything that has data you can monitor. Specifically, these are focused on incidents from New Relic sources, extracting the entities and providing a summary. Each entity is unique. You can see your entities in a list or on a map. Depending on the data in an issue, all four of these sections can show up together for each issue or separately. If you hover over an impacted entity application, you’ll notice a few calls to action: relevant dashboards, anomaly overview, deployment events, and entity overview. Relevant dashboards helps users in your account look at and interact with dashboards you've created that are related to an entity. The queries you've run to power the various widgets are automatically mapped to entities whenever possible and are presented back to you here for quick access and discovery. Anomaly overview will open the application's anomalies page. This is only available for applications that are set up for Proactive Detection. There are two types of deployment events: deployments and related deployments. Click Show all deployments to see all your deployment events when they arrive, or click a specific deployment to see its APM deployments page. The APM deployment page lists recent deployments and their impact on your end user and app server's Apdex scores, response times, throughput, and errors. This section will only show up if New Relic has identified applications under the impacted entities that have deployments. Impacted entities map Hover over an entity to see more information about it. An impacted entities map is available for any issue involving two or more entities. The map shows not only the affected entities, but also the services and resources directly related to those entities. Use suggested responders If you’re using PagerDuty or New Relic alerts violations as your incident notification tools, Incident Intelligence suggests relevant team members that can help resolve your issues. Incident Intelligence learns from your PagerDuty and alerts violations data to provide suggestions for each new incident. Once you receive a suggestion, you can contact the responder or search for relevant documentation that person may have written. To get started, enable PagerDuty or alerts violations as a source for Incident Intelligence. Afterwards, you can view the suggestions in two places: The issue feed, where you can also provide feedback on the suggestions. Directly within PagerDuty (both UI and API.) If you’re also using PagerDuty as a destination, the suggestions will appear in your issue notifications payload. Important This feature doesn't account for on-call availability at the time of incident. Tip In order to train the model, we use the information PagerDuty provides about individuals. We ingest incident information only, not users’ contact details. Root cause analysis Root cause analysis automatically finds potential causes for an issue and its impacted entities. It shows you why open issues occurred, which deployments contributed, and relevant error logs and attributes. With this, you can investigate the problem and reduce your mean time to resolution (MTTR). Tip Note that root cause analysis is dependent on other New Relic data sources and features. This is why root cause analysis information may not always be present for every issue. When you select an issue, you may see Root cause analysis information. Root cause analysis includes three main UI sections: Deployment events: When you set up deployments, we provide the deployment nearest to the issue creation. Changes, such as deployments, account for a high percentage of the root causes of incidents and having that information at hand can help diagnose and resolve issues. Error logs: You can explore millions of log messages with a single click and use manual querying to help you find anomalous patterns and hard-to-find problems. Attributes to investigate: We scan the distribution of attributes and surface possible causes by finding significant changes in the distribution. This section also shows changes in database and external metrics. You can also query interesting attributes. Issue timeline The issue timeline, as presented below, shows you a breakdown of: Incidents The trends taking place What incidents are active What incidents are resolved What is correlated to each other Various milestones at different issue levels In addition, you’ll see a grey line at the top of the timeline. In comparison to the visual timeline that shows the changes to each incident, the grey line represents changes to the issue. Mouse over the grey line to see details of the event. Finally, mouse over the incident to see information on the location, timing, and level of importance of a specific incident. This figure shows a particular incident populated on January 11th with a level of Critical. To view the issues in a text format, in the right hand corner, click Switch to issue log view. Related activity The issue page includes a Related activity section, which is a table displaying activity related to the incident or anomally you are are trying to analyze. You can click each line item in the table to view a unique dashboard that displays data for the entity the incident or anomally came from. The related activity section aggregates a set of incidents into a single issue, according to a rule-based system. Use decisions To further reduce noise or get improved incident correlation, you can change or customize your decisions. Decisions determine how Incident Intelligence groups incidents together. To get started, see Decisions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 358.71866,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use <em>Incident</em> <em>Intelligence</em>",
        "sections": "Use <em>Incident</em> <em>Intelligence</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": ". The map shows not only the affected entities, but also the services and resources directly related to those entities. Use suggested responders If you’re using PagerDuty or New Relic <em>alerts</em> violations as your <em>incident</em> notification tools, <em>Incident</em> <em>Intelligence</em> suggests relevant team members that can"
      },
      "id": "6080293564441fd0669d8580"
    },
    {
      "sections": [
        "Expanded anomaly detection",
        "Requirements",
        "Why it matters",
        "Get started with anomaly detection",
        "Detect anomalies with a faceted NRQL query",
        "See your anomalies in one place",
        "Tip",
        "Query anomaly data",
        "Reduce the number of detected anomalies"
      ],
      "title": "Expanded anomaly detection",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Proactive detection"
      ],
      "external_id": "0b07c0b6ce27f39b5edb3e112a0f949835cbb8c6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/proactive-detection/expanded-anomaly-detection/",
      "published_at": "2021-06-02T18:27:12Z",
      "updated_at": "2021-05-31T16:43:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We’ve expanded anomaly detection coverage beyond your APM applications. Configure anomaly detection for your browser applications, mobile applications, infrastructure hosts, and nearly anything you want to monitor. Requirements Expanded anomaly detection is available as a limited beta. You can request access here. Why it matters When starting to configure alert conditions for a variety of applications and hosts, it can be difficult to know what you’ll want to be notified about ahead of time. Anomaly detection helps you distinguish between what’s typical performance in your system and where you’re starting to have trouble. Instead of creating your alert conditions manually, you can simply tell us what you want to monitor. Anomaly detection will help you identify baseline performance in your system and flags anomalous activity in your system. Get started with anomaly detection To get started with expanded anomaly detection: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Select the account you want to use to record anomaly data, then select the workload or entities you’d like to monitor. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name your configuration and save. Detect anomalies with a faceted NRQL query To detect anomalies with a faceted NRQL query: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Click Use a query instead. You may need to select an account, if you have more than one. Add one or more queries with a FACET clause. Name the query and confirm the facets you want to monitor for anomalies. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name the configuration and save. See your anomalies in one place When you set up anomaly detection, New Relic starts analyzing the golden signals of your entities and workloads. Anomalies appear in your activity feeds throughout New Relic One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL alert condition for the NrAiAnomaly event. To view anomalies, from one.newrelic.com, go to Alerts & AI > Issues & activity > Anomalies. Query anomaly data Detected anomalies are written to the NrAiAnomaly event in your NRDB account. You can learn more about this event and how to query it here. Reduce the number of detected anomalies If you’re seeing too many anomalies, the first step is to make sure your sensitivity level is set to Low. If it’s already set to Low, you can define specific thresholds to distinguish between normal and anomalous behavior. To define custom thresholds: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab and the configuration you want to modify. Select an entity or workload, and then change the sensitivity level. You can use custom sensitivity to define specific thresholds for different entity types.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 290.3352,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " request access here. Why it matters When starting to configure <em>alert</em> conditions for a variety of applications and hosts, it can be difficult to know what you’ll want to be notified about ahead of time. Anomaly detection helps you distinguish between what’s typical performance in your system and where"
      },
      "id": "60b5124064441ff965e2cb01"
    },
    {
      "sections": [
        "Get started with Incident Intelligence",
        "Tip",
        "Set up Incident Intelligence",
        "1. Configure your environment (one-time)",
        "2. Configure sources",
        "Alerts",
        "Algorithmia (MLOps)",
        "Connect your Algorithmia data to New Relic",
        "Monitor your machine learning models",
        "Anomalies",
        "AWS",
        "Grafana",
        "PagerDuty",
        "Prometheus Alertmanager",
        "REST API",
        "Splunk",
        "Important",
        "Splunk metadata",
        "3. Configure destinations (ServiceNow and others)",
        "Configure ServiceNow (example)",
        "Send data to ServiceNow",
        "Custom notification message",
        "Other destinations",
        "Send data to PagerDuty",
        "Send data via webhook",
        "4. Configure pathways",
        "What's next?"
      ],
      "title": "Get started with Incident Intelligence",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "8c4a5a914ca01cb42250908d2fb1a12ccc697e25",
      "image": "https://docs.newrelic.com/static/5cb28999dc618c6a5a2b8be1fa72e660/b97f6/image-%25281%2529_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/get-started-incident-intelligence/",
      "published_at": "2021-06-02T18:25:14Z",
      "updated_at": "2021-05-16T16:21:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "As part of Applied Intelligence, Incident Intelligence helps you correlate your incidents and reduce noise in your environment. It gives you an overview of all your incidents, their sources, and related events. Tip To use Incident Intelligence and Applied Intelligence, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Set up Incident Intelligence To enable Incident Intelligence, follow these four steps. Afterwards, issues should start to appear in your issue feed. 1. Configure your environment (one-time). 2. Configure sources. 3. Configure destinations. 4. Configure pathways. 1. Configure your environment (one-time) To set up an environment in Incident Intelligence, you need an administrator to select a New Relic account for it. This account should be the one your team is using. Who sets the environment? Only administrators, and only for accounts where they have admin privileges. Can administrators set more than one environment? They can set one environment per master account and its sub-accounts. More than one can be set if an administrator has privileges for more than one master account. Need to change the environment's associated account? Reach out to your account executive or our support team for help. Tip Incident Intelligence is a cross-account product. This means you can send in data from any New Relic account or external source to correlate events. 2. Configure sources After setting up your environment, determine your incident sources. These are your data inputs. You can get data from any of the following sources: Alerts By integrating Incident Intelligence with your alerts violations, you can get context and correlations from what you're monitoring. To get data from alerts: From one.newrelic.com, click Alerts. On the left under Incident Intelligence, click Sources and then click Alerts. Select the policies you want to connect to Applied Intelligence, and click Connect. You can add additional alerts policies or remove policies you've already connected in Sources > New Relic Alerts. Tip Adding alerts as a source will not affect your current configuration or notifications. Algorithmia (MLOps) By integrating Incident Intelligence with your Algorithmia machine-learning models, you can monitor your machine learning model performance. Connect your Algorithmia data to New Relic Start monitoring your Algorithmia event flows with New Relic. Step Details Get your API key From one.newrelic.com the account menu, click API keys and then create a user key for your account with a meaningful name. Make note of this name for later. For more on API keys, see our docs. Create a dashboard From one.newrelic.com go to Dashboards, then click the Import dashboards button. Copy and paste the JSON code into the Paste your JSON field code. Update the YOUR_ACCOUNT_ID values with your account ID. { \"name\": \"Algorithmia Dashboard for Default Metrics\", \"description\": null, \"permissions\": \"PUBLIC_READ_WRITE\", \"pages\": [ { \"name\": \"Algorithmia Dashboard for Default Metrics\", \"description\": null, \"widgets\": [ { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"Runtime Duration by Algorithm\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": YOUR_ACCOUNT_ID, \"query\": \"SELECT average(algorithmia.duration_milliseconds) FROM Metric TIMESERIES FACET `algorithm_name` LIMIT 10 SINCE 1800 seconds ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"Throughput by Algorithm\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": YOUR_ACCOUNT_ID, \"query\": \"SELECT count(algorithmia.duration_milliseconds) FROM Metric TIMESERIES FACET `algorithm_name` LIMIT 10 SINCE 1800 seconds ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] } ] } ``` Copy Configure Algorithmia Insights for New Relic Use Algorithmia's docs to configure Algorithmia Insights for New Relic. Create the New Relic connector algorithm Use Python 3.8 to create a connector algorithm. If you're new to writing code to generate algorithms, see Algorithmia's getting started guide. import Algorithmia import json from datetime import datetime from newrelic_telemetry_sdk import GaugeMetric, MetricClient client = Algorithmia.client() metric_client = MetricClient(os.environ[\"newrelic_api_key\"]) def convert_str_timestamp_to_epoch(str_time): obj_time = datetime.strptime(str_time, \"%Y-%m-%dT%H:%M:%S.%f\") return int(obj_time.timestamp() * 1000) def get_operational_metrics(payload): ALGORITHM_TAGS = { \"algorithm_version\", \"request_id\", \"time\", \"algorithm_name\", \"session_id\", \"algorithm_owner\" } inference_metrics = { key: payload[key] for key in payload.keys() ^ ALGORITHM_TAGS } return inference_metrics def send_to_newrelic(inference_metrics, insights_payload): newrelic_metrics = [] for key, value in inference_metrics.items(): name = \"algorithmia.\" + key epoch_time = convert_str_timestamp_to_epoch(insights_payload[\"time\"]) tags = { \"algorithm_name\": insights_payload[\"algorithm_name\"], \"algorithm_version\": insights_payload[\"algorithm_version\"], \"algorithm_owner\": insights_payload[\"algorithm_owner\"], \"request_id\": insights_payload[\"request_id\"], \"session_id\": insights_payload[\"session_id\"], } newrelic_metrics.append(GaugeMetric( name=name, value=value, tags=tags, end_time_ms=epoch_time )) response = metric_client.send_batch(newrelic_metrics) response.raise_for_status() def apply(input): insights_payload = input inference_metrics = get_operational_metrics(insights_payload) send_to_newrelic(inference_metrics, insights_payload) return None Copy Include these dependencies: algorithmia>=1.0.0,<2.0 newrelic_telemetry_sdk==0.4.2 Copy Once your algorithm build finishes, you can test it with this sample payload to make sure it runs successfully. Your output should look something like this. { \"risk_score\": 0.2, \"duration_milliseconds\": 8, \"algorithm_version\": \"1.0.6\", \"session_id\": \"rses-f28bb94a-5556-4aeb-a6d2-89493626bf4f\", \"time\": \"2021-02-20T00:21:54.867231\", \"algorithm_name\": \"credit_card_approval\", \"request_id\": \"req-9f5345b4-a1cd-431c-a43a-bd2a06f4a6f4\", \"algorithm_owner\": \"asli\" } Copy Configure with your API key Add your New Relic API key to the Algorithmia secret store. Set up Algorithmia Event Flows with New Relic See Algorithmia's documentation on setting up your connector algorithm to send event-based machine learning flows to New Relic. Monitor your machine learning models Step Details Get your API key From one.newrelic.com the account menu, click API keys and then create a user key for your account with a meaningful name. Make note of this name for later. For more on API keys, see our docs. Create a dashboard From one.newrelic.com go to Dashboards, then click the Import dashboards button. Copy and paste the JSON code into the Paste your JSON field code. Update the YOUR_ACCOUNT_ID values with your account ID. { \"name\": \"Algorithmia Dashboard for Default Metrics\", \"description\": null, \"permissions\": \"PUBLIC_READ_WRITE\", \"pages\": [ { \"name\": \"Algorithmia Dashboard for Default Metrics\", \"description\": null, \"widgets\": [ { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"Runtime Duration by Algorithm\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": YOUR_ACCOUNT_ID, \"query\": \"SELECT average(algorithmia.duration_milliseconds) FROM Metric TIMESERIES FACET `algorithm_name` LIMIT 10 SINCE 1800 seconds ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"Throughput by Algorithm\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": YOUR_ACCOUNT_ID, \"query\": \"SELECT count(algorithmia.duration_milliseconds) FROM Metric TIMESERIES FACET `algorithm_name` LIMIT 10 SINCE 1800 seconds ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] } ] } ``` Copy Set up alerts notifications Once you've created some dashboards, you can get alerted on your data. To create a NRQL alerts condition from a chart, click the chart menu , then click Create alert condition. Once you've named and customized your condition, you can add it to an existing policy or create a new one. Get notified Once you've created an alerts condition, you can choose how you want to be notified. See our docs on how to set up notification channels. Correlate your incidents In addition to notifications, you can use Incident Intelligence to correlate your incidents. See our docs on how to correlate incidents using decisions. Anomalies By integrating Incident Intelligence with your New Relic Proactive Detection anomalies, you can get context and correlations from what you're monitoring. To get data from New Relic Proactive Detection anomalies: From one.newrelic.com, click Alerts & AI. On the left under Incident Intelligence, click Sources and then click Anomalies. Select the configurations you want to connect to Applied Intelligence by toggling to on (green). To add or remove alert policies, from Alerts & AI, click Sources, then Alerts. Tip Adding anomalies as a source won't affect your current Proactive Detection configurations or notifications. AWS You can integrate Incident Intelligence with Amazon CloudWatch to provide incident management for all of your AWS services. To integrate Amazon CloudWatch: Go to one.newrelic.com and click Alerts & AI. On the left under Incident Intelligence, click Sources and then click Amazon Web Services. Copy the URL. Create a new Amazon SNS topic. Set CloudWatch to forward all Alarms state changes to that topic: In the Amazon CloudWatch UI, click Events > Event Pattern. Select Service Name > CloudWatch. Select Event Type > CloudWatch Alarm State Change. Select Targets > SNS Topic, and select your new Amazon SNS topic. Create a new subscription: In the Amazon AWS UI, click Create a Subscription. Select your new Amazon SNS topic. Select Protocol > choose HTTPS. In Endpoint, paste the URL you previously copied from the Applied Intelligence Sources. Grafana You can integrate Incident Intelligence with Grafana's notifications for insight into events across your applications and environment. Grafana's webhook notification is a simple way to send information over HTTP to a custom endpoint. To integrate Grafana as a new webhook: Log into your Grafana portal using Admin permissions, and choose Alerting. On the Grafana Notification Channels page, click New Channel > Webhook. Go to one.newrelic.com and click Alerts & AI. On the left under Incident Intelligence, click Sources, and then click Grafana. Copy the URL, and paste it into your new Grafana webhook. PagerDuty You can integrate Incident Intelligence directly with your PagerDuty services to ingest, process, and enhance all of your PagerDuty incidents. To get data from PagerDuty: Make sure your PagerDuty API key has write access. From one.newrelic.com, click Alerts & AI. On the left under Incident Intelligence, click Sources and then click PagerDuty. Enter your PagerDuty API key. The key should be either a personal or general access key with write access. If it's created by a user, the user should be an admin. Select the PagerDuty services you want to connect to Applied Intelligence, and click Connect. You can add additional services or remove services you've already connected in Sources > PagerDuty. Tip Connecting PagerDuty services to Applied Intelligence will not affect your current services or notifications. Prometheus Alertmanager By integrating Incident Intelligence with Prometheus Alertmanager, you can receive and correlate your Prometheus alerts with events from other sources. To integrate Prometheus Alertmanager: Set up your Alertmanager configuration file by running: ./alertmanager -config.file=simple.yml Copy Go to one.newrelic.com and click Alerts & AI. On the left under Incident Intelligence, click Sources and then click Prometheus Alertmanager. Copy the Prometheus Alertmanager URL, and paste it into the <webhook_config>/url section of your Alertmanager config file. Reload the Prometheus Alertmanager configuration with one of the two methods: Send a SIGHUP to the process. Send an HTTP POST request to the /-/reload endpoint. REST API Incident Intelligence supports a dedicated REST API interface that lets you integrate with additional systems. The interface allows instrumentation of your code or other monitoring solutions to report any kind of metric or event. A metric can be a raw data point such as CPU, memory, disk utilization, or business KPI. An event can be a monitoring alert, deployment event, incident, exceptions or any other change in state that you want to describe. You can also send any type of data to Incident Intelligence straight from your own systems or applications. The REST API supports secure token-based authentication and accepts JSON content as input. For more information on authentication and the full API reference, see REST API for New Relic Applied Intelligence. Splunk By integrating Incident Intelligence with your Splunk log monitoring, you can: Use your environment's log data for searches and key term reports. Correlate alerts and search reports with your other metrics and incidents. Important Applied Intelligence supports Splunk Light, Splunk Cloud, and Splunk Enterprise version 6.3 and higher. To get data from Splunk: In your Splunk console, start a search for the relevant events. Save your search as an alert, configure your alert conditions, and then choose the webhook as the delivery method. Go to one.newrelic.com and click Alerts & AI. On the left under Incident Intelligence, click Sources and then click Splunk. Copy the collector URL, and paste it into the webhook endpoint in the Splunk console. Optional: Use Splunk tokens to enrich alert data with Splunk metadata. Splunk metadata To enrich alerts data with your Splunk metadata, use Splunk tokens. This helps you leverage your search data, which includes metadata and values from the first row of search results. If you want to... Do this... Access search data Use the format $<fieldname>$. For example, use $app$ for the app context for the search. Access field values To access field values from the first result row that a search returns, use the format $result.<fieldname>$. For example, use $result.host$ for the host value and $result.sourcetype$ for the source type. Use variables You can leverage any of the Selected fields in the Splunk search and add any unique fields to the Selected fields to make the data available as a variable. The following fields will automatically provide hints to the correlation engine: app: parsed as APPLICATION_NAME application:parsed as APPLICATION_NAME application_name: parsed as APPLICATION_NAME cluster: parsed as CLUSTER_NAME computer: parsed as HOST_NAME Dc: parsed as DATACENTER_NAME datacenter: parsed as DATACENTER_NAME host: parsed as HOST_NAME host_name: parsed as HOST_NAME hostname: parsed as HOST_NAME transaction: parsed as EVENT_ID Transaction_id: parsed as EVENT_ID user: parsed as USER_NAME 3. Configure destinations (ServiceNow and others) Now that you've set up your sources, you can configure your destinations. These are the data outputs where you view your incidents. Configure ServiceNow (example) Using ServiceNow as a destination enables you to push valuable violation data into new ServiceNow incident tickets. Send data to ServiceNow To configure Incident Intelligence to send data to ServiceNow: Go to one.newrelic.com, click Alerts & AI, in the left nav under Incident Intelligence click Destinations, then click ServiceNow. Required: Enter a channel name. This is used internally in Applied Intelligence to identify the destination (for example, in Pathways). Required: Enter your ServiceNow credentials: Team domain (This must be unique. No two destinations can have the same domain). Username Password Follow the two-way integration on screen instructions: Open and download this XML file. In the ServiceNow sidebar menu, go to System Definition > Business Rule. Click the menu icon in one of the column headers, select Import XML, and upload the XML file you downloaded. The two way integration will allow the ServiceNow incident to be updated with changes to the Applied Intelligence issue. Closing a ServiceNow incident will close its corresponding New Relic issue. When a New Relic issue is resolved, the corresponding ServiceNow incident will be closed. Custom notification message Applied Intelligence uses a templating framework called Jinja2 in the customization section interface. The Value field must be in valid Jinja syntax. By default, the interface populates a set of default fields in ServiceNow. When you add a custom field, enter the ServiceNow field name you want to use. When you want to skip a selected field in an issue update, add the | skip_on_update string at the end of the value you've selected. Tip By default, ServiceNow adds u_ to the beginning of its custom values. When mapping to ServiceNow attributes, use the Column name value. Please note that the name needs to be lowercase separated by underscores. Go here to see the custom notification message attribute descriptions. Go here to see Jinja2 Useful Syntax. Other destinations You can also set PagerDuty as a destination, as well as any other destination compatible with webhook: Send data to PagerDuty Recommended: Create a new PagerDuty service to use as a destination. Because PagerDuty services can also be used as sources, this can help you distinguish your data input from your output. To create a PagerDuty destination: Go to one.newrelic.com, click Alerts & AI, in the left nav under Incident Intelligence click Destinations, then click PagerDuty. Enter your PagerDuty API key. The key should be either a personal or general access key with write access. If it's created by a user, the user should be an admin. If you've configured a PagerDuty source with an API key, you can use the same key. Select the PagerDuty services you want to connect to Applied Intelligence, and click Connect. When you're ready, you can add policies for one or more PagerDuty destinations. You can also transfer the policies over from your existing services or leave them as sources if needed. From the Destinations > PagerDuty page, you can also: Review the permissions for your services. Click Authorize when you're done. Add or delete existing services from the PagerDuty destination. Edit permissions for any service. To configure your PagerDuty destinations, use the following settings: Configuration setting Description Trigger new incidents Required. Trigger correlated parent incidents so you can identify issues faster. Edit incident titles Required. Alter your incident titles to help you orient and understand issues. Add new integrations Required. Add integrations to enable incident creation for selected services. Add webhook extensions Add webhook extensions to sync user actions in PagerDuty to New Relic. This lets you update the correlated issue state. Auto-resolve correlated incidents When enabled, this will resolve and automatically close correlated parent/child incidents. Select a user to take actions in PagerDuty You need to select a user before you can enable deep integration with PagerDuty. Once you do, the user can: Add notes to incidents (required): Incident notes are used to enrich incidents with context. Acknowledge triggered incidents: When enabled, Applied Intelligence will acknowledge and correlate newly triggered incidents in PagerDuty before you're notified. Use the original escalation policy: When enabled, the escalation policy of the source service will be applied to each incident. Send data via webhook Incident Intelligence will send the event body in JSON format by HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). To configure Incident Intelligence to send data via webhook: Go to one.newrelic.com, click Alerts & AI, in the left nav under Incident Intelligence click Destinations, then click Webhook. Required: Configure the unique webhook key, used in Applied Intelligence to refer to this webhook configuration and its specific settings. Required: Configure the destination endpoint where the webhook payload will be sent. Optional steps: Configure custom headers, which are key:value pairs of headers to be sent with the request. Example: \"Authentication\" \"Bearer\" <bearer token> Configure a custom payload template that can be used to map New Relic fields to match the destination tool's expected name and format. Configure priority mapping (critical, high, medium, or low), used to map New Relic's priorities to the priorities expected at the destination. Tip There’s a retry mechanism that is triggered a few times with exponential backoff for a couple of minutes once an error occurs. If we reach the retry limit, the Webhook will get auto-disabled. For examples of destination templates, webhook formats, and JSON schema, see the Incident Intelligence destination examples. 4. Configure pathways To control when and where you want to receive notifications from your incidents, you can configure pathways. To add a pathway: Go to one.newrelic.com, click Alerts & AI, in the left nav under Incident Intelligence click Pathways, then click Add a pathway. In the query builder box, select an attribute, such as application/name. This can be from the list of all attributes available in PagerDuty incidents and New Relic alerts violations, or you can add your own attributes. Select a logical operator. For example, contains. Enter a specific value to complete the logical expression. To include all issues created by your sources, select Send everything. (Use this if you only use one PagerDuty service to manage all incidents.) To build more complex logic, use the AND/OR operators. Select one or more of your destinations. To edit or remove existing pathways, mouse over the pathway's name on the Pathways page. What's next? Now that you've set up some sources and destinations for your incidents, read about how to use Incident Intelligence.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 279.7902,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with <em>Incident</em> <em>Intelligence</em>",
        "sections": "Get started with <em>Incident</em> <em>Intelligence</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " and correlations from what you&#x27;re monitoring. To get data from <em>alerts</em>: From one.newrelic.com, click <em>Alerts</em>. On the left under <em>Incident</em> <em>Intelligence</em>, click Sources and then click <em>Alerts</em>. Select the policies you want to connect to <em>Applied</em> <em>Intelligence</em>, and click Connect. You can add additional <em>alerts</em> policies"
      },
      "id": "603ea62e64441f119f4e883f"
    }
  ],
  "/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/rest-api-applied-intelligence": [
    {
      "sections": [
        "Incident Intelligence destination examples",
        "Destination template examples",
        "Suggested OpsGenie template example",
        "Suggested ServiceNow template example",
        "Suggested Slack template example",
        "Suggested VictorOps template example",
        "Webhook and JSON format examples",
        "Webhook format and JSON example",
        "Jinja2 Default Payload",
        "Jinja2 Useful Syntax",
        "JSON schema",
        "JSON schema template"
      ],
      "title": "Incident Intelligence destination examples",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "a516d04f8b75541a6dc9338fa3ce9645ba87d620",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/incident-intelligence-destination-examples/",
      "published_at": "2021-06-02T18:22:22Z",
      "updated_at": "2021-06-02T18:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Destinations are the data outputs to Applied Intelligence, where you can view your automatically correlated incidents. You can configure Incident Intelligence destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema. Destination template examples The following template example destinations are formatted in Jinja2. Suggested OpsGenie template example { \"alias\": {{ id }}, \"message\": {{ ui_name }}, \"source\": '{{ sources }}', \"priority\": {{ priority }}, \"details\": { \"self_url\": {{ url }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"is_correlated\": {{ is_correlated }} }, \"description\": \"\"\"Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]\"\"\" } Copy Suggested ServiceNow template example { \"short_description\": {{ ui_name }}, \"description\": 'Issue Id: {{ id }}, \\n Description: {{ description }}, \\n Sources: {{ sources }}, \\n Priority: {{ priority }}, \\n Details: { \\n self_url: {{ url }}, \\n state: {{ state }}, \\n is_correlated: {{ is_correlated }}, \\n created_on: {{ created_on }}, \\n modified_on: {{ modified_on }}, \\n activated_on: {{ active_since }}, \\n closed_on: {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \\n is_correlated: {{is_correlated}} }, \\n\\n incidents: {{ incidents }}, \\n\\n pathways: {{ pathways }}' } Copy Suggested Slack template example Go to Slack incoming WebHooks Choose the right Slack workspace and click \"Add to Slack\" Select the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In New Relic Applied Intelligence, under Incident Intelligence click Destinations Add a WebHook In the end point paste the WebHook url from slack. In the custom payload, paste the following JSON: { \"blocks\": [ { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*New Relic Incident Intelligence Alert*\" } }, { \"type\": \"divider\" }, { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*CUSTOM FIELDS*:\" }, \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue ID*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Issue Title*\" }, { \"type\": \"plain_text\", \"text\": {{ id }} }, { \"type\": \"plain_text\", \"text\": {{ ui_name }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue URL*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Description*\" }, { \"type\": \"mrkdwn\", \"text\": {{ url }} }, { \"type\": \"plain_text\", \"text\": {{ description }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*State*\" }, { \"type\": \"mrkdwn\", \"text\": \"*is_correlated*\" }, { \"type\": \"plain_text\", \"text\": {{ state }} }, { \"type\": \"plain_text\", \"text\": \"{{ is_correlated }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Created On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Modified On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ created_on }}\" }, { \"type\": \"plain_text\", \"text\": \"{{ modified_on }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Activated On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Closed On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ active_since }}\" }, { \"type\": \"plain_text\", \"text\": \"{% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Aggregated Incidents*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Monitoring Tool*\" }, { \"type\": \"plain_text\", \"text\": \"{{ incident_count }}\" }, { \"type\": \"plain_text\", \"text\": {{ sources|join(', ') }} } ] } ] } Copy Suggested VictorOps template example { \"monitoring_tool\": {{ sources }}, {% if state == 'closed' %} \"message_type\": \"OK\", {% else %} \"message_type\": {{ priority }}, {% endif %} \"custom_fields\": { \"issue_url\": {{ url }}, \"description\": {{ description }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"related_incidents\": [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %} {% endfor %} ] }, \"state_message\": {{ description }}, \"entity_id\": {{ id }}, \"entity_display_name\": {{ ui_name }}, \"vo_annotate.u.NRAI_Link\": {{ url }} } Copy Webhook and JSON format examples Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). If you use webhooks to configure Incident Intelligence destinations, use these examples of the webhook body format and JSON schema. Webhook format and JSON example Webhook format: Name Description url Href A link to the UI where the issue can be seen. id String Unique identifier for the issue. title String The issue title. description String The description of the issue. priority Enum The issue priority. Can be Critical, High, Medium, or Low. state Enum The issue status. Can be Active, Closed, or Acknowledged. is_correlated Boolean True if the issue is based on correlated data. created_on String The date and time the issue was created (in ISO format). modified_on String The date and time the issue was modified (in ISO format). active_since String The date and time the issue was activated (in ISO format). closed_on String The date and time the issue was closed (in ISO format). sources List(String) List of the different sources that were used to send the events into Applied Intelligence (for example: PagerDuty). pathways List(Pathways) List of pathways that are associated with the issue. Each pathway contains an id and name: [{“id”: “pathway id”, “name”: “pathway name”}]. pathways[].id String The pathway ID. pathways[].name String The pathway name. incidents List(Incident) List of incidents that are attached to the issue. The list contains only the latest 100 incidents. incidents[].id String The incident ID. incidents[].events_count Integer The number of events used to create the incident. incidents[].title String The incident title. incidents[].description String The incident description. incidents[].labels Dictionary (String) A string to string mapping of the incident labels. Labels represent the unique entities that are used to describe the incident. incidents[].priority Enum The incident priority. Can be Critical, High, Medium, or Low. incidents[].sources List(String) The incident source. incidents[].state Enum(open, closed) The incident state. incidents[].opened_on String The date and time the incident was opened (in ISO format). incidents[].closed_on String The date and time the incident was closed (in ISO format). ui_name String Issue title. accumulations['alert/signal'] String Issue analysis summary golden signal/s (if applicable). accumulations['alert/components'] String Issue analysis summary golden components (if applicable). Jinja2 Default Payload Applied Intelligence uses a templating framework called Jinja2 in the Webhook interface. Here is a default Jinja2 payload to use: { \"id\": {{ id }}, \"url\": {{ url }}, \"ui_name\": {{ ui_name }}, \"description\": {{ description }}, \"priority\": {{ priority }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"active_since\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"sources\": {{ sources }}, \"incidents\": {{ incidents }}, \"pathways\": {{ pathways }}, } Copy Jinja2 Useful Syntax Below are a few useful Jinja2 commands to help you format your output. Casting a value to integer Example: “severity”: {{ priority | int }} Copy If clause to check if an attribute’s value is set Example: \"golden_signals\": {% if accumulations['alert/signal'] is defined %} {{ accumulations['alert/signal'] }} {% else %} None {% endif %} Copy For loop to iterate of an array of values: Example: \"description\": 'Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]' Copy Check if an array attribute's value is set: Example: \"hostname_field\": {% if incidents[0].labels['newrelic/tag/hostname'] is defined %} {{ incidents[0].labels['newrelic/tag/hostname'] }} {% else %} None {% endif %} Copy JSON schema Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). JSON schema template JSON schema: { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"definitions\": { \"Labels\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"LabelsSet\": { \"type\": \"array\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"$ref\": \"#/definitions/Labels\" }, \"uniqueItems\": true }, }, \"Annotations\": { \"type\": \"object\", \"title\": \"Additional contextual information about the Entity\", \"description\": \"Fields like title, description and priority can be described as annotations since\\nthey represent some additional information about the Incident.\\nFor example, the rule that creates the entity can have some logic that will create a title annotation field.\\nThe title will change according to the latest event received by the entity and as more\\nevent will keep coming the field may change, all this as a decision by the rule.\\nA different rule may decide not to populate the title at all.\\nSince a title can also be produced from the labels themselves.\", \"properties\": { \"title\": { \"type\": \"string\", \"maxLength\": 10000 }, \"description\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"patternProperties\": { \".*\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"Accumulations\": { \"type\": \"object\", \"title\": \"Accumulated data about the Incident\", \"description\": \"For example an entity with the label: host_name: foo will include a accumulated list of the\\nrelevant process names that are relevant to the entity. Accumulations will be derived from the events\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"type\": \"string\", \"maxLength\": 10000 } } }, \"IssueState\": { \"type\": \"string\", \"enum\": [ \"created\", \"active\", \"acknowledged\", \"closed\" ], \"properties\": {}, \"additionalProperties\": false }, \"Priority\": { \"type\": \"string\", \"enum\": [ \"critical\", \"high\", \"medium\", \"low\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueClosingReason\": { \"type\": \"string\", \"enum\": [ \"nacked\", \"resolved\", \"system\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueAction\": { \"type\": \"string\", \"enum\": [ \"ack\", \"snooze\", \"nack\", \"end_snooze\", \"expire_snooze\", \"star\", \"un_snooze\", \"unstar\", \"archive\", \"unarchive\", \"resolve\", \"reopen\", \"open\", \"feedback\", \"feedback_file\", \"open_ticket\", \"merge_issues\", \"active\", \"create\", \"close\", \"incident_updated\", \"confidence_changed\", \"diagnoses_changed\", \"rule_properties_changed\", \"flapping\", \"notification\", \"incident_events_limit_reached\", \"follow\", \"unfollow\", \"priority_updated\", \"comment\", \"incident_appended\", \"diagnosis_feedback\", \"flapping_delay_close\" ], \"properties\": {}, \"additionalProperties\": false }, \"StringKeyValue\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\" } }, \"JavaOptionalUuid\": { \"type\": \"string\", \"properties\": {}, \"additionalProperties\": false, \"format\": \"string-uuid\" } }, \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"customer_id\": { \"type\": \"integer\" }, \"labels_set\": { \"$ref\": \"#/definitions/LabelsSet\" }, \"annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations_version\": { \"type\": \"integer\" }, \"accumulations\": { \"$ref\": \"#/definitions/Accumulations\" }, \"state\": { \"$ref\": \"#/definitions/IssueState\" }, \"previous_state\": { \"$ref\": \"#/definitions/IssueState\" }, \"priority\": { \"$ref\": \"#/definitions/Priority\" }, \"closing_reason\": { \"oneOf\": [ { \"$ref\": \"#/definitions/IssueClosingReason\" }, { \"type\": \"null\" } ] }, \"modified_on\": { \"type\": \"integer\" }, \"created_on\": { \"type\": \"integer\" }, \"closed_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"acknowledged_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"active_since\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"assigned_to\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"created_by\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"progress_report\": { \"type\": \"array\", \"default\": [], \"items\": { \"type\": \"object\", \"properties\": { \"origin_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1 }, { \"type\": \"null\" } ] }, \"timestamp\": { \"type\": \"integer\" }, \"action_timestamp\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"origin_type\": { \"type\": \"string\", \"enum\": [ \"user\", \"system\" ] }, \"event_type\": { \"$ref\": \"#/definitions/IssueAction\" }, \"issue_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"format\": \"string-uuid\" }, { \"type\": \"null\" } ] }, \"attributes\": { \"oneOf\": [ { \"$ref\": \"#/definitions/StringKeyValue\" }, { \"type\": \"null\" } ] }, \"team_id\": { \"$ref\": \"#/definitions/JavaOptionalUuid\" } }, \"required\": [ \"timestamp\", \"origin_type\", \"event_type\" ], \"additionalProperties\": false }, \"uniqueItems\": true }, \"rule_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"maxLength\": 255 }, { \"type\": \"null\" } ] }, \"incident_ids\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"confidence\": { \"type\": \"number\", \"default\": 1.0, \"minimum\": 0.0, \"maximum\": 1.0 } }, \"required\": [ \"id\", \"customer_id\", \"labels_set\", \"annotations\", \"priority\", \"modified_on\", \"created_on\", \"confidence\" ], \"additionalProperties\": true } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 474.29813,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Incident</em> <em>Intelligence</em> destination examples",
        "sections": "<em>Incident</em> <em>Intelligence</em> destination examples",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "Destinations are the data outputs to <em>Applied</em> <em>Intelligence</em>, where you can view your automatically correlated incidents. You can configure <em>Incident</em> <em>Intelligence</em> destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema"
      },
      "id": "6044280d64441f4af5378ed3"
    },
    {
      "sections": [
        "Use Incident Intelligence",
        "Issue summary",
        "Impacted entities map",
        "Use suggested responders",
        "Important",
        "Tip",
        "Root cause analysis",
        "Issue timeline",
        "Related activity",
        "Use decisions"
      ],
      "title": "Use Incident Intelligence",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "f7b852fa406a6e9ff88b791e4cbccc2bd20a5962",
      "image": "https://docs.newrelic.com/static/6e37cc77304398121e1a0080a57e47bb/8c557/screenshot_incident_intelligence_timeline_event_detail.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/use-incident-intelligence/",
      "published_at": "2021-06-02T18:23:21Z",
      "updated_at": "2021-05-28T11:09:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you set up Incident Intelligence, our system will begin finding issues from your data sources. In the issue feed, you can find an overview of all your issues, along with helpful information about them. You can also click any individual issue for more detail, including its analysis summary, event log, and details about correlated issues. This screenshot shows an example issue feed, which describes your issues' statuses, correlations, and more. What's the difference between an issue, incident, and event? In short, these terms are like building blocks. Events are raw data from your sources. Incidents are made up of one or more events. Issues are composed of one or more incidents. In more detail: Events indicate a state change or trigger defined by your monitoring systems. An event contains information about the affected entity, and they are almost always triggered automatically by the system. Incidents are groups of events that describe the \"symptoms\" of your system over time. These symptoms are detected by your monitoring tools, which evaluate your data streams and events. Issues are groups of incidents that describe the underlying problem of your symptoms. When a new incident is created, Incident Intelligence opens an issue and evaluates other open issues for correlations. Issue summary The Issue page is built to provide you with bottom line insights first to understand the problem, and then to minimize the time you need to resolve it. The Issue page includes the following sections: Issue summary: This section has two machine learning modules, the golden signals and the related components. Suggested responders: This section will tell you who to potentially reach out to on your team to solve a specific problem. Label sets: Label sets are focused on incidents that come from 3rd party sources, such as PagerDuty, AWS Cloudwatch, REST APIs, etc., as well as for NRQL queries. They come in the form of key:value pairs. Impacted entities: An entity is anything that has data you can monitor. Specifically, these are focused on incidents from New Relic sources, extracting the entities and providing a summary. Each entity is unique. You can see your entities in a list or on a map. Depending on the data in an issue, all four of these sections can show up together for each issue or separately. If you hover over an impacted entity application, you’ll notice a few calls to action: relevant dashboards, anomaly overview, deployment events, and entity overview. Relevant dashboards helps users in your account look at and interact with dashboards you've created that are related to an entity. The queries you've run to power the various widgets are automatically mapped to entities whenever possible and are presented back to you here for quick access and discovery. Anomaly overview will open the application's anomalies page. This is only available for applications that are set up for Proactive Detection. There are two types of deployment events: deployments and related deployments. Click Show all deployments to see all your deployment events when they arrive, or click a specific deployment to see its APM deployments page. The APM deployment page lists recent deployments and their impact on your end user and app server's Apdex scores, response times, throughput, and errors. This section will only show up if New Relic has identified applications under the impacted entities that have deployments. Impacted entities map Hover over an entity to see more information about it. An impacted entities map is available for any issue involving two or more entities. The map shows not only the affected entities, but also the services and resources directly related to those entities. Use suggested responders If you’re using PagerDuty or New Relic alerts violations as your incident notification tools, Incident Intelligence suggests relevant team members that can help resolve your issues. Incident Intelligence learns from your PagerDuty and alerts violations data to provide suggestions for each new incident. Once you receive a suggestion, you can contact the responder or search for relevant documentation that person may have written. To get started, enable PagerDuty or alerts violations as a source for Incident Intelligence. Afterwards, you can view the suggestions in two places: The issue feed, where you can also provide feedback on the suggestions. Directly within PagerDuty (both UI and API.) If you’re also using PagerDuty as a destination, the suggestions will appear in your issue notifications payload. Important This feature doesn't account for on-call availability at the time of incident. Tip In order to train the model, we use the information PagerDuty provides about individuals. We ingest incident information only, not users’ contact details. Root cause analysis Root cause analysis automatically finds potential causes for an issue and its impacted entities. It shows you why open issues occurred, which deployments contributed, and relevant error logs and attributes. With this, you can investigate the problem and reduce your mean time to resolution (MTTR). Tip Note that root cause analysis is dependent on other New Relic data sources and features. This is why root cause analysis information may not always be present for every issue. When you select an issue, you may see Root cause analysis information. Root cause analysis includes three main UI sections: Deployment events: When you set up deployments, we provide the deployment nearest to the issue creation. Changes, such as deployments, account for a high percentage of the root causes of incidents and having that information at hand can help diagnose and resolve issues. Error logs: You can explore millions of log messages with a single click and use manual querying to help you find anomalous patterns and hard-to-find problems. Attributes to investigate: We scan the distribution of attributes and surface possible causes by finding significant changes in the distribution. This section also shows changes in database and external metrics. You can also query interesting attributes. Issue timeline The issue timeline, as presented below, shows you a breakdown of: Incidents The trends taking place What incidents are active What incidents are resolved What is correlated to each other Various milestones at different issue levels In addition, you’ll see a grey line at the top of the timeline. In comparison to the visual timeline that shows the changes to each incident, the grey line represents changes to the issue. Mouse over the grey line to see details of the event. Finally, mouse over the incident to see information on the location, timing, and level of importance of a specific incident. This figure shows a particular incident populated on January 11th with a level of Critical. To view the issues in a text format, in the right hand corner, click Switch to issue log view. Related activity The issue page includes a Related activity section, which is a table displaying activity related to the incident or anomally you are are trying to analyze. You can click each line item in the table to view a unique dashboard that displays data for the entity the incident or anomally came from. The related activity section aggregates a set of incidents into a single issue, according to a rule-based system. Use decisions To further reduce noise or get improved incident correlation, you can change or customize your decisions. Decisions determine how Incident Intelligence groups incidents together. To get started, see Decisions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 358.7185,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use <em>Incident</em> <em>Intelligence</em>",
        "sections": "Use <em>Incident</em> <em>Intelligence</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": ". The map shows not only the affected entities, but also the services and resources directly related to those entities. Use suggested responders If you’re using PagerDuty or New Relic <em>alerts</em> violations as your <em>incident</em> notification tools, <em>Incident</em> <em>Intelligence</em> suggests relevant team members that can"
      },
      "id": "6080293564441fd0669d8580"
    },
    {
      "sections": [
        "Expanded anomaly detection",
        "Requirements",
        "Why it matters",
        "Get started with anomaly detection",
        "Detect anomalies with a faceted NRQL query",
        "See your anomalies in one place",
        "Tip",
        "Query anomaly data",
        "Reduce the number of detected anomalies"
      ],
      "title": "Expanded anomaly detection",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Proactive detection"
      ],
      "external_id": "0b07c0b6ce27f39b5edb3e112a0f949835cbb8c6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/proactive-detection/expanded-anomaly-detection/",
      "published_at": "2021-06-02T18:27:12Z",
      "updated_at": "2021-05-31T16:43:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We’ve expanded anomaly detection coverage beyond your APM applications. Configure anomaly detection for your browser applications, mobile applications, infrastructure hosts, and nearly anything you want to monitor. Requirements Expanded anomaly detection is available as a limited beta. You can request access here. Why it matters When starting to configure alert conditions for a variety of applications and hosts, it can be difficult to know what you’ll want to be notified about ahead of time. Anomaly detection helps you distinguish between what’s typical performance in your system and where you’re starting to have trouble. Instead of creating your alert conditions manually, you can simply tell us what you want to monitor. Anomaly detection will help you identify baseline performance in your system and flags anomalous activity in your system. Get started with anomaly detection To get started with expanded anomaly detection: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Select the account you want to use to record anomaly data, then select the workload or entities you’d like to monitor. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name your configuration and save. Detect anomalies with a faceted NRQL query To detect anomalies with a faceted NRQL query: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Click Use a query instead. You may need to select an account, if you have more than one. Add one or more queries with a FACET clause. Name the query and confirm the facets you want to monitor for anomalies. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name the configuration and save. See your anomalies in one place When you set up anomaly detection, New Relic starts analyzing the golden signals of your entities and workloads. Anomalies appear in your activity feeds throughout New Relic One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL alert condition for the NrAiAnomaly event. To view anomalies, from one.newrelic.com, go to Alerts & AI > Issues & activity > Anomalies. Query anomaly data Detected anomalies are written to the NrAiAnomaly event in your NRDB account. You can learn more about this event and how to query it here. Reduce the number of detected anomalies If you’re seeing too many anomalies, the first step is to make sure your sensitivity level is set to Low. If it’s already set to Low, you can define specific thresholds to distinguish between normal and anomalous behavior. To define custom thresholds: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab and the configuration you want to modify. Select an entity or workload, and then change the sensitivity level. You can use custom sensitivity to define specific thresholds for different entity types.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 290.33502,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " request access here. Why it matters When starting to configure <em>alert</em> conditions for a variety of applications and hosts, it can be difficult to know what you’ll want to be notified about ahead of time. Anomaly detection helps you distinguish between what’s typical performance in your system and where"
      },
      "id": "60b5124064441ff965e2cb01"
    }
  ],
  "/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/use-incident-intelligence": [
    {
      "sections": [
        "Incident Intelligence destination examples",
        "Destination template examples",
        "Suggested OpsGenie template example",
        "Suggested ServiceNow template example",
        "Suggested Slack template example",
        "Suggested VictorOps template example",
        "Webhook and JSON format examples",
        "Webhook format and JSON example",
        "Jinja2 Default Payload",
        "Jinja2 Useful Syntax",
        "JSON schema",
        "JSON schema template"
      ],
      "title": "Incident Intelligence destination examples",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "a516d04f8b75541a6dc9338fa3ce9645ba87d620",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/incident-intelligence-destination-examples/",
      "published_at": "2021-06-02T18:22:22Z",
      "updated_at": "2021-06-02T18:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Destinations are the data outputs to Applied Intelligence, where you can view your automatically correlated incidents. You can configure Incident Intelligence destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema. Destination template examples The following template example destinations are formatted in Jinja2. Suggested OpsGenie template example { \"alias\": {{ id }}, \"message\": {{ ui_name }}, \"source\": '{{ sources }}', \"priority\": {{ priority }}, \"details\": { \"self_url\": {{ url }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"is_correlated\": {{ is_correlated }} }, \"description\": \"\"\"Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]\"\"\" } Copy Suggested ServiceNow template example { \"short_description\": {{ ui_name }}, \"description\": 'Issue Id: {{ id }}, \\n Description: {{ description }}, \\n Sources: {{ sources }}, \\n Priority: {{ priority }}, \\n Details: { \\n self_url: {{ url }}, \\n state: {{ state }}, \\n is_correlated: {{ is_correlated }}, \\n created_on: {{ created_on }}, \\n modified_on: {{ modified_on }}, \\n activated_on: {{ active_since }}, \\n closed_on: {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \\n is_correlated: {{is_correlated}} }, \\n\\n incidents: {{ incidents }}, \\n\\n pathways: {{ pathways }}' } Copy Suggested Slack template example Go to Slack incoming WebHooks Choose the right Slack workspace and click \"Add to Slack\" Select the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In New Relic Applied Intelligence, under Incident Intelligence click Destinations Add a WebHook In the end point paste the WebHook url from slack. In the custom payload, paste the following JSON: { \"blocks\": [ { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*New Relic Incident Intelligence Alert*\" } }, { \"type\": \"divider\" }, { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*CUSTOM FIELDS*:\" }, \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue ID*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Issue Title*\" }, { \"type\": \"plain_text\", \"text\": {{ id }} }, { \"type\": \"plain_text\", \"text\": {{ ui_name }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue URL*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Description*\" }, { \"type\": \"mrkdwn\", \"text\": {{ url }} }, { \"type\": \"plain_text\", \"text\": {{ description }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*State*\" }, { \"type\": \"mrkdwn\", \"text\": \"*is_correlated*\" }, { \"type\": \"plain_text\", \"text\": {{ state }} }, { \"type\": \"plain_text\", \"text\": \"{{ is_correlated }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Created On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Modified On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ created_on }}\" }, { \"type\": \"plain_text\", \"text\": \"{{ modified_on }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Activated On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Closed On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ active_since }}\" }, { \"type\": \"plain_text\", \"text\": \"{% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Aggregated Incidents*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Monitoring Tool*\" }, { \"type\": \"plain_text\", \"text\": \"{{ incident_count }}\" }, { \"type\": \"plain_text\", \"text\": {{ sources|join(', ') }} } ] } ] } Copy Suggested VictorOps template example { \"monitoring_tool\": {{ sources }}, {% if state == 'closed' %} \"message_type\": \"OK\", {% else %} \"message_type\": {{ priority }}, {% endif %} \"custom_fields\": { \"issue_url\": {{ url }}, \"description\": {{ description }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"related_incidents\": [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %} {% endfor %} ] }, \"state_message\": {{ description }}, \"entity_id\": {{ id }}, \"entity_display_name\": {{ ui_name }}, \"vo_annotate.u.NRAI_Link\": {{ url }} } Copy Webhook and JSON format examples Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). If you use webhooks to configure Incident Intelligence destinations, use these examples of the webhook body format and JSON schema. Webhook format and JSON example Webhook format: Name Description url Href A link to the UI where the issue can be seen. id String Unique identifier for the issue. title String The issue title. description String The description of the issue. priority Enum The issue priority. Can be Critical, High, Medium, or Low. state Enum The issue status. Can be Active, Closed, or Acknowledged. is_correlated Boolean True if the issue is based on correlated data. created_on String The date and time the issue was created (in ISO format). modified_on String The date and time the issue was modified (in ISO format). active_since String The date and time the issue was activated (in ISO format). closed_on String The date and time the issue was closed (in ISO format). sources List(String) List of the different sources that were used to send the events into Applied Intelligence (for example: PagerDuty). pathways List(Pathways) List of pathways that are associated with the issue. Each pathway contains an id and name: [{“id”: “pathway id”, “name”: “pathway name”}]. pathways[].id String The pathway ID. pathways[].name String The pathway name. incidents List(Incident) List of incidents that are attached to the issue. The list contains only the latest 100 incidents. incidents[].id String The incident ID. incidents[].events_count Integer The number of events used to create the incident. incidents[].title String The incident title. incidents[].description String The incident description. incidents[].labels Dictionary (String) A string to string mapping of the incident labels. Labels represent the unique entities that are used to describe the incident. incidents[].priority Enum The incident priority. Can be Critical, High, Medium, or Low. incidents[].sources List(String) The incident source. incidents[].state Enum(open, closed) The incident state. incidents[].opened_on String The date and time the incident was opened (in ISO format). incidents[].closed_on String The date and time the incident was closed (in ISO format). ui_name String Issue title. accumulations['alert/signal'] String Issue analysis summary golden signal/s (if applicable). accumulations['alert/components'] String Issue analysis summary golden components (if applicable). Jinja2 Default Payload Applied Intelligence uses a templating framework called Jinja2 in the Webhook interface. Here is a default Jinja2 payload to use: { \"id\": {{ id }}, \"url\": {{ url }}, \"ui_name\": {{ ui_name }}, \"description\": {{ description }}, \"priority\": {{ priority }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"active_since\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"sources\": {{ sources }}, \"incidents\": {{ incidents }}, \"pathways\": {{ pathways }}, } Copy Jinja2 Useful Syntax Below are a few useful Jinja2 commands to help you format your output. Casting a value to integer Example: “severity”: {{ priority | int }} Copy If clause to check if an attribute’s value is set Example: \"golden_signals\": {% if accumulations['alert/signal'] is defined %} {{ accumulations['alert/signal'] }} {% else %} None {% endif %} Copy For loop to iterate of an array of values: Example: \"description\": 'Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]' Copy Check if an array attribute's value is set: Example: \"hostname_field\": {% if incidents[0].labels['newrelic/tag/hostname'] is defined %} {{ incidents[0].labels['newrelic/tag/hostname'] }} {% else %} None {% endif %} Copy JSON schema Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). JSON schema template JSON schema: { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"definitions\": { \"Labels\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"LabelsSet\": { \"type\": \"array\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"$ref\": \"#/definitions/Labels\" }, \"uniqueItems\": true }, }, \"Annotations\": { \"type\": \"object\", \"title\": \"Additional contextual information about the Entity\", \"description\": \"Fields like title, description and priority can be described as annotations since\\nthey represent some additional information about the Incident.\\nFor example, the rule that creates the entity can have some logic that will create a title annotation field.\\nThe title will change according to the latest event received by the entity and as more\\nevent will keep coming the field may change, all this as a decision by the rule.\\nA different rule may decide not to populate the title at all.\\nSince a title can also be produced from the labels themselves.\", \"properties\": { \"title\": { \"type\": \"string\", \"maxLength\": 10000 }, \"description\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"patternProperties\": { \".*\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"Accumulations\": { \"type\": \"object\", \"title\": \"Accumulated data about the Incident\", \"description\": \"For example an entity with the label: host_name: foo will include a accumulated list of the\\nrelevant process names that are relevant to the entity. Accumulations will be derived from the events\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"type\": \"string\", \"maxLength\": 10000 } } }, \"IssueState\": { \"type\": \"string\", \"enum\": [ \"created\", \"active\", \"acknowledged\", \"closed\" ], \"properties\": {}, \"additionalProperties\": false }, \"Priority\": { \"type\": \"string\", \"enum\": [ \"critical\", \"high\", \"medium\", \"low\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueClosingReason\": { \"type\": \"string\", \"enum\": [ \"nacked\", \"resolved\", \"system\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueAction\": { \"type\": \"string\", \"enum\": [ \"ack\", \"snooze\", \"nack\", \"end_snooze\", \"expire_snooze\", \"star\", \"un_snooze\", \"unstar\", \"archive\", \"unarchive\", \"resolve\", \"reopen\", \"open\", \"feedback\", \"feedback_file\", \"open_ticket\", \"merge_issues\", \"active\", \"create\", \"close\", \"incident_updated\", \"confidence_changed\", \"diagnoses_changed\", \"rule_properties_changed\", \"flapping\", \"notification\", \"incident_events_limit_reached\", \"follow\", \"unfollow\", \"priority_updated\", \"comment\", \"incident_appended\", \"diagnosis_feedback\", \"flapping_delay_close\" ], \"properties\": {}, \"additionalProperties\": false }, \"StringKeyValue\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\" } }, \"JavaOptionalUuid\": { \"type\": \"string\", \"properties\": {}, \"additionalProperties\": false, \"format\": \"string-uuid\" } }, \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"customer_id\": { \"type\": \"integer\" }, \"labels_set\": { \"$ref\": \"#/definitions/LabelsSet\" }, \"annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations_version\": { \"type\": \"integer\" }, \"accumulations\": { \"$ref\": \"#/definitions/Accumulations\" }, \"state\": { \"$ref\": \"#/definitions/IssueState\" }, \"previous_state\": { \"$ref\": \"#/definitions/IssueState\" }, \"priority\": { \"$ref\": \"#/definitions/Priority\" }, \"closing_reason\": { \"oneOf\": [ { \"$ref\": \"#/definitions/IssueClosingReason\" }, { \"type\": \"null\" } ] }, \"modified_on\": { \"type\": \"integer\" }, \"created_on\": { \"type\": \"integer\" }, \"closed_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"acknowledged_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"active_since\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"assigned_to\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"created_by\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"progress_report\": { \"type\": \"array\", \"default\": [], \"items\": { \"type\": \"object\", \"properties\": { \"origin_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1 }, { \"type\": \"null\" } ] }, \"timestamp\": { \"type\": \"integer\" }, \"action_timestamp\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"origin_type\": { \"type\": \"string\", \"enum\": [ \"user\", \"system\" ] }, \"event_type\": { \"$ref\": \"#/definitions/IssueAction\" }, \"issue_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"format\": \"string-uuid\" }, { \"type\": \"null\" } ] }, \"attributes\": { \"oneOf\": [ { \"$ref\": \"#/definitions/StringKeyValue\" }, { \"type\": \"null\" } ] }, \"team_id\": { \"$ref\": \"#/definitions/JavaOptionalUuid\" } }, \"required\": [ \"timestamp\", \"origin_type\", \"event_type\" ], \"additionalProperties\": false }, \"uniqueItems\": true }, \"rule_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"maxLength\": 255 }, { \"type\": \"null\" } ] }, \"incident_ids\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"confidence\": { \"type\": \"number\", \"default\": 1.0, \"minimum\": 0.0, \"maximum\": 1.0 } }, \"required\": [ \"id\", \"customer_id\", \"labels_set\", \"annotations\", \"priority\", \"modified_on\", \"created_on\", \"confidence\" ], \"additionalProperties\": true } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 474.29813,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Incident</em> <em>Intelligence</em> destination examples",
        "sections": "<em>Incident</em> <em>Intelligence</em> destination examples",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "Destinations are the data outputs to <em>Applied</em> <em>Intelligence</em>, where you can view your automatically correlated incidents. You can configure <em>Incident</em> <em>Intelligence</em> destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema"
      },
      "id": "6044280d64441f4af5378ed3"
    },
    {
      "sections": [
        "Expanded anomaly detection",
        "Requirements",
        "Why it matters",
        "Get started with anomaly detection",
        "Detect anomalies with a faceted NRQL query",
        "See your anomalies in one place",
        "Tip",
        "Query anomaly data",
        "Reduce the number of detected anomalies"
      ],
      "title": "Expanded anomaly detection",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Proactive detection"
      ],
      "external_id": "0b07c0b6ce27f39b5edb3e112a0f949835cbb8c6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/proactive-detection/expanded-anomaly-detection/",
      "published_at": "2021-06-02T18:27:12Z",
      "updated_at": "2021-05-31T16:43:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We’ve expanded anomaly detection coverage beyond your APM applications. Configure anomaly detection for your browser applications, mobile applications, infrastructure hosts, and nearly anything you want to monitor. Requirements Expanded anomaly detection is available as a limited beta. You can request access here. Why it matters When starting to configure alert conditions for a variety of applications and hosts, it can be difficult to know what you’ll want to be notified about ahead of time. Anomaly detection helps you distinguish between what’s typical performance in your system and where you’re starting to have trouble. Instead of creating your alert conditions manually, you can simply tell us what you want to monitor. Anomaly detection will help you identify baseline performance in your system and flags anomalous activity in your system. Get started with anomaly detection To get started with expanded anomaly detection: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Select the account you want to use to record anomaly data, then select the workload or entities you’d like to monitor. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name your configuration and save. Detect anomalies with a faceted NRQL query To detect anomalies with a faceted NRQL query: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Click Use a query instead. You may need to select an account, if you have more than one. Add one or more queries with a FACET clause. Name the query and confirm the facets you want to monitor for anomalies. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name the configuration and save. See your anomalies in one place When you set up anomaly detection, New Relic starts analyzing the golden signals of your entities and workloads. Anomalies appear in your activity feeds throughout New Relic One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL alert condition for the NrAiAnomaly event. To view anomalies, from one.newrelic.com, go to Alerts & AI > Issues & activity > Anomalies. Query anomaly data Detected anomalies are written to the NrAiAnomaly event in your NRDB account. You can learn more about this event and how to query it here. Reduce the number of detected anomalies If you’re seeing too many anomalies, the first step is to make sure your sensitivity level is set to Low. If it’s already set to Low, you can define specific thresholds to distinguish between normal and anomalous behavior. To define custom thresholds: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab and the configuration you want to modify. Select an entity or workload, and then change the sensitivity level. You can use custom sensitivity to define specific thresholds for different entity types.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 290.33502,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " request access here. Why it matters When starting to configure <em>alert</em> conditions for a variety of applications and hosts, it can be difficult to know what you’ll want to be notified about ahead of time. Anomaly detection helps you distinguish between what’s typical performance in your system and where"
      },
      "id": "60b5124064441ff965e2cb01"
    },
    {
      "sections": [
        "Get started with Incident Intelligence",
        "Tip",
        "Set up Incident Intelligence",
        "1. Configure your environment (one-time)",
        "2. Configure sources",
        "Alerts",
        "Algorithmia (MLOps)",
        "Connect your Algorithmia data to New Relic",
        "Monitor your machine learning models",
        "Anomalies",
        "AWS",
        "Grafana",
        "PagerDuty",
        "Prometheus Alertmanager",
        "REST API",
        "Splunk",
        "Important",
        "Splunk metadata",
        "3. Configure destinations (ServiceNow and others)",
        "Configure ServiceNow (example)",
        "Send data to ServiceNow",
        "Custom notification message",
        "Other destinations",
        "Send data to PagerDuty",
        "Send data via webhook",
        "4. Configure pathways",
        "What's next?"
      ],
      "title": "Get started with Incident Intelligence",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "8c4a5a914ca01cb42250908d2fb1a12ccc697e25",
      "image": "https://docs.newrelic.com/static/5cb28999dc618c6a5a2b8be1fa72e660/b97f6/image-%25281%2529_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/get-started-incident-intelligence/",
      "published_at": "2021-06-02T18:25:14Z",
      "updated_at": "2021-05-16T16:21:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "As part of Applied Intelligence, Incident Intelligence helps you correlate your incidents and reduce noise in your environment. It gives you an overview of all your incidents, their sources, and related events. Tip To use Incident Intelligence and Applied Intelligence, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Set up Incident Intelligence To enable Incident Intelligence, follow these four steps. Afterwards, issues should start to appear in your issue feed. 1. Configure your environment (one-time). 2. Configure sources. 3. Configure destinations. 4. Configure pathways. 1. Configure your environment (one-time) To set up an environment in Incident Intelligence, you need an administrator to select a New Relic account for it. This account should be the one your team is using. Who sets the environment? Only administrators, and only for accounts where they have admin privileges. Can administrators set more than one environment? They can set one environment per master account and its sub-accounts. More than one can be set if an administrator has privileges for more than one master account. Need to change the environment's associated account? Reach out to your account executive or our support team for help. Tip Incident Intelligence is a cross-account product. This means you can send in data from any New Relic account or external source to correlate events. 2. Configure sources After setting up your environment, determine your incident sources. These are your data inputs. You can get data from any of the following sources: Alerts By integrating Incident Intelligence with your alerts violations, you can get context and correlations from what you're monitoring. To get data from alerts: From one.newrelic.com, click Alerts. On the left under Incident Intelligence, click Sources and then click Alerts. Select the policies you want to connect to Applied Intelligence, and click Connect. You can add additional alerts policies or remove policies you've already connected in Sources > New Relic Alerts. Tip Adding alerts as a source will not affect your current configuration or notifications. Algorithmia (MLOps) By integrating Incident Intelligence with your Algorithmia machine-learning models, you can monitor your machine learning model performance. Connect your Algorithmia data to New Relic Start monitoring your Algorithmia event flows with New Relic. Step Details Get your API key From one.newrelic.com the account menu, click API keys and then create a user key for your account with a meaningful name. Make note of this name for later. For more on API keys, see our docs. Create a dashboard From one.newrelic.com go to Dashboards, then click the Import dashboards button. Copy and paste the JSON code into the Paste your JSON field code. Update the YOUR_ACCOUNT_ID values with your account ID. { \"name\": \"Algorithmia Dashboard for Default Metrics\", \"description\": null, \"permissions\": \"PUBLIC_READ_WRITE\", \"pages\": [ { \"name\": \"Algorithmia Dashboard for Default Metrics\", \"description\": null, \"widgets\": [ { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"Runtime Duration by Algorithm\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": YOUR_ACCOUNT_ID, \"query\": \"SELECT average(algorithmia.duration_milliseconds) FROM Metric TIMESERIES FACET `algorithm_name` LIMIT 10 SINCE 1800 seconds ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"Throughput by Algorithm\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": YOUR_ACCOUNT_ID, \"query\": \"SELECT count(algorithmia.duration_milliseconds) FROM Metric TIMESERIES FACET `algorithm_name` LIMIT 10 SINCE 1800 seconds ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] } ] } ``` Copy Configure Algorithmia Insights for New Relic Use Algorithmia's docs to configure Algorithmia Insights for New Relic. Create the New Relic connector algorithm Use Python 3.8 to create a connector algorithm. If you're new to writing code to generate algorithms, see Algorithmia's getting started guide. import Algorithmia import json from datetime import datetime from newrelic_telemetry_sdk import GaugeMetric, MetricClient client = Algorithmia.client() metric_client = MetricClient(os.environ[\"newrelic_api_key\"]) def convert_str_timestamp_to_epoch(str_time): obj_time = datetime.strptime(str_time, \"%Y-%m-%dT%H:%M:%S.%f\") return int(obj_time.timestamp() * 1000) def get_operational_metrics(payload): ALGORITHM_TAGS = { \"algorithm_version\", \"request_id\", \"time\", \"algorithm_name\", \"session_id\", \"algorithm_owner\" } inference_metrics = { key: payload[key] for key in payload.keys() ^ ALGORITHM_TAGS } return inference_metrics def send_to_newrelic(inference_metrics, insights_payload): newrelic_metrics = [] for key, value in inference_metrics.items(): name = \"algorithmia.\" + key epoch_time = convert_str_timestamp_to_epoch(insights_payload[\"time\"]) tags = { \"algorithm_name\": insights_payload[\"algorithm_name\"], \"algorithm_version\": insights_payload[\"algorithm_version\"], \"algorithm_owner\": insights_payload[\"algorithm_owner\"], \"request_id\": insights_payload[\"request_id\"], \"session_id\": insights_payload[\"session_id\"], } newrelic_metrics.append(GaugeMetric( name=name, value=value, tags=tags, end_time_ms=epoch_time )) response = metric_client.send_batch(newrelic_metrics) response.raise_for_status() def apply(input): insights_payload = input inference_metrics = get_operational_metrics(insights_payload) send_to_newrelic(inference_metrics, insights_payload) return None Copy Include these dependencies: algorithmia>=1.0.0,<2.0 newrelic_telemetry_sdk==0.4.2 Copy Once your algorithm build finishes, you can test it with this sample payload to make sure it runs successfully. Your output should look something like this. { \"risk_score\": 0.2, \"duration_milliseconds\": 8, \"algorithm_version\": \"1.0.6\", \"session_id\": \"rses-f28bb94a-5556-4aeb-a6d2-89493626bf4f\", \"time\": \"2021-02-20T00:21:54.867231\", \"algorithm_name\": \"credit_card_approval\", \"request_id\": \"req-9f5345b4-a1cd-431c-a43a-bd2a06f4a6f4\", \"algorithm_owner\": \"asli\" } Copy Configure with your API key Add your New Relic API key to the Algorithmia secret store. Set up Algorithmia Event Flows with New Relic See Algorithmia's documentation on setting up your connector algorithm to send event-based machine learning flows to New Relic. Monitor your machine learning models Step Details Get your API key From one.newrelic.com the account menu, click API keys and then create a user key for your account with a meaningful name. Make note of this name for later. For more on API keys, see our docs. Create a dashboard From one.newrelic.com go to Dashboards, then click the Import dashboards button. Copy and paste the JSON code into the Paste your JSON field code. Update the YOUR_ACCOUNT_ID values with your account ID. { \"name\": \"Algorithmia Dashboard for Default Metrics\", \"description\": null, \"permissions\": \"PUBLIC_READ_WRITE\", \"pages\": [ { \"name\": \"Algorithmia Dashboard for Default Metrics\", \"description\": null, \"widgets\": [ { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 1, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"Runtime Duration by Algorithm\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": YOUR_ACCOUNT_ID, \"query\": \"SELECT average(algorithmia.duration_milliseconds) FROM Metric TIMESERIES FACET `algorithm_name` LIMIT 10 SINCE 1800 seconds ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null }, { \"visualization\": { \"id\": \"viz.line\" }, \"layout\": { \"column\": 5, \"row\": 1, \"height\": 3, \"width\": 4 }, \"title\": \"Throughput by Algorithm\", \"rawConfiguration\": { \"legend\": { \"enabled\": true }, \"nrqlQueries\": [ { \"accountId\": YOUR_ACCOUNT_ID, \"query\": \"SELECT count(algorithmia.duration_milliseconds) FROM Metric TIMESERIES FACET `algorithm_name` LIMIT 10 SINCE 1800 seconds ago\" } ], \"yAxisLeft\": { \"zero\": true } }, \"linkedEntityGuids\": null } ] } ] } ``` Copy Set up alerts notifications Once you've created some dashboards, you can get alerted on your data. To create a NRQL alerts condition from a chart, click the chart menu , then click Create alert condition. Once you've named and customized your condition, you can add it to an existing policy or create a new one. Get notified Once you've created an alerts condition, you can choose how you want to be notified. See our docs on how to set up notification channels. Correlate your incidents In addition to notifications, you can use Incident Intelligence to correlate your incidents. See our docs on how to correlate incidents using decisions. Anomalies By integrating Incident Intelligence with your New Relic Proactive Detection anomalies, you can get context and correlations from what you're monitoring. To get data from New Relic Proactive Detection anomalies: From one.newrelic.com, click Alerts & AI. On the left under Incident Intelligence, click Sources and then click Anomalies. Select the configurations you want to connect to Applied Intelligence by toggling to on (green). To add or remove alert policies, from Alerts & AI, click Sources, then Alerts. Tip Adding anomalies as a source won't affect your current Proactive Detection configurations or notifications. AWS You can integrate Incident Intelligence with Amazon CloudWatch to provide incident management for all of your AWS services. To integrate Amazon CloudWatch: Go to one.newrelic.com and click Alerts & AI. On the left under Incident Intelligence, click Sources and then click Amazon Web Services. Copy the URL. Create a new Amazon SNS topic. Set CloudWatch to forward all Alarms state changes to that topic: In the Amazon CloudWatch UI, click Events > Event Pattern. Select Service Name > CloudWatch. Select Event Type > CloudWatch Alarm State Change. Select Targets > SNS Topic, and select your new Amazon SNS topic. Create a new subscription: In the Amazon AWS UI, click Create a Subscription. Select your new Amazon SNS topic. Select Protocol > choose HTTPS. In Endpoint, paste the URL you previously copied from the Applied Intelligence Sources. Grafana You can integrate Incident Intelligence with Grafana's notifications for insight into events across your applications and environment. Grafana's webhook notification is a simple way to send information over HTTP to a custom endpoint. To integrate Grafana as a new webhook: Log into your Grafana portal using Admin permissions, and choose Alerting. On the Grafana Notification Channels page, click New Channel > Webhook. Go to one.newrelic.com and click Alerts & AI. On the left under Incident Intelligence, click Sources, and then click Grafana. Copy the URL, and paste it into your new Grafana webhook. PagerDuty You can integrate Incident Intelligence directly with your PagerDuty services to ingest, process, and enhance all of your PagerDuty incidents. To get data from PagerDuty: Make sure your PagerDuty API key has write access. From one.newrelic.com, click Alerts & AI. On the left under Incident Intelligence, click Sources and then click PagerDuty. Enter your PagerDuty API key. The key should be either a personal or general access key with write access. If it's created by a user, the user should be an admin. Select the PagerDuty services you want to connect to Applied Intelligence, and click Connect. You can add additional services or remove services you've already connected in Sources > PagerDuty. Tip Connecting PagerDuty services to Applied Intelligence will not affect your current services or notifications. Prometheus Alertmanager By integrating Incident Intelligence with Prometheus Alertmanager, you can receive and correlate your Prometheus alerts with events from other sources. To integrate Prometheus Alertmanager: Set up your Alertmanager configuration file by running: ./alertmanager -config.file=simple.yml Copy Go to one.newrelic.com and click Alerts & AI. On the left under Incident Intelligence, click Sources and then click Prometheus Alertmanager. Copy the Prometheus Alertmanager URL, and paste it into the <webhook_config>/url section of your Alertmanager config file. Reload the Prometheus Alertmanager configuration with one of the two methods: Send a SIGHUP to the process. Send an HTTP POST request to the /-/reload endpoint. REST API Incident Intelligence supports a dedicated REST API interface that lets you integrate with additional systems. The interface allows instrumentation of your code or other monitoring solutions to report any kind of metric or event. A metric can be a raw data point such as CPU, memory, disk utilization, or business KPI. An event can be a monitoring alert, deployment event, incident, exceptions or any other change in state that you want to describe. You can also send any type of data to Incident Intelligence straight from your own systems or applications. The REST API supports secure token-based authentication and accepts JSON content as input. For more information on authentication and the full API reference, see REST API for New Relic Applied Intelligence. Splunk By integrating Incident Intelligence with your Splunk log monitoring, you can: Use your environment's log data for searches and key term reports. Correlate alerts and search reports with your other metrics and incidents. Important Applied Intelligence supports Splunk Light, Splunk Cloud, and Splunk Enterprise version 6.3 and higher. To get data from Splunk: In your Splunk console, start a search for the relevant events. Save your search as an alert, configure your alert conditions, and then choose the webhook as the delivery method. Go to one.newrelic.com and click Alerts & AI. On the left under Incident Intelligence, click Sources and then click Splunk. Copy the collector URL, and paste it into the webhook endpoint in the Splunk console. Optional: Use Splunk tokens to enrich alert data with Splunk metadata. Splunk metadata To enrich alerts data with your Splunk metadata, use Splunk tokens. This helps you leverage your search data, which includes metadata and values from the first row of search results. If you want to... Do this... Access search data Use the format $<fieldname>$. For example, use $app$ for the app context for the search. Access field values To access field values from the first result row that a search returns, use the format $result.<fieldname>$. For example, use $result.host$ for the host value and $result.sourcetype$ for the source type. Use variables You can leverage any of the Selected fields in the Splunk search and add any unique fields to the Selected fields to make the data available as a variable. The following fields will automatically provide hints to the correlation engine: app: parsed as APPLICATION_NAME application:parsed as APPLICATION_NAME application_name: parsed as APPLICATION_NAME cluster: parsed as CLUSTER_NAME computer: parsed as HOST_NAME Dc: parsed as DATACENTER_NAME datacenter: parsed as DATACENTER_NAME host: parsed as HOST_NAME host_name: parsed as HOST_NAME hostname: parsed as HOST_NAME transaction: parsed as EVENT_ID Transaction_id: parsed as EVENT_ID user: parsed as USER_NAME 3. Configure destinations (ServiceNow and others) Now that you've set up your sources, you can configure your destinations. These are the data outputs where you view your incidents. Configure ServiceNow (example) Using ServiceNow as a destination enables you to push valuable violation data into new ServiceNow incident tickets. Send data to ServiceNow To configure Incident Intelligence to send data to ServiceNow: Go to one.newrelic.com, click Alerts & AI, in the left nav under Incident Intelligence click Destinations, then click ServiceNow. Required: Enter a channel name. This is used internally in Applied Intelligence to identify the destination (for example, in Pathways). Required: Enter your ServiceNow credentials: Team domain (This must be unique. No two destinations can have the same domain). Username Password Follow the two-way integration on screen instructions: Open and download this XML file. In the ServiceNow sidebar menu, go to System Definition > Business Rule. Click the menu icon in one of the column headers, select Import XML, and upload the XML file you downloaded. The two way integration will allow the ServiceNow incident to be updated with changes to the Applied Intelligence issue. Closing a ServiceNow incident will close its corresponding New Relic issue. When a New Relic issue is resolved, the corresponding ServiceNow incident will be closed. Custom notification message Applied Intelligence uses a templating framework called Jinja2 in the customization section interface. The Value field must be in valid Jinja syntax. By default, the interface populates a set of default fields in ServiceNow. When you add a custom field, enter the ServiceNow field name you want to use. When you want to skip a selected field in an issue update, add the | skip_on_update string at the end of the value you've selected. Tip By default, ServiceNow adds u_ to the beginning of its custom values. When mapping to ServiceNow attributes, use the Column name value. Please note that the name needs to be lowercase separated by underscores. Go here to see the custom notification message attribute descriptions. Go here to see Jinja2 Useful Syntax. Other destinations You can also set PagerDuty as a destination, as well as any other destination compatible with webhook: Send data to PagerDuty Recommended: Create a new PagerDuty service to use as a destination. Because PagerDuty services can also be used as sources, this can help you distinguish your data input from your output. To create a PagerDuty destination: Go to one.newrelic.com, click Alerts & AI, in the left nav under Incident Intelligence click Destinations, then click PagerDuty. Enter your PagerDuty API key. The key should be either a personal or general access key with write access. If it's created by a user, the user should be an admin. If you've configured a PagerDuty source with an API key, you can use the same key. Select the PagerDuty services you want to connect to Applied Intelligence, and click Connect. When you're ready, you can add policies for one or more PagerDuty destinations. You can also transfer the policies over from your existing services or leave them as sources if needed. From the Destinations > PagerDuty page, you can also: Review the permissions for your services. Click Authorize when you're done. Add or delete existing services from the PagerDuty destination. Edit permissions for any service. To configure your PagerDuty destinations, use the following settings: Configuration setting Description Trigger new incidents Required. Trigger correlated parent incidents so you can identify issues faster. Edit incident titles Required. Alter your incident titles to help you orient and understand issues. Add new integrations Required. Add integrations to enable incident creation for selected services. Add webhook extensions Add webhook extensions to sync user actions in PagerDuty to New Relic. This lets you update the correlated issue state. Auto-resolve correlated incidents When enabled, this will resolve and automatically close correlated parent/child incidents. Select a user to take actions in PagerDuty You need to select a user before you can enable deep integration with PagerDuty. Once you do, the user can: Add notes to incidents (required): Incident notes are used to enrich incidents with context. Acknowledge triggered incidents: When enabled, Applied Intelligence will acknowledge and correlate newly triggered incidents in PagerDuty before you're notified. Use the original escalation policy: When enabled, the escalation policy of the source service will be applied to each incident. Send data via webhook Incident Intelligence will send the event body in JSON format by HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). To configure Incident Intelligence to send data via webhook: Go to one.newrelic.com, click Alerts & AI, in the left nav under Incident Intelligence click Destinations, then click Webhook. Required: Configure the unique webhook key, used in Applied Intelligence to refer to this webhook configuration and its specific settings. Required: Configure the destination endpoint where the webhook payload will be sent. Optional steps: Configure custom headers, which are key:value pairs of headers to be sent with the request. Example: \"Authentication\" \"Bearer\" <bearer token> Configure a custom payload template that can be used to map New Relic fields to match the destination tool's expected name and format. Configure priority mapping (critical, high, medium, or low), used to map New Relic's priorities to the priorities expected at the destination. Tip There’s a retry mechanism that is triggered a few times with exponential backoff for a couple of minutes once an error occurs. If we reach the retry limit, the Webhook will get auto-disabled. For examples of destination templates, webhook formats, and JSON schema, see the Incident Intelligence destination examples. 4. Configure pathways To control when and where you want to receive notifications from your incidents, you can configure pathways. To add a pathway: Go to one.newrelic.com, click Alerts & AI, in the left nav under Incident Intelligence click Pathways, then click Add a pathway. In the query builder box, select an attribute, such as application/name. This can be from the list of all attributes available in PagerDuty incidents and New Relic alerts violations, or you can add your own attributes. Select a logical operator. For example, contains. Enter a specific value to complete the logical expression. To include all issues created by your sources, select Send everything. (Use this if you only use one PagerDuty service to manage all incidents.) To build more complex logic, use the AND/OR operators. Select one or more of your destinations. To edit or remove existing pathways, mouse over the pathway's name on the Pathways page. What's next? Now that you've set up some sources and destinations for your incidents, read about how to use Incident Intelligence.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 279.79016,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Get started with <em>Incident</em> <em>Intelligence</em>",
        "sections": "Get started with <em>Incident</em> <em>Intelligence</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " and correlations from what you&#x27;re monitoring. To get data from <em>alerts</em>: From one.newrelic.com, click <em>Alerts</em>. On the left under <em>Incident</em> <em>Intelligence</em>, click Sources and then click <em>Alerts</em>. Select the policies you want to connect to <em>Applied</em> <em>Intelligence</em>, and click Connect. You can add additional <em>alerts</em> policies"
      },
      "id": "603ea62e64441f119f4e883f"
    }
  ],
  "/docs/alerts-applied-intelligence/applied-intelligence/incident-workflows/custom-variables-incident-workflows": [
    {
      "sections": [
        "Incident Intelligence destination examples",
        "Destination template examples",
        "Suggested OpsGenie template example",
        "Suggested ServiceNow template example",
        "Suggested Slack template example",
        "Suggested VictorOps template example",
        "Webhook and JSON format examples",
        "Webhook format and JSON example",
        "Jinja2 Default Payload",
        "Jinja2 Useful Syntax",
        "JSON schema",
        "JSON schema template"
      ],
      "title": "Incident Intelligence destination examples",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "a516d04f8b75541a6dc9338fa3ce9645ba87d620",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/incident-intelligence-destination-examples/",
      "published_at": "2021-06-02T18:22:22Z",
      "updated_at": "2021-06-02T18:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Destinations are the data outputs to Applied Intelligence, where you can view your automatically correlated incidents. You can configure Incident Intelligence destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema. Destination template examples The following template example destinations are formatted in Jinja2. Suggested OpsGenie template example { \"alias\": {{ id }}, \"message\": {{ ui_name }}, \"source\": '{{ sources }}', \"priority\": {{ priority }}, \"details\": { \"self_url\": {{ url }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"is_correlated\": {{ is_correlated }} }, \"description\": \"\"\"Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]\"\"\" } Copy Suggested ServiceNow template example { \"short_description\": {{ ui_name }}, \"description\": 'Issue Id: {{ id }}, \\n Description: {{ description }}, \\n Sources: {{ sources }}, \\n Priority: {{ priority }}, \\n Details: { \\n self_url: {{ url }}, \\n state: {{ state }}, \\n is_correlated: {{ is_correlated }}, \\n created_on: {{ created_on }}, \\n modified_on: {{ modified_on }}, \\n activated_on: {{ active_since }}, \\n closed_on: {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \\n is_correlated: {{is_correlated}} }, \\n\\n incidents: {{ incidents }}, \\n\\n pathways: {{ pathways }}' } Copy Suggested Slack template example Go to Slack incoming WebHooks Choose the right Slack workspace and click \"Add to Slack\" Select the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In New Relic Applied Intelligence, under Incident Intelligence click Destinations Add a WebHook In the end point paste the WebHook url from slack. In the custom payload, paste the following JSON: { \"blocks\": [ { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*New Relic Incident Intelligence Alert*\" } }, { \"type\": \"divider\" }, { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*CUSTOM FIELDS*:\" }, \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue ID*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Issue Title*\" }, { \"type\": \"plain_text\", \"text\": {{ id }} }, { \"type\": \"plain_text\", \"text\": {{ ui_name }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue URL*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Description*\" }, { \"type\": \"mrkdwn\", \"text\": {{ url }} }, { \"type\": \"plain_text\", \"text\": {{ description }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*State*\" }, { \"type\": \"mrkdwn\", \"text\": \"*is_correlated*\" }, { \"type\": \"plain_text\", \"text\": {{ state }} }, { \"type\": \"plain_text\", \"text\": \"{{ is_correlated }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Created On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Modified On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ created_on }}\" }, { \"type\": \"plain_text\", \"text\": \"{{ modified_on }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Activated On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Closed On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ active_since }}\" }, { \"type\": \"plain_text\", \"text\": \"{% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Aggregated Incidents*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Monitoring Tool*\" }, { \"type\": \"plain_text\", \"text\": \"{{ incident_count }}\" }, { \"type\": \"plain_text\", \"text\": {{ sources|join(', ') }} } ] } ] } Copy Suggested VictorOps template example { \"monitoring_tool\": {{ sources }}, {% if state == 'closed' %} \"message_type\": \"OK\", {% else %} \"message_type\": {{ priority }}, {% endif %} \"custom_fields\": { \"issue_url\": {{ url }}, \"description\": {{ description }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"related_incidents\": [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %} {% endfor %} ] }, \"state_message\": {{ description }}, \"entity_id\": {{ id }}, \"entity_display_name\": {{ ui_name }}, \"vo_annotate.u.NRAI_Link\": {{ url }} } Copy Webhook and JSON format examples Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). If you use webhooks to configure Incident Intelligence destinations, use these examples of the webhook body format and JSON schema. Webhook format and JSON example Webhook format: Name Description url Href A link to the UI where the issue can be seen. id String Unique identifier for the issue. title String The issue title. description String The description of the issue. priority Enum The issue priority. Can be Critical, High, Medium, or Low. state Enum The issue status. Can be Active, Closed, or Acknowledged. is_correlated Boolean True if the issue is based on correlated data. created_on String The date and time the issue was created (in ISO format). modified_on String The date and time the issue was modified (in ISO format). active_since String The date and time the issue was activated (in ISO format). closed_on String The date and time the issue was closed (in ISO format). sources List(String) List of the different sources that were used to send the events into Applied Intelligence (for example: PagerDuty). pathways List(Pathways) List of pathways that are associated with the issue. Each pathway contains an id and name: [{“id”: “pathway id”, “name”: “pathway name”}]. pathways[].id String The pathway ID. pathways[].name String The pathway name. incidents List(Incident) List of incidents that are attached to the issue. The list contains only the latest 100 incidents. incidents[].id String The incident ID. incidents[].events_count Integer The number of events used to create the incident. incidents[].title String The incident title. incidents[].description String The incident description. incidents[].labels Dictionary (String) A string to string mapping of the incident labels. Labels represent the unique entities that are used to describe the incident. incidents[].priority Enum The incident priority. Can be Critical, High, Medium, or Low. incidents[].sources List(String) The incident source. incidents[].state Enum(open, closed) The incident state. incidents[].opened_on String The date and time the incident was opened (in ISO format). incidents[].closed_on String The date and time the incident was closed (in ISO format). ui_name String Issue title. accumulations['alert/signal'] String Issue analysis summary golden signal/s (if applicable). accumulations['alert/components'] String Issue analysis summary golden components (if applicable). Jinja2 Default Payload Applied Intelligence uses a templating framework called Jinja2 in the Webhook interface. Here is a default Jinja2 payload to use: { \"id\": {{ id }}, \"url\": {{ url }}, \"ui_name\": {{ ui_name }}, \"description\": {{ description }}, \"priority\": {{ priority }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"active_since\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"sources\": {{ sources }}, \"incidents\": {{ incidents }}, \"pathways\": {{ pathways }}, } Copy Jinja2 Useful Syntax Below are a few useful Jinja2 commands to help you format your output. Casting a value to integer Example: “severity”: {{ priority | int }} Copy If clause to check if an attribute’s value is set Example: \"golden_signals\": {% if accumulations['alert/signal'] is defined %} {{ accumulations['alert/signal'] }} {% else %} None {% endif %} Copy For loop to iterate of an array of values: Example: \"description\": 'Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]' Copy Check if an array attribute's value is set: Example: \"hostname_field\": {% if incidents[0].labels['newrelic/tag/hostname'] is defined %} {{ incidents[0].labels['newrelic/tag/hostname'] }} {% else %} None {% endif %} Copy JSON schema Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). JSON schema template JSON schema: { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"definitions\": { \"Labels\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"LabelsSet\": { \"type\": \"array\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"$ref\": \"#/definitions/Labels\" }, \"uniqueItems\": true }, }, \"Annotations\": { \"type\": \"object\", \"title\": \"Additional contextual information about the Entity\", \"description\": \"Fields like title, description and priority can be described as annotations since\\nthey represent some additional information about the Incident.\\nFor example, the rule that creates the entity can have some logic that will create a title annotation field.\\nThe title will change according to the latest event received by the entity and as more\\nevent will keep coming the field may change, all this as a decision by the rule.\\nA different rule may decide not to populate the title at all.\\nSince a title can also be produced from the labels themselves.\", \"properties\": { \"title\": { \"type\": \"string\", \"maxLength\": 10000 }, \"description\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"patternProperties\": { \".*\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"Accumulations\": { \"type\": \"object\", \"title\": \"Accumulated data about the Incident\", \"description\": \"For example an entity with the label: host_name: foo will include a accumulated list of the\\nrelevant process names that are relevant to the entity. Accumulations will be derived from the events\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"type\": \"string\", \"maxLength\": 10000 } } }, \"IssueState\": { \"type\": \"string\", \"enum\": [ \"created\", \"active\", \"acknowledged\", \"closed\" ], \"properties\": {}, \"additionalProperties\": false }, \"Priority\": { \"type\": \"string\", \"enum\": [ \"critical\", \"high\", \"medium\", \"low\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueClosingReason\": { \"type\": \"string\", \"enum\": [ \"nacked\", \"resolved\", \"system\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueAction\": { \"type\": \"string\", \"enum\": [ \"ack\", \"snooze\", \"nack\", \"end_snooze\", \"expire_snooze\", \"star\", \"un_snooze\", \"unstar\", \"archive\", \"unarchive\", \"resolve\", \"reopen\", \"open\", \"feedback\", \"feedback_file\", \"open_ticket\", \"merge_issues\", \"active\", \"create\", \"close\", \"incident_updated\", \"confidence_changed\", \"diagnoses_changed\", \"rule_properties_changed\", \"flapping\", \"notification\", \"incident_events_limit_reached\", \"follow\", \"unfollow\", \"priority_updated\", \"comment\", \"incident_appended\", \"diagnosis_feedback\", \"flapping_delay_close\" ], \"properties\": {}, \"additionalProperties\": false }, \"StringKeyValue\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\" } }, \"JavaOptionalUuid\": { \"type\": \"string\", \"properties\": {}, \"additionalProperties\": false, \"format\": \"string-uuid\" } }, \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"customer_id\": { \"type\": \"integer\" }, \"labels_set\": { \"$ref\": \"#/definitions/LabelsSet\" }, \"annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations_version\": { \"type\": \"integer\" }, \"accumulations\": { \"$ref\": \"#/definitions/Accumulations\" }, \"state\": { \"$ref\": \"#/definitions/IssueState\" }, \"previous_state\": { \"$ref\": \"#/definitions/IssueState\" }, \"priority\": { \"$ref\": \"#/definitions/Priority\" }, \"closing_reason\": { \"oneOf\": [ { \"$ref\": \"#/definitions/IssueClosingReason\" }, { \"type\": \"null\" } ] }, \"modified_on\": { \"type\": \"integer\" }, \"created_on\": { \"type\": \"integer\" }, \"closed_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"acknowledged_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"active_since\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"assigned_to\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"created_by\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"progress_report\": { \"type\": \"array\", \"default\": [], \"items\": { \"type\": \"object\", \"properties\": { \"origin_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1 }, { \"type\": \"null\" } ] }, \"timestamp\": { \"type\": \"integer\" }, \"action_timestamp\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"origin_type\": { \"type\": \"string\", \"enum\": [ \"user\", \"system\" ] }, \"event_type\": { \"$ref\": \"#/definitions/IssueAction\" }, \"issue_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"format\": \"string-uuid\" }, { \"type\": \"null\" } ] }, \"attributes\": { \"oneOf\": [ { \"$ref\": \"#/definitions/StringKeyValue\" }, { \"type\": \"null\" } ] }, \"team_id\": { \"$ref\": \"#/definitions/JavaOptionalUuid\" } }, \"required\": [ \"timestamp\", \"origin_type\", \"event_type\" ], \"additionalProperties\": false }, \"uniqueItems\": true }, \"rule_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"maxLength\": 255 }, { \"type\": \"null\" } ] }, \"incident_ids\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"confidence\": { \"type\": \"number\", \"default\": 1.0, \"minimum\": 0.0, \"maximum\": 1.0 } }, \"required\": [ \"id\", \"customer_id\", \"labels_set\", \"annotations\", \"priority\", \"modified_on\", \"created_on\", \"confidence\" ], \"additionalProperties\": true } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 332.55884,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Incident</em> <em>Intelligence</em> destination examples",
        "sections": "<em>Incident</em> <em>Intelligence</em> destination examples",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "Destinations are the data outputs to <em>Applied</em> <em>Intelligence</em>, where you can view your automatically correlated incidents. You can configure <em>Incident</em> <em>Intelligence</em> destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema"
      },
      "id": "6044280d64441f4af5378ed3"
    },
    {
      "sections": [
        "Expanded anomaly detection",
        "Requirements",
        "Why it matters",
        "Get started with anomaly detection",
        "Detect anomalies with a faceted NRQL query",
        "See your anomalies in one place",
        "Tip",
        "Query anomaly data",
        "Reduce the number of detected anomalies"
      ],
      "title": "Expanded anomaly detection",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Proactive detection"
      ],
      "external_id": "0b07c0b6ce27f39b5edb3e112a0f949835cbb8c6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/proactive-detection/expanded-anomaly-detection/",
      "published_at": "2021-06-02T18:27:12Z",
      "updated_at": "2021-05-31T16:43:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We’ve expanded anomaly detection coverage beyond your APM applications. Configure anomaly detection for your browser applications, mobile applications, infrastructure hosts, and nearly anything you want to monitor. Requirements Expanded anomaly detection is available as a limited beta. You can request access here. Why it matters When starting to configure alert conditions for a variety of applications and hosts, it can be difficult to know what you’ll want to be notified about ahead of time. Anomaly detection helps you distinguish between what’s typical performance in your system and where you’re starting to have trouble. Instead of creating your alert conditions manually, you can simply tell us what you want to monitor. Anomaly detection will help you identify baseline performance in your system and flags anomalous activity in your system. Get started with anomaly detection To get started with expanded anomaly detection: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Select the account you want to use to record anomaly data, then select the workload or entities you’d like to monitor. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name your configuration and save. Detect anomalies with a faceted NRQL query To detect anomalies with a faceted NRQL query: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Click Use a query instead. You may need to select an account, if you have more than one. Add one or more queries with a FACET clause. Name the query and confirm the facets you want to monitor for anomalies. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name the configuration and save. See your anomalies in one place When you set up anomaly detection, New Relic starts analyzing the golden signals of your entities and workloads. Anomalies appear in your activity feeds throughout New Relic One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL alert condition for the NrAiAnomaly event. To view anomalies, from one.newrelic.com, go to Alerts & AI > Issues & activity > Anomalies. Query anomaly data Detected anomalies are written to the NrAiAnomaly event in your NRDB account. You can learn more about this event and how to query it here. Reduce the number of detected anomalies If you’re seeing too many anomalies, the first step is to make sure your sensitivity level is set to Low. If it’s already set to Low, you can define specific thresholds to distinguish between normal and anomalous behavior. To define custom thresholds: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab and the configuration you want to modify. Select an entity or workload, and then change the sensitivity level. You can use custom sensitivity to define specific thresholds for different entity types.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 290.33484,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " request access here. Why it matters When starting to configure <em>alert</em> conditions for a variety of applications and hosts, it can be difficult to know what you’ll want to be notified about ahead of time. Anomaly detection helps you distinguish between what’s typical performance in your system and where"
      },
      "id": "60b5124064441ff965e2cb01"
    },
    {
      "sections": [
        "Use Incident Intelligence",
        "Issue summary",
        "Impacted entities map",
        "Use suggested responders",
        "Important",
        "Tip",
        "Root cause analysis",
        "Issue timeline",
        "Related activity",
        "Use decisions"
      ],
      "title": "Use Incident Intelligence",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "f7b852fa406a6e9ff88b791e4cbccc2bd20a5962",
      "image": "https://docs.newrelic.com/static/6e37cc77304398121e1a0080a57e47bb/8c557/screenshot_incident_intelligence_timeline_event_detail.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/use-incident-intelligence/",
      "published_at": "2021-06-02T18:23:21Z",
      "updated_at": "2021-05-28T11:09:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you set up Incident Intelligence, our system will begin finding issues from your data sources. In the issue feed, you can find an overview of all your issues, along with helpful information about them. You can also click any individual issue for more detail, including its analysis summary, event log, and details about correlated issues. This screenshot shows an example issue feed, which describes your issues' statuses, correlations, and more. What's the difference between an issue, incident, and event? In short, these terms are like building blocks. Events are raw data from your sources. Incidents are made up of one or more events. Issues are composed of one or more incidents. In more detail: Events indicate a state change or trigger defined by your monitoring systems. An event contains information about the affected entity, and they are almost always triggered automatically by the system. Incidents are groups of events that describe the \"symptoms\" of your system over time. These symptoms are detected by your monitoring tools, which evaluate your data streams and events. Issues are groups of incidents that describe the underlying problem of your symptoms. When a new incident is created, Incident Intelligence opens an issue and evaluates other open issues for correlations. Issue summary The Issue page is built to provide you with bottom line insights first to understand the problem, and then to minimize the time you need to resolve it. The Issue page includes the following sections: Issue summary: This section has two machine learning modules, the golden signals and the related components. Suggested responders: This section will tell you who to potentially reach out to on your team to solve a specific problem. Label sets: Label sets are focused on incidents that come from 3rd party sources, such as PagerDuty, AWS Cloudwatch, REST APIs, etc., as well as for NRQL queries. They come in the form of key:value pairs. Impacted entities: An entity is anything that has data you can monitor. Specifically, these are focused on incidents from New Relic sources, extracting the entities and providing a summary. Each entity is unique. You can see your entities in a list or on a map. Depending on the data in an issue, all four of these sections can show up together for each issue or separately. If you hover over an impacted entity application, you’ll notice a few calls to action: relevant dashboards, anomaly overview, deployment events, and entity overview. Relevant dashboards helps users in your account look at and interact with dashboards you've created that are related to an entity. The queries you've run to power the various widgets are automatically mapped to entities whenever possible and are presented back to you here for quick access and discovery. Anomaly overview will open the application's anomalies page. This is only available for applications that are set up for Proactive Detection. There are two types of deployment events: deployments and related deployments. Click Show all deployments to see all your deployment events when they arrive, or click a specific deployment to see its APM deployments page. The APM deployment page lists recent deployments and their impact on your end user and app server's Apdex scores, response times, throughput, and errors. This section will only show up if New Relic has identified applications under the impacted entities that have deployments. Impacted entities map Hover over an entity to see more information about it. An impacted entities map is available for any issue involving two or more entities. The map shows not only the affected entities, but also the services and resources directly related to those entities. Use suggested responders If you’re using PagerDuty or New Relic alerts violations as your incident notification tools, Incident Intelligence suggests relevant team members that can help resolve your issues. Incident Intelligence learns from your PagerDuty and alerts violations data to provide suggestions for each new incident. Once you receive a suggestion, you can contact the responder or search for relevant documentation that person may have written. To get started, enable PagerDuty or alerts violations as a source for Incident Intelligence. Afterwards, you can view the suggestions in two places: The issue feed, where you can also provide feedback on the suggestions. Directly within PagerDuty (both UI and API.) If you’re also using PagerDuty as a destination, the suggestions will appear in your issue notifications payload. Important This feature doesn't account for on-call availability at the time of incident. Tip In order to train the model, we use the information PagerDuty provides about individuals. We ingest incident information only, not users’ contact details. Root cause analysis Root cause analysis automatically finds potential causes for an issue and its impacted entities. It shows you why open issues occurred, which deployments contributed, and relevant error logs and attributes. With this, you can investigate the problem and reduce your mean time to resolution (MTTR). Tip Note that root cause analysis is dependent on other New Relic data sources and features. This is why root cause analysis information may not always be present for every issue. When you select an issue, you may see Root cause analysis information. Root cause analysis includes three main UI sections: Deployment events: When you set up deployments, we provide the deployment nearest to the issue creation. Changes, such as deployments, account for a high percentage of the root causes of incidents and having that information at hand can help diagnose and resolve issues. Error logs: You can explore millions of log messages with a single click and use manual querying to help you find anomalous patterns and hard-to-find problems. Attributes to investigate: We scan the distribution of attributes and surface possible causes by finding significant changes in the distribution. This section also shows changes in database and external metrics. You can also query interesting attributes. Issue timeline The issue timeline, as presented below, shows you a breakdown of: Incidents The trends taking place What incidents are active What incidents are resolved What is correlated to each other Various milestones at different issue levels In addition, you’ll see a grey line at the top of the timeline. In comparison to the visual timeline that shows the changes to each incident, the grey line represents changes to the issue. Mouse over the grey line to see details of the event. Finally, mouse over the incident to see information on the location, timing, and level of importance of a specific incident. This figure shows a particular incident populated on January 11th with a level of Critical. To view the issues in a text format, in the right hand corner, click Switch to issue log view. Related activity The issue page includes a Related activity section, which is a table displaying activity related to the incident or anomally you are are trying to analyze. You can click each line item in the table to view a unique dashboard that displays data for the entity the incident or anomally came from. The related activity section aggregates a set of incidents into a single issue, according to a rule-based system. Use decisions To further reduce noise or get improved incident correlation, you can change or customize your decisions. Decisions determine how Incident Intelligence groups incidents together. To get started, see Decisions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 251.51917,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use <em>Incident</em> <em>Intelligence</em>",
        "sections": "Use <em>Incident</em> <em>Intelligence</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": ". The map shows not only the affected entities, but also the services and resources directly related to those entities. Use suggested responders If you’re using PagerDuty or New Relic <em>alerts</em> violations as your <em>incident</em> notification tools, <em>Incident</em> <em>Intelligence</em> suggests relevant team members that can"
      },
      "id": "6080293564441fd0669d8580"
    }
  ],
  "/docs/alerts-applied-intelligence/applied-intelligence/incident-workflows/incident-workflows": [
    {
      "sections": [
        "Incident Intelligence destination examples",
        "Destination template examples",
        "Suggested OpsGenie template example",
        "Suggested ServiceNow template example",
        "Suggested Slack template example",
        "Suggested VictorOps template example",
        "Webhook and JSON format examples",
        "Webhook format and JSON example",
        "Jinja2 Default Payload",
        "Jinja2 Useful Syntax",
        "JSON schema",
        "JSON schema template"
      ],
      "title": "Incident Intelligence destination examples",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "a516d04f8b75541a6dc9338fa3ce9645ba87d620",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/incident-intelligence-destination-examples/",
      "published_at": "2021-06-02T18:22:22Z",
      "updated_at": "2021-06-02T18:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Destinations are the data outputs to Applied Intelligence, where you can view your automatically correlated incidents. You can configure Incident Intelligence destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema. Destination template examples The following template example destinations are formatted in Jinja2. Suggested OpsGenie template example { \"alias\": {{ id }}, \"message\": {{ ui_name }}, \"source\": '{{ sources }}', \"priority\": {{ priority }}, \"details\": { \"self_url\": {{ url }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"is_correlated\": {{ is_correlated }} }, \"description\": \"\"\"Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]\"\"\" } Copy Suggested ServiceNow template example { \"short_description\": {{ ui_name }}, \"description\": 'Issue Id: {{ id }}, \\n Description: {{ description }}, \\n Sources: {{ sources }}, \\n Priority: {{ priority }}, \\n Details: { \\n self_url: {{ url }}, \\n state: {{ state }}, \\n is_correlated: {{ is_correlated }}, \\n created_on: {{ created_on }}, \\n modified_on: {{ modified_on }}, \\n activated_on: {{ active_since }}, \\n closed_on: {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \\n is_correlated: {{is_correlated}} }, \\n\\n incidents: {{ incidents }}, \\n\\n pathways: {{ pathways }}' } Copy Suggested Slack template example Go to Slack incoming WebHooks Choose the right Slack workspace and click \"Add to Slack\" Select the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In New Relic Applied Intelligence, under Incident Intelligence click Destinations Add a WebHook In the end point paste the WebHook url from slack. In the custom payload, paste the following JSON: { \"blocks\": [ { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*New Relic Incident Intelligence Alert*\" } }, { \"type\": \"divider\" }, { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*CUSTOM FIELDS*:\" }, \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue ID*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Issue Title*\" }, { \"type\": \"plain_text\", \"text\": {{ id }} }, { \"type\": \"plain_text\", \"text\": {{ ui_name }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue URL*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Description*\" }, { \"type\": \"mrkdwn\", \"text\": {{ url }} }, { \"type\": \"plain_text\", \"text\": {{ description }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*State*\" }, { \"type\": \"mrkdwn\", \"text\": \"*is_correlated*\" }, { \"type\": \"plain_text\", \"text\": {{ state }} }, { \"type\": \"plain_text\", \"text\": \"{{ is_correlated }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Created On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Modified On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ created_on }}\" }, { \"type\": \"plain_text\", \"text\": \"{{ modified_on }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Activated On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Closed On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ active_since }}\" }, { \"type\": \"plain_text\", \"text\": \"{% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Aggregated Incidents*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Monitoring Tool*\" }, { \"type\": \"plain_text\", \"text\": \"{{ incident_count }}\" }, { \"type\": \"plain_text\", \"text\": {{ sources|join(', ') }} } ] } ] } Copy Suggested VictorOps template example { \"monitoring_tool\": {{ sources }}, {% if state == 'closed' %} \"message_type\": \"OK\", {% else %} \"message_type\": {{ priority }}, {% endif %} \"custom_fields\": { \"issue_url\": {{ url }}, \"description\": {{ description }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"related_incidents\": [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %} {% endfor %} ] }, \"state_message\": {{ description }}, \"entity_id\": {{ id }}, \"entity_display_name\": {{ ui_name }}, \"vo_annotate.u.NRAI_Link\": {{ url }} } Copy Webhook and JSON format examples Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). If you use webhooks to configure Incident Intelligence destinations, use these examples of the webhook body format and JSON schema. Webhook format and JSON example Webhook format: Name Description url Href A link to the UI where the issue can be seen. id String Unique identifier for the issue. title String The issue title. description String The description of the issue. priority Enum The issue priority. Can be Critical, High, Medium, or Low. state Enum The issue status. Can be Active, Closed, or Acknowledged. is_correlated Boolean True if the issue is based on correlated data. created_on String The date and time the issue was created (in ISO format). modified_on String The date and time the issue was modified (in ISO format). active_since String The date and time the issue was activated (in ISO format). closed_on String The date and time the issue was closed (in ISO format). sources List(String) List of the different sources that were used to send the events into Applied Intelligence (for example: PagerDuty). pathways List(Pathways) List of pathways that are associated with the issue. Each pathway contains an id and name: [{“id”: “pathway id”, “name”: “pathway name”}]. pathways[].id String The pathway ID. pathways[].name String The pathway name. incidents List(Incident) List of incidents that are attached to the issue. The list contains only the latest 100 incidents. incidents[].id String The incident ID. incidents[].events_count Integer The number of events used to create the incident. incidents[].title String The incident title. incidents[].description String The incident description. incidents[].labels Dictionary (String) A string to string mapping of the incident labels. Labels represent the unique entities that are used to describe the incident. incidents[].priority Enum The incident priority. Can be Critical, High, Medium, or Low. incidents[].sources List(String) The incident source. incidents[].state Enum(open, closed) The incident state. incidents[].opened_on String The date and time the incident was opened (in ISO format). incidents[].closed_on String The date and time the incident was closed (in ISO format). ui_name String Issue title. accumulations['alert/signal'] String Issue analysis summary golden signal/s (if applicable). accumulations['alert/components'] String Issue analysis summary golden components (if applicable). Jinja2 Default Payload Applied Intelligence uses a templating framework called Jinja2 in the Webhook interface. Here is a default Jinja2 payload to use: { \"id\": {{ id }}, \"url\": {{ url }}, \"ui_name\": {{ ui_name }}, \"description\": {{ description }}, \"priority\": {{ priority }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"active_since\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"sources\": {{ sources }}, \"incidents\": {{ incidents }}, \"pathways\": {{ pathways }}, } Copy Jinja2 Useful Syntax Below are a few useful Jinja2 commands to help you format your output. Casting a value to integer Example: “severity”: {{ priority | int }} Copy If clause to check if an attribute’s value is set Example: \"golden_signals\": {% if accumulations['alert/signal'] is defined %} {{ accumulations['alert/signal'] }} {% else %} None {% endif %} Copy For loop to iterate of an array of values: Example: \"description\": 'Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]' Copy Check if an array attribute's value is set: Example: \"hostname_field\": {% if incidents[0].labels['newrelic/tag/hostname'] is defined %} {{ incidents[0].labels['newrelic/tag/hostname'] }} {% else %} None {% endif %} Copy JSON schema Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). JSON schema template JSON schema: { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"definitions\": { \"Labels\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"LabelsSet\": { \"type\": \"array\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"$ref\": \"#/definitions/Labels\" }, \"uniqueItems\": true }, }, \"Annotations\": { \"type\": \"object\", \"title\": \"Additional contextual information about the Entity\", \"description\": \"Fields like title, description and priority can be described as annotations since\\nthey represent some additional information about the Incident.\\nFor example, the rule that creates the entity can have some logic that will create a title annotation field.\\nThe title will change according to the latest event received by the entity and as more\\nevent will keep coming the field may change, all this as a decision by the rule.\\nA different rule may decide not to populate the title at all.\\nSince a title can also be produced from the labels themselves.\", \"properties\": { \"title\": { \"type\": \"string\", \"maxLength\": 10000 }, \"description\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"patternProperties\": { \".*\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"Accumulations\": { \"type\": \"object\", \"title\": \"Accumulated data about the Incident\", \"description\": \"For example an entity with the label: host_name: foo will include a accumulated list of the\\nrelevant process names that are relevant to the entity. Accumulations will be derived from the events\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"type\": \"string\", \"maxLength\": 10000 } } }, \"IssueState\": { \"type\": \"string\", \"enum\": [ \"created\", \"active\", \"acknowledged\", \"closed\" ], \"properties\": {}, \"additionalProperties\": false }, \"Priority\": { \"type\": \"string\", \"enum\": [ \"critical\", \"high\", \"medium\", \"low\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueClosingReason\": { \"type\": \"string\", \"enum\": [ \"nacked\", \"resolved\", \"system\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueAction\": { \"type\": \"string\", \"enum\": [ \"ack\", \"snooze\", \"nack\", \"end_snooze\", \"expire_snooze\", \"star\", \"un_snooze\", \"unstar\", \"archive\", \"unarchive\", \"resolve\", \"reopen\", \"open\", \"feedback\", \"feedback_file\", \"open_ticket\", \"merge_issues\", \"active\", \"create\", \"close\", \"incident_updated\", \"confidence_changed\", \"diagnoses_changed\", \"rule_properties_changed\", \"flapping\", \"notification\", \"incident_events_limit_reached\", \"follow\", \"unfollow\", \"priority_updated\", \"comment\", \"incident_appended\", \"diagnosis_feedback\", \"flapping_delay_close\" ], \"properties\": {}, \"additionalProperties\": false }, \"StringKeyValue\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\" } }, \"JavaOptionalUuid\": { \"type\": \"string\", \"properties\": {}, \"additionalProperties\": false, \"format\": \"string-uuid\" } }, \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"customer_id\": { \"type\": \"integer\" }, \"labels_set\": { \"$ref\": \"#/definitions/LabelsSet\" }, \"annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations_version\": { \"type\": \"integer\" }, \"accumulations\": { \"$ref\": \"#/definitions/Accumulations\" }, \"state\": { \"$ref\": \"#/definitions/IssueState\" }, \"previous_state\": { \"$ref\": \"#/definitions/IssueState\" }, \"priority\": { \"$ref\": \"#/definitions/Priority\" }, \"closing_reason\": { \"oneOf\": [ { \"$ref\": \"#/definitions/IssueClosingReason\" }, { \"type\": \"null\" } ] }, \"modified_on\": { \"type\": \"integer\" }, \"created_on\": { \"type\": \"integer\" }, \"closed_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"acknowledged_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"active_since\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"assigned_to\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"created_by\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"progress_report\": { \"type\": \"array\", \"default\": [], \"items\": { \"type\": \"object\", \"properties\": { \"origin_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1 }, { \"type\": \"null\" } ] }, \"timestamp\": { \"type\": \"integer\" }, \"action_timestamp\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"origin_type\": { \"type\": \"string\", \"enum\": [ \"user\", \"system\" ] }, \"event_type\": { \"$ref\": \"#/definitions/IssueAction\" }, \"issue_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"format\": \"string-uuid\" }, { \"type\": \"null\" } ] }, \"attributes\": { \"oneOf\": [ { \"$ref\": \"#/definitions/StringKeyValue\" }, { \"type\": \"null\" } ] }, \"team_id\": { \"$ref\": \"#/definitions/JavaOptionalUuid\" } }, \"required\": [ \"timestamp\", \"origin_type\", \"event_type\" ], \"additionalProperties\": false }, \"uniqueItems\": true }, \"rule_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"maxLength\": 255 }, { \"type\": \"null\" } ] }, \"incident_ids\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"confidence\": { \"type\": \"number\", \"default\": 1.0, \"minimum\": 0.0, \"maximum\": 1.0 } }, \"required\": [ \"id\", \"customer_id\", \"labels_set\", \"annotations\", \"priority\", \"modified_on\", \"created_on\", \"confidence\" ], \"additionalProperties\": true } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 332.55884,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Incident</em> <em>Intelligence</em> destination examples",
        "sections": "<em>Incident</em> <em>Intelligence</em> destination examples",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "Destinations are the data outputs to <em>Applied</em> <em>Intelligence</em>, where you can view your automatically correlated incidents. You can configure <em>Incident</em> <em>Intelligence</em> destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema"
      },
      "id": "6044280d64441f4af5378ed3"
    },
    {
      "sections": [
        "Expanded anomaly detection",
        "Requirements",
        "Why it matters",
        "Get started with anomaly detection",
        "Detect anomalies with a faceted NRQL query",
        "See your anomalies in one place",
        "Tip",
        "Query anomaly data",
        "Reduce the number of detected anomalies"
      ],
      "title": "Expanded anomaly detection",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Proactive detection"
      ],
      "external_id": "0b07c0b6ce27f39b5edb3e112a0f949835cbb8c6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/proactive-detection/expanded-anomaly-detection/",
      "published_at": "2021-06-02T18:27:12Z",
      "updated_at": "2021-05-31T16:43:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We’ve expanded anomaly detection coverage beyond your APM applications. Configure anomaly detection for your browser applications, mobile applications, infrastructure hosts, and nearly anything you want to monitor. Requirements Expanded anomaly detection is available as a limited beta. You can request access here. Why it matters When starting to configure alert conditions for a variety of applications and hosts, it can be difficult to know what you’ll want to be notified about ahead of time. Anomaly detection helps you distinguish between what’s typical performance in your system and where you’re starting to have trouble. Instead of creating your alert conditions manually, you can simply tell us what you want to monitor. Anomaly detection will help you identify baseline performance in your system and flags anomalous activity in your system. Get started with anomaly detection To get started with expanded anomaly detection: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Select the account you want to use to record anomaly data, then select the workload or entities you’d like to monitor. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name your configuration and save. Detect anomalies with a faceted NRQL query To detect anomalies with a faceted NRQL query: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Click Use a query instead. You may need to select an account, if you have more than one. Add one or more queries with a FACET clause. Name the query and confirm the facets you want to monitor for anomalies. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name the configuration and save. See your anomalies in one place When you set up anomaly detection, New Relic starts analyzing the golden signals of your entities and workloads. Anomalies appear in your activity feeds throughout New Relic One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL alert condition for the NrAiAnomaly event. To view anomalies, from one.newrelic.com, go to Alerts & AI > Issues & activity > Anomalies. Query anomaly data Detected anomalies are written to the NrAiAnomaly event in your NRDB account. You can learn more about this event and how to query it here. Reduce the number of detected anomalies If you’re seeing too many anomalies, the first step is to make sure your sensitivity level is set to Low. If it’s already set to Low, you can define specific thresholds to distinguish between normal and anomalous behavior. To define custom thresholds: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab and the configuration you want to modify. Select an entity or workload, and then change the sensitivity level. You can use custom sensitivity to define specific thresholds for different entity types.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 290.33484,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " request access here. Why it matters When starting to configure <em>alert</em> conditions for a variety of applications and hosts, it can be difficult to know what you’ll want to be notified about ahead of time. Anomaly detection helps you distinguish between what’s typical performance in your system and where"
      },
      "id": "60b5124064441ff965e2cb01"
    },
    {
      "sections": [
        "Use Incident Intelligence",
        "Issue summary",
        "Impacted entities map",
        "Use suggested responders",
        "Important",
        "Tip",
        "Root cause analysis",
        "Issue timeline",
        "Related activity",
        "Use decisions"
      ],
      "title": "Use Incident Intelligence",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "f7b852fa406a6e9ff88b791e4cbccc2bd20a5962",
      "image": "https://docs.newrelic.com/static/6e37cc77304398121e1a0080a57e47bb/8c557/screenshot_incident_intelligence_timeline_event_detail.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/use-incident-intelligence/",
      "published_at": "2021-06-02T18:23:21Z",
      "updated_at": "2021-05-28T11:09:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you set up Incident Intelligence, our system will begin finding issues from your data sources. In the issue feed, you can find an overview of all your issues, along with helpful information about them. You can also click any individual issue for more detail, including its analysis summary, event log, and details about correlated issues. This screenshot shows an example issue feed, which describes your issues' statuses, correlations, and more. What's the difference between an issue, incident, and event? In short, these terms are like building blocks. Events are raw data from your sources. Incidents are made up of one or more events. Issues are composed of one or more incidents. In more detail: Events indicate a state change or trigger defined by your monitoring systems. An event contains information about the affected entity, and they are almost always triggered automatically by the system. Incidents are groups of events that describe the \"symptoms\" of your system over time. These symptoms are detected by your monitoring tools, which evaluate your data streams and events. Issues are groups of incidents that describe the underlying problem of your symptoms. When a new incident is created, Incident Intelligence opens an issue and evaluates other open issues for correlations. Issue summary The Issue page is built to provide you with bottom line insights first to understand the problem, and then to minimize the time you need to resolve it. The Issue page includes the following sections: Issue summary: This section has two machine learning modules, the golden signals and the related components. Suggested responders: This section will tell you who to potentially reach out to on your team to solve a specific problem. Label sets: Label sets are focused on incidents that come from 3rd party sources, such as PagerDuty, AWS Cloudwatch, REST APIs, etc., as well as for NRQL queries. They come in the form of key:value pairs. Impacted entities: An entity is anything that has data you can monitor. Specifically, these are focused on incidents from New Relic sources, extracting the entities and providing a summary. Each entity is unique. You can see your entities in a list or on a map. Depending on the data in an issue, all four of these sections can show up together for each issue or separately. If you hover over an impacted entity application, you’ll notice a few calls to action: relevant dashboards, anomaly overview, deployment events, and entity overview. Relevant dashboards helps users in your account look at and interact with dashboards you've created that are related to an entity. The queries you've run to power the various widgets are automatically mapped to entities whenever possible and are presented back to you here for quick access and discovery. Anomaly overview will open the application's anomalies page. This is only available for applications that are set up for Proactive Detection. There are two types of deployment events: deployments and related deployments. Click Show all deployments to see all your deployment events when they arrive, or click a specific deployment to see its APM deployments page. The APM deployment page lists recent deployments and their impact on your end user and app server's Apdex scores, response times, throughput, and errors. This section will only show up if New Relic has identified applications under the impacted entities that have deployments. Impacted entities map Hover over an entity to see more information about it. An impacted entities map is available for any issue involving two or more entities. The map shows not only the affected entities, but also the services and resources directly related to those entities. Use suggested responders If you’re using PagerDuty or New Relic alerts violations as your incident notification tools, Incident Intelligence suggests relevant team members that can help resolve your issues. Incident Intelligence learns from your PagerDuty and alerts violations data to provide suggestions for each new incident. Once you receive a suggestion, you can contact the responder or search for relevant documentation that person may have written. To get started, enable PagerDuty or alerts violations as a source for Incident Intelligence. Afterwards, you can view the suggestions in two places: The issue feed, where you can also provide feedback on the suggestions. Directly within PagerDuty (both UI and API.) If you’re also using PagerDuty as a destination, the suggestions will appear in your issue notifications payload. Important This feature doesn't account for on-call availability at the time of incident. Tip In order to train the model, we use the information PagerDuty provides about individuals. We ingest incident information only, not users’ contact details. Root cause analysis Root cause analysis automatically finds potential causes for an issue and its impacted entities. It shows you why open issues occurred, which deployments contributed, and relevant error logs and attributes. With this, you can investigate the problem and reduce your mean time to resolution (MTTR). Tip Note that root cause analysis is dependent on other New Relic data sources and features. This is why root cause analysis information may not always be present for every issue. When you select an issue, you may see Root cause analysis information. Root cause analysis includes three main UI sections: Deployment events: When you set up deployments, we provide the deployment nearest to the issue creation. Changes, such as deployments, account for a high percentage of the root causes of incidents and having that information at hand can help diagnose and resolve issues. Error logs: You can explore millions of log messages with a single click and use manual querying to help you find anomalous patterns and hard-to-find problems. Attributes to investigate: We scan the distribution of attributes and surface possible causes by finding significant changes in the distribution. This section also shows changes in database and external metrics. You can also query interesting attributes. Issue timeline The issue timeline, as presented below, shows you a breakdown of: Incidents The trends taking place What incidents are active What incidents are resolved What is correlated to each other Various milestones at different issue levels In addition, you’ll see a grey line at the top of the timeline. In comparison to the visual timeline that shows the changes to each incident, the grey line represents changes to the issue. Mouse over the grey line to see details of the event. Finally, mouse over the incident to see information on the location, timing, and level of importance of a specific incident. This figure shows a particular incident populated on January 11th with a level of Critical. To view the issues in a text format, in the right hand corner, click Switch to issue log view. Related activity The issue page includes a Related activity section, which is a table displaying activity related to the incident or anomally you are are trying to analyze. You can click each line item in the table to view a unique dashboard that displays data for the entity the incident or anomally came from. The related activity section aggregates a set of incidents into a single issue, according to a rule-based system. Use decisions To further reduce noise or get improved incident correlation, you can change or customize your decisions. Decisions determine how Incident Intelligence groups incidents together. To get started, see Decisions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 251.51917,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use <em>Incident</em> <em>Intelligence</em>",
        "sections": "Use <em>Incident</em> <em>Intelligence</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": ". The map shows not only the affected entities, but also the services and resources directly related to those entities. Use suggested responders If you’re using PagerDuty or New Relic <em>alerts</em> violations as your <em>incident</em> notification tools, <em>Incident</em> <em>Intelligence</em> suggests relevant team members that can"
      },
      "id": "6080293564441fd0669d8580"
    }
  ],
  "/docs/alerts-applied-intelligence/applied-intelligence/proactive-detection/expanded-anomaly-detection": [
    {
      "sections": [
        "Incident Intelligence destination examples",
        "Destination template examples",
        "Suggested OpsGenie template example",
        "Suggested ServiceNow template example",
        "Suggested Slack template example",
        "Suggested VictorOps template example",
        "Webhook and JSON format examples",
        "Webhook format and JSON example",
        "Jinja2 Default Payload",
        "Jinja2 Useful Syntax",
        "JSON schema",
        "JSON schema template"
      ],
      "title": "Incident Intelligence destination examples",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "a516d04f8b75541a6dc9338fa3ce9645ba87d620",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/incident-intelligence-destination-examples/",
      "published_at": "2021-06-02T18:22:22Z",
      "updated_at": "2021-06-02T18:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Destinations are the data outputs to Applied Intelligence, where you can view your automatically correlated incidents. You can configure Incident Intelligence destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema. Destination template examples The following template example destinations are formatted in Jinja2. Suggested OpsGenie template example { \"alias\": {{ id }}, \"message\": {{ ui_name }}, \"source\": '{{ sources }}', \"priority\": {{ priority }}, \"details\": { \"self_url\": {{ url }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"is_correlated\": {{ is_correlated }} }, \"description\": \"\"\"Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]\"\"\" } Copy Suggested ServiceNow template example { \"short_description\": {{ ui_name }}, \"description\": 'Issue Id: {{ id }}, \\n Description: {{ description }}, \\n Sources: {{ sources }}, \\n Priority: {{ priority }}, \\n Details: { \\n self_url: {{ url }}, \\n state: {{ state }}, \\n is_correlated: {{ is_correlated }}, \\n created_on: {{ created_on }}, \\n modified_on: {{ modified_on }}, \\n activated_on: {{ active_since }}, \\n closed_on: {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \\n is_correlated: {{is_correlated}} }, \\n\\n incidents: {{ incidents }}, \\n\\n pathways: {{ pathways }}' } Copy Suggested Slack template example Go to Slack incoming WebHooks Choose the right Slack workspace and click \"Add to Slack\" Select the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In New Relic Applied Intelligence, under Incident Intelligence click Destinations Add a WebHook In the end point paste the WebHook url from slack. In the custom payload, paste the following JSON: { \"blocks\": [ { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*New Relic Incident Intelligence Alert*\" } }, { \"type\": \"divider\" }, { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*CUSTOM FIELDS*:\" }, \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue ID*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Issue Title*\" }, { \"type\": \"plain_text\", \"text\": {{ id }} }, { \"type\": \"plain_text\", \"text\": {{ ui_name }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue URL*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Description*\" }, { \"type\": \"mrkdwn\", \"text\": {{ url }} }, { \"type\": \"plain_text\", \"text\": {{ description }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*State*\" }, { \"type\": \"mrkdwn\", \"text\": \"*is_correlated*\" }, { \"type\": \"plain_text\", \"text\": {{ state }} }, { \"type\": \"plain_text\", \"text\": \"{{ is_correlated }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Created On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Modified On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ created_on }}\" }, { \"type\": \"plain_text\", \"text\": \"{{ modified_on }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Activated On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Closed On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ active_since }}\" }, { \"type\": \"plain_text\", \"text\": \"{% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Aggregated Incidents*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Monitoring Tool*\" }, { \"type\": \"plain_text\", \"text\": \"{{ incident_count }}\" }, { \"type\": \"plain_text\", \"text\": {{ sources|join(', ') }} } ] } ] } Copy Suggested VictorOps template example { \"monitoring_tool\": {{ sources }}, {% if state == 'closed' %} \"message_type\": \"OK\", {% else %} \"message_type\": {{ priority }}, {% endif %} \"custom_fields\": { \"issue_url\": {{ url }}, \"description\": {{ description }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"related_incidents\": [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %} {% endfor %} ] }, \"state_message\": {{ description }}, \"entity_id\": {{ id }}, \"entity_display_name\": {{ ui_name }}, \"vo_annotate.u.NRAI_Link\": {{ url }} } Copy Webhook and JSON format examples Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). If you use webhooks to configure Incident Intelligence destinations, use these examples of the webhook body format and JSON schema. Webhook format and JSON example Webhook format: Name Description url Href A link to the UI where the issue can be seen. id String Unique identifier for the issue. title String The issue title. description String The description of the issue. priority Enum The issue priority. Can be Critical, High, Medium, or Low. state Enum The issue status. Can be Active, Closed, or Acknowledged. is_correlated Boolean True if the issue is based on correlated data. created_on String The date and time the issue was created (in ISO format). modified_on String The date and time the issue was modified (in ISO format). active_since String The date and time the issue was activated (in ISO format). closed_on String The date and time the issue was closed (in ISO format). sources List(String) List of the different sources that were used to send the events into Applied Intelligence (for example: PagerDuty). pathways List(Pathways) List of pathways that are associated with the issue. Each pathway contains an id and name: [{“id”: “pathway id”, “name”: “pathway name”}]. pathways[].id String The pathway ID. pathways[].name String The pathway name. incidents List(Incident) List of incidents that are attached to the issue. The list contains only the latest 100 incidents. incidents[].id String The incident ID. incidents[].events_count Integer The number of events used to create the incident. incidents[].title String The incident title. incidents[].description String The incident description. incidents[].labels Dictionary (String) A string to string mapping of the incident labels. Labels represent the unique entities that are used to describe the incident. incidents[].priority Enum The incident priority. Can be Critical, High, Medium, or Low. incidents[].sources List(String) The incident source. incidents[].state Enum(open, closed) The incident state. incidents[].opened_on String The date and time the incident was opened (in ISO format). incidents[].closed_on String The date and time the incident was closed (in ISO format). ui_name String Issue title. accumulations['alert/signal'] String Issue analysis summary golden signal/s (if applicable). accumulations['alert/components'] String Issue analysis summary golden components (if applicable). Jinja2 Default Payload Applied Intelligence uses a templating framework called Jinja2 in the Webhook interface. Here is a default Jinja2 payload to use: { \"id\": {{ id }}, \"url\": {{ url }}, \"ui_name\": {{ ui_name }}, \"description\": {{ description }}, \"priority\": {{ priority }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"active_since\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"sources\": {{ sources }}, \"incidents\": {{ incidents }}, \"pathways\": {{ pathways }}, } Copy Jinja2 Useful Syntax Below are a few useful Jinja2 commands to help you format your output. Casting a value to integer Example: “severity”: {{ priority | int }} Copy If clause to check if an attribute’s value is set Example: \"golden_signals\": {% if accumulations['alert/signal'] is defined %} {{ accumulations['alert/signal'] }} {% else %} None {% endif %} Copy For loop to iterate of an array of values: Example: \"description\": 'Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]' Copy Check if an array attribute's value is set: Example: \"hostname_field\": {% if incidents[0].labels['newrelic/tag/hostname'] is defined %} {{ incidents[0].labels['newrelic/tag/hostname'] }} {% else %} None {% endif %} Copy JSON schema Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). JSON schema template JSON schema: { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"definitions\": { \"Labels\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"LabelsSet\": { \"type\": \"array\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"$ref\": \"#/definitions/Labels\" }, \"uniqueItems\": true }, }, \"Annotations\": { \"type\": \"object\", \"title\": \"Additional contextual information about the Entity\", \"description\": \"Fields like title, description and priority can be described as annotations since\\nthey represent some additional information about the Incident.\\nFor example, the rule that creates the entity can have some logic that will create a title annotation field.\\nThe title will change according to the latest event received by the entity and as more\\nevent will keep coming the field may change, all this as a decision by the rule.\\nA different rule may decide not to populate the title at all.\\nSince a title can also be produced from the labels themselves.\", \"properties\": { \"title\": { \"type\": \"string\", \"maxLength\": 10000 }, \"description\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"patternProperties\": { \".*\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"Accumulations\": { \"type\": \"object\", \"title\": \"Accumulated data about the Incident\", \"description\": \"For example an entity with the label: host_name: foo will include a accumulated list of the\\nrelevant process names that are relevant to the entity. Accumulations will be derived from the events\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"type\": \"string\", \"maxLength\": 10000 } } }, \"IssueState\": { \"type\": \"string\", \"enum\": [ \"created\", \"active\", \"acknowledged\", \"closed\" ], \"properties\": {}, \"additionalProperties\": false }, \"Priority\": { \"type\": \"string\", \"enum\": [ \"critical\", \"high\", \"medium\", \"low\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueClosingReason\": { \"type\": \"string\", \"enum\": [ \"nacked\", \"resolved\", \"system\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueAction\": { \"type\": \"string\", \"enum\": [ \"ack\", \"snooze\", \"nack\", \"end_snooze\", \"expire_snooze\", \"star\", \"un_snooze\", \"unstar\", \"archive\", \"unarchive\", \"resolve\", \"reopen\", \"open\", \"feedback\", \"feedback_file\", \"open_ticket\", \"merge_issues\", \"active\", \"create\", \"close\", \"incident_updated\", \"confidence_changed\", \"diagnoses_changed\", \"rule_properties_changed\", \"flapping\", \"notification\", \"incident_events_limit_reached\", \"follow\", \"unfollow\", \"priority_updated\", \"comment\", \"incident_appended\", \"diagnosis_feedback\", \"flapping_delay_close\" ], \"properties\": {}, \"additionalProperties\": false }, \"StringKeyValue\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\" } }, \"JavaOptionalUuid\": { \"type\": \"string\", \"properties\": {}, \"additionalProperties\": false, \"format\": \"string-uuid\" } }, \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"customer_id\": { \"type\": \"integer\" }, \"labels_set\": { \"$ref\": \"#/definitions/LabelsSet\" }, \"annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations_version\": { \"type\": \"integer\" }, \"accumulations\": { \"$ref\": \"#/definitions/Accumulations\" }, \"state\": { \"$ref\": \"#/definitions/IssueState\" }, \"previous_state\": { \"$ref\": \"#/definitions/IssueState\" }, \"priority\": { \"$ref\": \"#/definitions/Priority\" }, \"closing_reason\": { \"oneOf\": [ { \"$ref\": \"#/definitions/IssueClosingReason\" }, { \"type\": \"null\" } ] }, \"modified_on\": { \"type\": \"integer\" }, \"created_on\": { \"type\": \"integer\" }, \"closed_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"acknowledged_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"active_since\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"assigned_to\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"created_by\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"progress_report\": { \"type\": \"array\", \"default\": [], \"items\": { \"type\": \"object\", \"properties\": { \"origin_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1 }, { \"type\": \"null\" } ] }, \"timestamp\": { \"type\": \"integer\" }, \"action_timestamp\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"origin_type\": { \"type\": \"string\", \"enum\": [ \"user\", \"system\" ] }, \"event_type\": { \"$ref\": \"#/definitions/IssueAction\" }, \"issue_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"format\": \"string-uuid\" }, { \"type\": \"null\" } ] }, \"attributes\": { \"oneOf\": [ { \"$ref\": \"#/definitions/StringKeyValue\" }, { \"type\": \"null\" } ] }, \"team_id\": { \"$ref\": \"#/definitions/JavaOptionalUuid\" } }, \"required\": [ \"timestamp\", \"origin_type\", \"event_type\" ], \"additionalProperties\": false }, \"uniqueItems\": true }, \"rule_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"maxLength\": 255 }, { \"type\": \"null\" } ] }, \"incident_ids\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"confidence\": { \"type\": \"number\", \"default\": 1.0, \"minimum\": 0.0, \"maximum\": 1.0 } }, \"required\": [ \"id\", \"customer_id\", \"labels_set\", \"annotations\", \"priority\", \"modified_on\", \"created_on\", \"confidence\" ], \"additionalProperties\": true } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 332.55853,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Incident <em>Intelligence</em> destination examples",
        "sections": "Incident <em>Intelligence</em> destination examples",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "Destinations are the data outputs to <em>Applied</em> <em>Intelligence</em>, where you can view your automatically correlated incidents. You can configure Incident <em>Intelligence</em> destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema"
      },
      "id": "6044280d64441f4af5378ed3"
    },
    {
      "sections": [
        "Use Incident Intelligence",
        "Issue summary",
        "Impacted entities map",
        "Use suggested responders",
        "Important",
        "Tip",
        "Root cause analysis",
        "Issue timeline",
        "Related activity",
        "Use decisions"
      ],
      "title": "Use Incident Intelligence",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "f7b852fa406a6e9ff88b791e4cbccc2bd20a5962",
      "image": "https://docs.newrelic.com/static/6e37cc77304398121e1a0080a57e47bb/8c557/screenshot_incident_intelligence_timeline_event_detail.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/use-incident-intelligence/",
      "published_at": "2021-06-02T18:23:21Z",
      "updated_at": "2021-05-28T11:09:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you set up Incident Intelligence, our system will begin finding issues from your data sources. In the issue feed, you can find an overview of all your issues, along with helpful information about them. You can also click any individual issue for more detail, including its analysis summary, event log, and details about correlated issues. This screenshot shows an example issue feed, which describes your issues' statuses, correlations, and more. What's the difference between an issue, incident, and event? In short, these terms are like building blocks. Events are raw data from your sources. Incidents are made up of one or more events. Issues are composed of one or more incidents. In more detail: Events indicate a state change or trigger defined by your monitoring systems. An event contains information about the affected entity, and they are almost always triggered automatically by the system. Incidents are groups of events that describe the \"symptoms\" of your system over time. These symptoms are detected by your monitoring tools, which evaluate your data streams and events. Issues are groups of incidents that describe the underlying problem of your symptoms. When a new incident is created, Incident Intelligence opens an issue and evaluates other open issues for correlations. Issue summary The Issue page is built to provide you with bottom line insights first to understand the problem, and then to minimize the time you need to resolve it. The Issue page includes the following sections: Issue summary: This section has two machine learning modules, the golden signals and the related components. Suggested responders: This section will tell you who to potentially reach out to on your team to solve a specific problem. Label sets: Label sets are focused on incidents that come from 3rd party sources, such as PagerDuty, AWS Cloudwatch, REST APIs, etc., as well as for NRQL queries. They come in the form of key:value pairs. Impacted entities: An entity is anything that has data you can monitor. Specifically, these are focused on incidents from New Relic sources, extracting the entities and providing a summary. Each entity is unique. You can see your entities in a list or on a map. Depending on the data in an issue, all four of these sections can show up together for each issue or separately. If you hover over an impacted entity application, you’ll notice a few calls to action: relevant dashboards, anomaly overview, deployment events, and entity overview. Relevant dashboards helps users in your account look at and interact with dashboards you've created that are related to an entity. The queries you've run to power the various widgets are automatically mapped to entities whenever possible and are presented back to you here for quick access and discovery. Anomaly overview will open the application's anomalies page. This is only available for applications that are set up for Proactive Detection. There are two types of deployment events: deployments and related deployments. Click Show all deployments to see all your deployment events when they arrive, or click a specific deployment to see its APM deployments page. The APM deployment page lists recent deployments and their impact on your end user and app server's Apdex scores, response times, throughput, and errors. This section will only show up if New Relic has identified applications under the impacted entities that have deployments. Impacted entities map Hover over an entity to see more information about it. An impacted entities map is available for any issue involving two or more entities. The map shows not only the affected entities, but also the services and resources directly related to those entities. Use suggested responders If you’re using PagerDuty or New Relic alerts violations as your incident notification tools, Incident Intelligence suggests relevant team members that can help resolve your issues. Incident Intelligence learns from your PagerDuty and alerts violations data to provide suggestions for each new incident. Once you receive a suggestion, you can contact the responder or search for relevant documentation that person may have written. To get started, enable PagerDuty or alerts violations as a source for Incident Intelligence. Afterwards, you can view the suggestions in two places: The issue feed, where you can also provide feedback on the suggestions. Directly within PagerDuty (both UI and API.) If you’re also using PagerDuty as a destination, the suggestions will appear in your issue notifications payload. Important This feature doesn't account for on-call availability at the time of incident. Tip In order to train the model, we use the information PagerDuty provides about individuals. We ingest incident information only, not users’ contact details. Root cause analysis Root cause analysis automatically finds potential causes for an issue and its impacted entities. It shows you why open issues occurred, which deployments contributed, and relevant error logs and attributes. With this, you can investigate the problem and reduce your mean time to resolution (MTTR). Tip Note that root cause analysis is dependent on other New Relic data sources and features. This is why root cause analysis information may not always be present for every issue. When you select an issue, you may see Root cause analysis information. Root cause analysis includes three main UI sections: Deployment events: When you set up deployments, we provide the deployment nearest to the issue creation. Changes, such as deployments, account for a high percentage of the root causes of incidents and having that information at hand can help diagnose and resolve issues. Error logs: You can explore millions of log messages with a single click and use manual querying to help you find anomalous patterns and hard-to-find problems. Attributes to investigate: We scan the distribution of attributes and surface possible causes by finding significant changes in the distribution. This section also shows changes in database and external metrics. You can also query interesting attributes. Issue timeline The issue timeline, as presented below, shows you a breakdown of: Incidents The trends taking place What incidents are active What incidents are resolved What is correlated to each other Various milestones at different issue levels In addition, you’ll see a grey line at the top of the timeline. In comparison to the visual timeline that shows the changes to each incident, the grey line represents changes to the issue. Mouse over the grey line to see details of the event. Finally, mouse over the incident to see information on the location, timing, and level of importance of a specific incident. This figure shows a particular incident populated on January 11th with a level of Critical. To view the issues in a text format, in the right hand corner, click Switch to issue log view. Related activity The issue page includes a Related activity section, which is a table displaying activity related to the incident or anomally you are are trying to analyze. You can click each line item in the table to view a unique dashboard that displays data for the entity the incident or anomally came from. The related activity section aggregates a set of incidents into a single issue, according to a rule-based system. Use decisions To further reduce noise or get improved incident correlation, you can change or customize your decisions. Decisions determine how Incident Intelligence groups incidents together. To get started, see Decisions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 313.48865,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use Incident <em>Intelligence</em>",
        "sections": "Use Incident <em>Intelligence</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " to entities whenever possible and are presented back to you here for quick access and discovery. Anomaly overview will open the application&#x27;s anomalies page. This is only available for applications that are set up for <em>Proactive</em> <em>Detection</em>. There are two types of deployment events: deployments"
      },
      "id": "6080293564441fd0669d8580"
    },
    {
      "sections": [
        "Proactive Detection with Applied Intelligence",
        "Tip",
        "Requirements",
        "Why it matters",
        "How it works",
        "Set up notifications for Proactive Detection",
        "Set up for Slack",
        "Set up for webhooks",
        "Set up without notifications",
        "Mute notifications (Slack only)",
        "Use Proactive Detection Slack messages",
        "View overview of anomalies",
        "Anomaly visibility settings",
        "Query anomaly data",
        "Important",
        "Add anomalies as source in Incident Intelligence",
        "Webhook payload and examples",
        "JSON schema example",
        "Data limits"
      ],
      "title": "Proactive Detection with Applied Intelligence",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Proactive detection"
      ],
      "external_id": "53e01b53fc341ef1e89b96e7927b16de03e72358",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/proactive-detection/proactive-detection-applied-intelligence/",
      "published_at": "2021-06-02T18:28:02Z",
      "updated_at": "2021-03-30T07:40:55Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With Applied Intelligence's Proactive Detection, anomalies from your New Relic APM-monitored applications are automatically surfaced in our activity streams and anomalies feed. Each anomaly can be clicked on to bring up an automatic analysis. You can have notifications for anomalies delivered in Slack, or you can set up a webhook to deliver messages when you need them. These events are available for querying, creating custom dashboards, and alerting. By creating a Proactive Detection configuration (a group of apps you’re interested in), you can then add this configuration as a source, and have anomalies automatically correlated with other data sources via Incident Intelligence. Tip Proactive Detection is automatically enabled and available at no additional cost. All that's required is data from your APM-monitored applications flowing into New Relic. To signup and take advantage of this and the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Requirements To use Proactive Detection, ensure you have: An APM agent installed for at least one applications. To receive notifications in Slack, you'll need to ask your IT administrator to install the Applied Intelligence application in your Slack workspace. For more on data limits, see Data limits. Why it matters With Proactive Detection, Applied Intelligence delivers insights about anomalies in your production system, along with an automatic analysis of the anomaly. It’s enabled automatically, at no additional cost. When an anomaly is detected, you can view it in the Applied Intelligence anomalies feed, or we'll send notifications directly to your Slack channel or a webhook. How it works Proactive Detection uses the following methods to detect anomalies in your app data: Proactive Detection monitors metric data reported by an APM agent, building a model of your typical application dynamics, and focuses on key golden signals: throughput, response time, and errors. If one of these golden signals shows anomalous behavior, the system flags it and tracks recovery to normal behavior. The system adapts to changes in your data, and continuously updates models based on new data. Automatically on: By default, Proactive Detection monitors all your APM applications, with no action required by you. When an anomaly is detected, it's automatically surfaced in various activity streams, the Applied Intelligence anomalies feed and is available for querying via NRQL. Receiving notifications: We send notifications when we detect anomalous changes in throughput, error rate, or response time. The notifications are sent to selected Slack channels, or sent via webhook. When the anomaly goes back to normal, a recovery message is sent. If you don't want to receive notifications, you still have access to the data via NRQL query. Anomaly analysis: For each anomaly, we provide a link in Slack to an analyze anomaly page. This page generates automatic insights into the anomaly. The page is also available from the anomalies tab, which lists recent anomalies. This page uses your existing APM and Proactive Detection data to provide explanations as to the cause of the anomaly. Activity stream: Inside various activity streams such as the New Relic One homepage, APM Summary page, Lookout and Explorer, you'll see relevant anomalies from your APM-monitored applications. Clicking on any of the anomaly events in the activity stream brings up the analysis page for that anomaly. Applications will not always generate anomalies, so it can be normal to not receive any detections. Set up notifications for Proactive Detection Proactive Detection is enabled automatically, at no additional cost. To receive notifications or to have a configuration (group of apps) that you can add as a source for Incident Intelligence, you will need to create a Proactive Detection configuration. You can create a configuration in the Proactive Detection UI: From one.newrelic.com, click Alerts & AI. Under Proactive Detection, click Settings. Click Add a configuration. Input the following information into the form: Choose a name for your configuration that helps you easily identify it from others in your account. Select an account. Select up to 1,000 applications. Note that certain applications with low throughput might not be good candidates for Proactive Detection, as they can be more sensitive to smaller amounts of data fluctuation. Optional: select the golden signals you'd like to monitor for anomalies. Optional: connect to Incident Intelligence. Set up for Slack To use Proactive Detection with Slack: Select Slack. Choose which Slack channel receives notifications. You can select any existing public or private channel. This prompts the workflow to add the Applied Intelligence Slack application to your selected channel. To create a new channel, do that directly in Slack first. Tip If you experience an error when assigning Slack channels, make sure that the New Relic AI Slack application has been added to your Slack workspace. Save the configuration. You can modify the applications for each configuration at any time by selecting the configuration in the configuration table. Set up for webhooks To use Proactive Detection with webhooks: Select Webhook. Input the following information into the form: Provide the webhook URL. Provide optional custom headers. Choose to edit the custom payload, or enable using the default payload. Save the configuration. You can modify the applications for each configuration at any time by selecting the configuration in the configuration table. Set up without notifications To use Proactive Detection when you don't need to receive notifications: Select No notifications. Save the configuration. You can modify the applications for each configuration at any time by selecting the configuration in the configuration table. Mute notifications (Slack only) In Slack, detections coming from specific applications can be muted temporarily or permanently. The entire channel can also be muted temporarily. This is useful in the case of an incident or when the channel should otherwise not be interrupted. To mute in Slack, select Mute this app’s warnings or Mute all warnings, then select the duration. We will resume sending notifications for any detections once the muting duration has completed. Muting an application permanently removes it from the configuration. To add it back in, go to one.newrelic.com, in the top nav click Alerts & AI, then click Proactive Detection, and select the configuration to edit. Muting Proactive Detection notifications does not affect alerts. Use Proactive Detection Slack messages Each anomaly message has several key pieces of information you can use to learn more about and start troubleshooting the potential issue: The application name and a link to more information about it in New Relic One. The metric experiencing an anomaly and a link to its details in New Relic One. A graph of the metric over time to provide a visual understanding of the anomaly’s behavior and degree. An Analyze button that navigates to an analysis page in Applied Intelligence that identifies key attributes that are unique to the anomaly, anomalies found upstream or downstream, and any other relevant signals. Once an anomaly has returned to normal, we send a recovery notification with the option to provide feedback. Your feedback provides our development team with input to help us improve detection quality. In the case of feedback provided on throughput anomalies, an evaluation is run each hour based on feedback to fit a more suitable model. If we helped you, you can select Yes or No. View overview of anomalies In addition to notifications for anomalies that give you information via Slack or webhook, you can view more information about the anomalies in your environment via the Anomalies tab on the Alerts & AI Overview page. That tab provides a list of all the recent anomalies from every configuration in the selected account, and you can select an anomaly for a detailed analysis. Anomaly visibility settings Anomalies are displayed in various New Relic activity streams and in the Applied Intelligence anomalies feed. You can customize what is displayed using the anomaly visibility settings (for example, hiding throughput anomalies on an activity stream but keeping them in the anomalies feed). To find these settings: from Alerts & AI, under Proactive Detection, click Settings. Notes on using these settings: These settings are applied at the user level. Changes you make won’t affect others users in your organization. Regardless of these settings, the anomalies are still reported and available for NRQL querying. Details on these UI sections: AI overview and anomalies tab: Use the AI overview and anomalies tab setting to hide anomalies from the AI overview and anomalies tab setting. Please note you also can use filters specific to these views as well. Global activity stream: Use the global activity stream section to customize what anomalies are shown in the various New Relic activity streams, including the New Relic One homepage, APM Summary, and Lookout. Anomaly types: Use the check boxes here to hide specific types of anomalies. For example uncheck Web throughput and Non-web throughput anomalies to hide these types of anomalies from both the activity streams and the AI overview and anomalies tab. (Note they are still reported and available for querying.) Query anomaly data You can use NRQL to query and chart your Proactive Detection data using the NrAiAnomaly event. For example: FROM NrAiAnomaly SELECT * Important This data has previously been attached to the ProactiveDetection event. That event will be deprecated on April 7, 2021. If you use ProactiveDetection in your custom charts, you should convert those queries to using NrAiAnomaly. Here are important attributes attached to this event: Attribute Description closeTime timestamp The time when the anomaly ended. Example: 1615304100000. configurationType string The type of configuration monitoring the event. If at least one configuration is monitoring the entity, this is set to configuration. Otherwise, it's set to automatic. entity.accountId number The New Relic account ID to which the entity belongs. entity.domain number The domain of the entity (currently only APM but will change with future functionality). entity.guid string The GUID of the entity. This is used to identify and retrieve data about the entity via NerdGraph. Identical to entityGuid. entityGuid string The GUID of the entity. This is used to identify and retrieve data about the entity via NerdGraph. Identical to entity.guid. entity.name string The name of the entity whose data was determined to be anomalous. Identical to entityName. Example: Laura's coffee service. entityName string The name of the entity whose data was determined to be anomalous. Identical to entity.name. entity.type string The type of entity (currently only APPLICATION but will change with future functionality). evaluationType string This is always anomaly. event string Indicates whether it's the beginning (open) or end (close) of the anomalous data. openTime timestamp The time when the anomaly opened. Example: 1615303740000. signalType string The type of data that was analyzed. For example, error_rate or response_time.non_web. timestamp timestamp The time at which the event was written. title string Description of the anomaly. Example: Error rate was much higher than normal. Add anomalies as source in Incident Intelligence By integrating Incident Intelligence with your Proactive Detection anomalies, you can get context and correlations. To learn about doing this in Incident Intelligence, see Configure sources. You can also select Connect to Incident Intelligence from inside of a configuration. Webhook payload and examples Proactive Detection sends the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). If you use webhooks to configure Proactive Detection, use these examples of the webhook body format and JSON schema. Attribute Description category enum The category of data that was analyzed. Categories include web throughput, non-web throughput, web transactions, non-web transactions, and error class. data list The time series data leading up to the detection. data[].timestamp number The timestamp of the data point in milliseconds since the Unix epoch. Example: 1584366819000 data[].unit string The unit describing the value of the data point. Data units include count, milliseconds, and error_rate. data[].value number The value of the data point. Example: 1.52 detectionType enum The type of data that was analyzed. Types include latency, throughput, and error_rate. entity object The entity that reported the unusual data. entity.accountId number The ID for the entity's account. entity.domain enum The domain for the entity. Example: APM. entity.domainId string The id used to uniquely identify the entity within the domain. entity.guid string The guid used to uniquely identify the entity across all products. entity.name string The name of the entity. Example: Laura’s coffee service entity.link string A link to view the entity. Example: https://rpm.newrelic.com/accounts/YOUR_ACCOUNT_ID/applications/987654321” Copy severity enum A description of how unusual of a change occurred, including NORMAL, WARNING, or CRITICAL. version string Version used to describe the data being provided. Example: v1 JSON schema example Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). Template: { \"version\": \"{{version}}\", \"entity\": { \"type\": \"{{entity.type}}\", \"name\": \"{{entity.name}}\", \"link\": \"{{entity.link}}\", \"entityGuid\": \"{{entity.entityGuid}}\", \"domainId\": \"{{entity.domainId}}\", \"domain\": \"{{entity.domain}}\", \"accountId\": {{entity.accountId}} }, \"detectionType\": \"{{detectionType}}\", \"category\": \"{{category}}\", \"data\": [{{#each data}} { \"value\": {{value}}, \"unit\": \"{{unit}}\", \"timestamp\": {{timestamp}} } {{#unless @last}},{{/unless}} {{/each}}] } Copy Sample payload: { \"version\": \"v1\", \"entity\": { \"type\": \"APPLICATION\", \"name\": \"My Application\", \"link\": \"https://rpm.newrelic.com/accounts/ACCOUNT_ID/applications/123\", \"entityGuid\": \"foo\", \"domainId\": \"123\", \"domain\": \"APM\", \"accountId\": YOUR_ACCOUNT_ID }, \"detectionType\": \"metric\", \"category\": \"web throughput\", \"severity\": \"CRITICAL\", \"data\": [ { \"value\": 100, \"unit\": \"count\", \"timestamp\": 1584047560917 } , { \"value\": 99, \"unit\": \"count\", \"timestamp\": 1584047620917 } , { \"value\": 0, \"unit\": \"count\", \"timestamp\": 1584047680917 } ] } Copy Data limits In addition to requirements, data limits include: Monitored APM applications: limited to 1,000 per configuration Slack configurations: limited to 200 per account Webhook configurations: limited to 200 per account Configurations without notifications: limited to 200 per account",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 263.33948,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Proactive</em> <em>Detection</em> with <em>Applied</em> <em>Intelligence</em>",
        "sections": "<em>Proactive</em> <em>Detection</em> with <em>Applied</em> <em>Intelligence</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "With <em>Applied</em> <em>Intelligence</em>&#x27;s <em>Proactive</em> <em>Detection</em>, anomalies from your New Relic APM-monitored applications are automatically surfaced in our activity streams and anomalies feed. Each anomaly can be clicked on to bring up an automatic analysis. You can have notifications for anomalies delivered"
      },
      "id": "603e9d68196a67dc21a83dd2"
    }
  ],
  "/docs/alerts-applied-intelligence/applied-intelligence/proactive-detection/proactive-detection-applied-intelligence": [
    {
      "sections": [
        "Expanded anomaly detection",
        "Requirements",
        "Why it matters",
        "Get started with anomaly detection",
        "Detect anomalies with a faceted NRQL query",
        "See your anomalies in one place",
        "Tip",
        "Query anomaly data",
        "Reduce the number of detected anomalies"
      ],
      "title": "Expanded anomaly detection",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Proactive detection"
      ],
      "external_id": "0b07c0b6ce27f39b5edb3e112a0f949835cbb8c6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/proactive-detection/expanded-anomaly-detection/",
      "published_at": "2021-06-02T18:27:12Z",
      "updated_at": "2021-05-31T16:43:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We’ve expanded anomaly detection coverage beyond your APM applications. Configure anomaly detection for your browser applications, mobile applications, infrastructure hosts, and nearly anything you want to monitor. Requirements Expanded anomaly detection is available as a limited beta. You can request access here. Why it matters When starting to configure alert conditions for a variety of applications and hosts, it can be difficult to know what you’ll want to be notified about ahead of time. Anomaly detection helps you distinguish between what’s typical performance in your system and where you’re starting to have trouble. Instead of creating your alert conditions manually, you can simply tell us what you want to monitor. Anomaly detection will help you identify baseline performance in your system and flags anomalous activity in your system. Get started with anomaly detection To get started with expanded anomaly detection: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Select the account you want to use to record anomaly data, then select the workload or entities you’d like to monitor. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name your configuration and save. Detect anomalies with a faceted NRQL query To detect anomalies with a faceted NRQL query: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Click Use a query instead. You may need to select an account, if you have more than one. Add one or more queries with a FACET clause. Name the query and confirm the facets you want to monitor for anomalies. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name the configuration and save. See your anomalies in one place When you set up anomaly detection, New Relic starts analyzing the golden signals of your entities and workloads. Anomalies appear in your activity feeds throughout New Relic One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL alert condition for the NrAiAnomaly event. To view anomalies, from one.newrelic.com, go to Alerts & AI > Issues & activity > Anomalies. Query anomaly data Detected anomalies are written to the NrAiAnomaly event in your NRDB account. You can learn more about this event and how to query it here. Reduce the number of detected anomalies If you’re seeing too many anomalies, the first step is to make sure your sensitivity level is set to Low. If it’s already set to Low, you can define specific thresholds to distinguish between normal and anomalous behavior. To define custom thresholds: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab and the configuration you want to modify. Select an entity or workload, and then change the sensitivity level. You can use custom sensitivity to define specific thresholds for different entity types.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 481.33475,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Expanded anomaly <em>detection</em>",
        "sections": "Expanded anomaly <em>detection</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " the <em>detection</em> sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name your configuration and save. <em>Detect</em> anomalies with a faceted NRQL query To <em>detect</em> anomalies with a faceted NRQL query: From one.newrelic.com, go to <em>Alerts</em> &amp; AI &gt; <em>Proactive</em> <em>Detection</em>"
      },
      "id": "60b5124064441ff965e2cb01"
    },
    {
      "sections": [
        "Incident Intelligence destination examples",
        "Destination template examples",
        "Suggested OpsGenie template example",
        "Suggested ServiceNow template example",
        "Suggested Slack template example",
        "Suggested VictorOps template example",
        "Webhook and JSON format examples",
        "Webhook format and JSON example",
        "Jinja2 Default Payload",
        "Jinja2 Useful Syntax",
        "JSON schema",
        "JSON schema template"
      ],
      "title": "Incident Intelligence destination examples",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "a516d04f8b75541a6dc9338fa3ce9645ba87d620",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/incident-intelligence-destination-examples/",
      "published_at": "2021-06-02T18:22:22Z",
      "updated_at": "2021-06-02T18:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Destinations are the data outputs to Applied Intelligence, where you can view your automatically correlated incidents. You can configure Incident Intelligence destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema. Destination template examples The following template example destinations are formatted in Jinja2. Suggested OpsGenie template example { \"alias\": {{ id }}, \"message\": {{ ui_name }}, \"source\": '{{ sources }}', \"priority\": {{ priority }}, \"details\": { \"self_url\": {{ url }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"is_correlated\": {{ is_correlated }} }, \"description\": \"\"\"Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]\"\"\" } Copy Suggested ServiceNow template example { \"short_description\": {{ ui_name }}, \"description\": 'Issue Id: {{ id }}, \\n Description: {{ description }}, \\n Sources: {{ sources }}, \\n Priority: {{ priority }}, \\n Details: { \\n self_url: {{ url }}, \\n state: {{ state }}, \\n is_correlated: {{ is_correlated }}, \\n created_on: {{ created_on }}, \\n modified_on: {{ modified_on }}, \\n activated_on: {{ active_since }}, \\n closed_on: {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \\n is_correlated: {{is_correlated}} }, \\n\\n incidents: {{ incidents }}, \\n\\n pathways: {{ pathways }}' } Copy Suggested Slack template example Go to Slack incoming WebHooks Choose the right Slack workspace and click \"Add to Slack\" Select the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In New Relic Applied Intelligence, under Incident Intelligence click Destinations Add a WebHook In the end point paste the WebHook url from slack. In the custom payload, paste the following JSON: { \"blocks\": [ { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*New Relic Incident Intelligence Alert*\" } }, { \"type\": \"divider\" }, { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*CUSTOM FIELDS*:\" }, \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue ID*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Issue Title*\" }, { \"type\": \"plain_text\", \"text\": {{ id }} }, { \"type\": \"plain_text\", \"text\": {{ ui_name }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue URL*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Description*\" }, { \"type\": \"mrkdwn\", \"text\": {{ url }} }, { \"type\": \"plain_text\", \"text\": {{ description }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*State*\" }, { \"type\": \"mrkdwn\", \"text\": \"*is_correlated*\" }, { \"type\": \"plain_text\", \"text\": {{ state }} }, { \"type\": \"plain_text\", \"text\": \"{{ is_correlated }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Created On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Modified On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ created_on }}\" }, { \"type\": \"plain_text\", \"text\": \"{{ modified_on }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Activated On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Closed On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ active_since }}\" }, { \"type\": \"plain_text\", \"text\": \"{% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Aggregated Incidents*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Monitoring Tool*\" }, { \"type\": \"plain_text\", \"text\": \"{{ incident_count }}\" }, { \"type\": \"plain_text\", \"text\": {{ sources|join(', ') }} } ] } ] } Copy Suggested VictorOps template example { \"monitoring_tool\": {{ sources }}, {% if state == 'closed' %} \"message_type\": \"OK\", {% else %} \"message_type\": {{ priority }}, {% endif %} \"custom_fields\": { \"issue_url\": {{ url }}, \"description\": {{ description }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"related_incidents\": [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %} {% endfor %} ] }, \"state_message\": {{ description }}, \"entity_id\": {{ id }}, \"entity_display_name\": {{ ui_name }}, \"vo_annotate.u.NRAI_Link\": {{ url }} } Copy Webhook and JSON format examples Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). If you use webhooks to configure Incident Intelligence destinations, use these examples of the webhook body format and JSON schema. Webhook format and JSON example Webhook format: Name Description url Href A link to the UI where the issue can be seen. id String Unique identifier for the issue. title String The issue title. description String The description of the issue. priority Enum The issue priority. Can be Critical, High, Medium, or Low. state Enum The issue status. Can be Active, Closed, or Acknowledged. is_correlated Boolean True if the issue is based on correlated data. created_on String The date and time the issue was created (in ISO format). modified_on String The date and time the issue was modified (in ISO format). active_since String The date and time the issue was activated (in ISO format). closed_on String The date and time the issue was closed (in ISO format). sources List(String) List of the different sources that were used to send the events into Applied Intelligence (for example: PagerDuty). pathways List(Pathways) List of pathways that are associated with the issue. Each pathway contains an id and name: [{“id”: “pathway id”, “name”: “pathway name”}]. pathways[].id String The pathway ID. pathways[].name String The pathway name. incidents List(Incident) List of incidents that are attached to the issue. The list contains only the latest 100 incidents. incidents[].id String The incident ID. incidents[].events_count Integer The number of events used to create the incident. incidents[].title String The incident title. incidents[].description String The incident description. incidents[].labels Dictionary (String) A string to string mapping of the incident labels. Labels represent the unique entities that are used to describe the incident. incidents[].priority Enum The incident priority. Can be Critical, High, Medium, or Low. incidents[].sources List(String) The incident source. incidents[].state Enum(open, closed) The incident state. incidents[].opened_on String The date and time the incident was opened (in ISO format). incidents[].closed_on String The date and time the incident was closed (in ISO format). ui_name String Issue title. accumulations['alert/signal'] String Issue analysis summary golden signal/s (if applicable). accumulations['alert/components'] String Issue analysis summary golden components (if applicable). Jinja2 Default Payload Applied Intelligence uses a templating framework called Jinja2 in the Webhook interface. Here is a default Jinja2 payload to use: { \"id\": {{ id }}, \"url\": {{ url }}, \"ui_name\": {{ ui_name }}, \"description\": {{ description }}, \"priority\": {{ priority }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"active_since\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"sources\": {{ sources }}, \"incidents\": {{ incidents }}, \"pathways\": {{ pathways }}, } Copy Jinja2 Useful Syntax Below are a few useful Jinja2 commands to help you format your output. Casting a value to integer Example: “severity”: {{ priority | int }} Copy If clause to check if an attribute’s value is set Example: \"golden_signals\": {% if accumulations['alert/signal'] is defined %} {{ accumulations['alert/signal'] }} {% else %} None {% endif %} Copy For loop to iterate of an array of values: Example: \"description\": 'Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]' Copy Check if an array attribute's value is set: Example: \"hostname_field\": {% if incidents[0].labels['newrelic/tag/hostname'] is defined %} {{ incidents[0].labels['newrelic/tag/hostname'] }} {% else %} None {% endif %} Copy JSON schema Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). JSON schema template JSON schema: { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"definitions\": { \"Labels\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"LabelsSet\": { \"type\": \"array\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"$ref\": \"#/definitions/Labels\" }, \"uniqueItems\": true }, }, \"Annotations\": { \"type\": \"object\", \"title\": \"Additional contextual information about the Entity\", \"description\": \"Fields like title, description and priority can be described as annotations since\\nthey represent some additional information about the Incident.\\nFor example, the rule that creates the entity can have some logic that will create a title annotation field.\\nThe title will change according to the latest event received by the entity and as more\\nevent will keep coming the field may change, all this as a decision by the rule.\\nA different rule may decide not to populate the title at all.\\nSince a title can also be produced from the labels themselves.\", \"properties\": { \"title\": { \"type\": \"string\", \"maxLength\": 10000 }, \"description\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"patternProperties\": { \".*\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"Accumulations\": { \"type\": \"object\", \"title\": \"Accumulated data about the Incident\", \"description\": \"For example an entity with the label: host_name: foo will include a accumulated list of the\\nrelevant process names that are relevant to the entity. Accumulations will be derived from the events\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"type\": \"string\", \"maxLength\": 10000 } } }, \"IssueState\": { \"type\": \"string\", \"enum\": [ \"created\", \"active\", \"acknowledged\", \"closed\" ], \"properties\": {}, \"additionalProperties\": false }, \"Priority\": { \"type\": \"string\", \"enum\": [ \"critical\", \"high\", \"medium\", \"low\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueClosingReason\": { \"type\": \"string\", \"enum\": [ \"nacked\", \"resolved\", \"system\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueAction\": { \"type\": \"string\", \"enum\": [ \"ack\", \"snooze\", \"nack\", \"end_snooze\", \"expire_snooze\", \"star\", \"un_snooze\", \"unstar\", \"archive\", \"unarchive\", \"resolve\", \"reopen\", \"open\", \"feedback\", \"feedback_file\", \"open_ticket\", \"merge_issues\", \"active\", \"create\", \"close\", \"incident_updated\", \"confidence_changed\", \"diagnoses_changed\", \"rule_properties_changed\", \"flapping\", \"notification\", \"incident_events_limit_reached\", \"follow\", \"unfollow\", \"priority_updated\", \"comment\", \"incident_appended\", \"diagnosis_feedback\", \"flapping_delay_close\" ], \"properties\": {}, \"additionalProperties\": false }, \"StringKeyValue\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\" } }, \"JavaOptionalUuid\": { \"type\": \"string\", \"properties\": {}, \"additionalProperties\": false, \"format\": \"string-uuid\" } }, \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"customer_id\": { \"type\": \"integer\" }, \"labels_set\": { \"$ref\": \"#/definitions/LabelsSet\" }, \"annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations_version\": { \"type\": \"integer\" }, \"accumulations\": { \"$ref\": \"#/definitions/Accumulations\" }, \"state\": { \"$ref\": \"#/definitions/IssueState\" }, \"previous_state\": { \"$ref\": \"#/definitions/IssueState\" }, \"priority\": { \"$ref\": \"#/definitions/Priority\" }, \"closing_reason\": { \"oneOf\": [ { \"$ref\": \"#/definitions/IssueClosingReason\" }, { \"type\": \"null\" } ] }, \"modified_on\": { \"type\": \"integer\" }, \"created_on\": { \"type\": \"integer\" }, \"closed_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"acknowledged_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"active_since\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"assigned_to\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"created_by\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"progress_report\": { \"type\": \"array\", \"default\": [], \"items\": { \"type\": \"object\", \"properties\": { \"origin_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1 }, { \"type\": \"null\" } ] }, \"timestamp\": { \"type\": \"integer\" }, \"action_timestamp\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"origin_type\": { \"type\": \"string\", \"enum\": [ \"user\", \"system\" ] }, \"event_type\": { \"$ref\": \"#/definitions/IssueAction\" }, \"issue_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"format\": \"string-uuid\" }, { \"type\": \"null\" } ] }, \"attributes\": { \"oneOf\": [ { \"$ref\": \"#/definitions/StringKeyValue\" }, { \"type\": \"null\" } ] }, \"team_id\": { \"$ref\": \"#/definitions/JavaOptionalUuid\" } }, \"required\": [ \"timestamp\", \"origin_type\", \"event_type\" ], \"additionalProperties\": false }, \"uniqueItems\": true }, \"rule_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"maxLength\": 255 }, { \"type\": \"null\" } ] }, \"incident_ids\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"confidence\": { \"type\": \"number\", \"default\": 1.0, \"minimum\": 0.0, \"maximum\": 1.0 } }, \"required\": [ \"id\", \"customer_id\", \"labels_set\", \"annotations\", \"priority\", \"modified_on\", \"created_on\", \"confidence\" ], \"additionalProperties\": true } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 332.55853,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Incident <em>Intelligence</em> destination examples",
        "sections": "Incident <em>Intelligence</em> destination examples",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "Destinations are the data outputs to <em>Applied</em> <em>Intelligence</em>, where you can view your automatically correlated incidents. You can configure Incident <em>Intelligence</em> destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema"
      },
      "id": "6044280d64441f4af5378ed3"
    },
    {
      "sections": [
        "Use Incident Intelligence",
        "Issue summary",
        "Impacted entities map",
        "Use suggested responders",
        "Important",
        "Tip",
        "Root cause analysis",
        "Issue timeline",
        "Related activity",
        "Use decisions"
      ],
      "title": "Use Incident Intelligence",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "f7b852fa406a6e9ff88b791e4cbccc2bd20a5962",
      "image": "https://docs.newrelic.com/static/6e37cc77304398121e1a0080a57e47bb/8c557/screenshot_incident_intelligence_timeline_event_detail.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/use-incident-intelligence/",
      "published_at": "2021-06-02T18:23:21Z",
      "updated_at": "2021-05-28T11:09:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you set up Incident Intelligence, our system will begin finding issues from your data sources. In the issue feed, you can find an overview of all your issues, along with helpful information about them. You can also click any individual issue for more detail, including its analysis summary, event log, and details about correlated issues. This screenshot shows an example issue feed, which describes your issues' statuses, correlations, and more. What's the difference between an issue, incident, and event? In short, these terms are like building blocks. Events are raw data from your sources. Incidents are made up of one or more events. Issues are composed of one or more incidents. In more detail: Events indicate a state change or trigger defined by your monitoring systems. An event contains information about the affected entity, and they are almost always triggered automatically by the system. Incidents are groups of events that describe the \"symptoms\" of your system over time. These symptoms are detected by your monitoring tools, which evaluate your data streams and events. Issues are groups of incidents that describe the underlying problem of your symptoms. When a new incident is created, Incident Intelligence opens an issue and evaluates other open issues for correlations. Issue summary The Issue page is built to provide you with bottom line insights first to understand the problem, and then to minimize the time you need to resolve it. The Issue page includes the following sections: Issue summary: This section has two machine learning modules, the golden signals and the related components. Suggested responders: This section will tell you who to potentially reach out to on your team to solve a specific problem. Label sets: Label sets are focused on incidents that come from 3rd party sources, such as PagerDuty, AWS Cloudwatch, REST APIs, etc., as well as for NRQL queries. They come in the form of key:value pairs. Impacted entities: An entity is anything that has data you can monitor. Specifically, these are focused on incidents from New Relic sources, extracting the entities and providing a summary. Each entity is unique. You can see your entities in a list or on a map. Depending on the data in an issue, all four of these sections can show up together for each issue or separately. If you hover over an impacted entity application, you’ll notice a few calls to action: relevant dashboards, anomaly overview, deployment events, and entity overview. Relevant dashboards helps users in your account look at and interact with dashboards you've created that are related to an entity. The queries you've run to power the various widgets are automatically mapped to entities whenever possible and are presented back to you here for quick access and discovery. Anomaly overview will open the application's anomalies page. This is only available for applications that are set up for Proactive Detection. There are two types of deployment events: deployments and related deployments. Click Show all deployments to see all your deployment events when they arrive, or click a specific deployment to see its APM deployments page. The APM deployment page lists recent deployments and their impact on your end user and app server's Apdex scores, response times, throughput, and errors. This section will only show up if New Relic has identified applications under the impacted entities that have deployments. Impacted entities map Hover over an entity to see more information about it. An impacted entities map is available for any issue involving two or more entities. The map shows not only the affected entities, but also the services and resources directly related to those entities. Use suggested responders If you’re using PagerDuty or New Relic alerts violations as your incident notification tools, Incident Intelligence suggests relevant team members that can help resolve your issues. Incident Intelligence learns from your PagerDuty and alerts violations data to provide suggestions for each new incident. Once you receive a suggestion, you can contact the responder or search for relevant documentation that person may have written. To get started, enable PagerDuty or alerts violations as a source for Incident Intelligence. Afterwards, you can view the suggestions in two places: The issue feed, where you can also provide feedback on the suggestions. Directly within PagerDuty (both UI and API.) If you’re also using PagerDuty as a destination, the suggestions will appear in your issue notifications payload. Important This feature doesn't account for on-call availability at the time of incident. Tip In order to train the model, we use the information PagerDuty provides about individuals. We ingest incident information only, not users’ contact details. Root cause analysis Root cause analysis automatically finds potential causes for an issue and its impacted entities. It shows you why open issues occurred, which deployments contributed, and relevant error logs and attributes. With this, you can investigate the problem and reduce your mean time to resolution (MTTR). Tip Note that root cause analysis is dependent on other New Relic data sources and features. This is why root cause analysis information may not always be present for every issue. When you select an issue, you may see Root cause analysis information. Root cause analysis includes three main UI sections: Deployment events: When you set up deployments, we provide the deployment nearest to the issue creation. Changes, such as deployments, account for a high percentage of the root causes of incidents and having that information at hand can help diagnose and resolve issues. Error logs: You can explore millions of log messages with a single click and use manual querying to help you find anomalous patterns and hard-to-find problems. Attributes to investigate: We scan the distribution of attributes and surface possible causes by finding significant changes in the distribution. This section also shows changes in database and external metrics. You can also query interesting attributes. Issue timeline The issue timeline, as presented below, shows you a breakdown of: Incidents The trends taking place What incidents are active What incidents are resolved What is correlated to each other Various milestones at different issue levels In addition, you’ll see a grey line at the top of the timeline. In comparison to the visual timeline that shows the changes to each incident, the grey line represents changes to the issue. Mouse over the grey line to see details of the event. Finally, mouse over the incident to see information on the location, timing, and level of importance of a specific incident. This figure shows a particular incident populated on January 11th with a level of Critical. To view the issues in a text format, in the right hand corner, click Switch to issue log view. Related activity The issue page includes a Related activity section, which is a table displaying activity related to the incident or anomally you are are trying to analyze. You can click each line item in the table to view a unique dashboard that displays data for the entity the incident or anomally came from. The related activity section aggregates a set of incidents into a single issue, according to a rule-based system. Use decisions To further reduce noise or get improved incident correlation, you can change or customize your decisions. Decisions determine how Incident Intelligence groups incidents together. To get started, see Decisions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 313.48865,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use Incident <em>Intelligence</em>",
        "sections": "Use Incident <em>Intelligence</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " to entities whenever possible and are presented back to you here for quick access and discovery. Anomaly overview will open the application&#x27;s anomalies page. This is only available for applications that are set up for <em>Proactive</em> <em>Detection</em>. There are two types of deployment events: deployments"
      },
      "id": "6080293564441fd0669d8580"
    }
  ],
  "/docs/alerts-applied-intelligence/index": [
    {
      "sections": [
        "Incident Intelligence destination examples",
        "Destination template examples",
        "Suggested OpsGenie template example",
        "Suggested ServiceNow template example",
        "Suggested Slack template example",
        "Suggested VictorOps template example",
        "Webhook and JSON format examples",
        "Webhook format and JSON example",
        "Jinja2 Default Payload",
        "Jinja2 Useful Syntax",
        "JSON schema",
        "JSON schema template"
      ],
      "title": "Incident Intelligence destination examples",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "a516d04f8b75541a6dc9338fa3ce9645ba87d620",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/incident-intelligence-destination-examples/",
      "published_at": "2021-06-02T18:22:22Z",
      "updated_at": "2021-06-02T18:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Destinations are the data outputs to Applied Intelligence, where you can view your automatically correlated incidents. You can configure Incident Intelligence destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema. Destination template examples The following template example destinations are formatted in Jinja2. Suggested OpsGenie template example { \"alias\": {{ id }}, \"message\": {{ ui_name }}, \"source\": '{{ sources }}', \"priority\": {{ priority }}, \"details\": { \"self_url\": {{ url }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"is_correlated\": {{ is_correlated }} }, \"description\": \"\"\"Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]\"\"\" } Copy Suggested ServiceNow template example { \"short_description\": {{ ui_name }}, \"description\": 'Issue Id: {{ id }}, \\n Description: {{ description }}, \\n Sources: {{ sources }}, \\n Priority: {{ priority }}, \\n Details: { \\n self_url: {{ url }}, \\n state: {{ state }}, \\n is_correlated: {{ is_correlated }}, \\n created_on: {{ created_on }}, \\n modified_on: {{ modified_on }}, \\n activated_on: {{ active_since }}, \\n closed_on: {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \\n is_correlated: {{is_correlated}} }, \\n\\n incidents: {{ incidents }}, \\n\\n pathways: {{ pathways }}' } Copy Suggested Slack template example Go to Slack incoming WebHooks Choose the right Slack workspace and click \"Add to Slack\" Select the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In New Relic Applied Intelligence, under Incident Intelligence click Destinations Add a WebHook In the end point paste the WebHook url from slack. In the custom payload, paste the following JSON: { \"blocks\": [ { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*New Relic Incident Intelligence Alert*\" } }, { \"type\": \"divider\" }, { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*CUSTOM FIELDS*:\" }, \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue ID*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Issue Title*\" }, { \"type\": \"plain_text\", \"text\": {{ id }} }, { \"type\": \"plain_text\", \"text\": {{ ui_name }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue URL*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Description*\" }, { \"type\": \"mrkdwn\", \"text\": {{ url }} }, { \"type\": \"plain_text\", \"text\": {{ description }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*State*\" }, { \"type\": \"mrkdwn\", \"text\": \"*is_correlated*\" }, { \"type\": \"plain_text\", \"text\": {{ state }} }, { \"type\": \"plain_text\", \"text\": \"{{ is_correlated }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Created On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Modified On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ created_on }}\" }, { \"type\": \"plain_text\", \"text\": \"{{ modified_on }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Activated On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Closed On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ active_since }}\" }, { \"type\": \"plain_text\", \"text\": \"{% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Aggregated Incidents*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Monitoring Tool*\" }, { \"type\": \"plain_text\", \"text\": \"{{ incident_count }}\" }, { \"type\": \"plain_text\", \"text\": {{ sources|join(', ') }} } ] } ] } Copy Suggested VictorOps template example { \"monitoring_tool\": {{ sources }}, {% if state == 'closed' %} \"message_type\": \"OK\", {% else %} \"message_type\": {{ priority }}, {% endif %} \"custom_fields\": { \"issue_url\": {{ url }}, \"description\": {{ description }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"related_incidents\": [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %} {% endfor %} ] }, \"state_message\": {{ description }}, \"entity_id\": {{ id }}, \"entity_display_name\": {{ ui_name }}, \"vo_annotate.u.NRAI_Link\": {{ url }} } Copy Webhook and JSON format examples Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). If you use webhooks to configure Incident Intelligence destinations, use these examples of the webhook body format and JSON schema. Webhook format and JSON example Webhook format: Name Description url Href A link to the UI where the issue can be seen. id String Unique identifier for the issue. title String The issue title. description String The description of the issue. priority Enum The issue priority. Can be Critical, High, Medium, or Low. state Enum The issue status. Can be Active, Closed, or Acknowledged. is_correlated Boolean True if the issue is based on correlated data. created_on String The date and time the issue was created (in ISO format). modified_on String The date and time the issue was modified (in ISO format). active_since String The date and time the issue was activated (in ISO format). closed_on String The date and time the issue was closed (in ISO format). sources List(String) List of the different sources that were used to send the events into Applied Intelligence (for example: PagerDuty). pathways List(Pathways) List of pathways that are associated with the issue. Each pathway contains an id and name: [{“id”: “pathway id”, “name”: “pathway name”}]. pathways[].id String The pathway ID. pathways[].name String The pathway name. incidents List(Incident) List of incidents that are attached to the issue. The list contains only the latest 100 incidents. incidents[].id String The incident ID. incidents[].events_count Integer The number of events used to create the incident. incidents[].title String The incident title. incidents[].description String The incident description. incidents[].labels Dictionary (String) A string to string mapping of the incident labels. Labels represent the unique entities that are used to describe the incident. incidents[].priority Enum The incident priority. Can be Critical, High, Medium, or Low. incidents[].sources List(String) The incident source. incidents[].state Enum(open, closed) The incident state. incidents[].opened_on String The date and time the incident was opened (in ISO format). incidents[].closed_on String The date and time the incident was closed (in ISO format). ui_name String Issue title. accumulations['alert/signal'] String Issue analysis summary golden signal/s (if applicable). accumulations['alert/components'] String Issue analysis summary golden components (if applicable). Jinja2 Default Payload Applied Intelligence uses a templating framework called Jinja2 in the Webhook interface. Here is a default Jinja2 payload to use: { \"id\": {{ id }}, \"url\": {{ url }}, \"ui_name\": {{ ui_name }}, \"description\": {{ description }}, \"priority\": {{ priority }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"active_since\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"sources\": {{ sources }}, \"incidents\": {{ incidents }}, \"pathways\": {{ pathways }}, } Copy Jinja2 Useful Syntax Below are a few useful Jinja2 commands to help you format your output. Casting a value to integer Example: “severity”: {{ priority | int }} Copy If clause to check if an attribute’s value is set Example: \"golden_signals\": {% if accumulations['alert/signal'] is defined %} {{ accumulations['alert/signal'] }} {% else %} None {% endif %} Copy For loop to iterate of an array of values: Example: \"description\": 'Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]' Copy Check if an array attribute's value is set: Example: \"hostname_field\": {% if incidents[0].labels['newrelic/tag/hostname'] is defined %} {{ incidents[0].labels['newrelic/tag/hostname'] }} {% else %} None {% endif %} Copy JSON schema Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). JSON schema template JSON schema: { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"definitions\": { \"Labels\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"LabelsSet\": { \"type\": \"array\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"$ref\": \"#/definitions/Labels\" }, \"uniqueItems\": true }, }, \"Annotations\": { \"type\": \"object\", \"title\": \"Additional contextual information about the Entity\", \"description\": \"Fields like title, description and priority can be described as annotations since\\nthey represent some additional information about the Incident.\\nFor example, the rule that creates the entity can have some logic that will create a title annotation field.\\nThe title will change according to the latest event received by the entity and as more\\nevent will keep coming the field may change, all this as a decision by the rule.\\nA different rule may decide not to populate the title at all.\\nSince a title can also be produced from the labels themselves.\", \"properties\": { \"title\": { \"type\": \"string\", \"maxLength\": 10000 }, \"description\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"patternProperties\": { \".*\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"Accumulations\": { \"type\": \"object\", \"title\": \"Accumulated data about the Incident\", \"description\": \"For example an entity with the label: host_name: foo will include a accumulated list of the\\nrelevant process names that are relevant to the entity. Accumulations will be derived from the events\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"type\": \"string\", \"maxLength\": 10000 } } }, \"IssueState\": { \"type\": \"string\", \"enum\": [ \"created\", \"active\", \"acknowledged\", \"closed\" ], \"properties\": {}, \"additionalProperties\": false }, \"Priority\": { \"type\": \"string\", \"enum\": [ \"critical\", \"high\", \"medium\", \"low\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueClosingReason\": { \"type\": \"string\", \"enum\": [ \"nacked\", \"resolved\", \"system\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueAction\": { \"type\": \"string\", \"enum\": [ \"ack\", \"snooze\", \"nack\", \"end_snooze\", \"expire_snooze\", \"star\", \"un_snooze\", \"unstar\", \"archive\", \"unarchive\", \"resolve\", \"reopen\", \"open\", \"feedback\", \"feedback_file\", \"open_ticket\", \"merge_issues\", \"active\", \"create\", \"close\", \"incident_updated\", \"confidence_changed\", \"diagnoses_changed\", \"rule_properties_changed\", \"flapping\", \"notification\", \"incident_events_limit_reached\", \"follow\", \"unfollow\", \"priority_updated\", \"comment\", \"incident_appended\", \"diagnosis_feedback\", \"flapping_delay_close\" ], \"properties\": {}, \"additionalProperties\": false }, \"StringKeyValue\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\" } }, \"JavaOptionalUuid\": { \"type\": \"string\", \"properties\": {}, \"additionalProperties\": false, \"format\": \"string-uuid\" } }, \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"customer_id\": { \"type\": \"integer\" }, \"labels_set\": { \"$ref\": \"#/definitions/LabelsSet\" }, \"annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations_version\": { \"type\": \"integer\" }, \"accumulations\": { \"$ref\": \"#/definitions/Accumulations\" }, \"state\": { \"$ref\": \"#/definitions/IssueState\" }, \"previous_state\": { \"$ref\": \"#/definitions/IssueState\" }, \"priority\": { \"$ref\": \"#/definitions/Priority\" }, \"closing_reason\": { \"oneOf\": [ { \"$ref\": \"#/definitions/IssueClosingReason\" }, { \"type\": \"null\" } ] }, \"modified_on\": { \"type\": \"integer\" }, \"created_on\": { \"type\": \"integer\" }, \"closed_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"acknowledged_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"active_since\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"assigned_to\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"created_by\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"progress_report\": { \"type\": \"array\", \"default\": [], \"items\": { \"type\": \"object\", \"properties\": { \"origin_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1 }, { \"type\": \"null\" } ] }, \"timestamp\": { \"type\": \"integer\" }, \"action_timestamp\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"origin_type\": { \"type\": \"string\", \"enum\": [ \"user\", \"system\" ] }, \"event_type\": { \"$ref\": \"#/definitions/IssueAction\" }, \"issue_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"format\": \"string-uuid\" }, { \"type\": \"null\" } ] }, \"attributes\": { \"oneOf\": [ { \"$ref\": \"#/definitions/StringKeyValue\" }, { \"type\": \"null\" } ] }, \"team_id\": { \"$ref\": \"#/definitions/JavaOptionalUuid\" } }, \"required\": [ \"timestamp\", \"origin_type\", \"event_type\" ], \"additionalProperties\": false }, \"uniqueItems\": true }, \"rule_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"maxLength\": 255 }, { \"type\": \"null\" } ] }, \"incident_ids\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"confidence\": { \"type\": \"number\", \"default\": 1.0, \"minimum\": 0.0, \"maximum\": 1.0 } }, \"required\": [ \"id\", \"customer_id\", \"labels_set\", \"annotations\", \"priority\", \"modified_on\", \"created_on\", \"confidence\" ], \"additionalProperties\": true } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 2225.6245,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Incident <em>Intelligence</em> destination examples",
        "sections": "Incident <em>Intelligence</em> destination examples",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "Destinations are the data outputs to <em>Applied</em> <em>Intelligence</em>, where you can view your automatically correlated incidents. You can configure Incident <em>Intelligence</em> destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema"
      },
      "id": "6044280d64441f4af5378ed3"
    },
    {
      "sections": [
        "Expanded anomaly detection",
        "Requirements",
        "Why it matters",
        "Get started with anomaly detection",
        "Detect anomalies with a faceted NRQL query",
        "See your anomalies in one place",
        "Tip",
        "Query anomaly data",
        "Reduce the number of detected anomalies"
      ],
      "title": "Expanded anomaly detection",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Proactive detection"
      ],
      "external_id": "0b07c0b6ce27f39b5edb3e112a0f949835cbb8c6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/proactive-detection/expanded-anomaly-detection/",
      "published_at": "2021-06-02T18:27:12Z",
      "updated_at": "2021-05-31T16:43:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We’ve expanded anomaly detection coverage beyond your APM applications. Configure anomaly detection for your browser applications, mobile applications, infrastructure hosts, and nearly anything you want to monitor. Requirements Expanded anomaly detection is available as a limited beta. You can request access here. Why it matters When starting to configure alert conditions for a variety of applications and hosts, it can be difficult to know what you’ll want to be notified about ahead of time. Anomaly detection helps you distinguish between what’s typical performance in your system and where you’re starting to have trouble. Instead of creating your alert conditions manually, you can simply tell us what you want to monitor. Anomaly detection will help you identify baseline performance in your system and flags anomalous activity in your system. Get started with anomaly detection To get started with expanded anomaly detection: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Select the account you want to use to record anomaly data, then select the workload or entities you’d like to monitor. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name your configuration and save. Detect anomalies with a faceted NRQL query To detect anomalies with a faceted NRQL query: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Click Use a query instead. You may need to select an account, if you have more than one. Add one or more queries with a FACET clause. Name the query and confirm the facets you want to monitor for anomalies. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name the configuration and save. See your anomalies in one place When you set up anomaly detection, New Relic starts analyzing the golden signals of your entities and workloads. Anomalies appear in your activity feeds throughout New Relic One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL alert condition for the NrAiAnomaly event. To view anomalies, from one.newrelic.com, go to Alerts & AI > Issues & activity > Anomalies. Query anomaly data Detected anomalies are written to the NrAiAnomaly event in your NRDB account. You can learn more about this event and how to query it here. Reduce the number of detected anomalies If you’re seeing too many anomalies, the first step is to make sure your sensitivity level is set to Low. If it’s already set to Low, you can define specific thresholds to distinguish between normal and anomalous behavior. To define custom thresholds: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab and the configuration you want to modify. Select an entity or workload, and then change the sensitivity level. You can use custom sensitivity to define specific thresholds for different entity types.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1943.0447,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " request access here. Why it matters When starting to configure <em>alert</em> conditions for a variety of applications and hosts, it can be difficult to know what you’ll want to be notified about ahead of time. Anomaly detection helps you distinguish between what’s typical performance in your system and where"
      },
      "id": "60b5124064441ff965e2cb01"
    },
    {
      "sections": [
        "Use Incident Intelligence",
        "Issue summary",
        "Impacted entities map",
        "Use suggested responders",
        "Important",
        "Tip",
        "Root cause analysis",
        "Issue timeline",
        "Related activity",
        "Use decisions"
      ],
      "title": "Use Incident Intelligence",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "f7b852fa406a6e9ff88b791e4cbccc2bd20a5962",
      "image": "https://docs.newrelic.com/static/6e37cc77304398121e1a0080a57e47bb/8c557/screenshot_incident_intelligence_timeline_event_detail.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/use-incident-intelligence/",
      "published_at": "2021-06-02T18:23:21Z",
      "updated_at": "2021-05-28T11:09:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you set up Incident Intelligence, our system will begin finding issues from your data sources. In the issue feed, you can find an overview of all your issues, along with helpful information about them. You can also click any individual issue for more detail, including its analysis summary, event log, and details about correlated issues. This screenshot shows an example issue feed, which describes your issues' statuses, correlations, and more. What's the difference between an issue, incident, and event? In short, these terms are like building blocks. Events are raw data from your sources. Incidents are made up of one or more events. Issues are composed of one or more incidents. In more detail: Events indicate a state change or trigger defined by your monitoring systems. An event contains information about the affected entity, and they are almost always triggered automatically by the system. Incidents are groups of events that describe the \"symptoms\" of your system over time. These symptoms are detected by your monitoring tools, which evaluate your data streams and events. Issues are groups of incidents that describe the underlying problem of your symptoms. When a new incident is created, Incident Intelligence opens an issue and evaluates other open issues for correlations. Issue summary The Issue page is built to provide you with bottom line insights first to understand the problem, and then to minimize the time you need to resolve it. The Issue page includes the following sections: Issue summary: This section has two machine learning modules, the golden signals and the related components. Suggested responders: This section will tell you who to potentially reach out to on your team to solve a specific problem. Label sets: Label sets are focused on incidents that come from 3rd party sources, such as PagerDuty, AWS Cloudwatch, REST APIs, etc., as well as for NRQL queries. They come in the form of key:value pairs. Impacted entities: An entity is anything that has data you can monitor. Specifically, these are focused on incidents from New Relic sources, extracting the entities and providing a summary. Each entity is unique. You can see your entities in a list or on a map. Depending on the data in an issue, all four of these sections can show up together for each issue or separately. If you hover over an impacted entity application, you’ll notice a few calls to action: relevant dashboards, anomaly overview, deployment events, and entity overview. Relevant dashboards helps users in your account look at and interact with dashboards you've created that are related to an entity. The queries you've run to power the various widgets are automatically mapped to entities whenever possible and are presented back to you here for quick access and discovery. Anomaly overview will open the application's anomalies page. This is only available for applications that are set up for Proactive Detection. There are two types of deployment events: deployments and related deployments. Click Show all deployments to see all your deployment events when they arrive, or click a specific deployment to see its APM deployments page. The APM deployment page lists recent deployments and their impact on your end user and app server's Apdex scores, response times, throughput, and errors. This section will only show up if New Relic has identified applications under the impacted entities that have deployments. Impacted entities map Hover over an entity to see more information about it. An impacted entities map is available for any issue involving two or more entities. The map shows not only the affected entities, but also the services and resources directly related to those entities. Use suggested responders If you’re using PagerDuty or New Relic alerts violations as your incident notification tools, Incident Intelligence suggests relevant team members that can help resolve your issues. Incident Intelligence learns from your PagerDuty and alerts violations data to provide suggestions for each new incident. Once you receive a suggestion, you can contact the responder or search for relevant documentation that person may have written. To get started, enable PagerDuty or alerts violations as a source for Incident Intelligence. Afterwards, you can view the suggestions in two places: The issue feed, where you can also provide feedback on the suggestions. Directly within PagerDuty (both UI and API.) If you’re also using PagerDuty as a destination, the suggestions will appear in your issue notifications payload. Important This feature doesn't account for on-call availability at the time of incident. Tip In order to train the model, we use the information PagerDuty provides about individuals. We ingest incident information only, not users’ contact details. Root cause analysis Root cause analysis automatically finds potential causes for an issue and its impacted entities. It shows you why open issues occurred, which deployments contributed, and relevant error logs and attributes. With this, you can investigate the problem and reduce your mean time to resolution (MTTR). Tip Note that root cause analysis is dependent on other New Relic data sources and features. This is why root cause analysis information may not always be present for every issue. When you select an issue, you may see Root cause analysis information. Root cause analysis includes three main UI sections: Deployment events: When you set up deployments, we provide the deployment nearest to the issue creation. Changes, such as deployments, account for a high percentage of the root causes of incidents and having that information at hand can help diagnose and resolve issues. Error logs: You can explore millions of log messages with a single click and use manual querying to help you find anomalous patterns and hard-to-find problems. Attributes to investigate: We scan the distribution of attributes and surface possible causes by finding significant changes in the distribution. This section also shows changes in database and external metrics. You can also query interesting attributes. Issue timeline The issue timeline, as presented below, shows you a breakdown of: Incidents The trends taking place What incidents are active What incidents are resolved What is correlated to each other Various milestones at different issue levels In addition, you’ll see a grey line at the top of the timeline. In comparison to the visual timeline that shows the changes to each incident, the grey line represents changes to the issue. Mouse over the grey line to see details of the event. Finally, mouse over the incident to see information on the location, timing, and level of importance of a specific incident. This figure shows a particular incident populated on January 11th with a level of Critical. To view the issues in a text format, in the right hand corner, click Switch to issue log view. Related activity The issue page includes a Related activity section, which is a table displaying activity related to the incident or anomally you are are trying to analyze. You can click each line item in the table to view a unique dashboard that displays data for the entity the incident or anomally came from. The related activity section aggregates a set of incidents into a single issue, according to a rule-based system. Use decisions To further reduce noise or get improved incident correlation, you can change or customize your decisions. Decisions determine how Incident Intelligence groups incidents together. To get started, see Decisions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 1683.2744,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use Incident <em>Intelligence</em>",
        "sections": "Use Incident <em>Intelligence</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": ". The map shows not only the affected entities, but also the services and resources directly related to those entities. Use suggested responders If you’re using PagerDuty or New Relic <em>alerts</em> violations as your incident notification tools, Incident <em>Intelligence</em> suggests relevant team members that can"
      },
      "id": "6080293564441fd0669d8580"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/alert-custom-violation-descriptions": [
    {
      "sections": [
        "Expanded anomaly detection",
        "Requirements",
        "Why it matters",
        "Get started with anomaly detection",
        "Detect anomalies with a faceted NRQL query",
        "See your anomalies in one place",
        "Tip",
        "Query anomaly data",
        "Reduce the number of detected anomalies"
      ],
      "title": "Expanded anomaly detection",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Proactive detection"
      ],
      "external_id": "0b07c0b6ce27f39b5edb3e112a0f949835cbb8c6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/proactive-detection/expanded-anomaly-detection/",
      "published_at": "2021-06-02T18:27:12Z",
      "updated_at": "2021-05-31T16:43:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We’ve expanded anomaly detection coverage beyond your APM applications. Configure anomaly detection for your browser applications, mobile applications, infrastructure hosts, and nearly anything you want to monitor. Requirements Expanded anomaly detection is available as a limited beta. You can request access here. Why it matters When starting to configure alert conditions for a variety of applications and hosts, it can be difficult to know what you’ll want to be notified about ahead of time. Anomaly detection helps you distinguish between what’s typical performance in your system and where you’re starting to have trouble. Instead of creating your alert conditions manually, you can simply tell us what you want to monitor. Anomaly detection will help you identify baseline performance in your system and flags anomalous activity in your system. Get started with anomaly detection To get started with expanded anomaly detection: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Select the account you want to use to record anomaly data, then select the workload or entities you’d like to monitor. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name your configuration and save. Detect anomalies with a faceted NRQL query To detect anomalies with a faceted NRQL query: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Click Use a query instead. You may need to select an account, if you have more than one. Add one or more queries with a FACET clause. Name the query and confirm the facets you want to monitor for anomalies. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name the configuration and save. See your anomalies in one place When you set up anomaly detection, New Relic starts analyzing the golden signals of your entities and workloads. Anomalies appear in your activity feeds throughout New Relic One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL alert condition for the NrAiAnomaly event. To view anomalies, from one.newrelic.com, go to Alerts & AI > Issues & activity > Anomalies. Query anomaly data Detected anomalies are written to the NrAiAnomaly event in your NRDB account. You can learn more about this event and how to query it here. Reduce the number of detected anomalies If you’re seeing too many anomalies, the first step is to make sure your sensitivity level is set to Low. If it’s already set to Low, you can define specific thresholds to distinguish between normal and anomalous behavior. To define custom thresholds: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab and the configuration you want to modify. Select an entity or workload, and then change the sensitivity level. You can use custom sensitivity to define specific thresholds for different entity types.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 229.84436,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " feeds throughout <em>New</em> <em>Relic</em> One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL <em>alert</em>"
      },
      "id": "60b5124064441ff965e2cb01"
    },
    {
      "sections": [
        "Update or disable policies and conditions",
        "Policy maintenance quick reference",
        "Add or remove policies assigned to a channel",
        "Change a policy name",
        "Check policy user assignment",
        "Check policy channel assignment",
        "Create a new policy",
        "Condition maintenance quick reference",
        "Add more conditions",
        "Copy a condition",
        "Change how threshold violations roll up into incidents",
        "Check for entities (targets) assigned to a policy",
        "Tip",
        "Change a condition",
        "Link to Incident Intelligence",
        "Disable or delete policies and conditions",
        "Disable or re-enable a condition",
        "Disable a policy",
        "Delete policy conditions",
        "Delete a policy"
      ],
      "title": "Update or disable policies and conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert policies"
      ],
      "external_id": "4a6c5107cd6af696df6a3fb0651c6a1bde7daf36",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-policies/update-or-disable-policies-conditions/",
      "published_at": "2021-05-28T11:10:28Z",
      "updated_at": "2021-05-21T15:35:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you create a policy, you can: Add more conditions to the policy. Edit the conditions' names, targets, or thresholds. Disable conditions. Continue the policy setup process by adding one or more notification channels to it. Rename or delete the policy. The user interface shows a Last modified timestamp for any changes to policies, including their conditions and notification channels. Policy maintenance quick reference Here is a quick reference which also includes links to more detailed information and procedures for maintaining your policies. Add or remove policies assigned to a channel To add or remove policies assigned to a channel: In the one.newrelic.com top nav, click Alerts & AI, click Notification channels, then (select a channel). Click Alert policies, then (select a policy). From the selected policy, use the windows to select, remove, or clear all. Change a policy name To rename a policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Click the policy name to edit it, then type a meaningful name for the policy (maximum 64 characters). Check policy user assignment To check whether an account user has been assigned any policies: In the one.newrelic.com top nav, click Alerts & AI, click Policies, (select a policy), then click Notification channels. Select a user, and then click Alert policies. Check policy channel assignment To check whether a notification channel has any policies assigned to it: In the one.newrelic.com top nav, click Alerts & AI, click Notification channels. The Policy subscriptions column lists how many policies are assigned to the channel. Create a new policy To create a new alert policy: In the one.newrelic.com top nav, click Alerts & AI, click Policies. Click New alert policy. Follow standard procedures to complete the basic setup process. Condition maintenance quick reference Here's a quick reference for maintaining a policy conditions. This includes the condition's entities (targets), Warning (yellow) and Critical (red) thresholds, and runbook URL. Add more conditions To add more conditions to a policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then click Add a condition. OR To copy a condition from any policy and add it to another policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then click Copy. Copy a condition To copy an existing condition, including its targets and thresholds, and add it to another policy for the selected account: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). From the policy's list of one or more Alert conditions, click Copy. From the Copy alert condition list, search or scroll the list to select the policy where you want to add this condition. Optional: Change the condition's name if necessary. Select Save. By default, the copied condition will be added to the selected alert policy in a Disabled state. Follow standard procedures to add or copy additional conditions to the alert policy, and then Enable the condition as needed. Change how threshold violations roll up into incidents To select how violations to your thresholds are grouped into incident records (by policy, by condition, or by target and condition): In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Click Incident preference. Check for entities (targets) assigned to a policy To check whether an entity (target) has any policies assigned: Go to the product (APM, Browser, etc.). From the selected product's index, check whether the entity's color-coded health status is light green with an icon. Tip Exception: Infrastructure does not use this feature. Change a condition To change a policy condition: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Then, from the list of Alert conditions for the selected policy: To change the condition's name, click Edit. To add, change, or remove targets (entities), select the name or number of targets for the condition, and then select Browse and select targets. To update the values for the required Critical (red) or optional Warning (yellow) thresholds, select the existing value. To update the condition's runbook URL, select the condition's Thresholds. Link to Incident Intelligence If you use Applied Intelligence, you can connect your conditions to Incident Intelligence. To do this, switch the Connect to Incident Intelligence to ON. Disable or delete policies and conditions If you disable or delete a policy, we'll continue to apply any other policies assigned to the product entity (target). If you remove all policies for the entity, its color-coded health status indicator will appear light green with an icon. Disable or re-enable a condition You can enable or disable any policy conditions, and the policy will continue to apply. To disable or re-enable a condition: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Then, from the list of Alert conditions, (select a condition). Click the On/Off switch to toggle it. Tip For Infrastructure conditions, use the checkbox at the bottom of the condition edit screen, then save the condition. If you copy a condition, it is automatically saved in the new policy as disabled (Off), even if the condition was enabled (On) in the original policy. Disable a policy You can't disable a policy directly. However, you can disable all of the policy's conditions. When you disable all of the conditions, the policy will continue to appear on the Alert policies index. The policy itself isn't disabled, and you can re-enable any or all of its conditions at any time. Delete policy conditions If a policy has multiple conditions, you can delete any or all of them, and the remaining conditions for the policy will continue to apply. To turn a condition off but keep it with the policy, disable it. To delete one or more conditions: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). From the list of Alert conditions, (select a condition), then click Delete. Tip If you don't see the delete button, your account admin may have disabled condition deletion for your organization. Delete a policy If you delete any of your account's policies, you can't restore them. Instead, you must re-create them if necessary. To delete a policy completely: In the one.newrelic.com top nav, click Alerts & AI, then click Alert policies. From the policy row, click the delete icon. Any notification channels associated with a deleted or disabled policy will remain. You must delete notification channels or remove them individually as necessary. You will still be able to view incidents and event violations related to the deleted policy. However, these records will be read only.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 212.1778,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Update or disable policies <em>and</em> <em>conditions</em>",
        "sections": "Update or disable policies <em>and</em> <em>conditions</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " to it: In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click Notification channels. The Policy subscriptions column lists how many policies are assigned to the channel. Create a <em>new</em> policy To create a <em>new</em> <em>alert</em> policy: In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click Policies. Click <em>New</em> <em>alert</em> policy. Follow"
      },
      "id": "604404ec28ccbc62492c6098"
    },
    {
      "sections": [
        "Create baseline alert conditions",
        "How it works",
        "Set baseline thresholds",
        "Faceted baseline conditions",
        "Baseline rules and settings",
        "Rules governing creation of baseline",
        "Baseline direction: select upper or lower ranges",
        "Preview chart: select 2 or 7 days"
      ],
      "title": "Create baseline alert conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "a144b0cc3c5eed1c31dbfcd079959bbd5496346a",
      "image": "https://docs.newrelic.com/static/3be661b029a5f41d3da75175a0259fb9/c1b63/new-relic-baseline-alerts-direction-image-examples_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-baseline-alert-conditions/",
      "published_at": "2021-05-28T03:27:17Z",
      "updated_at": "2021-05-16T08:44:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use baseline conditions to define violation thresholds that adjust to the behavior of your data. Baseline alerting is useful for creating conditions that: Only notify you when data is behaving abnormally. Dynamically adjust to changing data and trends, including daily or weekly trends. In addition, baseline alerting works well with new applications when you do not yet have known behaviors. How it works When you choose a data source (for example, an APM metric) for a baseline condition, we'll use the past values of that data to dynamically predict the data's near-future behavior. The line of that predicted future behavior for that value is called a baseline. It appears as a dotted black line on the preview chart in the baseline condition UI. You'll use the baseline alert condition UI to: Adjust how sensitive the condition is to fluctuations in the data source. Set the behavior that will trigger a violation (for example: \"deviating for more than five minutes\"). Set whether you want the condition to check for upper violations, lower violations, or both. When your data escapes the predicted \"normal\" behavior and meets the criteria you've chosen, you'll receive a notification. Set baseline thresholds one.newrelic.com > AI & Alerts > Policies > (create or select policy) > Create alert condition: Baseline alert conditions give you the ability to set intelligent, self-adjusting thresholds that only generate violations when abnormal behavior is detected. To create a baseline condition: When you start to create a condition, choose one of the following data sources: NRQL: Create a NRQL condition and then choose baseline APM: Application metric baseline Browser: Metric baseline Here are some tips for setting baseline thresholds: Set the baseline direction to monitor violations that happen either above or below the baseline. Set the preview chart to either 2 days or 7 days of displayed data. (Not applicable for NRQL alert conditions.) Use the slider bar to adjust the Critical threshold sensitivity, represented in the preview chart by the light gray area around the baseline. The tighter the band around the baseline, the more sensitive it is and the more violations it will generate. Optional: You can create a Warning threshold (the darker gray area around the baseline). For NRQL alerts, see the allowed types of NRQL queries. If the alert condition applies to multiple apps, you can select a choice from the dropdown above the chart to use different metrics. (Not applicable for NRQL alert conditions.) Faceted baseline conditions NRQL alerts conditions support faceted baselines. In the chart legend, click a time series to scope it to a single facet. Once you've run a faceted NRQL query for a baseline condition, you can scope your results to a single baseline. Click Return to full timeseries list to go back to seeing all your facets. The single time series shows the baseline, threshold band, and one or more violation regions, if there are any. Baseline rules and settings Here are some details about how the UI works: Rules governing creation of baseline The algorithm for baseline conditions is mathematically complex. Here are some of the major rules governing its predictive abilities: Data trait Baseline rules Age of data On initial creation, the baseline is calculated using between 1 to 4 weeks of data, depending on data availability and baseline type. After its creation, the algorithm will take into account ongoing data fluctuations over a long time period, although greater weight is given to more recent data. For data that has only existed for a short time, the baseline will likely fluctuate a good deal and not be very accurate. This is because there is not yet enough data to determine its usual values and behavior. The more history the data has, the more accurate the baseline and thresholds will become. Consistency of data For metric values that remain in a consistent range or that trend slowly and steadily, their more predictable behavior means that their thresholds will become tighter around the baseline. Data that is more varied and unpredictable will have looser (wider) thresholds. Regular fluctuations For shorter-than-one-week cyclical fluctuations (such as weekly Wednesday 1pm deployments or nightly reports), the baseline algorithm looks for these cyclical fluctuations and attempts to adjust to them. Baseline direction: select upper or lower ranges You can choose whether you want the condition to violate for behavior that goes above the baseline (\"upper\") or that goes below the baseline (\"lower\"), or that goes either above or below. You choose these with the Baseline direction selector. Example use cases for this: You might use the Upper setting for a data source like error rate, because you generally are only concerned if it goes up, and aren't concerned if it goes down. You might use the Lower setting for a data source like throughput, because sudden upward fluctuations are quite common, but a large sudden downswing would be a sign of a problem. Here are examples of how large fluctuations in your data would be treated under the different baseline direction settings. The red areas represent violations. Preview chart: select 2 or 7 days When setting thresholds, the preview chart has an option for displaying Since 2 days ago or Since 7 days ago. These selections are not the time period used to compute the baseline; they are only the time range used for a preview display. For more about the time range used to calculate the baseline, see the algorithm rules.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.87762,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create baseline <em>alert</em> <em>conditions</em>",
        "sections": "Create baseline <em>alert</em> <em>conditions</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": ". Set baseline thresholds one.newrelic.com &gt; AI &amp; <em>Alerts</em> &gt; Policies &gt; (create or select policy) &gt; Create <em>alert</em> condition: Baseline <em>alert</em> <em>conditions</em> give you the ability to set intelligent, self-adjusting thresholds that only generate violations when abnormal behavior is detected. To create a baseline"
      },
      "id": "6044095ee7b9d214955799e9"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/apm-metric-alert-conditions": [
    {
      "sections": [
        "Expanded anomaly detection",
        "Requirements",
        "Why it matters",
        "Get started with anomaly detection",
        "Detect anomalies with a faceted NRQL query",
        "See your anomalies in one place",
        "Tip",
        "Query anomaly data",
        "Reduce the number of detected anomalies"
      ],
      "title": "Expanded anomaly detection",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Proactive detection"
      ],
      "external_id": "0b07c0b6ce27f39b5edb3e112a0f949835cbb8c6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/proactive-detection/expanded-anomaly-detection/",
      "published_at": "2021-06-02T18:27:12Z",
      "updated_at": "2021-05-31T16:43:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We’ve expanded anomaly detection coverage beyond your APM applications. Configure anomaly detection for your browser applications, mobile applications, infrastructure hosts, and nearly anything you want to monitor. Requirements Expanded anomaly detection is available as a limited beta. You can request access here. Why it matters When starting to configure alert conditions for a variety of applications and hosts, it can be difficult to know what you’ll want to be notified about ahead of time. Anomaly detection helps you distinguish between what’s typical performance in your system and where you’re starting to have trouble. Instead of creating your alert conditions manually, you can simply tell us what you want to monitor. Anomaly detection will help you identify baseline performance in your system and flags anomalous activity in your system. Get started with anomaly detection To get started with expanded anomaly detection: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Select the account you want to use to record anomaly data, then select the workload or entities you’d like to monitor. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name your configuration and save. Detect anomalies with a faceted NRQL query To detect anomalies with a faceted NRQL query: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Click Use a query instead. You may need to select an account, if you have more than one. Add one or more queries with a FACET clause. Name the query and confirm the facets you want to monitor for anomalies. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name the configuration and save. See your anomalies in one place When you set up anomaly detection, New Relic starts analyzing the golden signals of your entities and workloads. Anomalies appear in your activity feeds throughout New Relic One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL alert condition for the NrAiAnomaly event. To view anomalies, from one.newrelic.com, go to Alerts & AI > Issues & activity > Anomalies. Query anomaly data Detected anomalies are written to the NrAiAnomaly event in your NRDB account. You can learn more about this event and how to query it here. Reduce the number of detected anomalies If you’re seeing too many anomalies, the first step is to make sure your sensitivity level is set to Low. If it’s already set to Low, you can define specific thresholds to distinguish between normal and anomalous behavior. To define custom thresholds: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab and the configuration you want to modify. Select an entity or workload, and then change the sensitivity level. You can use custom sensitivity to define specific thresholds for different entity types.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 229.84421,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " feeds throughout <em>New</em> <em>Relic</em> One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL <em>alert</em>"
      },
      "id": "60b5124064441ff965e2cb01"
    },
    {
      "sections": [
        "Update or disable policies and conditions",
        "Policy maintenance quick reference",
        "Add or remove policies assigned to a channel",
        "Change a policy name",
        "Check policy user assignment",
        "Check policy channel assignment",
        "Create a new policy",
        "Condition maintenance quick reference",
        "Add more conditions",
        "Copy a condition",
        "Change how threshold violations roll up into incidents",
        "Check for entities (targets) assigned to a policy",
        "Tip",
        "Change a condition",
        "Link to Incident Intelligence",
        "Disable or delete policies and conditions",
        "Disable or re-enable a condition",
        "Disable a policy",
        "Delete policy conditions",
        "Delete a policy"
      ],
      "title": "Update or disable policies and conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert policies"
      ],
      "external_id": "4a6c5107cd6af696df6a3fb0651c6a1bde7daf36",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-policies/update-or-disable-policies-conditions/",
      "published_at": "2021-05-28T11:10:28Z",
      "updated_at": "2021-05-21T15:35:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you create a policy, you can: Add more conditions to the policy. Edit the conditions' names, targets, or thresholds. Disable conditions. Continue the policy setup process by adding one or more notification channels to it. Rename or delete the policy. The user interface shows a Last modified timestamp for any changes to policies, including their conditions and notification channels. Policy maintenance quick reference Here is a quick reference which also includes links to more detailed information and procedures for maintaining your policies. Add or remove policies assigned to a channel To add or remove policies assigned to a channel: In the one.newrelic.com top nav, click Alerts & AI, click Notification channels, then (select a channel). Click Alert policies, then (select a policy). From the selected policy, use the windows to select, remove, or clear all. Change a policy name To rename a policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Click the policy name to edit it, then type a meaningful name for the policy (maximum 64 characters). Check policy user assignment To check whether an account user has been assigned any policies: In the one.newrelic.com top nav, click Alerts & AI, click Policies, (select a policy), then click Notification channels. Select a user, and then click Alert policies. Check policy channel assignment To check whether a notification channel has any policies assigned to it: In the one.newrelic.com top nav, click Alerts & AI, click Notification channels. The Policy subscriptions column lists how many policies are assigned to the channel. Create a new policy To create a new alert policy: In the one.newrelic.com top nav, click Alerts & AI, click Policies. Click New alert policy. Follow standard procedures to complete the basic setup process. Condition maintenance quick reference Here's a quick reference for maintaining a policy conditions. This includes the condition's entities (targets), Warning (yellow) and Critical (red) thresholds, and runbook URL. Add more conditions To add more conditions to a policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then click Add a condition. OR To copy a condition from any policy and add it to another policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then click Copy. Copy a condition To copy an existing condition, including its targets and thresholds, and add it to another policy for the selected account: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). From the policy's list of one or more Alert conditions, click Copy. From the Copy alert condition list, search or scroll the list to select the policy where you want to add this condition. Optional: Change the condition's name if necessary. Select Save. By default, the copied condition will be added to the selected alert policy in a Disabled state. Follow standard procedures to add or copy additional conditions to the alert policy, and then Enable the condition as needed. Change how threshold violations roll up into incidents To select how violations to your thresholds are grouped into incident records (by policy, by condition, or by target and condition): In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Click Incident preference. Check for entities (targets) assigned to a policy To check whether an entity (target) has any policies assigned: Go to the product (APM, Browser, etc.). From the selected product's index, check whether the entity's color-coded health status is light green with an icon. Tip Exception: Infrastructure does not use this feature. Change a condition To change a policy condition: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Then, from the list of Alert conditions for the selected policy: To change the condition's name, click Edit. To add, change, or remove targets (entities), select the name or number of targets for the condition, and then select Browse and select targets. To update the values for the required Critical (red) or optional Warning (yellow) thresholds, select the existing value. To update the condition's runbook URL, select the condition's Thresholds. Link to Incident Intelligence If you use Applied Intelligence, you can connect your conditions to Incident Intelligence. To do this, switch the Connect to Incident Intelligence to ON. Disable or delete policies and conditions If you disable or delete a policy, we'll continue to apply any other policies assigned to the product entity (target). If you remove all policies for the entity, its color-coded health status indicator will appear light green with an icon. Disable or re-enable a condition You can enable or disable any policy conditions, and the policy will continue to apply. To disable or re-enable a condition: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Then, from the list of Alert conditions, (select a condition). Click the On/Off switch to toggle it. Tip For Infrastructure conditions, use the checkbox at the bottom of the condition edit screen, then save the condition. If you copy a condition, it is automatically saved in the new policy as disabled (Off), even if the condition was enabled (On) in the original policy. Disable a policy You can't disable a policy directly. However, you can disable all of the policy's conditions. When you disable all of the conditions, the policy will continue to appear on the Alert policies index. The policy itself isn't disabled, and you can re-enable any or all of its conditions at any time. Delete policy conditions If a policy has multiple conditions, you can delete any or all of them, and the remaining conditions for the policy will continue to apply. To turn a condition off but keep it with the policy, disable it. To delete one or more conditions: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). From the list of Alert conditions, (select a condition), then click Delete. Tip If you don't see the delete button, your account admin may have disabled condition deletion for your organization. Delete a policy If you delete any of your account's policies, you can't restore them. Instead, you must re-create them if necessary. To delete a policy completely: In the one.newrelic.com top nav, click Alerts & AI, then click Alert policies. From the policy row, click the delete icon. Any notification channels associated with a deleted or disabled policy will remain. You must delete notification channels or remove them individually as necessary. You will still be able to view incidents and event violations related to the deleted policy. However, these records will be read only.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 212.17773,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Update or disable policies <em>and</em> <em>conditions</em>",
        "sections": "Update or disable policies <em>and</em> <em>conditions</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " to it: In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click Notification channels. The Policy subscriptions column lists how many policies are assigned to the channel. Create a <em>new</em> policy To create a <em>new</em> <em>alert</em> policy: In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click Policies. Click <em>New</em> <em>alert</em> policy. Follow"
      },
      "id": "604404ec28ccbc62492c6098"
    },
    {
      "sections": [
        "Create baseline alert conditions",
        "How it works",
        "Set baseline thresholds",
        "Faceted baseline conditions",
        "Baseline rules and settings",
        "Rules governing creation of baseline",
        "Baseline direction: select upper or lower ranges",
        "Preview chart: select 2 or 7 days"
      ],
      "title": "Create baseline alert conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "a144b0cc3c5eed1c31dbfcd079959bbd5496346a",
      "image": "https://docs.newrelic.com/static/3be661b029a5f41d3da75175a0259fb9/c1b63/new-relic-baseline-alerts-direction-image-examples_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-baseline-alert-conditions/",
      "published_at": "2021-05-28T03:27:17Z",
      "updated_at": "2021-05-16T08:44:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use baseline conditions to define violation thresholds that adjust to the behavior of your data. Baseline alerting is useful for creating conditions that: Only notify you when data is behaving abnormally. Dynamically adjust to changing data and trends, including daily or weekly trends. In addition, baseline alerting works well with new applications when you do not yet have known behaviors. How it works When you choose a data source (for example, an APM metric) for a baseline condition, we'll use the past values of that data to dynamically predict the data's near-future behavior. The line of that predicted future behavior for that value is called a baseline. It appears as a dotted black line on the preview chart in the baseline condition UI. You'll use the baseline alert condition UI to: Adjust how sensitive the condition is to fluctuations in the data source. Set the behavior that will trigger a violation (for example: \"deviating for more than five minutes\"). Set whether you want the condition to check for upper violations, lower violations, or both. When your data escapes the predicted \"normal\" behavior and meets the criteria you've chosen, you'll receive a notification. Set baseline thresholds one.newrelic.com > AI & Alerts > Policies > (create or select policy) > Create alert condition: Baseline alert conditions give you the ability to set intelligent, self-adjusting thresholds that only generate violations when abnormal behavior is detected. To create a baseline condition: When you start to create a condition, choose one of the following data sources: NRQL: Create a NRQL condition and then choose baseline APM: Application metric baseline Browser: Metric baseline Here are some tips for setting baseline thresholds: Set the baseline direction to monitor violations that happen either above or below the baseline. Set the preview chart to either 2 days or 7 days of displayed data. (Not applicable for NRQL alert conditions.) Use the slider bar to adjust the Critical threshold sensitivity, represented in the preview chart by the light gray area around the baseline. The tighter the band around the baseline, the more sensitive it is and the more violations it will generate. Optional: You can create a Warning threshold (the darker gray area around the baseline). For NRQL alerts, see the allowed types of NRQL queries. If the alert condition applies to multiple apps, you can select a choice from the dropdown above the chart to use different metrics. (Not applicable for NRQL alert conditions.) Faceted baseline conditions NRQL alerts conditions support faceted baselines. In the chart legend, click a time series to scope it to a single facet. Once you've run a faceted NRQL query for a baseline condition, you can scope your results to a single baseline. Click Return to full timeseries list to go back to seeing all your facets. The single time series shows the baseline, threshold band, and one or more violation regions, if there are any. Baseline rules and settings Here are some details about how the UI works: Rules governing creation of baseline The algorithm for baseline conditions is mathematically complex. Here are some of the major rules governing its predictive abilities: Data trait Baseline rules Age of data On initial creation, the baseline is calculated using between 1 to 4 weeks of data, depending on data availability and baseline type. After its creation, the algorithm will take into account ongoing data fluctuations over a long time period, although greater weight is given to more recent data. For data that has only existed for a short time, the baseline will likely fluctuate a good deal and not be very accurate. This is because there is not yet enough data to determine its usual values and behavior. The more history the data has, the more accurate the baseline and thresholds will become. Consistency of data For metric values that remain in a consistent range or that trend slowly and steadily, their more predictable behavior means that their thresholds will become tighter around the baseline. Data that is more varied and unpredictable will have looser (wider) thresholds. Regular fluctuations For shorter-than-one-week cyclical fluctuations (such as weekly Wednesday 1pm deployments or nightly reports), the baseline algorithm looks for these cyclical fluctuations and attempts to adjust to them. Baseline direction: select upper or lower ranges You can choose whether you want the condition to violate for behavior that goes above the baseline (\"upper\") or that goes below the baseline (\"lower\"), or that goes either above or below. You choose these with the Baseline direction selector. Example use cases for this: You might use the Upper setting for a data source like error rate, because you generally are only concerned if it goes up, and aren't concerned if it goes down. You might use the Lower setting for a data source like throughput, because sudden upward fluctuations are quite common, but a large sudden downswing would be a sign of a problem. Here are examples of how large fluctuations in your data would be treated under the different baseline direction settings. The red areas represent violations. Preview chart: select 2 or 7 days When setting thresholds, the preview chart has an option for displaying Since 2 days ago or Since 7 days ago. These selections are not the time period used to compute the baseline; they are only the time range used for a preview display. For more about the time range used to calculate the baseline, see the algorithm rules.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.8776,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create baseline <em>alert</em> <em>conditions</em>",
        "sections": "Create baseline <em>alert</em> <em>conditions</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": ". Set baseline thresholds one.newrelic.com &gt; AI &amp; <em>Alerts</em> &gt; Policies &gt; (create or select policy) &gt; Create <em>alert</em> condition: Baseline <em>alert</em> <em>conditions</em> give you the ability to set intelligent, self-adjusting thresholds that only generate violations when abnormal behavior is detected. To create a baseline"
      },
      "id": "6044095ee7b9d214955799e9"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-alert-conditions": [
    {
      "sections": [
        "Expanded anomaly detection",
        "Requirements",
        "Why it matters",
        "Get started with anomaly detection",
        "Detect anomalies with a faceted NRQL query",
        "See your anomalies in one place",
        "Tip",
        "Query anomaly data",
        "Reduce the number of detected anomalies"
      ],
      "title": "Expanded anomaly detection",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Proactive detection"
      ],
      "external_id": "0b07c0b6ce27f39b5edb3e112a0f949835cbb8c6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/proactive-detection/expanded-anomaly-detection/",
      "published_at": "2021-06-02T18:27:12Z",
      "updated_at": "2021-05-31T16:43:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We’ve expanded anomaly detection coverage beyond your APM applications. Configure anomaly detection for your browser applications, mobile applications, infrastructure hosts, and nearly anything you want to monitor. Requirements Expanded anomaly detection is available as a limited beta. You can request access here. Why it matters When starting to configure alert conditions for a variety of applications and hosts, it can be difficult to know what you’ll want to be notified about ahead of time. Anomaly detection helps you distinguish between what’s typical performance in your system and where you’re starting to have trouble. Instead of creating your alert conditions manually, you can simply tell us what you want to monitor. Anomaly detection will help you identify baseline performance in your system and flags anomalous activity in your system. Get started with anomaly detection To get started with expanded anomaly detection: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Select the account you want to use to record anomaly data, then select the workload or entities you’d like to monitor. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name your configuration and save. Detect anomalies with a faceted NRQL query To detect anomalies with a faceted NRQL query: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Click Use a query instead. You may need to select an account, if you have more than one. Add one or more queries with a FACET clause. Name the query and confirm the facets you want to monitor for anomalies. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name the configuration and save. See your anomalies in one place When you set up anomaly detection, New Relic starts analyzing the golden signals of your entities and workloads. Anomalies appear in your activity feeds throughout New Relic One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL alert condition for the NrAiAnomaly event. To view anomalies, from one.newrelic.com, go to Alerts & AI > Issues & activity > Anomalies. Query anomaly data Detected anomalies are written to the NrAiAnomaly event in your NRDB account. You can learn more about this event and how to query it here. Reduce the number of detected anomalies If you’re seeing too many anomalies, the first step is to make sure your sensitivity level is set to Low. If it’s already set to Low, you can define specific thresholds to distinguish between normal and anomalous behavior. To define custom thresholds: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab and the configuration you want to modify. Select an entity or workload, and then change the sensitivity level. You can use custom sensitivity to define specific thresholds for different entity types.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 229.84421,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " feeds throughout <em>New</em> <em>Relic</em> One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL <em>alert</em>"
      },
      "id": "60b5124064441ff965e2cb01"
    },
    {
      "sections": [
        "Update or disable policies and conditions",
        "Policy maintenance quick reference",
        "Add or remove policies assigned to a channel",
        "Change a policy name",
        "Check policy user assignment",
        "Check policy channel assignment",
        "Create a new policy",
        "Condition maintenance quick reference",
        "Add more conditions",
        "Copy a condition",
        "Change how threshold violations roll up into incidents",
        "Check for entities (targets) assigned to a policy",
        "Tip",
        "Change a condition",
        "Link to Incident Intelligence",
        "Disable or delete policies and conditions",
        "Disable or re-enable a condition",
        "Disable a policy",
        "Delete policy conditions",
        "Delete a policy"
      ],
      "title": "Update or disable policies and conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert policies"
      ],
      "external_id": "4a6c5107cd6af696df6a3fb0651c6a1bde7daf36",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-policies/update-or-disable-policies-conditions/",
      "published_at": "2021-05-28T11:10:28Z",
      "updated_at": "2021-05-21T15:35:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you create a policy, you can: Add more conditions to the policy. Edit the conditions' names, targets, or thresholds. Disable conditions. Continue the policy setup process by adding one or more notification channels to it. Rename or delete the policy. The user interface shows a Last modified timestamp for any changes to policies, including their conditions and notification channels. Policy maintenance quick reference Here is a quick reference which also includes links to more detailed information and procedures for maintaining your policies. Add or remove policies assigned to a channel To add or remove policies assigned to a channel: In the one.newrelic.com top nav, click Alerts & AI, click Notification channels, then (select a channel). Click Alert policies, then (select a policy). From the selected policy, use the windows to select, remove, or clear all. Change a policy name To rename a policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Click the policy name to edit it, then type a meaningful name for the policy (maximum 64 characters). Check policy user assignment To check whether an account user has been assigned any policies: In the one.newrelic.com top nav, click Alerts & AI, click Policies, (select a policy), then click Notification channels. Select a user, and then click Alert policies. Check policy channel assignment To check whether a notification channel has any policies assigned to it: In the one.newrelic.com top nav, click Alerts & AI, click Notification channels. The Policy subscriptions column lists how many policies are assigned to the channel. Create a new policy To create a new alert policy: In the one.newrelic.com top nav, click Alerts & AI, click Policies. Click New alert policy. Follow standard procedures to complete the basic setup process. Condition maintenance quick reference Here's a quick reference for maintaining a policy conditions. This includes the condition's entities (targets), Warning (yellow) and Critical (red) thresholds, and runbook URL. Add more conditions To add more conditions to a policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then click Add a condition. OR To copy a condition from any policy and add it to another policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then click Copy. Copy a condition To copy an existing condition, including its targets and thresholds, and add it to another policy for the selected account: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). From the policy's list of one or more Alert conditions, click Copy. From the Copy alert condition list, search or scroll the list to select the policy where you want to add this condition. Optional: Change the condition's name if necessary. Select Save. By default, the copied condition will be added to the selected alert policy in a Disabled state. Follow standard procedures to add or copy additional conditions to the alert policy, and then Enable the condition as needed. Change how threshold violations roll up into incidents To select how violations to your thresholds are grouped into incident records (by policy, by condition, or by target and condition): In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Click Incident preference. Check for entities (targets) assigned to a policy To check whether an entity (target) has any policies assigned: Go to the product (APM, Browser, etc.). From the selected product's index, check whether the entity's color-coded health status is light green with an icon. Tip Exception: Infrastructure does not use this feature. Change a condition To change a policy condition: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Then, from the list of Alert conditions for the selected policy: To change the condition's name, click Edit. To add, change, or remove targets (entities), select the name or number of targets for the condition, and then select Browse and select targets. To update the values for the required Critical (red) or optional Warning (yellow) thresholds, select the existing value. To update the condition's runbook URL, select the condition's Thresholds. Link to Incident Intelligence If you use Applied Intelligence, you can connect your conditions to Incident Intelligence. To do this, switch the Connect to Incident Intelligence to ON. Disable or delete policies and conditions If you disable or delete a policy, we'll continue to apply any other policies assigned to the product entity (target). If you remove all policies for the entity, its color-coded health status indicator will appear light green with an icon. Disable or re-enable a condition You can enable or disable any policy conditions, and the policy will continue to apply. To disable or re-enable a condition: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Then, from the list of Alert conditions, (select a condition). Click the On/Off switch to toggle it. Tip For Infrastructure conditions, use the checkbox at the bottom of the condition edit screen, then save the condition. If you copy a condition, it is automatically saved in the new policy as disabled (Off), even if the condition was enabled (On) in the original policy. Disable a policy You can't disable a policy directly. However, you can disable all of the policy's conditions. When you disable all of the conditions, the policy will continue to appear on the Alert policies index. The policy itself isn't disabled, and you can re-enable any or all of its conditions at any time. Delete policy conditions If a policy has multiple conditions, you can delete any or all of them, and the remaining conditions for the policy will continue to apply. To turn a condition off but keep it with the policy, disable it. To delete one or more conditions: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). From the list of Alert conditions, (select a condition), then click Delete. Tip If you don't see the delete button, your account admin may have disabled condition deletion for your organization. Delete a policy If you delete any of your account's policies, you can't restore them. Instead, you must re-create them if necessary. To delete a policy completely: In the one.newrelic.com top nav, click Alerts & AI, then click Alert policies. From the policy row, click the delete icon. Any notification channels associated with a deleted or disabled policy will remain. You must delete notification channels or remove them individually as necessary. You will still be able to view incidents and event violations related to the deleted policy. However, these records will be read only.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 212.17773,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Update or disable policies <em>and</em> <em>conditions</em>",
        "sections": "Update or disable policies <em>and</em> <em>conditions</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " to it: In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click Notification channels. The Policy subscriptions column lists how many policies are assigned to the channel. Create a <em>new</em> policy To create a <em>new</em> <em>alert</em> policy: In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click Policies. Click <em>New</em> <em>alert</em> policy. Follow"
      },
      "id": "604404ec28ccbc62492c6098"
    },
    {
      "sections": [
        "Create baseline alert conditions",
        "How it works",
        "Set baseline thresholds",
        "Faceted baseline conditions",
        "Baseline rules and settings",
        "Rules governing creation of baseline",
        "Baseline direction: select upper or lower ranges",
        "Preview chart: select 2 or 7 days"
      ],
      "title": "Create baseline alert conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "a144b0cc3c5eed1c31dbfcd079959bbd5496346a",
      "image": "https://docs.newrelic.com/static/3be661b029a5f41d3da75175a0259fb9/c1b63/new-relic-baseline-alerts-direction-image-examples_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-baseline-alert-conditions/",
      "published_at": "2021-05-28T03:27:17Z",
      "updated_at": "2021-05-16T08:44:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use baseline conditions to define violation thresholds that adjust to the behavior of your data. Baseline alerting is useful for creating conditions that: Only notify you when data is behaving abnormally. Dynamically adjust to changing data and trends, including daily or weekly trends. In addition, baseline alerting works well with new applications when you do not yet have known behaviors. How it works When you choose a data source (for example, an APM metric) for a baseline condition, we'll use the past values of that data to dynamically predict the data's near-future behavior. The line of that predicted future behavior for that value is called a baseline. It appears as a dotted black line on the preview chart in the baseline condition UI. You'll use the baseline alert condition UI to: Adjust how sensitive the condition is to fluctuations in the data source. Set the behavior that will trigger a violation (for example: \"deviating for more than five minutes\"). Set whether you want the condition to check for upper violations, lower violations, or both. When your data escapes the predicted \"normal\" behavior and meets the criteria you've chosen, you'll receive a notification. Set baseline thresholds one.newrelic.com > AI & Alerts > Policies > (create or select policy) > Create alert condition: Baseline alert conditions give you the ability to set intelligent, self-adjusting thresholds that only generate violations when abnormal behavior is detected. To create a baseline condition: When you start to create a condition, choose one of the following data sources: NRQL: Create a NRQL condition and then choose baseline APM: Application metric baseline Browser: Metric baseline Here are some tips for setting baseline thresholds: Set the baseline direction to monitor violations that happen either above or below the baseline. Set the preview chart to either 2 days or 7 days of displayed data. (Not applicable for NRQL alert conditions.) Use the slider bar to adjust the Critical threshold sensitivity, represented in the preview chart by the light gray area around the baseline. The tighter the band around the baseline, the more sensitive it is and the more violations it will generate. Optional: You can create a Warning threshold (the darker gray area around the baseline). For NRQL alerts, see the allowed types of NRQL queries. If the alert condition applies to multiple apps, you can select a choice from the dropdown above the chart to use different metrics. (Not applicable for NRQL alert conditions.) Faceted baseline conditions NRQL alerts conditions support faceted baselines. In the chart legend, click a time series to scope it to a single facet. Once you've run a faceted NRQL query for a baseline condition, you can scope your results to a single baseline. Click Return to full timeseries list to go back to seeing all your facets. The single time series shows the baseline, threshold band, and one or more violation regions, if there are any. Baseline rules and settings Here are some details about how the UI works: Rules governing creation of baseline The algorithm for baseline conditions is mathematically complex. Here are some of the major rules governing its predictive abilities: Data trait Baseline rules Age of data On initial creation, the baseline is calculated using between 1 to 4 weeks of data, depending on data availability and baseline type. After its creation, the algorithm will take into account ongoing data fluctuations over a long time period, although greater weight is given to more recent data. For data that has only existed for a short time, the baseline will likely fluctuate a good deal and not be very accurate. This is because there is not yet enough data to determine its usual values and behavior. The more history the data has, the more accurate the baseline and thresholds will become. Consistency of data For metric values that remain in a consistent range or that trend slowly and steadily, their more predictable behavior means that their thresholds will become tighter around the baseline. Data that is more varied and unpredictable will have looser (wider) thresholds. Regular fluctuations For shorter-than-one-week cyclical fluctuations (such as weekly Wednesday 1pm deployments or nightly reports), the baseline algorithm looks for these cyclical fluctuations and attempts to adjust to them. Baseline direction: select upper or lower ranges You can choose whether you want the condition to violate for behavior that goes above the baseline (\"upper\") or that goes below the baseline (\"lower\"), or that goes either above or below. You choose these with the Baseline direction selector. Example use cases for this: You might use the Upper setting for a data source like error rate, because you generally are only concerned if it goes up, and aren't concerned if it goes down. You might use the Lower setting for a data source like throughput, because sudden upward fluctuations are quite common, but a large sudden downswing would be a sign of a problem. Here are examples of how large fluctuations in your data would be treated under the different baseline direction settings. The red areas represent violations. Preview chart: select 2 or 7 days When setting thresholds, the preview chart has an option for displaying Since 2 days ago or Since 7 days ago. These selections are not the time period used to compute the baseline; they are only the time range used for a preview display. For more about the time range used to calculate the baseline, see the algorithm rules.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.8776,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create baseline <em>alert</em> <em>conditions</em>",
        "sections": "Create baseline <em>alert</em> <em>conditions</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": ". Set baseline thresholds one.newrelic.com &gt; AI &amp; <em>Alerts</em> &gt; Policies &gt; (create or select policy) &gt; Create <em>alert</em> condition: Baseline <em>alert</em> <em>conditions</em> give you the ability to set intelligent, self-adjusting thresholds that only generate violations when abnormal behavior is detected. To create a baseline"
      },
      "id": "6044095ee7b9d214955799e9"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-baseline-alert-conditions": [
    {
      "sections": [
        "Expanded anomaly detection",
        "Requirements",
        "Why it matters",
        "Get started with anomaly detection",
        "Detect anomalies with a faceted NRQL query",
        "See your anomalies in one place",
        "Tip",
        "Query anomaly data",
        "Reduce the number of detected anomalies"
      ],
      "title": "Expanded anomaly detection",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Proactive detection"
      ],
      "external_id": "0b07c0b6ce27f39b5edb3e112a0f949835cbb8c6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/proactive-detection/expanded-anomaly-detection/",
      "published_at": "2021-06-02T18:27:12Z",
      "updated_at": "2021-05-31T16:43:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We’ve expanded anomaly detection coverage beyond your APM applications. Configure anomaly detection for your browser applications, mobile applications, infrastructure hosts, and nearly anything you want to monitor. Requirements Expanded anomaly detection is available as a limited beta. You can request access here. Why it matters When starting to configure alert conditions for a variety of applications and hosts, it can be difficult to know what you’ll want to be notified about ahead of time. Anomaly detection helps you distinguish between what’s typical performance in your system and where you’re starting to have trouble. Instead of creating your alert conditions manually, you can simply tell us what you want to monitor. Anomaly detection will help you identify baseline performance in your system and flags anomalous activity in your system. Get started with anomaly detection To get started with expanded anomaly detection: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Select the account you want to use to record anomaly data, then select the workload or entities you’d like to monitor. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name your configuration and save. Detect anomalies with a faceted NRQL query To detect anomalies with a faceted NRQL query: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Click Use a query instead. You may need to select an account, if you have more than one. Add one or more queries with a FACET clause. Name the query and confirm the facets you want to monitor for anomalies. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name the configuration and save. See your anomalies in one place When you set up anomaly detection, New Relic starts analyzing the golden signals of your entities and workloads. Anomalies appear in your activity feeds throughout New Relic One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL alert condition for the NrAiAnomaly event. To view anomalies, from one.newrelic.com, go to Alerts & AI > Issues & activity > Anomalies. Query anomaly data Detected anomalies are written to the NrAiAnomaly event in your NRDB account. You can learn more about this event and how to query it here. Reduce the number of detected anomalies If you’re seeing too many anomalies, the first step is to make sure your sensitivity level is set to Low. If it’s already set to Low, you can define specific thresholds to distinguish between normal and anomalous behavior. To define custom thresholds: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab and the configuration you want to modify. Select an entity or workload, and then change the sensitivity level. You can use custom sensitivity to define specific thresholds for different entity types.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 229.84406,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " feeds throughout <em>New</em> <em>Relic</em> One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL <em>alert</em>"
      },
      "id": "60b5124064441ff965e2cb01"
    },
    {
      "sections": [
        "Update or disable policies and conditions",
        "Policy maintenance quick reference",
        "Add or remove policies assigned to a channel",
        "Change a policy name",
        "Check policy user assignment",
        "Check policy channel assignment",
        "Create a new policy",
        "Condition maintenance quick reference",
        "Add more conditions",
        "Copy a condition",
        "Change how threshold violations roll up into incidents",
        "Check for entities (targets) assigned to a policy",
        "Tip",
        "Change a condition",
        "Link to Incident Intelligence",
        "Disable or delete policies and conditions",
        "Disable or re-enable a condition",
        "Disable a policy",
        "Delete policy conditions",
        "Delete a policy"
      ],
      "title": "Update or disable policies and conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert policies"
      ],
      "external_id": "4a6c5107cd6af696df6a3fb0651c6a1bde7daf36",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-policies/update-or-disable-policies-conditions/",
      "published_at": "2021-05-28T11:10:28Z",
      "updated_at": "2021-05-21T15:35:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you create a policy, you can: Add more conditions to the policy. Edit the conditions' names, targets, or thresholds. Disable conditions. Continue the policy setup process by adding one or more notification channels to it. Rename or delete the policy. The user interface shows a Last modified timestamp for any changes to policies, including their conditions and notification channels. Policy maintenance quick reference Here is a quick reference which also includes links to more detailed information and procedures for maintaining your policies. Add or remove policies assigned to a channel To add or remove policies assigned to a channel: In the one.newrelic.com top nav, click Alerts & AI, click Notification channels, then (select a channel). Click Alert policies, then (select a policy). From the selected policy, use the windows to select, remove, or clear all. Change a policy name To rename a policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Click the policy name to edit it, then type a meaningful name for the policy (maximum 64 characters). Check policy user assignment To check whether an account user has been assigned any policies: In the one.newrelic.com top nav, click Alerts & AI, click Policies, (select a policy), then click Notification channels. Select a user, and then click Alert policies. Check policy channel assignment To check whether a notification channel has any policies assigned to it: In the one.newrelic.com top nav, click Alerts & AI, click Notification channels. The Policy subscriptions column lists how many policies are assigned to the channel. Create a new policy To create a new alert policy: In the one.newrelic.com top nav, click Alerts & AI, click Policies. Click New alert policy. Follow standard procedures to complete the basic setup process. Condition maintenance quick reference Here's a quick reference for maintaining a policy conditions. This includes the condition's entities (targets), Warning (yellow) and Critical (red) thresholds, and runbook URL. Add more conditions To add more conditions to a policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then click Add a condition. OR To copy a condition from any policy and add it to another policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then click Copy. Copy a condition To copy an existing condition, including its targets and thresholds, and add it to another policy for the selected account: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). From the policy's list of one or more Alert conditions, click Copy. From the Copy alert condition list, search or scroll the list to select the policy where you want to add this condition. Optional: Change the condition's name if necessary. Select Save. By default, the copied condition will be added to the selected alert policy in a Disabled state. Follow standard procedures to add or copy additional conditions to the alert policy, and then Enable the condition as needed. Change how threshold violations roll up into incidents To select how violations to your thresholds are grouped into incident records (by policy, by condition, or by target and condition): In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Click Incident preference. Check for entities (targets) assigned to a policy To check whether an entity (target) has any policies assigned: Go to the product (APM, Browser, etc.). From the selected product's index, check whether the entity's color-coded health status is light green with an icon. Tip Exception: Infrastructure does not use this feature. Change a condition To change a policy condition: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Then, from the list of Alert conditions for the selected policy: To change the condition's name, click Edit. To add, change, or remove targets (entities), select the name or number of targets for the condition, and then select Browse and select targets. To update the values for the required Critical (red) or optional Warning (yellow) thresholds, select the existing value. To update the condition's runbook URL, select the condition's Thresholds. Link to Incident Intelligence If you use Applied Intelligence, you can connect your conditions to Incident Intelligence. To do this, switch the Connect to Incident Intelligence to ON. Disable or delete policies and conditions If you disable or delete a policy, we'll continue to apply any other policies assigned to the product entity (target). If you remove all policies for the entity, its color-coded health status indicator will appear light green with an icon. Disable or re-enable a condition You can enable or disable any policy conditions, and the policy will continue to apply. To disable or re-enable a condition: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Then, from the list of Alert conditions, (select a condition). Click the On/Off switch to toggle it. Tip For Infrastructure conditions, use the checkbox at the bottom of the condition edit screen, then save the condition. If you copy a condition, it is automatically saved in the new policy as disabled (Off), even if the condition was enabled (On) in the original policy. Disable a policy You can't disable a policy directly. However, you can disable all of the policy's conditions. When you disable all of the conditions, the policy will continue to appear on the Alert policies index. The policy itself isn't disabled, and you can re-enable any or all of its conditions at any time. Delete policy conditions If a policy has multiple conditions, you can delete any or all of them, and the remaining conditions for the policy will continue to apply. To turn a condition off but keep it with the policy, disable it. To delete one or more conditions: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). From the list of Alert conditions, (select a condition), then click Delete. Tip If you don't see the delete button, your account admin may have disabled condition deletion for your organization. Delete a policy If you delete any of your account's policies, you can't restore them. Instead, you must re-create them if necessary. To delete a policy completely: In the one.newrelic.com top nav, click Alerts & AI, then click Alert policies. From the policy row, click the delete icon. Any notification channels associated with a deleted or disabled policy will remain. You must delete notification channels or remove them individually as necessary. You will still be able to view incidents and event violations related to the deleted policy. However, these records will be read only.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 212.1777,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Update or disable policies <em>and</em> <em>conditions</em>",
        "sections": "Update or disable policies <em>and</em> <em>conditions</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " to it: In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click Notification channels. The Policy subscriptions column lists how many policies are assigned to the channel. Create a <em>new</em> policy To create a <em>new</em> <em>alert</em> policy: In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click Policies. Click <em>New</em> <em>alert</em> policy. Follow"
      },
      "id": "604404ec28ccbc62492c6098"
    },
    {
      "sections": [
        "Create NRQL alert conditions",
        "Tip",
        "Create a NRQL alert condition",
        "Create a condition from a chart",
        "Caution",
        "NRQL alert syntax",
        "Important",
        "Reformatting incompatible NRQL",
        "NRQL alert threshold examples",
        "Alert on specific segments of your data",
        "Alert on Nth percentile of your data",
        "Alert on max, min, avg of your data",
        "Alert on a percentage of your data",
        "Alert on Apdex with any T-value",
        "Alert conditions and query order of operations",
        "Example: null value returned",
        "Example: zero value returned",
        "Nested aggregation NRQL alerts",
        "Nested queries with a non-faceted innermost query are not currently supported",
        "Queries at all levels must have the same aggregation window size",
        "Signal loss is not yet supported for nested queries",
        "NRQL condition creation tips",
        "Alert threshold types",
        "Sum of query results (limited or intermittent data)",
        "Set the loss of signal threshold",
        "Advanced signal settings",
        "Aggregation window",
        "Evaluation offset",
        "Fill data gaps"
      ],
      "title": "Create NRQL alert conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "2872f770a5fc8a802f99b9f848906f7e351ad761",
      "image": "https://docs.newrelic.com/static/eb8e1b2d826f9fd9cf46fe3dd5455217/c1b63/nr1_nrql_alert_conditions.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions/",
      "published_at": "2021-06-02T21:19:39Z",
      "updated_at": "2021-05-16T08:44:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use NRQL queries to create alert conditions. Once you've defined your signal, you can further define your warning and critical threshold levels. This determines when an alerts violation is created. Read on to learn more about how to do this. Go to one.newrelic.com, click Alerts & AI, in the left sidebar click Policies, select a policy, then Add a condition. Click NRQL, and then Next, define thresholds. Tip For more information on key concepts relating to NRQL alert conditions and streaming alerts, see Streaming alerts: key terms and concepts. Create a NRQL alert condition To create a NRQL alert condition for a policy: On one.newrelic.com, in the header click Alerts & AI, then in the left sidebar click Policies. Select an existing policy or click New alert policy to create a new policy. Click Add a condition. Under Select a product click NRQL, and then click Next, define thresholds. Create a condition from a chart You can use a chart to create a NRQL alert condition. To create a NRQL alerts condition from a chart, click the chart menu , then click Create alert condition. Once you've named and customized your condition, you can add it to an existing policy or create a new one. Caution A small number of our older charts don't include the option to create an alert condition. NRQL alert syntax Here's the basic syntax for creating all NRQL alert conditions. The FACET clause is required for outlier threshold types. It's optional for static and baseline. SELECT function(attribute) FROM Event WHERE attribute [comparison] [AND|OR ...] Copy Clause Notes SELECT function(attribute) Required Supported functions that return numbers include: apdex average count latest max min percentage percentile sum uniqueCount Tip If you use the percentile aggregator in a faceted alert condition with many facets, this may cause the following error to appear: An error occurred while fetching chart data. If you see this error, use average instead. FROM data type Required Only one data type can be targeted. Supported data types: Event Metric (RAW data points will be returned) WHERE attribute [comparison] [AND|OR ...] Use the WHERE clause to specify a series of one or more conditions. All the operators are supported. FACET attribute Required for outlier conditions Include an optional FACET clause in your NRQL syntax depending on the threshold type: static or baseline. Use the FACET clause to separate your results by attribute and alert on each attribute independently. No LIMIT clause is allowed, but all queries will receive the maximum number of facets possible. Faceted queries can return a maximum of 5000 values for static and baseline conditions and a maximum of 500 values for outlier conditions. Important If the query returns more than the maximum number of values, the alert condition can't be created. If you create the condition and the query returns more than this number later, the alert will fail. Modify your query so that it returns a fewer number of values. Reformatting incompatible NRQL Some elements of NRQL used in charts don’t make sense in the streaming context of alerts. Here’s a list of the most common incompatible elements and suggestions for reformatting a NRQL alert query to achieve the same effect. Element Notes SINCE and UNTIL Example: SELECT percentile(largestContentfulPaint, 75) FROM PageViewTiming WHERE (appId = 837807) SINCE yesterday Copy NRQL Alerting produces a never-ending stream of windowed query results, so the SINCE and UNTIL keywords to scope the query to a point in time are not compatible. As a convenience, we automatically strip SINCE and UNTIL from a query when creating a NRQL Alert Condition from the context of a chart. TIMESERIES In NRQL queries, the TIMESERIES clause is used to return data as a time series broken out by a specified period of time. For NRQL alerts, the equivalent property of a signal is the aggregation window. histogram() The histogram() aggregation function is used to generate histograms. histogram() is not compatible with NRQL alerting: histogram aggregations can not be formatted as a time series. To create an alert from a portion of a histogram (e.g. 95th percentile), use the percentile() aggregation function. Multiple Aggregation Functions Each alert condition can only target a single aggregated stream of data. To alert on multiple streams simultaneously, you’ll need to decompose them into individual conditions within the same policy. Original Query: SELECT count(foo), average(bar), max(baz) from Transaction Copy Decomposed: SELECT count(foo) from Transaction SELECT average(bar) from Transaction SELECT max(baz) from Transaction Copy COMPARE WITH The COMPARE WITH clause is used to compare the values for two different time ranges. This type of query is incompatible with NRQL alerting. We recommend using a Baseline Alert Condition to dynamically detect deviations for a particular signal. SLIDE BY The SLIDE BY clause supports a feature known as sliding windows. With sliding windows, SLIDE BY data is gathered into \"windows\" of time that overlap with each other. These windows can help to smooth out line graphs with a lot of variation in cases where the rolling aggregate (such as a rolling mean) is more important than aggregates from narrow windows of time. Sliding windows are not currently supported in NRQL alerts. LIMIT In NRQL queries, the LIMIT clause is used to control the amount of data a query returns, either the maximum number of facet values returned by FACET queries or the maximum number of items returned by SELECT * queries. LIMIT is not compatible with NRQL alerting: evaluation is always performed on the full result set. NRQL alert threshold examples Here are some common use cases for NRQL alert conditions. These queries will work for static and baseline threshold types. The outlier threshold type will require additional FACET clauses. Alert on specific segments of your data Create constrained alerts that target a specific segment of your data, such as a few key customers or a range of data. Use the WHERE clause to define those conditions. SELECT average(duration) FROM Transaction WHERE account_id in (91290, 102021, 20230) Copy SELECT percentile(duration, 95) FROM Transaction WHERE name LIKE 'Controller/checkout/%' Copy Alert on Nth percentile of your data Create alerts when an Nth percentile of your data hits a specified threshold; for example, maintaining SLA service levels. Since we evaluate the NRQL query in one-minute time windows, percentiles will be calculated for each minute separately. SELECT percentile(duration, 95) FROM Transaction Copy SELECT percentile(databaseDuration, 75) FROM Transaction Copy Alert on max, min, avg of your data Create alerts when your data hits a certain maximum, minimum, or average; for example, ensuring that a duration or response time does not pass a certain threshold. SELECT max(duration) FROM Transaction Copy SELECT average(duration) FROM Transaction Copy Alert on a percentage of your data Create alerts when a proportion of your data goes above or below a certain threshold. SELECT percentage(count(*), WHERE duration > 2) FROM Transaction Copy SELECT percentage(count(*), WHERE httpResponseCode = '500') FROM Transaction Copy Alert on Apdex with any T-value Create alerts on Apdex, applying your own T-value for certain transactions. For example, get an alert notification when your Apdex for a T-value of 500ms on transactions for production apps goes below 0.8. SELECT apdex(duration, t:0.5) FROM Transaction WHERE appName like '%prod%' Copy Alert conditions and query order of operations By default, the aggregation window is 1 minute, but you can change the window to suit your needs. Whatever the aggregation window, New Relic will collect data for that window using the function in the NRQL alert condition’s query. The query is parsed and executed by our systems in the following order: FROM clause – which event type needs to be grabbed? WHERE clause – what can be filtered out? SELECT clause – what information needs to be returned from the now-filtered data set? Example: null value returned Let's say this is your alert condition query: SELECT count(*) FROM SyntheticCheck WHERE monitorName = 'My Cool Monitor' AND result = 'FAILURE' Copy If there are no failures for the aggregation window: The system will execute the FROM clause by grabbing all SyntheticCheck events on your account. Then it will execute the WHERE clause to filter through those events by looking only for the ones that match the monitor name and result specified. If there are still events left to scan through after completing the FROM and WHERE operations, the SELECT clause will be executed. If there are no remainig events, the SELECT clause will not be executed. This means that aggregators like count() and uniqueCount() will never return a zero value. When there is a count of 0, the SELECT clause is ignored and no data is returned, resulting in a value of NULL. Example: zero value returned If you have a data source delivering legitimate numeric zeroes, the query will return zero values and not null values. Let's say this is your alert condition query, and that MyCoolEvent is an attribute that can sometimes return a zero value. SELECT average(MyCoolAttribute) FROM MyCoolEvent Copy If, in the aggregation window being evaluated, there's at least one instance of MyCoolEvent and if the average value of all MyCoolAttribute attributes from that window is equal to zero, then a 0 value will be returned. If there are no MyCoolEvent events during that minute, then a NULL will be returned due to the order of operations. Tip For more information about this topic, you can check out our blog post on troubleshooting for zero versus null values. Tip You can determine how null values will be handled by adjusting loss of signal and gap filling settings in the Alert Conditions UI. Nested aggregation NRQL alerts Nested aggregation queries are a powerful way to query your data. However, they have a few restrictions that are important to note. Nested queries with a non-faceted innermost query are not currently supported Without a FACET, the inner query produces a single result, giving the outer query nothing to aggregate. If you're using a nested query, make sure your inner query is faceted. SELECT max(cpu) FROM (FROM Event SELECT min(cpuTime) as cpu) ​​​​​ Copy Queries at all levels must have the same aggregation window size With an alert aggregation window of 1 minute, the inner query would produce two smaller windows of 30 seconds. In theory, these two windows could be aggregated by the outer query. However, this is not currently supported. SELECT max(cpu) FROM (FROM Event SELECT min(cpuTime) as cpu TIMESERIES 30 seconds)​​ Copy Signal loss is not yet supported for nested queries For more information on signal loss, see NerdGraph API: Loss of signal and gap filling. NRQL condition creation tips Here are some tips for creating and using a NRQL condition: Topic Tips Condition threshold types NRQL condition threshold types include static, baseline, and outlier. Create a description For NRQL conditions, you can create a custom description to add to each violation. Descriptions can be enhanced with variable substitution based on metadata in the specific violation. For details, see Description Query results Queries must return a number. The condition evaluates the returned number against the thresholds you've set. Time period As with all alert conditions, NRQL conditions evaluate one single minute at a time. The implicit SINCE ... UNTIL clause specifying which minute to evaluate is controlled by your Evaluation offset setting. Since very recent data may be incomplete, you may want to query data from 3 minutes ago or longer, especially for: Applications that run on multiple hosts. SyntheticCheck data: Timeouts can take 3 minutes, so 5 minutes or more is recommended. Also, if a query will generate intermittent data, consider using the sum of query results option. Lost signal threshold (loss of signal detection) You can use loss of signal detection to alert on when your data (a telemetry signal) should be considered lost. A signal loss can indicate that a service or entity is no longer online or that a periodic job failed to run. You can also use this to make sure that violations for sporadic data, such as error counts, are closed when no signal is coming in. Tip To learn more about signal loss and how to request access to it, see this announcement. Advanced signal settings These settings give you options for better handling continuous, streaming data signals that may sometimes be missing. These settings include the aggregation window, the evaluation offset, and an option for filling data gaps. For more on using these, see Advanced signal settings. Condition settings Use the Condition settings to: Create a concise, descriptive condition name. Provide a custom violation description for the condition that will be included in violations and notifications. Add the runbook URL to include your organization's procedures for handling incidents. You may also add this information to the custom violation description. Limits on conditions See the maximum values. Health status NRQL alert conditions don't affect an entity's health status display. Examples For more information, see: Expected NRQL syntax Examples of NRQL condition queries Alert threshold types When you create a NRQL alert, you can choose from different types of thresholds: NRQL alert threshold types Description Static This is the simplest type of NRQL threshold. It allows you to create a condition based on a NRQL query that returns a numeric value. Optional: Include a FACET clause. Baseline (Dynamic) Uses a self-adjusting condition based on the past behavior of the monitored values. Uses the same NRQL query form as the static type. Outlier Looks for group behavior and values that are outliers from those groups. Uses the same NRQL query form as the static type, but requires a FACET clause. Sum of query results (limited or intermittent data) Important Available only for static (basic) threshold types. If a query returns intermittent or limited data, it may be difficult to set a meaningful threshold. Missing or limited data will sometimes generate false positives or false negatives. You can use loss of signal, aggregation duration, and gap filling settings to minimize these false notifications. To avoid this problem when using the static threshold type, you can set the selector to sum of query results. This lets you set the alert on an aggregated sum instead of a value from a single harvest cycle. Up to two hours of one-minute data checks can be aggregated. The duration you select determines the width of the rolling sum and the preview chart will update accordingly. Set the loss of signal threshold Loss of signal occurs when no data matches the NRQL condition over a specific period of time. You can set your loss of signal threshold duration and and also what happens when the threshold is crossed. Go to one.newrelic.com, click Alerts & AI, in the left sidebar click Policies, select a policy, then Add a condition. Loss of signal is only available for NRQL conditions. You may also manage these settings using the GraphQL API (recommended), or the REST API. Go here for specific GraphQL API examples. Loss of signal settings: Loss of signal settings include a time duration and two possible actions. Signal loss expiration time UI label: Signal is lost after: GraphQL Node: expiration.expirationDuration Expiration duration is a timer that starts and resets when we receive a data point in the streaming alerts pipeline. If we don't receive another data point before your 'expiration time' expires, we consider that signal to be lost. This can be because no data is being sent to New Relic or the WHERE clause of your NRQL query is filtering that data out before it is streamed to the alerts pipeline. The loss of signal expiration time is independent of the threshold duration and triggers as soon as the timer expires. The maximum expiration duration is 48 hours. This is helpful when monitoring for the execution of infrequent jobs. The minimum is 30 seconds, but we recommend using at least 3-5 minutes. Loss of signal actions Once a signal is considered lost, you can close open violations, open new violations, or both. Close all current open violations: This closes all open violations that are related to a specific signal. It won't necessarily close all violations for a condition. If you're alerting on an ephemeral service, or on a sporadic signal, you'll want to choose this action to ensure that violations are closed properly. The GraphQL node name for this is \"closeViolationsOnExpiration\" Open new violations: This will open a new violation when the signal is considered lost. These violations will indicate that they are due to a loss of signal. Based on your incident preferences, this should trigger a notification. The graphQL node name for this is \"openViolationOnExpiration\" When you enable both actions, we'll close all open violations first, and then open a new violation for loss of signal. To create a NRQL alert configured with loss of signal detection in the UI: For a policy, when you create a condition, under Select a product, click NRQL, then click Next, define thresholds. Write a NRQL query that returns the values you want to alert on. For Threshold type, select Static or Baseline. Click + Add lost signal threshold, then set the signal expiration duration time in minutes or seconds in the Signal is lost after field. Choose what you want to happen when the signal is lost. You can check one or both of Close all current open violations and Open new \"lost signal\" violation . These control how loss of signal violations will be handled for the condition. Make sure you name your condition before you save it. Tip Loss of signal detection doesn't work on NRQL queries that use nested aggregation or sub-queries. Advanced signal settings When creating a NRQL alert condition, the advanced signal settings gives you better control over streaming alert data and helps you avoid false alarms. When creating a NRQL condition, there are several advanced signal settings: Aggregation window Evaluation offset Fill data gaps To read an explanation of what these settings are and how they relate to each other, see Streaming alerts concepts. Below are instructions and tips on how to configure them. Aggregation window You can set the aggregation window duration to choose how long data is accumulated in a streaming time window before it's aggregated. You can set it to anything between one second and 15 minutes. The default is one minute. Tip Baseline alert condition thresholds don't support editing the aggregation window. They use the 1 minute default. Evaluation offset You can adjust the evaluation offset to coordinate our streaming alerting algorithm with your data's latency. If it takes a while for your data to arrive, then you may need to increase the evaluation offset. The total supported latency is the product of the aggregation window duration multiplied by the evaluation offset. In the example screenshot above, the supported latency is 3 minutes (a 1-minute aggregation window multiplied by three windows). If the data type comes from an APM language agent and is aggregated from many app instances (for example, Transactions, TransactionErrors, etc.), we recommend using an evaluation offset of 3 with 1 minute aggregation windows. Important When creating NRQL conditions for data collected from Infrastructure Cloud Integrations such as AWS Cloudwatch or Azure, we recommend that you start with an evaluation offset of 15 minutes, then adjust up or down depending on how long it takes to collect your data. Fill data gaps Gap filling lets you customize the values to use when your signals don't have any data. You can fill gaps in your data streams with one of these settings: None: (Default) Choose this if you don't want to take any action on empty aggregation windows. On evaluation, an empty aggregation window will reset the threshold duration timer. For example, if a condition says that all aggregation windows must have data points above the threshold for 5 minutes, and 1 of the 5 aggregation windows is empty, then the condition won't be in violation. Custom static value: Choose this if you'd like to insert a custom static value into the empty aggregation windows before they're evaluated. This option has an additional, required parameter of fillValue (as named in the API) that specifies what static value should be used. This defaults to 0. Last known value: This option inserts the last seen value before evaluation occurs. We maintain the state of the last seen value for 2 hours. Options for editing data gap settings: In the NRQL conditions UI, go to Condition settings > Advanced signal settings > fill data gaps with and choose an option. If using our Nerdgraph API (preferred), this node is located at: actor : account : alerts : nrqlCondition : signal : fillOption | fillValue NerdGraph is the preferred API but if you are using our REST API, you can find this setting in the REST API explorer under the \"signal\" section of the Alert NRQL conditions API.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.87756,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create NRQL <em>alert</em> <em>conditions</em>",
        "sections": "<em>Alert</em> <em>conditions</em> <em>and</em> query order of operations",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": ") FROM Transaction WHERE appName like &#x27;%prod%&#x27; Copy <em>Alert</em> <em>conditions</em> and query order of operations By default, the aggregation window is 1 minute, but you can change the window to suit your needs. Whatever the aggregation window, <em>New</em> <em>Relic</em> will collect data for that window using the function"
      },
      "id": "603ef04864441fbc114e8883"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-nrql-alert-conditions": [
    {
      "sections": [
        "Expanded anomaly detection",
        "Requirements",
        "Why it matters",
        "Get started with anomaly detection",
        "Detect anomalies with a faceted NRQL query",
        "See your anomalies in one place",
        "Tip",
        "Query anomaly data",
        "Reduce the number of detected anomalies"
      ],
      "title": "Expanded anomaly detection",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Proactive detection"
      ],
      "external_id": "0b07c0b6ce27f39b5edb3e112a0f949835cbb8c6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/proactive-detection/expanded-anomaly-detection/",
      "published_at": "2021-06-02T18:27:12Z",
      "updated_at": "2021-05-31T16:43:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We’ve expanded anomaly detection coverage beyond your APM applications. Configure anomaly detection for your browser applications, mobile applications, infrastructure hosts, and nearly anything you want to monitor. Requirements Expanded anomaly detection is available as a limited beta. You can request access here. Why it matters When starting to configure alert conditions for a variety of applications and hosts, it can be difficult to know what you’ll want to be notified about ahead of time. Anomaly detection helps you distinguish between what’s typical performance in your system and where you’re starting to have trouble. Instead of creating your alert conditions manually, you can simply tell us what you want to monitor. Anomaly detection will help you identify baseline performance in your system and flags anomalous activity in your system. Get started with anomaly detection To get started with expanded anomaly detection: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Select the account you want to use to record anomaly data, then select the workload or entities you’d like to monitor. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name your configuration and save. Detect anomalies with a faceted NRQL query To detect anomalies with a faceted NRQL query: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Click Use a query instead. You may need to select an account, if you have more than one. Add one or more queries with a FACET clause. Name the query and confirm the facets you want to monitor for anomalies. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name the configuration and save. See your anomalies in one place When you set up anomaly detection, New Relic starts analyzing the golden signals of your entities and workloads. Anomalies appear in your activity feeds throughout New Relic One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL alert condition for the NrAiAnomaly event. To view anomalies, from one.newrelic.com, go to Alerts & AI > Issues & activity > Anomalies. Query anomaly data Detected anomalies are written to the NrAiAnomaly event in your NRDB account. You can learn more about this event and how to query it here. Reduce the number of detected anomalies If you’re seeing too many anomalies, the first step is to make sure your sensitivity level is set to Low. If it’s already set to Low, you can define specific thresholds to distinguish between normal and anomalous behavior. To define custom thresholds: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab and the configuration you want to modify. Select an entity or workload, and then change the sensitivity level. You can use custom sensitivity to define specific thresholds for different entity types.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 229.84406,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " feeds throughout <em>New</em> <em>Relic</em> One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL <em>alert</em>"
      },
      "id": "60b5124064441ff965e2cb01"
    },
    {
      "sections": [
        "Update or disable policies and conditions",
        "Policy maintenance quick reference",
        "Add or remove policies assigned to a channel",
        "Change a policy name",
        "Check policy user assignment",
        "Check policy channel assignment",
        "Create a new policy",
        "Condition maintenance quick reference",
        "Add more conditions",
        "Copy a condition",
        "Change how threshold violations roll up into incidents",
        "Check for entities (targets) assigned to a policy",
        "Tip",
        "Change a condition",
        "Link to Incident Intelligence",
        "Disable or delete policies and conditions",
        "Disable or re-enable a condition",
        "Disable a policy",
        "Delete policy conditions",
        "Delete a policy"
      ],
      "title": "Update or disable policies and conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert policies"
      ],
      "external_id": "4a6c5107cd6af696df6a3fb0651c6a1bde7daf36",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-policies/update-or-disable-policies-conditions/",
      "published_at": "2021-05-28T11:10:28Z",
      "updated_at": "2021-05-21T15:35:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you create a policy, you can: Add more conditions to the policy. Edit the conditions' names, targets, or thresholds. Disable conditions. Continue the policy setup process by adding one or more notification channels to it. Rename or delete the policy. The user interface shows a Last modified timestamp for any changes to policies, including their conditions and notification channels. Policy maintenance quick reference Here is a quick reference which also includes links to more detailed information and procedures for maintaining your policies. Add or remove policies assigned to a channel To add or remove policies assigned to a channel: In the one.newrelic.com top nav, click Alerts & AI, click Notification channels, then (select a channel). Click Alert policies, then (select a policy). From the selected policy, use the windows to select, remove, or clear all. Change a policy name To rename a policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Click the policy name to edit it, then type a meaningful name for the policy (maximum 64 characters). Check policy user assignment To check whether an account user has been assigned any policies: In the one.newrelic.com top nav, click Alerts & AI, click Policies, (select a policy), then click Notification channels. Select a user, and then click Alert policies. Check policy channel assignment To check whether a notification channel has any policies assigned to it: In the one.newrelic.com top nav, click Alerts & AI, click Notification channels. The Policy subscriptions column lists how many policies are assigned to the channel. Create a new policy To create a new alert policy: In the one.newrelic.com top nav, click Alerts & AI, click Policies. Click New alert policy. Follow standard procedures to complete the basic setup process. Condition maintenance quick reference Here's a quick reference for maintaining a policy conditions. This includes the condition's entities (targets), Warning (yellow) and Critical (red) thresholds, and runbook URL. Add more conditions To add more conditions to a policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then click Add a condition. OR To copy a condition from any policy and add it to another policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then click Copy. Copy a condition To copy an existing condition, including its targets and thresholds, and add it to another policy for the selected account: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). From the policy's list of one or more Alert conditions, click Copy. From the Copy alert condition list, search or scroll the list to select the policy where you want to add this condition. Optional: Change the condition's name if necessary. Select Save. By default, the copied condition will be added to the selected alert policy in a Disabled state. Follow standard procedures to add or copy additional conditions to the alert policy, and then Enable the condition as needed. Change how threshold violations roll up into incidents To select how violations to your thresholds are grouped into incident records (by policy, by condition, or by target and condition): In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Click Incident preference. Check for entities (targets) assigned to a policy To check whether an entity (target) has any policies assigned: Go to the product (APM, Browser, etc.). From the selected product's index, check whether the entity's color-coded health status is light green with an icon. Tip Exception: Infrastructure does not use this feature. Change a condition To change a policy condition: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Then, from the list of Alert conditions for the selected policy: To change the condition's name, click Edit. To add, change, or remove targets (entities), select the name or number of targets for the condition, and then select Browse and select targets. To update the values for the required Critical (red) or optional Warning (yellow) thresholds, select the existing value. To update the condition's runbook URL, select the condition's Thresholds. Link to Incident Intelligence If you use Applied Intelligence, you can connect your conditions to Incident Intelligence. To do this, switch the Connect to Incident Intelligence to ON. Disable or delete policies and conditions If you disable or delete a policy, we'll continue to apply any other policies assigned to the product entity (target). If you remove all policies for the entity, its color-coded health status indicator will appear light green with an icon. Disable or re-enable a condition You can enable or disable any policy conditions, and the policy will continue to apply. To disable or re-enable a condition: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Then, from the list of Alert conditions, (select a condition). Click the On/Off switch to toggle it. Tip For Infrastructure conditions, use the checkbox at the bottom of the condition edit screen, then save the condition. If you copy a condition, it is automatically saved in the new policy as disabled (Off), even if the condition was enabled (On) in the original policy. Disable a policy You can't disable a policy directly. However, you can disable all of the policy's conditions. When you disable all of the conditions, the policy will continue to appear on the Alert policies index. The policy itself isn't disabled, and you can re-enable any or all of its conditions at any time. Delete policy conditions If a policy has multiple conditions, you can delete any or all of them, and the remaining conditions for the policy will continue to apply. To turn a condition off but keep it with the policy, disable it. To delete one or more conditions: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). From the list of Alert conditions, (select a condition), then click Delete. Tip If you don't see the delete button, your account admin may have disabled condition deletion for your organization. Delete a policy If you delete any of your account's policies, you can't restore them. Instead, you must re-create them if necessary. To delete a policy completely: In the one.newrelic.com top nav, click Alerts & AI, then click Alert policies. From the policy row, click the delete icon. Any notification channels associated with a deleted or disabled policy will remain. You must delete notification channels or remove them individually as necessary. You will still be able to view incidents and event violations related to the deleted policy. However, these records will be read only.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 212.1777,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Update or disable policies <em>and</em> <em>conditions</em>",
        "sections": "Update or disable policies <em>and</em> <em>conditions</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " to it: In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click Notification channels. The Policy subscriptions column lists how many policies are assigned to the channel. Create a <em>new</em> policy To create a <em>new</em> <em>alert</em> policy: In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click Policies. Click <em>New</em> <em>alert</em> policy. Follow"
      },
      "id": "604404ec28ccbc62492c6098"
    },
    {
      "sections": [
        "Create baseline alert conditions",
        "How it works",
        "Set baseline thresholds",
        "Faceted baseline conditions",
        "Baseline rules and settings",
        "Rules governing creation of baseline",
        "Baseline direction: select upper or lower ranges",
        "Preview chart: select 2 or 7 days"
      ],
      "title": "Create baseline alert conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "a144b0cc3c5eed1c31dbfcd079959bbd5496346a",
      "image": "https://docs.newrelic.com/static/3be661b029a5f41d3da75175a0259fb9/c1b63/new-relic-baseline-alerts-direction-image-examples_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-baseline-alert-conditions/",
      "published_at": "2021-05-28T03:27:17Z",
      "updated_at": "2021-05-16T08:44:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use baseline conditions to define violation thresholds that adjust to the behavior of your data. Baseline alerting is useful for creating conditions that: Only notify you when data is behaving abnormally. Dynamically adjust to changing data and trends, including daily or weekly trends. In addition, baseline alerting works well with new applications when you do not yet have known behaviors. How it works When you choose a data source (for example, an APM metric) for a baseline condition, we'll use the past values of that data to dynamically predict the data's near-future behavior. The line of that predicted future behavior for that value is called a baseline. It appears as a dotted black line on the preview chart in the baseline condition UI. You'll use the baseline alert condition UI to: Adjust how sensitive the condition is to fluctuations in the data source. Set the behavior that will trigger a violation (for example: \"deviating for more than five minutes\"). Set whether you want the condition to check for upper violations, lower violations, or both. When your data escapes the predicted \"normal\" behavior and meets the criteria you've chosen, you'll receive a notification. Set baseline thresholds one.newrelic.com > AI & Alerts > Policies > (create or select policy) > Create alert condition: Baseline alert conditions give you the ability to set intelligent, self-adjusting thresholds that only generate violations when abnormal behavior is detected. To create a baseline condition: When you start to create a condition, choose one of the following data sources: NRQL: Create a NRQL condition and then choose baseline APM: Application metric baseline Browser: Metric baseline Here are some tips for setting baseline thresholds: Set the baseline direction to monitor violations that happen either above or below the baseline. Set the preview chart to either 2 days or 7 days of displayed data. (Not applicable for NRQL alert conditions.) Use the slider bar to adjust the Critical threshold sensitivity, represented in the preview chart by the light gray area around the baseline. The tighter the band around the baseline, the more sensitive it is and the more violations it will generate. Optional: You can create a Warning threshold (the darker gray area around the baseline). For NRQL alerts, see the allowed types of NRQL queries. If the alert condition applies to multiple apps, you can select a choice from the dropdown above the chart to use different metrics. (Not applicable for NRQL alert conditions.) Faceted baseline conditions NRQL alerts conditions support faceted baselines. In the chart legend, click a time series to scope it to a single facet. Once you've run a faceted NRQL query for a baseline condition, you can scope your results to a single baseline. Click Return to full timeseries list to go back to seeing all your facets. The single time series shows the baseline, threshold band, and one or more violation regions, if there are any. Baseline rules and settings Here are some details about how the UI works: Rules governing creation of baseline The algorithm for baseline conditions is mathematically complex. Here are some of the major rules governing its predictive abilities: Data trait Baseline rules Age of data On initial creation, the baseline is calculated using between 1 to 4 weeks of data, depending on data availability and baseline type. After its creation, the algorithm will take into account ongoing data fluctuations over a long time period, although greater weight is given to more recent data. For data that has only existed for a short time, the baseline will likely fluctuate a good deal and not be very accurate. This is because there is not yet enough data to determine its usual values and behavior. The more history the data has, the more accurate the baseline and thresholds will become. Consistency of data For metric values that remain in a consistent range or that trend slowly and steadily, their more predictable behavior means that their thresholds will become tighter around the baseline. Data that is more varied and unpredictable will have looser (wider) thresholds. Regular fluctuations For shorter-than-one-week cyclical fluctuations (such as weekly Wednesday 1pm deployments or nightly reports), the baseline algorithm looks for these cyclical fluctuations and attempts to adjust to them. Baseline direction: select upper or lower ranges You can choose whether you want the condition to violate for behavior that goes above the baseline (\"upper\") or that goes below the baseline (\"lower\"), or that goes either above or below. You choose these with the Baseline direction selector. Example use cases for this: You might use the Upper setting for a data source like error rate, because you generally are only concerned if it goes up, and aren't concerned if it goes down. You might use the Lower setting for a data source like throughput, because sudden upward fluctuations are quite common, but a large sudden downswing would be a sign of a problem. Here are examples of how large fluctuations in your data would be treated under the different baseline direction settings. The red areas represent violations. Preview chart: select 2 or 7 days When setting thresholds, the preview chart has an option for displaying Since 2 days ago or Since 7 days ago. These selections are not the time period used to compute the baseline; they are only the time range used for a preview display. For more about the time range used to calculate the baseline, see the algorithm rules.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.87756,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create baseline <em>alert</em> <em>conditions</em>",
        "sections": "Create baseline <em>alert</em> <em>conditions</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": ". Set baseline thresholds one.newrelic.com &gt; AI &amp; <em>Alerts</em> &gt; Policies &gt; (create or select policy) &gt; Create <em>alert</em> condition: Baseline <em>alert</em> <em>conditions</em> give you the ability to set intelligent, self-adjusting thresholds that only generate violations when abnormal behavior is detected. To create a baseline"
      },
      "id": "6044095ee7b9d214955799e9"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/define-custom-metrics-alert-condition": [
    {
      "sections": [
        "Expanded anomaly detection",
        "Requirements",
        "Why it matters",
        "Get started with anomaly detection",
        "Detect anomalies with a faceted NRQL query",
        "See your anomalies in one place",
        "Tip",
        "Query anomaly data",
        "Reduce the number of detected anomalies"
      ],
      "title": "Expanded anomaly detection",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Proactive detection"
      ],
      "external_id": "0b07c0b6ce27f39b5edb3e112a0f949835cbb8c6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/proactive-detection/expanded-anomaly-detection/",
      "published_at": "2021-06-02T18:27:12Z",
      "updated_at": "2021-05-31T16:43:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We’ve expanded anomaly detection coverage beyond your APM applications. Configure anomaly detection for your browser applications, mobile applications, infrastructure hosts, and nearly anything you want to monitor. Requirements Expanded anomaly detection is available as a limited beta. You can request access here. Why it matters When starting to configure alert conditions for a variety of applications and hosts, it can be difficult to know what you’ll want to be notified about ahead of time. Anomaly detection helps you distinguish between what’s typical performance in your system and where you’re starting to have trouble. Instead of creating your alert conditions manually, you can simply tell us what you want to monitor. Anomaly detection will help you identify baseline performance in your system and flags anomalous activity in your system. Get started with anomaly detection To get started with expanded anomaly detection: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Select the account you want to use to record anomaly data, then select the workload or entities you’d like to monitor. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name your configuration and save. Detect anomalies with a faceted NRQL query To detect anomalies with a faceted NRQL query: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Click Use a query instead. You may need to select an account, if you have more than one. Add one or more queries with a FACET clause. Name the query and confirm the facets you want to monitor for anomalies. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name the configuration and save. See your anomalies in one place When you set up anomaly detection, New Relic starts analyzing the golden signals of your entities and workloads. Anomalies appear in your activity feeds throughout New Relic One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL alert condition for the NrAiAnomaly event. To view anomalies, from one.newrelic.com, go to Alerts & AI > Issues & activity > Anomalies. Query anomaly data Detected anomalies are written to the NrAiAnomaly event in your NRDB account. You can learn more about this event and how to query it here. Reduce the number of detected anomalies If you’re seeing too many anomalies, the first step is to make sure your sensitivity level is set to Low. If it’s already set to Low, you can define specific thresholds to distinguish between normal and anomalous behavior. To define custom thresholds: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab and the configuration you want to modify. Select an entity or workload, and then change the sensitivity level. You can use custom sensitivity to define specific thresholds for different entity types.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 229.8439,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " feeds throughout <em>New</em> <em>Relic</em> One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL <em>alert</em>"
      },
      "id": "60b5124064441ff965e2cb01"
    },
    {
      "sections": [
        "Update or disable policies and conditions",
        "Policy maintenance quick reference",
        "Add or remove policies assigned to a channel",
        "Change a policy name",
        "Check policy user assignment",
        "Check policy channel assignment",
        "Create a new policy",
        "Condition maintenance quick reference",
        "Add more conditions",
        "Copy a condition",
        "Change how threshold violations roll up into incidents",
        "Check for entities (targets) assigned to a policy",
        "Tip",
        "Change a condition",
        "Link to Incident Intelligence",
        "Disable or delete policies and conditions",
        "Disable or re-enable a condition",
        "Disable a policy",
        "Delete policy conditions",
        "Delete a policy"
      ],
      "title": "Update or disable policies and conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert policies"
      ],
      "external_id": "4a6c5107cd6af696df6a3fb0651c6a1bde7daf36",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-policies/update-or-disable-policies-conditions/",
      "published_at": "2021-05-28T11:10:28Z",
      "updated_at": "2021-05-21T15:35:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you create a policy, you can: Add more conditions to the policy. Edit the conditions' names, targets, or thresholds. Disable conditions. Continue the policy setup process by adding one or more notification channels to it. Rename or delete the policy. The user interface shows a Last modified timestamp for any changes to policies, including their conditions and notification channels. Policy maintenance quick reference Here is a quick reference which also includes links to more detailed information and procedures for maintaining your policies. Add or remove policies assigned to a channel To add or remove policies assigned to a channel: In the one.newrelic.com top nav, click Alerts & AI, click Notification channels, then (select a channel). Click Alert policies, then (select a policy). From the selected policy, use the windows to select, remove, or clear all. Change a policy name To rename a policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Click the policy name to edit it, then type a meaningful name for the policy (maximum 64 characters). Check policy user assignment To check whether an account user has been assigned any policies: In the one.newrelic.com top nav, click Alerts & AI, click Policies, (select a policy), then click Notification channels. Select a user, and then click Alert policies. Check policy channel assignment To check whether a notification channel has any policies assigned to it: In the one.newrelic.com top nav, click Alerts & AI, click Notification channels. The Policy subscriptions column lists how many policies are assigned to the channel. Create a new policy To create a new alert policy: In the one.newrelic.com top nav, click Alerts & AI, click Policies. Click New alert policy. Follow standard procedures to complete the basic setup process. Condition maintenance quick reference Here's a quick reference for maintaining a policy conditions. This includes the condition's entities (targets), Warning (yellow) and Critical (red) thresholds, and runbook URL. Add more conditions To add more conditions to a policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then click Add a condition. OR To copy a condition from any policy and add it to another policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then click Copy. Copy a condition To copy an existing condition, including its targets and thresholds, and add it to another policy for the selected account: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). From the policy's list of one or more Alert conditions, click Copy. From the Copy alert condition list, search or scroll the list to select the policy where you want to add this condition. Optional: Change the condition's name if necessary. Select Save. By default, the copied condition will be added to the selected alert policy in a Disabled state. Follow standard procedures to add or copy additional conditions to the alert policy, and then Enable the condition as needed. Change how threshold violations roll up into incidents To select how violations to your thresholds are grouped into incident records (by policy, by condition, or by target and condition): In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Click Incident preference. Check for entities (targets) assigned to a policy To check whether an entity (target) has any policies assigned: Go to the product (APM, Browser, etc.). From the selected product's index, check whether the entity's color-coded health status is light green with an icon. Tip Exception: Infrastructure does not use this feature. Change a condition To change a policy condition: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Then, from the list of Alert conditions for the selected policy: To change the condition's name, click Edit. To add, change, or remove targets (entities), select the name or number of targets for the condition, and then select Browse and select targets. To update the values for the required Critical (red) or optional Warning (yellow) thresholds, select the existing value. To update the condition's runbook URL, select the condition's Thresholds. Link to Incident Intelligence If you use Applied Intelligence, you can connect your conditions to Incident Intelligence. To do this, switch the Connect to Incident Intelligence to ON. Disable or delete policies and conditions If you disable or delete a policy, we'll continue to apply any other policies assigned to the product entity (target). If you remove all policies for the entity, its color-coded health status indicator will appear light green with an icon. Disable or re-enable a condition You can enable or disable any policy conditions, and the policy will continue to apply. To disable or re-enable a condition: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Then, from the list of Alert conditions, (select a condition). Click the On/Off switch to toggle it. Tip For Infrastructure conditions, use the checkbox at the bottom of the condition edit screen, then save the condition. If you copy a condition, it is automatically saved in the new policy as disabled (Off), even if the condition was enabled (On) in the original policy. Disable a policy You can't disable a policy directly. However, you can disable all of the policy's conditions. When you disable all of the conditions, the policy will continue to appear on the Alert policies index. The policy itself isn't disabled, and you can re-enable any or all of its conditions at any time. Delete policy conditions If a policy has multiple conditions, you can delete any or all of them, and the remaining conditions for the policy will continue to apply. To turn a condition off but keep it with the policy, disable it. To delete one or more conditions: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). From the list of Alert conditions, (select a condition), then click Delete. Tip If you don't see the delete button, your account admin may have disabled condition deletion for your organization. Delete a policy If you delete any of your account's policies, you can't restore them. Instead, you must re-create them if necessary. To delete a policy completely: In the one.newrelic.com top nav, click Alerts & AI, then click Alert policies. From the policy row, click the delete icon. Any notification channels associated with a deleted or disabled policy will remain. You must delete notification channels or remove them individually as necessary. You will still be able to view incidents and event violations related to the deleted policy. However, these records will be read only.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 212.17764,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Update or disable policies <em>and</em> <em>conditions</em>",
        "sections": "Update or disable policies <em>and</em> <em>conditions</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " to it: In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click Notification channels. The Policy subscriptions column lists how many policies are assigned to the channel. Create a <em>new</em> policy To create a <em>new</em> <em>alert</em> policy: In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click Policies. Click <em>New</em> <em>alert</em> policy. Follow"
      },
      "id": "604404ec28ccbc62492c6098"
    },
    {
      "sections": [
        "Create baseline alert conditions",
        "How it works",
        "Set baseline thresholds",
        "Faceted baseline conditions",
        "Baseline rules and settings",
        "Rules governing creation of baseline",
        "Baseline direction: select upper or lower ranges",
        "Preview chart: select 2 or 7 days"
      ],
      "title": "Create baseline alert conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "a144b0cc3c5eed1c31dbfcd079959bbd5496346a",
      "image": "https://docs.newrelic.com/static/3be661b029a5f41d3da75175a0259fb9/c1b63/new-relic-baseline-alerts-direction-image-examples_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-baseline-alert-conditions/",
      "published_at": "2021-05-28T03:27:17Z",
      "updated_at": "2021-05-16T08:44:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use baseline conditions to define violation thresholds that adjust to the behavior of your data. Baseline alerting is useful for creating conditions that: Only notify you when data is behaving abnormally. Dynamically adjust to changing data and trends, including daily or weekly trends. In addition, baseline alerting works well with new applications when you do not yet have known behaviors. How it works When you choose a data source (for example, an APM metric) for a baseline condition, we'll use the past values of that data to dynamically predict the data's near-future behavior. The line of that predicted future behavior for that value is called a baseline. It appears as a dotted black line on the preview chart in the baseline condition UI. You'll use the baseline alert condition UI to: Adjust how sensitive the condition is to fluctuations in the data source. Set the behavior that will trigger a violation (for example: \"deviating for more than five minutes\"). Set whether you want the condition to check for upper violations, lower violations, or both. When your data escapes the predicted \"normal\" behavior and meets the criteria you've chosen, you'll receive a notification. Set baseline thresholds one.newrelic.com > AI & Alerts > Policies > (create or select policy) > Create alert condition: Baseline alert conditions give you the ability to set intelligent, self-adjusting thresholds that only generate violations when abnormal behavior is detected. To create a baseline condition: When you start to create a condition, choose one of the following data sources: NRQL: Create a NRQL condition and then choose baseline APM: Application metric baseline Browser: Metric baseline Here are some tips for setting baseline thresholds: Set the baseline direction to monitor violations that happen either above or below the baseline. Set the preview chart to either 2 days or 7 days of displayed data. (Not applicable for NRQL alert conditions.) Use the slider bar to adjust the Critical threshold sensitivity, represented in the preview chart by the light gray area around the baseline. The tighter the band around the baseline, the more sensitive it is and the more violations it will generate. Optional: You can create a Warning threshold (the darker gray area around the baseline). For NRQL alerts, see the allowed types of NRQL queries. If the alert condition applies to multiple apps, you can select a choice from the dropdown above the chart to use different metrics. (Not applicable for NRQL alert conditions.) Faceted baseline conditions NRQL alerts conditions support faceted baselines. In the chart legend, click a time series to scope it to a single facet. Once you've run a faceted NRQL query for a baseline condition, you can scope your results to a single baseline. Click Return to full timeseries list to go back to seeing all your facets. The single time series shows the baseline, threshold band, and one or more violation regions, if there are any. Baseline rules and settings Here are some details about how the UI works: Rules governing creation of baseline The algorithm for baseline conditions is mathematically complex. Here are some of the major rules governing its predictive abilities: Data trait Baseline rules Age of data On initial creation, the baseline is calculated using between 1 to 4 weeks of data, depending on data availability and baseline type. After its creation, the algorithm will take into account ongoing data fluctuations over a long time period, although greater weight is given to more recent data. For data that has only existed for a short time, the baseline will likely fluctuate a good deal and not be very accurate. This is because there is not yet enough data to determine its usual values and behavior. The more history the data has, the more accurate the baseline and thresholds will become. Consistency of data For metric values that remain in a consistent range or that trend slowly and steadily, their more predictable behavior means that their thresholds will become tighter around the baseline. Data that is more varied and unpredictable will have looser (wider) thresholds. Regular fluctuations For shorter-than-one-week cyclical fluctuations (such as weekly Wednesday 1pm deployments or nightly reports), the baseline algorithm looks for these cyclical fluctuations and attempts to adjust to them. Baseline direction: select upper or lower ranges You can choose whether you want the condition to violate for behavior that goes above the baseline (\"upper\") or that goes below the baseline (\"lower\"), or that goes either above or below. You choose these with the Baseline direction selector. Example use cases for this: You might use the Upper setting for a data source like error rate, because you generally are only concerned if it goes up, and aren't concerned if it goes down. You might use the Lower setting for a data source like throughput, because sudden upward fluctuations are quite common, but a large sudden downswing would be a sign of a problem. Here are examples of how large fluctuations in your data would be treated under the different baseline direction settings. The red areas represent violations. Preview chart: select 2 or 7 days When setting thresholds, the preview chart has an option for displaying Since 2 days ago or Since 7 days ago. These selections are not the time period used to compute the baseline; they are only the time range used for a preview display. For more about the time range used to calculate the baseline, see the algorithm rules.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.87753,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create baseline <em>alert</em> <em>conditions</em>",
        "sections": "Create baseline <em>alert</em> <em>conditions</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": ". Set baseline thresholds one.newrelic.com &gt; AI &amp; <em>Alerts</em> &gt; Policies &gt; (create or select policy) &gt; Create <em>alert</em> condition: Baseline <em>alert</em> <em>conditions</em> give you the ability to set intelligent, self-adjusting thresholds that only generate violations when abnormal behavior is detected. To create a baseline"
      },
      "id": "6044095ee7b9d214955799e9"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/multi-location-synthetic-monitoring-alert-conditions": [
    {
      "sections": [
        "Expanded anomaly detection",
        "Requirements",
        "Why it matters",
        "Get started with anomaly detection",
        "Detect anomalies with a faceted NRQL query",
        "See your anomalies in one place",
        "Tip",
        "Query anomaly data",
        "Reduce the number of detected anomalies"
      ],
      "title": "Expanded anomaly detection",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Proactive detection"
      ],
      "external_id": "0b07c0b6ce27f39b5edb3e112a0f949835cbb8c6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/proactive-detection/expanded-anomaly-detection/",
      "published_at": "2021-06-02T18:27:12Z",
      "updated_at": "2021-05-31T16:43:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We’ve expanded anomaly detection coverage beyond your APM applications. Configure anomaly detection for your browser applications, mobile applications, infrastructure hosts, and nearly anything you want to monitor. Requirements Expanded anomaly detection is available as a limited beta. You can request access here. Why it matters When starting to configure alert conditions for a variety of applications and hosts, it can be difficult to know what you’ll want to be notified about ahead of time. Anomaly detection helps you distinguish between what’s typical performance in your system and where you’re starting to have trouble. Instead of creating your alert conditions manually, you can simply tell us what you want to monitor. Anomaly detection will help you identify baseline performance in your system and flags anomalous activity in your system. Get started with anomaly detection To get started with expanded anomaly detection: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Select the account you want to use to record anomaly data, then select the workload or entities you’d like to monitor. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name your configuration and save. Detect anomalies with a faceted NRQL query To detect anomalies with a faceted NRQL query: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Click Use a query instead. You may need to select an account, if you have more than one. Add one or more queries with a FACET clause. Name the query and confirm the facets you want to monitor for anomalies. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name the configuration and save. See your anomalies in one place When you set up anomaly detection, New Relic starts analyzing the golden signals of your entities and workloads. Anomalies appear in your activity feeds throughout New Relic One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL alert condition for the NrAiAnomaly event. To view anomalies, from one.newrelic.com, go to Alerts & AI > Issues & activity > Anomalies. Query anomaly data Detected anomalies are written to the NrAiAnomaly event in your NRDB account. You can learn more about this event and how to query it here. Reduce the number of detected anomalies If you’re seeing too many anomalies, the first step is to make sure your sensitivity level is set to Low. If it’s already set to Low, you can define specific thresholds to distinguish between normal and anomalous behavior. To define custom thresholds: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab and the configuration you want to modify. Select an entity or workload, and then change the sensitivity level. You can use custom sensitivity to define specific thresholds for different entity types.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 229.8439,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " feeds throughout <em>New</em> <em>Relic</em> One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL <em>alert</em>"
      },
      "id": "60b5124064441ff965e2cb01"
    },
    {
      "sections": [
        "Update or disable policies and conditions",
        "Policy maintenance quick reference",
        "Add or remove policies assigned to a channel",
        "Change a policy name",
        "Check policy user assignment",
        "Check policy channel assignment",
        "Create a new policy",
        "Condition maintenance quick reference",
        "Add more conditions",
        "Copy a condition",
        "Change how threshold violations roll up into incidents",
        "Check for entities (targets) assigned to a policy",
        "Tip",
        "Change a condition",
        "Link to Incident Intelligence",
        "Disable or delete policies and conditions",
        "Disable or re-enable a condition",
        "Disable a policy",
        "Delete policy conditions",
        "Delete a policy"
      ],
      "title": "Update or disable policies and conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert policies"
      ],
      "external_id": "4a6c5107cd6af696df6a3fb0651c6a1bde7daf36",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-policies/update-or-disable-policies-conditions/",
      "published_at": "2021-05-28T11:10:28Z",
      "updated_at": "2021-05-21T15:35:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you create a policy, you can: Add more conditions to the policy. Edit the conditions' names, targets, or thresholds. Disable conditions. Continue the policy setup process by adding one or more notification channels to it. Rename or delete the policy. The user interface shows a Last modified timestamp for any changes to policies, including their conditions and notification channels. Policy maintenance quick reference Here is a quick reference which also includes links to more detailed information and procedures for maintaining your policies. Add or remove policies assigned to a channel To add or remove policies assigned to a channel: In the one.newrelic.com top nav, click Alerts & AI, click Notification channels, then (select a channel). Click Alert policies, then (select a policy). From the selected policy, use the windows to select, remove, or clear all. Change a policy name To rename a policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Click the policy name to edit it, then type a meaningful name for the policy (maximum 64 characters). Check policy user assignment To check whether an account user has been assigned any policies: In the one.newrelic.com top nav, click Alerts & AI, click Policies, (select a policy), then click Notification channels. Select a user, and then click Alert policies. Check policy channel assignment To check whether a notification channel has any policies assigned to it: In the one.newrelic.com top nav, click Alerts & AI, click Notification channels. The Policy subscriptions column lists how many policies are assigned to the channel. Create a new policy To create a new alert policy: In the one.newrelic.com top nav, click Alerts & AI, click Policies. Click New alert policy. Follow standard procedures to complete the basic setup process. Condition maintenance quick reference Here's a quick reference for maintaining a policy conditions. This includes the condition's entities (targets), Warning (yellow) and Critical (red) thresholds, and runbook URL. Add more conditions To add more conditions to a policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then click Add a condition. OR To copy a condition from any policy and add it to another policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then click Copy. Copy a condition To copy an existing condition, including its targets and thresholds, and add it to another policy for the selected account: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). From the policy's list of one or more Alert conditions, click Copy. From the Copy alert condition list, search or scroll the list to select the policy where you want to add this condition. Optional: Change the condition's name if necessary. Select Save. By default, the copied condition will be added to the selected alert policy in a Disabled state. Follow standard procedures to add or copy additional conditions to the alert policy, and then Enable the condition as needed. Change how threshold violations roll up into incidents To select how violations to your thresholds are grouped into incident records (by policy, by condition, or by target and condition): In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Click Incident preference. Check for entities (targets) assigned to a policy To check whether an entity (target) has any policies assigned: Go to the product (APM, Browser, etc.). From the selected product's index, check whether the entity's color-coded health status is light green with an icon. Tip Exception: Infrastructure does not use this feature. Change a condition To change a policy condition: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Then, from the list of Alert conditions for the selected policy: To change the condition's name, click Edit. To add, change, or remove targets (entities), select the name or number of targets for the condition, and then select Browse and select targets. To update the values for the required Critical (red) or optional Warning (yellow) thresholds, select the existing value. To update the condition's runbook URL, select the condition's Thresholds. Link to Incident Intelligence If you use Applied Intelligence, you can connect your conditions to Incident Intelligence. To do this, switch the Connect to Incident Intelligence to ON. Disable or delete policies and conditions If you disable or delete a policy, we'll continue to apply any other policies assigned to the product entity (target). If you remove all policies for the entity, its color-coded health status indicator will appear light green with an icon. Disable or re-enable a condition You can enable or disable any policy conditions, and the policy will continue to apply. To disable or re-enable a condition: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Then, from the list of Alert conditions, (select a condition). Click the On/Off switch to toggle it. Tip For Infrastructure conditions, use the checkbox at the bottom of the condition edit screen, then save the condition. If you copy a condition, it is automatically saved in the new policy as disabled (Off), even if the condition was enabled (On) in the original policy. Disable a policy You can't disable a policy directly. However, you can disable all of the policy's conditions. When you disable all of the conditions, the policy will continue to appear on the Alert policies index. The policy itself isn't disabled, and you can re-enable any or all of its conditions at any time. Delete policy conditions If a policy has multiple conditions, you can delete any or all of them, and the remaining conditions for the policy will continue to apply. To turn a condition off but keep it with the policy, disable it. To delete one or more conditions: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). From the list of Alert conditions, (select a condition), then click Delete. Tip If you don't see the delete button, your account admin may have disabled condition deletion for your organization. Delete a policy If you delete any of your account's policies, you can't restore them. Instead, you must re-create them if necessary. To delete a policy completely: In the one.newrelic.com top nav, click Alerts & AI, then click Alert policies. From the policy row, click the delete icon. Any notification channels associated with a deleted or disabled policy will remain. You must delete notification channels or remove them individually as necessary. You will still be able to view incidents and event violations related to the deleted policy. However, these records will be read only.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 212.17764,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Update or disable policies <em>and</em> <em>conditions</em>",
        "sections": "Update or disable policies <em>and</em> <em>conditions</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " to it: In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click Notification channels. The Policy subscriptions column lists how many policies are assigned to the channel. Create a <em>new</em> policy To create a <em>new</em> <em>alert</em> policy: In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click Policies. Click <em>New</em> <em>alert</em> policy. Follow"
      },
      "id": "604404ec28ccbc62492c6098"
    },
    {
      "sections": [
        "Create baseline alert conditions",
        "How it works",
        "Set baseline thresholds",
        "Faceted baseline conditions",
        "Baseline rules and settings",
        "Rules governing creation of baseline",
        "Baseline direction: select upper or lower ranges",
        "Preview chart: select 2 or 7 days"
      ],
      "title": "Create baseline alert conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "a144b0cc3c5eed1c31dbfcd079959bbd5496346a",
      "image": "https://docs.newrelic.com/static/3be661b029a5f41d3da75175a0259fb9/c1b63/new-relic-baseline-alerts-direction-image-examples_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-baseline-alert-conditions/",
      "published_at": "2021-05-28T03:27:17Z",
      "updated_at": "2021-05-16T08:44:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use baseline conditions to define violation thresholds that adjust to the behavior of your data. Baseline alerting is useful for creating conditions that: Only notify you when data is behaving abnormally. Dynamically adjust to changing data and trends, including daily or weekly trends. In addition, baseline alerting works well with new applications when you do not yet have known behaviors. How it works When you choose a data source (for example, an APM metric) for a baseline condition, we'll use the past values of that data to dynamically predict the data's near-future behavior. The line of that predicted future behavior for that value is called a baseline. It appears as a dotted black line on the preview chart in the baseline condition UI. You'll use the baseline alert condition UI to: Adjust how sensitive the condition is to fluctuations in the data source. Set the behavior that will trigger a violation (for example: \"deviating for more than five minutes\"). Set whether you want the condition to check for upper violations, lower violations, or both. When your data escapes the predicted \"normal\" behavior and meets the criteria you've chosen, you'll receive a notification. Set baseline thresholds one.newrelic.com > AI & Alerts > Policies > (create or select policy) > Create alert condition: Baseline alert conditions give you the ability to set intelligent, self-adjusting thresholds that only generate violations when abnormal behavior is detected. To create a baseline condition: When you start to create a condition, choose one of the following data sources: NRQL: Create a NRQL condition and then choose baseline APM: Application metric baseline Browser: Metric baseline Here are some tips for setting baseline thresholds: Set the baseline direction to monitor violations that happen either above or below the baseline. Set the preview chart to either 2 days or 7 days of displayed data. (Not applicable for NRQL alert conditions.) Use the slider bar to adjust the Critical threshold sensitivity, represented in the preview chart by the light gray area around the baseline. The tighter the band around the baseline, the more sensitive it is and the more violations it will generate. Optional: You can create a Warning threshold (the darker gray area around the baseline). For NRQL alerts, see the allowed types of NRQL queries. If the alert condition applies to multiple apps, you can select a choice from the dropdown above the chart to use different metrics. (Not applicable for NRQL alert conditions.) Faceted baseline conditions NRQL alerts conditions support faceted baselines. In the chart legend, click a time series to scope it to a single facet. Once you've run a faceted NRQL query for a baseline condition, you can scope your results to a single baseline. Click Return to full timeseries list to go back to seeing all your facets. The single time series shows the baseline, threshold band, and one or more violation regions, if there are any. Baseline rules and settings Here are some details about how the UI works: Rules governing creation of baseline The algorithm for baseline conditions is mathematically complex. Here are some of the major rules governing its predictive abilities: Data trait Baseline rules Age of data On initial creation, the baseline is calculated using between 1 to 4 weeks of data, depending on data availability and baseline type. After its creation, the algorithm will take into account ongoing data fluctuations over a long time period, although greater weight is given to more recent data. For data that has only existed for a short time, the baseline will likely fluctuate a good deal and not be very accurate. This is because there is not yet enough data to determine its usual values and behavior. The more history the data has, the more accurate the baseline and thresholds will become. Consistency of data For metric values that remain in a consistent range or that trend slowly and steadily, their more predictable behavior means that their thresholds will become tighter around the baseline. Data that is more varied and unpredictable will have looser (wider) thresholds. Regular fluctuations For shorter-than-one-week cyclical fluctuations (such as weekly Wednesday 1pm deployments or nightly reports), the baseline algorithm looks for these cyclical fluctuations and attempts to adjust to them. Baseline direction: select upper or lower ranges You can choose whether you want the condition to violate for behavior that goes above the baseline (\"upper\") or that goes below the baseline (\"lower\"), or that goes either above or below. You choose these with the Baseline direction selector. Example use cases for this: You might use the Upper setting for a data source like error rate, because you generally are only concerned if it goes up, and aren't concerned if it goes down. You might use the Lower setting for a data source like throughput, because sudden upward fluctuations are quite common, but a large sudden downswing would be a sign of a problem. Here are examples of how large fluctuations in your data would be treated under the different baseline direction settings. The red areas represent violations. Preview chart: select 2 or 7 days When setting thresholds, the preview chart has an option for displaying Since 2 days ago or Since 7 days ago. These selections are not the time period used to compute the baseline; they are only the time range used for a preview display. For more about the time range used to calculate the baseline, see the algorithm rules.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.87753,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create baseline <em>alert</em> <em>conditions</em>",
        "sections": "Create baseline <em>alert</em> <em>conditions</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": ". Set baseline thresholds one.newrelic.com &gt; AI &amp; <em>Alerts</em> &gt; Policies &gt; (create or select policy) &gt; Create <em>alert</em> condition: Baseline <em>alert</em> <em>conditions</em> give you the ability to set intelligent, self-adjusting thresholds that only generate violations when abnormal behavior is detected. To create a baseline"
      },
      "id": "6044095ee7b9d214955799e9"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/outlier-detection-nrql-alert": [
    {
      "sections": [
        "Expanded anomaly detection",
        "Requirements",
        "Why it matters",
        "Get started with anomaly detection",
        "Detect anomalies with a faceted NRQL query",
        "See your anomalies in one place",
        "Tip",
        "Query anomaly data",
        "Reduce the number of detected anomalies"
      ],
      "title": "Expanded anomaly detection",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Proactive detection"
      ],
      "external_id": "0b07c0b6ce27f39b5edb3e112a0f949835cbb8c6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/proactive-detection/expanded-anomaly-detection/",
      "published_at": "2021-06-02T18:27:12Z",
      "updated_at": "2021-05-31T16:43:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We’ve expanded anomaly detection coverage beyond your APM applications. Configure anomaly detection for your browser applications, mobile applications, infrastructure hosts, and nearly anything you want to monitor. Requirements Expanded anomaly detection is available as a limited beta. You can request access here. Why it matters When starting to configure alert conditions for a variety of applications and hosts, it can be difficult to know what you’ll want to be notified about ahead of time. Anomaly detection helps you distinguish between what’s typical performance in your system and where you’re starting to have trouble. Instead of creating your alert conditions manually, you can simply tell us what you want to monitor. Anomaly detection will help you identify baseline performance in your system and flags anomalous activity in your system. Get started with anomaly detection To get started with expanded anomaly detection: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Select the account you want to use to record anomaly data, then select the workload or entities you’d like to monitor. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name your configuration and save. Detect anomalies with a faceted NRQL query To detect anomalies with a faceted NRQL query: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Click Use a query instead. You may need to select an account, if you have more than one. Add one or more queries with a FACET clause. Name the query and confirm the facets you want to monitor for anomalies. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name the configuration and save. See your anomalies in one place When you set up anomaly detection, New Relic starts analyzing the golden signals of your entities and workloads. Anomalies appear in your activity feeds throughout New Relic One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL alert condition for the NrAiAnomaly event. To view anomalies, from one.newrelic.com, go to Alerts & AI > Issues & activity > Anomalies. Query anomaly data Detected anomalies are written to the NrAiAnomaly event in your NRDB account. You can learn more about this event and how to query it here. Reduce the number of detected anomalies If you’re seeing too many anomalies, the first step is to make sure your sensitivity level is set to Low. If it’s already set to Low, you can define specific thresholds to distinguish between normal and anomalous behavior. To define custom thresholds: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab and the configuration you want to modify. Select an entity or workload, and then change the sensitivity level. You can use custom sensitivity to define specific thresholds for different entity types.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 229.8439,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " feeds throughout <em>New</em> <em>Relic</em> One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL <em>alert</em>"
      },
      "id": "60b5124064441ff965e2cb01"
    },
    {
      "sections": [
        "Update or disable policies and conditions",
        "Policy maintenance quick reference",
        "Add or remove policies assigned to a channel",
        "Change a policy name",
        "Check policy user assignment",
        "Check policy channel assignment",
        "Create a new policy",
        "Condition maintenance quick reference",
        "Add more conditions",
        "Copy a condition",
        "Change how threshold violations roll up into incidents",
        "Check for entities (targets) assigned to a policy",
        "Tip",
        "Change a condition",
        "Link to Incident Intelligence",
        "Disable or delete policies and conditions",
        "Disable or re-enable a condition",
        "Disable a policy",
        "Delete policy conditions",
        "Delete a policy"
      ],
      "title": "Update or disable policies and conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert policies"
      ],
      "external_id": "4a6c5107cd6af696df6a3fb0651c6a1bde7daf36",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-policies/update-or-disable-policies-conditions/",
      "published_at": "2021-05-28T11:10:28Z",
      "updated_at": "2021-05-21T15:35:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you create a policy, you can: Add more conditions to the policy. Edit the conditions' names, targets, or thresholds. Disable conditions. Continue the policy setup process by adding one or more notification channels to it. Rename or delete the policy. The user interface shows a Last modified timestamp for any changes to policies, including their conditions and notification channels. Policy maintenance quick reference Here is a quick reference which also includes links to more detailed information and procedures for maintaining your policies. Add or remove policies assigned to a channel To add or remove policies assigned to a channel: In the one.newrelic.com top nav, click Alerts & AI, click Notification channels, then (select a channel). Click Alert policies, then (select a policy). From the selected policy, use the windows to select, remove, or clear all. Change a policy name To rename a policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Click the policy name to edit it, then type a meaningful name for the policy (maximum 64 characters). Check policy user assignment To check whether an account user has been assigned any policies: In the one.newrelic.com top nav, click Alerts & AI, click Policies, (select a policy), then click Notification channels. Select a user, and then click Alert policies. Check policy channel assignment To check whether a notification channel has any policies assigned to it: In the one.newrelic.com top nav, click Alerts & AI, click Notification channels. The Policy subscriptions column lists how many policies are assigned to the channel. Create a new policy To create a new alert policy: In the one.newrelic.com top nav, click Alerts & AI, click Policies. Click New alert policy. Follow standard procedures to complete the basic setup process. Condition maintenance quick reference Here's a quick reference for maintaining a policy conditions. This includes the condition's entities (targets), Warning (yellow) and Critical (red) thresholds, and runbook URL. Add more conditions To add more conditions to a policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then click Add a condition. OR To copy a condition from any policy and add it to another policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then click Copy. Copy a condition To copy an existing condition, including its targets and thresholds, and add it to another policy for the selected account: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). From the policy's list of one or more Alert conditions, click Copy. From the Copy alert condition list, search or scroll the list to select the policy where you want to add this condition. Optional: Change the condition's name if necessary. Select Save. By default, the copied condition will be added to the selected alert policy in a Disabled state. Follow standard procedures to add or copy additional conditions to the alert policy, and then Enable the condition as needed. Change how threshold violations roll up into incidents To select how violations to your thresholds are grouped into incident records (by policy, by condition, or by target and condition): In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Click Incident preference. Check for entities (targets) assigned to a policy To check whether an entity (target) has any policies assigned: Go to the product (APM, Browser, etc.). From the selected product's index, check whether the entity's color-coded health status is light green with an icon. Tip Exception: Infrastructure does not use this feature. Change a condition To change a policy condition: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Then, from the list of Alert conditions for the selected policy: To change the condition's name, click Edit. To add, change, or remove targets (entities), select the name or number of targets for the condition, and then select Browse and select targets. To update the values for the required Critical (red) or optional Warning (yellow) thresholds, select the existing value. To update the condition's runbook URL, select the condition's Thresholds. Link to Incident Intelligence If you use Applied Intelligence, you can connect your conditions to Incident Intelligence. To do this, switch the Connect to Incident Intelligence to ON. Disable or delete policies and conditions If you disable or delete a policy, we'll continue to apply any other policies assigned to the product entity (target). If you remove all policies for the entity, its color-coded health status indicator will appear light green with an icon. Disable or re-enable a condition You can enable or disable any policy conditions, and the policy will continue to apply. To disable or re-enable a condition: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Then, from the list of Alert conditions, (select a condition). Click the On/Off switch to toggle it. Tip For Infrastructure conditions, use the checkbox at the bottom of the condition edit screen, then save the condition. If you copy a condition, it is automatically saved in the new policy as disabled (Off), even if the condition was enabled (On) in the original policy. Disable a policy You can't disable a policy directly. However, you can disable all of the policy's conditions. When you disable all of the conditions, the policy will continue to appear on the Alert policies index. The policy itself isn't disabled, and you can re-enable any or all of its conditions at any time. Delete policy conditions If a policy has multiple conditions, you can delete any or all of them, and the remaining conditions for the policy will continue to apply. To turn a condition off but keep it with the policy, disable it. To delete one or more conditions: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). From the list of Alert conditions, (select a condition), then click Delete. Tip If you don't see the delete button, your account admin may have disabled condition deletion for your organization. Delete a policy If you delete any of your account's policies, you can't restore them. Instead, you must re-create them if necessary. To delete a policy completely: In the one.newrelic.com top nav, click Alerts & AI, then click Alert policies. From the policy row, click the delete icon. Any notification channels associated with a deleted or disabled policy will remain. You must delete notification channels or remove them individually as necessary. You will still be able to view incidents and event violations related to the deleted policy. However, these records will be read only.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 212.17764,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Update or disable policies <em>and</em> <em>conditions</em>",
        "sections": "Update or disable policies <em>and</em> <em>conditions</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " to it: In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click Notification channels. The Policy subscriptions column lists how many policies are assigned to the channel. Create a <em>new</em> policy To create a <em>new</em> <em>alert</em> policy: In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click Policies. Click <em>New</em> <em>alert</em> policy. Follow"
      },
      "id": "604404ec28ccbc62492c6098"
    },
    {
      "sections": [
        "Create baseline alert conditions",
        "How it works",
        "Set baseline thresholds",
        "Faceted baseline conditions",
        "Baseline rules and settings",
        "Rules governing creation of baseline",
        "Baseline direction: select upper or lower ranges",
        "Preview chart: select 2 or 7 days"
      ],
      "title": "Create baseline alert conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "a144b0cc3c5eed1c31dbfcd079959bbd5496346a",
      "image": "https://docs.newrelic.com/static/3be661b029a5f41d3da75175a0259fb9/c1b63/new-relic-baseline-alerts-direction-image-examples_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-baseline-alert-conditions/",
      "published_at": "2021-05-28T03:27:17Z",
      "updated_at": "2021-05-16T08:44:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use baseline conditions to define violation thresholds that adjust to the behavior of your data. Baseline alerting is useful for creating conditions that: Only notify you when data is behaving abnormally. Dynamically adjust to changing data and trends, including daily or weekly trends. In addition, baseline alerting works well with new applications when you do not yet have known behaviors. How it works When you choose a data source (for example, an APM metric) for a baseline condition, we'll use the past values of that data to dynamically predict the data's near-future behavior. The line of that predicted future behavior for that value is called a baseline. It appears as a dotted black line on the preview chart in the baseline condition UI. You'll use the baseline alert condition UI to: Adjust how sensitive the condition is to fluctuations in the data source. Set the behavior that will trigger a violation (for example: \"deviating for more than five minutes\"). Set whether you want the condition to check for upper violations, lower violations, or both. When your data escapes the predicted \"normal\" behavior and meets the criteria you've chosen, you'll receive a notification. Set baseline thresholds one.newrelic.com > AI & Alerts > Policies > (create or select policy) > Create alert condition: Baseline alert conditions give you the ability to set intelligent, self-adjusting thresholds that only generate violations when abnormal behavior is detected. To create a baseline condition: When you start to create a condition, choose one of the following data sources: NRQL: Create a NRQL condition and then choose baseline APM: Application metric baseline Browser: Metric baseline Here are some tips for setting baseline thresholds: Set the baseline direction to monitor violations that happen either above or below the baseline. Set the preview chart to either 2 days or 7 days of displayed data. (Not applicable for NRQL alert conditions.) Use the slider bar to adjust the Critical threshold sensitivity, represented in the preview chart by the light gray area around the baseline. The tighter the band around the baseline, the more sensitive it is and the more violations it will generate. Optional: You can create a Warning threshold (the darker gray area around the baseline). For NRQL alerts, see the allowed types of NRQL queries. If the alert condition applies to multiple apps, you can select a choice from the dropdown above the chart to use different metrics. (Not applicable for NRQL alert conditions.) Faceted baseline conditions NRQL alerts conditions support faceted baselines. In the chart legend, click a time series to scope it to a single facet. Once you've run a faceted NRQL query for a baseline condition, you can scope your results to a single baseline. Click Return to full timeseries list to go back to seeing all your facets. The single time series shows the baseline, threshold band, and one or more violation regions, if there are any. Baseline rules and settings Here are some details about how the UI works: Rules governing creation of baseline The algorithm for baseline conditions is mathematically complex. Here are some of the major rules governing its predictive abilities: Data trait Baseline rules Age of data On initial creation, the baseline is calculated using between 1 to 4 weeks of data, depending on data availability and baseline type. After its creation, the algorithm will take into account ongoing data fluctuations over a long time period, although greater weight is given to more recent data. For data that has only existed for a short time, the baseline will likely fluctuate a good deal and not be very accurate. This is because there is not yet enough data to determine its usual values and behavior. The more history the data has, the more accurate the baseline and thresholds will become. Consistency of data For metric values that remain in a consistent range or that trend slowly and steadily, their more predictable behavior means that their thresholds will become tighter around the baseline. Data that is more varied and unpredictable will have looser (wider) thresholds. Regular fluctuations For shorter-than-one-week cyclical fluctuations (such as weekly Wednesday 1pm deployments or nightly reports), the baseline algorithm looks for these cyclical fluctuations and attempts to adjust to them. Baseline direction: select upper or lower ranges You can choose whether you want the condition to violate for behavior that goes above the baseline (\"upper\") or that goes below the baseline (\"lower\"), or that goes either above or below. You choose these with the Baseline direction selector. Example use cases for this: You might use the Upper setting for a data source like error rate, because you generally are only concerned if it goes up, and aren't concerned if it goes down. You might use the Lower setting for a data source like throughput, because sudden upward fluctuations are quite common, but a large sudden downswing would be a sign of a problem. Here are examples of how large fluctuations in your data would be treated under the different baseline direction settings. The red areas represent violations. Preview chart: select 2 or 7 days When setting thresholds, the preview chart has an option for displaying Since 2 days ago or Since 7 days ago. These selections are not the time period used to compute the baseline; they are only the time range used for a preview display. For more about the time range used to calculate the baseline, see the algorithm rules.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.87753,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create baseline <em>alert</em> <em>conditions</em>",
        "sections": "Create baseline <em>alert</em> <em>conditions</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": ". Set baseline thresholds one.newrelic.com &gt; AI &amp; <em>Alerts</em> &gt; Policies &gt; (create or select policy) &gt; Create <em>alert</em> condition: Baseline <em>alert</em> <em>conditions</em> give you the ability to set intelligent, self-adjusting thresholds that only generate violations when abnormal behavior is detected. To create a baseline"
      },
      "id": "6044095ee7b9d214955799e9"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/provide-runbook-instructions-alert-activity": [
    {
      "sections": [
        "Expanded anomaly detection",
        "Requirements",
        "Why it matters",
        "Get started with anomaly detection",
        "Detect anomalies with a faceted NRQL query",
        "See your anomalies in one place",
        "Tip",
        "Query anomaly data",
        "Reduce the number of detected anomalies"
      ],
      "title": "Expanded anomaly detection",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Proactive detection"
      ],
      "external_id": "0b07c0b6ce27f39b5edb3e112a0f949835cbb8c6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/proactive-detection/expanded-anomaly-detection/",
      "published_at": "2021-06-02T18:27:12Z",
      "updated_at": "2021-05-31T16:43:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We’ve expanded anomaly detection coverage beyond your APM applications. Configure anomaly detection for your browser applications, mobile applications, infrastructure hosts, and nearly anything you want to monitor. Requirements Expanded anomaly detection is available as a limited beta. You can request access here. Why it matters When starting to configure alert conditions for a variety of applications and hosts, it can be difficult to know what you’ll want to be notified about ahead of time. Anomaly detection helps you distinguish between what’s typical performance in your system and where you’re starting to have trouble. Instead of creating your alert conditions manually, you can simply tell us what you want to monitor. Anomaly detection will help you identify baseline performance in your system and flags anomalous activity in your system. Get started with anomaly detection To get started with expanded anomaly detection: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Select the account you want to use to record anomaly data, then select the workload or entities you’d like to monitor. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name your configuration and save. Detect anomalies with a faceted NRQL query To detect anomalies with a faceted NRQL query: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Click Use a query instead. You may need to select an account, if you have more than one. Add one or more queries with a FACET clause. Name the query and confirm the facets you want to monitor for anomalies. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name the configuration and save. See your anomalies in one place When you set up anomaly detection, New Relic starts analyzing the golden signals of your entities and workloads. Anomalies appear in your activity feeds throughout New Relic One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL alert condition for the NrAiAnomaly event. To view anomalies, from one.newrelic.com, go to Alerts & AI > Issues & activity > Anomalies. Query anomaly data Detected anomalies are written to the NrAiAnomaly event in your NRDB account. You can learn more about this event and how to query it here. Reduce the number of detected anomalies If you’re seeing too many anomalies, the first step is to make sure your sensitivity level is set to Low. If it’s already set to Low, you can define specific thresholds to distinguish between normal and anomalous behavior. To define custom thresholds: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab and the configuration you want to modify. Select an entity or workload, and then change the sensitivity level. You can use custom sensitivity to define specific thresholds for different entity types.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 229.84377,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " feeds throughout <em>New</em> <em>Relic</em> One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL <em>alert</em>"
      },
      "id": "60b5124064441ff965e2cb01"
    },
    {
      "sections": [
        "Update or disable policies and conditions",
        "Policy maintenance quick reference",
        "Add or remove policies assigned to a channel",
        "Change a policy name",
        "Check policy user assignment",
        "Check policy channel assignment",
        "Create a new policy",
        "Condition maintenance quick reference",
        "Add more conditions",
        "Copy a condition",
        "Change how threshold violations roll up into incidents",
        "Check for entities (targets) assigned to a policy",
        "Tip",
        "Change a condition",
        "Link to Incident Intelligence",
        "Disable or delete policies and conditions",
        "Disable or re-enable a condition",
        "Disable a policy",
        "Delete policy conditions",
        "Delete a policy"
      ],
      "title": "Update or disable policies and conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert policies"
      ],
      "external_id": "4a6c5107cd6af696df6a3fb0651c6a1bde7daf36",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-policies/update-or-disable-policies-conditions/",
      "published_at": "2021-05-28T11:10:28Z",
      "updated_at": "2021-05-21T15:35:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you create a policy, you can: Add more conditions to the policy. Edit the conditions' names, targets, or thresholds. Disable conditions. Continue the policy setup process by adding one or more notification channels to it. Rename or delete the policy. The user interface shows a Last modified timestamp for any changes to policies, including their conditions and notification channels. Policy maintenance quick reference Here is a quick reference which also includes links to more detailed information and procedures for maintaining your policies. Add or remove policies assigned to a channel To add or remove policies assigned to a channel: In the one.newrelic.com top nav, click Alerts & AI, click Notification channels, then (select a channel). Click Alert policies, then (select a policy). From the selected policy, use the windows to select, remove, or clear all. Change a policy name To rename a policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Click the policy name to edit it, then type a meaningful name for the policy (maximum 64 characters). Check policy user assignment To check whether an account user has been assigned any policies: In the one.newrelic.com top nav, click Alerts & AI, click Policies, (select a policy), then click Notification channels. Select a user, and then click Alert policies. Check policy channel assignment To check whether a notification channel has any policies assigned to it: In the one.newrelic.com top nav, click Alerts & AI, click Notification channels. The Policy subscriptions column lists how many policies are assigned to the channel. Create a new policy To create a new alert policy: In the one.newrelic.com top nav, click Alerts & AI, click Policies. Click New alert policy. Follow standard procedures to complete the basic setup process. Condition maintenance quick reference Here's a quick reference for maintaining a policy conditions. This includes the condition's entities (targets), Warning (yellow) and Critical (red) thresholds, and runbook URL. Add more conditions To add more conditions to a policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then click Add a condition. OR To copy a condition from any policy and add it to another policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then click Copy. Copy a condition To copy an existing condition, including its targets and thresholds, and add it to another policy for the selected account: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). From the policy's list of one or more Alert conditions, click Copy. From the Copy alert condition list, search or scroll the list to select the policy where you want to add this condition. Optional: Change the condition's name if necessary. Select Save. By default, the copied condition will be added to the selected alert policy in a Disabled state. Follow standard procedures to add or copy additional conditions to the alert policy, and then Enable the condition as needed. Change how threshold violations roll up into incidents To select how violations to your thresholds are grouped into incident records (by policy, by condition, or by target and condition): In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Click Incident preference. Check for entities (targets) assigned to a policy To check whether an entity (target) has any policies assigned: Go to the product (APM, Browser, etc.). From the selected product's index, check whether the entity's color-coded health status is light green with an icon. Tip Exception: Infrastructure does not use this feature. Change a condition To change a policy condition: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Then, from the list of Alert conditions for the selected policy: To change the condition's name, click Edit. To add, change, or remove targets (entities), select the name or number of targets for the condition, and then select Browse and select targets. To update the values for the required Critical (red) or optional Warning (yellow) thresholds, select the existing value. To update the condition's runbook URL, select the condition's Thresholds. Link to Incident Intelligence If you use Applied Intelligence, you can connect your conditions to Incident Intelligence. To do this, switch the Connect to Incident Intelligence to ON. Disable or delete policies and conditions If you disable or delete a policy, we'll continue to apply any other policies assigned to the product entity (target). If you remove all policies for the entity, its color-coded health status indicator will appear light green with an icon. Disable or re-enable a condition You can enable or disable any policy conditions, and the policy will continue to apply. To disable or re-enable a condition: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Then, from the list of Alert conditions, (select a condition). Click the On/Off switch to toggle it. Tip For Infrastructure conditions, use the checkbox at the bottom of the condition edit screen, then save the condition. If you copy a condition, it is automatically saved in the new policy as disabled (Off), even if the condition was enabled (On) in the original policy. Disable a policy You can't disable a policy directly. However, you can disable all of the policy's conditions. When you disable all of the conditions, the policy will continue to appear on the Alert policies index. The policy itself isn't disabled, and you can re-enable any or all of its conditions at any time. Delete policy conditions If a policy has multiple conditions, you can delete any or all of them, and the remaining conditions for the policy will continue to apply. To turn a condition off but keep it with the policy, disable it. To delete one or more conditions: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). From the list of Alert conditions, (select a condition), then click Delete. Tip If you don't see the delete button, your account admin may have disabled condition deletion for your organization. Delete a policy If you delete any of your account's policies, you can't restore them. Instead, you must re-create them if necessary. To delete a policy completely: In the one.newrelic.com top nav, click Alerts & AI, then click Alert policies. From the policy row, click the delete icon. Any notification channels associated with a deleted or disabled policy will remain. You must delete notification channels or remove them individually as necessary. You will still be able to view incidents and event violations related to the deleted policy. However, these records will be read only.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 212.17761,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Update or disable policies <em>and</em> <em>conditions</em>",
        "sections": "Update or disable policies <em>and</em> <em>conditions</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " to it: In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click Notification channels. The Policy subscriptions column lists how many policies are assigned to the channel. Create a <em>new</em> policy To create a <em>new</em> <em>alert</em> policy: In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click Policies. Click <em>New</em> <em>alert</em> policy. Follow"
      },
      "id": "604404ec28ccbc62492c6098"
    },
    {
      "sections": [
        "Create baseline alert conditions",
        "How it works",
        "Set baseline thresholds",
        "Faceted baseline conditions",
        "Baseline rules and settings",
        "Rules governing creation of baseline",
        "Baseline direction: select upper or lower ranges",
        "Preview chart: select 2 or 7 days"
      ],
      "title": "Create baseline alert conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "a144b0cc3c5eed1c31dbfcd079959bbd5496346a",
      "image": "https://docs.newrelic.com/static/3be661b029a5f41d3da75175a0259fb9/c1b63/new-relic-baseline-alerts-direction-image-examples_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-baseline-alert-conditions/",
      "published_at": "2021-05-28T03:27:17Z",
      "updated_at": "2021-05-16T08:44:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use baseline conditions to define violation thresholds that adjust to the behavior of your data. Baseline alerting is useful for creating conditions that: Only notify you when data is behaving abnormally. Dynamically adjust to changing data and trends, including daily or weekly trends. In addition, baseline alerting works well with new applications when you do not yet have known behaviors. How it works When you choose a data source (for example, an APM metric) for a baseline condition, we'll use the past values of that data to dynamically predict the data's near-future behavior. The line of that predicted future behavior for that value is called a baseline. It appears as a dotted black line on the preview chart in the baseline condition UI. You'll use the baseline alert condition UI to: Adjust how sensitive the condition is to fluctuations in the data source. Set the behavior that will trigger a violation (for example: \"deviating for more than five minutes\"). Set whether you want the condition to check for upper violations, lower violations, or both. When your data escapes the predicted \"normal\" behavior and meets the criteria you've chosen, you'll receive a notification. Set baseline thresholds one.newrelic.com > AI & Alerts > Policies > (create or select policy) > Create alert condition: Baseline alert conditions give you the ability to set intelligent, self-adjusting thresholds that only generate violations when abnormal behavior is detected. To create a baseline condition: When you start to create a condition, choose one of the following data sources: NRQL: Create a NRQL condition and then choose baseline APM: Application metric baseline Browser: Metric baseline Here are some tips for setting baseline thresholds: Set the baseline direction to monitor violations that happen either above or below the baseline. Set the preview chart to either 2 days or 7 days of displayed data. (Not applicable for NRQL alert conditions.) Use the slider bar to adjust the Critical threshold sensitivity, represented in the preview chart by the light gray area around the baseline. The tighter the band around the baseline, the more sensitive it is and the more violations it will generate. Optional: You can create a Warning threshold (the darker gray area around the baseline). For NRQL alerts, see the allowed types of NRQL queries. If the alert condition applies to multiple apps, you can select a choice from the dropdown above the chart to use different metrics. (Not applicable for NRQL alert conditions.) Faceted baseline conditions NRQL alerts conditions support faceted baselines. In the chart legend, click a time series to scope it to a single facet. Once you've run a faceted NRQL query for a baseline condition, you can scope your results to a single baseline. Click Return to full timeseries list to go back to seeing all your facets. The single time series shows the baseline, threshold band, and one or more violation regions, if there are any. Baseline rules and settings Here are some details about how the UI works: Rules governing creation of baseline The algorithm for baseline conditions is mathematically complex. Here are some of the major rules governing its predictive abilities: Data trait Baseline rules Age of data On initial creation, the baseline is calculated using between 1 to 4 weeks of data, depending on data availability and baseline type. After its creation, the algorithm will take into account ongoing data fluctuations over a long time period, although greater weight is given to more recent data. For data that has only existed for a short time, the baseline will likely fluctuate a good deal and not be very accurate. This is because there is not yet enough data to determine its usual values and behavior. The more history the data has, the more accurate the baseline and thresholds will become. Consistency of data For metric values that remain in a consistent range or that trend slowly and steadily, their more predictable behavior means that their thresholds will become tighter around the baseline. Data that is more varied and unpredictable will have looser (wider) thresholds. Regular fluctuations For shorter-than-one-week cyclical fluctuations (such as weekly Wednesday 1pm deployments or nightly reports), the baseline algorithm looks for these cyclical fluctuations and attempts to adjust to them. Baseline direction: select upper or lower ranges You can choose whether you want the condition to violate for behavior that goes above the baseline (\"upper\") or that goes below the baseline (\"lower\"), or that goes either above or below. You choose these with the Baseline direction selector. Example use cases for this: You might use the Upper setting for a data source like error rate, because you generally are only concerned if it goes up, and aren't concerned if it goes down. You might use the Lower setting for a data source like throughput, because sudden upward fluctuations are quite common, but a large sudden downswing would be a sign of a problem. Here are examples of how large fluctuations in your data would be treated under the different baseline direction settings. The red areas represent violations. Preview chart: select 2 or 7 days When setting thresholds, the preview chart has an option for displaying Since 2 days ago or Since 7 days ago. These selections are not the time period used to compute the baseline; they are only the time range used for a preview display. For more about the time range used to calculate the baseline, see the algorithm rules.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.8775,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create baseline <em>alert</em> <em>conditions</em>",
        "sections": "Create baseline <em>alert</em> <em>conditions</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": ". Set baseline thresholds one.newrelic.com &gt; AI &amp; <em>Alerts</em> &gt; Policies &gt; (create or select policy) &gt; Create <em>alert</em> condition: Baseline <em>alert</em> <em>conditions</em> give you the ability to set intelligent, self-adjusting thresholds that only generate violations when abnormal behavior is detected. To create a baseline"
      },
      "id": "6044095ee7b9d214955799e9"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/scope-alert-thresholds-specific-instances": [
    {
      "sections": [
        "Expanded anomaly detection",
        "Requirements",
        "Why it matters",
        "Get started with anomaly detection",
        "Detect anomalies with a faceted NRQL query",
        "See your anomalies in one place",
        "Tip",
        "Query anomaly data",
        "Reduce the number of detected anomalies"
      ],
      "title": "Expanded anomaly detection",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Proactive detection"
      ],
      "external_id": "0b07c0b6ce27f39b5edb3e112a0f949835cbb8c6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/proactive-detection/expanded-anomaly-detection/",
      "published_at": "2021-06-02T18:27:12Z",
      "updated_at": "2021-05-31T16:43:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We’ve expanded anomaly detection coverage beyond your APM applications. Configure anomaly detection for your browser applications, mobile applications, infrastructure hosts, and nearly anything you want to monitor. Requirements Expanded anomaly detection is available as a limited beta. You can request access here. Why it matters When starting to configure alert conditions for a variety of applications and hosts, it can be difficult to know what you’ll want to be notified about ahead of time. Anomaly detection helps you distinguish between what’s typical performance in your system and where you’re starting to have trouble. Instead of creating your alert conditions manually, you can simply tell us what you want to monitor. Anomaly detection will help you identify baseline performance in your system and flags anomalous activity in your system. Get started with anomaly detection To get started with expanded anomaly detection: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Select the account you want to use to record anomaly data, then select the workload or entities you’d like to monitor. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name your configuration and save. Detect anomalies with a faceted NRQL query To detect anomalies with a faceted NRQL query: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Click Use a query instead. You may need to select an account, if you have more than one. Add one or more queries with a FACET clause. Name the query and confirm the facets you want to monitor for anomalies. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name the configuration and save. See your anomalies in one place When you set up anomaly detection, New Relic starts analyzing the golden signals of your entities and workloads. Anomalies appear in your activity feeds throughout New Relic One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL alert condition for the NrAiAnomaly event. To view anomalies, from one.newrelic.com, go to Alerts & AI > Issues & activity > Anomalies. Query anomaly data Detected anomalies are written to the NrAiAnomaly event in your NRDB account. You can learn more about this event and how to query it here. Reduce the number of detected anomalies If you’re seeing too many anomalies, the first step is to make sure your sensitivity level is set to Low. If it’s already set to Low, you can define specific thresholds to distinguish between normal and anomalous behavior. To define custom thresholds: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab and the configuration you want to modify. Select an entity or workload, and then change the sensitivity level. You can use custom sensitivity to define specific thresholds for different entity types.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 229.84377,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " feeds throughout <em>New</em> <em>Relic</em> One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL <em>alert</em>"
      },
      "id": "60b5124064441ff965e2cb01"
    },
    {
      "sections": [
        "Update or disable policies and conditions",
        "Policy maintenance quick reference",
        "Add or remove policies assigned to a channel",
        "Change a policy name",
        "Check policy user assignment",
        "Check policy channel assignment",
        "Create a new policy",
        "Condition maintenance quick reference",
        "Add more conditions",
        "Copy a condition",
        "Change how threshold violations roll up into incidents",
        "Check for entities (targets) assigned to a policy",
        "Tip",
        "Change a condition",
        "Link to Incident Intelligence",
        "Disable or delete policies and conditions",
        "Disable or re-enable a condition",
        "Disable a policy",
        "Delete policy conditions",
        "Delete a policy"
      ],
      "title": "Update or disable policies and conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert policies"
      ],
      "external_id": "4a6c5107cd6af696df6a3fb0651c6a1bde7daf36",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-policies/update-or-disable-policies-conditions/",
      "published_at": "2021-05-28T11:10:28Z",
      "updated_at": "2021-05-21T15:35:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you create a policy, you can: Add more conditions to the policy. Edit the conditions' names, targets, or thresholds. Disable conditions. Continue the policy setup process by adding one or more notification channels to it. Rename or delete the policy. The user interface shows a Last modified timestamp for any changes to policies, including their conditions and notification channels. Policy maintenance quick reference Here is a quick reference which also includes links to more detailed information and procedures for maintaining your policies. Add or remove policies assigned to a channel To add or remove policies assigned to a channel: In the one.newrelic.com top nav, click Alerts & AI, click Notification channels, then (select a channel). Click Alert policies, then (select a policy). From the selected policy, use the windows to select, remove, or clear all. Change a policy name To rename a policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Click the policy name to edit it, then type a meaningful name for the policy (maximum 64 characters). Check policy user assignment To check whether an account user has been assigned any policies: In the one.newrelic.com top nav, click Alerts & AI, click Policies, (select a policy), then click Notification channels. Select a user, and then click Alert policies. Check policy channel assignment To check whether a notification channel has any policies assigned to it: In the one.newrelic.com top nav, click Alerts & AI, click Notification channels. The Policy subscriptions column lists how many policies are assigned to the channel. Create a new policy To create a new alert policy: In the one.newrelic.com top nav, click Alerts & AI, click Policies. Click New alert policy. Follow standard procedures to complete the basic setup process. Condition maintenance quick reference Here's a quick reference for maintaining a policy conditions. This includes the condition's entities (targets), Warning (yellow) and Critical (red) thresholds, and runbook URL. Add more conditions To add more conditions to a policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then click Add a condition. OR To copy a condition from any policy and add it to another policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then click Copy. Copy a condition To copy an existing condition, including its targets and thresholds, and add it to another policy for the selected account: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). From the policy's list of one or more Alert conditions, click Copy. From the Copy alert condition list, search or scroll the list to select the policy where you want to add this condition. Optional: Change the condition's name if necessary. Select Save. By default, the copied condition will be added to the selected alert policy in a Disabled state. Follow standard procedures to add or copy additional conditions to the alert policy, and then Enable the condition as needed. Change how threshold violations roll up into incidents To select how violations to your thresholds are grouped into incident records (by policy, by condition, or by target and condition): In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Click Incident preference. Check for entities (targets) assigned to a policy To check whether an entity (target) has any policies assigned: Go to the product (APM, Browser, etc.). From the selected product's index, check whether the entity's color-coded health status is light green with an icon. Tip Exception: Infrastructure does not use this feature. Change a condition To change a policy condition: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Then, from the list of Alert conditions for the selected policy: To change the condition's name, click Edit. To add, change, or remove targets (entities), select the name or number of targets for the condition, and then select Browse and select targets. To update the values for the required Critical (red) or optional Warning (yellow) thresholds, select the existing value. To update the condition's runbook URL, select the condition's Thresholds. Link to Incident Intelligence If you use Applied Intelligence, you can connect your conditions to Incident Intelligence. To do this, switch the Connect to Incident Intelligence to ON. Disable or delete policies and conditions If you disable or delete a policy, we'll continue to apply any other policies assigned to the product entity (target). If you remove all policies for the entity, its color-coded health status indicator will appear light green with an icon. Disable or re-enable a condition You can enable or disable any policy conditions, and the policy will continue to apply. To disable or re-enable a condition: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Then, from the list of Alert conditions, (select a condition). Click the On/Off switch to toggle it. Tip For Infrastructure conditions, use the checkbox at the bottom of the condition edit screen, then save the condition. If you copy a condition, it is automatically saved in the new policy as disabled (Off), even if the condition was enabled (On) in the original policy. Disable a policy You can't disable a policy directly. However, you can disable all of the policy's conditions. When you disable all of the conditions, the policy will continue to appear on the Alert policies index. The policy itself isn't disabled, and you can re-enable any or all of its conditions at any time. Delete policy conditions If a policy has multiple conditions, you can delete any or all of them, and the remaining conditions for the policy will continue to apply. To turn a condition off but keep it with the policy, disable it. To delete one or more conditions: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). From the list of Alert conditions, (select a condition), then click Delete. Tip If you don't see the delete button, your account admin may have disabled condition deletion for your organization. Delete a policy If you delete any of your account's policies, you can't restore them. Instead, you must re-create them if necessary. To delete a policy completely: In the one.newrelic.com top nav, click Alerts & AI, then click Alert policies. From the policy row, click the delete icon. Any notification channels associated with a deleted or disabled policy will remain. You must delete notification channels or remove them individually as necessary. You will still be able to view incidents and event violations related to the deleted policy. However, these records will be read only.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 212.17761,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Update or disable policies <em>and</em> <em>conditions</em>",
        "sections": "Update or disable policies <em>and</em> <em>conditions</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " to it: In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click Notification channels. The Policy subscriptions column lists how many policies are assigned to the channel. Create a <em>new</em> policy To create a <em>new</em> <em>alert</em> policy: In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click Policies. Click <em>New</em> <em>alert</em> policy. Follow"
      },
      "id": "604404ec28ccbc62492c6098"
    },
    {
      "sections": [
        "Create baseline alert conditions",
        "How it works",
        "Set baseline thresholds",
        "Faceted baseline conditions",
        "Baseline rules and settings",
        "Rules governing creation of baseline",
        "Baseline direction: select upper or lower ranges",
        "Preview chart: select 2 or 7 days"
      ],
      "title": "Create baseline alert conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "a144b0cc3c5eed1c31dbfcd079959bbd5496346a",
      "image": "https://docs.newrelic.com/static/3be661b029a5f41d3da75175a0259fb9/c1b63/new-relic-baseline-alerts-direction-image-examples_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-baseline-alert-conditions/",
      "published_at": "2021-05-28T03:27:17Z",
      "updated_at": "2021-05-16T08:44:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use baseline conditions to define violation thresholds that adjust to the behavior of your data. Baseline alerting is useful for creating conditions that: Only notify you when data is behaving abnormally. Dynamically adjust to changing data and trends, including daily or weekly trends. In addition, baseline alerting works well with new applications when you do not yet have known behaviors. How it works When you choose a data source (for example, an APM metric) for a baseline condition, we'll use the past values of that data to dynamically predict the data's near-future behavior. The line of that predicted future behavior for that value is called a baseline. It appears as a dotted black line on the preview chart in the baseline condition UI. You'll use the baseline alert condition UI to: Adjust how sensitive the condition is to fluctuations in the data source. Set the behavior that will trigger a violation (for example: \"deviating for more than five minutes\"). Set whether you want the condition to check for upper violations, lower violations, or both. When your data escapes the predicted \"normal\" behavior and meets the criteria you've chosen, you'll receive a notification. Set baseline thresholds one.newrelic.com > AI & Alerts > Policies > (create or select policy) > Create alert condition: Baseline alert conditions give you the ability to set intelligent, self-adjusting thresholds that only generate violations when abnormal behavior is detected. To create a baseline condition: When you start to create a condition, choose one of the following data sources: NRQL: Create a NRQL condition and then choose baseline APM: Application metric baseline Browser: Metric baseline Here are some tips for setting baseline thresholds: Set the baseline direction to monitor violations that happen either above or below the baseline. Set the preview chart to either 2 days or 7 days of displayed data. (Not applicable for NRQL alert conditions.) Use the slider bar to adjust the Critical threshold sensitivity, represented in the preview chart by the light gray area around the baseline. The tighter the band around the baseline, the more sensitive it is and the more violations it will generate. Optional: You can create a Warning threshold (the darker gray area around the baseline). For NRQL alerts, see the allowed types of NRQL queries. If the alert condition applies to multiple apps, you can select a choice from the dropdown above the chart to use different metrics. (Not applicable for NRQL alert conditions.) Faceted baseline conditions NRQL alerts conditions support faceted baselines. In the chart legend, click a time series to scope it to a single facet. Once you've run a faceted NRQL query for a baseline condition, you can scope your results to a single baseline. Click Return to full timeseries list to go back to seeing all your facets. The single time series shows the baseline, threshold band, and one or more violation regions, if there are any. Baseline rules and settings Here are some details about how the UI works: Rules governing creation of baseline The algorithm for baseline conditions is mathematically complex. Here are some of the major rules governing its predictive abilities: Data trait Baseline rules Age of data On initial creation, the baseline is calculated using between 1 to 4 weeks of data, depending on data availability and baseline type. After its creation, the algorithm will take into account ongoing data fluctuations over a long time period, although greater weight is given to more recent data. For data that has only existed for a short time, the baseline will likely fluctuate a good deal and not be very accurate. This is because there is not yet enough data to determine its usual values and behavior. The more history the data has, the more accurate the baseline and thresholds will become. Consistency of data For metric values that remain in a consistent range or that trend slowly and steadily, their more predictable behavior means that their thresholds will become tighter around the baseline. Data that is more varied and unpredictable will have looser (wider) thresholds. Regular fluctuations For shorter-than-one-week cyclical fluctuations (such as weekly Wednesday 1pm deployments or nightly reports), the baseline algorithm looks for these cyclical fluctuations and attempts to adjust to them. Baseline direction: select upper or lower ranges You can choose whether you want the condition to violate for behavior that goes above the baseline (\"upper\") or that goes below the baseline (\"lower\"), or that goes either above or below. You choose these with the Baseline direction selector. Example use cases for this: You might use the Upper setting for a data source like error rate, because you generally are only concerned if it goes up, and aren't concerned if it goes down. You might use the Lower setting for a data source like throughput, because sudden upward fluctuations are quite common, but a large sudden downswing would be a sign of a problem. Here are examples of how large fluctuations in your data would be treated under the different baseline direction settings. The red areas represent violations. Preview chart: select 2 or 7 days When setting thresholds, the preview chart has an option for displaying Since 2 days ago or Since 7 days ago. These selections are not the time period used to compute the baseline; they are only the time range used for a preview display. For more about the time range used to calculate the baseline, see the algorithm rules.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.8775,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create baseline <em>alert</em> <em>conditions</em>",
        "sections": "Create baseline <em>alert</em> <em>conditions</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": ". Set baseline thresholds one.newrelic.com &gt; AI &amp; <em>Alerts</em> &gt; Policies &gt; (create or select policy) &gt; Create <em>alert</em> condition: Baseline <em>alert</em> <em>conditions</em> give you the ability to set intelligent, self-adjusting thresholds that only generate violations when abnormal behavior is detected. To create a baseline"
      },
      "id": "6044095ee7b9d214955799e9"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/select-product-targets-alert-condition": [
    {
      "sections": [
        "Expanded anomaly detection",
        "Requirements",
        "Why it matters",
        "Get started with anomaly detection",
        "Detect anomalies with a faceted NRQL query",
        "See your anomalies in one place",
        "Tip",
        "Query anomaly data",
        "Reduce the number of detected anomalies"
      ],
      "title": "Expanded anomaly detection",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Proactive detection"
      ],
      "external_id": "0b07c0b6ce27f39b5edb3e112a0f949835cbb8c6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/proactive-detection/expanded-anomaly-detection/",
      "published_at": "2021-06-02T18:27:12Z",
      "updated_at": "2021-05-31T16:43:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We’ve expanded anomaly detection coverage beyond your APM applications. Configure anomaly detection for your browser applications, mobile applications, infrastructure hosts, and nearly anything you want to monitor. Requirements Expanded anomaly detection is available as a limited beta. You can request access here. Why it matters When starting to configure alert conditions for a variety of applications and hosts, it can be difficult to know what you’ll want to be notified about ahead of time. Anomaly detection helps you distinguish between what’s typical performance in your system and where you’re starting to have trouble. Instead of creating your alert conditions manually, you can simply tell us what you want to monitor. Anomaly detection will help you identify baseline performance in your system and flags anomalous activity in your system. Get started with anomaly detection To get started with expanded anomaly detection: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Select the account you want to use to record anomaly data, then select the workload or entities you’d like to monitor. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name your configuration and save. Detect anomalies with a faceted NRQL query To detect anomalies with a faceted NRQL query: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Click Use a query instead. You may need to select an account, if you have more than one. Add one or more queries with a FACET clause. Name the query and confirm the facets you want to monitor for anomalies. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name the configuration and save. See your anomalies in one place When you set up anomaly detection, New Relic starts analyzing the golden signals of your entities and workloads. Anomalies appear in your activity feeds throughout New Relic One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL alert condition for the NrAiAnomaly event. To view anomalies, from one.newrelic.com, go to Alerts & AI > Issues & activity > Anomalies. Query anomaly data Detected anomalies are written to the NrAiAnomaly event in your NRDB account. You can learn more about this event and how to query it here. Reduce the number of detected anomalies If you’re seeing too many anomalies, the first step is to make sure your sensitivity level is set to Low. If it’s already set to Low, you can define specific thresholds to distinguish between normal and anomalous behavior. To define custom thresholds: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab and the configuration you want to modify. Select an entity or workload, and then change the sensitivity level. You can use custom sensitivity to define specific thresholds for different entity types.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 229.84363,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " feeds throughout <em>New</em> <em>Relic</em> One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL <em>alert</em>"
      },
      "id": "60b5124064441ff965e2cb01"
    },
    {
      "sections": [
        "Update or disable policies and conditions",
        "Policy maintenance quick reference",
        "Add or remove policies assigned to a channel",
        "Change a policy name",
        "Check policy user assignment",
        "Check policy channel assignment",
        "Create a new policy",
        "Condition maintenance quick reference",
        "Add more conditions",
        "Copy a condition",
        "Change how threshold violations roll up into incidents",
        "Check for entities (targets) assigned to a policy",
        "Tip",
        "Change a condition",
        "Link to Incident Intelligence",
        "Disable or delete policies and conditions",
        "Disable or re-enable a condition",
        "Disable a policy",
        "Delete policy conditions",
        "Delete a policy"
      ],
      "title": "Update or disable policies and conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert policies"
      ],
      "external_id": "4a6c5107cd6af696df6a3fb0651c6a1bde7daf36",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-policies/update-or-disable-policies-conditions/",
      "published_at": "2021-05-28T11:10:28Z",
      "updated_at": "2021-05-21T15:35:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you create a policy, you can: Add more conditions to the policy. Edit the conditions' names, targets, or thresholds. Disable conditions. Continue the policy setup process by adding one or more notification channels to it. Rename or delete the policy. The user interface shows a Last modified timestamp for any changes to policies, including their conditions and notification channels. Policy maintenance quick reference Here is a quick reference which also includes links to more detailed information and procedures for maintaining your policies. Add or remove policies assigned to a channel To add or remove policies assigned to a channel: In the one.newrelic.com top nav, click Alerts & AI, click Notification channels, then (select a channel). Click Alert policies, then (select a policy). From the selected policy, use the windows to select, remove, or clear all. Change a policy name To rename a policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Click the policy name to edit it, then type a meaningful name for the policy (maximum 64 characters). Check policy user assignment To check whether an account user has been assigned any policies: In the one.newrelic.com top nav, click Alerts & AI, click Policies, (select a policy), then click Notification channels. Select a user, and then click Alert policies. Check policy channel assignment To check whether a notification channel has any policies assigned to it: In the one.newrelic.com top nav, click Alerts & AI, click Notification channels. The Policy subscriptions column lists how many policies are assigned to the channel. Create a new policy To create a new alert policy: In the one.newrelic.com top nav, click Alerts & AI, click Policies. Click New alert policy. Follow standard procedures to complete the basic setup process. Condition maintenance quick reference Here's a quick reference for maintaining a policy conditions. This includes the condition's entities (targets), Warning (yellow) and Critical (red) thresholds, and runbook URL. Add more conditions To add more conditions to a policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then click Add a condition. OR To copy a condition from any policy and add it to another policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then click Copy. Copy a condition To copy an existing condition, including its targets and thresholds, and add it to another policy for the selected account: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). From the policy's list of one or more Alert conditions, click Copy. From the Copy alert condition list, search or scroll the list to select the policy where you want to add this condition. Optional: Change the condition's name if necessary. Select Save. By default, the copied condition will be added to the selected alert policy in a Disabled state. Follow standard procedures to add or copy additional conditions to the alert policy, and then Enable the condition as needed. Change how threshold violations roll up into incidents To select how violations to your thresholds are grouped into incident records (by policy, by condition, or by target and condition): In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Click Incident preference. Check for entities (targets) assigned to a policy To check whether an entity (target) has any policies assigned: Go to the product (APM, Browser, etc.). From the selected product's index, check whether the entity's color-coded health status is light green with an icon. Tip Exception: Infrastructure does not use this feature. Change a condition To change a policy condition: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Then, from the list of Alert conditions for the selected policy: To change the condition's name, click Edit. To add, change, or remove targets (entities), select the name or number of targets for the condition, and then select Browse and select targets. To update the values for the required Critical (red) or optional Warning (yellow) thresholds, select the existing value. To update the condition's runbook URL, select the condition's Thresholds. Link to Incident Intelligence If you use Applied Intelligence, you can connect your conditions to Incident Intelligence. To do this, switch the Connect to Incident Intelligence to ON. Disable or delete policies and conditions If you disable or delete a policy, we'll continue to apply any other policies assigned to the product entity (target). If you remove all policies for the entity, its color-coded health status indicator will appear light green with an icon. Disable or re-enable a condition You can enable or disable any policy conditions, and the policy will continue to apply. To disable or re-enable a condition: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Then, from the list of Alert conditions, (select a condition). Click the On/Off switch to toggle it. Tip For Infrastructure conditions, use the checkbox at the bottom of the condition edit screen, then save the condition. If you copy a condition, it is automatically saved in the new policy as disabled (Off), even if the condition was enabled (On) in the original policy. Disable a policy You can't disable a policy directly. However, you can disable all of the policy's conditions. When you disable all of the conditions, the policy will continue to appear on the Alert policies index. The policy itself isn't disabled, and you can re-enable any or all of its conditions at any time. Delete policy conditions If a policy has multiple conditions, you can delete any or all of them, and the remaining conditions for the policy will continue to apply. To turn a condition off but keep it with the policy, disable it. To delete one or more conditions: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). From the list of Alert conditions, (select a condition), then click Delete. Tip If you don't see the delete button, your account admin may have disabled condition deletion for your organization. Delete a policy If you delete any of your account's policies, you can't restore them. Instead, you must re-create them if necessary. To delete a policy completely: In the one.newrelic.com top nav, click Alerts & AI, then click Alert policies. From the policy row, click the delete icon. Any notification channels associated with a deleted or disabled policy will remain. You must delete notification channels or remove them individually as necessary. You will still be able to view incidents and event violations related to the deleted policy. However, these records will be read only.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 212.17757,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Update or disable policies <em>and</em> <em>conditions</em>",
        "sections": "Update or disable policies <em>and</em> <em>conditions</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " to it: In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click Notification channels. The Policy subscriptions column lists how many policies are assigned to the channel. Create a <em>new</em> policy To create a <em>new</em> <em>alert</em> policy: In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click Policies. Click <em>New</em> <em>alert</em> policy. Follow"
      },
      "id": "604404ec28ccbc62492c6098"
    },
    {
      "sections": [
        "Create baseline alert conditions",
        "How it works",
        "Set baseline thresholds",
        "Faceted baseline conditions",
        "Baseline rules and settings",
        "Rules governing creation of baseline",
        "Baseline direction: select upper or lower ranges",
        "Preview chart: select 2 or 7 days"
      ],
      "title": "Create baseline alert conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "a144b0cc3c5eed1c31dbfcd079959bbd5496346a",
      "image": "https://docs.newrelic.com/static/3be661b029a5f41d3da75175a0259fb9/c1b63/new-relic-baseline-alerts-direction-image-examples_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-baseline-alert-conditions/",
      "published_at": "2021-05-28T03:27:17Z",
      "updated_at": "2021-05-16T08:44:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use baseline conditions to define violation thresholds that adjust to the behavior of your data. Baseline alerting is useful for creating conditions that: Only notify you when data is behaving abnormally. Dynamically adjust to changing data and trends, including daily or weekly trends. In addition, baseline alerting works well with new applications when you do not yet have known behaviors. How it works When you choose a data source (for example, an APM metric) for a baseline condition, we'll use the past values of that data to dynamically predict the data's near-future behavior. The line of that predicted future behavior for that value is called a baseline. It appears as a dotted black line on the preview chart in the baseline condition UI. You'll use the baseline alert condition UI to: Adjust how sensitive the condition is to fluctuations in the data source. Set the behavior that will trigger a violation (for example: \"deviating for more than five minutes\"). Set whether you want the condition to check for upper violations, lower violations, or both. When your data escapes the predicted \"normal\" behavior and meets the criteria you've chosen, you'll receive a notification. Set baseline thresholds one.newrelic.com > AI & Alerts > Policies > (create or select policy) > Create alert condition: Baseline alert conditions give you the ability to set intelligent, self-adjusting thresholds that only generate violations when abnormal behavior is detected. To create a baseline condition: When you start to create a condition, choose one of the following data sources: NRQL: Create a NRQL condition and then choose baseline APM: Application metric baseline Browser: Metric baseline Here are some tips for setting baseline thresholds: Set the baseline direction to monitor violations that happen either above or below the baseline. Set the preview chart to either 2 days or 7 days of displayed data. (Not applicable for NRQL alert conditions.) Use the slider bar to adjust the Critical threshold sensitivity, represented in the preview chart by the light gray area around the baseline. The tighter the band around the baseline, the more sensitive it is and the more violations it will generate. Optional: You can create a Warning threshold (the darker gray area around the baseline). For NRQL alerts, see the allowed types of NRQL queries. If the alert condition applies to multiple apps, you can select a choice from the dropdown above the chart to use different metrics. (Not applicable for NRQL alert conditions.) Faceted baseline conditions NRQL alerts conditions support faceted baselines. In the chart legend, click a time series to scope it to a single facet. Once you've run a faceted NRQL query for a baseline condition, you can scope your results to a single baseline. Click Return to full timeseries list to go back to seeing all your facets. The single time series shows the baseline, threshold band, and one or more violation regions, if there are any. Baseline rules and settings Here are some details about how the UI works: Rules governing creation of baseline The algorithm for baseline conditions is mathematically complex. Here are some of the major rules governing its predictive abilities: Data trait Baseline rules Age of data On initial creation, the baseline is calculated using between 1 to 4 weeks of data, depending on data availability and baseline type. After its creation, the algorithm will take into account ongoing data fluctuations over a long time period, although greater weight is given to more recent data. For data that has only existed for a short time, the baseline will likely fluctuate a good deal and not be very accurate. This is because there is not yet enough data to determine its usual values and behavior. The more history the data has, the more accurate the baseline and thresholds will become. Consistency of data For metric values that remain in a consistent range or that trend slowly and steadily, their more predictable behavior means that their thresholds will become tighter around the baseline. Data that is more varied and unpredictable will have looser (wider) thresholds. Regular fluctuations For shorter-than-one-week cyclical fluctuations (such as weekly Wednesday 1pm deployments or nightly reports), the baseline algorithm looks for these cyclical fluctuations and attempts to adjust to them. Baseline direction: select upper or lower ranges You can choose whether you want the condition to violate for behavior that goes above the baseline (\"upper\") or that goes below the baseline (\"lower\"), or that goes either above or below. You choose these with the Baseline direction selector. Example use cases for this: You might use the Upper setting for a data source like error rate, because you generally are only concerned if it goes up, and aren't concerned if it goes down. You might use the Lower setting for a data source like throughput, because sudden upward fluctuations are quite common, but a large sudden downswing would be a sign of a problem. Here are examples of how large fluctuations in your data would be treated under the different baseline direction settings. The red areas represent violations. Preview chart: select 2 or 7 days When setting thresholds, the preview chart has an option for displaying Since 2 days ago or Since 7 days ago. These selections are not the time period used to compute the baseline; they are only the time range used for a preview display. For more about the time range used to calculate the baseline, see the algorithm rules.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.87747,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create baseline <em>alert</em> <em>conditions</em>",
        "sections": "Create baseline <em>alert</em> <em>conditions</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": ". Set baseline thresholds one.newrelic.com &gt; AI &amp; <em>Alerts</em> &gt; Policies &gt; (create or select policy) &gt; Create <em>alert</em> condition: Baseline <em>alert</em> <em>conditions</em> give you the ability to set intelligent, self-adjusting thresholds that only generate violations when abnormal behavior is detected. To create a baseline"
      },
      "id": "6044095ee7b9d214955799e9"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/set-thresholds-alert-condition": [
    {
      "sections": [
        "Expanded anomaly detection",
        "Requirements",
        "Why it matters",
        "Get started with anomaly detection",
        "Detect anomalies with a faceted NRQL query",
        "See your anomalies in one place",
        "Tip",
        "Query anomaly data",
        "Reduce the number of detected anomalies"
      ],
      "title": "Expanded anomaly detection",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Proactive detection"
      ],
      "external_id": "0b07c0b6ce27f39b5edb3e112a0f949835cbb8c6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/proactive-detection/expanded-anomaly-detection/",
      "published_at": "2021-06-02T18:27:12Z",
      "updated_at": "2021-05-31T16:43:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We’ve expanded anomaly detection coverage beyond your APM applications. Configure anomaly detection for your browser applications, mobile applications, infrastructure hosts, and nearly anything you want to monitor. Requirements Expanded anomaly detection is available as a limited beta. You can request access here. Why it matters When starting to configure alert conditions for a variety of applications and hosts, it can be difficult to know what you’ll want to be notified about ahead of time. Anomaly detection helps you distinguish between what’s typical performance in your system and where you’re starting to have trouble. Instead of creating your alert conditions manually, you can simply tell us what you want to monitor. Anomaly detection will help you identify baseline performance in your system and flags anomalous activity in your system. Get started with anomaly detection To get started with expanded anomaly detection: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Select the account you want to use to record anomaly data, then select the workload or entities you’d like to monitor. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name your configuration and save. Detect anomalies with a faceted NRQL query To detect anomalies with a faceted NRQL query: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Click Use a query instead. You may need to select an account, if you have more than one. Add one or more queries with a FACET clause. Name the query and confirm the facets you want to monitor for anomalies. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name the configuration and save. See your anomalies in one place When you set up anomaly detection, New Relic starts analyzing the golden signals of your entities and workloads. Anomalies appear in your activity feeds throughout New Relic One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL alert condition for the NrAiAnomaly event. To view anomalies, from one.newrelic.com, go to Alerts & AI > Issues & activity > Anomalies. Query anomaly data Detected anomalies are written to the NrAiAnomaly event in your NRDB account. You can learn more about this event and how to query it here. Reduce the number of detected anomalies If you’re seeing too many anomalies, the first step is to make sure your sensitivity level is set to Low. If it’s already set to Low, you can define specific thresholds to distinguish between normal and anomalous behavior. To define custom thresholds: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab and the configuration you want to modify. Select an entity or workload, and then change the sensitivity level. You can use custom sensitivity to define specific thresholds for different entity types.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 229.84363,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " feeds throughout <em>New</em> <em>Relic</em> One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL <em>alert</em>"
      },
      "id": "60b5124064441ff965e2cb01"
    },
    {
      "sections": [
        "Update or disable policies and conditions",
        "Policy maintenance quick reference",
        "Add or remove policies assigned to a channel",
        "Change a policy name",
        "Check policy user assignment",
        "Check policy channel assignment",
        "Create a new policy",
        "Condition maintenance quick reference",
        "Add more conditions",
        "Copy a condition",
        "Change how threshold violations roll up into incidents",
        "Check for entities (targets) assigned to a policy",
        "Tip",
        "Change a condition",
        "Link to Incident Intelligence",
        "Disable or delete policies and conditions",
        "Disable or re-enable a condition",
        "Disable a policy",
        "Delete policy conditions",
        "Delete a policy"
      ],
      "title": "Update or disable policies and conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert policies"
      ],
      "external_id": "4a6c5107cd6af696df6a3fb0651c6a1bde7daf36",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-policies/update-or-disable-policies-conditions/",
      "published_at": "2021-05-28T11:10:28Z",
      "updated_at": "2021-05-21T15:35:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you create a policy, you can: Add more conditions to the policy. Edit the conditions' names, targets, or thresholds. Disable conditions. Continue the policy setup process by adding one or more notification channels to it. Rename or delete the policy. The user interface shows a Last modified timestamp for any changes to policies, including their conditions and notification channels. Policy maintenance quick reference Here is a quick reference which also includes links to more detailed information and procedures for maintaining your policies. Add or remove policies assigned to a channel To add or remove policies assigned to a channel: In the one.newrelic.com top nav, click Alerts & AI, click Notification channels, then (select a channel). Click Alert policies, then (select a policy). From the selected policy, use the windows to select, remove, or clear all. Change a policy name To rename a policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Click the policy name to edit it, then type a meaningful name for the policy (maximum 64 characters). Check policy user assignment To check whether an account user has been assigned any policies: In the one.newrelic.com top nav, click Alerts & AI, click Policies, (select a policy), then click Notification channels. Select a user, and then click Alert policies. Check policy channel assignment To check whether a notification channel has any policies assigned to it: In the one.newrelic.com top nav, click Alerts & AI, click Notification channels. The Policy subscriptions column lists how many policies are assigned to the channel. Create a new policy To create a new alert policy: In the one.newrelic.com top nav, click Alerts & AI, click Policies. Click New alert policy. Follow standard procedures to complete the basic setup process. Condition maintenance quick reference Here's a quick reference for maintaining a policy conditions. This includes the condition's entities (targets), Warning (yellow) and Critical (red) thresholds, and runbook URL. Add more conditions To add more conditions to a policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then click Add a condition. OR To copy a condition from any policy and add it to another policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then click Copy. Copy a condition To copy an existing condition, including its targets and thresholds, and add it to another policy for the selected account: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). From the policy's list of one or more Alert conditions, click Copy. From the Copy alert condition list, search or scroll the list to select the policy where you want to add this condition. Optional: Change the condition's name if necessary. Select Save. By default, the copied condition will be added to the selected alert policy in a Disabled state. Follow standard procedures to add or copy additional conditions to the alert policy, and then Enable the condition as needed. Change how threshold violations roll up into incidents To select how violations to your thresholds are grouped into incident records (by policy, by condition, or by target and condition): In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Click Incident preference. Check for entities (targets) assigned to a policy To check whether an entity (target) has any policies assigned: Go to the product (APM, Browser, etc.). From the selected product's index, check whether the entity's color-coded health status is light green with an icon. Tip Exception: Infrastructure does not use this feature. Change a condition To change a policy condition: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Then, from the list of Alert conditions for the selected policy: To change the condition's name, click Edit. To add, change, or remove targets (entities), select the name or number of targets for the condition, and then select Browse and select targets. To update the values for the required Critical (red) or optional Warning (yellow) thresholds, select the existing value. To update the condition's runbook URL, select the condition's Thresholds. Link to Incident Intelligence If you use Applied Intelligence, you can connect your conditions to Incident Intelligence. To do this, switch the Connect to Incident Intelligence to ON. Disable or delete policies and conditions If you disable or delete a policy, we'll continue to apply any other policies assigned to the product entity (target). If you remove all policies for the entity, its color-coded health status indicator will appear light green with an icon. Disable or re-enable a condition You can enable or disable any policy conditions, and the policy will continue to apply. To disable or re-enable a condition: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Then, from the list of Alert conditions, (select a condition). Click the On/Off switch to toggle it. Tip For Infrastructure conditions, use the checkbox at the bottom of the condition edit screen, then save the condition. If you copy a condition, it is automatically saved in the new policy as disabled (Off), even if the condition was enabled (On) in the original policy. Disable a policy You can't disable a policy directly. However, you can disable all of the policy's conditions. When you disable all of the conditions, the policy will continue to appear on the Alert policies index. The policy itself isn't disabled, and you can re-enable any or all of its conditions at any time. Delete policy conditions If a policy has multiple conditions, you can delete any or all of them, and the remaining conditions for the policy will continue to apply. To turn a condition off but keep it with the policy, disable it. To delete one or more conditions: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). From the list of Alert conditions, (select a condition), then click Delete. Tip If you don't see the delete button, your account admin may have disabled condition deletion for your organization. Delete a policy If you delete any of your account's policies, you can't restore them. Instead, you must re-create them if necessary. To delete a policy completely: In the one.newrelic.com top nav, click Alerts & AI, then click Alert policies. From the policy row, click the delete icon. Any notification channels associated with a deleted or disabled policy will remain. You must delete notification channels or remove them individually as necessary. You will still be able to view incidents and event violations related to the deleted policy. However, these records will be read only.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 212.17757,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Update or disable policies <em>and</em> <em>conditions</em>",
        "sections": "Update or disable policies <em>and</em> <em>conditions</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " to it: In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click Notification channels. The Policy subscriptions column lists how many policies are assigned to the channel. Create a <em>new</em> policy To create a <em>new</em> <em>alert</em> policy: In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click Policies. Click <em>New</em> <em>alert</em> policy. Follow"
      },
      "id": "604404ec28ccbc62492c6098"
    },
    {
      "sections": [
        "Create baseline alert conditions",
        "How it works",
        "Set baseline thresholds",
        "Faceted baseline conditions",
        "Baseline rules and settings",
        "Rules governing creation of baseline",
        "Baseline direction: select upper or lower ranges",
        "Preview chart: select 2 or 7 days"
      ],
      "title": "Create baseline alert conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "a144b0cc3c5eed1c31dbfcd079959bbd5496346a",
      "image": "https://docs.newrelic.com/static/3be661b029a5f41d3da75175a0259fb9/c1b63/new-relic-baseline-alerts-direction-image-examples_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-baseline-alert-conditions/",
      "published_at": "2021-05-28T03:27:17Z",
      "updated_at": "2021-05-16T08:44:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use baseline conditions to define violation thresholds that adjust to the behavior of your data. Baseline alerting is useful for creating conditions that: Only notify you when data is behaving abnormally. Dynamically adjust to changing data and trends, including daily or weekly trends. In addition, baseline alerting works well with new applications when you do not yet have known behaviors. How it works When you choose a data source (for example, an APM metric) for a baseline condition, we'll use the past values of that data to dynamically predict the data's near-future behavior. The line of that predicted future behavior for that value is called a baseline. It appears as a dotted black line on the preview chart in the baseline condition UI. You'll use the baseline alert condition UI to: Adjust how sensitive the condition is to fluctuations in the data source. Set the behavior that will trigger a violation (for example: \"deviating for more than five minutes\"). Set whether you want the condition to check for upper violations, lower violations, or both. When your data escapes the predicted \"normal\" behavior and meets the criteria you've chosen, you'll receive a notification. Set baseline thresholds one.newrelic.com > AI & Alerts > Policies > (create or select policy) > Create alert condition: Baseline alert conditions give you the ability to set intelligent, self-adjusting thresholds that only generate violations when abnormal behavior is detected. To create a baseline condition: When you start to create a condition, choose one of the following data sources: NRQL: Create a NRQL condition and then choose baseline APM: Application metric baseline Browser: Metric baseline Here are some tips for setting baseline thresholds: Set the baseline direction to monitor violations that happen either above or below the baseline. Set the preview chart to either 2 days or 7 days of displayed data. (Not applicable for NRQL alert conditions.) Use the slider bar to adjust the Critical threshold sensitivity, represented in the preview chart by the light gray area around the baseline. The tighter the band around the baseline, the more sensitive it is and the more violations it will generate. Optional: You can create a Warning threshold (the darker gray area around the baseline). For NRQL alerts, see the allowed types of NRQL queries. If the alert condition applies to multiple apps, you can select a choice from the dropdown above the chart to use different metrics. (Not applicable for NRQL alert conditions.) Faceted baseline conditions NRQL alerts conditions support faceted baselines. In the chart legend, click a time series to scope it to a single facet. Once you've run a faceted NRQL query for a baseline condition, you can scope your results to a single baseline. Click Return to full timeseries list to go back to seeing all your facets. The single time series shows the baseline, threshold band, and one or more violation regions, if there are any. Baseline rules and settings Here are some details about how the UI works: Rules governing creation of baseline The algorithm for baseline conditions is mathematically complex. Here are some of the major rules governing its predictive abilities: Data trait Baseline rules Age of data On initial creation, the baseline is calculated using between 1 to 4 weeks of data, depending on data availability and baseline type. After its creation, the algorithm will take into account ongoing data fluctuations over a long time period, although greater weight is given to more recent data. For data that has only existed for a short time, the baseline will likely fluctuate a good deal and not be very accurate. This is because there is not yet enough data to determine its usual values and behavior. The more history the data has, the more accurate the baseline and thresholds will become. Consistency of data For metric values that remain in a consistent range or that trend slowly and steadily, their more predictable behavior means that their thresholds will become tighter around the baseline. Data that is more varied and unpredictable will have looser (wider) thresholds. Regular fluctuations For shorter-than-one-week cyclical fluctuations (such as weekly Wednesday 1pm deployments or nightly reports), the baseline algorithm looks for these cyclical fluctuations and attempts to adjust to them. Baseline direction: select upper or lower ranges You can choose whether you want the condition to violate for behavior that goes above the baseline (\"upper\") or that goes below the baseline (\"lower\"), or that goes either above or below. You choose these with the Baseline direction selector. Example use cases for this: You might use the Upper setting for a data source like error rate, because you generally are only concerned if it goes up, and aren't concerned if it goes down. You might use the Lower setting for a data source like throughput, because sudden upward fluctuations are quite common, but a large sudden downswing would be a sign of a problem. Here are examples of how large fluctuations in your data would be treated under the different baseline direction settings. The red areas represent violations. Preview chart: select 2 or 7 days When setting thresholds, the preview chart has an option for displaying Since 2 days ago or Since 7 days ago. These selections are not the time period used to compute the baseline; they are only the time range used for a preview display. For more about the time range used to calculate the baseline, see the algorithm rules.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.87747,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create baseline <em>alert</em> <em>conditions</em>",
        "sections": "Create baseline <em>alert</em> <em>conditions</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": ". Set baseline thresholds one.newrelic.com &gt; AI &amp; <em>Alerts</em> &gt; Policies &gt; (create or select policy) &gt; Create <em>alert</em> condition: Baseline <em>alert</em> <em>conditions</em> give you the ability to set intelligent, self-adjusting thresholds that only generate violations when abnormal behavior is detected. To create a baseline"
      },
      "id": "6044095ee7b9d214955799e9"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/view-entity-health-status-find-entities-without-alert-conditions": [
    {
      "sections": [
        "Expanded anomaly detection",
        "Requirements",
        "Why it matters",
        "Get started with anomaly detection",
        "Detect anomalies with a faceted NRQL query",
        "See your anomalies in one place",
        "Tip",
        "Query anomaly data",
        "Reduce the number of detected anomalies"
      ],
      "title": "Expanded anomaly detection",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Proactive detection"
      ],
      "external_id": "0b07c0b6ce27f39b5edb3e112a0f949835cbb8c6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/proactive-detection/expanded-anomaly-detection/",
      "published_at": "2021-06-02T18:27:12Z",
      "updated_at": "2021-05-31T16:43:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We’ve expanded anomaly detection coverage beyond your APM applications. Configure anomaly detection for your browser applications, mobile applications, infrastructure hosts, and nearly anything you want to monitor. Requirements Expanded anomaly detection is available as a limited beta. You can request access here. Why it matters When starting to configure alert conditions for a variety of applications and hosts, it can be difficult to know what you’ll want to be notified about ahead of time. Anomaly detection helps you distinguish between what’s typical performance in your system and where you’re starting to have trouble. Instead of creating your alert conditions manually, you can simply tell us what you want to monitor. Anomaly detection will help you identify baseline performance in your system and flags anomalous activity in your system. Get started with anomaly detection To get started with expanded anomaly detection: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Select the account you want to use to record anomaly data, then select the workload or entities you’d like to monitor. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name your configuration and save. Detect anomalies with a faceted NRQL query To detect anomalies with a faceted NRQL query: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Click Use a query instead. You may need to select an account, if you have more than one. Add one or more queries with a FACET clause. Name the query and confirm the facets you want to monitor for anomalies. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name the configuration and save. See your anomalies in one place When you set up anomaly detection, New Relic starts analyzing the golden signals of your entities and workloads. Anomalies appear in your activity feeds throughout New Relic One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL alert condition for the NrAiAnomaly event. To view anomalies, from one.newrelic.com, go to Alerts & AI > Issues & activity > Anomalies. Query anomaly data Detected anomalies are written to the NrAiAnomaly event in your NRDB account. You can learn more about this event and how to query it here. Reduce the number of detected anomalies If you’re seeing too many anomalies, the first step is to make sure your sensitivity level is set to Low. If it’s already set to Low, you can define specific thresholds to distinguish between normal and anomalous behavior. To define custom thresholds: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab and the configuration you want to modify. Select an entity or workload, and then change the sensitivity level. You can use custom sensitivity to define specific thresholds for different entity types.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 229.84348,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " feeds throughout <em>New</em> <em>Relic</em> One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL <em>alert</em>"
      },
      "id": "60b5124064441ff965e2cb01"
    },
    {
      "sections": [
        "Update or disable policies and conditions",
        "Policy maintenance quick reference",
        "Add or remove policies assigned to a channel",
        "Change a policy name",
        "Check policy user assignment",
        "Check policy channel assignment",
        "Create a new policy",
        "Condition maintenance quick reference",
        "Add more conditions",
        "Copy a condition",
        "Change how threshold violations roll up into incidents",
        "Check for entities (targets) assigned to a policy",
        "Tip",
        "Change a condition",
        "Link to Incident Intelligence",
        "Disable or delete policies and conditions",
        "Disable or re-enable a condition",
        "Disable a policy",
        "Delete policy conditions",
        "Delete a policy"
      ],
      "title": "Update or disable policies and conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert policies"
      ],
      "external_id": "4a6c5107cd6af696df6a3fb0651c6a1bde7daf36",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-policies/update-or-disable-policies-conditions/",
      "published_at": "2021-05-28T11:10:28Z",
      "updated_at": "2021-05-21T15:35:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you create a policy, you can: Add more conditions to the policy. Edit the conditions' names, targets, or thresholds. Disable conditions. Continue the policy setup process by adding one or more notification channels to it. Rename or delete the policy. The user interface shows a Last modified timestamp for any changes to policies, including their conditions and notification channels. Policy maintenance quick reference Here is a quick reference which also includes links to more detailed information and procedures for maintaining your policies. Add or remove policies assigned to a channel To add or remove policies assigned to a channel: In the one.newrelic.com top nav, click Alerts & AI, click Notification channels, then (select a channel). Click Alert policies, then (select a policy). From the selected policy, use the windows to select, remove, or clear all. Change a policy name To rename a policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Click the policy name to edit it, then type a meaningful name for the policy (maximum 64 characters). Check policy user assignment To check whether an account user has been assigned any policies: In the one.newrelic.com top nav, click Alerts & AI, click Policies, (select a policy), then click Notification channels. Select a user, and then click Alert policies. Check policy channel assignment To check whether a notification channel has any policies assigned to it: In the one.newrelic.com top nav, click Alerts & AI, click Notification channels. The Policy subscriptions column lists how many policies are assigned to the channel. Create a new policy To create a new alert policy: In the one.newrelic.com top nav, click Alerts & AI, click Policies. Click New alert policy. Follow standard procedures to complete the basic setup process. Condition maintenance quick reference Here's a quick reference for maintaining a policy conditions. This includes the condition's entities (targets), Warning (yellow) and Critical (red) thresholds, and runbook URL. Add more conditions To add more conditions to a policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then click Add a condition. OR To copy a condition from any policy and add it to another policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then click Copy. Copy a condition To copy an existing condition, including its targets and thresholds, and add it to another policy for the selected account: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). From the policy's list of one or more Alert conditions, click Copy. From the Copy alert condition list, search or scroll the list to select the policy where you want to add this condition. Optional: Change the condition's name if necessary. Select Save. By default, the copied condition will be added to the selected alert policy in a Disabled state. Follow standard procedures to add or copy additional conditions to the alert policy, and then Enable the condition as needed. Change how threshold violations roll up into incidents To select how violations to your thresholds are grouped into incident records (by policy, by condition, or by target and condition): In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Click Incident preference. Check for entities (targets) assigned to a policy To check whether an entity (target) has any policies assigned: Go to the product (APM, Browser, etc.). From the selected product's index, check whether the entity's color-coded health status is light green with an icon. Tip Exception: Infrastructure does not use this feature. Change a condition To change a policy condition: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Then, from the list of Alert conditions for the selected policy: To change the condition's name, click Edit. To add, change, or remove targets (entities), select the name or number of targets for the condition, and then select Browse and select targets. To update the values for the required Critical (red) or optional Warning (yellow) thresholds, select the existing value. To update the condition's runbook URL, select the condition's Thresholds. Link to Incident Intelligence If you use Applied Intelligence, you can connect your conditions to Incident Intelligence. To do this, switch the Connect to Incident Intelligence to ON. Disable or delete policies and conditions If you disable or delete a policy, we'll continue to apply any other policies assigned to the product entity (target). If you remove all policies for the entity, its color-coded health status indicator will appear light green with an icon. Disable or re-enable a condition You can enable or disable any policy conditions, and the policy will continue to apply. To disable or re-enable a condition: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Then, from the list of Alert conditions, (select a condition). Click the On/Off switch to toggle it. Tip For Infrastructure conditions, use the checkbox at the bottom of the condition edit screen, then save the condition. If you copy a condition, it is automatically saved in the new policy as disabled (Off), even if the condition was enabled (On) in the original policy. Disable a policy You can't disable a policy directly. However, you can disable all of the policy's conditions. When you disable all of the conditions, the policy will continue to appear on the Alert policies index. The policy itself isn't disabled, and you can re-enable any or all of its conditions at any time. Delete policy conditions If a policy has multiple conditions, you can delete any or all of them, and the remaining conditions for the policy will continue to apply. To turn a condition off but keep it with the policy, disable it. To delete one or more conditions: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). From the list of Alert conditions, (select a condition), then click Delete. Tip If you don't see the delete button, your account admin may have disabled condition deletion for your organization. Delete a policy If you delete any of your account's policies, you can't restore them. Instead, you must re-create them if necessary. To delete a policy completely: In the one.newrelic.com top nav, click Alerts & AI, then click Alert policies. From the policy row, click the delete icon. Any notification channels associated with a deleted or disabled policy will remain. You must delete notification channels or remove them individually as necessary. You will still be able to view incidents and event violations related to the deleted policy. However, these records will be read only.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 212.17752,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Update or disable policies <em>and</em> <em>conditions</em>",
        "sections": "Update or disable policies <em>and</em> <em>conditions</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " to it: In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click Notification channels. The Policy subscriptions column lists how many policies are assigned to the channel. Create a <em>new</em> policy To create a <em>new</em> <em>alert</em> policy: In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click Policies. Click <em>New</em> <em>alert</em> policy. Follow"
      },
      "id": "604404ec28ccbc62492c6098"
    },
    {
      "sections": [
        "Create baseline alert conditions",
        "How it works",
        "Set baseline thresholds",
        "Faceted baseline conditions",
        "Baseline rules and settings",
        "Rules governing creation of baseline",
        "Baseline direction: select upper or lower ranges",
        "Preview chart: select 2 or 7 days"
      ],
      "title": "Create baseline alert conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "a144b0cc3c5eed1c31dbfcd079959bbd5496346a",
      "image": "https://docs.newrelic.com/static/3be661b029a5f41d3da75175a0259fb9/c1b63/new-relic-baseline-alerts-direction-image-examples_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/create-baseline-alert-conditions/",
      "published_at": "2021-05-28T03:27:17Z",
      "updated_at": "2021-05-16T08:44:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use baseline conditions to define violation thresholds that adjust to the behavior of your data. Baseline alerting is useful for creating conditions that: Only notify you when data is behaving abnormally. Dynamically adjust to changing data and trends, including daily or weekly trends. In addition, baseline alerting works well with new applications when you do not yet have known behaviors. How it works When you choose a data source (for example, an APM metric) for a baseline condition, we'll use the past values of that data to dynamically predict the data's near-future behavior. The line of that predicted future behavior for that value is called a baseline. It appears as a dotted black line on the preview chart in the baseline condition UI. You'll use the baseline alert condition UI to: Adjust how sensitive the condition is to fluctuations in the data source. Set the behavior that will trigger a violation (for example: \"deviating for more than five minutes\"). Set whether you want the condition to check for upper violations, lower violations, or both. When your data escapes the predicted \"normal\" behavior and meets the criteria you've chosen, you'll receive a notification. Set baseline thresholds one.newrelic.com > AI & Alerts > Policies > (create or select policy) > Create alert condition: Baseline alert conditions give you the ability to set intelligent, self-adjusting thresholds that only generate violations when abnormal behavior is detected. To create a baseline condition: When you start to create a condition, choose one of the following data sources: NRQL: Create a NRQL condition and then choose baseline APM: Application metric baseline Browser: Metric baseline Here are some tips for setting baseline thresholds: Set the baseline direction to monitor violations that happen either above or below the baseline. Set the preview chart to either 2 days or 7 days of displayed data. (Not applicable for NRQL alert conditions.) Use the slider bar to adjust the Critical threshold sensitivity, represented in the preview chart by the light gray area around the baseline. The tighter the band around the baseline, the more sensitive it is and the more violations it will generate. Optional: You can create a Warning threshold (the darker gray area around the baseline). For NRQL alerts, see the allowed types of NRQL queries. If the alert condition applies to multiple apps, you can select a choice from the dropdown above the chart to use different metrics. (Not applicable for NRQL alert conditions.) Faceted baseline conditions NRQL alerts conditions support faceted baselines. In the chart legend, click a time series to scope it to a single facet. Once you've run a faceted NRQL query for a baseline condition, you can scope your results to a single baseline. Click Return to full timeseries list to go back to seeing all your facets. The single time series shows the baseline, threshold band, and one or more violation regions, if there are any. Baseline rules and settings Here are some details about how the UI works: Rules governing creation of baseline The algorithm for baseline conditions is mathematically complex. Here are some of the major rules governing its predictive abilities: Data trait Baseline rules Age of data On initial creation, the baseline is calculated using between 1 to 4 weeks of data, depending on data availability and baseline type. After its creation, the algorithm will take into account ongoing data fluctuations over a long time period, although greater weight is given to more recent data. For data that has only existed for a short time, the baseline will likely fluctuate a good deal and not be very accurate. This is because there is not yet enough data to determine its usual values and behavior. The more history the data has, the more accurate the baseline and thresholds will become. Consistency of data For metric values that remain in a consistent range or that trend slowly and steadily, their more predictable behavior means that their thresholds will become tighter around the baseline. Data that is more varied and unpredictable will have looser (wider) thresholds. Regular fluctuations For shorter-than-one-week cyclical fluctuations (such as weekly Wednesday 1pm deployments or nightly reports), the baseline algorithm looks for these cyclical fluctuations and attempts to adjust to them. Baseline direction: select upper or lower ranges You can choose whether you want the condition to violate for behavior that goes above the baseline (\"upper\") or that goes below the baseline (\"lower\"), or that goes either above or below. You choose these with the Baseline direction selector. Example use cases for this: You might use the Upper setting for a data source like error rate, because you generally are only concerned if it goes up, and aren't concerned if it goes down. You might use the Lower setting for a data source like throughput, because sudden upward fluctuations are quite common, but a large sudden downswing would be a sign of a problem. Here are examples of how large fluctuations in your data would be treated under the different baseline direction settings. The red areas represent violations. Preview chart: select 2 or 7 days When setting thresholds, the preview chart has an option for displaying Since 2 days ago or Since 7 days ago. These selections are not the time period used to compute the baseline; they are only the time range used for a preview display. For more about the time range used to calculate the baseline, see the algorithm rules.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.87744,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Create baseline <em>alert</em> <em>conditions</em>",
        "sections": "Create baseline <em>alert</em> <em>conditions</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": ". Set baseline thresholds one.newrelic.com &gt; AI &amp; <em>Alerts</em> &gt; Policies &gt; (create or select policy) &gt; Create <em>alert</em> condition: Baseline <em>alert</em> <em>conditions</em> give you the ability to set intelligent, self-adjusting thresholds that only generate violations when abnormal behavior is detected. To create a baseline"
      },
      "id": "6044095ee7b9d214955799e9"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-incidents/acknowledge-alert-incidents": [
    {
      "sections": [
        "Incident Intelligence destination examples",
        "Destination template examples",
        "Suggested OpsGenie template example",
        "Suggested ServiceNow template example",
        "Suggested Slack template example",
        "Suggested VictorOps template example",
        "Webhook and JSON format examples",
        "Webhook format and JSON example",
        "Jinja2 Default Payload",
        "Jinja2 Useful Syntax",
        "JSON schema",
        "JSON schema template"
      ],
      "title": "Incident Intelligence destination examples",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "a516d04f8b75541a6dc9338fa3ce9645ba87d620",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/incident-intelligence-destination-examples/",
      "published_at": "2021-06-02T18:22:22Z",
      "updated_at": "2021-06-02T18:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Destinations are the data outputs to Applied Intelligence, where you can view your automatically correlated incidents. You can configure Incident Intelligence destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema. Destination template examples The following template example destinations are formatted in Jinja2. Suggested OpsGenie template example { \"alias\": {{ id }}, \"message\": {{ ui_name }}, \"source\": '{{ sources }}', \"priority\": {{ priority }}, \"details\": { \"self_url\": {{ url }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"is_correlated\": {{ is_correlated }} }, \"description\": \"\"\"Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]\"\"\" } Copy Suggested ServiceNow template example { \"short_description\": {{ ui_name }}, \"description\": 'Issue Id: {{ id }}, \\n Description: {{ description }}, \\n Sources: {{ sources }}, \\n Priority: {{ priority }}, \\n Details: { \\n self_url: {{ url }}, \\n state: {{ state }}, \\n is_correlated: {{ is_correlated }}, \\n created_on: {{ created_on }}, \\n modified_on: {{ modified_on }}, \\n activated_on: {{ active_since }}, \\n closed_on: {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \\n is_correlated: {{is_correlated}} }, \\n\\n incidents: {{ incidents }}, \\n\\n pathways: {{ pathways }}' } Copy Suggested Slack template example Go to Slack incoming WebHooks Choose the right Slack workspace and click \"Add to Slack\" Select the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In New Relic Applied Intelligence, under Incident Intelligence click Destinations Add a WebHook In the end point paste the WebHook url from slack. In the custom payload, paste the following JSON: { \"blocks\": [ { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*New Relic Incident Intelligence Alert*\" } }, { \"type\": \"divider\" }, { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*CUSTOM FIELDS*:\" }, \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue ID*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Issue Title*\" }, { \"type\": \"plain_text\", \"text\": {{ id }} }, { \"type\": \"plain_text\", \"text\": {{ ui_name }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue URL*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Description*\" }, { \"type\": \"mrkdwn\", \"text\": {{ url }} }, { \"type\": \"plain_text\", \"text\": {{ description }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*State*\" }, { \"type\": \"mrkdwn\", \"text\": \"*is_correlated*\" }, { \"type\": \"plain_text\", \"text\": {{ state }} }, { \"type\": \"plain_text\", \"text\": \"{{ is_correlated }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Created On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Modified On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ created_on }}\" }, { \"type\": \"plain_text\", \"text\": \"{{ modified_on }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Activated On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Closed On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ active_since }}\" }, { \"type\": \"plain_text\", \"text\": \"{% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Aggregated Incidents*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Monitoring Tool*\" }, { \"type\": \"plain_text\", \"text\": \"{{ incident_count }}\" }, { \"type\": \"plain_text\", \"text\": {{ sources|join(', ') }} } ] } ] } Copy Suggested VictorOps template example { \"monitoring_tool\": {{ sources }}, {% if state == 'closed' %} \"message_type\": \"OK\", {% else %} \"message_type\": {{ priority }}, {% endif %} \"custom_fields\": { \"issue_url\": {{ url }}, \"description\": {{ description }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"related_incidents\": [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %} {% endfor %} ] }, \"state_message\": {{ description }}, \"entity_id\": {{ id }}, \"entity_display_name\": {{ ui_name }}, \"vo_annotate.u.NRAI_Link\": {{ url }} } Copy Webhook and JSON format examples Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). If you use webhooks to configure Incident Intelligence destinations, use these examples of the webhook body format and JSON schema. Webhook format and JSON example Webhook format: Name Description url Href A link to the UI where the issue can be seen. id String Unique identifier for the issue. title String The issue title. description String The description of the issue. priority Enum The issue priority. Can be Critical, High, Medium, or Low. state Enum The issue status. Can be Active, Closed, or Acknowledged. is_correlated Boolean True if the issue is based on correlated data. created_on String The date and time the issue was created (in ISO format). modified_on String The date and time the issue was modified (in ISO format). active_since String The date and time the issue was activated (in ISO format). closed_on String The date and time the issue was closed (in ISO format). sources List(String) List of the different sources that were used to send the events into Applied Intelligence (for example: PagerDuty). pathways List(Pathways) List of pathways that are associated with the issue. Each pathway contains an id and name: [{“id”: “pathway id”, “name”: “pathway name”}]. pathways[].id String The pathway ID. pathways[].name String The pathway name. incidents List(Incident) List of incidents that are attached to the issue. The list contains only the latest 100 incidents. incidents[].id String The incident ID. incidents[].events_count Integer The number of events used to create the incident. incidents[].title String The incident title. incidents[].description String The incident description. incidents[].labels Dictionary (String) A string to string mapping of the incident labels. Labels represent the unique entities that are used to describe the incident. incidents[].priority Enum The incident priority. Can be Critical, High, Medium, or Low. incidents[].sources List(String) The incident source. incidents[].state Enum(open, closed) The incident state. incidents[].opened_on String The date and time the incident was opened (in ISO format). incidents[].closed_on String The date and time the incident was closed (in ISO format). ui_name String Issue title. accumulations['alert/signal'] String Issue analysis summary golden signal/s (if applicable). accumulations['alert/components'] String Issue analysis summary golden components (if applicable). Jinja2 Default Payload Applied Intelligence uses a templating framework called Jinja2 in the Webhook interface. Here is a default Jinja2 payload to use: { \"id\": {{ id }}, \"url\": {{ url }}, \"ui_name\": {{ ui_name }}, \"description\": {{ description }}, \"priority\": {{ priority }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"active_since\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"sources\": {{ sources }}, \"incidents\": {{ incidents }}, \"pathways\": {{ pathways }}, } Copy Jinja2 Useful Syntax Below are a few useful Jinja2 commands to help you format your output. Casting a value to integer Example: “severity”: {{ priority | int }} Copy If clause to check if an attribute’s value is set Example: \"golden_signals\": {% if accumulations['alert/signal'] is defined %} {{ accumulations['alert/signal'] }} {% else %} None {% endif %} Copy For loop to iterate of an array of values: Example: \"description\": 'Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]' Copy Check if an array attribute's value is set: Example: \"hostname_field\": {% if incidents[0].labels['newrelic/tag/hostname'] is defined %} {{ incidents[0].labels['newrelic/tag/hostname'] }} {% else %} None {% endif %} Copy JSON schema Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). JSON schema template JSON schema: { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"definitions\": { \"Labels\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"LabelsSet\": { \"type\": \"array\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"$ref\": \"#/definitions/Labels\" }, \"uniqueItems\": true }, }, \"Annotations\": { \"type\": \"object\", \"title\": \"Additional contextual information about the Entity\", \"description\": \"Fields like title, description and priority can be described as annotations since\\nthey represent some additional information about the Incident.\\nFor example, the rule that creates the entity can have some logic that will create a title annotation field.\\nThe title will change according to the latest event received by the entity and as more\\nevent will keep coming the field may change, all this as a decision by the rule.\\nA different rule may decide not to populate the title at all.\\nSince a title can also be produced from the labels themselves.\", \"properties\": { \"title\": { \"type\": \"string\", \"maxLength\": 10000 }, \"description\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"patternProperties\": { \".*\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"Accumulations\": { \"type\": \"object\", \"title\": \"Accumulated data about the Incident\", \"description\": \"For example an entity with the label: host_name: foo will include a accumulated list of the\\nrelevant process names that are relevant to the entity. Accumulations will be derived from the events\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"type\": \"string\", \"maxLength\": 10000 } } }, \"IssueState\": { \"type\": \"string\", \"enum\": [ \"created\", \"active\", \"acknowledged\", \"closed\" ], \"properties\": {}, \"additionalProperties\": false }, \"Priority\": { \"type\": \"string\", \"enum\": [ \"critical\", \"high\", \"medium\", \"low\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueClosingReason\": { \"type\": \"string\", \"enum\": [ \"nacked\", \"resolved\", \"system\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueAction\": { \"type\": \"string\", \"enum\": [ \"ack\", \"snooze\", \"nack\", \"end_snooze\", \"expire_snooze\", \"star\", \"un_snooze\", \"unstar\", \"archive\", \"unarchive\", \"resolve\", \"reopen\", \"open\", \"feedback\", \"feedback_file\", \"open_ticket\", \"merge_issues\", \"active\", \"create\", \"close\", \"incident_updated\", \"confidence_changed\", \"diagnoses_changed\", \"rule_properties_changed\", \"flapping\", \"notification\", \"incident_events_limit_reached\", \"follow\", \"unfollow\", \"priority_updated\", \"comment\", \"incident_appended\", \"diagnosis_feedback\", \"flapping_delay_close\" ], \"properties\": {}, \"additionalProperties\": false }, \"StringKeyValue\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\" } }, \"JavaOptionalUuid\": { \"type\": \"string\", \"properties\": {}, \"additionalProperties\": false, \"format\": \"string-uuid\" } }, \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"customer_id\": { \"type\": \"integer\" }, \"labels_set\": { \"$ref\": \"#/definitions/LabelsSet\" }, \"annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations_version\": { \"type\": \"integer\" }, \"accumulations\": { \"$ref\": \"#/definitions/Accumulations\" }, \"state\": { \"$ref\": \"#/definitions/IssueState\" }, \"previous_state\": { \"$ref\": \"#/definitions/IssueState\" }, \"priority\": { \"$ref\": \"#/definitions/Priority\" }, \"closing_reason\": { \"oneOf\": [ { \"$ref\": \"#/definitions/IssueClosingReason\" }, { \"type\": \"null\" } ] }, \"modified_on\": { \"type\": \"integer\" }, \"created_on\": { \"type\": \"integer\" }, \"closed_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"acknowledged_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"active_since\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"assigned_to\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"created_by\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"progress_report\": { \"type\": \"array\", \"default\": [], \"items\": { \"type\": \"object\", \"properties\": { \"origin_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1 }, { \"type\": \"null\" } ] }, \"timestamp\": { \"type\": \"integer\" }, \"action_timestamp\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"origin_type\": { \"type\": \"string\", \"enum\": [ \"user\", \"system\" ] }, \"event_type\": { \"$ref\": \"#/definitions/IssueAction\" }, \"issue_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"format\": \"string-uuid\" }, { \"type\": \"null\" } ] }, \"attributes\": { \"oneOf\": [ { \"$ref\": \"#/definitions/StringKeyValue\" }, { \"type\": \"null\" } ] }, \"team_id\": { \"$ref\": \"#/definitions/JavaOptionalUuid\" } }, \"required\": [ \"timestamp\", \"origin_type\", \"event_type\" ], \"additionalProperties\": false }, \"uniqueItems\": true }, \"rule_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"maxLength\": 255 }, { \"type\": \"null\" } ] }, \"incident_ids\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"confidence\": { \"type\": \"number\", \"default\": 1.0, \"minimum\": 0.0, \"maximum\": 1.0 } }, \"required\": [ \"id\", \"customer_id\", \"labels_set\", \"annotations\", \"priority\", \"modified_on\", \"created_on\", \"confidence\" ], \"additionalProperties\": true } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.20096,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Incident</em> <em>Intelligence</em> destination examples",
        "sections": "<em>Incident</em> <em>Intelligence</em> destination examples",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In <em>New</em> <em>Relic</em> <em>Applied</em> <em>Intelligence</em>, under Incident <em>Intelligence</em> click Destinations Add a WebHook In the end point paste the WebHook url"
      },
      "id": "6044280d64441f4af5378ed3"
    },
    {
      "sections": [
        "View violation and event details for incidents",
        "View the incidents index and violation details",
        "Tip",
        "View the events in an incident",
        "Time between violation and notification",
        "Anomalous behavior detection",
        "Alerts notification in Slack",
        "Alerts notification in PagerDuty"
      ],
      "title": "View violation and event details for incidents",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert incidents"
      ],
      "external_id": "7c01873917140e1922227598b7532b36343e308a",
      "image": "https://docs.newrelic.com/static/5878dd9ec30c9251961517a34ba88dc5/8c557/screen-alerts-incident-page_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-incidents/view-violation-event-details-incidents/",
      "published_at": "2021-06-02T21:22:23Z",
      "updated_at": "2021-03-30T07:44:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When violations of the threshold set in a condition occur, depending on the policy's Incident preference settings, Alerts may create an incident. You can review information about incidents in several ways: View the incidents index so you can scan for patterns in a list of incidents. View the violations included in a specific incident to examine associated performance details. View the events included in a specific incident to review the timestamps for events, such as a violation opening or closing, notifications, and acknowledgments. one.newrelic.com > Alerts & AI > Incidents > (select an incident): Notice that the condition's threshold was violated around 2pm (the blue line went over the red dotted line), but the alert wasn't triggered until the violation occurred for more than five minutes, as specified in the condition. View the incidents index and violation details Violations are grouped together into incidents. If you want to change how violations are grouped, open the associated policy and change the Incident preference setting. To view violation details: In the one.newrelic.com top nav, click Alerts & AI, click Incidents, then click Open incidents or All incidents. Select an incident row. Click Violations to view a list of the violations included in this incident. Select one of the violations to see a chart and details for it. Details for individual violation charts include: Timing information: The shaded red area on the chart shows you the time period when the violation occurred, where the preceding shaded pink area represents the degradation period. If you select a violation that lasted longer than two hours, the timeline on the bottom of the chart will be jagged. To provide context for events in the incident, the chart also shows the time frame surrounding the violation. Chart guidelines: The red dotted line marks the threshold for the condition. The blue line depicts performance information. Anomalous behavior: If Alerts detects anomalous behavior near the time of the violation, you'll see a notification in the violation details. From this page, you can take action regarding the incident: If you want to... Do this Assume responsibility for the incident Acknowledge the incident by selecting the acknowledge icon or button. View information about events Mouse over any spot on the blue line in the chart to display event information. Manually close the violation Below the chart, select the Manually close violation link. Tip Anyone in the account who can view the violation can also close it. Edit the policy or condition Select the Settings gear icon or select the name of the policy above the chart. View the events in an incident If you want to view alerting events across all products, go to one.newrelic.com, then click Explorer. To view the events for just one incident: Go to one.newrelic.com, then click Explorer. Select an entity row. In the left nav under Events, click Violations. Select one of the events to view a chart and details for it. Time between violation and notification There may be a difference of up to three minutes between the violation event time and the initial notification time due to variances in data processing time. Notification time: The time in the notification reflects the timestamp of when we received the request to deliver a notification. Violation time: The time you see on the Events page for the violation reflects the timestamp of data collection for the last data point that contributed to opening the violation. Anomalous behavior detection When we detect large changes in key signals in the alerting entity and/or upstream/downstream applications of the alerting entity, an \"anomalous behavior detected\" notification appears on the violation's page and in notification channels. You can: Expand the notification for details about the detected anomaly (web only). See upstream/downstream anomalies (Slack only). Select a link to go to the relevant product chart for further investigation. Alerts notification in Slack Example of an \"anomalous behavior detected\" notification in Slack. Alerts notification in PagerDuty Example of an \"anomalous behavior detected\" notification in PagerDuty.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.11018,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "View violation <em>and</em> event details for <em>incidents</em>",
        "sections": "View violation <em>and</em> event details for <em>incidents</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "When violations of the threshold set in a condition occur, depending on the policy&#x27;s Incident preference settings, <em>Alerts</em> may create an incident. You can review information about <em>incidents</em> in several ways: View the <em>incidents</em> index so you can scan for patterns in a list of <em>incidents</em>. View"
      },
      "id": "60440c01196a67ba9c960f3c"
    },
    {
      "sections": [
        "View events from their products",
        "View health status from product entities (targets)",
        "View events and activity lists from products",
        "Tip",
        "View event violations",
        "View all event types"
      ],
      "title": "View events from their products",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert incidents"
      ],
      "external_id": "0ccba4fb4db302b133e2d9047a943db9aba5bffc",
      "image": "https://docs.newrelic.com/static/17ca06d35c7d290e100b436c4e9dbe9d/8c557/crop-apm-index-health_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-incidents/view-events-their-products/",
      "published_at": "2021-06-02T21:21:45Z",
      "updated_at": "2021-03-13T01:30:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can view events and other activity for a specific entity from the New Relic One product index. For example, to find more information about a specific app in APM: Go to one.newrelic.com, in the top nav click APM, then mouse over the listed apps, or select an event from the Applications activity list. For instructions on how to view these details in Infrastructure, see the Infrastructure documentation. View health status from product entities (targets) To view information about the current status for an entity (alert condition target): From the menu bar, select the product (APM, Browser, etc.). The right side of the screen shows all of the violations for the entities listed. one.newrelic.com > APM : This example shows the violations for all of the APM applications for a specific account. The color-coded health states indicate Critical (red) conditions. View events and activity lists from products You can view a list of events and other activity from the index for the selected product. By selecting an event from the list, you can go directly to the selected entity's Summary page, where you can view detailed information. one.newrelic.com: Here's an example of a Summary of Application activity. It includes errors and violations. Depending on the product, the recent events and activity list also may appear on the selected entity's Overview page. Tip Exception: The index for dashboards and Synthetic monitoring doesn't include a list of recent events and other activity. View event violations To view an index of events resulting in condition violations across all available products: Go to one.newrelic.com, in the top nav click Alerts & AI, click Events, then click Violations. The Violations index provides summary information about alerting events across all products. From here, follow standard procedures to sort any column or select available links on any row to view drill-down details. For example: To view the Overview page for the entity associated with the violation (if available), select the Target. To view the condition that triggered the violation, select the Condition. To view incident details, select the Incident ID. View all event types To view an index of events for all available products: Go to one.newrelic.com, in the top nav click Alerts & AI, click Events, then click All events. The All events index provides summary information about alerting events across available products. From here, follow standard procedures to sort any column or select available links on any row to view drill-down details. For example: To view the Overview page for the entity associated with the violation, select its name from the Description. To view the condition that triggered the violation, select the condition's name from the Description. To view incident details, select the Incident ID.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 162.83357,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View events <em>and</em> activity lists from products",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "You can view events and other activity for a specific entity from the <em>New</em> <em>Relic</em> One product index. For example, to find more information about a specific app in APM: Go to one.newrelic.com, in the top nav click APM, then mouse over the listed apps, or select an event from the Applications activity"
      },
      "id": "60440c01196a67ac6b960f71"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-incidents/view-events-their-products": [
    {
      "sections": [
        "Incident Intelligence destination examples",
        "Destination template examples",
        "Suggested OpsGenie template example",
        "Suggested ServiceNow template example",
        "Suggested Slack template example",
        "Suggested VictorOps template example",
        "Webhook and JSON format examples",
        "Webhook format and JSON example",
        "Jinja2 Default Payload",
        "Jinja2 Useful Syntax",
        "JSON schema",
        "JSON schema template"
      ],
      "title": "Incident Intelligence destination examples",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "a516d04f8b75541a6dc9338fa3ce9645ba87d620",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/incident-intelligence-destination-examples/",
      "published_at": "2021-06-02T18:22:22Z",
      "updated_at": "2021-06-02T18:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Destinations are the data outputs to Applied Intelligence, where you can view your automatically correlated incidents. You can configure Incident Intelligence destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema. Destination template examples The following template example destinations are formatted in Jinja2. Suggested OpsGenie template example { \"alias\": {{ id }}, \"message\": {{ ui_name }}, \"source\": '{{ sources }}', \"priority\": {{ priority }}, \"details\": { \"self_url\": {{ url }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"is_correlated\": {{ is_correlated }} }, \"description\": \"\"\"Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]\"\"\" } Copy Suggested ServiceNow template example { \"short_description\": {{ ui_name }}, \"description\": 'Issue Id: {{ id }}, \\n Description: {{ description }}, \\n Sources: {{ sources }}, \\n Priority: {{ priority }}, \\n Details: { \\n self_url: {{ url }}, \\n state: {{ state }}, \\n is_correlated: {{ is_correlated }}, \\n created_on: {{ created_on }}, \\n modified_on: {{ modified_on }}, \\n activated_on: {{ active_since }}, \\n closed_on: {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \\n is_correlated: {{is_correlated}} }, \\n\\n incidents: {{ incidents }}, \\n\\n pathways: {{ pathways }}' } Copy Suggested Slack template example Go to Slack incoming WebHooks Choose the right Slack workspace and click \"Add to Slack\" Select the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In New Relic Applied Intelligence, under Incident Intelligence click Destinations Add a WebHook In the end point paste the WebHook url from slack. In the custom payload, paste the following JSON: { \"blocks\": [ { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*New Relic Incident Intelligence Alert*\" } }, { \"type\": \"divider\" }, { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*CUSTOM FIELDS*:\" }, \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue ID*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Issue Title*\" }, { \"type\": \"plain_text\", \"text\": {{ id }} }, { \"type\": \"plain_text\", \"text\": {{ ui_name }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue URL*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Description*\" }, { \"type\": \"mrkdwn\", \"text\": {{ url }} }, { \"type\": \"plain_text\", \"text\": {{ description }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*State*\" }, { \"type\": \"mrkdwn\", \"text\": \"*is_correlated*\" }, { \"type\": \"plain_text\", \"text\": {{ state }} }, { \"type\": \"plain_text\", \"text\": \"{{ is_correlated }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Created On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Modified On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ created_on }}\" }, { \"type\": \"plain_text\", \"text\": \"{{ modified_on }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Activated On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Closed On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ active_since }}\" }, { \"type\": \"plain_text\", \"text\": \"{% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Aggregated Incidents*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Monitoring Tool*\" }, { \"type\": \"plain_text\", \"text\": \"{{ incident_count }}\" }, { \"type\": \"plain_text\", \"text\": {{ sources|join(', ') }} } ] } ] } Copy Suggested VictorOps template example { \"monitoring_tool\": {{ sources }}, {% if state == 'closed' %} \"message_type\": \"OK\", {% else %} \"message_type\": {{ priority }}, {% endif %} \"custom_fields\": { \"issue_url\": {{ url }}, \"description\": {{ description }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"related_incidents\": [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %} {% endfor %} ] }, \"state_message\": {{ description }}, \"entity_id\": {{ id }}, \"entity_display_name\": {{ ui_name }}, \"vo_annotate.u.NRAI_Link\": {{ url }} } Copy Webhook and JSON format examples Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). If you use webhooks to configure Incident Intelligence destinations, use these examples of the webhook body format and JSON schema. Webhook format and JSON example Webhook format: Name Description url Href A link to the UI where the issue can be seen. id String Unique identifier for the issue. title String The issue title. description String The description of the issue. priority Enum The issue priority. Can be Critical, High, Medium, or Low. state Enum The issue status. Can be Active, Closed, or Acknowledged. is_correlated Boolean True if the issue is based on correlated data. created_on String The date and time the issue was created (in ISO format). modified_on String The date and time the issue was modified (in ISO format). active_since String The date and time the issue was activated (in ISO format). closed_on String The date and time the issue was closed (in ISO format). sources List(String) List of the different sources that were used to send the events into Applied Intelligence (for example: PagerDuty). pathways List(Pathways) List of pathways that are associated with the issue. Each pathway contains an id and name: [{“id”: “pathway id”, “name”: “pathway name”}]. pathways[].id String The pathway ID. pathways[].name String The pathway name. incidents List(Incident) List of incidents that are attached to the issue. The list contains only the latest 100 incidents. incidents[].id String The incident ID. incidents[].events_count Integer The number of events used to create the incident. incidents[].title String The incident title. incidents[].description String The incident description. incidents[].labels Dictionary (String) A string to string mapping of the incident labels. Labels represent the unique entities that are used to describe the incident. incidents[].priority Enum The incident priority. Can be Critical, High, Medium, or Low. incidents[].sources List(String) The incident source. incidents[].state Enum(open, closed) The incident state. incidents[].opened_on String The date and time the incident was opened (in ISO format). incidents[].closed_on String The date and time the incident was closed (in ISO format). ui_name String Issue title. accumulations['alert/signal'] String Issue analysis summary golden signal/s (if applicable). accumulations['alert/components'] String Issue analysis summary golden components (if applicable). Jinja2 Default Payload Applied Intelligence uses a templating framework called Jinja2 in the Webhook interface. Here is a default Jinja2 payload to use: { \"id\": {{ id }}, \"url\": {{ url }}, \"ui_name\": {{ ui_name }}, \"description\": {{ description }}, \"priority\": {{ priority }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"active_since\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"sources\": {{ sources }}, \"incidents\": {{ incidents }}, \"pathways\": {{ pathways }}, } Copy Jinja2 Useful Syntax Below are a few useful Jinja2 commands to help you format your output. Casting a value to integer Example: “severity”: {{ priority | int }} Copy If clause to check if an attribute’s value is set Example: \"golden_signals\": {% if accumulations['alert/signal'] is defined %} {{ accumulations['alert/signal'] }} {% else %} None {% endif %} Copy For loop to iterate of an array of values: Example: \"description\": 'Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]' Copy Check if an array attribute's value is set: Example: \"hostname_field\": {% if incidents[0].labels['newrelic/tag/hostname'] is defined %} {{ incidents[0].labels['newrelic/tag/hostname'] }} {% else %} None {% endif %} Copy JSON schema Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). JSON schema template JSON schema: { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"definitions\": { \"Labels\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"LabelsSet\": { \"type\": \"array\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"$ref\": \"#/definitions/Labels\" }, \"uniqueItems\": true }, }, \"Annotations\": { \"type\": \"object\", \"title\": \"Additional contextual information about the Entity\", \"description\": \"Fields like title, description and priority can be described as annotations since\\nthey represent some additional information about the Incident.\\nFor example, the rule that creates the entity can have some logic that will create a title annotation field.\\nThe title will change according to the latest event received by the entity and as more\\nevent will keep coming the field may change, all this as a decision by the rule.\\nA different rule may decide not to populate the title at all.\\nSince a title can also be produced from the labels themselves.\", \"properties\": { \"title\": { \"type\": \"string\", \"maxLength\": 10000 }, \"description\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"patternProperties\": { \".*\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"Accumulations\": { \"type\": \"object\", \"title\": \"Accumulated data about the Incident\", \"description\": \"For example an entity with the label: host_name: foo will include a accumulated list of the\\nrelevant process names that are relevant to the entity. Accumulations will be derived from the events\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"type\": \"string\", \"maxLength\": 10000 } } }, \"IssueState\": { \"type\": \"string\", \"enum\": [ \"created\", \"active\", \"acknowledged\", \"closed\" ], \"properties\": {}, \"additionalProperties\": false }, \"Priority\": { \"type\": \"string\", \"enum\": [ \"critical\", \"high\", \"medium\", \"low\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueClosingReason\": { \"type\": \"string\", \"enum\": [ \"nacked\", \"resolved\", \"system\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueAction\": { \"type\": \"string\", \"enum\": [ \"ack\", \"snooze\", \"nack\", \"end_snooze\", \"expire_snooze\", \"star\", \"un_snooze\", \"unstar\", \"archive\", \"unarchive\", \"resolve\", \"reopen\", \"open\", \"feedback\", \"feedback_file\", \"open_ticket\", \"merge_issues\", \"active\", \"create\", \"close\", \"incident_updated\", \"confidence_changed\", \"diagnoses_changed\", \"rule_properties_changed\", \"flapping\", \"notification\", \"incident_events_limit_reached\", \"follow\", \"unfollow\", \"priority_updated\", \"comment\", \"incident_appended\", \"diagnosis_feedback\", \"flapping_delay_close\" ], \"properties\": {}, \"additionalProperties\": false }, \"StringKeyValue\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\" } }, \"JavaOptionalUuid\": { \"type\": \"string\", \"properties\": {}, \"additionalProperties\": false, \"format\": \"string-uuid\" } }, \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"customer_id\": { \"type\": \"integer\" }, \"labels_set\": { \"$ref\": \"#/definitions/LabelsSet\" }, \"annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations_version\": { \"type\": \"integer\" }, \"accumulations\": { \"$ref\": \"#/definitions/Accumulations\" }, \"state\": { \"$ref\": \"#/definitions/IssueState\" }, \"previous_state\": { \"$ref\": \"#/definitions/IssueState\" }, \"priority\": { \"$ref\": \"#/definitions/Priority\" }, \"closing_reason\": { \"oneOf\": [ { \"$ref\": \"#/definitions/IssueClosingReason\" }, { \"type\": \"null\" } ] }, \"modified_on\": { \"type\": \"integer\" }, \"created_on\": { \"type\": \"integer\" }, \"closed_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"acknowledged_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"active_since\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"assigned_to\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"created_by\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"progress_report\": { \"type\": \"array\", \"default\": [], \"items\": { \"type\": \"object\", \"properties\": { \"origin_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1 }, { \"type\": \"null\" } ] }, \"timestamp\": { \"type\": \"integer\" }, \"action_timestamp\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"origin_type\": { \"type\": \"string\", \"enum\": [ \"user\", \"system\" ] }, \"event_type\": { \"$ref\": \"#/definitions/IssueAction\" }, \"issue_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"format\": \"string-uuid\" }, { \"type\": \"null\" } ] }, \"attributes\": { \"oneOf\": [ { \"$ref\": \"#/definitions/StringKeyValue\" }, { \"type\": \"null\" } ] }, \"team_id\": { \"$ref\": \"#/definitions/JavaOptionalUuid\" } }, \"required\": [ \"timestamp\", \"origin_type\", \"event_type\" ], \"additionalProperties\": false }, \"uniqueItems\": true }, \"rule_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"maxLength\": 255 }, { \"type\": \"null\" } ] }, \"incident_ids\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"confidence\": { \"type\": \"number\", \"default\": 1.0, \"minimum\": 0.0, \"maximum\": 1.0 } }, \"required\": [ \"id\", \"customer_id\", \"labels_set\", \"annotations\", \"priority\", \"modified_on\", \"created_on\", \"confidence\" ], \"additionalProperties\": true } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.2008,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Incident</em> <em>Intelligence</em> destination examples",
        "sections": "<em>Incident</em> <em>Intelligence</em> destination examples",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In <em>New</em> <em>Relic</em> <em>Applied</em> <em>Intelligence</em>, under Incident <em>Intelligence</em> click Destinations Add a WebHook In the end point paste the WebHook url"
      },
      "id": "6044280d64441f4af5378ed3"
    },
    {
      "sections": [
        "View violation and event details for incidents",
        "View the incidents index and violation details",
        "Tip",
        "View the events in an incident",
        "Time between violation and notification",
        "Anomalous behavior detection",
        "Alerts notification in Slack",
        "Alerts notification in PagerDuty"
      ],
      "title": "View violation and event details for incidents",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert incidents"
      ],
      "external_id": "7c01873917140e1922227598b7532b36343e308a",
      "image": "https://docs.newrelic.com/static/5878dd9ec30c9251961517a34ba88dc5/8c557/screen-alerts-incident-page_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-incidents/view-violation-event-details-incidents/",
      "published_at": "2021-06-02T21:22:23Z",
      "updated_at": "2021-03-30T07:44:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When violations of the threshold set in a condition occur, depending on the policy's Incident preference settings, Alerts may create an incident. You can review information about incidents in several ways: View the incidents index so you can scan for patterns in a list of incidents. View the violations included in a specific incident to examine associated performance details. View the events included in a specific incident to review the timestamps for events, such as a violation opening or closing, notifications, and acknowledgments. one.newrelic.com > Alerts & AI > Incidents > (select an incident): Notice that the condition's threshold was violated around 2pm (the blue line went over the red dotted line), but the alert wasn't triggered until the violation occurred for more than five minutes, as specified in the condition. View the incidents index and violation details Violations are grouped together into incidents. If you want to change how violations are grouped, open the associated policy and change the Incident preference setting. To view violation details: In the one.newrelic.com top nav, click Alerts & AI, click Incidents, then click Open incidents or All incidents. Select an incident row. Click Violations to view a list of the violations included in this incident. Select one of the violations to see a chart and details for it. Details for individual violation charts include: Timing information: The shaded red area on the chart shows you the time period when the violation occurred, where the preceding shaded pink area represents the degradation period. If you select a violation that lasted longer than two hours, the timeline on the bottom of the chart will be jagged. To provide context for events in the incident, the chart also shows the time frame surrounding the violation. Chart guidelines: The red dotted line marks the threshold for the condition. The blue line depicts performance information. Anomalous behavior: If Alerts detects anomalous behavior near the time of the violation, you'll see a notification in the violation details. From this page, you can take action regarding the incident: If you want to... Do this Assume responsibility for the incident Acknowledge the incident by selecting the acknowledge icon or button. View information about events Mouse over any spot on the blue line in the chart to display event information. Manually close the violation Below the chart, select the Manually close violation link. Tip Anyone in the account who can view the violation can also close it. Edit the policy or condition Select the Settings gear icon or select the name of the policy above the chart. View the events in an incident If you want to view alerting events across all products, go to one.newrelic.com, then click Explorer. To view the events for just one incident: Go to one.newrelic.com, then click Explorer. Select an entity row. In the left nav under Events, click Violations. Select one of the events to view a chart and details for it. Time between violation and notification There may be a difference of up to three minutes between the violation event time and the initial notification time due to variances in data processing time. Notification time: The time in the notification reflects the timestamp of when we received the request to deliver a notification. Violation time: The time you see on the Events page for the violation reflects the timestamp of data collection for the last data point that contributed to opening the violation. Anomalous behavior detection When we detect large changes in key signals in the alerting entity and/or upstream/downstream applications of the alerting entity, an \"anomalous behavior detected\" notification appears on the violation's page and in notification channels. You can: Expand the notification for details about the detected anomaly (web only). See upstream/downstream anomalies (Slack only). Select a link to go to the relevant product chart for further investigation. Alerts notification in Slack Example of an \"anomalous behavior detected\" notification in Slack. Alerts notification in PagerDuty Example of an \"anomalous behavior detected\" notification in PagerDuty.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.11018,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "View violation <em>and</em> event details for <em>incidents</em>",
        "sections": "View violation <em>and</em> event details for <em>incidents</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "When violations of the threshold set in a condition occur, depending on the policy&#x27;s Incident preference settings, <em>Alerts</em> may create an incident. You can review information about <em>incidents</em> in several ways: View the <em>incidents</em> index so you can scan for patterns in a list of <em>incidents</em>. View"
      },
      "id": "60440c01196a67ba9c960f3c"
    },
    {
      "sections": [
        "Acknowledge alert incidents",
        "What \"acknowledge\" means",
        "Tip",
        "How to acknowledge incidents",
        "What happens to additional violations",
        "Where to view your acknowledged incidents",
        "What other options to acknowledge are available"
      ],
      "title": "Acknowledge alert incidents",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert incidents"
      ],
      "external_id": "826f58dd9f52aefe2177c12a844cdb361b858f0d",
      "image": "https://docs.newrelic.com/static/7a41dffde9123be6f0fbe7baae9252dc/632ae/040815incidents-ack.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-incidents/acknowledge-alert-incidents/",
      "published_at": "2021-06-02T21:21:16Z",
      "updated_at": "2021-03-16T06:59:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When you acknowledge an incident, this indicates you're taking ownership of it. This is useful to let others who've received the notification know that you've taken responsibility for it. What \"acknowledge\" means Follow your organization's guidelines for what responsibilities you are agreeing to own when you acknowledge an incident. By acknowledging the incident, this simply flags your name and notifies others. Tip To provide a quick reference to your organization's standard operating procedures for handling an alert, you can include a runbook URL in the condition thresholds for the alert policy. The UI will include the runbook URL in Incidents pages and in email notifications as applicable. Only one person can acknowledge an incident. Once you acknowledge it, you can't undo it. If others try to acknowledge the same incident (for example, from their email notification), the incident's History page will appear, showing that the incident has been acknowledged. How to acknowledge incidents The user interface allows you to view incidents and acknowledge them, either from the Incidents index or from the selected incident itself. The Incidents page provides details about the incident history so you can more easily analyze the chain of events and their timeline throughout an incident. To acknowledge an incident from the user interface: In the one.newrelic.com top nav, click Alerts & AI, click Incidents, then click Open incidents or All incidents. From the selected incident row, check whether someone else's name or avatar already appears in the Acknowledge column. To find out the user's name, mouse over the avatar. To acknowledge the incident, yourself, select the Acknowledge icon. This automatically notifies everyone who has been set up to receive the notification. The UI also automatically adds your name (or avatar if applicable) to the incident's Acknowledge column. What happens to additional violations Your incident rollup preference determines whether and how Alerts will group the additional violations in the Incidents page. If you acknowledge an incident and new violations occur that roll up into the incident you just acknowledged, no further notifications will be sent out until the incident closes. Where to view your acknowledged incidents To view any incidents you have acknowledged: In the one.newrelic.com top nav, click Alerts & AI, click Incidents, then click Open incidents. Optional: Use any available search or sort options to refine the index results (not available for the Acknowledge column). Select any row that shows your name or avatar to view the incident's history and details. What other options to acknowledge are available You can use additional methods (channels) to acknowledge notifications. For example: If your notification channel includes email, you can acknowledge the alert at the time you receive it by selecting the email's Acknowledge link. If you've registered and linked your iOS or Android mobile app to your account, you can add mobile as a notification channel in your policies. For example, Android users can then acknowledge an alert by using the notification bar. You don't need to open the New Relic app.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.50316,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Acknowledge <em>alert</em> <em>incidents</em>",
        "sections": "Acknowledge <em>alert</em> <em>incidents</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " also automatically adds your name (or avatar if applicable) to the incident&#x27;s Acknowledge column. What happens to additional violations Your incident rollup preference determines whether and how <em>Alerts</em> will group the additional violations in the <em>Incidents</em> page. If you acknowledge an incident and <em>new</em>"
      },
      "id": "603ed04a64441fa7104e8840"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-incidents/view-violation-event-details-incidents": [
    {
      "sections": [
        "Incident Intelligence destination examples",
        "Destination template examples",
        "Suggested OpsGenie template example",
        "Suggested ServiceNow template example",
        "Suggested Slack template example",
        "Suggested VictorOps template example",
        "Webhook and JSON format examples",
        "Webhook format and JSON example",
        "Jinja2 Default Payload",
        "Jinja2 Useful Syntax",
        "JSON schema",
        "JSON schema template"
      ],
      "title": "Incident Intelligence destination examples",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "a516d04f8b75541a6dc9338fa3ce9645ba87d620",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/incident-intelligence-destination-examples/",
      "published_at": "2021-06-02T18:22:22Z",
      "updated_at": "2021-06-02T18:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Destinations are the data outputs to Applied Intelligence, where you can view your automatically correlated incidents. You can configure Incident Intelligence destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema. Destination template examples The following template example destinations are formatted in Jinja2. Suggested OpsGenie template example { \"alias\": {{ id }}, \"message\": {{ ui_name }}, \"source\": '{{ sources }}', \"priority\": {{ priority }}, \"details\": { \"self_url\": {{ url }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"is_correlated\": {{ is_correlated }} }, \"description\": \"\"\"Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]\"\"\" } Copy Suggested ServiceNow template example { \"short_description\": {{ ui_name }}, \"description\": 'Issue Id: {{ id }}, \\n Description: {{ description }}, \\n Sources: {{ sources }}, \\n Priority: {{ priority }}, \\n Details: { \\n self_url: {{ url }}, \\n state: {{ state }}, \\n is_correlated: {{ is_correlated }}, \\n created_on: {{ created_on }}, \\n modified_on: {{ modified_on }}, \\n activated_on: {{ active_since }}, \\n closed_on: {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \\n is_correlated: {{is_correlated}} }, \\n\\n incidents: {{ incidents }}, \\n\\n pathways: {{ pathways }}' } Copy Suggested Slack template example Go to Slack incoming WebHooks Choose the right Slack workspace and click \"Add to Slack\" Select the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In New Relic Applied Intelligence, under Incident Intelligence click Destinations Add a WebHook In the end point paste the WebHook url from slack. In the custom payload, paste the following JSON: { \"blocks\": [ { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*New Relic Incident Intelligence Alert*\" } }, { \"type\": \"divider\" }, { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*CUSTOM FIELDS*:\" }, \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue ID*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Issue Title*\" }, { \"type\": \"plain_text\", \"text\": {{ id }} }, { \"type\": \"plain_text\", \"text\": {{ ui_name }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue URL*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Description*\" }, { \"type\": \"mrkdwn\", \"text\": {{ url }} }, { \"type\": \"plain_text\", \"text\": {{ description }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*State*\" }, { \"type\": \"mrkdwn\", \"text\": \"*is_correlated*\" }, { \"type\": \"plain_text\", \"text\": {{ state }} }, { \"type\": \"plain_text\", \"text\": \"{{ is_correlated }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Created On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Modified On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ created_on }}\" }, { \"type\": \"plain_text\", \"text\": \"{{ modified_on }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Activated On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Closed On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ active_since }}\" }, { \"type\": \"plain_text\", \"text\": \"{% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Aggregated Incidents*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Monitoring Tool*\" }, { \"type\": \"plain_text\", \"text\": \"{{ incident_count }}\" }, { \"type\": \"plain_text\", \"text\": {{ sources|join(', ') }} } ] } ] } Copy Suggested VictorOps template example { \"monitoring_tool\": {{ sources }}, {% if state == 'closed' %} \"message_type\": \"OK\", {% else %} \"message_type\": {{ priority }}, {% endif %} \"custom_fields\": { \"issue_url\": {{ url }}, \"description\": {{ description }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"related_incidents\": [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %} {% endfor %} ] }, \"state_message\": {{ description }}, \"entity_id\": {{ id }}, \"entity_display_name\": {{ ui_name }}, \"vo_annotate.u.NRAI_Link\": {{ url }} } Copy Webhook and JSON format examples Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). If you use webhooks to configure Incident Intelligence destinations, use these examples of the webhook body format and JSON schema. Webhook format and JSON example Webhook format: Name Description url Href A link to the UI where the issue can be seen. id String Unique identifier for the issue. title String The issue title. description String The description of the issue. priority Enum The issue priority. Can be Critical, High, Medium, or Low. state Enum The issue status. Can be Active, Closed, or Acknowledged. is_correlated Boolean True if the issue is based on correlated data. created_on String The date and time the issue was created (in ISO format). modified_on String The date and time the issue was modified (in ISO format). active_since String The date and time the issue was activated (in ISO format). closed_on String The date and time the issue was closed (in ISO format). sources List(String) List of the different sources that were used to send the events into Applied Intelligence (for example: PagerDuty). pathways List(Pathways) List of pathways that are associated with the issue. Each pathway contains an id and name: [{“id”: “pathway id”, “name”: “pathway name”}]. pathways[].id String The pathway ID. pathways[].name String The pathway name. incidents List(Incident) List of incidents that are attached to the issue. The list contains only the latest 100 incidents. incidents[].id String The incident ID. incidents[].events_count Integer The number of events used to create the incident. incidents[].title String The incident title. incidents[].description String The incident description. incidents[].labels Dictionary (String) A string to string mapping of the incident labels. Labels represent the unique entities that are used to describe the incident. incidents[].priority Enum The incident priority. Can be Critical, High, Medium, or Low. incidents[].sources List(String) The incident source. incidents[].state Enum(open, closed) The incident state. incidents[].opened_on String The date and time the incident was opened (in ISO format). incidents[].closed_on String The date and time the incident was closed (in ISO format). ui_name String Issue title. accumulations['alert/signal'] String Issue analysis summary golden signal/s (if applicable). accumulations['alert/components'] String Issue analysis summary golden components (if applicable). Jinja2 Default Payload Applied Intelligence uses a templating framework called Jinja2 in the Webhook interface. Here is a default Jinja2 payload to use: { \"id\": {{ id }}, \"url\": {{ url }}, \"ui_name\": {{ ui_name }}, \"description\": {{ description }}, \"priority\": {{ priority }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"active_since\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"sources\": {{ sources }}, \"incidents\": {{ incidents }}, \"pathways\": {{ pathways }}, } Copy Jinja2 Useful Syntax Below are a few useful Jinja2 commands to help you format your output. Casting a value to integer Example: “severity”: {{ priority | int }} Copy If clause to check if an attribute’s value is set Example: \"golden_signals\": {% if accumulations['alert/signal'] is defined %} {{ accumulations['alert/signal'] }} {% else %} None {% endif %} Copy For loop to iterate of an array of values: Example: \"description\": 'Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]' Copy Check if an array attribute's value is set: Example: \"hostname_field\": {% if incidents[0].labels['newrelic/tag/hostname'] is defined %} {{ incidents[0].labels['newrelic/tag/hostname'] }} {% else %} None {% endif %} Copy JSON schema Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). JSON schema template JSON schema: { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"definitions\": { \"Labels\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"LabelsSet\": { \"type\": \"array\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"$ref\": \"#/definitions/Labels\" }, \"uniqueItems\": true }, }, \"Annotations\": { \"type\": \"object\", \"title\": \"Additional contextual information about the Entity\", \"description\": \"Fields like title, description and priority can be described as annotations since\\nthey represent some additional information about the Incident.\\nFor example, the rule that creates the entity can have some logic that will create a title annotation field.\\nThe title will change according to the latest event received by the entity and as more\\nevent will keep coming the field may change, all this as a decision by the rule.\\nA different rule may decide not to populate the title at all.\\nSince a title can also be produced from the labels themselves.\", \"properties\": { \"title\": { \"type\": \"string\", \"maxLength\": 10000 }, \"description\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"patternProperties\": { \".*\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"Accumulations\": { \"type\": \"object\", \"title\": \"Accumulated data about the Incident\", \"description\": \"For example an entity with the label: host_name: foo will include a accumulated list of the\\nrelevant process names that are relevant to the entity. Accumulations will be derived from the events\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"type\": \"string\", \"maxLength\": 10000 } } }, \"IssueState\": { \"type\": \"string\", \"enum\": [ \"created\", \"active\", \"acknowledged\", \"closed\" ], \"properties\": {}, \"additionalProperties\": false }, \"Priority\": { \"type\": \"string\", \"enum\": [ \"critical\", \"high\", \"medium\", \"low\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueClosingReason\": { \"type\": \"string\", \"enum\": [ \"nacked\", \"resolved\", \"system\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueAction\": { \"type\": \"string\", \"enum\": [ \"ack\", \"snooze\", \"nack\", \"end_snooze\", \"expire_snooze\", \"star\", \"un_snooze\", \"unstar\", \"archive\", \"unarchive\", \"resolve\", \"reopen\", \"open\", \"feedback\", \"feedback_file\", \"open_ticket\", \"merge_issues\", \"active\", \"create\", \"close\", \"incident_updated\", \"confidence_changed\", \"diagnoses_changed\", \"rule_properties_changed\", \"flapping\", \"notification\", \"incident_events_limit_reached\", \"follow\", \"unfollow\", \"priority_updated\", \"comment\", \"incident_appended\", \"diagnosis_feedback\", \"flapping_delay_close\" ], \"properties\": {}, \"additionalProperties\": false }, \"StringKeyValue\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\" } }, \"JavaOptionalUuid\": { \"type\": \"string\", \"properties\": {}, \"additionalProperties\": false, \"format\": \"string-uuid\" } }, \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"customer_id\": { \"type\": \"integer\" }, \"labels_set\": { \"$ref\": \"#/definitions/LabelsSet\" }, \"annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations_version\": { \"type\": \"integer\" }, \"accumulations\": { \"$ref\": \"#/definitions/Accumulations\" }, \"state\": { \"$ref\": \"#/definitions/IssueState\" }, \"previous_state\": { \"$ref\": \"#/definitions/IssueState\" }, \"priority\": { \"$ref\": \"#/definitions/Priority\" }, \"closing_reason\": { \"oneOf\": [ { \"$ref\": \"#/definitions/IssueClosingReason\" }, { \"type\": \"null\" } ] }, \"modified_on\": { \"type\": \"integer\" }, \"created_on\": { \"type\": \"integer\" }, \"closed_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"acknowledged_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"active_since\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"assigned_to\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"created_by\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"progress_report\": { \"type\": \"array\", \"default\": [], \"items\": { \"type\": \"object\", \"properties\": { \"origin_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1 }, { \"type\": \"null\" } ] }, \"timestamp\": { \"type\": \"integer\" }, \"action_timestamp\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"origin_type\": { \"type\": \"string\", \"enum\": [ \"user\", \"system\" ] }, \"event_type\": { \"$ref\": \"#/definitions/IssueAction\" }, \"issue_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"format\": \"string-uuid\" }, { \"type\": \"null\" } ] }, \"attributes\": { \"oneOf\": [ { \"$ref\": \"#/definitions/StringKeyValue\" }, { \"type\": \"null\" } ] }, \"team_id\": { \"$ref\": \"#/definitions/JavaOptionalUuid\" } }, \"required\": [ \"timestamp\", \"origin_type\", \"event_type\" ], \"additionalProperties\": false }, \"uniqueItems\": true }, \"rule_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"maxLength\": 255 }, { \"type\": \"null\" } ] }, \"incident_ids\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"confidence\": { \"type\": \"number\", \"default\": 1.0, \"minimum\": 0.0, \"maximum\": 1.0 } }, \"required\": [ \"id\", \"customer_id\", \"labels_set\", \"annotations\", \"priority\", \"modified_on\", \"created_on\", \"confidence\" ], \"additionalProperties\": true } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.2008,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Incident</em> <em>Intelligence</em> destination examples",
        "sections": "<em>Incident</em> <em>Intelligence</em> destination examples",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In <em>New</em> <em>Relic</em> <em>Applied</em> <em>Intelligence</em>, under Incident <em>Intelligence</em> click Destinations Add a WebHook In the end point paste the WebHook url"
      },
      "id": "6044280d64441f4af5378ed3"
    },
    {
      "sections": [
        "Acknowledge alert incidents",
        "What \"acknowledge\" means",
        "Tip",
        "How to acknowledge incidents",
        "What happens to additional violations",
        "Where to view your acknowledged incidents",
        "What other options to acknowledge are available"
      ],
      "title": "Acknowledge alert incidents",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert incidents"
      ],
      "external_id": "826f58dd9f52aefe2177c12a844cdb361b858f0d",
      "image": "https://docs.newrelic.com/static/7a41dffde9123be6f0fbe7baae9252dc/632ae/040815incidents-ack.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-incidents/acknowledge-alert-incidents/",
      "published_at": "2021-06-02T21:21:16Z",
      "updated_at": "2021-03-16T06:59:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When you acknowledge an incident, this indicates you're taking ownership of it. This is useful to let others who've received the notification know that you've taken responsibility for it. What \"acknowledge\" means Follow your organization's guidelines for what responsibilities you are agreeing to own when you acknowledge an incident. By acknowledging the incident, this simply flags your name and notifies others. Tip To provide a quick reference to your organization's standard operating procedures for handling an alert, you can include a runbook URL in the condition thresholds for the alert policy. The UI will include the runbook URL in Incidents pages and in email notifications as applicable. Only one person can acknowledge an incident. Once you acknowledge it, you can't undo it. If others try to acknowledge the same incident (for example, from their email notification), the incident's History page will appear, showing that the incident has been acknowledged. How to acknowledge incidents The user interface allows you to view incidents and acknowledge them, either from the Incidents index or from the selected incident itself. The Incidents page provides details about the incident history so you can more easily analyze the chain of events and their timeline throughout an incident. To acknowledge an incident from the user interface: In the one.newrelic.com top nav, click Alerts & AI, click Incidents, then click Open incidents or All incidents. From the selected incident row, check whether someone else's name or avatar already appears in the Acknowledge column. To find out the user's name, mouse over the avatar. To acknowledge the incident, yourself, select the Acknowledge icon. This automatically notifies everyone who has been set up to receive the notification. The UI also automatically adds your name (or avatar if applicable) to the incident's Acknowledge column. What happens to additional violations Your incident rollup preference determines whether and how Alerts will group the additional violations in the Incidents page. If you acknowledge an incident and new violations occur that roll up into the incident you just acknowledged, no further notifications will be sent out until the incident closes. Where to view your acknowledged incidents To view any incidents you have acknowledged: In the one.newrelic.com top nav, click Alerts & AI, click Incidents, then click Open incidents. Optional: Use any available search or sort options to refine the index results (not available for the Acknowledge column). Select any row that shows your name or avatar to view the incident's history and details. What other options to acknowledge are available You can use additional methods (channels) to acknowledge notifications. For example: If your notification channel includes email, you can acknowledge the alert at the time you receive it by selecting the email's Acknowledge link. If you've registered and linked your iOS or Android mobile app to your account, you can add mobile as a notification channel in your policies. For example, Android users can then acknowledge an alert by using the notification bar. You don't need to open the New Relic app.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 163.50316,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Acknowledge <em>alert</em> <em>incidents</em>",
        "sections": "Acknowledge <em>alert</em> <em>incidents</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " also automatically adds your name (or avatar if applicable) to the incident&#x27;s Acknowledge column. What happens to additional violations Your incident rollup preference determines whether and how <em>Alerts</em> will group the additional violations in the <em>Incidents</em> page. If you acknowledge an incident and <em>new</em>"
      },
      "id": "603ed04a64441fa7104e8840"
    },
    {
      "sections": [
        "View events from their products",
        "View health status from product entities (targets)",
        "View events and activity lists from products",
        "Tip",
        "View event violations",
        "View all event types"
      ],
      "title": "View events from their products",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert incidents"
      ],
      "external_id": "0ccba4fb4db302b133e2d9047a943db9aba5bffc",
      "image": "https://docs.newrelic.com/static/17ca06d35c7d290e100b436c4e9dbe9d/8c557/crop-apm-index-health_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-incidents/view-events-their-products/",
      "published_at": "2021-06-02T21:21:45Z",
      "updated_at": "2021-03-13T01:30:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can view events and other activity for a specific entity from the New Relic One product index. For example, to find more information about a specific app in APM: Go to one.newrelic.com, in the top nav click APM, then mouse over the listed apps, or select an event from the Applications activity list. For instructions on how to view these details in Infrastructure, see the Infrastructure documentation. View health status from product entities (targets) To view information about the current status for an entity (alert condition target): From the menu bar, select the product (APM, Browser, etc.). The right side of the screen shows all of the violations for the entities listed. one.newrelic.com > APM : This example shows the violations for all of the APM applications for a specific account. The color-coded health states indicate Critical (red) conditions. View events and activity lists from products You can view a list of events and other activity from the index for the selected product. By selecting an event from the list, you can go directly to the selected entity's Summary page, where you can view detailed information. one.newrelic.com: Here's an example of a Summary of Application activity. It includes errors and violations. Depending on the product, the recent events and activity list also may appear on the selected entity's Overview page. Tip Exception: The index for dashboards and Synthetic monitoring doesn't include a list of recent events and other activity. View event violations To view an index of events resulting in condition violations across all available products: Go to one.newrelic.com, in the top nav click Alerts & AI, click Events, then click Violations. The Violations index provides summary information about alerting events across all products. From here, follow standard procedures to sort any column or select available links on any row to view drill-down details. For example: To view the Overview page for the entity associated with the violation (if available), select the Target. To view the condition that triggered the violation, select the Condition. To view incident details, select the Incident ID. View all event types To view an index of events for all available products: Go to one.newrelic.com, in the top nav click Alerts & AI, click Events, then click All events. The All events index provides summary information about alerting events across available products. From here, follow standard procedures to sort any column or select available links on any row to view drill-down details. For example: To view the Overview page for the entity associated with the violation, select its name from the Description. To view the condition that triggered the violation, select the condition's name from the Description. To view incident details, select the Incident ID.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 162.83357,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "View events <em>and</em> activity lists from products",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "You can view events and other activity for a specific entity from the <em>New</em> <em>Relic</em> One product index. For example, to find more information about a specific app in APM: Go to one.newrelic.com, in the top nav click APM, then mouse over the listed apps, or select an event from the Applications activity"
      },
      "id": "60440c01196a67ac6b960f71"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/customize-your-webhook-payload": [
    {
      "sections": [
        "Muting rules: Suppress notifications",
        "Manage muting rules",
        "Create a muting rule",
        "Tip",
        "Schedule a muting rule",
        "Manage muting rules with NerdGraph",
        "How muting rules work",
        "Muting behavior",
        "View muted violations and incidents",
        "An incident with a critical violation that's been muted",
        "An incident that has been muted",
        "A list of violations, some of which are muted",
        "A list of alert events, some of which are muted",
        "Mute faceted results using tags.",
        "Sub-condition operators",
        "Muting examples",
        "Fetch muting rules for account",
        "Create muting rule",
        "Create muting rule for specific hosts or products",
        "Create a muting rule with a recurring schedule",
        "Rename and disable muting rule",
        "Delete muting rule"
      ],
      "title": "Muting rules: Suppress notifications",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "07d71869062b00bb820e52cf89fcb6a06ce523a4",
      "image": "https://docs.newrelic.com/static/595b1c9a595bf6a5c9175f5052298e88/03914/manage_muting_rules.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/muting-rules-suppress-notifications/",
      "published_at": "2021-05-27T19:23:09Z",
      "updated_at": "2021-05-16T09:31:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts sends out timely notifications when your system is having problems. Sometimes there are notifications you know you don't need to see. You can use muting rules to stop being bombarded by messages you don't want. Once you've spotted the common elements in your unwanted notifications, you can define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, Alerts still gathers data on those violations. Muting rules don't interfere with the alerts process and are applied at the point right before a notification is sent. You can read more about why we added muting rules in this blog post. Manage muting rules A muting rule condition is the set of individual expressions made up of attributes, operators, and values that define which violations to target for muting. You can create, enable, disable, and manage muting rules. Go to one.newrelic.com, in the top nav, click Alerts & AI, and then click Muting rules. Enable or disable muting rules at any time. Rules can have one of the following statuses: Active: Muting is enabled and active. Scheduled: Muting is enabled but not active yet (there's a future schedule). Ended: Muting is enabled, but no longer active (there's no future schedule). Inactive: Muting is disabled. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Create a muting rule Tip Before creating muting rules, you'll need to create policies and conditions that generate violation notifications. To create a muting rule, click + Add a rule in the Muting rules screen. Enter a name and a description for the muting rule, and select the account to which the rule will apply. Next, build the violation filter. You can use violation event attributes and sub-condition operators. Values can be compared against one of your violation attributes, such as an Alerts policy ID or a condition name. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Schedule a muting rule If needed, you can schedule your muting rules. To do this, select a start time and/or end time. Optionally, you can set the muting rule to last an entire day. You can also choose to select a time zone for the muting rule schedule. The default is the time zone selected in your user preferences. Flexible and powerful options for scheduling your muting rules. You can schedule your muting rules to recur daily, weekly, or monthly. A muting rule that's scheduled to repeat weekly includes the option to select the days of the week to recur. If no days are selected, the weekly recurrence will default to repeating on the day of the week that the muting rule is scheduled to start. You can also specify when you would like recurrence to end by selecting either a specific date or a certain number of occurrences. Manage muting rules with NerdGraph In NerdGraph, you can use the following queries and mutations with your muting rules. You can see the schema in more detail in the API Explorer. actor.account.alerts.mutingRule: Fetch a muting rule by id. actor.account.alerts.mutingRules: Fetch a list of muting rules for an account. alertsMutingRuleCreate: Create a muting rule for an account. alertsMutingRuleUpdate: Update a muting rule by id and account id. alertsMutingRuleDelete: Delete a muting rule by id and account id. We've given you some sample queries and mutations examples in this document. A muting rule has the following fields and components: Muting rule Fields and components id The unique identifier for the muting rule. name (Required) A text field for the user-friendly name of the muting rule. This is used when listing or referencing a rule. We don't require that the name be unique, but it is recommended. description This is an optional text field describing the muting rule. It can be a useful way to provide more context for your muting rule. This data is only used for management display purposes. accountId The muting rule's account ID. A muting rule will only affect violations that occur in a single account. To mute violations across multiple accounts, you'll need to create a muting rule for each account separately. createdAt The timestamp when the muting rule was created (UTC). createdBy The user ID of the person who created the muting rule. updatedAt The timestamp when the muting rule was last modified (UTC). updatedBy The user ID of the person who last modified the muting rule. enabled Enable or disable the muting rule (Boolean). Muting rules must be manually enabled and disabled. condition The set of individual expressions that define which violations to target. A muting rule condition has: operator: The boolean operator AND or OR that defines how to combine the set of conditions. conditions: The set of individual expressions (sub-conditions) that target attributes within a violation. These are evaluated together based on the operator. You can have a maximum of 20 sub-conditions for a single muting rule. A sub-condition has: attribute: A single attribute within a violation. Go here for a list of Violation event attributes. operator: The comparison function used to compare the selected violation attribute against values in the condition. Go here for a list of sub-condition operators. values: An array of string values to compare against selected violation attributes. When the muting rules evaluate a condition, if necessary, values will be coerced from strings. You can use a maximum of 500 values when using an operator that supports comparison against multiple values, such as IN. schedule The time window when the MutingRule actively mutes violations. startTime: The datetime stamp that represents when the muting rule starts. This is in local ISO 8601 format without an offset. Example: '2020-07-08T14:30:00' endTime: The datetime stamp that represents when the muting rule ends. This is in local ISO 8601 format without an offset. Example: '2020-07-15T14:30:00' timeZone: The time zone that applies to the muting rule schedule. Example: 'America/Los_Angeles'. See Wikipedia's list of tz database time zones. repeat: The frequency the muting rule schedule repeats. If it does not repeat, use null. Options are DAILY, WEEKLY, MONTHLY. endRepeat: The datetime stamp when the muting rule schedule stops repeating. This is in local ISO 8601 format without an offset. Example: '2020-07-10T15:00:00'. Note: Either endRepeat or repeatCount should be used to end a muting rule schedule. Both fields should not be provided together. repeatCount: The number of times the muting rule schedule repeats. This includes the original schedule. For example, a repeatCount of 2 will recur one time. A repeatCount of 3 will recur two times. Note: Either repeatCount or endRepeat can be used to end a muting rule schedule. Both fields should not be provided together. weeklyRepeatDays: The day(s) of the week that a muting rule should repeat when the repeat field is set to 'WEEKLY'. Example: [ 'MONDAY', 'WEDNESDAY']. How muting rules work Muting rules are applied at the end of the default alert lifecycle in order to suppress, or mute, notifications. They don't disable existing policies or conditions. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations will still be identified, even though the notifications for those violations are muted. A muting rule uses a set of conditions that match against attributes in a violation event. The muting rules tell us how to: Identify individual violations after they're created, but before an incident is opened. Override their default condition to indicate that they should be \"muted.\" Currently, muting a violation means that the normal Alerts incident lifecycle will be maintained, except that an incident that only contains muted violations will not send out any notifications. Muting rules override specific violations. They don't disable existing policies or conditions. This allows you to mute violations from specific entities that may be covered by a policy or condition that covers a large number of entities. This also keeps you from having to over-mute your monitoring when you are performing maintenance on a subset of your system. Muting behavior The following table describes how the Alerts incident lifecycle is affected by muted violations: IF AND THEN Event: Incident opens An incident opens because of a violation that is not muted An “Open incident” notification will be sent (default). An incident opens due to a violation that is muted An “Open incident” notification will not be sent (muted). Event: Violation added to an open incident A new muted violation is added to an already open incident No notification action is triggered (default). A new unmuted violation is added to an open incident An “Open incident” notification has not been sent An “Open incident” notification will be sent. A new unmuted violation is added to an open incident An “Open incident” notification has already been sent No notification action is triggered (default). Event: Incident closed An Incident is closed An “Open incident” notification has not been sent A “Close incident” notification will not be sent. An Incident is closed An “Open incident” notification has been sent A “Close incident” notification will be sent. Event: Incident acknowledged An Incident is acknowledged An “Open incident” notification has not been sent An “Incident acknowledged” notification will not be sent. An Incident is acknowledged An “Open incident” notification has been sent An “Incident acknowledged” notification will be sent. View muted violations and incidents When viewing an open or closed incident, violations and incidents are marked as Muted. The following sections show some of these muted violations and incidents, and where you can find them. An incident with a critical violation that's been muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Incidents. An incident that has been muted Violations and incidents are marked as Muted in the State column: Go to one.newrelic.com, and in the top nav click Alerts & AI, click Incidents, then click Open incidents. A list of violations, some of which are muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Events. A list of alert events, some of which are muted In the list of alert events, the State column shows which events have been muted. Go to one.newrelic.com, in the top nav click Alerts & AI, click Events, then click All events. Mute faceted results using tags. To mute results of faceted queries, use the tags.FACETED_ATTRIBUTE attribute, where FACETED_ATTRIBUTE represents the attributed you've run a NRQL FACET query on. For example: if your NRQL alert condition includes FACET host in its query, you can target that FACET attribute using tags.host. NRQL condition queries can accept multiple facet attributes. If you want to be able to filter from attributes in your events or metric time series that have been aggregated, you must add those attributes to your NRQL query FACET clause; for example: FACET host, region, cluster. For an example of using tags., see Create muting rule. Sub-condition operators The following are the logical operators available to use to compare attributes when you're constructing muting rules. For examples of these being used, see Examples. EQUALS: Where the supplied value equals the violation attribute value. NOT_EQUALS: Where the supplied value does not equal the violation attribute value. IN: Where the violation attribute value is present in a list of supplied values (up to 500). NOT_IN: Where the violation attribute value is not present in a list of supplied values (up to 500). CONTAINS: Where the supplied value string is present in the violation attribute value. NOT_CONTAINS: Where the supplied value string is not present in the violation attribute value. ANY: Caution: A condition with this operator will mute all violations on the account. IS_BLANK: Where the violation attribute value is blank. Null, empty string, etc. IS_NOT_BLANK: Where the violation attribute value is not blank. Null, empty string, etc. STARTS_WITH: Where the violation attribute value begins with the supplied value string. NOT_STARTS_WITH: Where the violation attribute value does not begin with the supplied value string. ENDS_WITH: Where the violation attribute value ends with the supplied value string. NOT_ENDS_WITH: Where the violation attribute value does not end with the supplied value string. Muting examples For more information about making requests to NerdGraph, see the NerdGraph documentation, including GraphQL tutorials. Fetch muting rules for account To fetch the list of muting rules (with name and condition) for an account: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { mutingRules { name condition { operator conditions { attribute operator values } } } } } } } Copy Create muting rule To create a muting rule and return the muting rule's id for muting violations from NRQL conditions where host facet is host-1: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 mute rule\", description: \"Mute host-1 violations\", enabled: true, condition: { operator: AND, conditions: [{ attribute: \"tags.host\", operator: EQUALS, values: [\"host-1\"] }] } }) { id } } Copy Create muting rule for specific hosts or products To create a muting rule and return the muting rule's id for muting violations from Infrastructure conditions where the target host is host-1 or the violation was from Synthetic monitoring or Mobile products: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 and Synthetics/Mobile mute rule\", description: \"Mute host-1 and Synthetics/Mobile violations\", enabled: true, condition: { operator: OR, conditions: [ { attribute: \"targetName\", operator: EQUALS, values: [\"host-1\"] }, { attribute: \"product\", operator: IN, values: [\"SYNTHETICS\", \"MOBILE\"] } ] } }) { id } } Copy Create a muting rule with a recurring schedule To create a muting rule scheduled to repeat with these criteria: Weekly on Tuesday and Friday End on 01/31/2021 Return the muting rule's schedule and id mutation { alertsMutingRuleCreate( accountId: YOUR_ACCOUNT_ID, rule: { condition: { conditions: { attribute: \"conditionName\", operator: ANY, values: \"This is a condition\" }, operator: AND }, enabled: true, name: \"Recur Weekly\", schedule: { startTime: \"2020-12-01T12:00:00\", endTime: \"2020-12-01T14:00:00\", timeZone: \"America/Los_Angeles\", repeat: WEEKLY, endRepeat: \"2021-01-31T12:00:00\", weeklyRepeatDays: [TUESDAY, FRIDAY] } } ) { id schedule { endTime startTime timeZone repeat repeatCount endRepeat weeklyRepeatDays nextStartTime nextEndTime } } } Copy Rename and disable muting rule To change the name and disable a muting rule and return its new name: mutation { alertsMutingRuleUpdate(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID, rule: { name: \"updated name\", enabled: false }) { name } } Copy Delete muting rule To delete a muting rule: mutation { alertsMutingRuleDelete(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.50339,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Muting rules: Suppress <em>notifications</em>",
        "sections": "Muting rules: Suppress <em>notifications</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " define muting rules that specifically target those elements, while letting other <em>notifications</em> through. Even when a notification is muted, <em>Alerts</em> still gathers data on those violations. Muting rules don&#x27;t interfere with the <em>alerts</em> process and are <em>applied</em> at the point right before a notification"
      },
      "id": "60440c4728ccbc9c612c60c7"
    },
    {
      "sections": [
        "Notification channels: Control where to send alerts",
        "Tip",
        "View notification channels",
        "Add or remove notification channels",
        "Instructions for specific notification channels",
        "User",
        "Email",
        "OpsGenie",
        "PagerDuty",
        "Slack",
        "VictorOps",
        "Webhook",
        "Important",
        "Caution",
        "xMatters",
        "Receive mobile push notifications",
        "Acknowledge alert notifications"
      ],
      "title": "Notification channels: Control where to send alerts",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "8600dc86e59fad5da1e4a2b4170d2b86df78ee2f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/notification-channels-control-where-send-alerts/",
      "published_at": "2021-05-28T03:30:14Z",
      "updated_at": "2021-04-21T16:00:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use alerts to set up notification channels, and attach those channels to policies. Your selected channels provide fast and consistent ways for the right personnel to be notified about incidents. For example, notifications allow you to include charts about the incident to provide context and share them with your team. Alerts offers several notification channels, including webhooks, Slack rooms, email, and more. You'll be notified by your notification channels when incidents are opened, acknowledged, or closed. This document explains the available notification channels and how to set them up. Tip This document is about alerts notifications. For general information about unsubscribing from other New Relic emails, including marketing emails, weekly reports, and announcements, see Unsubscribe from New Relic emails. View notification channels To see all notification channels in your account: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. Add or remove notification channels To set up a new notification channel: On the Notification channels, click New notification channel. Select the type of channel and complete other required steps for it. To add or remove a notification policy or channel: Select a specific notification channel, select Alert policies, and add or remove a policy. OR Select a specific policy, select Notification channels, and add or remove a channel. Instructions for specific notification channels These are the available notification channel types. User Requirement: This feature is not available for users on the New Relic One user model, only to users on the original user model (learn about user model differences). As a workaround, you can use the email notification channel. Use the User notification channel to select existing account team members and admins. To view the Users list or to add users to alert policies: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. If a user has configured the New Relic mobile app, the user notification channel also sends push notifications to any of the user's registered mobile devices. If your account has one or more sub-accounts, the notification channel includes only users for the currently selected master or sub-account. Email We automatically add every individual and their email address on the selected account to the User notification channel and you can select them there. You don't need to add existing New Relic accounts to the Email channel. To add an email channel for other users, follow these guidelines: Field Description Email (required) In general, use the Email notification channel to identify user emails or email aliases that are not already on the selected account. For example, if you have a dev-ops@company.com email alias for your DevOps team, add the email alias to the Email channel. Otherwise, use the User notification channel to select specific users on your DevOps team. For easier maintenance, add a single non-user email address or alias to a single alert notification channel. If you want to use the email channel for more than one email, create an email group or alias outside your account. These email addresses can be the same as or different from email addresses already on your account. Users can unsubscribe from general (non-alerts-related) emails, but they cannot unsubscribe from alerts email notifications. Instead, the account Owner, Admin, or add-on manager must remove users from the policy's email notification channel. Include JSON attachment (optional) To include a JSON attachment with the email notification, select this checkbox. OpsGenie You must have an existing OpsGenie account integrated with New Relic in order to provide the following information: Field Description Channel name (required) A meaningful name for the OpsGenie notification channel (maximum 64 characters). API key (required) The API key generated from your OpsGenie integration used to authenticate API requests. Teams (optional) List of team names that are responsible for the alert. OpsGenie runs team escalation policies to calculate which users will receive notifications. Tags (optional) A comma-separated list of labels attached to the alert. Tip To overwrite the OpsGenie Quiet Hours setting for urgent alerts, add an OverwriteQuietHours tag. Recipients (optional) One or more names of users, groups, on-call schedules, escalation policies, etc., that OpsGenie uses to calculate where to send notifications. PagerDuty You must have an existing PagerDuty account in order to provide the following information: Field Description Service name (required) The name of your service integrating with PagerDuty for notifications. Integration key (required) The unique service identifier used by PagerDuty's Integration API to trigger, acknowledge, and resolve incidents for the service. Slack Before adding Slack notifications, you must create a unique webhook integration using Slack's New Relic integration. If you want web, transaction, server, and mobile alerts to be posted in separate channels, you must set up separate integrations for each one. Field Description Channel name (required) A meaningful name for the Slack notification channel (maximum 64 characters); for example, Network Ops Center. URL (required) Copy and paste the New Relic webhook integration URL that you've set up with Slack. For example: https://hooks.slack.com/services/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 Be sure to include https:// in the URL. Do not use http://. Team channel (optional) If used, include # before the name of the Slack channel where alert notifications are sent; for example, #NOC. VictorOps You must have an existing VictorOps account in order to provide the following required information: Field Description Channel name (required) A meaningful name for this notification channel (maximum 64 characters). For example, if the VictorOps Route key is for your Technical Support team, you could name this channel Tech Support - VictorOps. Key (required) VictorOps generates a unique key for each account. It maps the VictorOps account to its associated integrations. Route key (optional) This key maps the alert or incident to a specific team. Webhook Webhooks are HTTP POST messages containing JSON documents delivered to a destination URL. When an incident is opened, acknowledged, or closed, our webhook feature sends a message to your URL with any relevant information, such as a description of the event and a link back to New Relic. You also have the option to customize the payload in the POST message for further integration into your system. Important If your endpoint does not acknowledge the POST request within 10 seconds, the Alerts UI may indicate a failed notification event for the related incident. Before adding webhook notifications, you must have an endpoint set up to respond with a status code between 200 and 206 after receiving the following required information: Field Description Channel name (required) A meaningful name for the webhook (maximum 64 characters). Base url (required) The endpoint that will receive the POST message and trigger customized behaviors in your system. Caution If you want to include a port number in the webhook URL, make sure the port is available for requests. Otherwise the webhook will not work. Basic auth (optional) To require basic authentication for the webhook, select Add basic auth, and provide the user name and password to authenticate the webhook. Custom headers (optional) To include headers with webhooks, select Add custom headers, and provide the name and value for each header. Use custom payload (optional) To use the default values, leave blank. To view and edit the default values, select Add custom payload. Payload (for custom payloads only) Your customized POST message code. This field includes: A list of variables you can use Syntax highlighting, based on payload type Payload type (for custom payloads only) Specify the message format: JSON (default) or Form. xMatters You must have an existing xMatters account in order to provide the following information: Field Description Channel name (required) Name your channel so you can identify it easily when associating it with a policy. Integration url (required) The unique integration url provided by xMatters pointing to your xMatters account. Receive mobile push notifications Important In order to receive mobile push notifications, your device must be registered and listed in (account) > User preferences. If the device is not listed in User preferences, log out of the app, log back in, and check again to see if it is listed. To receive mobile push notifications: Log in to your New Relic account via the mobile app at least once to ensure the device is registered. Add the user channel to the alert policy. Switch push notifications On for the device. Acknowledge alert notifications Anyone in your account can acknowledge notifications through the user interface or email notification. Acknowledging an incident in New Relic also acknowledges any associated incident in PagerDuty.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 177.6083,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Notification</em> channels: Control where to send <em>alerts</em>",
        "sections": "<em>Notification</em> channels: Control where to send <em>alerts</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " them up. Tip This document is about <em>alerts</em> <em>notifications</em>. For general information about unsubscribing from other <em>New</em> <em>Relic</em> emails, including marketing emails, weekly reports, and announcements, see Unsubscribe from <em>New</em> <em>Relic</em> emails. View notification channels To see all notification channels in your"
      },
      "id": "603ecfbf64441f4ee54e885f"
    },
    {
      "sections": [
        "Incident Intelligence destination examples",
        "Destination template examples",
        "Suggested OpsGenie template example",
        "Suggested ServiceNow template example",
        "Suggested Slack template example",
        "Suggested VictorOps template example",
        "Webhook and JSON format examples",
        "Webhook format and JSON example",
        "Jinja2 Default Payload",
        "Jinja2 Useful Syntax",
        "JSON schema",
        "JSON schema template"
      ],
      "title": "Incident Intelligence destination examples",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "a516d04f8b75541a6dc9338fa3ce9645ba87d620",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/incident-intelligence-destination-examples/",
      "published_at": "2021-06-02T18:22:22Z",
      "updated_at": "2021-06-02T18:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Destinations are the data outputs to Applied Intelligence, where you can view your automatically correlated incidents. You can configure Incident Intelligence destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema. Destination template examples The following template example destinations are formatted in Jinja2. Suggested OpsGenie template example { \"alias\": {{ id }}, \"message\": {{ ui_name }}, \"source\": '{{ sources }}', \"priority\": {{ priority }}, \"details\": { \"self_url\": {{ url }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"is_correlated\": {{ is_correlated }} }, \"description\": \"\"\"Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]\"\"\" } Copy Suggested ServiceNow template example { \"short_description\": {{ ui_name }}, \"description\": 'Issue Id: {{ id }}, \\n Description: {{ description }}, \\n Sources: {{ sources }}, \\n Priority: {{ priority }}, \\n Details: { \\n self_url: {{ url }}, \\n state: {{ state }}, \\n is_correlated: {{ is_correlated }}, \\n created_on: {{ created_on }}, \\n modified_on: {{ modified_on }}, \\n activated_on: {{ active_since }}, \\n closed_on: {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \\n is_correlated: {{is_correlated}} }, \\n\\n incidents: {{ incidents }}, \\n\\n pathways: {{ pathways }}' } Copy Suggested Slack template example Go to Slack incoming WebHooks Choose the right Slack workspace and click \"Add to Slack\" Select the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In New Relic Applied Intelligence, under Incident Intelligence click Destinations Add a WebHook In the end point paste the WebHook url from slack. In the custom payload, paste the following JSON: { \"blocks\": [ { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*New Relic Incident Intelligence Alert*\" } }, { \"type\": \"divider\" }, { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*CUSTOM FIELDS*:\" }, \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue ID*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Issue Title*\" }, { \"type\": \"plain_text\", \"text\": {{ id }} }, { \"type\": \"plain_text\", \"text\": {{ ui_name }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue URL*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Description*\" }, { \"type\": \"mrkdwn\", \"text\": {{ url }} }, { \"type\": \"plain_text\", \"text\": {{ description }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*State*\" }, { \"type\": \"mrkdwn\", \"text\": \"*is_correlated*\" }, { \"type\": \"plain_text\", \"text\": {{ state }} }, { \"type\": \"plain_text\", \"text\": \"{{ is_correlated }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Created On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Modified On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ created_on }}\" }, { \"type\": \"plain_text\", \"text\": \"{{ modified_on }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Activated On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Closed On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ active_since }}\" }, { \"type\": \"plain_text\", \"text\": \"{% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Aggregated Incidents*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Monitoring Tool*\" }, { \"type\": \"plain_text\", \"text\": \"{{ incident_count }}\" }, { \"type\": \"plain_text\", \"text\": {{ sources|join(', ') }} } ] } ] } Copy Suggested VictorOps template example { \"monitoring_tool\": {{ sources }}, {% if state == 'closed' %} \"message_type\": \"OK\", {% else %} \"message_type\": {{ priority }}, {% endif %} \"custom_fields\": { \"issue_url\": {{ url }}, \"description\": {{ description }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"related_incidents\": [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %} {% endfor %} ] }, \"state_message\": {{ description }}, \"entity_id\": {{ id }}, \"entity_display_name\": {{ ui_name }}, \"vo_annotate.u.NRAI_Link\": {{ url }} } Copy Webhook and JSON format examples Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). If you use webhooks to configure Incident Intelligence destinations, use these examples of the webhook body format and JSON schema. Webhook format and JSON example Webhook format: Name Description url Href A link to the UI where the issue can be seen. id String Unique identifier for the issue. title String The issue title. description String The description of the issue. priority Enum The issue priority. Can be Critical, High, Medium, or Low. state Enum The issue status. Can be Active, Closed, or Acknowledged. is_correlated Boolean True if the issue is based on correlated data. created_on String The date and time the issue was created (in ISO format). modified_on String The date and time the issue was modified (in ISO format). active_since String The date and time the issue was activated (in ISO format). closed_on String The date and time the issue was closed (in ISO format). sources List(String) List of the different sources that were used to send the events into Applied Intelligence (for example: PagerDuty). pathways List(Pathways) List of pathways that are associated with the issue. Each pathway contains an id and name: [{“id”: “pathway id”, “name”: “pathway name”}]. pathways[].id String The pathway ID. pathways[].name String The pathway name. incidents List(Incident) List of incidents that are attached to the issue. The list contains only the latest 100 incidents. incidents[].id String The incident ID. incidents[].events_count Integer The number of events used to create the incident. incidents[].title String The incident title. incidents[].description String The incident description. incidents[].labels Dictionary (String) A string to string mapping of the incident labels. Labels represent the unique entities that are used to describe the incident. incidents[].priority Enum The incident priority. Can be Critical, High, Medium, or Low. incidents[].sources List(String) The incident source. incidents[].state Enum(open, closed) The incident state. incidents[].opened_on String The date and time the incident was opened (in ISO format). incidents[].closed_on String The date and time the incident was closed (in ISO format). ui_name String Issue title. accumulations['alert/signal'] String Issue analysis summary golden signal/s (if applicable). accumulations['alert/components'] String Issue analysis summary golden components (if applicable). Jinja2 Default Payload Applied Intelligence uses a templating framework called Jinja2 in the Webhook interface. Here is a default Jinja2 payload to use: { \"id\": {{ id }}, \"url\": {{ url }}, \"ui_name\": {{ ui_name }}, \"description\": {{ description }}, \"priority\": {{ priority }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"active_since\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"sources\": {{ sources }}, \"incidents\": {{ incidents }}, \"pathways\": {{ pathways }}, } Copy Jinja2 Useful Syntax Below are a few useful Jinja2 commands to help you format your output. Casting a value to integer Example: “severity”: {{ priority | int }} Copy If clause to check if an attribute’s value is set Example: \"golden_signals\": {% if accumulations['alert/signal'] is defined %} {{ accumulations['alert/signal'] }} {% else %} None {% endif %} Copy For loop to iterate of an array of values: Example: \"description\": 'Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]' Copy Check if an array attribute's value is set: Example: \"hostname_field\": {% if incidents[0].labels['newrelic/tag/hostname'] is defined %} {{ incidents[0].labels['newrelic/tag/hostname'] }} {% else %} None {% endif %} Copy JSON schema Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). JSON schema template JSON schema: { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"definitions\": { \"Labels\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"LabelsSet\": { \"type\": \"array\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"$ref\": \"#/definitions/Labels\" }, \"uniqueItems\": true }, }, \"Annotations\": { \"type\": \"object\", \"title\": \"Additional contextual information about the Entity\", \"description\": \"Fields like title, description and priority can be described as annotations since\\nthey represent some additional information about the Incident.\\nFor example, the rule that creates the entity can have some logic that will create a title annotation field.\\nThe title will change according to the latest event received by the entity and as more\\nevent will keep coming the field may change, all this as a decision by the rule.\\nA different rule may decide not to populate the title at all.\\nSince a title can also be produced from the labels themselves.\", \"properties\": { \"title\": { \"type\": \"string\", \"maxLength\": 10000 }, \"description\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"patternProperties\": { \".*\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"Accumulations\": { \"type\": \"object\", \"title\": \"Accumulated data about the Incident\", \"description\": \"For example an entity with the label: host_name: foo will include a accumulated list of the\\nrelevant process names that are relevant to the entity. Accumulations will be derived from the events\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"type\": \"string\", \"maxLength\": 10000 } } }, \"IssueState\": { \"type\": \"string\", \"enum\": [ \"created\", \"active\", \"acknowledged\", \"closed\" ], \"properties\": {}, \"additionalProperties\": false }, \"Priority\": { \"type\": \"string\", \"enum\": [ \"critical\", \"high\", \"medium\", \"low\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueClosingReason\": { \"type\": \"string\", \"enum\": [ \"nacked\", \"resolved\", \"system\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueAction\": { \"type\": \"string\", \"enum\": [ \"ack\", \"snooze\", \"nack\", \"end_snooze\", \"expire_snooze\", \"star\", \"un_snooze\", \"unstar\", \"archive\", \"unarchive\", \"resolve\", \"reopen\", \"open\", \"feedback\", \"feedback_file\", \"open_ticket\", \"merge_issues\", \"active\", \"create\", \"close\", \"incident_updated\", \"confidence_changed\", \"diagnoses_changed\", \"rule_properties_changed\", \"flapping\", \"notification\", \"incident_events_limit_reached\", \"follow\", \"unfollow\", \"priority_updated\", \"comment\", \"incident_appended\", \"diagnosis_feedback\", \"flapping_delay_close\" ], \"properties\": {}, \"additionalProperties\": false }, \"StringKeyValue\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\" } }, \"JavaOptionalUuid\": { \"type\": \"string\", \"properties\": {}, \"additionalProperties\": false, \"format\": \"string-uuid\" } }, \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"customer_id\": { \"type\": \"integer\" }, \"labels_set\": { \"$ref\": \"#/definitions/LabelsSet\" }, \"annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations_version\": { \"type\": \"integer\" }, \"accumulations\": { \"$ref\": \"#/definitions/Accumulations\" }, \"state\": { \"$ref\": \"#/definitions/IssueState\" }, \"previous_state\": { \"$ref\": \"#/definitions/IssueState\" }, \"priority\": { \"$ref\": \"#/definitions/Priority\" }, \"closing_reason\": { \"oneOf\": [ { \"$ref\": \"#/definitions/IssueClosingReason\" }, { \"type\": \"null\" } ] }, \"modified_on\": { \"type\": \"integer\" }, \"created_on\": { \"type\": \"integer\" }, \"closed_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"acknowledged_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"active_since\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"assigned_to\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"created_by\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"progress_report\": { \"type\": \"array\", \"default\": [], \"items\": { \"type\": \"object\", \"properties\": { \"origin_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1 }, { \"type\": \"null\" } ] }, \"timestamp\": { \"type\": \"integer\" }, \"action_timestamp\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"origin_type\": { \"type\": \"string\", \"enum\": [ \"user\", \"system\" ] }, \"event_type\": { \"$ref\": \"#/definitions/IssueAction\" }, \"issue_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"format\": \"string-uuid\" }, { \"type\": \"null\" } ] }, \"attributes\": { \"oneOf\": [ { \"$ref\": \"#/definitions/StringKeyValue\" }, { \"type\": \"null\" } ] }, \"team_id\": { \"$ref\": \"#/definitions/JavaOptionalUuid\" } }, \"required\": [ \"timestamp\", \"origin_type\", \"event_type\" ], \"additionalProperties\": false }, \"uniqueItems\": true }, \"rule_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"maxLength\": 255 }, { \"type\": \"null\" } ] }, \"incident_ids\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"confidence\": { \"type\": \"number\", \"default\": 1.0, \"minimum\": 0.0, \"maximum\": 1.0 } }, \"required\": [ \"id\", \"customer_id\", \"labels_set\", \"annotations\", \"priority\", \"modified_on\", \"created_on\", \"confidence\" ], \"additionalProperties\": true } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.20981,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Incident <em>Intelligence</em> destination examples",
        "sections": "Incident <em>Intelligence</em> destination examples",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " the destination channel to receive the <em>notifications</em> to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In <em>New</em> <em>Relic</em> <em>Applied</em> <em>Intelligence</em>, under Incident <em>Intelligence</em> click Destinations Add a WebHook In the end point paste the WebHook url"
      },
      "id": "6044280d64441f4af5378ed3"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/delete-alert-notification-channels": [
    {
      "sections": [
        "Muting rules: Suppress notifications",
        "Manage muting rules",
        "Create a muting rule",
        "Tip",
        "Schedule a muting rule",
        "Manage muting rules with NerdGraph",
        "How muting rules work",
        "Muting behavior",
        "View muted violations and incidents",
        "An incident with a critical violation that's been muted",
        "An incident that has been muted",
        "A list of violations, some of which are muted",
        "A list of alert events, some of which are muted",
        "Mute faceted results using tags.",
        "Sub-condition operators",
        "Muting examples",
        "Fetch muting rules for account",
        "Create muting rule",
        "Create muting rule for specific hosts or products",
        "Create a muting rule with a recurring schedule",
        "Rename and disable muting rule",
        "Delete muting rule"
      ],
      "title": "Muting rules: Suppress notifications",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "07d71869062b00bb820e52cf89fcb6a06ce523a4",
      "image": "https://docs.newrelic.com/static/595b1c9a595bf6a5c9175f5052298e88/03914/manage_muting_rules.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/muting-rules-suppress-notifications/",
      "published_at": "2021-05-27T19:23:09Z",
      "updated_at": "2021-05-16T09:31:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts sends out timely notifications when your system is having problems. Sometimes there are notifications you know you don't need to see. You can use muting rules to stop being bombarded by messages you don't want. Once you've spotted the common elements in your unwanted notifications, you can define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, Alerts still gathers data on those violations. Muting rules don't interfere with the alerts process and are applied at the point right before a notification is sent. You can read more about why we added muting rules in this blog post. Manage muting rules A muting rule condition is the set of individual expressions made up of attributes, operators, and values that define which violations to target for muting. You can create, enable, disable, and manage muting rules. Go to one.newrelic.com, in the top nav, click Alerts & AI, and then click Muting rules. Enable or disable muting rules at any time. Rules can have one of the following statuses: Active: Muting is enabled and active. Scheduled: Muting is enabled but not active yet (there's a future schedule). Ended: Muting is enabled, but no longer active (there's no future schedule). Inactive: Muting is disabled. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Create a muting rule Tip Before creating muting rules, you'll need to create policies and conditions that generate violation notifications. To create a muting rule, click + Add a rule in the Muting rules screen. Enter a name and a description for the muting rule, and select the account to which the rule will apply. Next, build the violation filter. You can use violation event attributes and sub-condition operators. Values can be compared against one of your violation attributes, such as an Alerts policy ID or a condition name. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Schedule a muting rule If needed, you can schedule your muting rules. To do this, select a start time and/or end time. Optionally, you can set the muting rule to last an entire day. You can also choose to select a time zone for the muting rule schedule. The default is the time zone selected in your user preferences. Flexible and powerful options for scheduling your muting rules. You can schedule your muting rules to recur daily, weekly, or monthly. A muting rule that's scheduled to repeat weekly includes the option to select the days of the week to recur. If no days are selected, the weekly recurrence will default to repeating on the day of the week that the muting rule is scheduled to start. You can also specify when you would like recurrence to end by selecting either a specific date or a certain number of occurrences. Manage muting rules with NerdGraph In NerdGraph, you can use the following queries and mutations with your muting rules. You can see the schema in more detail in the API Explorer. actor.account.alerts.mutingRule: Fetch a muting rule by id. actor.account.alerts.mutingRules: Fetch a list of muting rules for an account. alertsMutingRuleCreate: Create a muting rule for an account. alertsMutingRuleUpdate: Update a muting rule by id and account id. alertsMutingRuleDelete: Delete a muting rule by id and account id. We've given you some sample queries and mutations examples in this document. A muting rule has the following fields and components: Muting rule Fields and components id The unique identifier for the muting rule. name (Required) A text field for the user-friendly name of the muting rule. This is used when listing or referencing a rule. We don't require that the name be unique, but it is recommended. description This is an optional text field describing the muting rule. It can be a useful way to provide more context for your muting rule. This data is only used for management display purposes. accountId The muting rule's account ID. A muting rule will only affect violations that occur in a single account. To mute violations across multiple accounts, you'll need to create a muting rule for each account separately. createdAt The timestamp when the muting rule was created (UTC). createdBy The user ID of the person who created the muting rule. updatedAt The timestamp when the muting rule was last modified (UTC). updatedBy The user ID of the person who last modified the muting rule. enabled Enable or disable the muting rule (Boolean). Muting rules must be manually enabled and disabled. condition The set of individual expressions that define which violations to target. A muting rule condition has: operator: The boolean operator AND or OR that defines how to combine the set of conditions. conditions: The set of individual expressions (sub-conditions) that target attributes within a violation. These are evaluated together based on the operator. You can have a maximum of 20 sub-conditions for a single muting rule. A sub-condition has: attribute: A single attribute within a violation. Go here for a list of Violation event attributes. operator: The comparison function used to compare the selected violation attribute against values in the condition. Go here for a list of sub-condition operators. values: An array of string values to compare against selected violation attributes. When the muting rules evaluate a condition, if necessary, values will be coerced from strings. You can use a maximum of 500 values when using an operator that supports comparison against multiple values, such as IN. schedule The time window when the MutingRule actively mutes violations. startTime: The datetime stamp that represents when the muting rule starts. This is in local ISO 8601 format without an offset. Example: '2020-07-08T14:30:00' endTime: The datetime stamp that represents when the muting rule ends. This is in local ISO 8601 format without an offset. Example: '2020-07-15T14:30:00' timeZone: The time zone that applies to the muting rule schedule. Example: 'America/Los_Angeles'. See Wikipedia's list of tz database time zones. repeat: The frequency the muting rule schedule repeats. If it does not repeat, use null. Options are DAILY, WEEKLY, MONTHLY. endRepeat: The datetime stamp when the muting rule schedule stops repeating. This is in local ISO 8601 format without an offset. Example: '2020-07-10T15:00:00'. Note: Either endRepeat or repeatCount should be used to end a muting rule schedule. Both fields should not be provided together. repeatCount: The number of times the muting rule schedule repeats. This includes the original schedule. For example, a repeatCount of 2 will recur one time. A repeatCount of 3 will recur two times. Note: Either repeatCount or endRepeat can be used to end a muting rule schedule. Both fields should not be provided together. weeklyRepeatDays: The day(s) of the week that a muting rule should repeat when the repeat field is set to 'WEEKLY'. Example: [ 'MONDAY', 'WEDNESDAY']. How muting rules work Muting rules are applied at the end of the default alert lifecycle in order to suppress, or mute, notifications. They don't disable existing policies or conditions. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations will still be identified, even though the notifications for those violations are muted. A muting rule uses a set of conditions that match against attributes in a violation event. The muting rules tell us how to: Identify individual violations after they're created, but before an incident is opened. Override their default condition to indicate that they should be \"muted.\" Currently, muting a violation means that the normal Alerts incident lifecycle will be maintained, except that an incident that only contains muted violations will not send out any notifications. Muting rules override specific violations. They don't disable existing policies or conditions. This allows you to mute violations from specific entities that may be covered by a policy or condition that covers a large number of entities. This also keeps you from having to over-mute your monitoring when you are performing maintenance on a subset of your system. Muting behavior The following table describes how the Alerts incident lifecycle is affected by muted violations: IF AND THEN Event: Incident opens An incident opens because of a violation that is not muted An “Open incident” notification will be sent (default). An incident opens due to a violation that is muted An “Open incident” notification will not be sent (muted). Event: Violation added to an open incident A new muted violation is added to an already open incident No notification action is triggered (default). A new unmuted violation is added to an open incident An “Open incident” notification has not been sent An “Open incident” notification will be sent. A new unmuted violation is added to an open incident An “Open incident” notification has already been sent No notification action is triggered (default). Event: Incident closed An Incident is closed An “Open incident” notification has not been sent A “Close incident” notification will not be sent. An Incident is closed An “Open incident” notification has been sent A “Close incident” notification will be sent. Event: Incident acknowledged An Incident is acknowledged An “Open incident” notification has not been sent An “Incident acknowledged” notification will not be sent. An Incident is acknowledged An “Open incident” notification has been sent An “Incident acknowledged” notification will be sent. View muted violations and incidents When viewing an open or closed incident, violations and incidents are marked as Muted. The following sections show some of these muted violations and incidents, and where you can find them. An incident with a critical violation that's been muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Incidents. An incident that has been muted Violations and incidents are marked as Muted in the State column: Go to one.newrelic.com, and in the top nav click Alerts & AI, click Incidents, then click Open incidents. A list of violations, some of which are muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Events. A list of alert events, some of which are muted In the list of alert events, the State column shows which events have been muted. Go to one.newrelic.com, in the top nav click Alerts & AI, click Events, then click All events. Mute faceted results using tags. To mute results of faceted queries, use the tags.FACETED_ATTRIBUTE attribute, where FACETED_ATTRIBUTE represents the attributed you've run a NRQL FACET query on. For example: if your NRQL alert condition includes FACET host in its query, you can target that FACET attribute using tags.host. NRQL condition queries can accept multiple facet attributes. If you want to be able to filter from attributes in your events or metric time series that have been aggregated, you must add those attributes to your NRQL query FACET clause; for example: FACET host, region, cluster. For an example of using tags., see Create muting rule. Sub-condition operators The following are the logical operators available to use to compare attributes when you're constructing muting rules. For examples of these being used, see Examples. EQUALS: Where the supplied value equals the violation attribute value. NOT_EQUALS: Where the supplied value does not equal the violation attribute value. IN: Where the violation attribute value is present in a list of supplied values (up to 500). NOT_IN: Where the violation attribute value is not present in a list of supplied values (up to 500). CONTAINS: Where the supplied value string is present in the violation attribute value. NOT_CONTAINS: Where the supplied value string is not present in the violation attribute value. ANY: Caution: A condition with this operator will mute all violations on the account. IS_BLANK: Where the violation attribute value is blank. Null, empty string, etc. IS_NOT_BLANK: Where the violation attribute value is not blank. Null, empty string, etc. STARTS_WITH: Where the violation attribute value begins with the supplied value string. NOT_STARTS_WITH: Where the violation attribute value does not begin with the supplied value string. ENDS_WITH: Where the violation attribute value ends with the supplied value string. NOT_ENDS_WITH: Where the violation attribute value does not end with the supplied value string. Muting examples For more information about making requests to NerdGraph, see the NerdGraph documentation, including GraphQL tutorials. Fetch muting rules for account To fetch the list of muting rules (with name and condition) for an account: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { mutingRules { name condition { operator conditions { attribute operator values } } } } } } } Copy Create muting rule To create a muting rule and return the muting rule's id for muting violations from NRQL conditions where host facet is host-1: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 mute rule\", description: \"Mute host-1 violations\", enabled: true, condition: { operator: AND, conditions: [{ attribute: \"tags.host\", operator: EQUALS, values: [\"host-1\"] }] } }) { id } } Copy Create muting rule for specific hosts or products To create a muting rule and return the muting rule's id for muting violations from Infrastructure conditions where the target host is host-1 or the violation was from Synthetic monitoring or Mobile products: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 and Synthetics/Mobile mute rule\", description: \"Mute host-1 and Synthetics/Mobile violations\", enabled: true, condition: { operator: OR, conditions: [ { attribute: \"targetName\", operator: EQUALS, values: [\"host-1\"] }, { attribute: \"product\", operator: IN, values: [\"SYNTHETICS\", \"MOBILE\"] } ] } }) { id } } Copy Create a muting rule with a recurring schedule To create a muting rule scheduled to repeat with these criteria: Weekly on Tuesday and Friday End on 01/31/2021 Return the muting rule's schedule and id mutation { alertsMutingRuleCreate( accountId: YOUR_ACCOUNT_ID, rule: { condition: { conditions: { attribute: \"conditionName\", operator: ANY, values: \"This is a condition\" }, operator: AND }, enabled: true, name: \"Recur Weekly\", schedule: { startTime: \"2020-12-01T12:00:00\", endTime: \"2020-12-01T14:00:00\", timeZone: \"America/Los_Angeles\", repeat: WEEKLY, endRepeat: \"2021-01-31T12:00:00\", weeklyRepeatDays: [TUESDAY, FRIDAY] } } ) { id schedule { endTime startTime timeZone repeat repeatCount endRepeat weeklyRepeatDays nextStartTime nextEndTime } } } Copy Rename and disable muting rule To change the name and disable a muting rule and return its new name: mutation { alertsMutingRuleUpdate(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID, rule: { name: \"updated name\", enabled: false }) { name } } Copy Delete muting rule To delete a muting rule: mutation { alertsMutingRuleDelete(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.50339,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Muting rules: Suppress <em>notifications</em>",
        "sections": "Muting rules: Suppress <em>notifications</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " define muting rules that specifically target those elements, while letting other <em>notifications</em> through. Even when a notification is muted, <em>Alerts</em> still gathers data on those violations. Muting rules don&#x27;t interfere with the <em>alerts</em> process and are <em>applied</em> at the point right before a notification"
      },
      "id": "60440c4728ccbc9c612c60c7"
    },
    {
      "sections": [
        "Customize your webhook payload",
        "Define webhooks",
        "Webhook values",
        "Targets values",
        "Webhook format example",
        "JSON webhook example",
        "Important",
        "Form webhook example",
        "Plain text output",
        "Microsoft Teams example"
      ],
      "title": "Customize your webhook payload",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "26f483edd4fd0bf049a3d3e6c5885788dcdfdd46",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/customize-your-webhook-payload/",
      "published_at": "2021-06-02T20:58:08Z",
      "updated_at": "2021-05-16T08:48:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use webhooks as your alerts notification channel, you can use the default values. You can also customize the payload in the POST message for further integration into your system. Define webhooks When defining JSON webhooks, use the format \"name\":\"value\",. For example: \"current_state\":\"acknowledged\", Copy When defining static webhook variables in a form payload, use the format name=\"value\". For example: current_state=\"acknowledged\" Copy Do not include any custom, self-signed SSL certificates in your webhook. Our agents enable SSL by default. Due to our security policy, custom SSL certificates will not be imported into our Trust store. Webhook values We support these default dynamic webhook values. For your convenience, they are listed in alphabetical order, but you can define your webhook values in any order. You may also add custom variables by using your own key/value pairs. Key Variable \"account_id\" $ACCOUNT_ID Possible values: New Relic account ID (string) \"account_name\" $ACCOUNT_NAME Possible values: New Relic account name (string) \"closed_violations_count_critical\" $CLOSED_VIOLATIONS_COUNT_CRITICAL \"closed_violations_count_warning\" $CLOSED_VIOLATIONS_COUNT_WARNING \"condition_id\" $CONDITION_ID \"condition_description\" $DESCRIPTION This includes the description field from the alert condition, if there is one. \"condition_name\" $CONDITION_NAME Possible values: (user-defined string) \"current_state\" $EVENT_STATE Possible values: [open|acknowledged|closed] \"details\" $EVENT_DETAILS \"duration\" $DURATION \"event_type\" $EVENT_TYPE Possible values: [INCIDENT] \"incident_acknowledge_url\" $INCIDENT_ACKNOWLEDGE_URL \"incident_id\" $INCIDENT_ID \"incident_url\" $INCIDENT_URL \"metadata\" $METADATA Currently used only for Synthetic monitoring multi-location failure conditions. \"open_violations_count_critical\" $OPEN_VIOLATIONS_COUNT_CRITICAL \"open_violations_count_warning\" $OPEN_VIOLATIONS_COUNT_WARNING \"owner\" $EVENT_OWNER \"policy_name\" $POLICY_NAME Possible values: (user-defined string) \"policy_url\" $POLICY_URL \"runbook_url\" $RUNBOOK_URL \"severity\" $SEVERITY Possible values: [CRITICAL] \"targets\" $TARGETS The $TARGETS variable cannot be used with FORM data, but is compatible with JSON data. For static NRQL faceted alerts, the name of the facet that triggered the alert will be populated in the target’s name field. For a description of the available fields, see Target values. \"timestamp\" $TIMESTAMP \"timestamp_utc_string\" $TIMESTAMP_UTC_STRING A human-readable timestamp in the YYYY-MM-DD, HH:MM UTC format. \"version\" $VERSION \"violation_callback_url\" $VIOLATION_CALLBACK_URL \"violation_chart_url\" $VIOLATION_CHART_URL Targets values This section describes the $TARGETS field in your webhook. This data is not customizable and is provided here for reference. Your $TARGETS contain a list of zero or more targets (entities). Each target is described by a JSON object with the following fields. Key Variable \"id\" ID of the target or entity \"name\" Name of the target or entity \"labels\" Combined entity tags and NRQL facets that are derived from the condition evaluation and available entity tags. \"link\" URL link to this target or entity. \"product\" Type of product for this target or entity; for example, APM \"type\" Type of target or entity under product; for example, Application Webhook format example The following examples show a webhook payload using both the default dynamic variables and a custom variable. You can use some or all of the dynamic variables, along with any custom variables, to define your own payload. JSON webhook example Important The following webhook example has extra spaces and line breaks for readability. Actual webhook responses are delivered as one continuous line of text. The \"team\": \"DevOps\" line is an example of a custom variable. { \"account_id\": \"$ACCOUNT_ID\", \"account_name\": \"$ACCOUNT_NAME\", \"closed_violations_count_critical\": \"$CLOSED_VIOLATIONS_COUNT_CRITICAL\", \"closed_violations_count_warning\": \"$CLOSED_VIOLATIONS_COUNT_WARNING\", \"condition_family_id\": \"$CONDITION_FAMILY_ID\", \"condition_id\": \"$CONDITION_ID\", \"condition_name\": \"$CONDITION_NAME\", \"current_state\": \"$EVENT_STATE\", \"details\": \"$EVENT_DETAILS\", \"duration\": \"$DURATION\", \"event_type\": \"$EVENT_TYPE\", \"incident_acknowledge_url\": \"$INCIDENT_ACKNOWLEDGE_URL\", \"incident_id\": \"$INCIDENT_ID\", \"incident_url\": \"$INCIDENT_URL\", \"open_violations_count_critical\": \"$OPEN_VIOLATIONS_COUNT_CRITICAL\", \"open_violations_count_warning\": \"$OPEN_VIOLATIONS_COUNT_WARNING\", \"owner\": \"$EVENT_OWNER\", \"policy_name\": \"$POLICY_NAME\", \"policy_url\": \"$POLICY_URL\", \"runbook_url\": \"$RUNBOOK_URL\", \"severity\": \"$SEVERITY\", \"targets\": \"$TARGETS\", \"timestamp\": \"$TIMESTAMP\", \"timestamp_utc_string\": \"$TIMESTAMP_UTC_STRING\", \"violation_callback_url\": \"$VIOLATION_CALLBACK_URL\", \"violation_chart_url\": \"$VIOLATION_CHART_URL\", \"team\": \"DevOps\" } Copy Form webhook example Important The following webhook example has extra spaces and line breaks for readability. Actual webhook responses are delivered as one continuous line of text. account_id=$ACCOUNT_ID account_name=$ACCOUNT_NAME closed_violations_count_critical=$CLOSED_VIOLATIONS_COUNT_CRITICAL closed_violations_count_warning=$CLOSED_VIOLATIONS_COUNT_WARNING condition_family_id=$CONDITION_FAMILY_ID condition_id=$CONDITION_ID condition_name=$CONDITION_NAME current_state=$EVENT_STATE details=$EVENT_DETAILS duration=$DURATION event_type=$EVENT_TYPE incident_acknowledge_url=$INCIDENT_ACKNOWLEDGE_URL incident_id=$INCIDENT_ID incident_url=$INCIDENT_URL open_violations_count_critical=$OPEN_VIOLATIONS_COUNT_CRITICAL open_violations_count_warning=$OPEN_VIOLATIONS_COUNT_WARNING owner=$EVENT_OWNER policy_name=$POLICY_NAME policy_url=$POLICY_URL runbook_url=$RUNBOOK_URL severity=$SEVERITY timestamp=$TIMESTAMP timestamp_utc_string=$TIMESTAMP_UTC_STRING violation_callback_url=$VIOLATION_CALLBACK_URL violation_chart_url=$VIOLATION_CHART_URL team=\"DevOps\" <--[example of custom variable] Copy Plain text output New Relic Alert Incident open: CPU > 50% for 5 minutes Policy: http://alerts.newrelic.com/accounts/1234/policies/5678 Chart URL: http://gorgon.nr-assets.net/image/12345678-abcd-efgh-ijkl-1234567890 For more details, see: http://alerts.newrelic.com/accounts/1234/incidents/3456 Copy Microsoft Teams example { \"@type\": \"MessageCard\", \"@context\": \"http://schema.org/extensions\", \"themeColor\": \"0076D7\", \"summary\": \"$CONDITION_NAME\", \"sections\": [{ \"activityTitle\": \"$CONDITION_NAME\", \"activitySubtitle\": \"$POLICY_NAME\", \"activityImage\": \"https://newrelic.com/themes/custom/curio/assets/mediakit/NR_logo_Horizontal_Rev.png\", \"facts\": [{ \"name\": \"Timestamp\", \"value\": \"$TIMESTAMP_UTC_STRING\" }, { \"name\": \"Account ID\", \"value\": \"$ACCOUNT_ID\" }, { \"name\": \"Account Name\", \"value\": \"$ACCOUNT_NAME\" }, { \"name\": \"Severity\", \"value\": \"$SEVERITY\" }, { \"name\": \"State\", \"value\": \"$EVENT_STATE\" }, { \"name\": \"Duration\", \"value\": \"$DURATION\" }, { \"name\": \"Details\", \"value\": \"$EVENT_DETAILS\" }], \"markdown\": true }, { \"text\": \"$METADATA<p><img src=\\\"$VIOLATION_CHART_URL\\\" alt=\\\"Incident Chart\\\"></img></p>\" }], \"potentialAction\": [{ \"@type\": \"OpenUri\", \"name\": \"View Incident\", \"targets\": [{ \"os\": \"default\", \"uri\": \"$INCIDENT_URL\" }] }, { \"@type\": \"OpenUri\", \"name\": \"Aknowledge Incident\", \"targets\": [{ \"os\": \"default\", \"uri\": \"$INCIDENT_ACKNOWLEDGE_URL\" }] }, { \"@type\": \"OpenUri\", \"name\": \"Open Runbook\", \"targets\": [{ \"os\": \"default\", \"uri\": \"$RUNBOOK_URL\" }] }] } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.42696,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "=$POLICY_URL runbook_url=$RUNBOOK_URL severity=$SEVERITY timestamp=$TIMESTAMP timestamp_utc_string=$TIMESTAMP_UTC_STRING violation_callback_url=$VIOLATION_CALLBACK_URL violation_chart_url=$VIOLATION_CHART_URL team=&quot;DevOps&quot; &lt;--[example of custom variable] Copy Plain text output <em>New</em> <em>Relic</em> <em>Alert</em> Incident open"
      },
      "id": "603ed08e28ccbcbdcdeba74a"
    },
    {
      "sections": [
        "Notification channels: Control where to send alerts",
        "Tip",
        "View notification channels",
        "Add or remove notification channels",
        "Instructions for specific notification channels",
        "User",
        "Email",
        "OpsGenie",
        "PagerDuty",
        "Slack",
        "VictorOps",
        "Webhook",
        "Important",
        "Caution",
        "xMatters",
        "Receive mobile push notifications",
        "Acknowledge alert notifications"
      ],
      "title": "Notification channels: Control where to send alerts",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "8600dc86e59fad5da1e4a2b4170d2b86df78ee2f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/notification-channels-control-where-send-alerts/",
      "published_at": "2021-05-28T03:30:14Z",
      "updated_at": "2021-04-21T16:00:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use alerts to set up notification channels, and attach those channels to policies. Your selected channels provide fast and consistent ways for the right personnel to be notified about incidents. For example, notifications allow you to include charts about the incident to provide context and share them with your team. Alerts offers several notification channels, including webhooks, Slack rooms, email, and more. You'll be notified by your notification channels when incidents are opened, acknowledged, or closed. This document explains the available notification channels and how to set them up. Tip This document is about alerts notifications. For general information about unsubscribing from other New Relic emails, including marketing emails, weekly reports, and announcements, see Unsubscribe from New Relic emails. View notification channels To see all notification channels in your account: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. Add or remove notification channels To set up a new notification channel: On the Notification channels, click New notification channel. Select the type of channel and complete other required steps for it. To add or remove a notification policy or channel: Select a specific notification channel, select Alert policies, and add or remove a policy. OR Select a specific policy, select Notification channels, and add or remove a channel. Instructions for specific notification channels These are the available notification channel types. User Requirement: This feature is not available for users on the New Relic One user model, only to users on the original user model (learn about user model differences). As a workaround, you can use the email notification channel. Use the User notification channel to select existing account team members and admins. To view the Users list or to add users to alert policies: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. If a user has configured the New Relic mobile app, the user notification channel also sends push notifications to any of the user's registered mobile devices. If your account has one or more sub-accounts, the notification channel includes only users for the currently selected master or sub-account. Email We automatically add every individual and their email address on the selected account to the User notification channel and you can select them there. You don't need to add existing New Relic accounts to the Email channel. To add an email channel for other users, follow these guidelines: Field Description Email (required) In general, use the Email notification channel to identify user emails or email aliases that are not already on the selected account. For example, if you have a dev-ops@company.com email alias for your DevOps team, add the email alias to the Email channel. Otherwise, use the User notification channel to select specific users on your DevOps team. For easier maintenance, add a single non-user email address or alias to a single alert notification channel. If you want to use the email channel for more than one email, create an email group or alias outside your account. These email addresses can be the same as or different from email addresses already on your account. Users can unsubscribe from general (non-alerts-related) emails, but they cannot unsubscribe from alerts email notifications. Instead, the account Owner, Admin, or add-on manager must remove users from the policy's email notification channel. Include JSON attachment (optional) To include a JSON attachment with the email notification, select this checkbox. OpsGenie You must have an existing OpsGenie account integrated with New Relic in order to provide the following information: Field Description Channel name (required) A meaningful name for the OpsGenie notification channel (maximum 64 characters). API key (required) The API key generated from your OpsGenie integration used to authenticate API requests. Teams (optional) List of team names that are responsible for the alert. OpsGenie runs team escalation policies to calculate which users will receive notifications. Tags (optional) A comma-separated list of labels attached to the alert. Tip To overwrite the OpsGenie Quiet Hours setting for urgent alerts, add an OverwriteQuietHours tag. Recipients (optional) One or more names of users, groups, on-call schedules, escalation policies, etc., that OpsGenie uses to calculate where to send notifications. PagerDuty You must have an existing PagerDuty account in order to provide the following information: Field Description Service name (required) The name of your service integrating with PagerDuty for notifications. Integration key (required) The unique service identifier used by PagerDuty's Integration API to trigger, acknowledge, and resolve incidents for the service. Slack Before adding Slack notifications, you must create a unique webhook integration using Slack's New Relic integration. If you want web, transaction, server, and mobile alerts to be posted in separate channels, you must set up separate integrations for each one. Field Description Channel name (required) A meaningful name for the Slack notification channel (maximum 64 characters); for example, Network Ops Center. URL (required) Copy and paste the New Relic webhook integration URL that you've set up with Slack. For example: https://hooks.slack.com/services/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 Be sure to include https:// in the URL. Do not use http://. Team channel (optional) If used, include # before the name of the Slack channel where alert notifications are sent; for example, #NOC. VictorOps You must have an existing VictorOps account in order to provide the following required information: Field Description Channel name (required) A meaningful name for this notification channel (maximum 64 characters). For example, if the VictorOps Route key is for your Technical Support team, you could name this channel Tech Support - VictorOps. Key (required) VictorOps generates a unique key for each account. It maps the VictorOps account to its associated integrations. Route key (optional) This key maps the alert or incident to a specific team. Webhook Webhooks are HTTP POST messages containing JSON documents delivered to a destination URL. When an incident is opened, acknowledged, or closed, our webhook feature sends a message to your URL with any relevant information, such as a description of the event and a link back to New Relic. You also have the option to customize the payload in the POST message for further integration into your system. Important If your endpoint does not acknowledge the POST request within 10 seconds, the Alerts UI may indicate a failed notification event for the related incident. Before adding webhook notifications, you must have an endpoint set up to respond with a status code between 200 and 206 after receiving the following required information: Field Description Channel name (required) A meaningful name for the webhook (maximum 64 characters). Base url (required) The endpoint that will receive the POST message and trigger customized behaviors in your system. Caution If you want to include a port number in the webhook URL, make sure the port is available for requests. Otherwise the webhook will not work. Basic auth (optional) To require basic authentication for the webhook, select Add basic auth, and provide the user name and password to authenticate the webhook. Custom headers (optional) To include headers with webhooks, select Add custom headers, and provide the name and value for each header. Use custom payload (optional) To use the default values, leave blank. To view and edit the default values, select Add custom payload. Payload (for custom payloads only) Your customized POST message code. This field includes: A list of variables you can use Syntax highlighting, based on payload type Payload type (for custom payloads only) Specify the message format: JSON (default) or Form. xMatters You must have an existing xMatters account in order to provide the following information: Field Description Channel name (required) Name your channel so you can identify it easily when associating it with a policy. Integration url (required) The unique integration url provided by xMatters pointing to your xMatters account. Receive mobile push notifications Important In order to receive mobile push notifications, your device must be registered and listed in (account) > User preferences. If the device is not listed in User preferences, log out of the app, log back in, and check again to see if it is listed. To receive mobile push notifications: Log in to your New Relic account via the mobile app at least once to ensure the device is registered. Add the user channel to the alert policy. Switch push notifications On for the device. Acknowledge alert notifications Anyone in your account can acknowledge notifications through the user interface or email notification. Acknowledging an incident in New Relic also acknowledges any associated incident in PagerDuty.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 177.6083,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Notification</em> channels: Control where to send <em>alerts</em>",
        "sections": "<em>Notification</em> channels: Control where to send <em>alerts</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " them up. Tip This document is about <em>alerts</em> <em>notifications</em>. For general information about unsubscribing from other <em>New</em> <em>Relic</em> emails, including marketing emails, weekly reports, and announcements, see Unsubscribe from <em>New</em> <em>Relic</em> emails. View notification channels To see all notification channels in your"
      },
      "id": "603ecfbf64441f4ee54e885f"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/muting-rules-suppress-notifications": [
    {
      "sections": [
        "Customize your webhook payload",
        "Define webhooks",
        "Webhook values",
        "Targets values",
        "Webhook format example",
        "JSON webhook example",
        "Important",
        "Form webhook example",
        "Plain text output",
        "Microsoft Teams example"
      ],
      "title": "Customize your webhook payload",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "26f483edd4fd0bf049a3d3e6c5885788dcdfdd46",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/customize-your-webhook-payload/",
      "published_at": "2021-06-02T20:58:08Z",
      "updated_at": "2021-05-16T08:48:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use webhooks as your alerts notification channel, you can use the default values. You can also customize the payload in the POST message for further integration into your system. Define webhooks When defining JSON webhooks, use the format \"name\":\"value\",. For example: \"current_state\":\"acknowledged\", Copy When defining static webhook variables in a form payload, use the format name=\"value\". For example: current_state=\"acknowledged\" Copy Do not include any custom, self-signed SSL certificates in your webhook. Our agents enable SSL by default. Due to our security policy, custom SSL certificates will not be imported into our Trust store. Webhook values We support these default dynamic webhook values. For your convenience, they are listed in alphabetical order, but you can define your webhook values in any order. You may also add custom variables by using your own key/value pairs. Key Variable \"account_id\" $ACCOUNT_ID Possible values: New Relic account ID (string) \"account_name\" $ACCOUNT_NAME Possible values: New Relic account name (string) \"closed_violations_count_critical\" $CLOSED_VIOLATIONS_COUNT_CRITICAL \"closed_violations_count_warning\" $CLOSED_VIOLATIONS_COUNT_WARNING \"condition_id\" $CONDITION_ID \"condition_description\" $DESCRIPTION This includes the description field from the alert condition, if there is one. \"condition_name\" $CONDITION_NAME Possible values: (user-defined string) \"current_state\" $EVENT_STATE Possible values: [open|acknowledged|closed] \"details\" $EVENT_DETAILS \"duration\" $DURATION \"event_type\" $EVENT_TYPE Possible values: [INCIDENT] \"incident_acknowledge_url\" $INCIDENT_ACKNOWLEDGE_URL \"incident_id\" $INCIDENT_ID \"incident_url\" $INCIDENT_URL \"metadata\" $METADATA Currently used only for Synthetic monitoring multi-location failure conditions. \"open_violations_count_critical\" $OPEN_VIOLATIONS_COUNT_CRITICAL \"open_violations_count_warning\" $OPEN_VIOLATIONS_COUNT_WARNING \"owner\" $EVENT_OWNER \"policy_name\" $POLICY_NAME Possible values: (user-defined string) \"policy_url\" $POLICY_URL \"runbook_url\" $RUNBOOK_URL \"severity\" $SEVERITY Possible values: [CRITICAL] \"targets\" $TARGETS The $TARGETS variable cannot be used with FORM data, but is compatible with JSON data. For static NRQL faceted alerts, the name of the facet that triggered the alert will be populated in the target’s name field. For a description of the available fields, see Target values. \"timestamp\" $TIMESTAMP \"timestamp_utc_string\" $TIMESTAMP_UTC_STRING A human-readable timestamp in the YYYY-MM-DD, HH:MM UTC format. \"version\" $VERSION \"violation_callback_url\" $VIOLATION_CALLBACK_URL \"violation_chart_url\" $VIOLATION_CHART_URL Targets values This section describes the $TARGETS field in your webhook. This data is not customizable and is provided here for reference. Your $TARGETS contain a list of zero or more targets (entities). Each target is described by a JSON object with the following fields. Key Variable \"id\" ID of the target or entity \"name\" Name of the target or entity \"labels\" Combined entity tags and NRQL facets that are derived from the condition evaluation and available entity tags. \"link\" URL link to this target or entity. \"product\" Type of product for this target or entity; for example, APM \"type\" Type of target or entity under product; for example, Application Webhook format example The following examples show a webhook payload using both the default dynamic variables and a custom variable. You can use some or all of the dynamic variables, along with any custom variables, to define your own payload. JSON webhook example Important The following webhook example has extra spaces and line breaks for readability. Actual webhook responses are delivered as one continuous line of text. The \"team\": \"DevOps\" line is an example of a custom variable. { \"account_id\": \"$ACCOUNT_ID\", \"account_name\": \"$ACCOUNT_NAME\", \"closed_violations_count_critical\": \"$CLOSED_VIOLATIONS_COUNT_CRITICAL\", \"closed_violations_count_warning\": \"$CLOSED_VIOLATIONS_COUNT_WARNING\", \"condition_family_id\": \"$CONDITION_FAMILY_ID\", \"condition_id\": \"$CONDITION_ID\", \"condition_name\": \"$CONDITION_NAME\", \"current_state\": \"$EVENT_STATE\", \"details\": \"$EVENT_DETAILS\", \"duration\": \"$DURATION\", \"event_type\": \"$EVENT_TYPE\", \"incident_acknowledge_url\": \"$INCIDENT_ACKNOWLEDGE_URL\", \"incident_id\": \"$INCIDENT_ID\", \"incident_url\": \"$INCIDENT_URL\", \"open_violations_count_critical\": \"$OPEN_VIOLATIONS_COUNT_CRITICAL\", \"open_violations_count_warning\": \"$OPEN_VIOLATIONS_COUNT_WARNING\", \"owner\": \"$EVENT_OWNER\", \"policy_name\": \"$POLICY_NAME\", \"policy_url\": \"$POLICY_URL\", \"runbook_url\": \"$RUNBOOK_URL\", \"severity\": \"$SEVERITY\", \"targets\": \"$TARGETS\", \"timestamp\": \"$TIMESTAMP\", \"timestamp_utc_string\": \"$TIMESTAMP_UTC_STRING\", \"violation_callback_url\": \"$VIOLATION_CALLBACK_URL\", \"violation_chart_url\": \"$VIOLATION_CHART_URL\", \"team\": \"DevOps\" } Copy Form webhook example Important The following webhook example has extra spaces and line breaks for readability. Actual webhook responses are delivered as one continuous line of text. account_id=$ACCOUNT_ID account_name=$ACCOUNT_NAME closed_violations_count_critical=$CLOSED_VIOLATIONS_COUNT_CRITICAL closed_violations_count_warning=$CLOSED_VIOLATIONS_COUNT_WARNING condition_family_id=$CONDITION_FAMILY_ID condition_id=$CONDITION_ID condition_name=$CONDITION_NAME current_state=$EVENT_STATE details=$EVENT_DETAILS duration=$DURATION event_type=$EVENT_TYPE incident_acknowledge_url=$INCIDENT_ACKNOWLEDGE_URL incident_id=$INCIDENT_ID incident_url=$INCIDENT_URL open_violations_count_critical=$OPEN_VIOLATIONS_COUNT_CRITICAL open_violations_count_warning=$OPEN_VIOLATIONS_COUNT_WARNING owner=$EVENT_OWNER policy_name=$POLICY_NAME policy_url=$POLICY_URL runbook_url=$RUNBOOK_URL severity=$SEVERITY timestamp=$TIMESTAMP timestamp_utc_string=$TIMESTAMP_UTC_STRING violation_callback_url=$VIOLATION_CALLBACK_URL violation_chart_url=$VIOLATION_CHART_URL team=\"DevOps\" <--[example of custom variable] Copy Plain text output New Relic Alert Incident open: CPU > 50% for 5 minutes Policy: http://alerts.newrelic.com/accounts/1234/policies/5678 Chart URL: http://gorgon.nr-assets.net/image/12345678-abcd-efgh-ijkl-1234567890 For more details, see: http://alerts.newrelic.com/accounts/1234/incidents/3456 Copy Microsoft Teams example { \"@type\": \"MessageCard\", \"@context\": \"http://schema.org/extensions\", \"themeColor\": \"0076D7\", \"summary\": \"$CONDITION_NAME\", \"sections\": [{ \"activityTitle\": \"$CONDITION_NAME\", \"activitySubtitle\": \"$POLICY_NAME\", \"activityImage\": \"https://newrelic.com/themes/custom/curio/assets/mediakit/NR_logo_Horizontal_Rev.png\", \"facts\": [{ \"name\": \"Timestamp\", \"value\": \"$TIMESTAMP_UTC_STRING\" }, { \"name\": \"Account ID\", \"value\": \"$ACCOUNT_ID\" }, { \"name\": \"Account Name\", \"value\": \"$ACCOUNT_NAME\" }, { \"name\": \"Severity\", \"value\": \"$SEVERITY\" }, { \"name\": \"State\", \"value\": \"$EVENT_STATE\" }, { \"name\": \"Duration\", \"value\": \"$DURATION\" }, { \"name\": \"Details\", \"value\": \"$EVENT_DETAILS\" }], \"markdown\": true }, { \"text\": \"$METADATA<p><img src=\\\"$VIOLATION_CHART_URL\\\" alt=\\\"Incident Chart\\\"></img></p>\" }], \"potentialAction\": [{ \"@type\": \"OpenUri\", \"name\": \"View Incident\", \"targets\": [{ \"os\": \"default\", \"uri\": \"$INCIDENT_URL\" }] }, { \"@type\": \"OpenUri\", \"name\": \"Aknowledge Incident\", \"targets\": [{ \"os\": \"default\", \"uri\": \"$INCIDENT_ACKNOWLEDGE_URL\" }] }, { \"@type\": \"OpenUri\", \"name\": \"Open Runbook\", \"targets\": [{ \"os\": \"default\", \"uri\": \"$RUNBOOK_URL\" }] }] } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.42693,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "=$POLICY_URL runbook_url=$RUNBOOK_URL severity=$SEVERITY timestamp=$TIMESTAMP timestamp_utc_string=$TIMESTAMP_UTC_STRING violation_callback_url=$VIOLATION_CALLBACK_URL violation_chart_url=$VIOLATION_CHART_URL team=&quot;DevOps&quot; &lt;--[example of custom variable] Copy Plain text output <em>New</em> <em>Relic</em> <em>Alert</em> Incident open"
      },
      "id": "603ed08e28ccbcbdcdeba74a"
    },
    {
      "sections": [
        "Notification channels: Control where to send alerts",
        "Tip",
        "View notification channels",
        "Add or remove notification channels",
        "Instructions for specific notification channels",
        "User",
        "Email",
        "OpsGenie",
        "PagerDuty",
        "Slack",
        "VictorOps",
        "Webhook",
        "Important",
        "Caution",
        "xMatters",
        "Receive mobile push notifications",
        "Acknowledge alert notifications"
      ],
      "title": "Notification channels: Control where to send alerts",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "8600dc86e59fad5da1e4a2b4170d2b86df78ee2f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/notification-channels-control-where-send-alerts/",
      "published_at": "2021-05-28T03:30:14Z",
      "updated_at": "2021-04-21T16:00:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use alerts to set up notification channels, and attach those channels to policies. Your selected channels provide fast and consistent ways for the right personnel to be notified about incidents. For example, notifications allow you to include charts about the incident to provide context and share them with your team. Alerts offers several notification channels, including webhooks, Slack rooms, email, and more. You'll be notified by your notification channels when incidents are opened, acknowledged, or closed. This document explains the available notification channels and how to set them up. Tip This document is about alerts notifications. For general information about unsubscribing from other New Relic emails, including marketing emails, weekly reports, and announcements, see Unsubscribe from New Relic emails. View notification channels To see all notification channels in your account: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. Add or remove notification channels To set up a new notification channel: On the Notification channels, click New notification channel. Select the type of channel and complete other required steps for it. To add or remove a notification policy or channel: Select a specific notification channel, select Alert policies, and add or remove a policy. OR Select a specific policy, select Notification channels, and add or remove a channel. Instructions for specific notification channels These are the available notification channel types. User Requirement: This feature is not available for users on the New Relic One user model, only to users on the original user model (learn about user model differences). As a workaround, you can use the email notification channel. Use the User notification channel to select existing account team members and admins. To view the Users list or to add users to alert policies: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. If a user has configured the New Relic mobile app, the user notification channel also sends push notifications to any of the user's registered mobile devices. If your account has one or more sub-accounts, the notification channel includes only users for the currently selected master or sub-account. Email We automatically add every individual and their email address on the selected account to the User notification channel and you can select them there. You don't need to add existing New Relic accounts to the Email channel. To add an email channel for other users, follow these guidelines: Field Description Email (required) In general, use the Email notification channel to identify user emails or email aliases that are not already on the selected account. For example, if you have a dev-ops@company.com email alias for your DevOps team, add the email alias to the Email channel. Otherwise, use the User notification channel to select specific users on your DevOps team. For easier maintenance, add a single non-user email address or alias to a single alert notification channel. If you want to use the email channel for more than one email, create an email group or alias outside your account. These email addresses can be the same as or different from email addresses already on your account. Users can unsubscribe from general (non-alerts-related) emails, but they cannot unsubscribe from alerts email notifications. Instead, the account Owner, Admin, or add-on manager must remove users from the policy's email notification channel. Include JSON attachment (optional) To include a JSON attachment with the email notification, select this checkbox. OpsGenie You must have an existing OpsGenie account integrated with New Relic in order to provide the following information: Field Description Channel name (required) A meaningful name for the OpsGenie notification channel (maximum 64 characters). API key (required) The API key generated from your OpsGenie integration used to authenticate API requests. Teams (optional) List of team names that are responsible for the alert. OpsGenie runs team escalation policies to calculate which users will receive notifications. Tags (optional) A comma-separated list of labels attached to the alert. Tip To overwrite the OpsGenie Quiet Hours setting for urgent alerts, add an OverwriteQuietHours tag. Recipients (optional) One or more names of users, groups, on-call schedules, escalation policies, etc., that OpsGenie uses to calculate where to send notifications. PagerDuty You must have an existing PagerDuty account in order to provide the following information: Field Description Service name (required) The name of your service integrating with PagerDuty for notifications. Integration key (required) The unique service identifier used by PagerDuty's Integration API to trigger, acknowledge, and resolve incidents for the service. Slack Before adding Slack notifications, you must create a unique webhook integration using Slack's New Relic integration. If you want web, transaction, server, and mobile alerts to be posted in separate channels, you must set up separate integrations for each one. Field Description Channel name (required) A meaningful name for the Slack notification channel (maximum 64 characters); for example, Network Ops Center. URL (required) Copy and paste the New Relic webhook integration URL that you've set up with Slack. For example: https://hooks.slack.com/services/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 Be sure to include https:// in the URL. Do not use http://. Team channel (optional) If used, include # before the name of the Slack channel where alert notifications are sent; for example, #NOC. VictorOps You must have an existing VictorOps account in order to provide the following required information: Field Description Channel name (required) A meaningful name for this notification channel (maximum 64 characters). For example, if the VictorOps Route key is for your Technical Support team, you could name this channel Tech Support - VictorOps. Key (required) VictorOps generates a unique key for each account. It maps the VictorOps account to its associated integrations. Route key (optional) This key maps the alert or incident to a specific team. Webhook Webhooks are HTTP POST messages containing JSON documents delivered to a destination URL. When an incident is opened, acknowledged, or closed, our webhook feature sends a message to your URL with any relevant information, such as a description of the event and a link back to New Relic. You also have the option to customize the payload in the POST message for further integration into your system. Important If your endpoint does not acknowledge the POST request within 10 seconds, the Alerts UI may indicate a failed notification event for the related incident. Before adding webhook notifications, you must have an endpoint set up to respond with a status code between 200 and 206 after receiving the following required information: Field Description Channel name (required) A meaningful name for the webhook (maximum 64 characters). Base url (required) The endpoint that will receive the POST message and trigger customized behaviors in your system. Caution If you want to include a port number in the webhook URL, make sure the port is available for requests. Otherwise the webhook will not work. Basic auth (optional) To require basic authentication for the webhook, select Add basic auth, and provide the user name and password to authenticate the webhook. Custom headers (optional) To include headers with webhooks, select Add custom headers, and provide the name and value for each header. Use custom payload (optional) To use the default values, leave blank. To view and edit the default values, select Add custom payload. Payload (for custom payloads only) Your customized POST message code. This field includes: A list of variables you can use Syntax highlighting, based on payload type Payload type (for custom payloads only) Specify the message format: JSON (default) or Form. xMatters You must have an existing xMatters account in order to provide the following information: Field Description Channel name (required) Name your channel so you can identify it easily when associating it with a policy. Integration url (required) The unique integration url provided by xMatters pointing to your xMatters account. Receive mobile push notifications Important In order to receive mobile push notifications, your device must be registered and listed in (account) > User preferences. If the device is not listed in User preferences, log out of the app, log back in, and check again to see if it is listed. To receive mobile push notifications: Log in to your New Relic account via the mobile app at least once to ensure the device is registered. Add the user channel to the alert policy. Switch push notifications On for the device. Acknowledge alert notifications Anyone in your account can acknowledge notifications through the user interface or email notification. Acknowledging an incident in New Relic also acknowledges any associated incident in PagerDuty.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 177.6083,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Notification</em> channels: Control where to send <em>alerts</em>",
        "sections": "<em>Notification</em> channels: Control where to send <em>alerts</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " them up. Tip This document is about <em>alerts</em> <em>notifications</em>. For general information about unsubscribing from other <em>New</em> <em>Relic</em> emails, including marketing emails, weekly reports, and announcements, see Unsubscribe from <em>New</em> <em>Relic</em> emails. View notification channels To see all notification channels in your"
      },
      "id": "603ecfbf64441f4ee54e885f"
    },
    {
      "sections": [
        "Incident Intelligence destination examples",
        "Destination template examples",
        "Suggested OpsGenie template example",
        "Suggested ServiceNow template example",
        "Suggested Slack template example",
        "Suggested VictorOps template example",
        "Webhook and JSON format examples",
        "Webhook format and JSON example",
        "Jinja2 Default Payload",
        "Jinja2 Useful Syntax",
        "JSON schema",
        "JSON schema template"
      ],
      "title": "Incident Intelligence destination examples",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "a516d04f8b75541a6dc9338fa3ce9645ba87d620",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/incident-intelligence-destination-examples/",
      "published_at": "2021-06-02T18:22:22Z",
      "updated_at": "2021-06-02T18:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Destinations are the data outputs to Applied Intelligence, where you can view your automatically correlated incidents. You can configure Incident Intelligence destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema. Destination template examples The following template example destinations are formatted in Jinja2. Suggested OpsGenie template example { \"alias\": {{ id }}, \"message\": {{ ui_name }}, \"source\": '{{ sources }}', \"priority\": {{ priority }}, \"details\": { \"self_url\": {{ url }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"is_correlated\": {{ is_correlated }} }, \"description\": \"\"\"Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]\"\"\" } Copy Suggested ServiceNow template example { \"short_description\": {{ ui_name }}, \"description\": 'Issue Id: {{ id }}, \\n Description: {{ description }}, \\n Sources: {{ sources }}, \\n Priority: {{ priority }}, \\n Details: { \\n self_url: {{ url }}, \\n state: {{ state }}, \\n is_correlated: {{ is_correlated }}, \\n created_on: {{ created_on }}, \\n modified_on: {{ modified_on }}, \\n activated_on: {{ active_since }}, \\n closed_on: {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \\n is_correlated: {{is_correlated}} }, \\n\\n incidents: {{ incidents }}, \\n\\n pathways: {{ pathways }}' } Copy Suggested Slack template example Go to Slack incoming WebHooks Choose the right Slack workspace and click \"Add to Slack\" Select the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In New Relic Applied Intelligence, under Incident Intelligence click Destinations Add a WebHook In the end point paste the WebHook url from slack. In the custom payload, paste the following JSON: { \"blocks\": [ { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*New Relic Incident Intelligence Alert*\" } }, { \"type\": \"divider\" }, { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*CUSTOM FIELDS*:\" }, \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue ID*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Issue Title*\" }, { \"type\": \"plain_text\", \"text\": {{ id }} }, { \"type\": \"plain_text\", \"text\": {{ ui_name }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue URL*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Description*\" }, { \"type\": \"mrkdwn\", \"text\": {{ url }} }, { \"type\": \"plain_text\", \"text\": {{ description }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*State*\" }, { \"type\": \"mrkdwn\", \"text\": \"*is_correlated*\" }, { \"type\": \"plain_text\", \"text\": {{ state }} }, { \"type\": \"plain_text\", \"text\": \"{{ is_correlated }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Created On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Modified On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ created_on }}\" }, { \"type\": \"plain_text\", \"text\": \"{{ modified_on }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Activated On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Closed On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ active_since }}\" }, { \"type\": \"plain_text\", \"text\": \"{% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Aggregated Incidents*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Monitoring Tool*\" }, { \"type\": \"plain_text\", \"text\": \"{{ incident_count }}\" }, { \"type\": \"plain_text\", \"text\": {{ sources|join(', ') }} } ] } ] } Copy Suggested VictorOps template example { \"monitoring_tool\": {{ sources }}, {% if state == 'closed' %} \"message_type\": \"OK\", {% else %} \"message_type\": {{ priority }}, {% endif %} \"custom_fields\": { \"issue_url\": {{ url }}, \"description\": {{ description }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"related_incidents\": [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %} {% endfor %} ] }, \"state_message\": {{ description }}, \"entity_id\": {{ id }}, \"entity_display_name\": {{ ui_name }}, \"vo_annotate.u.NRAI_Link\": {{ url }} } Copy Webhook and JSON format examples Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). If you use webhooks to configure Incident Intelligence destinations, use these examples of the webhook body format and JSON schema. Webhook format and JSON example Webhook format: Name Description url Href A link to the UI where the issue can be seen. id String Unique identifier for the issue. title String The issue title. description String The description of the issue. priority Enum The issue priority. Can be Critical, High, Medium, or Low. state Enum The issue status. Can be Active, Closed, or Acknowledged. is_correlated Boolean True if the issue is based on correlated data. created_on String The date and time the issue was created (in ISO format). modified_on String The date and time the issue was modified (in ISO format). active_since String The date and time the issue was activated (in ISO format). closed_on String The date and time the issue was closed (in ISO format). sources List(String) List of the different sources that were used to send the events into Applied Intelligence (for example: PagerDuty). pathways List(Pathways) List of pathways that are associated with the issue. Each pathway contains an id and name: [{“id”: “pathway id”, “name”: “pathway name”}]. pathways[].id String The pathway ID. pathways[].name String The pathway name. incidents List(Incident) List of incidents that are attached to the issue. The list contains only the latest 100 incidents. incidents[].id String The incident ID. incidents[].events_count Integer The number of events used to create the incident. incidents[].title String The incident title. incidents[].description String The incident description. incidents[].labels Dictionary (String) A string to string mapping of the incident labels. Labels represent the unique entities that are used to describe the incident. incidents[].priority Enum The incident priority. Can be Critical, High, Medium, or Low. incidents[].sources List(String) The incident source. incidents[].state Enum(open, closed) The incident state. incidents[].opened_on String The date and time the incident was opened (in ISO format). incidents[].closed_on String The date and time the incident was closed (in ISO format). ui_name String Issue title. accumulations['alert/signal'] String Issue analysis summary golden signal/s (if applicable). accumulations['alert/components'] String Issue analysis summary golden components (if applicable). Jinja2 Default Payload Applied Intelligence uses a templating framework called Jinja2 in the Webhook interface. Here is a default Jinja2 payload to use: { \"id\": {{ id }}, \"url\": {{ url }}, \"ui_name\": {{ ui_name }}, \"description\": {{ description }}, \"priority\": {{ priority }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"active_since\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"sources\": {{ sources }}, \"incidents\": {{ incidents }}, \"pathways\": {{ pathways }}, } Copy Jinja2 Useful Syntax Below are a few useful Jinja2 commands to help you format your output. Casting a value to integer Example: “severity”: {{ priority | int }} Copy If clause to check if an attribute’s value is set Example: \"golden_signals\": {% if accumulations['alert/signal'] is defined %} {{ accumulations['alert/signal'] }} {% else %} None {% endif %} Copy For loop to iterate of an array of values: Example: \"description\": 'Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]' Copy Check if an array attribute's value is set: Example: \"hostname_field\": {% if incidents[0].labels['newrelic/tag/hostname'] is defined %} {{ incidents[0].labels['newrelic/tag/hostname'] }} {% else %} None {% endif %} Copy JSON schema Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). JSON schema template JSON schema: { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"definitions\": { \"Labels\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"LabelsSet\": { \"type\": \"array\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"$ref\": \"#/definitions/Labels\" }, \"uniqueItems\": true }, }, \"Annotations\": { \"type\": \"object\", \"title\": \"Additional contextual information about the Entity\", \"description\": \"Fields like title, description and priority can be described as annotations since\\nthey represent some additional information about the Incident.\\nFor example, the rule that creates the entity can have some logic that will create a title annotation field.\\nThe title will change according to the latest event received by the entity and as more\\nevent will keep coming the field may change, all this as a decision by the rule.\\nA different rule may decide not to populate the title at all.\\nSince a title can also be produced from the labels themselves.\", \"properties\": { \"title\": { \"type\": \"string\", \"maxLength\": 10000 }, \"description\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"patternProperties\": { \".*\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"Accumulations\": { \"type\": \"object\", \"title\": \"Accumulated data about the Incident\", \"description\": \"For example an entity with the label: host_name: foo will include a accumulated list of the\\nrelevant process names that are relevant to the entity. Accumulations will be derived from the events\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"type\": \"string\", \"maxLength\": 10000 } } }, \"IssueState\": { \"type\": \"string\", \"enum\": [ \"created\", \"active\", \"acknowledged\", \"closed\" ], \"properties\": {}, \"additionalProperties\": false }, \"Priority\": { \"type\": \"string\", \"enum\": [ \"critical\", \"high\", \"medium\", \"low\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueClosingReason\": { \"type\": \"string\", \"enum\": [ \"nacked\", \"resolved\", \"system\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueAction\": { \"type\": \"string\", \"enum\": [ \"ack\", \"snooze\", \"nack\", \"end_snooze\", \"expire_snooze\", \"star\", \"un_snooze\", \"unstar\", \"archive\", \"unarchive\", \"resolve\", \"reopen\", \"open\", \"feedback\", \"feedback_file\", \"open_ticket\", \"merge_issues\", \"active\", \"create\", \"close\", \"incident_updated\", \"confidence_changed\", \"diagnoses_changed\", \"rule_properties_changed\", \"flapping\", \"notification\", \"incident_events_limit_reached\", \"follow\", \"unfollow\", \"priority_updated\", \"comment\", \"incident_appended\", \"diagnosis_feedback\", \"flapping_delay_close\" ], \"properties\": {}, \"additionalProperties\": false }, \"StringKeyValue\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\" } }, \"JavaOptionalUuid\": { \"type\": \"string\", \"properties\": {}, \"additionalProperties\": false, \"format\": \"string-uuid\" } }, \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"customer_id\": { \"type\": \"integer\" }, \"labels_set\": { \"$ref\": \"#/definitions/LabelsSet\" }, \"annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations_version\": { \"type\": \"integer\" }, \"accumulations\": { \"$ref\": \"#/definitions/Accumulations\" }, \"state\": { \"$ref\": \"#/definitions/IssueState\" }, \"previous_state\": { \"$ref\": \"#/definitions/IssueState\" }, \"priority\": { \"$ref\": \"#/definitions/Priority\" }, \"closing_reason\": { \"oneOf\": [ { \"$ref\": \"#/definitions/IssueClosingReason\" }, { \"type\": \"null\" } ] }, \"modified_on\": { \"type\": \"integer\" }, \"created_on\": { \"type\": \"integer\" }, \"closed_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"acknowledged_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"active_since\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"assigned_to\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"created_by\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"progress_report\": { \"type\": \"array\", \"default\": [], \"items\": { \"type\": \"object\", \"properties\": { \"origin_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1 }, { \"type\": \"null\" } ] }, \"timestamp\": { \"type\": \"integer\" }, \"action_timestamp\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"origin_type\": { \"type\": \"string\", \"enum\": [ \"user\", \"system\" ] }, \"event_type\": { \"$ref\": \"#/definitions/IssueAction\" }, \"issue_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"format\": \"string-uuid\" }, { \"type\": \"null\" } ] }, \"attributes\": { \"oneOf\": [ { \"$ref\": \"#/definitions/StringKeyValue\" }, { \"type\": \"null\" } ] }, \"team_id\": { \"$ref\": \"#/definitions/JavaOptionalUuid\" } }, \"required\": [ \"timestamp\", \"origin_type\", \"event_type\" ], \"additionalProperties\": false }, \"uniqueItems\": true }, \"rule_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"maxLength\": 255 }, { \"type\": \"null\" } ] }, \"incident_ids\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"confidence\": { \"type\": \"number\", \"default\": 1.0, \"minimum\": 0.0, \"maximum\": 1.0 } }, \"required\": [ \"id\", \"customer_id\", \"labels_set\", \"annotations\", \"priority\", \"modified_on\", \"created_on\", \"confidence\" ], \"additionalProperties\": true } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.20966,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Incident <em>Intelligence</em> destination examples",
        "sections": "Incident <em>Intelligence</em> destination examples",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " the destination channel to receive the <em>notifications</em> to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In <em>New</em> <em>Relic</em> <em>Applied</em> <em>Intelligence</em>, under Incident <em>Intelligence</em> click Destinations Add a WebHook In the end point paste the WebHook url"
      },
      "id": "6044280d64441f4af5378ed3"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/notification-channels-control-where-send-alerts": [
    {
      "sections": [
        "Muting rules: Suppress notifications",
        "Manage muting rules",
        "Create a muting rule",
        "Tip",
        "Schedule a muting rule",
        "Manage muting rules with NerdGraph",
        "How muting rules work",
        "Muting behavior",
        "View muted violations and incidents",
        "An incident with a critical violation that's been muted",
        "An incident that has been muted",
        "A list of violations, some of which are muted",
        "A list of alert events, some of which are muted",
        "Mute faceted results using tags.",
        "Sub-condition operators",
        "Muting examples",
        "Fetch muting rules for account",
        "Create muting rule",
        "Create muting rule for specific hosts or products",
        "Create a muting rule with a recurring schedule",
        "Rename and disable muting rule",
        "Delete muting rule"
      ],
      "title": "Muting rules: Suppress notifications",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "07d71869062b00bb820e52cf89fcb6a06ce523a4",
      "image": "https://docs.newrelic.com/static/595b1c9a595bf6a5c9175f5052298e88/03914/manage_muting_rules.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/muting-rules-suppress-notifications/",
      "published_at": "2021-05-27T19:23:09Z",
      "updated_at": "2021-05-16T09:31:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts sends out timely notifications when your system is having problems. Sometimes there are notifications you know you don't need to see. You can use muting rules to stop being bombarded by messages you don't want. Once you've spotted the common elements in your unwanted notifications, you can define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, Alerts still gathers data on those violations. Muting rules don't interfere with the alerts process and are applied at the point right before a notification is sent. You can read more about why we added muting rules in this blog post. Manage muting rules A muting rule condition is the set of individual expressions made up of attributes, operators, and values that define which violations to target for muting. You can create, enable, disable, and manage muting rules. Go to one.newrelic.com, in the top nav, click Alerts & AI, and then click Muting rules. Enable or disable muting rules at any time. Rules can have one of the following statuses: Active: Muting is enabled and active. Scheduled: Muting is enabled but not active yet (there's a future schedule). Ended: Muting is enabled, but no longer active (there's no future schedule). Inactive: Muting is disabled. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Create a muting rule Tip Before creating muting rules, you'll need to create policies and conditions that generate violation notifications. To create a muting rule, click + Add a rule in the Muting rules screen. Enter a name and a description for the muting rule, and select the account to which the rule will apply. Next, build the violation filter. You can use violation event attributes and sub-condition operators. Values can be compared against one of your violation attributes, such as an Alerts policy ID or a condition name. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Schedule a muting rule If needed, you can schedule your muting rules. To do this, select a start time and/or end time. Optionally, you can set the muting rule to last an entire day. You can also choose to select a time zone for the muting rule schedule. The default is the time zone selected in your user preferences. Flexible and powerful options for scheduling your muting rules. You can schedule your muting rules to recur daily, weekly, or monthly. A muting rule that's scheduled to repeat weekly includes the option to select the days of the week to recur. If no days are selected, the weekly recurrence will default to repeating on the day of the week that the muting rule is scheduled to start. You can also specify when you would like recurrence to end by selecting either a specific date or a certain number of occurrences. Manage muting rules with NerdGraph In NerdGraph, you can use the following queries and mutations with your muting rules. You can see the schema in more detail in the API Explorer. actor.account.alerts.mutingRule: Fetch a muting rule by id. actor.account.alerts.mutingRules: Fetch a list of muting rules for an account. alertsMutingRuleCreate: Create a muting rule for an account. alertsMutingRuleUpdate: Update a muting rule by id and account id. alertsMutingRuleDelete: Delete a muting rule by id and account id. We've given you some sample queries and mutations examples in this document. A muting rule has the following fields and components: Muting rule Fields and components id The unique identifier for the muting rule. name (Required) A text field for the user-friendly name of the muting rule. This is used when listing or referencing a rule. We don't require that the name be unique, but it is recommended. description This is an optional text field describing the muting rule. It can be a useful way to provide more context for your muting rule. This data is only used for management display purposes. accountId The muting rule's account ID. A muting rule will only affect violations that occur in a single account. To mute violations across multiple accounts, you'll need to create a muting rule for each account separately. createdAt The timestamp when the muting rule was created (UTC). createdBy The user ID of the person who created the muting rule. updatedAt The timestamp when the muting rule was last modified (UTC). updatedBy The user ID of the person who last modified the muting rule. enabled Enable or disable the muting rule (Boolean). Muting rules must be manually enabled and disabled. condition The set of individual expressions that define which violations to target. A muting rule condition has: operator: The boolean operator AND or OR that defines how to combine the set of conditions. conditions: The set of individual expressions (sub-conditions) that target attributes within a violation. These are evaluated together based on the operator. You can have a maximum of 20 sub-conditions for a single muting rule. A sub-condition has: attribute: A single attribute within a violation. Go here for a list of Violation event attributes. operator: The comparison function used to compare the selected violation attribute against values in the condition. Go here for a list of sub-condition operators. values: An array of string values to compare against selected violation attributes. When the muting rules evaluate a condition, if necessary, values will be coerced from strings. You can use a maximum of 500 values when using an operator that supports comparison against multiple values, such as IN. schedule The time window when the MutingRule actively mutes violations. startTime: The datetime stamp that represents when the muting rule starts. This is in local ISO 8601 format without an offset. Example: '2020-07-08T14:30:00' endTime: The datetime stamp that represents when the muting rule ends. This is in local ISO 8601 format without an offset. Example: '2020-07-15T14:30:00' timeZone: The time zone that applies to the muting rule schedule. Example: 'America/Los_Angeles'. See Wikipedia's list of tz database time zones. repeat: The frequency the muting rule schedule repeats. If it does not repeat, use null. Options are DAILY, WEEKLY, MONTHLY. endRepeat: The datetime stamp when the muting rule schedule stops repeating. This is in local ISO 8601 format without an offset. Example: '2020-07-10T15:00:00'. Note: Either endRepeat or repeatCount should be used to end a muting rule schedule. Both fields should not be provided together. repeatCount: The number of times the muting rule schedule repeats. This includes the original schedule. For example, a repeatCount of 2 will recur one time. A repeatCount of 3 will recur two times. Note: Either repeatCount or endRepeat can be used to end a muting rule schedule. Both fields should not be provided together. weeklyRepeatDays: The day(s) of the week that a muting rule should repeat when the repeat field is set to 'WEEKLY'. Example: [ 'MONDAY', 'WEDNESDAY']. How muting rules work Muting rules are applied at the end of the default alert lifecycle in order to suppress, or mute, notifications. They don't disable existing policies or conditions. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations will still be identified, even though the notifications for those violations are muted. A muting rule uses a set of conditions that match against attributes in a violation event. The muting rules tell us how to: Identify individual violations after they're created, but before an incident is opened. Override their default condition to indicate that they should be \"muted.\" Currently, muting a violation means that the normal Alerts incident lifecycle will be maintained, except that an incident that only contains muted violations will not send out any notifications. Muting rules override specific violations. They don't disable existing policies or conditions. This allows you to mute violations from specific entities that may be covered by a policy or condition that covers a large number of entities. This also keeps you from having to over-mute your monitoring when you are performing maintenance on a subset of your system. Muting behavior The following table describes how the Alerts incident lifecycle is affected by muted violations: IF AND THEN Event: Incident opens An incident opens because of a violation that is not muted An “Open incident” notification will be sent (default). An incident opens due to a violation that is muted An “Open incident” notification will not be sent (muted). Event: Violation added to an open incident A new muted violation is added to an already open incident No notification action is triggered (default). A new unmuted violation is added to an open incident An “Open incident” notification has not been sent An “Open incident” notification will be sent. A new unmuted violation is added to an open incident An “Open incident” notification has already been sent No notification action is triggered (default). Event: Incident closed An Incident is closed An “Open incident” notification has not been sent A “Close incident” notification will not be sent. An Incident is closed An “Open incident” notification has been sent A “Close incident” notification will be sent. Event: Incident acknowledged An Incident is acknowledged An “Open incident” notification has not been sent An “Incident acknowledged” notification will not be sent. An Incident is acknowledged An “Open incident” notification has been sent An “Incident acknowledged” notification will be sent. View muted violations and incidents When viewing an open or closed incident, violations and incidents are marked as Muted. The following sections show some of these muted violations and incidents, and where you can find them. An incident with a critical violation that's been muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Incidents. An incident that has been muted Violations and incidents are marked as Muted in the State column: Go to one.newrelic.com, and in the top nav click Alerts & AI, click Incidents, then click Open incidents. A list of violations, some of which are muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Events. A list of alert events, some of which are muted In the list of alert events, the State column shows which events have been muted. Go to one.newrelic.com, in the top nav click Alerts & AI, click Events, then click All events. Mute faceted results using tags. To mute results of faceted queries, use the tags.FACETED_ATTRIBUTE attribute, where FACETED_ATTRIBUTE represents the attributed you've run a NRQL FACET query on. For example: if your NRQL alert condition includes FACET host in its query, you can target that FACET attribute using tags.host. NRQL condition queries can accept multiple facet attributes. If you want to be able to filter from attributes in your events or metric time series that have been aggregated, you must add those attributes to your NRQL query FACET clause; for example: FACET host, region, cluster. For an example of using tags., see Create muting rule. Sub-condition operators The following are the logical operators available to use to compare attributes when you're constructing muting rules. For examples of these being used, see Examples. EQUALS: Where the supplied value equals the violation attribute value. NOT_EQUALS: Where the supplied value does not equal the violation attribute value. IN: Where the violation attribute value is present in a list of supplied values (up to 500). NOT_IN: Where the violation attribute value is not present in a list of supplied values (up to 500). CONTAINS: Where the supplied value string is present in the violation attribute value. NOT_CONTAINS: Where the supplied value string is not present in the violation attribute value. ANY: Caution: A condition with this operator will mute all violations on the account. IS_BLANK: Where the violation attribute value is blank. Null, empty string, etc. IS_NOT_BLANK: Where the violation attribute value is not blank. Null, empty string, etc. STARTS_WITH: Where the violation attribute value begins with the supplied value string. NOT_STARTS_WITH: Where the violation attribute value does not begin with the supplied value string. ENDS_WITH: Where the violation attribute value ends with the supplied value string. NOT_ENDS_WITH: Where the violation attribute value does not end with the supplied value string. Muting examples For more information about making requests to NerdGraph, see the NerdGraph documentation, including GraphQL tutorials. Fetch muting rules for account To fetch the list of muting rules (with name and condition) for an account: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { mutingRules { name condition { operator conditions { attribute operator values } } } } } } } Copy Create muting rule To create a muting rule and return the muting rule's id for muting violations from NRQL conditions where host facet is host-1: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 mute rule\", description: \"Mute host-1 violations\", enabled: true, condition: { operator: AND, conditions: [{ attribute: \"tags.host\", operator: EQUALS, values: [\"host-1\"] }] } }) { id } } Copy Create muting rule for specific hosts or products To create a muting rule and return the muting rule's id for muting violations from Infrastructure conditions where the target host is host-1 or the violation was from Synthetic monitoring or Mobile products: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 and Synthetics/Mobile mute rule\", description: \"Mute host-1 and Synthetics/Mobile violations\", enabled: true, condition: { operator: OR, conditions: [ { attribute: \"targetName\", operator: EQUALS, values: [\"host-1\"] }, { attribute: \"product\", operator: IN, values: [\"SYNTHETICS\", \"MOBILE\"] } ] } }) { id } } Copy Create a muting rule with a recurring schedule To create a muting rule scheduled to repeat with these criteria: Weekly on Tuesday and Friday End on 01/31/2021 Return the muting rule's schedule and id mutation { alertsMutingRuleCreate( accountId: YOUR_ACCOUNT_ID, rule: { condition: { conditions: { attribute: \"conditionName\", operator: ANY, values: \"This is a condition\" }, operator: AND }, enabled: true, name: \"Recur Weekly\", schedule: { startTime: \"2020-12-01T12:00:00\", endTime: \"2020-12-01T14:00:00\", timeZone: \"America/Los_Angeles\", repeat: WEEKLY, endRepeat: \"2021-01-31T12:00:00\", weeklyRepeatDays: [TUESDAY, FRIDAY] } } ) { id schedule { endTime startTime timeZone repeat repeatCount endRepeat weeklyRepeatDays nextStartTime nextEndTime } } } Copy Rename and disable muting rule To change the name and disable a muting rule and return its new name: mutation { alertsMutingRuleUpdate(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID, rule: { name: \"updated name\", enabled: false }) { name } } Copy Delete muting rule To delete a muting rule: mutation { alertsMutingRuleDelete(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.50336,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Muting rules: Suppress <em>notifications</em>",
        "sections": "Muting rules: Suppress <em>notifications</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " define muting rules that specifically target those elements, while letting other <em>notifications</em> through. Even when a notification is muted, <em>Alerts</em> still gathers data on those violations. Muting rules don&#x27;t interfere with the <em>alerts</em> process and are <em>applied</em> at the point right before a notification"
      },
      "id": "60440c4728ccbc9c612c60c7"
    },
    {
      "sections": [
        "Customize your webhook payload",
        "Define webhooks",
        "Webhook values",
        "Targets values",
        "Webhook format example",
        "JSON webhook example",
        "Important",
        "Form webhook example",
        "Plain text output",
        "Microsoft Teams example"
      ],
      "title": "Customize your webhook payload",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "26f483edd4fd0bf049a3d3e6c5885788dcdfdd46",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/customize-your-webhook-payload/",
      "published_at": "2021-06-02T20:58:08Z",
      "updated_at": "2021-05-16T08:48:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use webhooks as your alerts notification channel, you can use the default values. You can also customize the payload in the POST message for further integration into your system. Define webhooks When defining JSON webhooks, use the format \"name\":\"value\",. For example: \"current_state\":\"acknowledged\", Copy When defining static webhook variables in a form payload, use the format name=\"value\". For example: current_state=\"acknowledged\" Copy Do not include any custom, self-signed SSL certificates in your webhook. Our agents enable SSL by default. Due to our security policy, custom SSL certificates will not be imported into our Trust store. Webhook values We support these default dynamic webhook values. For your convenience, they are listed in alphabetical order, but you can define your webhook values in any order. You may also add custom variables by using your own key/value pairs. Key Variable \"account_id\" $ACCOUNT_ID Possible values: New Relic account ID (string) \"account_name\" $ACCOUNT_NAME Possible values: New Relic account name (string) \"closed_violations_count_critical\" $CLOSED_VIOLATIONS_COUNT_CRITICAL \"closed_violations_count_warning\" $CLOSED_VIOLATIONS_COUNT_WARNING \"condition_id\" $CONDITION_ID \"condition_description\" $DESCRIPTION This includes the description field from the alert condition, if there is one. \"condition_name\" $CONDITION_NAME Possible values: (user-defined string) \"current_state\" $EVENT_STATE Possible values: [open|acknowledged|closed] \"details\" $EVENT_DETAILS \"duration\" $DURATION \"event_type\" $EVENT_TYPE Possible values: [INCIDENT] \"incident_acknowledge_url\" $INCIDENT_ACKNOWLEDGE_URL \"incident_id\" $INCIDENT_ID \"incident_url\" $INCIDENT_URL \"metadata\" $METADATA Currently used only for Synthetic monitoring multi-location failure conditions. \"open_violations_count_critical\" $OPEN_VIOLATIONS_COUNT_CRITICAL \"open_violations_count_warning\" $OPEN_VIOLATIONS_COUNT_WARNING \"owner\" $EVENT_OWNER \"policy_name\" $POLICY_NAME Possible values: (user-defined string) \"policy_url\" $POLICY_URL \"runbook_url\" $RUNBOOK_URL \"severity\" $SEVERITY Possible values: [CRITICAL] \"targets\" $TARGETS The $TARGETS variable cannot be used with FORM data, but is compatible with JSON data. For static NRQL faceted alerts, the name of the facet that triggered the alert will be populated in the target’s name field. For a description of the available fields, see Target values. \"timestamp\" $TIMESTAMP \"timestamp_utc_string\" $TIMESTAMP_UTC_STRING A human-readable timestamp in the YYYY-MM-DD, HH:MM UTC format. \"version\" $VERSION \"violation_callback_url\" $VIOLATION_CALLBACK_URL \"violation_chart_url\" $VIOLATION_CHART_URL Targets values This section describes the $TARGETS field in your webhook. This data is not customizable and is provided here for reference. Your $TARGETS contain a list of zero or more targets (entities). Each target is described by a JSON object with the following fields. Key Variable \"id\" ID of the target or entity \"name\" Name of the target or entity \"labels\" Combined entity tags and NRQL facets that are derived from the condition evaluation and available entity tags. \"link\" URL link to this target or entity. \"product\" Type of product for this target or entity; for example, APM \"type\" Type of target or entity under product; for example, Application Webhook format example The following examples show a webhook payload using both the default dynamic variables and a custom variable. You can use some or all of the dynamic variables, along with any custom variables, to define your own payload. JSON webhook example Important The following webhook example has extra spaces and line breaks for readability. Actual webhook responses are delivered as one continuous line of text. The \"team\": \"DevOps\" line is an example of a custom variable. { \"account_id\": \"$ACCOUNT_ID\", \"account_name\": \"$ACCOUNT_NAME\", \"closed_violations_count_critical\": \"$CLOSED_VIOLATIONS_COUNT_CRITICAL\", \"closed_violations_count_warning\": \"$CLOSED_VIOLATIONS_COUNT_WARNING\", \"condition_family_id\": \"$CONDITION_FAMILY_ID\", \"condition_id\": \"$CONDITION_ID\", \"condition_name\": \"$CONDITION_NAME\", \"current_state\": \"$EVENT_STATE\", \"details\": \"$EVENT_DETAILS\", \"duration\": \"$DURATION\", \"event_type\": \"$EVENT_TYPE\", \"incident_acknowledge_url\": \"$INCIDENT_ACKNOWLEDGE_URL\", \"incident_id\": \"$INCIDENT_ID\", \"incident_url\": \"$INCIDENT_URL\", \"open_violations_count_critical\": \"$OPEN_VIOLATIONS_COUNT_CRITICAL\", \"open_violations_count_warning\": \"$OPEN_VIOLATIONS_COUNT_WARNING\", \"owner\": \"$EVENT_OWNER\", \"policy_name\": \"$POLICY_NAME\", \"policy_url\": \"$POLICY_URL\", \"runbook_url\": \"$RUNBOOK_URL\", \"severity\": \"$SEVERITY\", \"targets\": \"$TARGETS\", \"timestamp\": \"$TIMESTAMP\", \"timestamp_utc_string\": \"$TIMESTAMP_UTC_STRING\", \"violation_callback_url\": \"$VIOLATION_CALLBACK_URL\", \"violation_chart_url\": \"$VIOLATION_CHART_URL\", \"team\": \"DevOps\" } Copy Form webhook example Important The following webhook example has extra spaces and line breaks for readability. Actual webhook responses are delivered as one continuous line of text. account_id=$ACCOUNT_ID account_name=$ACCOUNT_NAME closed_violations_count_critical=$CLOSED_VIOLATIONS_COUNT_CRITICAL closed_violations_count_warning=$CLOSED_VIOLATIONS_COUNT_WARNING condition_family_id=$CONDITION_FAMILY_ID condition_id=$CONDITION_ID condition_name=$CONDITION_NAME current_state=$EVENT_STATE details=$EVENT_DETAILS duration=$DURATION event_type=$EVENT_TYPE incident_acknowledge_url=$INCIDENT_ACKNOWLEDGE_URL incident_id=$INCIDENT_ID incident_url=$INCIDENT_URL open_violations_count_critical=$OPEN_VIOLATIONS_COUNT_CRITICAL open_violations_count_warning=$OPEN_VIOLATIONS_COUNT_WARNING owner=$EVENT_OWNER policy_name=$POLICY_NAME policy_url=$POLICY_URL runbook_url=$RUNBOOK_URL severity=$SEVERITY timestamp=$TIMESTAMP timestamp_utc_string=$TIMESTAMP_UTC_STRING violation_callback_url=$VIOLATION_CALLBACK_URL violation_chart_url=$VIOLATION_CHART_URL team=\"DevOps\" <--[example of custom variable] Copy Plain text output New Relic Alert Incident open: CPU > 50% for 5 minutes Policy: http://alerts.newrelic.com/accounts/1234/policies/5678 Chart URL: http://gorgon.nr-assets.net/image/12345678-abcd-efgh-ijkl-1234567890 For more details, see: http://alerts.newrelic.com/accounts/1234/incidents/3456 Copy Microsoft Teams example { \"@type\": \"MessageCard\", \"@context\": \"http://schema.org/extensions\", \"themeColor\": \"0076D7\", \"summary\": \"$CONDITION_NAME\", \"sections\": [{ \"activityTitle\": \"$CONDITION_NAME\", \"activitySubtitle\": \"$POLICY_NAME\", \"activityImage\": \"https://newrelic.com/themes/custom/curio/assets/mediakit/NR_logo_Horizontal_Rev.png\", \"facts\": [{ \"name\": \"Timestamp\", \"value\": \"$TIMESTAMP_UTC_STRING\" }, { \"name\": \"Account ID\", \"value\": \"$ACCOUNT_ID\" }, { \"name\": \"Account Name\", \"value\": \"$ACCOUNT_NAME\" }, { \"name\": \"Severity\", \"value\": \"$SEVERITY\" }, { \"name\": \"State\", \"value\": \"$EVENT_STATE\" }, { \"name\": \"Duration\", \"value\": \"$DURATION\" }, { \"name\": \"Details\", \"value\": \"$EVENT_DETAILS\" }], \"markdown\": true }, { \"text\": \"$METADATA<p><img src=\\\"$VIOLATION_CHART_URL\\\" alt=\\\"Incident Chart\\\"></img></p>\" }], \"potentialAction\": [{ \"@type\": \"OpenUri\", \"name\": \"View Incident\", \"targets\": [{ \"os\": \"default\", \"uri\": \"$INCIDENT_URL\" }] }, { \"@type\": \"OpenUri\", \"name\": \"Aknowledge Incident\", \"targets\": [{ \"os\": \"default\", \"uri\": \"$INCIDENT_ACKNOWLEDGE_URL\" }] }, { \"@type\": \"OpenUri\", \"name\": \"Open Runbook\", \"targets\": [{ \"os\": \"default\", \"uri\": \"$RUNBOOK_URL\" }] }] } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.42693,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "=$POLICY_URL runbook_url=$RUNBOOK_URL severity=$SEVERITY timestamp=$TIMESTAMP timestamp_utc_string=$TIMESTAMP_UTC_STRING violation_callback_url=$VIOLATION_CALLBACK_URL violation_chart_url=$VIOLATION_CHART_URL team=&quot;DevOps&quot; &lt;--[example of custom variable] Copy Plain text output <em>New</em> <em>Relic</em> <em>Alert</em> Incident open"
      },
      "id": "603ed08e28ccbcbdcdeba74a"
    },
    {
      "sections": [
        "Incident Intelligence destination examples",
        "Destination template examples",
        "Suggested OpsGenie template example",
        "Suggested ServiceNow template example",
        "Suggested Slack template example",
        "Suggested VictorOps template example",
        "Webhook and JSON format examples",
        "Webhook format and JSON example",
        "Jinja2 Default Payload",
        "Jinja2 Useful Syntax",
        "JSON schema",
        "JSON schema template"
      ],
      "title": "Incident Intelligence destination examples",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "a516d04f8b75541a6dc9338fa3ce9645ba87d620",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/incident-intelligence-destination-examples/",
      "published_at": "2021-06-02T18:22:22Z",
      "updated_at": "2021-06-02T18:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Destinations are the data outputs to Applied Intelligence, where you can view your automatically correlated incidents. You can configure Incident Intelligence destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema. Destination template examples The following template example destinations are formatted in Jinja2. Suggested OpsGenie template example { \"alias\": {{ id }}, \"message\": {{ ui_name }}, \"source\": '{{ sources }}', \"priority\": {{ priority }}, \"details\": { \"self_url\": {{ url }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"is_correlated\": {{ is_correlated }} }, \"description\": \"\"\"Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]\"\"\" } Copy Suggested ServiceNow template example { \"short_description\": {{ ui_name }}, \"description\": 'Issue Id: {{ id }}, \\n Description: {{ description }}, \\n Sources: {{ sources }}, \\n Priority: {{ priority }}, \\n Details: { \\n self_url: {{ url }}, \\n state: {{ state }}, \\n is_correlated: {{ is_correlated }}, \\n created_on: {{ created_on }}, \\n modified_on: {{ modified_on }}, \\n activated_on: {{ active_since }}, \\n closed_on: {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \\n is_correlated: {{is_correlated}} }, \\n\\n incidents: {{ incidents }}, \\n\\n pathways: {{ pathways }}' } Copy Suggested Slack template example Go to Slack incoming WebHooks Choose the right Slack workspace and click \"Add to Slack\" Select the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In New Relic Applied Intelligence, under Incident Intelligence click Destinations Add a WebHook In the end point paste the WebHook url from slack. In the custom payload, paste the following JSON: { \"blocks\": [ { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*New Relic Incident Intelligence Alert*\" } }, { \"type\": \"divider\" }, { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*CUSTOM FIELDS*:\" }, \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue ID*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Issue Title*\" }, { \"type\": \"plain_text\", \"text\": {{ id }} }, { \"type\": \"plain_text\", \"text\": {{ ui_name }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue URL*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Description*\" }, { \"type\": \"mrkdwn\", \"text\": {{ url }} }, { \"type\": \"plain_text\", \"text\": {{ description }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*State*\" }, { \"type\": \"mrkdwn\", \"text\": \"*is_correlated*\" }, { \"type\": \"plain_text\", \"text\": {{ state }} }, { \"type\": \"plain_text\", \"text\": \"{{ is_correlated }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Created On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Modified On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ created_on }}\" }, { \"type\": \"plain_text\", \"text\": \"{{ modified_on }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Activated On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Closed On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ active_since }}\" }, { \"type\": \"plain_text\", \"text\": \"{% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Aggregated Incidents*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Monitoring Tool*\" }, { \"type\": \"plain_text\", \"text\": \"{{ incident_count }}\" }, { \"type\": \"plain_text\", \"text\": {{ sources|join(', ') }} } ] } ] } Copy Suggested VictorOps template example { \"monitoring_tool\": {{ sources }}, {% if state == 'closed' %} \"message_type\": \"OK\", {% else %} \"message_type\": {{ priority }}, {% endif %} \"custom_fields\": { \"issue_url\": {{ url }}, \"description\": {{ description }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"related_incidents\": [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %} {% endfor %} ] }, \"state_message\": {{ description }}, \"entity_id\": {{ id }}, \"entity_display_name\": {{ ui_name }}, \"vo_annotate.u.NRAI_Link\": {{ url }} } Copy Webhook and JSON format examples Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). If you use webhooks to configure Incident Intelligence destinations, use these examples of the webhook body format and JSON schema. Webhook format and JSON example Webhook format: Name Description url Href A link to the UI where the issue can be seen. id String Unique identifier for the issue. title String The issue title. description String The description of the issue. priority Enum The issue priority. Can be Critical, High, Medium, or Low. state Enum The issue status. Can be Active, Closed, or Acknowledged. is_correlated Boolean True if the issue is based on correlated data. created_on String The date and time the issue was created (in ISO format). modified_on String The date and time the issue was modified (in ISO format). active_since String The date and time the issue was activated (in ISO format). closed_on String The date and time the issue was closed (in ISO format). sources List(String) List of the different sources that were used to send the events into Applied Intelligence (for example: PagerDuty). pathways List(Pathways) List of pathways that are associated with the issue. Each pathway contains an id and name: [{“id”: “pathway id”, “name”: “pathway name”}]. pathways[].id String The pathway ID. pathways[].name String The pathway name. incidents List(Incident) List of incidents that are attached to the issue. The list contains only the latest 100 incidents. incidents[].id String The incident ID. incidents[].events_count Integer The number of events used to create the incident. incidents[].title String The incident title. incidents[].description String The incident description. incidents[].labels Dictionary (String) A string to string mapping of the incident labels. Labels represent the unique entities that are used to describe the incident. incidents[].priority Enum The incident priority. Can be Critical, High, Medium, or Low. incidents[].sources List(String) The incident source. incidents[].state Enum(open, closed) The incident state. incidents[].opened_on String The date and time the incident was opened (in ISO format). incidents[].closed_on String The date and time the incident was closed (in ISO format). ui_name String Issue title. accumulations['alert/signal'] String Issue analysis summary golden signal/s (if applicable). accumulations['alert/components'] String Issue analysis summary golden components (if applicable). Jinja2 Default Payload Applied Intelligence uses a templating framework called Jinja2 in the Webhook interface. Here is a default Jinja2 payload to use: { \"id\": {{ id }}, \"url\": {{ url }}, \"ui_name\": {{ ui_name }}, \"description\": {{ description }}, \"priority\": {{ priority }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"active_since\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"sources\": {{ sources }}, \"incidents\": {{ incidents }}, \"pathways\": {{ pathways }}, } Copy Jinja2 Useful Syntax Below are a few useful Jinja2 commands to help you format your output. Casting a value to integer Example: “severity”: {{ priority | int }} Copy If clause to check if an attribute’s value is set Example: \"golden_signals\": {% if accumulations['alert/signal'] is defined %} {{ accumulations['alert/signal'] }} {% else %} None {% endif %} Copy For loop to iterate of an array of values: Example: \"description\": 'Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]' Copy Check if an array attribute's value is set: Example: \"hostname_field\": {% if incidents[0].labels['newrelic/tag/hostname'] is defined %} {{ incidents[0].labels['newrelic/tag/hostname'] }} {% else %} None {% endif %} Copy JSON schema Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). JSON schema template JSON schema: { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"definitions\": { \"Labels\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"LabelsSet\": { \"type\": \"array\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"$ref\": \"#/definitions/Labels\" }, \"uniqueItems\": true }, }, \"Annotations\": { \"type\": \"object\", \"title\": \"Additional contextual information about the Entity\", \"description\": \"Fields like title, description and priority can be described as annotations since\\nthey represent some additional information about the Incident.\\nFor example, the rule that creates the entity can have some logic that will create a title annotation field.\\nThe title will change according to the latest event received by the entity and as more\\nevent will keep coming the field may change, all this as a decision by the rule.\\nA different rule may decide not to populate the title at all.\\nSince a title can also be produced from the labels themselves.\", \"properties\": { \"title\": { \"type\": \"string\", \"maxLength\": 10000 }, \"description\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"patternProperties\": { \".*\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"Accumulations\": { \"type\": \"object\", \"title\": \"Accumulated data about the Incident\", \"description\": \"For example an entity with the label: host_name: foo will include a accumulated list of the\\nrelevant process names that are relevant to the entity. Accumulations will be derived from the events\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"type\": \"string\", \"maxLength\": 10000 } } }, \"IssueState\": { \"type\": \"string\", \"enum\": [ \"created\", \"active\", \"acknowledged\", \"closed\" ], \"properties\": {}, \"additionalProperties\": false }, \"Priority\": { \"type\": \"string\", \"enum\": [ \"critical\", \"high\", \"medium\", \"low\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueClosingReason\": { \"type\": \"string\", \"enum\": [ \"nacked\", \"resolved\", \"system\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueAction\": { \"type\": \"string\", \"enum\": [ \"ack\", \"snooze\", \"nack\", \"end_snooze\", \"expire_snooze\", \"star\", \"un_snooze\", \"unstar\", \"archive\", \"unarchive\", \"resolve\", \"reopen\", \"open\", \"feedback\", \"feedback_file\", \"open_ticket\", \"merge_issues\", \"active\", \"create\", \"close\", \"incident_updated\", \"confidence_changed\", \"diagnoses_changed\", \"rule_properties_changed\", \"flapping\", \"notification\", \"incident_events_limit_reached\", \"follow\", \"unfollow\", \"priority_updated\", \"comment\", \"incident_appended\", \"diagnosis_feedback\", \"flapping_delay_close\" ], \"properties\": {}, \"additionalProperties\": false }, \"StringKeyValue\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\" } }, \"JavaOptionalUuid\": { \"type\": \"string\", \"properties\": {}, \"additionalProperties\": false, \"format\": \"string-uuid\" } }, \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"customer_id\": { \"type\": \"integer\" }, \"labels_set\": { \"$ref\": \"#/definitions/LabelsSet\" }, \"annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations_version\": { \"type\": \"integer\" }, \"accumulations\": { \"$ref\": \"#/definitions/Accumulations\" }, \"state\": { \"$ref\": \"#/definitions/IssueState\" }, \"previous_state\": { \"$ref\": \"#/definitions/IssueState\" }, \"priority\": { \"$ref\": \"#/definitions/Priority\" }, \"closing_reason\": { \"oneOf\": [ { \"$ref\": \"#/definitions/IssueClosingReason\" }, { \"type\": \"null\" } ] }, \"modified_on\": { \"type\": \"integer\" }, \"created_on\": { \"type\": \"integer\" }, \"closed_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"acknowledged_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"active_since\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"assigned_to\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"created_by\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"progress_report\": { \"type\": \"array\", \"default\": [], \"items\": { \"type\": \"object\", \"properties\": { \"origin_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1 }, { \"type\": \"null\" } ] }, \"timestamp\": { \"type\": \"integer\" }, \"action_timestamp\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"origin_type\": { \"type\": \"string\", \"enum\": [ \"user\", \"system\" ] }, \"event_type\": { \"$ref\": \"#/definitions/IssueAction\" }, \"issue_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"format\": \"string-uuid\" }, { \"type\": \"null\" } ] }, \"attributes\": { \"oneOf\": [ { \"$ref\": \"#/definitions/StringKeyValue\" }, { \"type\": \"null\" } ] }, \"team_id\": { \"$ref\": \"#/definitions/JavaOptionalUuid\" } }, \"required\": [ \"timestamp\", \"origin_type\", \"event_type\" ], \"additionalProperties\": false }, \"uniqueItems\": true }, \"rule_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"maxLength\": 255 }, { \"type\": \"null\" } ] }, \"incident_ids\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"confidence\": { \"type\": \"number\", \"default\": 1.0, \"minimum\": 0.0, \"maximum\": 1.0 } }, \"required\": [ \"id\", \"customer_id\", \"labels_set\", \"annotations\", \"priority\", \"modified_on\", \"created_on\", \"confidence\" ], \"additionalProperties\": true } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.20966,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Incident <em>Intelligence</em> destination examples",
        "sections": "Incident <em>Intelligence</em> destination examples",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " the destination channel to receive the <em>notifications</em> to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In <em>New</em> <em>Relic</em> <em>Applied</em> <em>Intelligence</em>, under Incident <em>Intelligence</em> click Destinations Add a WebHook In the end point paste the WebHook url"
      },
      "id": "6044280d64441f4af5378ed3"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/test-alert-notification-channels": [
    {
      "sections": [
        "Muting rules: Suppress notifications",
        "Manage muting rules",
        "Create a muting rule",
        "Tip",
        "Schedule a muting rule",
        "Manage muting rules with NerdGraph",
        "How muting rules work",
        "Muting behavior",
        "View muted violations and incidents",
        "An incident with a critical violation that's been muted",
        "An incident that has been muted",
        "A list of violations, some of which are muted",
        "A list of alert events, some of which are muted",
        "Mute faceted results using tags.",
        "Sub-condition operators",
        "Muting examples",
        "Fetch muting rules for account",
        "Create muting rule",
        "Create muting rule for specific hosts or products",
        "Create a muting rule with a recurring schedule",
        "Rename and disable muting rule",
        "Delete muting rule"
      ],
      "title": "Muting rules: Suppress notifications",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "07d71869062b00bb820e52cf89fcb6a06ce523a4",
      "image": "https://docs.newrelic.com/static/595b1c9a595bf6a5c9175f5052298e88/03914/manage_muting_rules.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/muting-rules-suppress-notifications/",
      "published_at": "2021-05-27T19:23:09Z",
      "updated_at": "2021-05-16T09:31:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts sends out timely notifications when your system is having problems. Sometimes there are notifications you know you don't need to see. You can use muting rules to stop being bombarded by messages you don't want. Once you've spotted the common elements in your unwanted notifications, you can define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, Alerts still gathers data on those violations. Muting rules don't interfere with the alerts process and are applied at the point right before a notification is sent. You can read more about why we added muting rules in this blog post. Manage muting rules A muting rule condition is the set of individual expressions made up of attributes, operators, and values that define which violations to target for muting. You can create, enable, disable, and manage muting rules. Go to one.newrelic.com, in the top nav, click Alerts & AI, and then click Muting rules. Enable or disable muting rules at any time. Rules can have one of the following statuses: Active: Muting is enabled and active. Scheduled: Muting is enabled but not active yet (there's a future schedule). Ended: Muting is enabled, but no longer active (there's no future schedule). Inactive: Muting is disabled. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Create a muting rule Tip Before creating muting rules, you'll need to create policies and conditions that generate violation notifications. To create a muting rule, click + Add a rule in the Muting rules screen. Enter a name and a description for the muting rule, and select the account to which the rule will apply. Next, build the violation filter. You can use violation event attributes and sub-condition operators. Values can be compared against one of your violation attributes, such as an Alerts policy ID or a condition name. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Schedule a muting rule If needed, you can schedule your muting rules. To do this, select a start time and/or end time. Optionally, you can set the muting rule to last an entire day. You can also choose to select a time zone for the muting rule schedule. The default is the time zone selected in your user preferences. Flexible and powerful options for scheduling your muting rules. You can schedule your muting rules to recur daily, weekly, or monthly. A muting rule that's scheduled to repeat weekly includes the option to select the days of the week to recur. If no days are selected, the weekly recurrence will default to repeating on the day of the week that the muting rule is scheduled to start. You can also specify when you would like recurrence to end by selecting either a specific date or a certain number of occurrences. Manage muting rules with NerdGraph In NerdGraph, you can use the following queries and mutations with your muting rules. You can see the schema in more detail in the API Explorer. actor.account.alerts.mutingRule: Fetch a muting rule by id. actor.account.alerts.mutingRules: Fetch a list of muting rules for an account. alertsMutingRuleCreate: Create a muting rule for an account. alertsMutingRuleUpdate: Update a muting rule by id and account id. alertsMutingRuleDelete: Delete a muting rule by id and account id. We've given you some sample queries and mutations examples in this document. A muting rule has the following fields and components: Muting rule Fields and components id The unique identifier for the muting rule. name (Required) A text field for the user-friendly name of the muting rule. This is used when listing or referencing a rule. We don't require that the name be unique, but it is recommended. description This is an optional text field describing the muting rule. It can be a useful way to provide more context for your muting rule. This data is only used for management display purposes. accountId The muting rule's account ID. A muting rule will only affect violations that occur in a single account. To mute violations across multiple accounts, you'll need to create a muting rule for each account separately. createdAt The timestamp when the muting rule was created (UTC). createdBy The user ID of the person who created the muting rule. updatedAt The timestamp when the muting rule was last modified (UTC). updatedBy The user ID of the person who last modified the muting rule. enabled Enable or disable the muting rule (Boolean). Muting rules must be manually enabled and disabled. condition The set of individual expressions that define which violations to target. A muting rule condition has: operator: The boolean operator AND or OR that defines how to combine the set of conditions. conditions: The set of individual expressions (sub-conditions) that target attributes within a violation. These are evaluated together based on the operator. You can have a maximum of 20 sub-conditions for a single muting rule. A sub-condition has: attribute: A single attribute within a violation. Go here for a list of Violation event attributes. operator: The comparison function used to compare the selected violation attribute against values in the condition. Go here for a list of sub-condition operators. values: An array of string values to compare against selected violation attributes. When the muting rules evaluate a condition, if necessary, values will be coerced from strings. You can use a maximum of 500 values when using an operator that supports comparison against multiple values, such as IN. schedule The time window when the MutingRule actively mutes violations. startTime: The datetime stamp that represents when the muting rule starts. This is in local ISO 8601 format without an offset. Example: '2020-07-08T14:30:00' endTime: The datetime stamp that represents when the muting rule ends. This is in local ISO 8601 format without an offset. Example: '2020-07-15T14:30:00' timeZone: The time zone that applies to the muting rule schedule. Example: 'America/Los_Angeles'. See Wikipedia's list of tz database time zones. repeat: The frequency the muting rule schedule repeats. If it does not repeat, use null. Options are DAILY, WEEKLY, MONTHLY. endRepeat: The datetime stamp when the muting rule schedule stops repeating. This is in local ISO 8601 format without an offset. Example: '2020-07-10T15:00:00'. Note: Either endRepeat or repeatCount should be used to end a muting rule schedule. Both fields should not be provided together. repeatCount: The number of times the muting rule schedule repeats. This includes the original schedule. For example, a repeatCount of 2 will recur one time. A repeatCount of 3 will recur two times. Note: Either repeatCount or endRepeat can be used to end a muting rule schedule. Both fields should not be provided together. weeklyRepeatDays: The day(s) of the week that a muting rule should repeat when the repeat field is set to 'WEEKLY'. Example: [ 'MONDAY', 'WEDNESDAY']. How muting rules work Muting rules are applied at the end of the default alert lifecycle in order to suppress, or mute, notifications. They don't disable existing policies or conditions. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations will still be identified, even though the notifications for those violations are muted. A muting rule uses a set of conditions that match against attributes in a violation event. The muting rules tell us how to: Identify individual violations after they're created, but before an incident is opened. Override their default condition to indicate that they should be \"muted.\" Currently, muting a violation means that the normal Alerts incident lifecycle will be maintained, except that an incident that only contains muted violations will not send out any notifications. Muting rules override specific violations. They don't disable existing policies or conditions. This allows you to mute violations from specific entities that may be covered by a policy or condition that covers a large number of entities. This also keeps you from having to over-mute your monitoring when you are performing maintenance on a subset of your system. Muting behavior The following table describes how the Alerts incident lifecycle is affected by muted violations: IF AND THEN Event: Incident opens An incident opens because of a violation that is not muted An “Open incident” notification will be sent (default). An incident opens due to a violation that is muted An “Open incident” notification will not be sent (muted). Event: Violation added to an open incident A new muted violation is added to an already open incident No notification action is triggered (default). A new unmuted violation is added to an open incident An “Open incident” notification has not been sent An “Open incident” notification will be sent. A new unmuted violation is added to an open incident An “Open incident” notification has already been sent No notification action is triggered (default). Event: Incident closed An Incident is closed An “Open incident” notification has not been sent A “Close incident” notification will not be sent. An Incident is closed An “Open incident” notification has been sent A “Close incident” notification will be sent. Event: Incident acknowledged An Incident is acknowledged An “Open incident” notification has not been sent An “Incident acknowledged” notification will not be sent. An Incident is acknowledged An “Open incident” notification has been sent An “Incident acknowledged” notification will be sent. View muted violations and incidents When viewing an open or closed incident, violations and incidents are marked as Muted. The following sections show some of these muted violations and incidents, and where you can find them. An incident with a critical violation that's been muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Incidents. An incident that has been muted Violations and incidents are marked as Muted in the State column: Go to one.newrelic.com, and in the top nav click Alerts & AI, click Incidents, then click Open incidents. A list of violations, some of which are muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Events. A list of alert events, some of which are muted In the list of alert events, the State column shows which events have been muted. Go to one.newrelic.com, in the top nav click Alerts & AI, click Events, then click All events. Mute faceted results using tags. To mute results of faceted queries, use the tags.FACETED_ATTRIBUTE attribute, where FACETED_ATTRIBUTE represents the attributed you've run a NRQL FACET query on. For example: if your NRQL alert condition includes FACET host in its query, you can target that FACET attribute using tags.host. NRQL condition queries can accept multiple facet attributes. If you want to be able to filter from attributes in your events or metric time series that have been aggregated, you must add those attributes to your NRQL query FACET clause; for example: FACET host, region, cluster. For an example of using tags., see Create muting rule. Sub-condition operators The following are the logical operators available to use to compare attributes when you're constructing muting rules. For examples of these being used, see Examples. EQUALS: Where the supplied value equals the violation attribute value. NOT_EQUALS: Where the supplied value does not equal the violation attribute value. IN: Where the violation attribute value is present in a list of supplied values (up to 500). NOT_IN: Where the violation attribute value is not present in a list of supplied values (up to 500). CONTAINS: Where the supplied value string is present in the violation attribute value. NOT_CONTAINS: Where the supplied value string is not present in the violation attribute value. ANY: Caution: A condition with this operator will mute all violations on the account. IS_BLANK: Where the violation attribute value is blank. Null, empty string, etc. IS_NOT_BLANK: Where the violation attribute value is not blank. Null, empty string, etc. STARTS_WITH: Where the violation attribute value begins with the supplied value string. NOT_STARTS_WITH: Where the violation attribute value does not begin with the supplied value string. ENDS_WITH: Where the violation attribute value ends with the supplied value string. NOT_ENDS_WITH: Where the violation attribute value does not end with the supplied value string. Muting examples For more information about making requests to NerdGraph, see the NerdGraph documentation, including GraphQL tutorials. Fetch muting rules for account To fetch the list of muting rules (with name and condition) for an account: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { mutingRules { name condition { operator conditions { attribute operator values } } } } } } } Copy Create muting rule To create a muting rule and return the muting rule's id for muting violations from NRQL conditions where host facet is host-1: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 mute rule\", description: \"Mute host-1 violations\", enabled: true, condition: { operator: AND, conditions: [{ attribute: \"tags.host\", operator: EQUALS, values: [\"host-1\"] }] } }) { id } } Copy Create muting rule for specific hosts or products To create a muting rule and return the muting rule's id for muting violations from Infrastructure conditions where the target host is host-1 or the violation was from Synthetic monitoring or Mobile products: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 and Synthetics/Mobile mute rule\", description: \"Mute host-1 and Synthetics/Mobile violations\", enabled: true, condition: { operator: OR, conditions: [ { attribute: \"targetName\", operator: EQUALS, values: [\"host-1\"] }, { attribute: \"product\", operator: IN, values: [\"SYNTHETICS\", \"MOBILE\"] } ] } }) { id } } Copy Create a muting rule with a recurring schedule To create a muting rule scheduled to repeat with these criteria: Weekly on Tuesday and Friday End on 01/31/2021 Return the muting rule's schedule and id mutation { alertsMutingRuleCreate( accountId: YOUR_ACCOUNT_ID, rule: { condition: { conditions: { attribute: \"conditionName\", operator: ANY, values: \"This is a condition\" }, operator: AND }, enabled: true, name: \"Recur Weekly\", schedule: { startTime: \"2020-12-01T12:00:00\", endTime: \"2020-12-01T14:00:00\", timeZone: \"America/Los_Angeles\", repeat: WEEKLY, endRepeat: \"2021-01-31T12:00:00\", weeklyRepeatDays: [TUESDAY, FRIDAY] } } ) { id schedule { endTime startTime timeZone repeat repeatCount endRepeat weeklyRepeatDays nextStartTime nextEndTime } } } Copy Rename and disable muting rule To change the name and disable a muting rule and return its new name: mutation { alertsMutingRuleUpdate(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID, rule: { name: \"updated name\", enabled: false }) { name } } Copy Delete muting rule To delete a muting rule: mutation { alertsMutingRuleDelete(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.50333,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Muting rules: Suppress <em>notifications</em>",
        "sections": "Muting rules: Suppress <em>notifications</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " define muting rules that specifically target those elements, while letting other <em>notifications</em> through. Even when a notification is muted, <em>Alerts</em> still gathers data on those violations. Muting rules don&#x27;t interfere with the <em>alerts</em> process and are <em>applied</em> at the point right before a notification"
      },
      "id": "60440c4728ccbc9c612c60c7"
    },
    {
      "sections": [
        "Customize your webhook payload",
        "Define webhooks",
        "Webhook values",
        "Targets values",
        "Webhook format example",
        "JSON webhook example",
        "Important",
        "Form webhook example",
        "Plain text output",
        "Microsoft Teams example"
      ],
      "title": "Customize your webhook payload",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "26f483edd4fd0bf049a3d3e6c5885788dcdfdd46",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/customize-your-webhook-payload/",
      "published_at": "2021-06-02T20:58:08Z",
      "updated_at": "2021-05-16T08:48:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use webhooks as your alerts notification channel, you can use the default values. You can also customize the payload in the POST message for further integration into your system. Define webhooks When defining JSON webhooks, use the format \"name\":\"value\",. For example: \"current_state\":\"acknowledged\", Copy When defining static webhook variables in a form payload, use the format name=\"value\". For example: current_state=\"acknowledged\" Copy Do not include any custom, self-signed SSL certificates in your webhook. Our agents enable SSL by default. Due to our security policy, custom SSL certificates will not be imported into our Trust store. Webhook values We support these default dynamic webhook values. For your convenience, they are listed in alphabetical order, but you can define your webhook values in any order. You may also add custom variables by using your own key/value pairs. Key Variable \"account_id\" $ACCOUNT_ID Possible values: New Relic account ID (string) \"account_name\" $ACCOUNT_NAME Possible values: New Relic account name (string) \"closed_violations_count_critical\" $CLOSED_VIOLATIONS_COUNT_CRITICAL \"closed_violations_count_warning\" $CLOSED_VIOLATIONS_COUNT_WARNING \"condition_id\" $CONDITION_ID \"condition_description\" $DESCRIPTION This includes the description field from the alert condition, if there is one. \"condition_name\" $CONDITION_NAME Possible values: (user-defined string) \"current_state\" $EVENT_STATE Possible values: [open|acknowledged|closed] \"details\" $EVENT_DETAILS \"duration\" $DURATION \"event_type\" $EVENT_TYPE Possible values: [INCIDENT] \"incident_acknowledge_url\" $INCIDENT_ACKNOWLEDGE_URL \"incident_id\" $INCIDENT_ID \"incident_url\" $INCIDENT_URL \"metadata\" $METADATA Currently used only for Synthetic monitoring multi-location failure conditions. \"open_violations_count_critical\" $OPEN_VIOLATIONS_COUNT_CRITICAL \"open_violations_count_warning\" $OPEN_VIOLATIONS_COUNT_WARNING \"owner\" $EVENT_OWNER \"policy_name\" $POLICY_NAME Possible values: (user-defined string) \"policy_url\" $POLICY_URL \"runbook_url\" $RUNBOOK_URL \"severity\" $SEVERITY Possible values: [CRITICAL] \"targets\" $TARGETS The $TARGETS variable cannot be used with FORM data, but is compatible with JSON data. For static NRQL faceted alerts, the name of the facet that triggered the alert will be populated in the target’s name field. For a description of the available fields, see Target values. \"timestamp\" $TIMESTAMP \"timestamp_utc_string\" $TIMESTAMP_UTC_STRING A human-readable timestamp in the YYYY-MM-DD, HH:MM UTC format. \"version\" $VERSION \"violation_callback_url\" $VIOLATION_CALLBACK_URL \"violation_chart_url\" $VIOLATION_CHART_URL Targets values This section describes the $TARGETS field in your webhook. This data is not customizable and is provided here for reference. Your $TARGETS contain a list of zero or more targets (entities). Each target is described by a JSON object with the following fields. Key Variable \"id\" ID of the target or entity \"name\" Name of the target or entity \"labels\" Combined entity tags and NRQL facets that are derived from the condition evaluation and available entity tags. \"link\" URL link to this target or entity. \"product\" Type of product for this target or entity; for example, APM \"type\" Type of target or entity under product; for example, Application Webhook format example The following examples show a webhook payload using both the default dynamic variables and a custom variable. You can use some or all of the dynamic variables, along with any custom variables, to define your own payload. JSON webhook example Important The following webhook example has extra spaces and line breaks for readability. Actual webhook responses are delivered as one continuous line of text. The \"team\": \"DevOps\" line is an example of a custom variable. { \"account_id\": \"$ACCOUNT_ID\", \"account_name\": \"$ACCOUNT_NAME\", \"closed_violations_count_critical\": \"$CLOSED_VIOLATIONS_COUNT_CRITICAL\", \"closed_violations_count_warning\": \"$CLOSED_VIOLATIONS_COUNT_WARNING\", \"condition_family_id\": \"$CONDITION_FAMILY_ID\", \"condition_id\": \"$CONDITION_ID\", \"condition_name\": \"$CONDITION_NAME\", \"current_state\": \"$EVENT_STATE\", \"details\": \"$EVENT_DETAILS\", \"duration\": \"$DURATION\", \"event_type\": \"$EVENT_TYPE\", \"incident_acknowledge_url\": \"$INCIDENT_ACKNOWLEDGE_URL\", \"incident_id\": \"$INCIDENT_ID\", \"incident_url\": \"$INCIDENT_URL\", \"open_violations_count_critical\": \"$OPEN_VIOLATIONS_COUNT_CRITICAL\", \"open_violations_count_warning\": \"$OPEN_VIOLATIONS_COUNT_WARNING\", \"owner\": \"$EVENT_OWNER\", \"policy_name\": \"$POLICY_NAME\", \"policy_url\": \"$POLICY_URL\", \"runbook_url\": \"$RUNBOOK_URL\", \"severity\": \"$SEVERITY\", \"targets\": \"$TARGETS\", \"timestamp\": \"$TIMESTAMP\", \"timestamp_utc_string\": \"$TIMESTAMP_UTC_STRING\", \"violation_callback_url\": \"$VIOLATION_CALLBACK_URL\", \"violation_chart_url\": \"$VIOLATION_CHART_URL\", \"team\": \"DevOps\" } Copy Form webhook example Important The following webhook example has extra spaces and line breaks for readability. Actual webhook responses are delivered as one continuous line of text. account_id=$ACCOUNT_ID account_name=$ACCOUNT_NAME closed_violations_count_critical=$CLOSED_VIOLATIONS_COUNT_CRITICAL closed_violations_count_warning=$CLOSED_VIOLATIONS_COUNT_WARNING condition_family_id=$CONDITION_FAMILY_ID condition_id=$CONDITION_ID condition_name=$CONDITION_NAME current_state=$EVENT_STATE details=$EVENT_DETAILS duration=$DURATION event_type=$EVENT_TYPE incident_acknowledge_url=$INCIDENT_ACKNOWLEDGE_URL incident_id=$INCIDENT_ID incident_url=$INCIDENT_URL open_violations_count_critical=$OPEN_VIOLATIONS_COUNT_CRITICAL open_violations_count_warning=$OPEN_VIOLATIONS_COUNT_WARNING owner=$EVENT_OWNER policy_name=$POLICY_NAME policy_url=$POLICY_URL runbook_url=$RUNBOOK_URL severity=$SEVERITY timestamp=$TIMESTAMP timestamp_utc_string=$TIMESTAMP_UTC_STRING violation_callback_url=$VIOLATION_CALLBACK_URL violation_chart_url=$VIOLATION_CHART_URL team=\"DevOps\" <--[example of custom variable] Copy Plain text output New Relic Alert Incident open: CPU > 50% for 5 minutes Policy: http://alerts.newrelic.com/accounts/1234/policies/5678 Chart URL: http://gorgon.nr-assets.net/image/12345678-abcd-efgh-ijkl-1234567890 For more details, see: http://alerts.newrelic.com/accounts/1234/incidents/3456 Copy Microsoft Teams example { \"@type\": \"MessageCard\", \"@context\": \"http://schema.org/extensions\", \"themeColor\": \"0076D7\", \"summary\": \"$CONDITION_NAME\", \"sections\": [{ \"activityTitle\": \"$CONDITION_NAME\", \"activitySubtitle\": \"$POLICY_NAME\", \"activityImage\": \"https://newrelic.com/themes/custom/curio/assets/mediakit/NR_logo_Horizontal_Rev.png\", \"facts\": [{ \"name\": \"Timestamp\", \"value\": \"$TIMESTAMP_UTC_STRING\" }, { \"name\": \"Account ID\", \"value\": \"$ACCOUNT_ID\" }, { \"name\": \"Account Name\", \"value\": \"$ACCOUNT_NAME\" }, { \"name\": \"Severity\", \"value\": \"$SEVERITY\" }, { \"name\": \"State\", \"value\": \"$EVENT_STATE\" }, { \"name\": \"Duration\", \"value\": \"$DURATION\" }, { \"name\": \"Details\", \"value\": \"$EVENT_DETAILS\" }], \"markdown\": true }, { \"text\": \"$METADATA<p><img src=\\\"$VIOLATION_CHART_URL\\\" alt=\\\"Incident Chart\\\"></img></p>\" }], \"potentialAction\": [{ \"@type\": \"OpenUri\", \"name\": \"View Incident\", \"targets\": [{ \"os\": \"default\", \"uri\": \"$INCIDENT_URL\" }] }, { \"@type\": \"OpenUri\", \"name\": \"Aknowledge Incident\", \"targets\": [{ \"os\": \"default\", \"uri\": \"$INCIDENT_ACKNOWLEDGE_URL\" }] }, { \"@type\": \"OpenUri\", \"name\": \"Open Runbook\", \"targets\": [{ \"os\": \"default\", \"uri\": \"$RUNBOOK_URL\" }] }] } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.4269,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "=$POLICY_URL runbook_url=$RUNBOOK_URL severity=$SEVERITY timestamp=$TIMESTAMP timestamp_utc_string=$TIMESTAMP_UTC_STRING violation_callback_url=$VIOLATION_CALLBACK_URL violation_chart_url=$VIOLATION_CHART_URL team=&quot;DevOps&quot; &lt;--[example of custom variable] Copy Plain text output <em>New</em> <em>Relic</em> <em>Alert</em> Incident open"
      },
      "id": "603ed08e28ccbcbdcdeba74a"
    },
    {
      "sections": [
        "Notification channels: Control where to send alerts",
        "Tip",
        "View notification channels",
        "Add or remove notification channels",
        "Instructions for specific notification channels",
        "User",
        "Email",
        "OpsGenie",
        "PagerDuty",
        "Slack",
        "VictorOps",
        "Webhook",
        "Important",
        "Caution",
        "xMatters",
        "Receive mobile push notifications",
        "Acknowledge alert notifications"
      ],
      "title": "Notification channels: Control where to send alerts",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "8600dc86e59fad5da1e4a2b4170d2b86df78ee2f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/notification-channels-control-where-send-alerts/",
      "published_at": "2021-05-28T03:30:14Z",
      "updated_at": "2021-04-21T16:00:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use alerts to set up notification channels, and attach those channels to policies. Your selected channels provide fast and consistent ways for the right personnel to be notified about incidents. For example, notifications allow you to include charts about the incident to provide context and share them with your team. Alerts offers several notification channels, including webhooks, Slack rooms, email, and more. You'll be notified by your notification channels when incidents are opened, acknowledged, or closed. This document explains the available notification channels and how to set them up. Tip This document is about alerts notifications. For general information about unsubscribing from other New Relic emails, including marketing emails, weekly reports, and announcements, see Unsubscribe from New Relic emails. View notification channels To see all notification channels in your account: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. Add or remove notification channels To set up a new notification channel: On the Notification channels, click New notification channel. Select the type of channel and complete other required steps for it. To add or remove a notification policy or channel: Select a specific notification channel, select Alert policies, and add or remove a policy. OR Select a specific policy, select Notification channels, and add or remove a channel. Instructions for specific notification channels These are the available notification channel types. User Requirement: This feature is not available for users on the New Relic One user model, only to users on the original user model (learn about user model differences). As a workaround, you can use the email notification channel. Use the User notification channel to select existing account team members and admins. To view the Users list or to add users to alert policies: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. If a user has configured the New Relic mobile app, the user notification channel also sends push notifications to any of the user's registered mobile devices. If your account has one or more sub-accounts, the notification channel includes only users for the currently selected master or sub-account. Email We automatically add every individual and their email address on the selected account to the User notification channel and you can select them there. You don't need to add existing New Relic accounts to the Email channel. To add an email channel for other users, follow these guidelines: Field Description Email (required) In general, use the Email notification channel to identify user emails or email aliases that are not already on the selected account. For example, if you have a dev-ops@company.com email alias for your DevOps team, add the email alias to the Email channel. Otherwise, use the User notification channel to select specific users on your DevOps team. For easier maintenance, add a single non-user email address or alias to a single alert notification channel. If you want to use the email channel for more than one email, create an email group or alias outside your account. These email addresses can be the same as or different from email addresses already on your account. Users can unsubscribe from general (non-alerts-related) emails, but they cannot unsubscribe from alerts email notifications. Instead, the account Owner, Admin, or add-on manager must remove users from the policy's email notification channel. Include JSON attachment (optional) To include a JSON attachment with the email notification, select this checkbox. OpsGenie You must have an existing OpsGenie account integrated with New Relic in order to provide the following information: Field Description Channel name (required) A meaningful name for the OpsGenie notification channel (maximum 64 characters). API key (required) The API key generated from your OpsGenie integration used to authenticate API requests. Teams (optional) List of team names that are responsible for the alert. OpsGenie runs team escalation policies to calculate which users will receive notifications. Tags (optional) A comma-separated list of labels attached to the alert. Tip To overwrite the OpsGenie Quiet Hours setting for urgent alerts, add an OverwriteQuietHours tag. Recipients (optional) One or more names of users, groups, on-call schedules, escalation policies, etc., that OpsGenie uses to calculate where to send notifications. PagerDuty You must have an existing PagerDuty account in order to provide the following information: Field Description Service name (required) The name of your service integrating with PagerDuty for notifications. Integration key (required) The unique service identifier used by PagerDuty's Integration API to trigger, acknowledge, and resolve incidents for the service. Slack Before adding Slack notifications, you must create a unique webhook integration using Slack's New Relic integration. If you want web, transaction, server, and mobile alerts to be posted in separate channels, you must set up separate integrations for each one. Field Description Channel name (required) A meaningful name for the Slack notification channel (maximum 64 characters); for example, Network Ops Center. URL (required) Copy and paste the New Relic webhook integration URL that you've set up with Slack. For example: https://hooks.slack.com/services/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 Be sure to include https:// in the URL. Do not use http://. Team channel (optional) If used, include # before the name of the Slack channel where alert notifications are sent; for example, #NOC. VictorOps You must have an existing VictorOps account in order to provide the following required information: Field Description Channel name (required) A meaningful name for this notification channel (maximum 64 characters). For example, if the VictorOps Route key is for your Technical Support team, you could name this channel Tech Support - VictorOps. Key (required) VictorOps generates a unique key for each account. It maps the VictorOps account to its associated integrations. Route key (optional) This key maps the alert or incident to a specific team. Webhook Webhooks are HTTP POST messages containing JSON documents delivered to a destination URL. When an incident is opened, acknowledged, or closed, our webhook feature sends a message to your URL with any relevant information, such as a description of the event and a link back to New Relic. You also have the option to customize the payload in the POST message for further integration into your system. Important If your endpoint does not acknowledge the POST request within 10 seconds, the Alerts UI may indicate a failed notification event for the related incident. Before adding webhook notifications, you must have an endpoint set up to respond with a status code between 200 and 206 after receiving the following required information: Field Description Channel name (required) A meaningful name for the webhook (maximum 64 characters). Base url (required) The endpoint that will receive the POST message and trigger customized behaviors in your system. Caution If you want to include a port number in the webhook URL, make sure the port is available for requests. Otherwise the webhook will not work. Basic auth (optional) To require basic authentication for the webhook, select Add basic auth, and provide the user name and password to authenticate the webhook. Custom headers (optional) To include headers with webhooks, select Add custom headers, and provide the name and value for each header. Use custom payload (optional) To use the default values, leave blank. To view and edit the default values, select Add custom payload. Payload (for custom payloads only) Your customized POST message code. This field includes: A list of variables you can use Syntax highlighting, based on payload type Payload type (for custom payloads only) Specify the message format: JSON (default) or Form. xMatters You must have an existing xMatters account in order to provide the following information: Field Description Channel name (required) Name your channel so you can identify it easily when associating it with a policy. Integration url (required) The unique integration url provided by xMatters pointing to your xMatters account. Receive mobile push notifications Important In order to receive mobile push notifications, your device must be registered and listed in (account) > User preferences. If the device is not listed in User preferences, log out of the app, log back in, and check again to see if it is listed. To receive mobile push notifications: Log in to your New Relic account via the mobile app at least once to ensure the device is registered. Add the user channel to the alert policy. Switch push notifications On for the device. Acknowledge alert notifications Anyone in your account can acknowledge notifications through the user interface or email notification. Acknowledging an incident in New Relic also acknowledges any associated incident in PagerDuty.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 177.6083,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Notification</em> channels: Control where to send <em>alerts</em>",
        "sections": "<em>Notification</em> channels: Control where to send <em>alerts</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " them up. Tip This document is about <em>alerts</em> <em>notifications</em>. For general information about unsubscribing from other <em>New</em> <em>Relic</em> emails, including marketing emails, weekly reports, and announcements, see Unsubscribe from <em>New</em> <em>Relic</em> emails. View notification channels To see all notification channels in your"
      },
      "id": "603ecfbf64441f4ee54e885f"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/update-alert-notification-channels": [
    {
      "sections": [
        "Muting rules: Suppress notifications",
        "Manage muting rules",
        "Create a muting rule",
        "Tip",
        "Schedule a muting rule",
        "Manage muting rules with NerdGraph",
        "How muting rules work",
        "Muting behavior",
        "View muted violations and incidents",
        "An incident with a critical violation that's been muted",
        "An incident that has been muted",
        "A list of violations, some of which are muted",
        "A list of alert events, some of which are muted",
        "Mute faceted results using tags.",
        "Sub-condition operators",
        "Muting examples",
        "Fetch muting rules for account",
        "Create muting rule",
        "Create muting rule for specific hosts or products",
        "Create a muting rule with a recurring schedule",
        "Rename and disable muting rule",
        "Delete muting rule"
      ],
      "title": "Muting rules: Suppress notifications",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "07d71869062b00bb820e52cf89fcb6a06ce523a4",
      "image": "https://docs.newrelic.com/static/595b1c9a595bf6a5c9175f5052298e88/03914/manage_muting_rules.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/muting-rules-suppress-notifications/",
      "published_at": "2021-05-27T19:23:09Z",
      "updated_at": "2021-05-16T09:31:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts sends out timely notifications when your system is having problems. Sometimes there are notifications you know you don't need to see. You can use muting rules to stop being bombarded by messages you don't want. Once you've spotted the common elements in your unwanted notifications, you can define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, Alerts still gathers data on those violations. Muting rules don't interfere with the alerts process and are applied at the point right before a notification is sent. You can read more about why we added muting rules in this blog post. Manage muting rules A muting rule condition is the set of individual expressions made up of attributes, operators, and values that define which violations to target for muting. You can create, enable, disable, and manage muting rules. Go to one.newrelic.com, in the top nav, click Alerts & AI, and then click Muting rules. Enable or disable muting rules at any time. Rules can have one of the following statuses: Active: Muting is enabled and active. Scheduled: Muting is enabled but not active yet (there's a future schedule). Ended: Muting is enabled, but no longer active (there's no future schedule). Inactive: Muting is disabled. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Create a muting rule Tip Before creating muting rules, you'll need to create policies and conditions that generate violation notifications. To create a muting rule, click + Add a rule in the Muting rules screen. Enter a name and a description for the muting rule, and select the account to which the rule will apply. Next, build the violation filter. You can use violation event attributes and sub-condition operators. Values can be compared against one of your violation attributes, such as an Alerts policy ID or a condition name. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Schedule a muting rule If needed, you can schedule your muting rules. To do this, select a start time and/or end time. Optionally, you can set the muting rule to last an entire day. You can also choose to select a time zone for the muting rule schedule. The default is the time zone selected in your user preferences. Flexible and powerful options for scheduling your muting rules. You can schedule your muting rules to recur daily, weekly, or monthly. A muting rule that's scheduled to repeat weekly includes the option to select the days of the week to recur. If no days are selected, the weekly recurrence will default to repeating on the day of the week that the muting rule is scheduled to start. You can also specify when you would like recurrence to end by selecting either a specific date or a certain number of occurrences. Manage muting rules with NerdGraph In NerdGraph, you can use the following queries and mutations with your muting rules. You can see the schema in more detail in the API Explorer. actor.account.alerts.mutingRule: Fetch a muting rule by id. actor.account.alerts.mutingRules: Fetch a list of muting rules for an account. alertsMutingRuleCreate: Create a muting rule for an account. alertsMutingRuleUpdate: Update a muting rule by id and account id. alertsMutingRuleDelete: Delete a muting rule by id and account id. We've given you some sample queries and mutations examples in this document. A muting rule has the following fields and components: Muting rule Fields and components id The unique identifier for the muting rule. name (Required) A text field for the user-friendly name of the muting rule. This is used when listing or referencing a rule. We don't require that the name be unique, but it is recommended. description This is an optional text field describing the muting rule. It can be a useful way to provide more context for your muting rule. This data is only used for management display purposes. accountId The muting rule's account ID. A muting rule will only affect violations that occur in a single account. To mute violations across multiple accounts, you'll need to create a muting rule for each account separately. createdAt The timestamp when the muting rule was created (UTC). createdBy The user ID of the person who created the muting rule. updatedAt The timestamp when the muting rule was last modified (UTC). updatedBy The user ID of the person who last modified the muting rule. enabled Enable or disable the muting rule (Boolean). Muting rules must be manually enabled and disabled. condition The set of individual expressions that define which violations to target. A muting rule condition has: operator: The boolean operator AND or OR that defines how to combine the set of conditions. conditions: The set of individual expressions (sub-conditions) that target attributes within a violation. These are evaluated together based on the operator. You can have a maximum of 20 sub-conditions for a single muting rule. A sub-condition has: attribute: A single attribute within a violation. Go here for a list of Violation event attributes. operator: The comparison function used to compare the selected violation attribute against values in the condition. Go here for a list of sub-condition operators. values: An array of string values to compare against selected violation attributes. When the muting rules evaluate a condition, if necessary, values will be coerced from strings. You can use a maximum of 500 values when using an operator that supports comparison against multiple values, such as IN. schedule The time window when the MutingRule actively mutes violations. startTime: The datetime stamp that represents when the muting rule starts. This is in local ISO 8601 format without an offset. Example: '2020-07-08T14:30:00' endTime: The datetime stamp that represents when the muting rule ends. This is in local ISO 8601 format without an offset. Example: '2020-07-15T14:30:00' timeZone: The time zone that applies to the muting rule schedule. Example: 'America/Los_Angeles'. See Wikipedia's list of tz database time zones. repeat: The frequency the muting rule schedule repeats. If it does not repeat, use null. Options are DAILY, WEEKLY, MONTHLY. endRepeat: The datetime stamp when the muting rule schedule stops repeating. This is in local ISO 8601 format without an offset. Example: '2020-07-10T15:00:00'. Note: Either endRepeat or repeatCount should be used to end a muting rule schedule. Both fields should not be provided together. repeatCount: The number of times the muting rule schedule repeats. This includes the original schedule. For example, a repeatCount of 2 will recur one time. A repeatCount of 3 will recur two times. Note: Either repeatCount or endRepeat can be used to end a muting rule schedule. Both fields should not be provided together. weeklyRepeatDays: The day(s) of the week that a muting rule should repeat when the repeat field is set to 'WEEKLY'. Example: [ 'MONDAY', 'WEDNESDAY']. How muting rules work Muting rules are applied at the end of the default alert lifecycle in order to suppress, or mute, notifications. They don't disable existing policies or conditions. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations will still be identified, even though the notifications for those violations are muted. A muting rule uses a set of conditions that match against attributes in a violation event. The muting rules tell us how to: Identify individual violations after they're created, but before an incident is opened. Override their default condition to indicate that they should be \"muted.\" Currently, muting a violation means that the normal Alerts incident lifecycle will be maintained, except that an incident that only contains muted violations will not send out any notifications. Muting rules override specific violations. They don't disable existing policies or conditions. This allows you to mute violations from specific entities that may be covered by a policy or condition that covers a large number of entities. This also keeps you from having to over-mute your monitoring when you are performing maintenance on a subset of your system. Muting behavior The following table describes how the Alerts incident lifecycle is affected by muted violations: IF AND THEN Event: Incident opens An incident opens because of a violation that is not muted An “Open incident” notification will be sent (default). An incident opens due to a violation that is muted An “Open incident” notification will not be sent (muted). Event: Violation added to an open incident A new muted violation is added to an already open incident No notification action is triggered (default). A new unmuted violation is added to an open incident An “Open incident” notification has not been sent An “Open incident” notification will be sent. A new unmuted violation is added to an open incident An “Open incident” notification has already been sent No notification action is triggered (default). Event: Incident closed An Incident is closed An “Open incident” notification has not been sent A “Close incident” notification will not be sent. An Incident is closed An “Open incident” notification has been sent A “Close incident” notification will be sent. Event: Incident acknowledged An Incident is acknowledged An “Open incident” notification has not been sent An “Incident acknowledged” notification will not be sent. An Incident is acknowledged An “Open incident” notification has been sent An “Incident acknowledged” notification will be sent. View muted violations and incidents When viewing an open or closed incident, violations and incidents are marked as Muted. The following sections show some of these muted violations and incidents, and where you can find them. An incident with a critical violation that's been muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Incidents. An incident that has been muted Violations and incidents are marked as Muted in the State column: Go to one.newrelic.com, and in the top nav click Alerts & AI, click Incidents, then click Open incidents. A list of violations, some of which are muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Events. A list of alert events, some of which are muted In the list of alert events, the State column shows which events have been muted. Go to one.newrelic.com, in the top nav click Alerts & AI, click Events, then click All events. Mute faceted results using tags. To mute results of faceted queries, use the tags.FACETED_ATTRIBUTE attribute, where FACETED_ATTRIBUTE represents the attributed you've run a NRQL FACET query on. For example: if your NRQL alert condition includes FACET host in its query, you can target that FACET attribute using tags.host. NRQL condition queries can accept multiple facet attributes. If you want to be able to filter from attributes in your events or metric time series that have been aggregated, you must add those attributes to your NRQL query FACET clause; for example: FACET host, region, cluster. For an example of using tags., see Create muting rule. Sub-condition operators The following are the logical operators available to use to compare attributes when you're constructing muting rules. For examples of these being used, see Examples. EQUALS: Where the supplied value equals the violation attribute value. NOT_EQUALS: Where the supplied value does not equal the violation attribute value. IN: Where the violation attribute value is present in a list of supplied values (up to 500). NOT_IN: Where the violation attribute value is not present in a list of supplied values (up to 500). CONTAINS: Where the supplied value string is present in the violation attribute value. NOT_CONTAINS: Where the supplied value string is not present in the violation attribute value. ANY: Caution: A condition with this operator will mute all violations on the account. IS_BLANK: Where the violation attribute value is blank. Null, empty string, etc. IS_NOT_BLANK: Where the violation attribute value is not blank. Null, empty string, etc. STARTS_WITH: Where the violation attribute value begins with the supplied value string. NOT_STARTS_WITH: Where the violation attribute value does not begin with the supplied value string. ENDS_WITH: Where the violation attribute value ends with the supplied value string. NOT_ENDS_WITH: Where the violation attribute value does not end with the supplied value string. Muting examples For more information about making requests to NerdGraph, see the NerdGraph documentation, including GraphQL tutorials. Fetch muting rules for account To fetch the list of muting rules (with name and condition) for an account: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { mutingRules { name condition { operator conditions { attribute operator values } } } } } } } Copy Create muting rule To create a muting rule and return the muting rule's id for muting violations from NRQL conditions where host facet is host-1: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 mute rule\", description: \"Mute host-1 violations\", enabled: true, condition: { operator: AND, conditions: [{ attribute: \"tags.host\", operator: EQUALS, values: [\"host-1\"] }] } }) { id } } Copy Create muting rule for specific hosts or products To create a muting rule and return the muting rule's id for muting violations from Infrastructure conditions where the target host is host-1 or the violation was from Synthetic monitoring or Mobile products: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 and Synthetics/Mobile mute rule\", description: \"Mute host-1 and Synthetics/Mobile violations\", enabled: true, condition: { operator: OR, conditions: [ { attribute: \"targetName\", operator: EQUALS, values: [\"host-1\"] }, { attribute: \"product\", operator: IN, values: [\"SYNTHETICS\", \"MOBILE\"] } ] } }) { id } } Copy Create a muting rule with a recurring schedule To create a muting rule scheduled to repeat with these criteria: Weekly on Tuesday and Friday End on 01/31/2021 Return the muting rule's schedule and id mutation { alertsMutingRuleCreate( accountId: YOUR_ACCOUNT_ID, rule: { condition: { conditions: { attribute: \"conditionName\", operator: ANY, values: \"This is a condition\" }, operator: AND }, enabled: true, name: \"Recur Weekly\", schedule: { startTime: \"2020-12-01T12:00:00\", endTime: \"2020-12-01T14:00:00\", timeZone: \"America/Los_Angeles\", repeat: WEEKLY, endRepeat: \"2021-01-31T12:00:00\", weeklyRepeatDays: [TUESDAY, FRIDAY] } } ) { id schedule { endTime startTime timeZone repeat repeatCount endRepeat weeklyRepeatDays nextStartTime nextEndTime } } } Copy Rename and disable muting rule To change the name and disable a muting rule and return its new name: mutation { alertsMutingRuleUpdate(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID, rule: { name: \"updated name\", enabled: false }) { name } } Copy Delete muting rule To delete a muting rule: mutation { alertsMutingRuleDelete(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.50333,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Muting rules: Suppress <em>notifications</em>",
        "sections": "Muting rules: Suppress <em>notifications</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " define muting rules that specifically target those elements, while letting other <em>notifications</em> through. Even when a notification is muted, <em>Alerts</em> still gathers data on those violations. Muting rules don&#x27;t interfere with the <em>alerts</em> process and are <em>applied</em> at the point right before a notification"
      },
      "id": "60440c4728ccbc9c612c60c7"
    },
    {
      "sections": [
        "Customize your webhook payload",
        "Define webhooks",
        "Webhook values",
        "Targets values",
        "Webhook format example",
        "JSON webhook example",
        "Important",
        "Form webhook example",
        "Plain text output",
        "Microsoft Teams example"
      ],
      "title": "Customize your webhook payload",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "26f483edd4fd0bf049a3d3e6c5885788dcdfdd46",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/customize-your-webhook-payload/",
      "published_at": "2021-06-02T20:58:08Z",
      "updated_at": "2021-05-16T08:48:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use webhooks as your alerts notification channel, you can use the default values. You can also customize the payload in the POST message for further integration into your system. Define webhooks When defining JSON webhooks, use the format \"name\":\"value\",. For example: \"current_state\":\"acknowledged\", Copy When defining static webhook variables in a form payload, use the format name=\"value\". For example: current_state=\"acknowledged\" Copy Do not include any custom, self-signed SSL certificates in your webhook. Our agents enable SSL by default. Due to our security policy, custom SSL certificates will not be imported into our Trust store. Webhook values We support these default dynamic webhook values. For your convenience, they are listed in alphabetical order, but you can define your webhook values in any order. You may also add custom variables by using your own key/value pairs. Key Variable \"account_id\" $ACCOUNT_ID Possible values: New Relic account ID (string) \"account_name\" $ACCOUNT_NAME Possible values: New Relic account name (string) \"closed_violations_count_critical\" $CLOSED_VIOLATIONS_COUNT_CRITICAL \"closed_violations_count_warning\" $CLOSED_VIOLATIONS_COUNT_WARNING \"condition_id\" $CONDITION_ID \"condition_description\" $DESCRIPTION This includes the description field from the alert condition, if there is one. \"condition_name\" $CONDITION_NAME Possible values: (user-defined string) \"current_state\" $EVENT_STATE Possible values: [open|acknowledged|closed] \"details\" $EVENT_DETAILS \"duration\" $DURATION \"event_type\" $EVENT_TYPE Possible values: [INCIDENT] \"incident_acknowledge_url\" $INCIDENT_ACKNOWLEDGE_URL \"incident_id\" $INCIDENT_ID \"incident_url\" $INCIDENT_URL \"metadata\" $METADATA Currently used only for Synthetic monitoring multi-location failure conditions. \"open_violations_count_critical\" $OPEN_VIOLATIONS_COUNT_CRITICAL \"open_violations_count_warning\" $OPEN_VIOLATIONS_COUNT_WARNING \"owner\" $EVENT_OWNER \"policy_name\" $POLICY_NAME Possible values: (user-defined string) \"policy_url\" $POLICY_URL \"runbook_url\" $RUNBOOK_URL \"severity\" $SEVERITY Possible values: [CRITICAL] \"targets\" $TARGETS The $TARGETS variable cannot be used with FORM data, but is compatible with JSON data. For static NRQL faceted alerts, the name of the facet that triggered the alert will be populated in the target’s name field. For a description of the available fields, see Target values. \"timestamp\" $TIMESTAMP \"timestamp_utc_string\" $TIMESTAMP_UTC_STRING A human-readable timestamp in the YYYY-MM-DD, HH:MM UTC format. \"version\" $VERSION \"violation_callback_url\" $VIOLATION_CALLBACK_URL \"violation_chart_url\" $VIOLATION_CHART_URL Targets values This section describes the $TARGETS field in your webhook. This data is not customizable and is provided here for reference. Your $TARGETS contain a list of zero or more targets (entities). Each target is described by a JSON object with the following fields. Key Variable \"id\" ID of the target or entity \"name\" Name of the target or entity \"labels\" Combined entity tags and NRQL facets that are derived from the condition evaluation and available entity tags. \"link\" URL link to this target or entity. \"product\" Type of product for this target or entity; for example, APM \"type\" Type of target or entity under product; for example, Application Webhook format example The following examples show a webhook payload using both the default dynamic variables and a custom variable. You can use some or all of the dynamic variables, along with any custom variables, to define your own payload. JSON webhook example Important The following webhook example has extra spaces and line breaks for readability. Actual webhook responses are delivered as one continuous line of text. The \"team\": \"DevOps\" line is an example of a custom variable. { \"account_id\": \"$ACCOUNT_ID\", \"account_name\": \"$ACCOUNT_NAME\", \"closed_violations_count_critical\": \"$CLOSED_VIOLATIONS_COUNT_CRITICAL\", \"closed_violations_count_warning\": \"$CLOSED_VIOLATIONS_COUNT_WARNING\", \"condition_family_id\": \"$CONDITION_FAMILY_ID\", \"condition_id\": \"$CONDITION_ID\", \"condition_name\": \"$CONDITION_NAME\", \"current_state\": \"$EVENT_STATE\", \"details\": \"$EVENT_DETAILS\", \"duration\": \"$DURATION\", \"event_type\": \"$EVENT_TYPE\", \"incident_acknowledge_url\": \"$INCIDENT_ACKNOWLEDGE_URL\", \"incident_id\": \"$INCIDENT_ID\", \"incident_url\": \"$INCIDENT_URL\", \"open_violations_count_critical\": \"$OPEN_VIOLATIONS_COUNT_CRITICAL\", \"open_violations_count_warning\": \"$OPEN_VIOLATIONS_COUNT_WARNING\", \"owner\": \"$EVENT_OWNER\", \"policy_name\": \"$POLICY_NAME\", \"policy_url\": \"$POLICY_URL\", \"runbook_url\": \"$RUNBOOK_URL\", \"severity\": \"$SEVERITY\", \"targets\": \"$TARGETS\", \"timestamp\": \"$TIMESTAMP\", \"timestamp_utc_string\": \"$TIMESTAMP_UTC_STRING\", \"violation_callback_url\": \"$VIOLATION_CALLBACK_URL\", \"violation_chart_url\": \"$VIOLATION_CHART_URL\", \"team\": \"DevOps\" } Copy Form webhook example Important The following webhook example has extra spaces and line breaks for readability. Actual webhook responses are delivered as one continuous line of text. account_id=$ACCOUNT_ID account_name=$ACCOUNT_NAME closed_violations_count_critical=$CLOSED_VIOLATIONS_COUNT_CRITICAL closed_violations_count_warning=$CLOSED_VIOLATIONS_COUNT_WARNING condition_family_id=$CONDITION_FAMILY_ID condition_id=$CONDITION_ID condition_name=$CONDITION_NAME current_state=$EVENT_STATE details=$EVENT_DETAILS duration=$DURATION event_type=$EVENT_TYPE incident_acknowledge_url=$INCIDENT_ACKNOWLEDGE_URL incident_id=$INCIDENT_ID incident_url=$INCIDENT_URL open_violations_count_critical=$OPEN_VIOLATIONS_COUNT_CRITICAL open_violations_count_warning=$OPEN_VIOLATIONS_COUNT_WARNING owner=$EVENT_OWNER policy_name=$POLICY_NAME policy_url=$POLICY_URL runbook_url=$RUNBOOK_URL severity=$SEVERITY timestamp=$TIMESTAMP timestamp_utc_string=$TIMESTAMP_UTC_STRING violation_callback_url=$VIOLATION_CALLBACK_URL violation_chart_url=$VIOLATION_CHART_URL team=\"DevOps\" <--[example of custom variable] Copy Plain text output New Relic Alert Incident open: CPU > 50% for 5 minutes Policy: http://alerts.newrelic.com/accounts/1234/policies/5678 Chart URL: http://gorgon.nr-assets.net/image/12345678-abcd-efgh-ijkl-1234567890 For more details, see: http://alerts.newrelic.com/accounts/1234/incidents/3456 Copy Microsoft Teams example { \"@type\": \"MessageCard\", \"@context\": \"http://schema.org/extensions\", \"themeColor\": \"0076D7\", \"summary\": \"$CONDITION_NAME\", \"sections\": [{ \"activityTitle\": \"$CONDITION_NAME\", \"activitySubtitle\": \"$POLICY_NAME\", \"activityImage\": \"https://newrelic.com/themes/custom/curio/assets/mediakit/NR_logo_Horizontal_Rev.png\", \"facts\": [{ \"name\": \"Timestamp\", \"value\": \"$TIMESTAMP_UTC_STRING\" }, { \"name\": \"Account ID\", \"value\": \"$ACCOUNT_ID\" }, { \"name\": \"Account Name\", \"value\": \"$ACCOUNT_NAME\" }, { \"name\": \"Severity\", \"value\": \"$SEVERITY\" }, { \"name\": \"State\", \"value\": \"$EVENT_STATE\" }, { \"name\": \"Duration\", \"value\": \"$DURATION\" }, { \"name\": \"Details\", \"value\": \"$EVENT_DETAILS\" }], \"markdown\": true }, { \"text\": \"$METADATA<p><img src=\\\"$VIOLATION_CHART_URL\\\" alt=\\\"Incident Chart\\\"></img></p>\" }], \"potentialAction\": [{ \"@type\": \"OpenUri\", \"name\": \"View Incident\", \"targets\": [{ \"os\": \"default\", \"uri\": \"$INCIDENT_URL\" }] }, { \"@type\": \"OpenUri\", \"name\": \"Aknowledge Incident\", \"targets\": [{ \"os\": \"default\", \"uri\": \"$INCIDENT_ACKNOWLEDGE_URL\" }] }, { \"@type\": \"OpenUri\", \"name\": \"Open Runbook\", \"targets\": [{ \"os\": \"default\", \"uri\": \"$RUNBOOK_URL\" }] }] } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.4269,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "=$POLICY_URL runbook_url=$RUNBOOK_URL severity=$SEVERITY timestamp=$TIMESTAMP timestamp_utc_string=$TIMESTAMP_UTC_STRING violation_callback_url=$VIOLATION_CALLBACK_URL violation_chart_url=$VIOLATION_CHART_URL team=&quot;DevOps&quot; &lt;--[example of custom variable] Copy Plain text output <em>New</em> <em>Relic</em> <em>Alert</em> Incident open"
      },
      "id": "603ed08e28ccbcbdcdeba74a"
    },
    {
      "sections": [
        "Notification channels: Control where to send alerts",
        "Tip",
        "View notification channels",
        "Add or remove notification channels",
        "Instructions for specific notification channels",
        "User",
        "Email",
        "OpsGenie",
        "PagerDuty",
        "Slack",
        "VictorOps",
        "Webhook",
        "Important",
        "Caution",
        "xMatters",
        "Receive mobile push notifications",
        "Acknowledge alert notifications"
      ],
      "title": "Notification channels: Control where to send alerts",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "8600dc86e59fad5da1e4a2b4170d2b86df78ee2f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/notification-channels-control-where-send-alerts/",
      "published_at": "2021-05-28T03:30:14Z",
      "updated_at": "2021-04-21T16:00:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use alerts to set up notification channels, and attach those channels to policies. Your selected channels provide fast and consistent ways for the right personnel to be notified about incidents. For example, notifications allow you to include charts about the incident to provide context and share them with your team. Alerts offers several notification channels, including webhooks, Slack rooms, email, and more. You'll be notified by your notification channels when incidents are opened, acknowledged, or closed. This document explains the available notification channels and how to set them up. Tip This document is about alerts notifications. For general information about unsubscribing from other New Relic emails, including marketing emails, weekly reports, and announcements, see Unsubscribe from New Relic emails. View notification channels To see all notification channels in your account: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. Add or remove notification channels To set up a new notification channel: On the Notification channels, click New notification channel. Select the type of channel and complete other required steps for it. To add or remove a notification policy or channel: Select a specific notification channel, select Alert policies, and add or remove a policy. OR Select a specific policy, select Notification channels, and add or remove a channel. Instructions for specific notification channels These are the available notification channel types. User Requirement: This feature is not available for users on the New Relic One user model, only to users on the original user model (learn about user model differences). As a workaround, you can use the email notification channel. Use the User notification channel to select existing account team members and admins. To view the Users list or to add users to alert policies: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. If a user has configured the New Relic mobile app, the user notification channel also sends push notifications to any of the user's registered mobile devices. If your account has one or more sub-accounts, the notification channel includes only users for the currently selected master or sub-account. Email We automatically add every individual and their email address on the selected account to the User notification channel and you can select them there. You don't need to add existing New Relic accounts to the Email channel. To add an email channel for other users, follow these guidelines: Field Description Email (required) In general, use the Email notification channel to identify user emails or email aliases that are not already on the selected account. For example, if you have a dev-ops@company.com email alias for your DevOps team, add the email alias to the Email channel. Otherwise, use the User notification channel to select specific users on your DevOps team. For easier maintenance, add a single non-user email address or alias to a single alert notification channel. If you want to use the email channel for more than one email, create an email group or alias outside your account. These email addresses can be the same as or different from email addresses already on your account. Users can unsubscribe from general (non-alerts-related) emails, but they cannot unsubscribe from alerts email notifications. Instead, the account Owner, Admin, or add-on manager must remove users from the policy's email notification channel. Include JSON attachment (optional) To include a JSON attachment with the email notification, select this checkbox. OpsGenie You must have an existing OpsGenie account integrated with New Relic in order to provide the following information: Field Description Channel name (required) A meaningful name for the OpsGenie notification channel (maximum 64 characters). API key (required) The API key generated from your OpsGenie integration used to authenticate API requests. Teams (optional) List of team names that are responsible for the alert. OpsGenie runs team escalation policies to calculate which users will receive notifications. Tags (optional) A comma-separated list of labels attached to the alert. Tip To overwrite the OpsGenie Quiet Hours setting for urgent alerts, add an OverwriteQuietHours tag. Recipients (optional) One or more names of users, groups, on-call schedules, escalation policies, etc., that OpsGenie uses to calculate where to send notifications. PagerDuty You must have an existing PagerDuty account in order to provide the following information: Field Description Service name (required) The name of your service integrating with PagerDuty for notifications. Integration key (required) The unique service identifier used by PagerDuty's Integration API to trigger, acknowledge, and resolve incidents for the service. Slack Before adding Slack notifications, you must create a unique webhook integration using Slack's New Relic integration. If you want web, transaction, server, and mobile alerts to be posted in separate channels, you must set up separate integrations for each one. Field Description Channel name (required) A meaningful name for the Slack notification channel (maximum 64 characters); for example, Network Ops Center. URL (required) Copy and paste the New Relic webhook integration URL that you've set up with Slack. For example: https://hooks.slack.com/services/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 Be sure to include https:// in the URL. Do not use http://. Team channel (optional) If used, include # before the name of the Slack channel where alert notifications are sent; for example, #NOC. VictorOps You must have an existing VictorOps account in order to provide the following required information: Field Description Channel name (required) A meaningful name for this notification channel (maximum 64 characters). For example, if the VictorOps Route key is for your Technical Support team, you could name this channel Tech Support - VictorOps. Key (required) VictorOps generates a unique key for each account. It maps the VictorOps account to its associated integrations. Route key (optional) This key maps the alert or incident to a specific team. Webhook Webhooks are HTTP POST messages containing JSON documents delivered to a destination URL. When an incident is opened, acknowledged, or closed, our webhook feature sends a message to your URL with any relevant information, such as a description of the event and a link back to New Relic. You also have the option to customize the payload in the POST message for further integration into your system. Important If your endpoint does not acknowledge the POST request within 10 seconds, the Alerts UI may indicate a failed notification event for the related incident. Before adding webhook notifications, you must have an endpoint set up to respond with a status code between 200 and 206 after receiving the following required information: Field Description Channel name (required) A meaningful name for the webhook (maximum 64 characters). Base url (required) The endpoint that will receive the POST message and trigger customized behaviors in your system. Caution If you want to include a port number in the webhook URL, make sure the port is available for requests. Otherwise the webhook will not work. Basic auth (optional) To require basic authentication for the webhook, select Add basic auth, and provide the user name and password to authenticate the webhook. Custom headers (optional) To include headers with webhooks, select Add custom headers, and provide the name and value for each header. Use custom payload (optional) To use the default values, leave blank. To view and edit the default values, select Add custom payload. Payload (for custom payloads only) Your customized POST message code. This field includes: A list of variables you can use Syntax highlighting, based on payload type Payload type (for custom payloads only) Specify the message format: JSON (default) or Form. xMatters You must have an existing xMatters account in order to provide the following information: Field Description Channel name (required) Name your channel so you can identify it easily when associating it with a policy. Integration url (required) The unique integration url provided by xMatters pointing to your xMatters account. Receive mobile push notifications Important In order to receive mobile push notifications, your device must be registered and listed in (account) > User preferences. If the device is not listed in User preferences, log out of the app, log back in, and check again to see if it is listed. To receive mobile push notifications: Log in to your New Relic account via the mobile app at least once to ensure the device is registered. Add the user channel to the alert policy. Switch push notifications On for the device. Acknowledge alert notifications Anyone in your account can acknowledge notifications through the user interface or email notification. Acknowledging an incident in New Relic also acknowledges any associated incident in PagerDuty.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 177.6083,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Notification</em> channels: Control where to send <em>alerts</em>",
        "sections": "<em>Notification</em> channels: Control where to send <em>alerts</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " them up. Tip This document is about <em>alerts</em> <em>notifications</em>. For general information about unsubscribing from other <em>New</em> <em>Relic</em> emails, including marketing emails, weekly reports, and announcements, see Unsubscribe from <em>New</em> <em>Relic</em> emails. View notification channels To see all notification channels in your"
      },
      "id": "603ecfbf64441f4ee54e885f"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/view-or-update-user-email-channels": [
    {
      "sections": [
        "Muting rules: Suppress notifications",
        "Manage muting rules",
        "Create a muting rule",
        "Tip",
        "Schedule a muting rule",
        "Manage muting rules with NerdGraph",
        "How muting rules work",
        "Muting behavior",
        "View muted violations and incidents",
        "An incident with a critical violation that's been muted",
        "An incident that has been muted",
        "A list of violations, some of which are muted",
        "A list of alert events, some of which are muted",
        "Mute faceted results using tags.",
        "Sub-condition operators",
        "Muting examples",
        "Fetch muting rules for account",
        "Create muting rule",
        "Create muting rule for specific hosts or products",
        "Create a muting rule with a recurring schedule",
        "Rename and disable muting rule",
        "Delete muting rule"
      ],
      "title": "Muting rules: Suppress notifications",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "07d71869062b00bb820e52cf89fcb6a06ce523a4",
      "image": "https://docs.newrelic.com/static/595b1c9a595bf6a5c9175f5052298e88/03914/manage_muting_rules.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/muting-rules-suppress-notifications/",
      "published_at": "2021-05-27T19:23:09Z",
      "updated_at": "2021-05-16T09:31:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alerts sends out timely notifications when your system is having problems. Sometimes there are notifications you know you don't need to see. You can use muting rules to stop being bombarded by messages you don't want. Once you've spotted the common elements in your unwanted notifications, you can define muting rules that specifically target those elements, while letting other notifications through. Even when a notification is muted, Alerts still gathers data on those violations. Muting rules don't interfere with the alerts process and are applied at the point right before a notification is sent. You can read more about why we added muting rules in this blog post. Manage muting rules A muting rule condition is the set of individual expressions made up of attributes, operators, and values that define which violations to target for muting. You can create, enable, disable, and manage muting rules. Go to one.newrelic.com, in the top nav, click Alerts & AI, and then click Muting rules. Enable or disable muting rules at any time. Rules can have one of the following statuses: Active: Muting is enabled and active. Scheduled: Muting is enabled but not active yet (there's a future schedule). Ended: Muting is enabled, but no longer active (there's no future schedule). Inactive: Muting is disabled. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Create a muting rule Tip Before creating muting rules, you'll need to create policies and conditions that generate violation notifications. To create a muting rule, click + Add a rule in the Muting rules screen. Enter a name and a description for the muting rule, and select the account to which the rule will apply. Next, build the violation filter. You can use violation event attributes and sub-condition operators. Values can be compared against one of your violation attributes, such as an Alerts policy ID or a condition name. one.newrelic.com > Alerts & AI > Muting rules: You can create complex muting rules to target a small or large set of unwanted notifications. Schedule a muting rule If needed, you can schedule your muting rules. To do this, select a start time and/or end time. Optionally, you can set the muting rule to last an entire day. You can also choose to select a time zone for the muting rule schedule. The default is the time zone selected in your user preferences. Flexible and powerful options for scheduling your muting rules. You can schedule your muting rules to recur daily, weekly, or monthly. A muting rule that's scheduled to repeat weekly includes the option to select the days of the week to recur. If no days are selected, the weekly recurrence will default to repeating on the day of the week that the muting rule is scheduled to start. You can also specify when you would like recurrence to end by selecting either a specific date or a certain number of occurrences. Manage muting rules with NerdGraph In NerdGraph, you can use the following queries and mutations with your muting rules. You can see the schema in more detail in the API Explorer. actor.account.alerts.mutingRule: Fetch a muting rule by id. actor.account.alerts.mutingRules: Fetch a list of muting rules for an account. alertsMutingRuleCreate: Create a muting rule for an account. alertsMutingRuleUpdate: Update a muting rule by id and account id. alertsMutingRuleDelete: Delete a muting rule by id and account id. We've given you some sample queries and mutations examples in this document. A muting rule has the following fields and components: Muting rule Fields and components id The unique identifier for the muting rule. name (Required) A text field for the user-friendly name of the muting rule. This is used when listing or referencing a rule. We don't require that the name be unique, but it is recommended. description This is an optional text field describing the muting rule. It can be a useful way to provide more context for your muting rule. This data is only used for management display purposes. accountId The muting rule's account ID. A muting rule will only affect violations that occur in a single account. To mute violations across multiple accounts, you'll need to create a muting rule for each account separately. createdAt The timestamp when the muting rule was created (UTC). createdBy The user ID of the person who created the muting rule. updatedAt The timestamp when the muting rule was last modified (UTC). updatedBy The user ID of the person who last modified the muting rule. enabled Enable or disable the muting rule (Boolean). Muting rules must be manually enabled and disabled. condition The set of individual expressions that define which violations to target. A muting rule condition has: operator: The boolean operator AND or OR that defines how to combine the set of conditions. conditions: The set of individual expressions (sub-conditions) that target attributes within a violation. These are evaluated together based on the operator. You can have a maximum of 20 sub-conditions for a single muting rule. A sub-condition has: attribute: A single attribute within a violation. Go here for a list of Violation event attributes. operator: The comparison function used to compare the selected violation attribute against values in the condition. Go here for a list of sub-condition operators. values: An array of string values to compare against selected violation attributes. When the muting rules evaluate a condition, if necessary, values will be coerced from strings. You can use a maximum of 500 values when using an operator that supports comparison against multiple values, such as IN. schedule The time window when the MutingRule actively mutes violations. startTime: The datetime stamp that represents when the muting rule starts. This is in local ISO 8601 format without an offset. Example: '2020-07-08T14:30:00' endTime: The datetime stamp that represents when the muting rule ends. This is in local ISO 8601 format without an offset. Example: '2020-07-15T14:30:00' timeZone: The time zone that applies to the muting rule schedule. Example: 'America/Los_Angeles'. See Wikipedia's list of tz database time zones. repeat: The frequency the muting rule schedule repeats. If it does not repeat, use null. Options are DAILY, WEEKLY, MONTHLY. endRepeat: The datetime stamp when the muting rule schedule stops repeating. This is in local ISO 8601 format without an offset. Example: '2020-07-10T15:00:00'. Note: Either endRepeat or repeatCount should be used to end a muting rule schedule. Both fields should not be provided together. repeatCount: The number of times the muting rule schedule repeats. This includes the original schedule. For example, a repeatCount of 2 will recur one time. A repeatCount of 3 will recur two times. Note: Either repeatCount or endRepeat can be used to end a muting rule schedule. Both fields should not be provided together. weeklyRepeatDays: The day(s) of the week that a muting rule should repeat when the repeat field is set to 'WEEKLY'. Example: [ 'MONDAY', 'WEDNESDAY']. How muting rules work Muting rules are applied at the end of the default alert lifecycle in order to suppress, or mute, notifications. They don't disable existing policies or conditions. For example, you can mute notifications during known system disruptions, such as maintenance windows and deployments. System disruption violations will still be identified, even though the notifications for those violations are muted. A muting rule uses a set of conditions that match against attributes in a violation event. The muting rules tell us how to: Identify individual violations after they're created, but before an incident is opened. Override their default condition to indicate that they should be \"muted.\" Currently, muting a violation means that the normal Alerts incident lifecycle will be maintained, except that an incident that only contains muted violations will not send out any notifications. Muting rules override specific violations. They don't disable existing policies or conditions. This allows you to mute violations from specific entities that may be covered by a policy or condition that covers a large number of entities. This also keeps you from having to over-mute your monitoring when you are performing maintenance on a subset of your system. Muting behavior The following table describes how the Alerts incident lifecycle is affected by muted violations: IF AND THEN Event: Incident opens An incident opens because of a violation that is not muted An “Open incident” notification will be sent (default). An incident opens due to a violation that is muted An “Open incident” notification will not be sent (muted). Event: Violation added to an open incident A new muted violation is added to an already open incident No notification action is triggered (default). A new unmuted violation is added to an open incident An “Open incident” notification has not been sent An “Open incident” notification will be sent. A new unmuted violation is added to an open incident An “Open incident” notification has already been sent No notification action is triggered (default). Event: Incident closed An Incident is closed An “Open incident” notification has not been sent A “Close incident” notification will not be sent. An Incident is closed An “Open incident” notification has been sent A “Close incident” notification will be sent. Event: Incident acknowledged An Incident is acknowledged An “Open incident” notification has not been sent An “Incident acknowledged” notification will not be sent. An Incident is acknowledged An “Open incident” notification has been sent An “Incident acknowledged” notification will be sent. View muted violations and incidents When viewing an open or closed incident, violations and incidents are marked as Muted. The following sections show some of these muted violations and incidents, and where you can find them. An incident with a critical violation that's been muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Incidents. An incident that has been muted Violations and incidents are marked as Muted in the State column: Go to one.newrelic.com, and in the top nav click Alerts & AI, click Incidents, then click Open incidents. A list of violations, some of which are muted Go to one.newrelic.com, and in the top nav, click Alerts & AI, then click Events. A list of alert events, some of which are muted In the list of alert events, the State column shows which events have been muted. Go to one.newrelic.com, in the top nav click Alerts & AI, click Events, then click All events. Mute faceted results using tags. To mute results of faceted queries, use the tags.FACETED_ATTRIBUTE attribute, where FACETED_ATTRIBUTE represents the attributed you've run a NRQL FACET query on. For example: if your NRQL alert condition includes FACET host in its query, you can target that FACET attribute using tags.host. NRQL condition queries can accept multiple facet attributes. If you want to be able to filter from attributes in your events or metric time series that have been aggregated, you must add those attributes to your NRQL query FACET clause; for example: FACET host, region, cluster. For an example of using tags., see Create muting rule. Sub-condition operators The following are the logical operators available to use to compare attributes when you're constructing muting rules. For examples of these being used, see Examples. EQUALS: Where the supplied value equals the violation attribute value. NOT_EQUALS: Where the supplied value does not equal the violation attribute value. IN: Where the violation attribute value is present in a list of supplied values (up to 500). NOT_IN: Where the violation attribute value is not present in a list of supplied values (up to 500). CONTAINS: Where the supplied value string is present in the violation attribute value. NOT_CONTAINS: Where the supplied value string is not present in the violation attribute value. ANY: Caution: A condition with this operator will mute all violations on the account. IS_BLANK: Where the violation attribute value is blank. Null, empty string, etc. IS_NOT_BLANK: Where the violation attribute value is not blank. Null, empty string, etc. STARTS_WITH: Where the violation attribute value begins with the supplied value string. NOT_STARTS_WITH: Where the violation attribute value does not begin with the supplied value string. ENDS_WITH: Where the violation attribute value ends with the supplied value string. NOT_ENDS_WITH: Where the violation attribute value does not end with the supplied value string. Muting examples For more information about making requests to NerdGraph, see the NerdGraph documentation, including GraphQL tutorials. Fetch muting rules for account To fetch the list of muting rules (with name and condition) for an account: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { mutingRules { name condition { operator conditions { attribute operator values } } } } } } } Copy Create muting rule To create a muting rule and return the muting rule's id for muting violations from NRQL conditions where host facet is host-1: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 mute rule\", description: \"Mute host-1 violations\", enabled: true, condition: { operator: AND, conditions: [{ attribute: \"tags.host\", operator: EQUALS, values: [\"host-1\"] }] } }) { id } } Copy Create muting rule for specific hosts or products To create a muting rule and return the muting rule's id for muting violations from Infrastructure conditions where the target host is host-1 or the violation was from Synthetic monitoring or Mobile products: mutation { alertsMutingRuleCreate(accountId: YOUR_ACCOUNT_ID, rule: { name: \"host-1 and Synthetics/Mobile mute rule\", description: \"Mute host-1 and Synthetics/Mobile violations\", enabled: true, condition: { operator: OR, conditions: [ { attribute: \"targetName\", operator: EQUALS, values: [\"host-1\"] }, { attribute: \"product\", operator: IN, values: [\"SYNTHETICS\", \"MOBILE\"] } ] } }) { id } } Copy Create a muting rule with a recurring schedule To create a muting rule scheduled to repeat with these criteria: Weekly on Tuesday and Friday End on 01/31/2021 Return the muting rule's schedule and id mutation { alertsMutingRuleCreate( accountId: YOUR_ACCOUNT_ID, rule: { condition: { conditions: { attribute: \"conditionName\", operator: ANY, values: \"This is a condition\" }, operator: AND }, enabled: true, name: \"Recur Weekly\", schedule: { startTime: \"2020-12-01T12:00:00\", endTime: \"2020-12-01T14:00:00\", timeZone: \"America/Los_Angeles\", repeat: WEEKLY, endRepeat: \"2021-01-31T12:00:00\", weeklyRepeatDays: [TUESDAY, FRIDAY] } } ) { id schedule { endTime startTime timeZone repeat repeatCount endRepeat weeklyRepeatDays nextStartTime nextEndTime } } } Copy Rename and disable muting rule To change the name and disable a muting rule and return its new name: mutation { alertsMutingRuleUpdate(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID, rule: { name: \"updated name\", enabled: false }) { name } } Copy Delete muting rule To delete a muting rule: mutation { alertsMutingRuleDelete(accountId: YOUR_ACCOUNT_ID, id: MUTING_RULE_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.5033,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Muting rules: Suppress <em>notifications</em>",
        "sections": "Muting rules: Suppress <em>notifications</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " define muting rules that specifically target those elements, while letting other <em>notifications</em> through. Even when a notification is muted, <em>Alerts</em> still gathers data on those violations. Muting rules don&#x27;t interfere with the <em>alerts</em> process and are <em>applied</em> at the point right before a notification"
      },
      "id": "60440c4728ccbc9c612c60c7"
    },
    {
      "sections": [
        "Customize your webhook payload",
        "Define webhooks",
        "Webhook values",
        "Targets values",
        "Webhook format example",
        "JSON webhook example",
        "Important",
        "Form webhook example",
        "Plain text output",
        "Microsoft Teams example"
      ],
      "title": "Customize your webhook payload",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "26f483edd4fd0bf049a3d3e6c5885788dcdfdd46",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/customize-your-webhook-payload/",
      "published_at": "2021-06-02T20:58:08Z",
      "updated_at": "2021-05-16T08:48:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you use webhooks as your alerts notification channel, you can use the default values. You can also customize the payload in the POST message for further integration into your system. Define webhooks When defining JSON webhooks, use the format \"name\":\"value\",. For example: \"current_state\":\"acknowledged\", Copy When defining static webhook variables in a form payload, use the format name=\"value\". For example: current_state=\"acknowledged\" Copy Do not include any custom, self-signed SSL certificates in your webhook. Our agents enable SSL by default. Due to our security policy, custom SSL certificates will not be imported into our Trust store. Webhook values We support these default dynamic webhook values. For your convenience, they are listed in alphabetical order, but you can define your webhook values in any order. You may also add custom variables by using your own key/value pairs. Key Variable \"account_id\" $ACCOUNT_ID Possible values: New Relic account ID (string) \"account_name\" $ACCOUNT_NAME Possible values: New Relic account name (string) \"closed_violations_count_critical\" $CLOSED_VIOLATIONS_COUNT_CRITICAL \"closed_violations_count_warning\" $CLOSED_VIOLATIONS_COUNT_WARNING \"condition_id\" $CONDITION_ID \"condition_description\" $DESCRIPTION This includes the description field from the alert condition, if there is one. \"condition_name\" $CONDITION_NAME Possible values: (user-defined string) \"current_state\" $EVENT_STATE Possible values: [open|acknowledged|closed] \"details\" $EVENT_DETAILS \"duration\" $DURATION \"event_type\" $EVENT_TYPE Possible values: [INCIDENT] \"incident_acknowledge_url\" $INCIDENT_ACKNOWLEDGE_URL \"incident_id\" $INCIDENT_ID \"incident_url\" $INCIDENT_URL \"metadata\" $METADATA Currently used only for Synthetic monitoring multi-location failure conditions. \"open_violations_count_critical\" $OPEN_VIOLATIONS_COUNT_CRITICAL \"open_violations_count_warning\" $OPEN_VIOLATIONS_COUNT_WARNING \"owner\" $EVENT_OWNER \"policy_name\" $POLICY_NAME Possible values: (user-defined string) \"policy_url\" $POLICY_URL \"runbook_url\" $RUNBOOK_URL \"severity\" $SEVERITY Possible values: [CRITICAL] \"targets\" $TARGETS The $TARGETS variable cannot be used with FORM data, but is compatible with JSON data. For static NRQL faceted alerts, the name of the facet that triggered the alert will be populated in the target’s name field. For a description of the available fields, see Target values. \"timestamp\" $TIMESTAMP \"timestamp_utc_string\" $TIMESTAMP_UTC_STRING A human-readable timestamp in the YYYY-MM-DD, HH:MM UTC format. \"version\" $VERSION \"violation_callback_url\" $VIOLATION_CALLBACK_URL \"violation_chart_url\" $VIOLATION_CHART_URL Targets values This section describes the $TARGETS field in your webhook. This data is not customizable and is provided here for reference. Your $TARGETS contain a list of zero or more targets (entities). Each target is described by a JSON object with the following fields. Key Variable \"id\" ID of the target or entity \"name\" Name of the target or entity \"labels\" Combined entity tags and NRQL facets that are derived from the condition evaluation and available entity tags. \"link\" URL link to this target or entity. \"product\" Type of product for this target or entity; for example, APM \"type\" Type of target or entity under product; for example, Application Webhook format example The following examples show a webhook payload using both the default dynamic variables and a custom variable. You can use some or all of the dynamic variables, along with any custom variables, to define your own payload. JSON webhook example Important The following webhook example has extra spaces and line breaks for readability. Actual webhook responses are delivered as one continuous line of text. The \"team\": \"DevOps\" line is an example of a custom variable. { \"account_id\": \"$ACCOUNT_ID\", \"account_name\": \"$ACCOUNT_NAME\", \"closed_violations_count_critical\": \"$CLOSED_VIOLATIONS_COUNT_CRITICAL\", \"closed_violations_count_warning\": \"$CLOSED_VIOLATIONS_COUNT_WARNING\", \"condition_family_id\": \"$CONDITION_FAMILY_ID\", \"condition_id\": \"$CONDITION_ID\", \"condition_name\": \"$CONDITION_NAME\", \"current_state\": \"$EVENT_STATE\", \"details\": \"$EVENT_DETAILS\", \"duration\": \"$DURATION\", \"event_type\": \"$EVENT_TYPE\", \"incident_acknowledge_url\": \"$INCIDENT_ACKNOWLEDGE_URL\", \"incident_id\": \"$INCIDENT_ID\", \"incident_url\": \"$INCIDENT_URL\", \"open_violations_count_critical\": \"$OPEN_VIOLATIONS_COUNT_CRITICAL\", \"open_violations_count_warning\": \"$OPEN_VIOLATIONS_COUNT_WARNING\", \"owner\": \"$EVENT_OWNER\", \"policy_name\": \"$POLICY_NAME\", \"policy_url\": \"$POLICY_URL\", \"runbook_url\": \"$RUNBOOK_URL\", \"severity\": \"$SEVERITY\", \"targets\": \"$TARGETS\", \"timestamp\": \"$TIMESTAMP\", \"timestamp_utc_string\": \"$TIMESTAMP_UTC_STRING\", \"violation_callback_url\": \"$VIOLATION_CALLBACK_URL\", \"violation_chart_url\": \"$VIOLATION_CHART_URL\", \"team\": \"DevOps\" } Copy Form webhook example Important The following webhook example has extra spaces and line breaks for readability. Actual webhook responses are delivered as one continuous line of text. account_id=$ACCOUNT_ID account_name=$ACCOUNT_NAME closed_violations_count_critical=$CLOSED_VIOLATIONS_COUNT_CRITICAL closed_violations_count_warning=$CLOSED_VIOLATIONS_COUNT_WARNING condition_family_id=$CONDITION_FAMILY_ID condition_id=$CONDITION_ID condition_name=$CONDITION_NAME current_state=$EVENT_STATE details=$EVENT_DETAILS duration=$DURATION event_type=$EVENT_TYPE incident_acknowledge_url=$INCIDENT_ACKNOWLEDGE_URL incident_id=$INCIDENT_ID incident_url=$INCIDENT_URL open_violations_count_critical=$OPEN_VIOLATIONS_COUNT_CRITICAL open_violations_count_warning=$OPEN_VIOLATIONS_COUNT_WARNING owner=$EVENT_OWNER policy_name=$POLICY_NAME policy_url=$POLICY_URL runbook_url=$RUNBOOK_URL severity=$SEVERITY timestamp=$TIMESTAMP timestamp_utc_string=$TIMESTAMP_UTC_STRING violation_callback_url=$VIOLATION_CALLBACK_URL violation_chart_url=$VIOLATION_CHART_URL team=\"DevOps\" <--[example of custom variable] Copy Plain text output New Relic Alert Incident open: CPU > 50% for 5 minutes Policy: http://alerts.newrelic.com/accounts/1234/policies/5678 Chart URL: http://gorgon.nr-assets.net/image/12345678-abcd-efgh-ijkl-1234567890 For more details, see: http://alerts.newrelic.com/accounts/1234/incidents/3456 Copy Microsoft Teams example { \"@type\": \"MessageCard\", \"@context\": \"http://schema.org/extensions\", \"themeColor\": \"0076D7\", \"summary\": \"$CONDITION_NAME\", \"sections\": [{ \"activityTitle\": \"$CONDITION_NAME\", \"activitySubtitle\": \"$POLICY_NAME\", \"activityImage\": \"https://newrelic.com/themes/custom/curio/assets/mediakit/NR_logo_Horizontal_Rev.png\", \"facts\": [{ \"name\": \"Timestamp\", \"value\": \"$TIMESTAMP_UTC_STRING\" }, { \"name\": \"Account ID\", \"value\": \"$ACCOUNT_ID\" }, { \"name\": \"Account Name\", \"value\": \"$ACCOUNT_NAME\" }, { \"name\": \"Severity\", \"value\": \"$SEVERITY\" }, { \"name\": \"State\", \"value\": \"$EVENT_STATE\" }, { \"name\": \"Duration\", \"value\": \"$DURATION\" }, { \"name\": \"Details\", \"value\": \"$EVENT_DETAILS\" }], \"markdown\": true }, { \"text\": \"$METADATA<p><img src=\\\"$VIOLATION_CHART_URL\\\" alt=\\\"Incident Chart\\\"></img></p>\" }], \"potentialAction\": [{ \"@type\": \"OpenUri\", \"name\": \"View Incident\", \"targets\": [{ \"os\": \"default\", \"uri\": \"$INCIDENT_URL\" }] }, { \"@type\": \"OpenUri\", \"name\": \"Aknowledge Incident\", \"targets\": [{ \"os\": \"default\", \"uri\": \"$INCIDENT_ACKNOWLEDGE_URL\" }] }, { \"@type\": \"OpenUri\", \"name\": \"Open Runbook\", \"targets\": [{ \"os\": \"default\", \"uri\": \"$RUNBOOK_URL\" }] }] } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 209.42686,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "=$POLICY_URL runbook_url=$RUNBOOK_URL severity=$SEVERITY timestamp=$TIMESTAMP timestamp_utc_string=$TIMESTAMP_UTC_STRING violation_callback_url=$VIOLATION_CALLBACK_URL violation_chart_url=$VIOLATION_CHART_URL team=&quot;DevOps&quot; &lt;--[example of custom variable] Copy Plain text output <em>New</em> <em>Relic</em> <em>Alert</em> Incident open"
      },
      "id": "603ed08e28ccbcbdcdeba74a"
    },
    {
      "sections": [
        "Notification channels: Control where to send alerts",
        "Tip",
        "View notification channels",
        "Add or remove notification channels",
        "Instructions for specific notification channels",
        "User",
        "Email",
        "OpsGenie",
        "PagerDuty",
        "Slack",
        "VictorOps",
        "Webhook",
        "Important",
        "Caution",
        "xMatters",
        "Receive mobile push notifications",
        "Acknowledge alert notifications"
      ],
      "title": "Notification channels: Control where to send alerts",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert notifications"
      ],
      "external_id": "8600dc86e59fad5da1e4a2b4170d2b86df78ee2f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-notifications/notification-channels-control-where-send-alerts/",
      "published_at": "2021-05-28T03:30:14Z",
      "updated_at": "2021-04-21T16:00:40Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use alerts to set up notification channels, and attach those channels to policies. Your selected channels provide fast and consistent ways for the right personnel to be notified about incidents. For example, notifications allow you to include charts about the incident to provide context and share them with your team. Alerts offers several notification channels, including webhooks, Slack rooms, email, and more. You'll be notified by your notification channels when incidents are opened, acknowledged, or closed. This document explains the available notification channels and how to set them up. Tip This document is about alerts notifications. For general information about unsubscribing from other New Relic emails, including marketing emails, weekly reports, and announcements, see Unsubscribe from New Relic emails. View notification channels To see all notification channels in your account: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. Add or remove notification channels To set up a new notification channel: On the Notification channels, click New notification channel. Select the type of channel and complete other required steps for it. To add or remove a notification policy or channel: Select a specific notification channel, select Alert policies, and add or remove a policy. OR Select a specific policy, select Notification channels, and add or remove a channel. Instructions for specific notification channels These are the available notification channel types. User Requirement: This feature is not available for users on the New Relic One user model, only to users on the original user model (learn about user model differences). As a workaround, you can use the email notification channel. Use the User notification channel to select existing account team members and admins. To view the Users list or to add users to alert policies: Go to one.newrelic.com, in the top nav click Alerts & AI, then click Notification channels. If a user has configured the New Relic mobile app, the user notification channel also sends push notifications to any of the user's registered mobile devices. If your account has one or more sub-accounts, the notification channel includes only users for the currently selected master or sub-account. Email We automatically add every individual and their email address on the selected account to the User notification channel and you can select them there. You don't need to add existing New Relic accounts to the Email channel. To add an email channel for other users, follow these guidelines: Field Description Email (required) In general, use the Email notification channel to identify user emails or email aliases that are not already on the selected account. For example, if you have a dev-ops@company.com email alias for your DevOps team, add the email alias to the Email channel. Otherwise, use the User notification channel to select specific users on your DevOps team. For easier maintenance, add a single non-user email address or alias to a single alert notification channel. If you want to use the email channel for more than one email, create an email group or alias outside your account. These email addresses can be the same as or different from email addresses already on your account. Users can unsubscribe from general (non-alerts-related) emails, but they cannot unsubscribe from alerts email notifications. Instead, the account Owner, Admin, or add-on manager must remove users from the policy's email notification channel. Include JSON attachment (optional) To include a JSON attachment with the email notification, select this checkbox. OpsGenie You must have an existing OpsGenie account integrated with New Relic in order to provide the following information: Field Description Channel name (required) A meaningful name for the OpsGenie notification channel (maximum 64 characters). API key (required) The API key generated from your OpsGenie integration used to authenticate API requests. Teams (optional) List of team names that are responsible for the alert. OpsGenie runs team escalation policies to calculate which users will receive notifications. Tags (optional) A comma-separated list of labels attached to the alert. Tip To overwrite the OpsGenie Quiet Hours setting for urgent alerts, add an OverwriteQuietHours tag. Recipients (optional) One or more names of users, groups, on-call schedules, escalation policies, etc., that OpsGenie uses to calculate where to send notifications. PagerDuty You must have an existing PagerDuty account in order to provide the following information: Field Description Service name (required) The name of your service integrating with PagerDuty for notifications. Integration key (required) The unique service identifier used by PagerDuty's Integration API to trigger, acknowledge, and resolve incidents for the service. Slack Before adding Slack notifications, you must create a unique webhook integration using Slack's New Relic integration. If you want web, transaction, server, and mobile alerts to be posted in separate channels, you must set up separate integrations for each one. Field Description Channel name (required) A meaningful name for the Slack notification channel (maximum 64 characters); for example, Network Ops Center. URL (required) Copy and paste the New Relic webhook integration URL that you've set up with Slack. For example: https://hooks.slack.com/services/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 Be sure to include https:// in the URL. Do not use http://. Team channel (optional) If used, include # before the name of the Slack channel where alert notifications are sent; for example, #NOC. VictorOps You must have an existing VictorOps account in order to provide the following required information: Field Description Channel name (required) A meaningful name for this notification channel (maximum 64 characters). For example, if the VictorOps Route key is for your Technical Support team, you could name this channel Tech Support - VictorOps. Key (required) VictorOps generates a unique key for each account. It maps the VictorOps account to its associated integrations. Route key (optional) This key maps the alert or incident to a specific team. Webhook Webhooks are HTTP POST messages containing JSON documents delivered to a destination URL. When an incident is opened, acknowledged, or closed, our webhook feature sends a message to your URL with any relevant information, such as a description of the event and a link back to New Relic. You also have the option to customize the payload in the POST message for further integration into your system. Important If your endpoint does not acknowledge the POST request within 10 seconds, the Alerts UI may indicate a failed notification event for the related incident. Before adding webhook notifications, you must have an endpoint set up to respond with a status code between 200 and 206 after receiving the following required information: Field Description Channel name (required) A meaningful name for the webhook (maximum 64 characters). Base url (required) The endpoint that will receive the POST message and trigger customized behaviors in your system. Caution If you want to include a port number in the webhook URL, make sure the port is available for requests. Otherwise the webhook will not work. Basic auth (optional) To require basic authentication for the webhook, select Add basic auth, and provide the user name and password to authenticate the webhook. Custom headers (optional) To include headers with webhooks, select Add custom headers, and provide the name and value for each header. Use custom payload (optional) To use the default values, leave blank. To view and edit the default values, select Add custom payload. Payload (for custom payloads only) Your customized POST message code. This field includes: A list of variables you can use Syntax highlighting, based on payload type Payload type (for custom payloads only) Specify the message format: JSON (default) or Form. xMatters You must have an existing xMatters account in order to provide the following information: Field Description Channel name (required) Name your channel so you can identify it easily when associating it with a policy. Integration url (required) The unique integration url provided by xMatters pointing to your xMatters account. Receive mobile push notifications Important In order to receive mobile push notifications, your device must be registered and listed in (account) > User preferences. If the device is not listed in User preferences, log out of the app, log back in, and check again to see if it is listed. To receive mobile push notifications: Log in to your New Relic account via the mobile app at least once to ensure the device is registered. Add the user channel to the alert policy. Switch push notifications On for the device. Acknowledge alert notifications Anyone in your account can acknowledge notifications through the user interface or email notification. Acknowledging an incident in New Relic also acknowledges any associated incident in PagerDuty.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 177.60829,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Notification</em> channels: Control where to send <em>alerts</em>",
        "sections": "<em>Notification</em> channels: Control where to send <em>alerts</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " them up. Tip This document is about <em>alerts</em> <em>notifications</em>. For general information about unsubscribing from other <em>New</em> <em>Relic</em> emails, including marketing emails, weekly reports, and announcements, see Unsubscribe from <em>New</em> <em>Relic</em> emails. View notification channels To see all notification channels in your"
      },
      "id": "603ecfbf64441f4ee54e885f"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-policies/create-edit-or-find-alert-policy": [
    {
      "sections": [
        "Update or disable policies and conditions",
        "Policy maintenance quick reference",
        "Add or remove policies assigned to a channel",
        "Change a policy name",
        "Check policy user assignment",
        "Check policy channel assignment",
        "Create a new policy",
        "Condition maintenance quick reference",
        "Add more conditions",
        "Copy a condition",
        "Change how threshold violations roll up into incidents",
        "Check for entities (targets) assigned to a policy",
        "Tip",
        "Change a condition",
        "Link to Incident Intelligence",
        "Disable or delete policies and conditions",
        "Disable or re-enable a condition",
        "Disable a policy",
        "Delete policy conditions",
        "Delete a policy"
      ],
      "title": "Update or disable policies and conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert policies"
      ],
      "external_id": "4a6c5107cd6af696df6a3fb0651c6a1bde7daf36",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-policies/update-or-disable-policies-conditions/",
      "published_at": "2021-05-28T11:10:28Z",
      "updated_at": "2021-05-21T15:35:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you create a policy, you can: Add more conditions to the policy. Edit the conditions' names, targets, or thresholds. Disable conditions. Continue the policy setup process by adding one or more notification channels to it. Rename or delete the policy. The user interface shows a Last modified timestamp for any changes to policies, including their conditions and notification channels. Policy maintenance quick reference Here is a quick reference which also includes links to more detailed information and procedures for maintaining your policies. Add or remove policies assigned to a channel To add or remove policies assigned to a channel: In the one.newrelic.com top nav, click Alerts & AI, click Notification channels, then (select a channel). Click Alert policies, then (select a policy). From the selected policy, use the windows to select, remove, or clear all. Change a policy name To rename a policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Click the policy name to edit it, then type a meaningful name for the policy (maximum 64 characters). Check policy user assignment To check whether an account user has been assigned any policies: In the one.newrelic.com top nav, click Alerts & AI, click Policies, (select a policy), then click Notification channels. Select a user, and then click Alert policies. Check policy channel assignment To check whether a notification channel has any policies assigned to it: In the one.newrelic.com top nav, click Alerts & AI, click Notification channels. The Policy subscriptions column lists how many policies are assigned to the channel. Create a new policy To create a new alert policy: In the one.newrelic.com top nav, click Alerts & AI, click Policies. Click New alert policy. Follow standard procedures to complete the basic setup process. Condition maintenance quick reference Here's a quick reference for maintaining a policy conditions. This includes the condition's entities (targets), Warning (yellow) and Critical (red) thresholds, and runbook URL. Add more conditions To add more conditions to a policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then click Add a condition. OR To copy a condition from any policy and add it to another policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then click Copy. Copy a condition To copy an existing condition, including its targets and thresholds, and add it to another policy for the selected account: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). From the policy's list of one or more Alert conditions, click Copy. From the Copy alert condition list, search or scroll the list to select the policy where you want to add this condition. Optional: Change the condition's name if necessary. Select Save. By default, the copied condition will be added to the selected alert policy in a Disabled state. Follow standard procedures to add or copy additional conditions to the alert policy, and then Enable the condition as needed. Change how threshold violations roll up into incidents To select how violations to your thresholds are grouped into incident records (by policy, by condition, or by target and condition): In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Click Incident preference. Check for entities (targets) assigned to a policy To check whether an entity (target) has any policies assigned: Go to the product (APM, Browser, etc.). From the selected product's index, check whether the entity's color-coded health status is light green with an icon. Tip Exception: Infrastructure does not use this feature. Change a condition To change a policy condition: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Then, from the list of Alert conditions for the selected policy: To change the condition's name, click Edit. To add, change, or remove targets (entities), select the name or number of targets for the condition, and then select Browse and select targets. To update the values for the required Critical (red) or optional Warning (yellow) thresholds, select the existing value. To update the condition's runbook URL, select the condition's Thresholds. Link to Incident Intelligence If you use Applied Intelligence, you can connect your conditions to Incident Intelligence. To do this, switch the Connect to Incident Intelligence to ON. Disable or delete policies and conditions If you disable or delete a policy, we'll continue to apply any other policies assigned to the product entity (target). If you remove all policies for the entity, its color-coded health status indicator will appear light green with an icon. Disable or re-enable a condition You can enable or disable any policy conditions, and the policy will continue to apply. To disable or re-enable a condition: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Then, from the list of Alert conditions, (select a condition). Click the On/Off switch to toggle it. Tip For Infrastructure conditions, use the checkbox at the bottom of the condition edit screen, then save the condition. If you copy a condition, it is automatically saved in the new policy as disabled (Off), even if the condition was enabled (On) in the original policy. Disable a policy You can't disable a policy directly. However, you can disable all of the policy's conditions. When you disable all of the conditions, the policy will continue to appear on the Alert policies index. The policy itself isn't disabled, and you can re-enable any or all of its conditions at any time. Delete policy conditions If a policy has multiple conditions, you can delete any or all of them, and the remaining conditions for the policy will continue to apply. To turn a condition off but keep it with the policy, disable it. To delete one or more conditions: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). From the list of Alert conditions, (select a condition), then click Delete. Tip If you don't see the delete button, your account admin may have disabled condition deletion for your organization. Delete a policy If you delete any of your account's policies, you can't restore them. Instead, you must re-create them if necessary. To delete a policy completely: In the one.newrelic.com top nav, click Alerts & AI, then click Alert policies. From the policy row, click the delete icon. Any notification channels associated with a deleted or disabled policy will remain. You must delete notification channels or remove them individually as necessary. You will still be able to view incidents and event violations related to the deleted policy. However, these records will be read only.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 237.02203,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Update or disable <em>policies</em> <em>and</em> conditions",
        "sections": "Update or disable <em>policies</em> <em>and</em> conditions",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " to it: In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click Notification channels. The Policy subscriptions column lists how many <em>policies</em> are assigned to the channel. Create a <em>new</em> policy To create a <em>new</em> <em>alert</em> policy: In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click <em>Policies</em>. Click <em>New</em> <em>alert</em> policy. Follow"
      },
      "id": "604404ec28ccbc62492c6098"
    },
    {
      "sections": [
        "Specify when alerts create incidents",
        "Tip",
        "Incident preference options",
        "Select your incident preference",
        "Example: By policy (default)",
        "Example: By condition",
        "Example: By condition and signal",
        "For more help"
      ],
      "title": "Specify when alerts create incidents",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert policies"
      ],
      "external_id": "7ddf9dfd669866e413eb87573c063ecf558747bf",
      "image": "https://docs.newrelic.com/static/233d82abf03b4f77340c757671f3a96a/8c557/example-policy-incident.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-policies/specify-when-alerts-create-incidents/",
      "published_at": "2021-05-27T20:34:28Z",
      "updated_at": "2021-04-12T02:19:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When a policy condition violates a Critical (red) threshold, it can create an incident record with detailed information to help you respond efficiently. An incident is a collection of one or more violations. It includes all of the open and close timestamps for each violation. The incident record will include any Warning (yellow) violations which occurred after the opening Critical (red) threshold violation. Notifications are sent to every notification channel on the policy when an incident opens, if and when an incident is acknowledged, and when an incident closes. Tip To select when alerts create incidents and how violations are grouped, use the Incident preference setting inside your policy. Then, to view the alerts policy violations (incident records), select the Incidents indexes. Incident preference options Each option for incident preference has its own advantages. You can select any option for any policy. Incident preference Comments By policy (default) Only one incident will be open at a time for the entire policy. Fewest number of notifications Requires immediate action and closing the incidents to be effective By condition One incident will be open at a time for each condition in your policy. More notifications Useful for policies containing conditions that focus on entities that perform the same job; for example, hosts that all serve the same application(s) By condition and signal An incident will be created for every violation in your policy. The most notifications Useful if you need to be notified of every violation or if you have an external system where you want to send alert notifications Select your incident preference By default, a single incident record will be created for each policy. one.newrelic.com > Alert & AI > Policies > (select a policy): The selected policy page shows how alerts rolls up incidents for alert notifications and UI details. (Default is By policy). To choose a different option for this policy, click Incident preference. To change the incident preference for the selected policy: In the one.newrelic.com top nav, click Alerts & AI, then click Policies, and then (select a policy). Click Incident preference, select your choice of available options, and then save. Repeat these steps for each policy as needed. Example: By policy (default) When you select the default (By policy) as your incident preference, it will group all condition violations into the same incident. By default, a single incident record will be created for each alert policy. If additional conditions are violated by any target after the incident opens, the violations are added to the same incident. Only one incident appears on your Incidents indexes for the selected policy. Selecting the By policy preference is the most general option. All condition violations for every target will be accumulated into a single incident record. Example: By condition When you select By condition as your incident preference, it will group all violations by any target for a specific condition into separate incidents. Selecting the By condition option is useful, for example, when you want an individual incident record to focus on a specific condition. If the policy has multiple conditions, separate incident records for each condition will appear on your Incidents indexes. If a target violates a condition for the alert policy, an incident record will be created. If the same target violates another condition for the alert policy, another incident record will be created. If additional targets violate the same condition after the incident opens, these violations will be added to the incident record already open for that condition. Example: By condition and signal When you select By condition and signal as your incident preference, it will not group violations at all. A new incident will be created for every violation that occurs in your policy. Selecting the By condition and signal option is the most granular level for creating incident records. This is useful, for example, when you want to closely monitor anything that is occurring anywhere across your infrastructure. An incident will appear on your Incidents indexes for every violation that occurs within your policy. For more help Additional documentation resources include: Alert policy workflow (basic process to set up your alert policies, regardless of which New Relic product uses the alert policy) Explore the incident history (examine details about alert policy violations, take action, and skim for patterns)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.93846,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Specify when <em>alerts</em> create incidents",
        "sections": "Specify when <em>alerts</em> create incidents",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " that occurs within your policy. For more help Additional documentation resources include: <em>Alert</em> policy workflow (basic process to set up your <em>alert</em> <em>policies</em>, regardless of which <em>New</em> <em>Relic</em> product uses the <em>alert</em> policy) Explore the incident history (examine details about <em>alert</em> policy violations, take action, and skim for patterns)"
      },
      "id": "603e9efd28ccbc79eeeba786"
    },
    {
      "sections": [
        "Incident Intelligence destination examples",
        "Destination template examples",
        "Suggested OpsGenie template example",
        "Suggested ServiceNow template example",
        "Suggested Slack template example",
        "Suggested VictorOps template example",
        "Webhook and JSON format examples",
        "Webhook format and JSON example",
        "Jinja2 Default Payload",
        "Jinja2 Useful Syntax",
        "JSON schema",
        "JSON schema template"
      ],
      "title": "Incident Intelligence destination examples",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "a516d04f8b75541a6dc9338fa3ce9645ba87d620",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/incident-intelligence-destination-examples/",
      "published_at": "2021-06-02T18:22:22Z",
      "updated_at": "2021-06-02T18:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Destinations are the data outputs to Applied Intelligence, where you can view your automatically correlated incidents. You can configure Incident Intelligence destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema. Destination template examples The following template example destinations are formatted in Jinja2. Suggested OpsGenie template example { \"alias\": {{ id }}, \"message\": {{ ui_name }}, \"source\": '{{ sources }}', \"priority\": {{ priority }}, \"details\": { \"self_url\": {{ url }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"is_correlated\": {{ is_correlated }} }, \"description\": \"\"\"Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]\"\"\" } Copy Suggested ServiceNow template example { \"short_description\": {{ ui_name }}, \"description\": 'Issue Id: {{ id }}, \\n Description: {{ description }}, \\n Sources: {{ sources }}, \\n Priority: {{ priority }}, \\n Details: { \\n self_url: {{ url }}, \\n state: {{ state }}, \\n is_correlated: {{ is_correlated }}, \\n created_on: {{ created_on }}, \\n modified_on: {{ modified_on }}, \\n activated_on: {{ active_since }}, \\n closed_on: {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \\n is_correlated: {{is_correlated}} }, \\n\\n incidents: {{ incidents }}, \\n\\n pathways: {{ pathways }}' } Copy Suggested Slack template example Go to Slack incoming WebHooks Choose the right Slack workspace and click \"Add to Slack\" Select the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In New Relic Applied Intelligence, under Incident Intelligence click Destinations Add a WebHook In the end point paste the WebHook url from slack. In the custom payload, paste the following JSON: { \"blocks\": [ { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*New Relic Incident Intelligence Alert*\" } }, { \"type\": \"divider\" }, { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*CUSTOM FIELDS*:\" }, \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue ID*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Issue Title*\" }, { \"type\": \"plain_text\", \"text\": {{ id }} }, { \"type\": \"plain_text\", \"text\": {{ ui_name }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue URL*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Description*\" }, { \"type\": \"mrkdwn\", \"text\": {{ url }} }, { \"type\": \"plain_text\", \"text\": {{ description }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*State*\" }, { \"type\": \"mrkdwn\", \"text\": \"*is_correlated*\" }, { \"type\": \"plain_text\", \"text\": {{ state }} }, { \"type\": \"plain_text\", \"text\": \"{{ is_correlated }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Created On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Modified On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ created_on }}\" }, { \"type\": \"plain_text\", \"text\": \"{{ modified_on }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Activated On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Closed On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ active_since }}\" }, { \"type\": \"plain_text\", \"text\": \"{% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Aggregated Incidents*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Monitoring Tool*\" }, { \"type\": \"plain_text\", \"text\": \"{{ incident_count }}\" }, { \"type\": \"plain_text\", \"text\": {{ sources|join(', ') }} } ] } ] } Copy Suggested VictorOps template example { \"monitoring_tool\": {{ sources }}, {% if state == 'closed' %} \"message_type\": \"OK\", {% else %} \"message_type\": {{ priority }}, {% endif %} \"custom_fields\": { \"issue_url\": {{ url }}, \"description\": {{ description }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"related_incidents\": [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %} {% endfor %} ] }, \"state_message\": {{ description }}, \"entity_id\": {{ id }}, \"entity_display_name\": {{ ui_name }}, \"vo_annotate.u.NRAI_Link\": {{ url }} } Copy Webhook and JSON format examples Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). If you use webhooks to configure Incident Intelligence destinations, use these examples of the webhook body format and JSON schema. Webhook format and JSON example Webhook format: Name Description url Href A link to the UI where the issue can be seen. id String Unique identifier for the issue. title String The issue title. description String The description of the issue. priority Enum The issue priority. Can be Critical, High, Medium, or Low. state Enum The issue status. Can be Active, Closed, or Acknowledged. is_correlated Boolean True if the issue is based on correlated data. created_on String The date and time the issue was created (in ISO format). modified_on String The date and time the issue was modified (in ISO format). active_since String The date and time the issue was activated (in ISO format). closed_on String The date and time the issue was closed (in ISO format). sources List(String) List of the different sources that were used to send the events into Applied Intelligence (for example: PagerDuty). pathways List(Pathways) List of pathways that are associated with the issue. Each pathway contains an id and name: [{“id”: “pathway id”, “name”: “pathway name”}]. pathways[].id String The pathway ID. pathways[].name String The pathway name. incidents List(Incident) List of incidents that are attached to the issue. The list contains only the latest 100 incidents. incidents[].id String The incident ID. incidents[].events_count Integer The number of events used to create the incident. incidents[].title String The incident title. incidents[].description String The incident description. incidents[].labels Dictionary (String) A string to string mapping of the incident labels. Labels represent the unique entities that are used to describe the incident. incidents[].priority Enum The incident priority. Can be Critical, High, Medium, or Low. incidents[].sources List(String) The incident source. incidents[].state Enum(open, closed) The incident state. incidents[].opened_on String The date and time the incident was opened (in ISO format). incidents[].closed_on String The date and time the incident was closed (in ISO format). ui_name String Issue title. accumulations['alert/signal'] String Issue analysis summary golden signal/s (if applicable). accumulations['alert/components'] String Issue analysis summary golden components (if applicable). Jinja2 Default Payload Applied Intelligence uses a templating framework called Jinja2 in the Webhook interface. Here is a default Jinja2 payload to use: { \"id\": {{ id }}, \"url\": {{ url }}, \"ui_name\": {{ ui_name }}, \"description\": {{ description }}, \"priority\": {{ priority }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"active_since\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"sources\": {{ sources }}, \"incidents\": {{ incidents }}, \"pathways\": {{ pathways }}, } Copy Jinja2 Useful Syntax Below are a few useful Jinja2 commands to help you format your output. Casting a value to integer Example: “severity”: {{ priority | int }} Copy If clause to check if an attribute’s value is set Example: \"golden_signals\": {% if accumulations['alert/signal'] is defined %} {{ accumulations['alert/signal'] }} {% else %} None {% endif %} Copy For loop to iterate of an array of values: Example: \"description\": 'Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]' Copy Check if an array attribute's value is set: Example: \"hostname_field\": {% if incidents[0].labels['newrelic/tag/hostname'] is defined %} {{ incidents[0].labels['newrelic/tag/hostname'] }} {% else %} None {% endif %} Copy JSON schema Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). JSON schema template JSON schema: { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"definitions\": { \"Labels\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"LabelsSet\": { \"type\": \"array\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"$ref\": \"#/definitions/Labels\" }, \"uniqueItems\": true }, }, \"Annotations\": { \"type\": \"object\", \"title\": \"Additional contextual information about the Entity\", \"description\": \"Fields like title, description and priority can be described as annotations since\\nthey represent some additional information about the Incident.\\nFor example, the rule that creates the entity can have some logic that will create a title annotation field.\\nThe title will change according to the latest event received by the entity and as more\\nevent will keep coming the field may change, all this as a decision by the rule.\\nA different rule may decide not to populate the title at all.\\nSince a title can also be produced from the labels themselves.\", \"properties\": { \"title\": { \"type\": \"string\", \"maxLength\": 10000 }, \"description\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"patternProperties\": { \".*\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"Accumulations\": { \"type\": \"object\", \"title\": \"Accumulated data about the Incident\", \"description\": \"For example an entity with the label: host_name: foo will include a accumulated list of the\\nrelevant process names that are relevant to the entity. Accumulations will be derived from the events\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"type\": \"string\", \"maxLength\": 10000 } } }, \"IssueState\": { \"type\": \"string\", \"enum\": [ \"created\", \"active\", \"acknowledged\", \"closed\" ], \"properties\": {}, \"additionalProperties\": false }, \"Priority\": { \"type\": \"string\", \"enum\": [ \"critical\", \"high\", \"medium\", \"low\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueClosingReason\": { \"type\": \"string\", \"enum\": [ \"nacked\", \"resolved\", \"system\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueAction\": { \"type\": \"string\", \"enum\": [ \"ack\", \"snooze\", \"nack\", \"end_snooze\", \"expire_snooze\", \"star\", \"un_snooze\", \"unstar\", \"archive\", \"unarchive\", \"resolve\", \"reopen\", \"open\", \"feedback\", \"feedback_file\", \"open_ticket\", \"merge_issues\", \"active\", \"create\", \"close\", \"incident_updated\", \"confidence_changed\", \"diagnoses_changed\", \"rule_properties_changed\", \"flapping\", \"notification\", \"incident_events_limit_reached\", \"follow\", \"unfollow\", \"priority_updated\", \"comment\", \"incident_appended\", \"diagnosis_feedback\", \"flapping_delay_close\" ], \"properties\": {}, \"additionalProperties\": false }, \"StringKeyValue\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\" } }, \"JavaOptionalUuid\": { \"type\": \"string\", \"properties\": {}, \"additionalProperties\": false, \"format\": \"string-uuid\" } }, \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"customer_id\": { \"type\": \"integer\" }, \"labels_set\": { \"$ref\": \"#/definitions/LabelsSet\" }, \"annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations_version\": { \"type\": \"integer\" }, \"accumulations\": { \"$ref\": \"#/definitions/Accumulations\" }, \"state\": { \"$ref\": \"#/definitions/IssueState\" }, \"previous_state\": { \"$ref\": \"#/definitions/IssueState\" }, \"priority\": { \"$ref\": \"#/definitions/Priority\" }, \"closing_reason\": { \"oneOf\": [ { \"$ref\": \"#/definitions/IssueClosingReason\" }, { \"type\": \"null\" } ] }, \"modified_on\": { \"type\": \"integer\" }, \"created_on\": { \"type\": \"integer\" }, \"closed_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"acknowledged_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"active_since\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"assigned_to\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"created_by\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"progress_report\": { \"type\": \"array\", \"default\": [], \"items\": { \"type\": \"object\", \"properties\": { \"origin_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1 }, { \"type\": \"null\" } ] }, \"timestamp\": { \"type\": \"integer\" }, \"action_timestamp\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"origin_type\": { \"type\": \"string\", \"enum\": [ \"user\", \"system\" ] }, \"event_type\": { \"$ref\": \"#/definitions/IssueAction\" }, \"issue_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"format\": \"string-uuid\" }, { \"type\": \"null\" } ] }, \"attributes\": { \"oneOf\": [ { \"$ref\": \"#/definitions/StringKeyValue\" }, { \"type\": \"null\" } ] }, \"team_id\": { \"$ref\": \"#/definitions/JavaOptionalUuid\" } }, \"required\": [ \"timestamp\", \"origin_type\", \"event_type\" ], \"additionalProperties\": false }, \"uniqueItems\": true }, \"rule_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"maxLength\": 255 }, { \"type\": \"null\" } ] }, \"incident_ids\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"confidence\": { \"type\": \"number\", \"default\": 1.0, \"minimum\": 0.0, \"maximum\": 1.0 } }, \"required\": [ \"id\", \"customer_id\", \"labels_set\", \"annotations\", \"priority\", \"modified_on\", \"created_on\", \"confidence\" ], \"additionalProperties\": true } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.2002,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Incident <em>Intelligence</em> destination examples",
        "sections": "Incident <em>Intelligence</em> destination examples",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In <em>New</em> <em>Relic</em> <em>Applied</em> <em>Intelligence</em>, under Incident <em>Intelligence</em> click Destinations Add a WebHook In the end point paste the WebHook url"
      },
      "id": "6044280d64441f4af5378ed3"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-policies/specify-when-alerts-create-incidents": [
    {
      "sections": [
        "Update or disable policies and conditions",
        "Policy maintenance quick reference",
        "Add or remove policies assigned to a channel",
        "Change a policy name",
        "Check policy user assignment",
        "Check policy channel assignment",
        "Create a new policy",
        "Condition maintenance quick reference",
        "Add more conditions",
        "Copy a condition",
        "Change how threshold violations roll up into incidents",
        "Check for entities (targets) assigned to a policy",
        "Tip",
        "Change a condition",
        "Link to Incident Intelligence",
        "Disable or delete policies and conditions",
        "Disable or re-enable a condition",
        "Disable a policy",
        "Delete policy conditions",
        "Delete a policy"
      ],
      "title": "Update or disable policies and conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert policies"
      ],
      "external_id": "4a6c5107cd6af696df6a3fb0651c6a1bde7daf36",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-policies/update-or-disable-policies-conditions/",
      "published_at": "2021-05-28T11:10:28Z",
      "updated_at": "2021-05-21T15:35:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you create a policy, you can: Add more conditions to the policy. Edit the conditions' names, targets, or thresholds. Disable conditions. Continue the policy setup process by adding one or more notification channels to it. Rename or delete the policy. The user interface shows a Last modified timestamp for any changes to policies, including their conditions and notification channels. Policy maintenance quick reference Here is a quick reference which also includes links to more detailed information and procedures for maintaining your policies. Add or remove policies assigned to a channel To add or remove policies assigned to a channel: In the one.newrelic.com top nav, click Alerts & AI, click Notification channels, then (select a channel). Click Alert policies, then (select a policy). From the selected policy, use the windows to select, remove, or clear all. Change a policy name To rename a policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Click the policy name to edit it, then type a meaningful name for the policy (maximum 64 characters). Check policy user assignment To check whether an account user has been assigned any policies: In the one.newrelic.com top nav, click Alerts & AI, click Policies, (select a policy), then click Notification channels. Select a user, and then click Alert policies. Check policy channel assignment To check whether a notification channel has any policies assigned to it: In the one.newrelic.com top nav, click Alerts & AI, click Notification channels. The Policy subscriptions column lists how many policies are assigned to the channel. Create a new policy To create a new alert policy: In the one.newrelic.com top nav, click Alerts & AI, click Policies. Click New alert policy. Follow standard procedures to complete the basic setup process. Condition maintenance quick reference Here's a quick reference for maintaining a policy conditions. This includes the condition's entities (targets), Warning (yellow) and Critical (red) thresholds, and runbook URL. Add more conditions To add more conditions to a policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then click Add a condition. OR To copy a condition from any policy and add it to another policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then click Copy. Copy a condition To copy an existing condition, including its targets and thresholds, and add it to another policy for the selected account: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). From the policy's list of one or more Alert conditions, click Copy. From the Copy alert condition list, search or scroll the list to select the policy where you want to add this condition. Optional: Change the condition's name if necessary. Select Save. By default, the copied condition will be added to the selected alert policy in a Disabled state. Follow standard procedures to add or copy additional conditions to the alert policy, and then Enable the condition as needed. Change how threshold violations roll up into incidents To select how violations to your thresholds are grouped into incident records (by policy, by condition, or by target and condition): In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Click Incident preference. Check for entities (targets) assigned to a policy To check whether an entity (target) has any policies assigned: Go to the product (APM, Browser, etc.). From the selected product's index, check whether the entity's color-coded health status is light green with an icon. Tip Exception: Infrastructure does not use this feature. Change a condition To change a policy condition: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Then, from the list of Alert conditions for the selected policy: To change the condition's name, click Edit. To add, change, or remove targets (entities), select the name or number of targets for the condition, and then select Browse and select targets. To update the values for the required Critical (red) or optional Warning (yellow) thresholds, select the existing value. To update the condition's runbook URL, select the condition's Thresholds. Link to Incident Intelligence If you use Applied Intelligence, you can connect your conditions to Incident Intelligence. To do this, switch the Connect to Incident Intelligence to ON. Disable or delete policies and conditions If you disable or delete a policy, we'll continue to apply any other policies assigned to the product entity (target). If you remove all policies for the entity, its color-coded health status indicator will appear light green with an icon. Disable or re-enable a condition You can enable or disable any policy conditions, and the policy will continue to apply. To disable or re-enable a condition: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Then, from the list of Alert conditions, (select a condition). Click the On/Off switch to toggle it. Tip For Infrastructure conditions, use the checkbox at the bottom of the condition edit screen, then save the condition. If you copy a condition, it is automatically saved in the new policy as disabled (Off), even if the condition was enabled (On) in the original policy. Disable a policy You can't disable a policy directly. However, you can disable all of the policy's conditions. When you disable all of the conditions, the policy will continue to appear on the Alert policies index. The policy itself isn't disabled, and you can re-enable any or all of its conditions at any time. Delete policy conditions If a policy has multiple conditions, you can delete any or all of them, and the remaining conditions for the policy will continue to apply. To turn a condition off but keep it with the policy, disable it. To delete one or more conditions: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). From the list of Alert conditions, (select a condition), then click Delete. Tip If you don't see the delete button, your account admin may have disabled condition deletion for your organization. Delete a policy If you delete any of your account's policies, you can't restore them. Instead, you must re-create them if necessary. To delete a policy completely: In the one.newrelic.com top nav, click Alerts & AI, then click Alert policies. From the policy row, click the delete icon. Any notification channels associated with a deleted or disabled policy will remain. You must delete notification channels or remove them individually as necessary. You will still be able to view incidents and event violations related to the deleted policy. However, these records will be read only.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 237.02197,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Update or disable <em>policies</em> <em>and</em> conditions",
        "sections": "Update or disable <em>policies</em> <em>and</em> conditions",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " to it: In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click Notification channels. The Policy subscriptions column lists how many <em>policies</em> are assigned to the channel. Create a <em>new</em> policy To create a <em>new</em> <em>alert</em> policy: In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click <em>Policies</em>. Click <em>New</em> <em>alert</em> policy. Follow"
      },
      "id": "604404ec28ccbc62492c6098"
    },
    {
      "sections": [
        "Incident Intelligence destination examples",
        "Destination template examples",
        "Suggested OpsGenie template example",
        "Suggested ServiceNow template example",
        "Suggested Slack template example",
        "Suggested VictorOps template example",
        "Webhook and JSON format examples",
        "Webhook format and JSON example",
        "Jinja2 Default Payload",
        "Jinja2 Useful Syntax",
        "JSON schema",
        "JSON schema template"
      ],
      "title": "Incident Intelligence destination examples",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "a516d04f8b75541a6dc9338fa3ce9645ba87d620",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/incident-intelligence-destination-examples/",
      "published_at": "2021-06-02T18:22:22Z",
      "updated_at": "2021-06-02T18:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Destinations are the data outputs to Applied Intelligence, where you can view your automatically correlated incidents. You can configure Incident Intelligence destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema. Destination template examples The following template example destinations are formatted in Jinja2. Suggested OpsGenie template example { \"alias\": {{ id }}, \"message\": {{ ui_name }}, \"source\": '{{ sources }}', \"priority\": {{ priority }}, \"details\": { \"self_url\": {{ url }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"is_correlated\": {{ is_correlated }} }, \"description\": \"\"\"Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]\"\"\" } Copy Suggested ServiceNow template example { \"short_description\": {{ ui_name }}, \"description\": 'Issue Id: {{ id }}, \\n Description: {{ description }}, \\n Sources: {{ sources }}, \\n Priority: {{ priority }}, \\n Details: { \\n self_url: {{ url }}, \\n state: {{ state }}, \\n is_correlated: {{ is_correlated }}, \\n created_on: {{ created_on }}, \\n modified_on: {{ modified_on }}, \\n activated_on: {{ active_since }}, \\n closed_on: {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \\n is_correlated: {{is_correlated}} }, \\n\\n incidents: {{ incidents }}, \\n\\n pathways: {{ pathways }}' } Copy Suggested Slack template example Go to Slack incoming WebHooks Choose the right Slack workspace and click \"Add to Slack\" Select the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In New Relic Applied Intelligence, under Incident Intelligence click Destinations Add a WebHook In the end point paste the WebHook url from slack. In the custom payload, paste the following JSON: { \"blocks\": [ { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*New Relic Incident Intelligence Alert*\" } }, { \"type\": \"divider\" }, { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*CUSTOM FIELDS*:\" }, \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue ID*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Issue Title*\" }, { \"type\": \"plain_text\", \"text\": {{ id }} }, { \"type\": \"plain_text\", \"text\": {{ ui_name }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue URL*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Description*\" }, { \"type\": \"mrkdwn\", \"text\": {{ url }} }, { \"type\": \"plain_text\", \"text\": {{ description }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*State*\" }, { \"type\": \"mrkdwn\", \"text\": \"*is_correlated*\" }, { \"type\": \"plain_text\", \"text\": {{ state }} }, { \"type\": \"plain_text\", \"text\": \"{{ is_correlated }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Created On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Modified On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ created_on }}\" }, { \"type\": \"plain_text\", \"text\": \"{{ modified_on }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Activated On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Closed On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ active_since }}\" }, { \"type\": \"plain_text\", \"text\": \"{% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Aggregated Incidents*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Monitoring Tool*\" }, { \"type\": \"plain_text\", \"text\": \"{{ incident_count }}\" }, { \"type\": \"plain_text\", \"text\": {{ sources|join(', ') }} } ] } ] } Copy Suggested VictorOps template example { \"monitoring_tool\": {{ sources }}, {% if state == 'closed' %} \"message_type\": \"OK\", {% else %} \"message_type\": {{ priority }}, {% endif %} \"custom_fields\": { \"issue_url\": {{ url }}, \"description\": {{ description }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"related_incidents\": [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %} {% endfor %} ] }, \"state_message\": {{ description }}, \"entity_id\": {{ id }}, \"entity_display_name\": {{ ui_name }}, \"vo_annotate.u.NRAI_Link\": {{ url }} } Copy Webhook and JSON format examples Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). If you use webhooks to configure Incident Intelligence destinations, use these examples of the webhook body format and JSON schema. Webhook format and JSON example Webhook format: Name Description url Href A link to the UI where the issue can be seen. id String Unique identifier for the issue. title String The issue title. description String The description of the issue. priority Enum The issue priority. Can be Critical, High, Medium, or Low. state Enum The issue status. Can be Active, Closed, or Acknowledged. is_correlated Boolean True if the issue is based on correlated data. created_on String The date and time the issue was created (in ISO format). modified_on String The date and time the issue was modified (in ISO format). active_since String The date and time the issue was activated (in ISO format). closed_on String The date and time the issue was closed (in ISO format). sources List(String) List of the different sources that were used to send the events into Applied Intelligence (for example: PagerDuty). pathways List(Pathways) List of pathways that are associated with the issue. Each pathway contains an id and name: [{“id”: “pathway id”, “name”: “pathway name”}]. pathways[].id String The pathway ID. pathways[].name String The pathway name. incidents List(Incident) List of incidents that are attached to the issue. The list contains only the latest 100 incidents. incidents[].id String The incident ID. incidents[].events_count Integer The number of events used to create the incident. incidents[].title String The incident title. incidents[].description String The incident description. incidents[].labels Dictionary (String) A string to string mapping of the incident labels. Labels represent the unique entities that are used to describe the incident. incidents[].priority Enum The incident priority. Can be Critical, High, Medium, or Low. incidents[].sources List(String) The incident source. incidents[].state Enum(open, closed) The incident state. incidents[].opened_on String The date and time the incident was opened (in ISO format). incidents[].closed_on String The date and time the incident was closed (in ISO format). ui_name String Issue title. accumulations['alert/signal'] String Issue analysis summary golden signal/s (if applicable). accumulations['alert/components'] String Issue analysis summary golden components (if applicable). Jinja2 Default Payload Applied Intelligence uses a templating framework called Jinja2 in the Webhook interface. Here is a default Jinja2 payload to use: { \"id\": {{ id }}, \"url\": {{ url }}, \"ui_name\": {{ ui_name }}, \"description\": {{ description }}, \"priority\": {{ priority }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"active_since\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"sources\": {{ sources }}, \"incidents\": {{ incidents }}, \"pathways\": {{ pathways }}, } Copy Jinja2 Useful Syntax Below are a few useful Jinja2 commands to help you format your output. Casting a value to integer Example: “severity”: {{ priority | int }} Copy If clause to check if an attribute’s value is set Example: \"golden_signals\": {% if accumulations['alert/signal'] is defined %} {{ accumulations['alert/signal'] }} {% else %} None {% endif %} Copy For loop to iterate of an array of values: Example: \"description\": 'Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]' Copy Check if an array attribute's value is set: Example: \"hostname_field\": {% if incidents[0].labels['newrelic/tag/hostname'] is defined %} {{ incidents[0].labels['newrelic/tag/hostname'] }} {% else %} None {% endif %} Copy JSON schema Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). JSON schema template JSON schema: { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"definitions\": { \"Labels\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"LabelsSet\": { \"type\": \"array\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"$ref\": \"#/definitions/Labels\" }, \"uniqueItems\": true }, }, \"Annotations\": { \"type\": \"object\", \"title\": \"Additional contextual information about the Entity\", \"description\": \"Fields like title, description and priority can be described as annotations since\\nthey represent some additional information about the Incident.\\nFor example, the rule that creates the entity can have some logic that will create a title annotation field.\\nThe title will change according to the latest event received by the entity and as more\\nevent will keep coming the field may change, all this as a decision by the rule.\\nA different rule may decide not to populate the title at all.\\nSince a title can also be produced from the labels themselves.\", \"properties\": { \"title\": { \"type\": \"string\", \"maxLength\": 10000 }, \"description\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"patternProperties\": { \".*\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"Accumulations\": { \"type\": \"object\", \"title\": \"Accumulated data about the Incident\", \"description\": \"For example an entity with the label: host_name: foo will include a accumulated list of the\\nrelevant process names that are relevant to the entity. Accumulations will be derived from the events\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"type\": \"string\", \"maxLength\": 10000 } } }, \"IssueState\": { \"type\": \"string\", \"enum\": [ \"created\", \"active\", \"acknowledged\", \"closed\" ], \"properties\": {}, \"additionalProperties\": false }, \"Priority\": { \"type\": \"string\", \"enum\": [ \"critical\", \"high\", \"medium\", \"low\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueClosingReason\": { \"type\": \"string\", \"enum\": [ \"nacked\", \"resolved\", \"system\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueAction\": { \"type\": \"string\", \"enum\": [ \"ack\", \"snooze\", \"nack\", \"end_snooze\", \"expire_snooze\", \"star\", \"un_snooze\", \"unstar\", \"archive\", \"unarchive\", \"resolve\", \"reopen\", \"open\", \"feedback\", \"feedback_file\", \"open_ticket\", \"merge_issues\", \"active\", \"create\", \"close\", \"incident_updated\", \"confidence_changed\", \"diagnoses_changed\", \"rule_properties_changed\", \"flapping\", \"notification\", \"incident_events_limit_reached\", \"follow\", \"unfollow\", \"priority_updated\", \"comment\", \"incident_appended\", \"diagnosis_feedback\", \"flapping_delay_close\" ], \"properties\": {}, \"additionalProperties\": false }, \"StringKeyValue\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\" } }, \"JavaOptionalUuid\": { \"type\": \"string\", \"properties\": {}, \"additionalProperties\": false, \"format\": \"string-uuid\" } }, \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"customer_id\": { \"type\": \"integer\" }, \"labels_set\": { \"$ref\": \"#/definitions/LabelsSet\" }, \"annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations_version\": { \"type\": \"integer\" }, \"accumulations\": { \"$ref\": \"#/definitions/Accumulations\" }, \"state\": { \"$ref\": \"#/definitions/IssueState\" }, \"previous_state\": { \"$ref\": \"#/definitions/IssueState\" }, \"priority\": { \"$ref\": \"#/definitions/Priority\" }, \"closing_reason\": { \"oneOf\": [ { \"$ref\": \"#/definitions/IssueClosingReason\" }, { \"type\": \"null\" } ] }, \"modified_on\": { \"type\": \"integer\" }, \"created_on\": { \"type\": \"integer\" }, \"closed_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"acknowledged_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"active_since\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"assigned_to\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"created_by\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"progress_report\": { \"type\": \"array\", \"default\": [], \"items\": { \"type\": \"object\", \"properties\": { \"origin_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1 }, { \"type\": \"null\" } ] }, \"timestamp\": { \"type\": \"integer\" }, \"action_timestamp\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"origin_type\": { \"type\": \"string\", \"enum\": [ \"user\", \"system\" ] }, \"event_type\": { \"$ref\": \"#/definitions/IssueAction\" }, \"issue_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"format\": \"string-uuid\" }, { \"type\": \"null\" } ] }, \"attributes\": { \"oneOf\": [ { \"$ref\": \"#/definitions/StringKeyValue\" }, { \"type\": \"null\" } ] }, \"team_id\": { \"$ref\": \"#/definitions/JavaOptionalUuid\" } }, \"required\": [ \"timestamp\", \"origin_type\", \"event_type\" ], \"additionalProperties\": false }, \"uniqueItems\": true }, \"rule_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"maxLength\": 255 }, { \"type\": \"null\" } ] }, \"incident_ids\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"confidence\": { \"type\": \"number\", \"default\": 1.0, \"minimum\": 0.0, \"maximum\": 1.0 } }, \"required\": [ \"id\", \"customer_id\", \"labels_set\", \"annotations\", \"priority\", \"modified_on\", \"created_on\", \"confidence\" ], \"additionalProperties\": true } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.20003,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Incident <em>Intelligence</em> destination examples",
        "sections": "Incident <em>Intelligence</em> destination examples",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In <em>New</em> <em>Relic</em> <em>Applied</em> <em>Intelligence</em>, under Incident <em>Intelligence</em> click Destinations Add a WebHook In the end point paste the WebHook url"
      },
      "id": "6044280d64441f4af5378ed3"
    },
    {
      "sections": [
        "Provide runbook instructions for alert activity",
        "For more help"
      ],
      "title": "Provide runbook instructions for alert activity",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "209676f38e20698c66798037bc5517598344c2de",
      "image": "https://docs.newrelic.com/static/f991e6b8f9d85697c3fdd280d522d403/8c557/040815alerts-runbook-url_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/provide-runbook-instructions-alert-activity/",
      "published_at": "2021-05-28T03:27:44Z",
      "updated_at": "2021-03-13T04:41:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alert conditions include the option to identify the URL for your runbook instructions. This allows you to link to information or standard procedures for handling an incident opened when a situation breaches the condition's critical threshold. In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then (select a condition): You can add a runbook URL so that personnel handling the incident that triggered the alert will know what to do. To edit the runbook URL associated with a condition: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then (select a condition). On the Edit conditions page, click Add runbook URL, then provide the full path for your runbook URL (runbook URL, URL to internal wiki page, etc.), and then save. Optional: To change or delete an existing runbook URL from the alert condition, click Remove. We'll include your runbook URL in Incident details and in email notifications so that personnel will know exactly what to do. For more help Additional documentation resources include: Policy workflow (basic process to set up your alert policies) View or update user email channels (maintaining the selected account's user emails as notification channels) Explore the incident history (examine details about incidents, take action, and skim for patterns)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.85924,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Provide runbook instructions for <em>alert</em> activity",
        "sections": "Provide runbook instructions for <em>alert</em> activity",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": ", click <em>Alert</em> <em>policies</em>, (select a policy), then (select a condition): You can add a runbook URL so that personnel handling the incident that triggered the <em>alert</em> will know what to do. To edit the runbook URL associated with a condition: In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click <em>Alert</em>"
      },
      "id": "60440c0128ccbcdf7b2c60b8"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-policies/update-or-disable-policies-conditions": [
    {
      "sections": [
        "Specify when alerts create incidents",
        "Tip",
        "Incident preference options",
        "Select your incident preference",
        "Example: By policy (default)",
        "Example: By condition",
        "Example: By condition and signal",
        "For more help"
      ],
      "title": "Specify when alerts create incidents",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert policies"
      ],
      "external_id": "7ddf9dfd669866e413eb87573c063ecf558747bf",
      "image": "https://docs.newrelic.com/static/233d82abf03b4f77340c757671f3a96a/8c557/example-policy-incident.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-policies/specify-when-alerts-create-incidents/",
      "published_at": "2021-05-27T20:34:28Z",
      "updated_at": "2021-04-12T02:19:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When a policy condition violates a Critical (red) threshold, it can create an incident record with detailed information to help you respond efficiently. An incident is a collection of one or more violations. It includes all of the open and close timestamps for each violation. The incident record will include any Warning (yellow) violations which occurred after the opening Critical (red) threshold violation. Notifications are sent to every notification channel on the policy when an incident opens, if and when an incident is acknowledged, and when an incident closes. Tip To select when alerts create incidents and how violations are grouped, use the Incident preference setting inside your policy. Then, to view the alerts policy violations (incident records), select the Incidents indexes. Incident preference options Each option for incident preference has its own advantages. You can select any option for any policy. Incident preference Comments By policy (default) Only one incident will be open at a time for the entire policy. Fewest number of notifications Requires immediate action and closing the incidents to be effective By condition One incident will be open at a time for each condition in your policy. More notifications Useful for policies containing conditions that focus on entities that perform the same job; for example, hosts that all serve the same application(s) By condition and signal An incident will be created for every violation in your policy. The most notifications Useful if you need to be notified of every violation or if you have an external system where you want to send alert notifications Select your incident preference By default, a single incident record will be created for each policy. one.newrelic.com > Alert & AI > Policies > (select a policy): The selected policy page shows how alerts rolls up incidents for alert notifications and UI details. (Default is By policy). To choose a different option for this policy, click Incident preference. To change the incident preference for the selected policy: In the one.newrelic.com top nav, click Alerts & AI, then click Policies, and then (select a policy). Click Incident preference, select your choice of available options, and then save. Repeat these steps for each policy as needed. Example: By policy (default) When you select the default (By policy) as your incident preference, it will group all condition violations into the same incident. By default, a single incident record will be created for each alert policy. If additional conditions are violated by any target after the incident opens, the violations are added to the same incident. Only one incident appears on your Incidents indexes for the selected policy. Selecting the By policy preference is the most general option. All condition violations for every target will be accumulated into a single incident record. Example: By condition When you select By condition as your incident preference, it will group all violations by any target for a specific condition into separate incidents. Selecting the By condition option is useful, for example, when you want an individual incident record to focus on a specific condition. If the policy has multiple conditions, separate incident records for each condition will appear on your Incidents indexes. If a target violates a condition for the alert policy, an incident record will be created. If the same target violates another condition for the alert policy, another incident record will be created. If additional targets violate the same condition after the incident opens, these violations will be added to the incident record already open for that condition. Example: By condition and signal When you select By condition and signal as your incident preference, it will not group violations at all. A new incident will be created for every violation that occurs in your policy. Selecting the By condition and signal option is the most granular level for creating incident records. This is useful, for example, when you want to closely monitor anything that is occurring anywhere across your infrastructure. An incident will appear on your Incidents indexes for every violation that occurs within your policy. For more help Additional documentation resources include: Alert policy workflow (basic process to set up your alert policies, regardless of which New Relic product uses the alert policy) Explore the incident history (examine details about alert policy violations, take action, and skim for patterns)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.93845,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Specify when <em>alerts</em> create incidents",
        "sections": "Specify when <em>alerts</em> create incidents",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " that occurs within your policy. For more help Additional documentation resources include: <em>Alert</em> policy workflow (basic process to set up your <em>alert</em> <em>policies</em>, regardless of which <em>New</em> <em>Relic</em> product uses the <em>alert</em> policy) Explore the incident history (examine details about <em>alert</em> policy violations, take action, and skim for patterns)"
      },
      "id": "603e9efd28ccbc79eeeba786"
    },
    {
      "sections": [
        "Incident Intelligence destination examples",
        "Destination template examples",
        "Suggested OpsGenie template example",
        "Suggested ServiceNow template example",
        "Suggested Slack template example",
        "Suggested VictorOps template example",
        "Webhook and JSON format examples",
        "Webhook format and JSON example",
        "Jinja2 Default Payload",
        "Jinja2 Useful Syntax",
        "JSON schema",
        "JSON schema template"
      ],
      "title": "Incident Intelligence destination examples",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "a516d04f8b75541a6dc9338fa3ce9645ba87d620",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/incident-intelligence-destination-examples/",
      "published_at": "2021-06-02T18:22:22Z",
      "updated_at": "2021-06-02T18:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Destinations are the data outputs to Applied Intelligence, where you can view your automatically correlated incidents. You can configure Incident Intelligence destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema. Destination template examples The following template example destinations are formatted in Jinja2. Suggested OpsGenie template example { \"alias\": {{ id }}, \"message\": {{ ui_name }}, \"source\": '{{ sources }}', \"priority\": {{ priority }}, \"details\": { \"self_url\": {{ url }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"is_correlated\": {{ is_correlated }} }, \"description\": \"\"\"Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]\"\"\" } Copy Suggested ServiceNow template example { \"short_description\": {{ ui_name }}, \"description\": 'Issue Id: {{ id }}, \\n Description: {{ description }}, \\n Sources: {{ sources }}, \\n Priority: {{ priority }}, \\n Details: { \\n self_url: {{ url }}, \\n state: {{ state }}, \\n is_correlated: {{ is_correlated }}, \\n created_on: {{ created_on }}, \\n modified_on: {{ modified_on }}, \\n activated_on: {{ active_since }}, \\n closed_on: {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \\n is_correlated: {{is_correlated}} }, \\n\\n incidents: {{ incidents }}, \\n\\n pathways: {{ pathways }}' } Copy Suggested Slack template example Go to Slack incoming WebHooks Choose the right Slack workspace and click \"Add to Slack\" Select the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In New Relic Applied Intelligence, under Incident Intelligence click Destinations Add a WebHook In the end point paste the WebHook url from slack. In the custom payload, paste the following JSON: { \"blocks\": [ { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*New Relic Incident Intelligence Alert*\" } }, { \"type\": \"divider\" }, { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*CUSTOM FIELDS*:\" }, \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue ID*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Issue Title*\" }, { \"type\": \"plain_text\", \"text\": {{ id }} }, { \"type\": \"plain_text\", \"text\": {{ ui_name }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue URL*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Description*\" }, { \"type\": \"mrkdwn\", \"text\": {{ url }} }, { \"type\": \"plain_text\", \"text\": {{ description }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*State*\" }, { \"type\": \"mrkdwn\", \"text\": \"*is_correlated*\" }, { \"type\": \"plain_text\", \"text\": {{ state }} }, { \"type\": \"plain_text\", \"text\": \"{{ is_correlated }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Created On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Modified On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ created_on }}\" }, { \"type\": \"plain_text\", \"text\": \"{{ modified_on }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Activated On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Closed On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ active_since }}\" }, { \"type\": \"plain_text\", \"text\": \"{% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Aggregated Incidents*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Monitoring Tool*\" }, { \"type\": \"plain_text\", \"text\": \"{{ incident_count }}\" }, { \"type\": \"plain_text\", \"text\": {{ sources|join(', ') }} } ] } ] } Copy Suggested VictorOps template example { \"monitoring_tool\": {{ sources }}, {% if state == 'closed' %} \"message_type\": \"OK\", {% else %} \"message_type\": {{ priority }}, {% endif %} \"custom_fields\": { \"issue_url\": {{ url }}, \"description\": {{ description }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"related_incidents\": [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %} {% endfor %} ] }, \"state_message\": {{ description }}, \"entity_id\": {{ id }}, \"entity_display_name\": {{ ui_name }}, \"vo_annotate.u.NRAI_Link\": {{ url }} } Copy Webhook and JSON format examples Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). If you use webhooks to configure Incident Intelligence destinations, use these examples of the webhook body format and JSON schema. Webhook format and JSON example Webhook format: Name Description url Href A link to the UI where the issue can be seen. id String Unique identifier for the issue. title String The issue title. description String The description of the issue. priority Enum The issue priority. Can be Critical, High, Medium, or Low. state Enum The issue status. Can be Active, Closed, or Acknowledged. is_correlated Boolean True if the issue is based on correlated data. created_on String The date and time the issue was created (in ISO format). modified_on String The date and time the issue was modified (in ISO format). active_since String The date and time the issue was activated (in ISO format). closed_on String The date and time the issue was closed (in ISO format). sources List(String) List of the different sources that were used to send the events into Applied Intelligence (for example: PagerDuty). pathways List(Pathways) List of pathways that are associated with the issue. Each pathway contains an id and name: [{“id”: “pathway id”, “name”: “pathway name”}]. pathways[].id String The pathway ID. pathways[].name String The pathway name. incidents List(Incident) List of incidents that are attached to the issue. The list contains only the latest 100 incidents. incidents[].id String The incident ID. incidents[].events_count Integer The number of events used to create the incident. incidents[].title String The incident title. incidents[].description String The incident description. incidents[].labels Dictionary (String) A string to string mapping of the incident labels. Labels represent the unique entities that are used to describe the incident. incidents[].priority Enum The incident priority. Can be Critical, High, Medium, or Low. incidents[].sources List(String) The incident source. incidents[].state Enum(open, closed) The incident state. incidents[].opened_on String The date and time the incident was opened (in ISO format). incidents[].closed_on String The date and time the incident was closed (in ISO format). ui_name String Issue title. accumulations['alert/signal'] String Issue analysis summary golden signal/s (if applicable). accumulations['alert/components'] String Issue analysis summary golden components (if applicable). Jinja2 Default Payload Applied Intelligence uses a templating framework called Jinja2 in the Webhook interface. Here is a default Jinja2 payload to use: { \"id\": {{ id }}, \"url\": {{ url }}, \"ui_name\": {{ ui_name }}, \"description\": {{ description }}, \"priority\": {{ priority }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"active_since\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"sources\": {{ sources }}, \"incidents\": {{ incidents }}, \"pathways\": {{ pathways }}, } Copy Jinja2 Useful Syntax Below are a few useful Jinja2 commands to help you format your output. Casting a value to integer Example: “severity”: {{ priority | int }} Copy If clause to check if an attribute’s value is set Example: \"golden_signals\": {% if accumulations['alert/signal'] is defined %} {{ accumulations['alert/signal'] }} {% else %} None {% endif %} Copy For loop to iterate of an array of values: Example: \"description\": 'Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]' Copy Check if an array attribute's value is set: Example: \"hostname_field\": {% if incidents[0].labels['newrelic/tag/hostname'] is defined %} {{ incidents[0].labels['newrelic/tag/hostname'] }} {% else %} None {% endif %} Copy JSON schema Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). JSON schema template JSON schema: { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"definitions\": { \"Labels\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"LabelsSet\": { \"type\": \"array\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"$ref\": \"#/definitions/Labels\" }, \"uniqueItems\": true }, }, \"Annotations\": { \"type\": \"object\", \"title\": \"Additional contextual information about the Entity\", \"description\": \"Fields like title, description and priority can be described as annotations since\\nthey represent some additional information about the Incident.\\nFor example, the rule that creates the entity can have some logic that will create a title annotation field.\\nThe title will change according to the latest event received by the entity and as more\\nevent will keep coming the field may change, all this as a decision by the rule.\\nA different rule may decide not to populate the title at all.\\nSince a title can also be produced from the labels themselves.\", \"properties\": { \"title\": { \"type\": \"string\", \"maxLength\": 10000 }, \"description\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"patternProperties\": { \".*\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"Accumulations\": { \"type\": \"object\", \"title\": \"Accumulated data about the Incident\", \"description\": \"For example an entity with the label: host_name: foo will include a accumulated list of the\\nrelevant process names that are relevant to the entity. Accumulations will be derived from the events\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"type\": \"string\", \"maxLength\": 10000 } } }, \"IssueState\": { \"type\": \"string\", \"enum\": [ \"created\", \"active\", \"acknowledged\", \"closed\" ], \"properties\": {}, \"additionalProperties\": false }, \"Priority\": { \"type\": \"string\", \"enum\": [ \"critical\", \"high\", \"medium\", \"low\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueClosingReason\": { \"type\": \"string\", \"enum\": [ \"nacked\", \"resolved\", \"system\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueAction\": { \"type\": \"string\", \"enum\": [ \"ack\", \"snooze\", \"nack\", \"end_snooze\", \"expire_snooze\", \"star\", \"un_snooze\", \"unstar\", \"archive\", \"unarchive\", \"resolve\", \"reopen\", \"open\", \"feedback\", \"feedback_file\", \"open_ticket\", \"merge_issues\", \"active\", \"create\", \"close\", \"incident_updated\", \"confidence_changed\", \"diagnoses_changed\", \"rule_properties_changed\", \"flapping\", \"notification\", \"incident_events_limit_reached\", \"follow\", \"unfollow\", \"priority_updated\", \"comment\", \"incident_appended\", \"diagnosis_feedback\", \"flapping_delay_close\" ], \"properties\": {}, \"additionalProperties\": false }, \"StringKeyValue\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\" } }, \"JavaOptionalUuid\": { \"type\": \"string\", \"properties\": {}, \"additionalProperties\": false, \"format\": \"string-uuid\" } }, \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"customer_id\": { \"type\": \"integer\" }, \"labels_set\": { \"$ref\": \"#/definitions/LabelsSet\" }, \"annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations_version\": { \"type\": \"integer\" }, \"accumulations\": { \"$ref\": \"#/definitions/Accumulations\" }, \"state\": { \"$ref\": \"#/definitions/IssueState\" }, \"previous_state\": { \"$ref\": \"#/definitions/IssueState\" }, \"priority\": { \"$ref\": \"#/definitions/Priority\" }, \"closing_reason\": { \"oneOf\": [ { \"$ref\": \"#/definitions/IssueClosingReason\" }, { \"type\": \"null\" } ] }, \"modified_on\": { \"type\": \"integer\" }, \"created_on\": { \"type\": \"integer\" }, \"closed_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"acknowledged_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"active_since\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"assigned_to\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"created_by\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"progress_report\": { \"type\": \"array\", \"default\": [], \"items\": { \"type\": \"object\", \"properties\": { \"origin_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1 }, { \"type\": \"null\" } ] }, \"timestamp\": { \"type\": \"integer\" }, \"action_timestamp\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"origin_type\": { \"type\": \"string\", \"enum\": [ \"user\", \"system\" ] }, \"event_type\": { \"$ref\": \"#/definitions/IssueAction\" }, \"issue_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"format\": \"string-uuid\" }, { \"type\": \"null\" } ] }, \"attributes\": { \"oneOf\": [ { \"$ref\": \"#/definitions/StringKeyValue\" }, { \"type\": \"null\" } ] }, \"team_id\": { \"$ref\": \"#/definitions/JavaOptionalUuid\" } }, \"required\": [ \"timestamp\", \"origin_type\", \"event_type\" ], \"additionalProperties\": false }, \"uniqueItems\": true }, \"rule_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"maxLength\": 255 }, { \"type\": \"null\" } ] }, \"incident_ids\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"confidence\": { \"type\": \"number\", \"default\": 1.0, \"minimum\": 0.0, \"maximum\": 1.0 } }, \"required\": [ \"id\", \"customer_id\", \"labels_set\", \"annotations\", \"priority\", \"modified_on\", \"created_on\", \"confidence\" ], \"additionalProperties\": true } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.20003,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Incident <em>Intelligence</em> destination examples",
        "sections": "Incident <em>Intelligence</em> destination examples",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In <em>New</em> <em>Relic</em> <em>Applied</em> <em>Intelligence</em>, under Incident <em>Intelligence</em> click Destinations Add a WebHook In the end point paste the WebHook url"
      },
      "id": "6044280d64441f4af5378ed3"
    },
    {
      "sections": [
        "Provide runbook instructions for alert activity",
        "For more help"
      ],
      "title": "Provide runbook instructions for alert activity",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert conditions"
      ],
      "external_id": "209676f38e20698c66798037bc5517598344c2de",
      "image": "https://docs.newrelic.com/static/f991e6b8f9d85697c3fdd280d522d403/8c557/040815alerts-runbook-url_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-conditions/provide-runbook-instructions-alert-activity/",
      "published_at": "2021-05-28T03:27:44Z",
      "updated_at": "2021-03-13T04:41:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Alert conditions include the option to identify the URL for your runbook instructions. This allows you to link to information or standard procedures for handling an incident opened when a situation breaches the condition's critical threshold. In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then (select a condition): You can add a runbook URL so that personnel handling the incident that triggered the alert will know what to do. To edit the runbook URL associated with a condition: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then (select a condition). On the Edit conditions page, click Add runbook URL, then provide the full path for your runbook URL (runbook URL, URL to internal wiki page, etc.), and then save. Optional: To change or delete an existing runbook URL from the alert condition, click Remove. We'll include your runbook URL in Incident details and in email notifications so that personnel will know exactly what to do. For more help Additional documentation resources include: Policy workflow (basic process to set up your alert policies) View or update user email channels (maintaining the selected account's user emails as notification channels) Explore the incident history (examine details about incidents, take action, and skim for patterns)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.85924,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Provide runbook instructions for <em>alert</em> activity",
        "sections": "Provide runbook instructions for <em>alert</em> activity",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": ", click <em>Alert</em> <em>policies</em>, (select a policy), then (select a condition): You can add a runbook URL so that personnel handling the incident that triggered the <em>alert</em> will know what to do. To edit the runbook URL associated with a condition: In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click <em>Alert</em>"
      },
      "id": "60440c0128ccbcdf7b2c60b8"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-policies/view-policies-conditions-our-products": [
    {
      "sections": [
        "Update or disable policies and conditions",
        "Policy maintenance quick reference",
        "Add or remove policies assigned to a channel",
        "Change a policy name",
        "Check policy user assignment",
        "Check policy channel assignment",
        "Create a new policy",
        "Condition maintenance quick reference",
        "Add more conditions",
        "Copy a condition",
        "Change how threshold violations roll up into incidents",
        "Check for entities (targets) assigned to a policy",
        "Tip",
        "Change a condition",
        "Link to Incident Intelligence",
        "Disable or delete policies and conditions",
        "Disable or re-enable a condition",
        "Disable a policy",
        "Delete policy conditions",
        "Delete a policy"
      ],
      "title": "Update or disable policies and conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert policies"
      ],
      "external_id": "4a6c5107cd6af696df6a3fb0651c6a1bde7daf36",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-policies/update-or-disable-policies-conditions/",
      "published_at": "2021-05-28T11:10:28Z",
      "updated_at": "2021-05-21T15:35:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you create a policy, you can: Add more conditions to the policy. Edit the conditions' names, targets, or thresholds. Disable conditions. Continue the policy setup process by adding one or more notification channels to it. Rename or delete the policy. The user interface shows a Last modified timestamp for any changes to policies, including their conditions and notification channels. Policy maintenance quick reference Here is a quick reference which also includes links to more detailed information and procedures for maintaining your policies. Add or remove policies assigned to a channel To add or remove policies assigned to a channel: In the one.newrelic.com top nav, click Alerts & AI, click Notification channels, then (select a channel). Click Alert policies, then (select a policy). From the selected policy, use the windows to select, remove, or clear all. Change a policy name To rename a policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Click the policy name to edit it, then type a meaningful name for the policy (maximum 64 characters). Check policy user assignment To check whether an account user has been assigned any policies: In the one.newrelic.com top nav, click Alerts & AI, click Policies, (select a policy), then click Notification channels. Select a user, and then click Alert policies. Check policy channel assignment To check whether a notification channel has any policies assigned to it: In the one.newrelic.com top nav, click Alerts & AI, click Notification channels. The Policy subscriptions column lists how many policies are assigned to the channel. Create a new policy To create a new alert policy: In the one.newrelic.com top nav, click Alerts & AI, click Policies. Click New alert policy. Follow standard procedures to complete the basic setup process. Condition maintenance quick reference Here's a quick reference for maintaining a policy conditions. This includes the condition's entities (targets), Warning (yellow) and Critical (red) thresholds, and runbook URL. Add more conditions To add more conditions to a policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then click Add a condition. OR To copy a condition from any policy and add it to another policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then click Copy. Copy a condition To copy an existing condition, including its targets and thresholds, and add it to another policy for the selected account: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). From the policy's list of one or more Alert conditions, click Copy. From the Copy alert condition list, search or scroll the list to select the policy where you want to add this condition. Optional: Change the condition's name if necessary. Select Save. By default, the copied condition will be added to the selected alert policy in a Disabled state. Follow standard procedures to add or copy additional conditions to the alert policy, and then Enable the condition as needed. Change how threshold violations roll up into incidents To select how violations to your thresholds are grouped into incident records (by policy, by condition, or by target and condition): In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Click Incident preference. Check for entities (targets) assigned to a policy To check whether an entity (target) has any policies assigned: Go to the product (APM, Browser, etc.). From the selected product's index, check whether the entity's color-coded health status is light green with an icon. Tip Exception: Infrastructure does not use this feature. Change a condition To change a policy condition: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Then, from the list of Alert conditions for the selected policy: To change the condition's name, click Edit. To add, change, or remove targets (entities), select the name or number of targets for the condition, and then select Browse and select targets. To update the values for the required Critical (red) or optional Warning (yellow) thresholds, select the existing value. To update the condition's runbook URL, select the condition's Thresholds. Link to Incident Intelligence If you use Applied Intelligence, you can connect your conditions to Incident Intelligence. To do this, switch the Connect to Incident Intelligence to ON. Disable or delete policies and conditions If you disable or delete a policy, we'll continue to apply any other policies assigned to the product entity (target). If you remove all policies for the entity, its color-coded health status indicator will appear light green with an icon. Disable or re-enable a condition You can enable or disable any policy conditions, and the policy will continue to apply. To disable or re-enable a condition: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Then, from the list of Alert conditions, (select a condition). Click the On/Off switch to toggle it. Tip For Infrastructure conditions, use the checkbox at the bottom of the condition edit screen, then save the condition. If you copy a condition, it is automatically saved in the new policy as disabled (Off), even if the condition was enabled (On) in the original policy. Disable a policy You can't disable a policy directly. However, you can disable all of the policy's conditions. When you disable all of the conditions, the policy will continue to appear on the Alert policies index. The policy itself isn't disabled, and you can re-enable any or all of its conditions at any time. Delete policy conditions If a policy has multiple conditions, you can delete any or all of them, and the remaining conditions for the policy will continue to apply. To turn a condition off but keep it with the policy, disable it. To delete one or more conditions: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). From the list of Alert conditions, (select a condition), then click Delete. Tip If you don't see the delete button, your account admin may have disabled condition deletion for your organization. Delete a policy If you delete any of your account's policies, you can't restore them. Instead, you must re-create them if necessary. To delete a policy completely: In the one.newrelic.com top nav, click Alerts & AI, then click Alert policies. From the policy row, click the delete icon. Any notification channels associated with a deleted or disabled policy will remain. You must delete notification channels or remove them individually as necessary. You will still be able to view incidents and event violations related to the deleted policy. However, these records will be read only.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 237.02193,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Update or disable <em>policies</em> <em>and</em> conditions",
        "sections": "Update or disable <em>policies</em> <em>and</em> conditions",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " to it: In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click Notification channels. The Policy subscriptions column lists how many <em>policies</em> are assigned to the channel. Create a <em>new</em> policy To create a <em>new</em> <em>alert</em> policy: In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click <em>Policies</em>. Click <em>New</em> <em>alert</em> policy. Follow"
      },
      "id": "604404ec28ccbc62492c6098"
    },
    {
      "sections": [
        "Specify when alerts create incidents",
        "Tip",
        "Incident preference options",
        "Select your incident preference",
        "Example: By policy (default)",
        "Example: By condition",
        "Example: By condition and signal",
        "For more help"
      ],
      "title": "Specify when alerts create incidents",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert policies"
      ],
      "external_id": "7ddf9dfd669866e413eb87573c063ecf558747bf",
      "image": "https://docs.newrelic.com/static/233d82abf03b4f77340c757671f3a96a/8c557/example-policy-incident.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-policies/specify-when-alerts-create-incidents/",
      "published_at": "2021-05-27T20:34:28Z",
      "updated_at": "2021-04-12T02:19:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When a policy condition violates a Critical (red) threshold, it can create an incident record with detailed information to help you respond efficiently. An incident is a collection of one or more violations. It includes all of the open and close timestamps for each violation. The incident record will include any Warning (yellow) violations which occurred after the opening Critical (red) threshold violation. Notifications are sent to every notification channel on the policy when an incident opens, if and when an incident is acknowledged, and when an incident closes. Tip To select when alerts create incidents and how violations are grouped, use the Incident preference setting inside your policy. Then, to view the alerts policy violations (incident records), select the Incidents indexes. Incident preference options Each option for incident preference has its own advantages. You can select any option for any policy. Incident preference Comments By policy (default) Only one incident will be open at a time for the entire policy. Fewest number of notifications Requires immediate action and closing the incidents to be effective By condition One incident will be open at a time for each condition in your policy. More notifications Useful for policies containing conditions that focus on entities that perform the same job; for example, hosts that all serve the same application(s) By condition and signal An incident will be created for every violation in your policy. The most notifications Useful if you need to be notified of every violation or if you have an external system where you want to send alert notifications Select your incident preference By default, a single incident record will be created for each policy. one.newrelic.com > Alert & AI > Policies > (select a policy): The selected policy page shows how alerts rolls up incidents for alert notifications and UI details. (Default is By policy). To choose a different option for this policy, click Incident preference. To change the incident preference for the selected policy: In the one.newrelic.com top nav, click Alerts & AI, then click Policies, and then (select a policy). Click Incident preference, select your choice of available options, and then save. Repeat these steps for each policy as needed. Example: By policy (default) When you select the default (By policy) as your incident preference, it will group all condition violations into the same incident. By default, a single incident record will be created for each alert policy. If additional conditions are violated by any target after the incident opens, the violations are added to the same incident. Only one incident appears on your Incidents indexes for the selected policy. Selecting the By policy preference is the most general option. All condition violations for every target will be accumulated into a single incident record. Example: By condition When you select By condition as your incident preference, it will group all violations by any target for a specific condition into separate incidents. Selecting the By condition option is useful, for example, when you want an individual incident record to focus on a specific condition. If the policy has multiple conditions, separate incident records for each condition will appear on your Incidents indexes. If a target violates a condition for the alert policy, an incident record will be created. If the same target violates another condition for the alert policy, another incident record will be created. If additional targets violate the same condition after the incident opens, these violations will be added to the incident record already open for that condition. Example: By condition and signal When you select By condition and signal as your incident preference, it will not group violations at all. A new incident will be created for every violation that occurs in your policy. Selecting the By condition and signal option is the most granular level for creating incident records. This is useful, for example, when you want to closely monitor anything that is occurring anywhere across your infrastructure. An incident will appear on your Incidents indexes for every violation that occurs within your policy. For more help Additional documentation resources include: Alert policy workflow (basic process to set up your alert policies, regardless of which New Relic product uses the alert policy) Explore the incident history (examine details about alert policy violations, take action, and skim for patterns)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.93845,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Specify when <em>alerts</em> create incidents",
        "sections": "Specify when <em>alerts</em> create incidents",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " that occurs within your policy. For more help Additional documentation resources include: <em>Alert</em> policy workflow (basic process to set up your <em>alert</em> <em>policies</em>, regardless of which <em>New</em> <em>Relic</em> product uses the <em>alert</em> policy) Explore the incident history (examine details about <em>alert</em> policy violations, take action, and skim for patterns)"
      },
      "id": "603e9efd28ccbc79eeeba786"
    },
    {
      "sections": [
        "Incident Intelligence destination examples",
        "Destination template examples",
        "Suggested OpsGenie template example",
        "Suggested ServiceNow template example",
        "Suggested Slack template example",
        "Suggested VictorOps template example",
        "Webhook and JSON format examples",
        "Webhook format and JSON example",
        "Jinja2 Default Payload",
        "Jinja2 Useful Syntax",
        "JSON schema",
        "JSON schema template"
      ],
      "title": "Incident Intelligence destination examples",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "a516d04f8b75541a6dc9338fa3ce9645ba87d620",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/incident-intelligence-destination-examples/",
      "published_at": "2021-06-02T18:22:22Z",
      "updated_at": "2021-06-02T18:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Destinations are the data outputs to Applied Intelligence, where you can view your automatically correlated incidents. You can configure Incident Intelligence destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema. Destination template examples The following template example destinations are formatted in Jinja2. Suggested OpsGenie template example { \"alias\": {{ id }}, \"message\": {{ ui_name }}, \"source\": '{{ sources }}', \"priority\": {{ priority }}, \"details\": { \"self_url\": {{ url }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"is_correlated\": {{ is_correlated }} }, \"description\": \"\"\"Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]\"\"\" } Copy Suggested ServiceNow template example { \"short_description\": {{ ui_name }}, \"description\": 'Issue Id: {{ id }}, \\n Description: {{ description }}, \\n Sources: {{ sources }}, \\n Priority: {{ priority }}, \\n Details: { \\n self_url: {{ url }}, \\n state: {{ state }}, \\n is_correlated: {{ is_correlated }}, \\n created_on: {{ created_on }}, \\n modified_on: {{ modified_on }}, \\n activated_on: {{ active_since }}, \\n closed_on: {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \\n is_correlated: {{is_correlated}} }, \\n\\n incidents: {{ incidents }}, \\n\\n pathways: {{ pathways }}' } Copy Suggested Slack template example Go to Slack incoming WebHooks Choose the right Slack workspace and click \"Add to Slack\" Select the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In New Relic Applied Intelligence, under Incident Intelligence click Destinations Add a WebHook In the end point paste the WebHook url from slack. In the custom payload, paste the following JSON: { \"blocks\": [ { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*New Relic Incident Intelligence Alert*\" } }, { \"type\": \"divider\" }, { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*CUSTOM FIELDS*:\" }, \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue ID*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Issue Title*\" }, { \"type\": \"plain_text\", \"text\": {{ id }} }, { \"type\": \"plain_text\", \"text\": {{ ui_name }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue URL*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Description*\" }, { \"type\": \"mrkdwn\", \"text\": {{ url }} }, { \"type\": \"plain_text\", \"text\": {{ description }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*State*\" }, { \"type\": \"mrkdwn\", \"text\": \"*is_correlated*\" }, { \"type\": \"plain_text\", \"text\": {{ state }} }, { \"type\": \"plain_text\", \"text\": \"{{ is_correlated }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Created On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Modified On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ created_on }}\" }, { \"type\": \"plain_text\", \"text\": \"{{ modified_on }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Activated On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Closed On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ active_since }}\" }, { \"type\": \"plain_text\", \"text\": \"{% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Aggregated Incidents*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Monitoring Tool*\" }, { \"type\": \"plain_text\", \"text\": \"{{ incident_count }}\" }, { \"type\": \"plain_text\", \"text\": {{ sources|join(', ') }} } ] } ] } Copy Suggested VictorOps template example { \"monitoring_tool\": {{ sources }}, {% if state == 'closed' %} \"message_type\": \"OK\", {% else %} \"message_type\": {{ priority }}, {% endif %} \"custom_fields\": { \"issue_url\": {{ url }}, \"description\": {{ description }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"related_incidents\": [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %} {% endfor %} ] }, \"state_message\": {{ description }}, \"entity_id\": {{ id }}, \"entity_display_name\": {{ ui_name }}, \"vo_annotate.u.NRAI_Link\": {{ url }} } Copy Webhook and JSON format examples Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). If you use webhooks to configure Incident Intelligence destinations, use these examples of the webhook body format and JSON schema. Webhook format and JSON example Webhook format: Name Description url Href A link to the UI where the issue can be seen. id String Unique identifier for the issue. title String The issue title. description String The description of the issue. priority Enum The issue priority. Can be Critical, High, Medium, or Low. state Enum The issue status. Can be Active, Closed, or Acknowledged. is_correlated Boolean True if the issue is based on correlated data. created_on String The date and time the issue was created (in ISO format). modified_on String The date and time the issue was modified (in ISO format). active_since String The date and time the issue was activated (in ISO format). closed_on String The date and time the issue was closed (in ISO format). sources List(String) List of the different sources that were used to send the events into Applied Intelligence (for example: PagerDuty). pathways List(Pathways) List of pathways that are associated with the issue. Each pathway contains an id and name: [{“id”: “pathway id”, “name”: “pathway name”}]. pathways[].id String The pathway ID. pathways[].name String The pathway name. incidents List(Incident) List of incidents that are attached to the issue. The list contains only the latest 100 incidents. incidents[].id String The incident ID. incidents[].events_count Integer The number of events used to create the incident. incidents[].title String The incident title. incidents[].description String The incident description. incidents[].labels Dictionary (String) A string to string mapping of the incident labels. Labels represent the unique entities that are used to describe the incident. incidents[].priority Enum The incident priority. Can be Critical, High, Medium, or Low. incidents[].sources List(String) The incident source. incidents[].state Enum(open, closed) The incident state. incidents[].opened_on String The date and time the incident was opened (in ISO format). incidents[].closed_on String The date and time the incident was closed (in ISO format). ui_name String Issue title. accumulations['alert/signal'] String Issue analysis summary golden signal/s (if applicable). accumulations['alert/components'] String Issue analysis summary golden components (if applicable). Jinja2 Default Payload Applied Intelligence uses a templating framework called Jinja2 in the Webhook interface. Here is a default Jinja2 payload to use: { \"id\": {{ id }}, \"url\": {{ url }}, \"ui_name\": {{ ui_name }}, \"description\": {{ description }}, \"priority\": {{ priority }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"active_since\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"sources\": {{ sources }}, \"incidents\": {{ incidents }}, \"pathways\": {{ pathways }}, } Copy Jinja2 Useful Syntax Below are a few useful Jinja2 commands to help you format your output. Casting a value to integer Example: “severity”: {{ priority | int }} Copy If clause to check if an attribute’s value is set Example: \"golden_signals\": {% if accumulations['alert/signal'] is defined %} {{ accumulations['alert/signal'] }} {% else %} None {% endif %} Copy For loop to iterate of an array of values: Example: \"description\": 'Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]' Copy Check if an array attribute's value is set: Example: \"hostname_field\": {% if incidents[0].labels['newrelic/tag/hostname'] is defined %} {{ incidents[0].labels['newrelic/tag/hostname'] }} {% else %} None {% endif %} Copy JSON schema Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). JSON schema template JSON schema: { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"definitions\": { \"Labels\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"LabelsSet\": { \"type\": \"array\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"$ref\": \"#/definitions/Labels\" }, \"uniqueItems\": true }, }, \"Annotations\": { \"type\": \"object\", \"title\": \"Additional contextual information about the Entity\", \"description\": \"Fields like title, description and priority can be described as annotations since\\nthey represent some additional information about the Incident.\\nFor example, the rule that creates the entity can have some logic that will create a title annotation field.\\nThe title will change according to the latest event received by the entity and as more\\nevent will keep coming the field may change, all this as a decision by the rule.\\nA different rule may decide not to populate the title at all.\\nSince a title can also be produced from the labels themselves.\", \"properties\": { \"title\": { \"type\": \"string\", \"maxLength\": 10000 }, \"description\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"patternProperties\": { \".*\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"Accumulations\": { \"type\": \"object\", \"title\": \"Accumulated data about the Incident\", \"description\": \"For example an entity with the label: host_name: foo will include a accumulated list of the\\nrelevant process names that are relevant to the entity. Accumulations will be derived from the events\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"type\": \"string\", \"maxLength\": 10000 } } }, \"IssueState\": { \"type\": \"string\", \"enum\": [ \"created\", \"active\", \"acknowledged\", \"closed\" ], \"properties\": {}, \"additionalProperties\": false }, \"Priority\": { \"type\": \"string\", \"enum\": [ \"critical\", \"high\", \"medium\", \"low\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueClosingReason\": { \"type\": \"string\", \"enum\": [ \"nacked\", \"resolved\", \"system\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueAction\": { \"type\": \"string\", \"enum\": [ \"ack\", \"snooze\", \"nack\", \"end_snooze\", \"expire_snooze\", \"star\", \"un_snooze\", \"unstar\", \"archive\", \"unarchive\", \"resolve\", \"reopen\", \"open\", \"feedback\", \"feedback_file\", \"open_ticket\", \"merge_issues\", \"active\", \"create\", \"close\", \"incident_updated\", \"confidence_changed\", \"diagnoses_changed\", \"rule_properties_changed\", \"flapping\", \"notification\", \"incident_events_limit_reached\", \"follow\", \"unfollow\", \"priority_updated\", \"comment\", \"incident_appended\", \"diagnosis_feedback\", \"flapping_delay_close\" ], \"properties\": {}, \"additionalProperties\": false }, \"StringKeyValue\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\" } }, \"JavaOptionalUuid\": { \"type\": \"string\", \"properties\": {}, \"additionalProperties\": false, \"format\": \"string-uuid\" } }, \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"customer_id\": { \"type\": \"integer\" }, \"labels_set\": { \"$ref\": \"#/definitions/LabelsSet\" }, \"annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations_version\": { \"type\": \"integer\" }, \"accumulations\": { \"$ref\": \"#/definitions/Accumulations\" }, \"state\": { \"$ref\": \"#/definitions/IssueState\" }, \"previous_state\": { \"$ref\": \"#/definitions/IssueState\" }, \"priority\": { \"$ref\": \"#/definitions/Priority\" }, \"closing_reason\": { \"oneOf\": [ { \"$ref\": \"#/definitions/IssueClosingReason\" }, { \"type\": \"null\" } ] }, \"modified_on\": { \"type\": \"integer\" }, \"created_on\": { \"type\": \"integer\" }, \"closed_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"acknowledged_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"active_since\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"assigned_to\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"created_by\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"progress_report\": { \"type\": \"array\", \"default\": [], \"items\": { \"type\": \"object\", \"properties\": { \"origin_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1 }, { \"type\": \"null\" } ] }, \"timestamp\": { \"type\": \"integer\" }, \"action_timestamp\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"origin_type\": { \"type\": \"string\", \"enum\": [ \"user\", \"system\" ] }, \"event_type\": { \"$ref\": \"#/definitions/IssueAction\" }, \"issue_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"format\": \"string-uuid\" }, { \"type\": \"null\" } ] }, \"attributes\": { \"oneOf\": [ { \"$ref\": \"#/definitions/StringKeyValue\" }, { \"type\": \"null\" } ] }, \"team_id\": { \"$ref\": \"#/definitions/JavaOptionalUuid\" } }, \"required\": [ \"timestamp\", \"origin_type\", \"event_type\" ], \"additionalProperties\": false }, \"uniqueItems\": true }, \"rule_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"maxLength\": 255 }, { \"type\": \"null\" } ] }, \"incident_ids\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"confidence\": { \"type\": \"number\", \"default\": 1.0, \"minimum\": 0.0, \"maximum\": 1.0 } }, \"required\": [ \"id\", \"customer_id\", \"labels_set\", \"annotations\", \"priority\", \"modified_on\", \"created_on\", \"confidence\" ], \"additionalProperties\": true } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.19987,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Incident <em>Intelligence</em> destination examples",
        "sections": "Incident <em>Intelligence</em> destination examples",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In <em>New</em> <em>Relic</em> <em>Applied</em> <em>Intelligence</em>, under Incident <em>Intelligence</em> click Destinations Add a WebHook In the end point paste the WebHook url"
      },
      "id": "6044280d64441f4af5378ed3"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-violations/how-alert-condition-violations-are-closed": [
    {
      "sections": [
        "View alert violations from our products",
        "APM",
        "Browser",
        "Infrastructure",
        "Mobile",
        "Synthetic monitoring"
      ],
      "title": "View alert violations from our products",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert violations"
      ],
      "external_id": "88fe8f43f2051726d47724a7449cdf0de73e547a",
      "image": "https://docs.newrelic.com/static/1f6ac9f210cb330e6e0a0b7a9221ea1a/c1b63/screen-apm-violations_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-violations/view-alert-violations-our-products/",
      "published_at": "2021-05-28T11:11:26Z",
      "updated_at": "2021-03-29T18:15:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view violations for a specific entity (alert target), select the Violations index from the product page. Then, from the product's Violations index, use the available tools to search, sort, or view violations for the selected entity. From here you can also view or update the policies and conditions that triggered the violations. one.newrelic.com > Explorer > (select an app) > Events > Violations: Here's an example of the Violations index. Use the available tools to search, sort, or view violations for the selected entity, or to view or update the associated policies and conditions. APM To view violations for a specific app or key transaction: App: In the one.newrelic.com top nav, click APM, (select an application), then under Events, click Violations. Key transaction: In the one.newrelic.com top nav, click More, click Key transactions, then (select a key transaction). In the left nav under Events, click Violations. Browser To view violations for a specific browser app: In the one.newrelic.com top nav, click Browser, then (select a browser app). In the left nav click Move views, click Violations. Infrastructure To view violations for a specific host monitored by Infrastructure: In the one.newrelic.com top nav, click Infrastructure, and then click Settings. In the left nav, click Alerts. Mobile To view violations for a specific mobile app: In the one.newrelic.com top nav, click Mobile, then (select a mobile app). In the left nav click More views, then click Event explorer. Synthetic monitoring To view violations for a specific monitor: In the one.newrelic.com top nav, click Synthetics, then (select a monitor). In the right nav under Activity, click Alert violations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.41302,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "View <em>alert</em> <em>violations</em> from our products",
        "sections": "View <em>alert</em> <em>violations</em> from our products",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "To view <em>violations</em> for a specific entity (<em>alert</em> target), select the <em>Violations</em> index from the product page. Then, from the product&#x27;s <em>Violations</em> index, use the available tools to search, sort, or view <em>violations</em> for the selected entity. From here you can also view or update the policies"
      },
      "id": "6043fcb6196a6784a0960f1d"
    },
    {
      "sections": [
        "Violation event attributes",
        "What is a violation event?",
        "Important"
      ],
      "title": "Violation event attributes",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert violations"
      ],
      "external_id": "88b2cda2475a81d7c2628b7d8b032b25ad8de0f8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-violations/violation-event-attributes/",
      "published_at": "2021-05-28T03:30:40Z",
      "updated_at": "2021-03-13T05:42:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The violation of a condition generates a violation event, which passes important information downstream. For more about the definition of violations and other terms, see Alerts concepts. What is a violation event? The violation of a condition generates a violation event. This event has various attributes (metadata) attached to it and different attributes can be used by different features. Important The violation event is a concept used to determine alerting features. While you can query some of its associated attributes via NerdGraph, you cannot directly query the violation event. Violation event attributes This table shows violation event attributes. All attributes are available for use in a description. Read about attributes available for muting rules. Attribute Description Muting rules? accountId The ID of the account where the violation occurred. conditionId The ID of the condition that triggered the violation. conditionName The name of the condition that triggered the violation. conditionType The type of alert condition that triggered the violation. Available values: baseline, external service, host not reporting, jvm metric, key transaction metric, location failure, metric, monitor failure, outlier, process running, response time percentile, static. event Available values: Open, Close, Muted, Acknowledge, Sent. product The New Relic product of the violation’s target. Available values: NRQL, BROWSER, PLUGINS, INFRASTRUCTURE, APM, SYNTHETICS, MOBILE, SERVERS. runbookUrl The runbook URL for the condition that triggered the violation. nrqlEventType The type of data targeted by a NRQL condition. In this context, this refers to any NRQL-queryable data type. nrqlQuery The full string of the NRQL query. Can be used for sub-string matching on attributes in the WHERE clause. policyId The ID of the policy that triggered the violation. policyName The name of the policy that triggered the violation. tag.* Arbitrary key-value metadata, or tags, associated with the violation. tag. is the prefix and * is the metadata/tag name. For details on how to use this, see the documentation for muting rules or description. targetName The name of the violation’s target. type Possible values: Violation, Incident, Notification.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.06277,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Violation</em> event attributes",
        "sections": "<em>Violation</em> event attributes",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": ", monitor failure, outlier, process running, response time percentile, static. event Available values: Open, Close, Muted, Acknowledge, Sent. product The <em>New</em> <em>Relic</em> product of the <em>violation’s</em> target. Available values: NRQL, BROWSER, PLUGINS, INFRASTRUCTURE, APM, SYNTHETICS, MOBILE, SERVERS. runbookUrl"
      },
      "id": "6043fcf228ccbcf6da2c608d"
    },
    {
      "sections": [
        "Incident Intelligence destination examples",
        "Destination template examples",
        "Suggested OpsGenie template example",
        "Suggested ServiceNow template example",
        "Suggested Slack template example",
        "Suggested VictorOps template example",
        "Webhook and JSON format examples",
        "Webhook format and JSON example",
        "Jinja2 Default Payload",
        "Jinja2 Useful Syntax",
        "JSON schema",
        "JSON schema template"
      ],
      "title": "Incident Intelligence destination examples",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "a516d04f8b75541a6dc9338fa3ce9645ba87d620",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/incident-intelligence-destination-examples/",
      "published_at": "2021-06-02T18:22:22Z",
      "updated_at": "2021-06-02T18:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Destinations are the data outputs to Applied Intelligence, where you can view your automatically correlated incidents. You can configure Incident Intelligence destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema. Destination template examples The following template example destinations are formatted in Jinja2. Suggested OpsGenie template example { \"alias\": {{ id }}, \"message\": {{ ui_name }}, \"source\": '{{ sources }}', \"priority\": {{ priority }}, \"details\": { \"self_url\": {{ url }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"is_correlated\": {{ is_correlated }} }, \"description\": \"\"\"Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]\"\"\" } Copy Suggested ServiceNow template example { \"short_description\": {{ ui_name }}, \"description\": 'Issue Id: {{ id }}, \\n Description: {{ description }}, \\n Sources: {{ sources }}, \\n Priority: {{ priority }}, \\n Details: { \\n self_url: {{ url }}, \\n state: {{ state }}, \\n is_correlated: {{ is_correlated }}, \\n created_on: {{ created_on }}, \\n modified_on: {{ modified_on }}, \\n activated_on: {{ active_since }}, \\n closed_on: {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \\n is_correlated: {{is_correlated}} }, \\n\\n incidents: {{ incidents }}, \\n\\n pathways: {{ pathways }}' } Copy Suggested Slack template example Go to Slack incoming WebHooks Choose the right Slack workspace and click \"Add to Slack\" Select the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In New Relic Applied Intelligence, under Incident Intelligence click Destinations Add a WebHook In the end point paste the WebHook url from slack. In the custom payload, paste the following JSON: { \"blocks\": [ { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*New Relic Incident Intelligence Alert*\" } }, { \"type\": \"divider\" }, { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*CUSTOM FIELDS*:\" }, \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue ID*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Issue Title*\" }, { \"type\": \"plain_text\", \"text\": {{ id }} }, { \"type\": \"plain_text\", \"text\": {{ ui_name }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue URL*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Description*\" }, { \"type\": \"mrkdwn\", \"text\": {{ url }} }, { \"type\": \"plain_text\", \"text\": {{ description }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*State*\" }, { \"type\": \"mrkdwn\", \"text\": \"*is_correlated*\" }, { \"type\": \"plain_text\", \"text\": {{ state }} }, { \"type\": \"plain_text\", \"text\": \"{{ is_correlated }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Created On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Modified On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ created_on }}\" }, { \"type\": \"plain_text\", \"text\": \"{{ modified_on }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Activated On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Closed On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ active_since }}\" }, { \"type\": \"plain_text\", \"text\": \"{% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Aggregated Incidents*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Monitoring Tool*\" }, { \"type\": \"plain_text\", \"text\": \"{{ incident_count }}\" }, { \"type\": \"plain_text\", \"text\": {{ sources|join(', ') }} } ] } ] } Copy Suggested VictorOps template example { \"monitoring_tool\": {{ sources }}, {% if state == 'closed' %} \"message_type\": \"OK\", {% else %} \"message_type\": {{ priority }}, {% endif %} \"custom_fields\": { \"issue_url\": {{ url }}, \"description\": {{ description }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"related_incidents\": [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %} {% endfor %} ] }, \"state_message\": {{ description }}, \"entity_id\": {{ id }}, \"entity_display_name\": {{ ui_name }}, \"vo_annotate.u.NRAI_Link\": {{ url }} } Copy Webhook and JSON format examples Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). If you use webhooks to configure Incident Intelligence destinations, use these examples of the webhook body format and JSON schema. Webhook format and JSON example Webhook format: Name Description url Href A link to the UI where the issue can be seen. id String Unique identifier for the issue. title String The issue title. description String The description of the issue. priority Enum The issue priority. Can be Critical, High, Medium, or Low. state Enum The issue status. Can be Active, Closed, or Acknowledged. is_correlated Boolean True if the issue is based on correlated data. created_on String The date and time the issue was created (in ISO format). modified_on String The date and time the issue was modified (in ISO format). active_since String The date and time the issue was activated (in ISO format). closed_on String The date and time the issue was closed (in ISO format). sources List(String) List of the different sources that were used to send the events into Applied Intelligence (for example: PagerDuty). pathways List(Pathways) List of pathways that are associated with the issue. Each pathway contains an id and name: [{“id”: “pathway id”, “name”: “pathway name”}]. pathways[].id String The pathway ID. pathways[].name String The pathway name. incidents List(Incident) List of incidents that are attached to the issue. The list contains only the latest 100 incidents. incidents[].id String The incident ID. incidents[].events_count Integer The number of events used to create the incident. incidents[].title String The incident title. incidents[].description String The incident description. incidents[].labels Dictionary (String) A string to string mapping of the incident labels. Labels represent the unique entities that are used to describe the incident. incidents[].priority Enum The incident priority. Can be Critical, High, Medium, or Low. incidents[].sources List(String) The incident source. incidents[].state Enum(open, closed) The incident state. incidents[].opened_on String The date and time the incident was opened (in ISO format). incidents[].closed_on String The date and time the incident was closed (in ISO format). ui_name String Issue title. accumulations['alert/signal'] String Issue analysis summary golden signal/s (if applicable). accumulations['alert/components'] String Issue analysis summary golden components (if applicable). Jinja2 Default Payload Applied Intelligence uses a templating framework called Jinja2 in the Webhook interface. Here is a default Jinja2 payload to use: { \"id\": {{ id }}, \"url\": {{ url }}, \"ui_name\": {{ ui_name }}, \"description\": {{ description }}, \"priority\": {{ priority }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"active_since\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"sources\": {{ sources }}, \"incidents\": {{ incidents }}, \"pathways\": {{ pathways }}, } Copy Jinja2 Useful Syntax Below are a few useful Jinja2 commands to help you format your output. Casting a value to integer Example: “severity”: {{ priority | int }} Copy If clause to check if an attribute’s value is set Example: \"golden_signals\": {% if accumulations['alert/signal'] is defined %} {{ accumulations['alert/signal'] }} {% else %} None {% endif %} Copy For loop to iterate of an array of values: Example: \"description\": 'Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]' Copy Check if an array attribute's value is set: Example: \"hostname_field\": {% if incidents[0].labels['newrelic/tag/hostname'] is defined %} {{ incidents[0].labels['newrelic/tag/hostname'] }} {% else %} None {% endif %} Copy JSON schema Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). JSON schema template JSON schema: { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"definitions\": { \"Labels\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"LabelsSet\": { \"type\": \"array\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"$ref\": \"#/definitions/Labels\" }, \"uniqueItems\": true }, }, \"Annotations\": { \"type\": \"object\", \"title\": \"Additional contextual information about the Entity\", \"description\": \"Fields like title, description and priority can be described as annotations since\\nthey represent some additional information about the Incident.\\nFor example, the rule that creates the entity can have some logic that will create a title annotation field.\\nThe title will change according to the latest event received by the entity and as more\\nevent will keep coming the field may change, all this as a decision by the rule.\\nA different rule may decide not to populate the title at all.\\nSince a title can also be produced from the labels themselves.\", \"properties\": { \"title\": { \"type\": \"string\", \"maxLength\": 10000 }, \"description\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"patternProperties\": { \".*\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"Accumulations\": { \"type\": \"object\", \"title\": \"Accumulated data about the Incident\", \"description\": \"For example an entity with the label: host_name: foo will include a accumulated list of the\\nrelevant process names that are relevant to the entity. Accumulations will be derived from the events\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"type\": \"string\", \"maxLength\": 10000 } } }, \"IssueState\": { \"type\": \"string\", \"enum\": [ \"created\", \"active\", \"acknowledged\", \"closed\" ], \"properties\": {}, \"additionalProperties\": false }, \"Priority\": { \"type\": \"string\", \"enum\": [ \"critical\", \"high\", \"medium\", \"low\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueClosingReason\": { \"type\": \"string\", \"enum\": [ \"nacked\", \"resolved\", \"system\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueAction\": { \"type\": \"string\", \"enum\": [ \"ack\", \"snooze\", \"nack\", \"end_snooze\", \"expire_snooze\", \"star\", \"un_snooze\", \"unstar\", \"archive\", \"unarchive\", \"resolve\", \"reopen\", \"open\", \"feedback\", \"feedback_file\", \"open_ticket\", \"merge_issues\", \"active\", \"create\", \"close\", \"incident_updated\", \"confidence_changed\", \"diagnoses_changed\", \"rule_properties_changed\", \"flapping\", \"notification\", \"incident_events_limit_reached\", \"follow\", \"unfollow\", \"priority_updated\", \"comment\", \"incident_appended\", \"diagnosis_feedback\", \"flapping_delay_close\" ], \"properties\": {}, \"additionalProperties\": false }, \"StringKeyValue\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\" } }, \"JavaOptionalUuid\": { \"type\": \"string\", \"properties\": {}, \"additionalProperties\": false, \"format\": \"string-uuid\" } }, \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"customer_id\": { \"type\": \"integer\" }, \"labels_set\": { \"$ref\": \"#/definitions/LabelsSet\" }, \"annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations_version\": { \"type\": \"integer\" }, \"accumulations\": { \"$ref\": \"#/definitions/Accumulations\" }, \"state\": { \"$ref\": \"#/definitions/IssueState\" }, \"previous_state\": { \"$ref\": \"#/definitions/IssueState\" }, \"priority\": { \"$ref\": \"#/definitions/Priority\" }, \"closing_reason\": { \"oneOf\": [ { \"$ref\": \"#/definitions/IssueClosingReason\" }, { \"type\": \"null\" } ] }, \"modified_on\": { \"type\": \"integer\" }, \"created_on\": { \"type\": \"integer\" }, \"closed_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"acknowledged_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"active_since\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"assigned_to\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"created_by\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"progress_report\": { \"type\": \"array\", \"default\": [], \"items\": { \"type\": \"object\", \"properties\": { \"origin_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1 }, { \"type\": \"null\" } ] }, \"timestamp\": { \"type\": \"integer\" }, \"action_timestamp\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"origin_type\": { \"type\": \"string\", \"enum\": [ \"user\", \"system\" ] }, \"event_type\": { \"$ref\": \"#/definitions/IssueAction\" }, \"issue_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"format\": \"string-uuid\" }, { \"type\": \"null\" } ] }, \"attributes\": { \"oneOf\": [ { \"$ref\": \"#/definitions/StringKeyValue\" }, { \"type\": \"null\" } ] }, \"team_id\": { \"$ref\": \"#/definitions/JavaOptionalUuid\" } }, \"required\": [ \"timestamp\", \"origin_type\", \"event_type\" ], \"additionalProperties\": false }, \"uniqueItems\": true }, \"rule_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"maxLength\": 255 }, { \"type\": \"null\" } ] }, \"incident_ids\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"confidence\": { \"type\": \"number\", \"default\": 1.0, \"minimum\": 0.0, \"maximum\": 1.0 } }, \"required\": [ \"id\", \"customer_id\", \"labels_set\", \"annotations\", \"priority\", \"modified_on\", \"created_on\", \"confidence\" ], \"additionalProperties\": true } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.19987,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Incident <em>Intelligence</em> destination examples",
        "sections": "Incident <em>Intelligence</em> destination examples",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In <em>New</em> <em>Relic</em> <em>Applied</em> <em>Intelligence</em>, under Incident <em>Intelligence</em> click Destinations Add a WebHook In the end point paste the WebHook url"
      },
      "id": "6044280d64441f4af5378ed3"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-violations/view-alert-violations-our-products": [
    {
      "sections": [
        "Violation event attributes",
        "What is a violation event?",
        "Important"
      ],
      "title": "Violation event attributes",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert violations"
      ],
      "external_id": "88b2cda2475a81d7c2628b7d8b032b25ad8de0f8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-violations/violation-event-attributes/",
      "published_at": "2021-05-28T03:30:40Z",
      "updated_at": "2021-03-13T05:42:18Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The violation of a condition generates a violation event, which passes important information downstream. For more about the definition of violations and other terms, see Alerts concepts. What is a violation event? The violation of a condition generates a violation event. This event has various attributes (metadata) attached to it and different attributes can be used by different features. Important The violation event is a concept used to determine alerting features. While you can query some of its associated attributes via NerdGraph, you cannot directly query the violation event. Violation event attributes This table shows violation event attributes. All attributes are available for use in a description. Read about attributes available for muting rules. Attribute Description Muting rules? accountId The ID of the account where the violation occurred. conditionId The ID of the condition that triggered the violation. conditionName The name of the condition that triggered the violation. conditionType The type of alert condition that triggered the violation. Available values: baseline, external service, host not reporting, jvm metric, key transaction metric, location failure, metric, monitor failure, outlier, process running, response time percentile, static. event Available values: Open, Close, Muted, Acknowledge, Sent. product The New Relic product of the violation’s target. Available values: NRQL, BROWSER, PLUGINS, INFRASTRUCTURE, APM, SYNTHETICS, MOBILE, SERVERS. runbookUrl The runbook URL for the condition that triggered the violation. nrqlEventType The type of data targeted by a NRQL condition. In this context, this refers to any NRQL-queryable data type. nrqlQuery The full string of the NRQL query. Can be used for sub-string matching on attributes in the WHERE clause. policyId The ID of the policy that triggered the violation. policyName The name of the policy that triggered the violation. tag.* Arbitrary key-value metadata, or tags, associated with the violation. tag. is the prefix and * is the metadata/tag name. For details on how to use this, see the documentation for muting rules or description. targetName The name of the violation’s target. type Possible values: Violation, Incident, Notification.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.06276,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Violation</em> event attributes",
        "sections": "<em>Violation</em> event attributes",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": ", monitor failure, outlier, process running, response time percentile, static. event Available values: Open, Close, Muted, Acknowledge, Sent. product The <em>New</em> <em>Relic</em> product of the <em>violation’s</em> target. Available values: NRQL, BROWSER, PLUGINS, INFRASTRUCTURE, APM, SYNTHETICS, MOBILE, SERVERS. runbookUrl"
      },
      "id": "6043fcf228ccbcf6da2c608d"
    },
    {
      "sections": [
        "How alert condition violations are closed",
        "How violations automatically close",
        "Manually close a violation",
        "Important",
        "Set a time limit for long-lasting violations"
      ],
      "title": "How alert condition violations are closed",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert violations"
      ],
      "external_id": "41e9d59a43c91f2364ae832f472f4c395986c355",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-violations/how-alert-condition-violations-are-closed/",
      "published_at": "2021-05-28T17:59:03Z",
      "updated_at": "2021-03-13T04:04:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains the different ways violations can be closed. How violations automatically close A violation will automatically close when the targeted signal returns to a non-violating state for the time period indicated in the condition's thresholds. This wait time is called the recovery period. For example: If the violating behavior is \"Apdex score below 0.80 at least once in 5 minutes,\" then the violation will automatically close when the Apdex score is equal to or higher than .80 for 5 consecutive minutes. The same applies to a \"for at least x minutes\" threshold: x minutes of non-violating behavior are required to automatically close the violation. When a violation closes automatically: The closing timestamp is backdated to the start of the recovery period. The evaluation resets and restarts from when the previous violation ended. Some types of conditions have a violation time limit setting that will automatically force-close a long-lasting violation. Manually close a violation You can manually close an open violation. This is useful, for example, when a signal has violated the threshold, but it no longer exists and also doesn't have a violation time limit. (A time limit would automatically close a long-lasting violation.) To close a violation: Go to the open violation you want to close. Click Manually close violation. To close all violations associated with a condition: Go to the condition you want to close. Disable the condition and then re-enable it. Important An incident will close automatically when all of its associated critical violations have been closed. Set a time limit for long-lasting violations Some types of conditions have a violation time limit setting. This limit will automatically force-close a long-lasting violation after the number of hours you select. This is most useful for ephemeral entities that, when they disappear, cause a continual violation that won't automatically close. Limits and Defaults All alert violations will have a violation time limit applied to them. Most alert conditions will allow you to edit this field. The default value, if one is not supplied during configuration, is 30 days. Violation time limit can be set as low as 5 minutes, and as high as 30 days. If, for some reason, the signal is still violating in 30 days, the violation will close, and a new violation will open. Examples: You set the violation time limit to 12 hours. If that violation lasts for 12 hours, it will be closed at 12 hours and the condition's evaluation of that entity will be reset. Your JVM has a CPU spike and this creates a violation. The JVM then crashes and is replaced by a new JVM. If you have not set a violation time limit, the crashed JVM’s violation will never close.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.04822,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "How <em>alert</em> condition <em>violations</em> are closed",
        "sections": "How <em>alert</em> condition <em>violations</em> are closed",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " of hours you select. This is most useful for ephemeral entities that, when they disappear, cause a continual violation that won&#x27;t automatically close. Limits and Defaults All <em>alert</em> <em>violations</em> will have a violation time limit <em>applied</em> to them. Most <em>alert</em> conditions will allow you to edit this field"
      },
      "id": "6043fcf2196a67dcce960f80"
    },
    {
      "sections": [
        "Incident Intelligence destination examples",
        "Destination template examples",
        "Suggested OpsGenie template example",
        "Suggested ServiceNow template example",
        "Suggested Slack template example",
        "Suggested VictorOps template example",
        "Webhook and JSON format examples",
        "Webhook format and JSON example",
        "Jinja2 Default Payload",
        "Jinja2 Useful Syntax",
        "JSON schema",
        "JSON schema template"
      ],
      "title": "Incident Intelligence destination examples",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "a516d04f8b75541a6dc9338fa3ce9645ba87d620",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/incident-intelligence-destination-examples/",
      "published_at": "2021-06-02T18:22:22Z",
      "updated_at": "2021-06-02T18:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Destinations are the data outputs to Applied Intelligence, where you can view your automatically correlated incidents. You can configure Incident Intelligence destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema. Destination template examples The following template example destinations are formatted in Jinja2. Suggested OpsGenie template example { \"alias\": {{ id }}, \"message\": {{ ui_name }}, \"source\": '{{ sources }}', \"priority\": {{ priority }}, \"details\": { \"self_url\": {{ url }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"is_correlated\": {{ is_correlated }} }, \"description\": \"\"\"Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]\"\"\" } Copy Suggested ServiceNow template example { \"short_description\": {{ ui_name }}, \"description\": 'Issue Id: {{ id }}, \\n Description: {{ description }}, \\n Sources: {{ sources }}, \\n Priority: {{ priority }}, \\n Details: { \\n self_url: {{ url }}, \\n state: {{ state }}, \\n is_correlated: {{ is_correlated }}, \\n created_on: {{ created_on }}, \\n modified_on: {{ modified_on }}, \\n activated_on: {{ active_since }}, \\n closed_on: {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \\n is_correlated: {{is_correlated}} }, \\n\\n incidents: {{ incidents }}, \\n\\n pathways: {{ pathways }}' } Copy Suggested Slack template example Go to Slack incoming WebHooks Choose the right Slack workspace and click \"Add to Slack\" Select the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In New Relic Applied Intelligence, under Incident Intelligence click Destinations Add a WebHook In the end point paste the WebHook url from slack. In the custom payload, paste the following JSON: { \"blocks\": [ { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*New Relic Incident Intelligence Alert*\" } }, { \"type\": \"divider\" }, { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*CUSTOM FIELDS*:\" }, \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue ID*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Issue Title*\" }, { \"type\": \"plain_text\", \"text\": {{ id }} }, { \"type\": \"plain_text\", \"text\": {{ ui_name }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue URL*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Description*\" }, { \"type\": \"mrkdwn\", \"text\": {{ url }} }, { \"type\": \"plain_text\", \"text\": {{ description }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*State*\" }, { \"type\": \"mrkdwn\", \"text\": \"*is_correlated*\" }, { \"type\": \"plain_text\", \"text\": {{ state }} }, { \"type\": \"plain_text\", \"text\": \"{{ is_correlated }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Created On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Modified On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ created_on }}\" }, { \"type\": \"plain_text\", \"text\": \"{{ modified_on }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Activated On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Closed On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ active_since }}\" }, { \"type\": \"plain_text\", \"text\": \"{% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Aggregated Incidents*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Monitoring Tool*\" }, { \"type\": \"plain_text\", \"text\": \"{{ incident_count }}\" }, { \"type\": \"plain_text\", \"text\": {{ sources|join(', ') }} } ] } ] } Copy Suggested VictorOps template example { \"monitoring_tool\": {{ sources }}, {% if state == 'closed' %} \"message_type\": \"OK\", {% else %} \"message_type\": {{ priority }}, {% endif %} \"custom_fields\": { \"issue_url\": {{ url }}, \"description\": {{ description }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"related_incidents\": [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %} {% endfor %} ] }, \"state_message\": {{ description }}, \"entity_id\": {{ id }}, \"entity_display_name\": {{ ui_name }}, \"vo_annotate.u.NRAI_Link\": {{ url }} } Copy Webhook and JSON format examples Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). If you use webhooks to configure Incident Intelligence destinations, use these examples of the webhook body format and JSON schema. Webhook format and JSON example Webhook format: Name Description url Href A link to the UI where the issue can be seen. id String Unique identifier for the issue. title String The issue title. description String The description of the issue. priority Enum The issue priority. Can be Critical, High, Medium, or Low. state Enum The issue status. Can be Active, Closed, or Acknowledged. is_correlated Boolean True if the issue is based on correlated data. created_on String The date and time the issue was created (in ISO format). modified_on String The date and time the issue was modified (in ISO format). active_since String The date and time the issue was activated (in ISO format). closed_on String The date and time the issue was closed (in ISO format). sources List(String) List of the different sources that were used to send the events into Applied Intelligence (for example: PagerDuty). pathways List(Pathways) List of pathways that are associated with the issue. Each pathway contains an id and name: [{“id”: “pathway id”, “name”: “pathway name”}]. pathways[].id String The pathway ID. pathways[].name String The pathway name. incidents List(Incident) List of incidents that are attached to the issue. The list contains only the latest 100 incidents. incidents[].id String The incident ID. incidents[].events_count Integer The number of events used to create the incident. incidents[].title String The incident title. incidents[].description String The incident description. incidents[].labels Dictionary (String) A string to string mapping of the incident labels. Labels represent the unique entities that are used to describe the incident. incidents[].priority Enum The incident priority. Can be Critical, High, Medium, or Low. incidents[].sources List(String) The incident source. incidents[].state Enum(open, closed) The incident state. incidents[].opened_on String The date and time the incident was opened (in ISO format). incidents[].closed_on String The date and time the incident was closed (in ISO format). ui_name String Issue title. accumulations['alert/signal'] String Issue analysis summary golden signal/s (if applicable). accumulations['alert/components'] String Issue analysis summary golden components (if applicable). Jinja2 Default Payload Applied Intelligence uses a templating framework called Jinja2 in the Webhook interface. Here is a default Jinja2 payload to use: { \"id\": {{ id }}, \"url\": {{ url }}, \"ui_name\": {{ ui_name }}, \"description\": {{ description }}, \"priority\": {{ priority }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"active_since\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"sources\": {{ sources }}, \"incidents\": {{ incidents }}, \"pathways\": {{ pathways }}, } Copy Jinja2 Useful Syntax Below are a few useful Jinja2 commands to help you format your output. Casting a value to integer Example: “severity”: {{ priority | int }} Copy If clause to check if an attribute’s value is set Example: \"golden_signals\": {% if accumulations['alert/signal'] is defined %} {{ accumulations['alert/signal'] }} {% else %} None {% endif %} Copy For loop to iterate of an array of values: Example: \"description\": 'Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]' Copy Check if an array attribute's value is set: Example: \"hostname_field\": {% if incidents[0].labels['newrelic/tag/hostname'] is defined %} {{ incidents[0].labels['newrelic/tag/hostname'] }} {% else %} None {% endif %} Copy JSON schema Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). JSON schema template JSON schema: { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"definitions\": { \"Labels\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"LabelsSet\": { \"type\": \"array\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"$ref\": \"#/definitions/Labels\" }, \"uniqueItems\": true }, }, \"Annotations\": { \"type\": \"object\", \"title\": \"Additional contextual information about the Entity\", \"description\": \"Fields like title, description and priority can be described as annotations since\\nthey represent some additional information about the Incident.\\nFor example, the rule that creates the entity can have some logic that will create a title annotation field.\\nThe title will change according to the latest event received by the entity and as more\\nevent will keep coming the field may change, all this as a decision by the rule.\\nA different rule may decide not to populate the title at all.\\nSince a title can also be produced from the labels themselves.\", \"properties\": { \"title\": { \"type\": \"string\", \"maxLength\": 10000 }, \"description\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"patternProperties\": { \".*\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"Accumulations\": { \"type\": \"object\", \"title\": \"Accumulated data about the Incident\", \"description\": \"For example an entity with the label: host_name: foo will include a accumulated list of the\\nrelevant process names that are relevant to the entity. Accumulations will be derived from the events\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"type\": \"string\", \"maxLength\": 10000 } } }, \"IssueState\": { \"type\": \"string\", \"enum\": [ \"created\", \"active\", \"acknowledged\", \"closed\" ], \"properties\": {}, \"additionalProperties\": false }, \"Priority\": { \"type\": \"string\", \"enum\": [ \"critical\", \"high\", \"medium\", \"low\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueClosingReason\": { \"type\": \"string\", \"enum\": [ \"nacked\", \"resolved\", \"system\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueAction\": { \"type\": \"string\", \"enum\": [ \"ack\", \"snooze\", \"nack\", \"end_snooze\", \"expire_snooze\", \"star\", \"un_snooze\", \"unstar\", \"archive\", \"unarchive\", \"resolve\", \"reopen\", \"open\", \"feedback\", \"feedback_file\", \"open_ticket\", \"merge_issues\", \"active\", \"create\", \"close\", \"incident_updated\", \"confidence_changed\", \"diagnoses_changed\", \"rule_properties_changed\", \"flapping\", \"notification\", \"incident_events_limit_reached\", \"follow\", \"unfollow\", \"priority_updated\", \"comment\", \"incident_appended\", \"diagnosis_feedback\", \"flapping_delay_close\" ], \"properties\": {}, \"additionalProperties\": false }, \"StringKeyValue\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\" } }, \"JavaOptionalUuid\": { \"type\": \"string\", \"properties\": {}, \"additionalProperties\": false, \"format\": \"string-uuid\" } }, \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"customer_id\": { \"type\": \"integer\" }, \"labels_set\": { \"$ref\": \"#/definitions/LabelsSet\" }, \"annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations_version\": { \"type\": \"integer\" }, \"accumulations\": { \"$ref\": \"#/definitions/Accumulations\" }, \"state\": { \"$ref\": \"#/definitions/IssueState\" }, \"previous_state\": { \"$ref\": \"#/definitions/IssueState\" }, \"priority\": { \"$ref\": \"#/definitions/Priority\" }, \"closing_reason\": { \"oneOf\": [ { \"$ref\": \"#/definitions/IssueClosingReason\" }, { \"type\": \"null\" } ] }, \"modified_on\": { \"type\": \"integer\" }, \"created_on\": { \"type\": \"integer\" }, \"closed_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"acknowledged_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"active_since\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"assigned_to\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"created_by\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"progress_report\": { \"type\": \"array\", \"default\": [], \"items\": { \"type\": \"object\", \"properties\": { \"origin_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1 }, { \"type\": \"null\" } ] }, \"timestamp\": { \"type\": \"integer\" }, \"action_timestamp\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"origin_type\": { \"type\": \"string\", \"enum\": [ \"user\", \"system\" ] }, \"event_type\": { \"$ref\": \"#/definitions/IssueAction\" }, \"issue_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"format\": \"string-uuid\" }, { \"type\": \"null\" } ] }, \"attributes\": { \"oneOf\": [ { \"$ref\": \"#/definitions/StringKeyValue\" }, { \"type\": \"null\" } ] }, \"team_id\": { \"$ref\": \"#/definitions/JavaOptionalUuid\" } }, \"required\": [ \"timestamp\", \"origin_type\", \"event_type\" ], \"additionalProperties\": false }, \"uniqueItems\": true }, \"rule_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"maxLength\": 255 }, { \"type\": \"null\" } ] }, \"incident_ids\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"confidence\": { \"type\": \"number\", \"default\": 1.0, \"minimum\": 0.0, \"maximum\": 1.0 } }, \"required\": [ \"id\", \"customer_id\", \"labels_set\", \"annotations\", \"priority\", \"modified_on\", \"created_on\", \"confidence\" ], \"additionalProperties\": true } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.19972,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Incident <em>Intelligence</em> destination examples",
        "sections": "Incident <em>Intelligence</em> destination examples",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In <em>New</em> <em>Relic</em> <em>Applied</em> <em>Intelligence</em>, under Incident <em>Intelligence</em> click Destinations Add a WebHook In the end point paste the WebHook url"
      },
      "id": "6044280d64441f4af5378ed3"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alert-violations/violation-event-attributes": [
    {
      "sections": [
        "View alert violations from our products",
        "APM",
        "Browser",
        "Infrastructure",
        "Mobile",
        "Synthetic monitoring"
      ],
      "title": "View alert violations from our products",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert violations"
      ],
      "external_id": "88fe8f43f2051726d47724a7449cdf0de73e547a",
      "image": "https://docs.newrelic.com/static/1f6ac9f210cb330e6e0a0b7a9221ea1a/c1b63/screen-apm-violations_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-violations/view-alert-violations-our-products/",
      "published_at": "2021-05-28T11:11:26Z",
      "updated_at": "2021-03-29T18:15:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To view violations for a specific entity (alert target), select the Violations index from the product page. Then, from the product's Violations index, use the available tools to search, sort, or view violations for the selected entity. From here you can also view or update the policies and conditions that triggered the violations. one.newrelic.com > Explorer > (select an app) > Events > Violations: Here's an example of the Violations index. Use the available tools to search, sort, or view violations for the selected entity, or to view or update the associated policies and conditions. APM To view violations for a specific app or key transaction: App: In the one.newrelic.com top nav, click APM, (select an application), then under Events, click Violations. Key transaction: In the one.newrelic.com top nav, click More, click Key transactions, then (select a key transaction). In the left nav under Events, click Violations. Browser To view violations for a specific browser app: In the one.newrelic.com top nav, click Browser, then (select a browser app). In the left nav click Move views, click Violations. Infrastructure To view violations for a specific host monitored by Infrastructure: In the one.newrelic.com top nav, click Infrastructure, and then click Settings. In the left nav, click Alerts. Mobile To view violations for a specific mobile app: In the one.newrelic.com top nav, click Mobile, then (select a mobile app). In the left nav click More views, then click Event explorer. Synthetic monitoring To view violations for a specific monitor: In the one.newrelic.com top nav, click Synthetics, then (select a monitor). In the right nav under Activity, click Alert violations.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.41302,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "View <em>alert</em> <em>violations</em> from our products",
        "sections": "View <em>alert</em> <em>violations</em> from our products",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "To view <em>violations</em> for a specific entity (<em>alert</em> target), select the <em>Violations</em> index from the product page. Then, from the product&#x27;s <em>Violations</em> index, use the available tools to search, sort, or view <em>violations</em> for the selected entity. From here you can also view or update the policies"
      },
      "id": "6043fcb6196a6784a0960f1d"
    },
    {
      "sections": [
        "How alert condition violations are closed",
        "How violations automatically close",
        "Manually close a violation",
        "Important",
        "Set a time limit for long-lasting violations"
      ],
      "title": "How alert condition violations are closed",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert violations"
      ],
      "external_id": "41e9d59a43c91f2364ae832f472f4c395986c355",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-violations/how-alert-condition-violations-are-closed/",
      "published_at": "2021-05-28T17:59:03Z",
      "updated_at": "2021-03-13T04:04:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains the different ways violations can be closed. How violations automatically close A violation will automatically close when the targeted signal returns to a non-violating state for the time period indicated in the condition's thresholds. This wait time is called the recovery period. For example: If the violating behavior is \"Apdex score below 0.80 at least once in 5 minutes,\" then the violation will automatically close when the Apdex score is equal to or higher than .80 for 5 consecutive minutes. The same applies to a \"for at least x minutes\" threshold: x minutes of non-violating behavior are required to automatically close the violation. When a violation closes automatically: The closing timestamp is backdated to the start of the recovery period. The evaluation resets and restarts from when the previous violation ended. Some types of conditions have a violation time limit setting that will automatically force-close a long-lasting violation. Manually close a violation You can manually close an open violation. This is useful, for example, when a signal has violated the threshold, but it no longer exists and also doesn't have a violation time limit. (A time limit would automatically close a long-lasting violation.) To close a violation: Go to the open violation you want to close. Click Manually close violation. To close all violations associated with a condition: Go to the condition you want to close. Disable the condition and then re-enable it. Important An incident will close automatically when all of its associated critical violations have been closed. Set a time limit for long-lasting violations Some types of conditions have a violation time limit setting. This limit will automatically force-close a long-lasting violation after the number of hours you select. This is most useful for ephemeral entities that, when they disappear, cause a continual violation that won't automatically close. Limits and Defaults All alert violations will have a violation time limit applied to them. Most alert conditions will allow you to edit this field. The default value, if one is not supplied during configuration, is 30 days. Violation time limit can be set as low as 5 minutes, and as high as 30 days. If, for some reason, the signal is still violating in 30 days, the violation will close, and a new violation will open. Examples: You set the violation time limit to 12 hours. If that violation lasts for 12 hours, it will be closed at 12 hours and the condition's evaluation of that entity will be reset. Your JVM has a CPU spike and this creates a violation. The JVM then crashes and is replaced by a new JVM. If you have not set a violation time limit, the crashed JVM’s violation will never close.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.04822,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "How <em>alert</em> condition <em>violations</em> are closed",
        "sections": "How <em>alert</em> condition <em>violations</em> are closed",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " of hours you select. This is most useful for ephemeral entities that, when they disappear, cause a continual violation that won&#x27;t automatically close. Limits and Defaults All <em>alert</em> <em>violations</em> will have a violation time limit <em>applied</em> to them. Most <em>alert</em> conditions will allow you to edit this field"
      },
      "id": "6043fcf2196a67dcce960f80"
    },
    {
      "sections": [
        "Incident Intelligence destination examples",
        "Destination template examples",
        "Suggested OpsGenie template example",
        "Suggested ServiceNow template example",
        "Suggested Slack template example",
        "Suggested VictorOps template example",
        "Webhook and JSON format examples",
        "Webhook format and JSON example",
        "Jinja2 Default Payload",
        "Jinja2 Useful Syntax",
        "JSON schema",
        "JSON schema template"
      ],
      "title": "Incident Intelligence destination examples",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "a516d04f8b75541a6dc9338fa3ce9645ba87d620",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/incident-intelligence-destination-examples/",
      "published_at": "2021-06-02T18:22:22Z",
      "updated_at": "2021-06-02T18:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Destinations are the data outputs to Applied Intelligence, where you can view your automatically correlated incidents. You can configure Incident Intelligence destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema. Destination template examples The following template example destinations are formatted in Jinja2. Suggested OpsGenie template example { \"alias\": {{ id }}, \"message\": {{ ui_name }}, \"source\": '{{ sources }}', \"priority\": {{ priority }}, \"details\": { \"self_url\": {{ url }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"is_correlated\": {{ is_correlated }} }, \"description\": \"\"\"Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]\"\"\" } Copy Suggested ServiceNow template example { \"short_description\": {{ ui_name }}, \"description\": 'Issue Id: {{ id }}, \\n Description: {{ description }}, \\n Sources: {{ sources }}, \\n Priority: {{ priority }}, \\n Details: { \\n self_url: {{ url }}, \\n state: {{ state }}, \\n is_correlated: {{ is_correlated }}, \\n created_on: {{ created_on }}, \\n modified_on: {{ modified_on }}, \\n activated_on: {{ active_since }}, \\n closed_on: {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \\n is_correlated: {{is_correlated}} }, \\n\\n incidents: {{ incidents }}, \\n\\n pathways: {{ pathways }}' } Copy Suggested Slack template example Go to Slack incoming WebHooks Choose the right Slack workspace and click \"Add to Slack\" Select the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In New Relic Applied Intelligence, under Incident Intelligence click Destinations Add a WebHook In the end point paste the WebHook url from slack. In the custom payload, paste the following JSON: { \"blocks\": [ { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*New Relic Incident Intelligence Alert*\" } }, { \"type\": \"divider\" }, { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*CUSTOM FIELDS*:\" }, \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue ID*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Issue Title*\" }, { \"type\": \"plain_text\", \"text\": {{ id }} }, { \"type\": \"plain_text\", \"text\": {{ ui_name }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue URL*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Description*\" }, { \"type\": \"mrkdwn\", \"text\": {{ url }} }, { \"type\": \"plain_text\", \"text\": {{ description }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*State*\" }, { \"type\": \"mrkdwn\", \"text\": \"*is_correlated*\" }, { \"type\": \"plain_text\", \"text\": {{ state }} }, { \"type\": \"plain_text\", \"text\": \"{{ is_correlated }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Created On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Modified On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ created_on }}\" }, { \"type\": \"plain_text\", \"text\": \"{{ modified_on }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Activated On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Closed On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ active_since }}\" }, { \"type\": \"plain_text\", \"text\": \"{% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Aggregated Incidents*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Monitoring Tool*\" }, { \"type\": \"plain_text\", \"text\": \"{{ incident_count }}\" }, { \"type\": \"plain_text\", \"text\": {{ sources|join(', ') }} } ] } ] } Copy Suggested VictorOps template example { \"monitoring_tool\": {{ sources }}, {% if state == 'closed' %} \"message_type\": \"OK\", {% else %} \"message_type\": {{ priority }}, {% endif %} \"custom_fields\": { \"issue_url\": {{ url }}, \"description\": {{ description }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"related_incidents\": [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %} {% endfor %} ] }, \"state_message\": {{ description }}, \"entity_id\": {{ id }}, \"entity_display_name\": {{ ui_name }}, \"vo_annotate.u.NRAI_Link\": {{ url }} } Copy Webhook and JSON format examples Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). If you use webhooks to configure Incident Intelligence destinations, use these examples of the webhook body format and JSON schema. Webhook format and JSON example Webhook format: Name Description url Href A link to the UI where the issue can be seen. id String Unique identifier for the issue. title String The issue title. description String The description of the issue. priority Enum The issue priority. Can be Critical, High, Medium, or Low. state Enum The issue status. Can be Active, Closed, or Acknowledged. is_correlated Boolean True if the issue is based on correlated data. created_on String The date and time the issue was created (in ISO format). modified_on String The date and time the issue was modified (in ISO format). active_since String The date and time the issue was activated (in ISO format). closed_on String The date and time the issue was closed (in ISO format). sources List(String) List of the different sources that were used to send the events into Applied Intelligence (for example: PagerDuty). pathways List(Pathways) List of pathways that are associated with the issue. Each pathway contains an id and name: [{“id”: “pathway id”, “name”: “pathway name”}]. pathways[].id String The pathway ID. pathways[].name String The pathway name. incidents List(Incident) List of incidents that are attached to the issue. The list contains only the latest 100 incidents. incidents[].id String The incident ID. incidents[].events_count Integer The number of events used to create the incident. incidents[].title String The incident title. incidents[].description String The incident description. incidents[].labels Dictionary (String) A string to string mapping of the incident labels. Labels represent the unique entities that are used to describe the incident. incidents[].priority Enum The incident priority. Can be Critical, High, Medium, or Low. incidents[].sources List(String) The incident source. incidents[].state Enum(open, closed) The incident state. incidents[].opened_on String The date and time the incident was opened (in ISO format). incidents[].closed_on String The date and time the incident was closed (in ISO format). ui_name String Issue title. accumulations['alert/signal'] String Issue analysis summary golden signal/s (if applicable). accumulations['alert/components'] String Issue analysis summary golden components (if applicable). Jinja2 Default Payload Applied Intelligence uses a templating framework called Jinja2 in the Webhook interface. Here is a default Jinja2 payload to use: { \"id\": {{ id }}, \"url\": {{ url }}, \"ui_name\": {{ ui_name }}, \"description\": {{ description }}, \"priority\": {{ priority }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"active_since\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"sources\": {{ sources }}, \"incidents\": {{ incidents }}, \"pathways\": {{ pathways }}, } Copy Jinja2 Useful Syntax Below are a few useful Jinja2 commands to help you format your output. Casting a value to integer Example: “severity”: {{ priority | int }} Copy If clause to check if an attribute’s value is set Example: \"golden_signals\": {% if accumulations['alert/signal'] is defined %} {{ accumulations['alert/signal'] }} {% else %} None {% endif %} Copy For loop to iterate of an array of values: Example: \"description\": 'Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]' Copy Check if an array attribute's value is set: Example: \"hostname_field\": {% if incidents[0].labels['newrelic/tag/hostname'] is defined %} {{ incidents[0].labels['newrelic/tag/hostname'] }} {% else %} None {% endif %} Copy JSON schema Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). JSON schema template JSON schema: { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"definitions\": { \"Labels\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"LabelsSet\": { \"type\": \"array\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"$ref\": \"#/definitions/Labels\" }, \"uniqueItems\": true }, }, \"Annotations\": { \"type\": \"object\", \"title\": \"Additional contextual information about the Entity\", \"description\": \"Fields like title, description and priority can be described as annotations since\\nthey represent some additional information about the Incident.\\nFor example, the rule that creates the entity can have some logic that will create a title annotation field.\\nThe title will change according to the latest event received by the entity and as more\\nevent will keep coming the field may change, all this as a decision by the rule.\\nA different rule may decide not to populate the title at all.\\nSince a title can also be produced from the labels themselves.\", \"properties\": { \"title\": { \"type\": \"string\", \"maxLength\": 10000 }, \"description\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"patternProperties\": { \".*\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"Accumulations\": { \"type\": \"object\", \"title\": \"Accumulated data about the Incident\", \"description\": \"For example an entity with the label: host_name: foo will include a accumulated list of the\\nrelevant process names that are relevant to the entity. Accumulations will be derived from the events\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"type\": \"string\", \"maxLength\": 10000 } } }, \"IssueState\": { \"type\": \"string\", \"enum\": [ \"created\", \"active\", \"acknowledged\", \"closed\" ], \"properties\": {}, \"additionalProperties\": false }, \"Priority\": { \"type\": \"string\", \"enum\": [ \"critical\", \"high\", \"medium\", \"low\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueClosingReason\": { \"type\": \"string\", \"enum\": [ \"nacked\", \"resolved\", \"system\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueAction\": { \"type\": \"string\", \"enum\": [ \"ack\", \"snooze\", \"nack\", \"end_snooze\", \"expire_snooze\", \"star\", \"un_snooze\", \"unstar\", \"archive\", \"unarchive\", \"resolve\", \"reopen\", \"open\", \"feedback\", \"feedback_file\", \"open_ticket\", \"merge_issues\", \"active\", \"create\", \"close\", \"incident_updated\", \"confidence_changed\", \"diagnoses_changed\", \"rule_properties_changed\", \"flapping\", \"notification\", \"incident_events_limit_reached\", \"follow\", \"unfollow\", \"priority_updated\", \"comment\", \"incident_appended\", \"diagnosis_feedback\", \"flapping_delay_close\" ], \"properties\": {}, \"additionalProperties\": false }, \"StringKeyValue\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\" } }, \"JavaOptionalUuid\": { \"type\": \"string\", \"properties\": {}, \"additionalProperties\": false, \"format\": \"string-uuid\" } }, \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"customer_id\": { \"type\": \"integer\" }, \"labels_set\": { \"$ref\": \"#/definitions/LabelsSet\" }, \"annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations_version\": { \"type\": \"integer\" }, \"accumulations\": { \"$ref\": \"#/definitions/Accumulations\" }, \"state\": { \"$ref\": \"#/definitions/IssueState\" }, \"previous_state\": { \"$ref\": \"#/definitions/IssueState\" }, \"priority\": { \"$ref\": \"#/definitions/Priority\" }, \"closing_reason\": { \"oneOf\": [ { \"$ref\": \"#/definitions/IssueClosingReason\" }, { \"type\": \"null\" } ] }, \"modified_on\": { \"type\": \"integer\" }, \"created_on\": { \"type\": \"integer\" }, \"closed_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"acknowledged_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"active_since\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"assigned_to\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"created_by\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"progress_report\": { \"type\": \"array\", \"default\": [], \"items\": { \"type\": \"object\", \"properties\": { \"origin_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1 }, { \"type\": \"null\" } ] }, \"timestamp\": { \"type\": \"integer\" }, \"action_timestamp\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"origin_type\": { \"type\": \"string\", \"enum\": [ \"user\", \"system\" ] }, \"event_type\": { \"$ref\": \"#/definitions/IssueAction\" }, \"issue_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"format\": \"string-uuid\" }, { \"type\": \"null\" } ] }, \"attributes\": { \"oneOf\": [ { \"$ref\": \"#/definitions/StringKeyValue\" }, { \"type\": \"null\" } ] }, \"team_id\": { \"$ref\": \"#/definitions/JavaOptionalUuid\" } }, \"required\": [ \"timestamp\", \"origin_type\", \"event_type\" ], \"additionalProperties\": false }, \"uniqueItems\": true }, \"rule_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"maxLength\": 255 }, { \"type\": \"null\" } ] }, \"incident_ids\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"confidence\": { \"type\": \"number\", \"default\": 1.0, \"minimum\": 0.0, \"maximum\": 1.0 } }, \"required\": [ \"id\", \"customer_id\", \"labels_set\", \"annotations\", \"priority\", \"modified_on\", \"created_on\", \"confidence\" ], \"additionalProperties\": true } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.19972,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Incident <em>Intelligence</em> destination examples",
        "sections": "Incident <em>Intelligence</em> destination examples",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In <em>New</em> <em>Relic</em> <em>Applied</em> <em>Intelligence</em>, under Incident <em>Intelligence</em> click Destinations Add a WebHook In the end point paste the WebHook url"
      },
      "id": "6044280d64441f4af5378ed3"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-alerts-policies": [
    {
      "sections": [
        "NerdGraph tutorial: Loss of signal and gap filling",
        "Tip",
        "Customize your loss of signal detection",
        "View loss of signal settings for an existing condition",
        "Create a new condition with loss of signal settings",
        "Update the loss of signal settings of a condition",
        "Customize gap filling",
        "Important"
      ],
      "title": "NerdGraph tutorial: Loss of signal and gap filling",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alerts and Nerdgraph"
      ],
      "external_id": "ff33c468e6df0d99acc13f7a8827da5bbf07d341",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-loss-signal-gap-filling/",
      "published_at": "2021-05-28T18:13:13Z",
      "updated_at": "2021-04-22T10:48:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Loss of signal occurs when New Relic stops receiving data for a while; technically, we detect loss of signal after a significant amount of time has elapsed since data was last received in a time series. Loss of signal can be used to trigger or resolve a violation, which you can use to set up alerts. Gap filling can help you solve issues caused by lost data points. When gaps are detected between valid data points, we automatically fill those gaps with replacement values, such as the last known values or a static value. Gap filling can prevent alerts from triggering or resolving when they shouldn't. Tip To learn more about signal loss, gap filling, and how to request access to these features, see this announcement. You can customize loss of signal detection and gap filling using NerdGraph. For example, you can configure how long to wait before considering the signal lost, or what value should be used for filling gaps in the time series. Here are some queries and examples you can use in our NerdGraph API explorer. In this guide we cover the following: Customize loss of signal detection Customize gap filling Customize your loss of signal detection Loss of signal detection opens or closes violations if no data is received after a certain amount of time. For example, if you set the duration of the expiration period to 60 seconds and an integration doesn't seem to send data for more than a minute, a loss of signal violation would be triggered. You can configure the duration of the signal loss and whether to open a violation or close it by using these three fields in NerdGraph: expiration.expirationDuration: How long to wait, in seconds, after the last data point is received by our platform before considering the signal as lost. This is based on the time when data arrives at our platform and not on data timestamps. The default is to leave this null, and therefore this wouldn't enable Loss of Signal Detection. expiration.openViolationOnExpiration: If true, a new violation is opened when a signal is lost. Default is false. To use this field, a duration must be specified. expiration.closeViolationsOnExpiration: If true, open violations related to the signal are closed on expiration. Default is false. To use this field, a duration must be specified. View loss of signal settings for an existing condition Existing NRQL conditions may have their loss of signal settings already configured. To view the existing condition settings, select the fields under nrqlCondition > expiration: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlCondition(id: NRQL_CONDITION_ID) { ... on AlertsNrqlStaticCondition { id name nrql { query } expiration { closeViolationsOnExpiration expirationDuration openViolationOnExpiration } } } } } } } Copy You should see a result like this: { \"data\": { \"actor\": { \"account\": { \"alerts\": { \"nrqlCondition\": { \"expiration\": { \" closeViolationsOnExpiration \": false, \" expirationDuration \": 300, \" openViolationOnExpiration \": true }, \"id\": \"YOUR_ACCOUNT_ID\", \"name\": \"Any less than - Extrapolation\", \"nrql\": { \"query\": \"SELECT average(value) FROM AlertsSmokeTestSignals WHERE wave_type IN ('min-max', 'single-gap') FACET wave_type\" } } } } } }, ... Copy Create a new condition with loss of signal settings Let's say that you want to create a new create a NRQL static condition that triggers a loss of signal violation after no data is received for two minutes. You would set expirationDuration to 120 seconds and set openViolationOnExpiration to true, like in the example below. mutation { alertsNrqlConditionStaticCreate( accountId: YOUR_ACCOUNT_ID policyId: YOUR_POLICY_ID condition: { name: \"Low Host Count - Catastrophic\" enabled: true nrql: { query: \"SELECT uniqueCount(host) from Transaction where appName='my-app-name'\" } signal { aggregationWindow: 60 evaluationOffset: 3 } terms: [{ threshold: 2 thresholdOccurrences: AT_LEAST_ONCE thresholdDuration: 600 operator: BELOW priority: CRITICAL }] valueFunction: SINGLE_VALUE violationTimeLimitSeconds: 86400 expiration : { expirationDuration : 120 openViolationOnExpiration : true } } ) { id name } } Copy Update the loss of signal settings of a condition What if you want to update loss of signal parameters for an alert condition? The following mutation allows you to update a NRQL static condition with new expiration values. mutation { alertsNrqlConditionStaticUpdate( accountId: YOUR_ACCOUNT_ID id: YOUR_STATIC_CONDITION_ID condition: { expiration: { closeViolationsOnExpiration : BOOLEAN expirationDuration : DURATION_IN_SECONDS openViolationOnExpiration : BOOLEAN } } ) { id expiration { closeViolationsOnExpiration expirationDuration openViolationOnExpiration } } } Copy Customize gap filling Gap filling replaces gap values in a time series with either the last value found or a static, arbitrary value of your choice. We fill gaps only after another data point has been received after the gaps in signal (after data reception has been restored). You can configure both the type of filling and the value, if the type is set to static: signal.fillOption: Type of replacement value for lost data points. Values can be: NONE: Gap filling is disabled. LAST_VALUE: The last value seen in the time series. STATIC: An arbitrary value, defined in fillValue. signal.fillValue: Value to use for replacing lost data points when fillOption is set to STATIC. Important Gap filling is also affected by expiration.expirationDuration. When a gap is longer than the expiration duration, the signal is considered expired and the gap will no longer be filled. For example, here's how to create a static NRQL condition with gap filling configured: mutation { alertsNrqlConditionStaticCreate( accountId: YOUR_ACCOUNT_ID policyId: YOUR_POLICY_ID condition: { enabled: true name: \"Example Gap Filling Condition\" nrql: { query: \"select count(*) from Transaction\" } terms: { operator: ABOVE priority: CRITICAL threshold: 1000 thresholdDuration: 300 thresholdOccurrences: ALL } valueFunction: SINGLE_VALUE violationTimeLimitSeconds: 28800 signal: { aggregationWindow: 60, evaluationOffset: 3, fillOption: STATIC, fillValue: 1 } } ) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 191.22678,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: Loss of signal <em>and</em> gap filling",
        "sections": "<em>NerdGraph</em> tutorial: Loss of signal <em>and</em> gap filling",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "Loss of signal occurs when <em>New</em> <em>Relic</em> stops receiving data for a while; technically, we detect loss of signal after a significant amount of time has elapsed since data was last received in a time series. Loss of signal can be used to trigger or resolve a violation, which you can use to set up <em>alerts</em>"
      },
      "id": "603f1f24196a67f381a83da8"
    },
    {
      "sections": [
        "NerdGraph tutorial: NRQL condition alerts",
        "Tip",
        "Steps to create a NRQL condition",
        "NRQL static condition",
        "NRQL baseline condition",
        "NRQL outlier condition",
        "Update a condition",
        "Update mutations",
        "List and filter NRQL conditions",
        "Use cursor pagination",
        "Request type-specific fields",
        "Filter NRQL conditions",
        "Singular NRQL condition queries",
        "Update the description",
        "Delete conditions"
      ],
      "title": "NerdGraph tutorial: NRQL condition alerts",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alerts and Nerdgraph"
      ],
      "external_id": "85399f92d659094c72d6565f258061a0161e751d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-nrql-condition-alerts/",
      "published_at": "2021-05-28T11:11:27Z",
      "updated_at": "2021-04-21T16:20:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can manage alerts conditions using our GraphQL NerdGraph API. Here are some conditions queries and mutations you can develop in our NerdGraph API explorer. Tip See the NerdGraph introduction for help getting started with NerdGraph API explorer. This document covers the following: Steps to create a NRQL condition NRQL static condition NRQL baseline condition NRQL outlier condition Update a condition Update mutations List and filter NRQL conditions Singular NRQL condition queries Create a description Delete conditions Steps to create a NRQL condition Follow these steps: Decide which condition type you want to create (see NRQL Condition threshold types). Find your relevant policyID by doing one of the following: Use the NerdGraph policies API. Go to one.newrelic.com, in the top nav click Alerts & AI, then click Policies. Choose a policy. Find the ID under the policy name. Provide the appropriate mutation for your NRQL condition type and the relevant values. Tip The NerdGraph GraphiQL explorer is the best place to find up-to-date documentation about the per-field specifics of the NerdGraph NRQL Conditions API. For example, questions like \"What does the valueFunction field accept?\" are best answered with the inline NerdGraph documentation. NRQL static condition Here's an example of creating a static condition: mutation { alertsNrqlConditionStaticCreate(accountId: YOUR_ACCOUNT_ID, policyId: YOUR_POLICY_ID, condition: { name: \"Low Host Count - Catastrophic\" enabled: true nrql: { query: \"SELECT uniqueCount(host) from Transaction where appName='my-app-name'\" } signal: { aggregationWindow: 60 evaluationOffset: 3 } terms: { threshold: 2 thresholdOccurrences: AT_LEAST_ONCE thresholdDuration: 600 operator: BELOW priority: CRITICAL } valueFunction: SINGLE_VALUE violationTimeLimitSeconds: 86400 }) { id name } } Copy NRQL baseline condition Here's an example of creating a baseline condition: mutation { alertsNrqlConditionBaselineCreate(accountId: YOUR_ACCOUNT_ID, policyId: YOUR_POLICY_ID, condition: { name: \"Baseline Condition\" enabled: true baselineDirection: UPPER_ONLY nrql: { query: \"SELECT average(duration) FROM Transaction\" } signal: { aggregationWindow: 60 evaluationOffset: 3 } terms: { threshold: 13 thresholdDuration: 180 thresholdOccurrences: ALL operator: ABOVE priority: CRITICAL } violationTimeLimitSeconds: 86400 }) { id name baselineDirection } } Copy NRQL outlier condition Here's an example of creating an outlier condition: mutation { alertsNrqlConditionOutlierCreate(accountId: YOUR_ACCOUNT_ID, policyId: YOUR_POLICY_ID, condition: { name: \"Outlier Condition\" enabled: true expectedGroups: 4 openViolationOnGroupOverlap: false nrql: { query: \"SELECT average(duration) FROM Transaction FACET httpResponseCode\" } signal: { aggregationWindow: 60 evaluationOffset: 3 } terms: { threshold: 1 thresholdDuration: 300 thresholdOccurrences: ALL operator: ABOVE priority: CRITICAL } violationTimeLimitSeconds: 86400 }) { id name expectedGroups openViolationOnGroupOverlap } } Copy Update a condition Complete the following: Determine the type of your existing condition by requesting the type field in a nrqlConditionsSearch query like this: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch { nrqlConditions { id type } } } } } } Copy Tip The type returned is what you use for your update mutation. For example, if the type returned is STATIC, use alertsNrqlConditionStaticUpdate. If the type returned is BASELINE, use alertsNrqlConditionBaselineUpdate. If the type returned is OUTLIER, use alertsNrqlConditionOutlierUpdate. Provide the id of your condition to your relevant condition type mutation. Note that you can only update conditions of the relevant type. Only provide update mutations for the fields you want to update. Fields you don't provide in the update are not touched. Update mutations Only fields that you provide in the update are changed. In the following example, baselineDirection returns unchanged, but name is updated. mutation { alertsNrqlConditionBaselineUpdate(id: YOUR_CONDITION_ID, accountId: YOUR_ACCOUNT_ID, condition: { name: \"Your updated name\" }) { id name baselineDirection } } Copy List and filter NRQL conditions To list or filter your NRQL conditions, use the nrqlConditionsSearch query in NerdGraph. Use cursor pagination The basic of list functionality for NRQL conditions allows you to paginate through your NRQL conditions as well as request the total count of conditions per account. The nrqlConditionsSearch query utilizes cursor pagination to paginate through resources. The idea behind cursor pagination is that the client will request a cursor in a programmatic loop until the cursor comes back empty. An initial list response will look something like this: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch { nextCursor nrqlConditions { id name type } totalCount } } } } } Copy This example returns a JSON response like this: { \"data\": { \"actor\": { \"account\": { \"alerts\": { \"nrqlConditionsSearch\": { \"nextCursor\": \"WOwfJ4+TWm9QTFeKMGyg+w==:QqkI8S4+Wwnpno6z+uk8kQ==\", \"nrqlConditions\": [ { \"id\": \"4432\", \"name\": \"Baseline Condition\", \"type\": \"BASELINE\" }, { \"id\": \"443\", \"name\": \"A static condition\", \"type\": \"STATIC\" }, // more conditions here in reality ], \"totalCount\": 435 } } } } }, } Copy In order to paginate through conditions in the response, have the client request the cursor to be returned until the nextCursor returns from the response as null: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch(cursor: \"WOwfJ4+TWm9QTFeKMGyg+w==:QqkI8S4+Wwnpno6z+uk8kQ==\", ) { nextCursor nrqlConditions { id name type } totalCount } } } } } Copy Request type-specific fields Certain fields are only available on specific NRQL condition types. The main reason that mutations are split between the different condition types is because they have minor differences between the fields they accept. For example, valueFunction is only relevant for static NRQL conditions and baselineDirection is only relevant on baseline NRQL conditions. But if these fields are only available on these certain condition types, how do we return them in a list of all of our condition types? The answer is a GraphQL convention known as inline fragments. Inline fragments allow you to access the data on a specific type of NRQL condition: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch { nrqlConditions { id name type ...on AlertsNrqlStaticCondition { valueFunction } ...on AlertsNrqlBaselineCondition { baselineDirection } ...on AlertsNrqlOutlierCondition { expectedGroups } } } } } } } Copy In the previous example query, we are asking GraphQL to do the hard work for us to determine which NRQL conditions are the correct type. So, when the returned type is a static condition, it will return the valueFunction in the object. When the returned type is a baseline condition, it will return baselineDirection instead, and when the type is an outlier condition, it will return expectedGroups. Here is an example response: { \"data\": { \"actor\": { \"account\": { \"alerts\": { \"nrqlConditionsSearch\": { \"nrqlConditions\": [ { \"baselineDirection\": \"UPPER_ONLY\", \"id\": \"342\", \"name\": \"My baseline condition\", \"type\": \"BASELINE\" }, { \"id\": \"553\", \"name\": \"My static condition\", \"type\": \"STATIC\", \"valueFunction\": \"SINGLE_VALUE\" }, { \"expectedGroups\": 4, \"id\": \"802\", \"name\": \"My outlier condition\", \"type\": \"OUTLIER\" } ] } } } } } } Copy Filter NRQL conditions You can filter NRQL conditions with the searchCriteria argument of the nrqlConditionsSearch query: Here's an example of filtering NRQL conditions with matching by name. This query returns NRQL conditions that match the provided name. Note that this match is case insensitive. { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch(searchCriteria: { name: \"Baseline Condition\" }) { nrqlConditions { id name type } } } } } } Copy Singular NRQL condition queries You can use the NRQL condition API to query for a singular condition. Run the nrqlCondition query in the alerts namespace. Similar to type specific fields on the nrqlConditionSearch query, you can also use these inline fragments to request fields that are restricted to a NRQL condition type. { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlCondition(id: YOUR_CONDITION_ID) { id name ...on AlertsNrqlStaticCondition { valueFunction } } } } } } Copy Update the description This will walk you through the procedure to create a description for a NRQL alert condition. Get all the conditions for a policy: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditions(policyId: YOUR_POLICY_ID) { nextCursor results { id name description enabled nrql { query } signal { aggregationWindow evaluationOffset } policyId runbookUrl terms { duration operator priority timeFunction threshold } type violationTimeLimitSeconds } } } } } } Copy Get the details for a single condition: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlCondition(id: \"YOUR_CONDITION_ID\") { description id enabled name nrql { query } signal { aggregationWindow evaluationOffset } policyId runbookUrl terms { operator priority threshold thresholdDuration thresholdOccurrences } type violationTimeLimitSeconds } } } } } Copy Create a mutation with the description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { description } } Copy Here's an example mutation with an included example description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tag.commandLine}} \\n entityGuid : {{tag.entityGuid}} \\n entityName : {{tag.entityName}} \\n fullHostname : {{tag.fullHostname}} \\n instanceType : {{tag.instanceType}} \\n processDisplayName : {{tag.processDisplayName}}\"}) { description } } Copy Delete conditions You can use the alertsConditionDelete mutation to delete any type of condition. You can only request the id field on a delete mutation; for example: mutation { alertsConditionDelete(accountId: YOUR_ACCOUNT_ID, id: YOUR_CONDITION_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 190.68335,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: NRQL condition <em>alerts</em>",
        "sections": "<em>NerdGraph</em> tutorial: NRQL condition <em>alerts</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "You can manage <em>alerts</em> conditions using our GraphQL <em>NerdGraph</em> API. Here are some conditions queries and mutations you can develop in our <em>NerdGraph</em> API explorer. Tip See the <em>NerdGraph</em> introduction for help getting started with <em>NerdGraph</em> API explorer. This document covers the following: Steps"
      },
      "id": "60440540196a678165960f6a"
    },
    {
      "sections": [
        "Intro to using Alerts via NerdGraph API",
        "Alerts features you can manage with NerdGraph",
        "NerdGraph API explorer",
        "Tip",
        "Queries",
        "Mutations"
      ],
      "title": "Intro to using Alerts via NerdGraph API",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alerts and Nerdgraph"
      ],
      "external_id": "62c3f9bdca2acc3e9257b07970a717ee2ab0548f",
      "image": "https://docs.newrelic.com/static/6551638ff382e1ef38324cd82dca1214/e2c15/alerts_query_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-examples/",
      "published_at": "2021-05-28T18:40:20Z",
      "updated_at": "2021-04-21T16:08:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can manage your policies, conditions, and muting rules programmatically using our GraphQL NerdGraph API. This is a powerful alternative to managing them in New Relic One or through the REST API. Alerts features you can manage with NerdGraph Here's what you can do in NerdGraph: Manage policies Use NRQL conditions Muting rules: suppress notifications The easiest way to discover alerts queries and mutations is through the NerdGraph API explorer. NerdGraph API explorer Our NerdGraph API explorer is a GraphiQL editor where you can prototype queries and mutations. Here are some examples showing how to find fields for queries and mutations. Tip For general information about NerdGraph, see Introduction to NerdGraph. Queries To explore the various queries, look for the available queries under the actor.account.alerts namespace in NerdGraph API explorer: Mutations To explore various mutations, look in the alerts dropdown in the NerdGraph API explorer:",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 190.67711,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to using <em>Alerts</em> via <em>NerdGraph</em> API",
        "sections": "Intro to using <em>Alerts</em> via <em>NerdGraph</em> API",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "You can manage your policies, conditions, and muting rules programmatically using our GraphQL <em>NerdGraph</em> API. This is a powerful alternative to managing them in <em>New</em> <em>Relic</em> One or through the REST API. <em>Alerts</em> features you can manage with <em>NerdGraph</em> Here&#x27;s what you can do in <em>NerdGraph</em>: Manage policies"
      },
      "id": "6043fe3864441f2dd2378ee8"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-examples": [
    {
      "sections": [
        "NerdGraph tutorial: Loss of signal and gap filling",
        "Tip",
        "Customize your loss of signal detection",
        "View loss of signal settings for an existing condition",
        "Create a new condition with loss of signal settings",
        "Update the loss of signal settings of a condition",
        "Customize gap filling",
        "Important"
      ],
      "title": "NerdGraph tutorial: Loss of signal and gap filling",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alerts and Nerdgraph"
      ],
      "external_id": "ff33c468e6df0d99acc13f7a8827da5bbf07d341",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-loss-signal-gap-filling/",
      "published_at": "2021-05-28T18:13:13Z",
      "updated_at": "2021-04-22T10:48:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Loss of signal occurs when New Relic stops receiving data for a while; technically, we detect loss of signal after a significant amount of time has elapsed since data was last received in a time series. Loss of signal can be used to trigger or resolve a violation, which you can use to set up alerts. Gap filling can help you solve issues caused by lost data points. When gaps are detected between valid data points, we automatically fill those gaps with replacement values, such as the last known values or a static value. Gap filling can prevent alerts from triggering or resolving when they shouldn't. Tip To learn more about signal loss, gap filling, and how to request access to these features, see this announcement. You can customize loss of signal detection and gap filling using NerdGraph. For example, you can configure how long to wait before considering the signal lost, or what value should be used for filling gaps in the time series. Here are some queries and examples you can use in our NerdGraph API explorer. In this guide we cover the following: Customize loss of signal detection Customize gap filling Customize your loss of signal detection Loss of signal detection opens or closes violations if no data is received after a certain amount of time. For example, if you set the duration of the expiration period to 60 seconds and an integration doesn't seem to send data for more than a minute, a loss of signal violation would be triggered. You can configure the duration of the signal loss and whether to open a violation or close it by using these three fields in NerdGraph: expiration.expirationDuration: How long to wait, in seconds, after the last data point is received by our platform before considering the signal as lost. This is based on the time when data arrives at our platform and not on data timestamps. The default is to leave this null, and therefore this wouldn't enable Loss of Signal Detection. expiration.openViolationOnExpiration: If true, a new violation is opened when a signal is lost. Default is false. To use this field, a duration must be specified. expiration.closeViolationsOnExpiration: If true, open violations related to the signal are closed on expiration. Default is false. To use this field, a duration must be specified. View loss of signal settings for an existing condition Existing NRQL conditions may have their loss of signal settings already configured. To view the existing condition settings, select the fields under nrqlCondition > expiration: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlCondition(id: NRQL_CONDITION_ID) { ... on AlertsNrqlStaticCondition { id name nrql { query } expiration { closeViolationsOnExpiration expirationDuration openViolationOnExpiration } } } } } } } Copy You should see a result like this: { \"data\": { \"actor\": { \"account\": { \"alerts\": { \"nrqlCondition\": { \"expiration\": { \" closeViolationsOnExpiration \": false, \" expirationDuration \": 300, \" openViolationOnExpiration \": true }, \"id\": \"YOUR_ACCOUNT_ID\", \"name\": \"Any less than - Extrapolation\", \"nrql\": { \"query\": \"SELECT average(value) FROM AlertsSmokeTestSignals WHERE wave_type IN ('min-max', 'single-gap') FACET wave_type\" } } } } } }, ... Copy Create a new condition with loss of signal settings Let's say that you want to create a new create a NRQL static condition that triggers a loss of signal violation after no data is received for two minutes. You would set expirationDuration to 120 seconds and set openViolationOnExpiration to true, like in the example below. mutation { alertsNrqlConditionStaticCreate( accountId: YOUR_ACCOUNT_ID policyId: YOUR_POLICY_ID condition: { name: \"Low Host Count - Catastrophic\" enabled: true nrql: { query: \"SELECT uniqueCount(host) from Transaction where appName='my-app-name'\" } signal { aggregationWindow: 60 evaluationOffset: 3 } terms: [{ threshold: 2 thresholdOccurrences: AT_LEAST_ONCE thresholdDuration: 600 operator: BELOW priority: CRITICAL }] valueFunction: SINGLE_VALUE violationTimeLimitSeconds: 86400 expiration : { expirationDuration : 120 openViolationOnExpiration : true } } ) { id name } } Copy Update the loss of signal settings of a condition What if you want to update loss of signal parameters for an alert condition? The following mutation allows you to update a NRQL static condition with new expiration values. mutation { alertsNrqlConditionStaticUpdate( accountId: YOUR_ACCOUNT_ID id: YOUR_STATIC_CONDITION_ID condition: { expiration: { closeViolationsOnExpiration : BOOLEAN expirationDuration : DURATION_IN_SECONDS openViolationOnExpiration : BOOLEAN } } ) { id expiration { closeViolationsOnExpiration expirationDuration openViolationOnExpiration } } } Copy Customize gap filling Gap filling replaces gap values in a time series with either the last value found or a static, arbitrary value of your choice. We fill gaps only after another data point has been received after the gaps in signal (after data reception has been restored). You can configure both the type of filling and the value, if the type is set to static: signal.fillOption: Type of replacement value for lost data points. Values can be: NONE: Gap filling is disabled. LAST_VALUE: The last value seen in the time series. STATIC: An arbitrary value, defined in fillValue. signal.fillValue: Value to use for replacing lost data points when fillOption is set to STATIC. Important Gap filling is also affected by expiration.expirationDuration. When a gap is longer than the expiration duration, the signal is considered expired and the gap will no longer be filled. For example, here's how to create a static NRQL condition with gap filling configured: mutation { alertsNrqlConditionStaticCreate( accountId: YOUR_ACCOUNT_ID policyId: YOUR_POLICY_ID condition: { enabled: true name: \"Example Gap Filling Condition\" nrql: { query: \"select count(*) from Transaction\" } terms: { operator: ABOVE priority: CRITICAL threshold: 1000 thresholdDuration: 300 thresholdOccurrences: ALL } valueFunction: SINGLE_VALUE violationTimeLimitSeconds: 28800 signal: { aggregationWindow: 60, evaluationOffset: 3, fillOption: STATIC, fillValue: 1 } } ) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 191.22678,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: Loss of signal <em>and</em> gap filling",
        "sections": "<em>NerdGraph</em> tutorial: Loss of signal <em>and</em> gap filling",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "Loss of signal occurs when <em>New</em> <em>Relic</em> stops receiving data for a while; technically, we detect loss of signal after a significant amount of time has elapsed since data was last received in a time series. Loss of signal can be used to trigger or resolve a violation, which you can use to set up <em>alerts</em>"
      },
      "id": "603f1f24196a67f381a83da8"
    },
    {
      "sections": [
        "NerdGraph tutorial: Alerts policies",
        "Tip",
        "List and filter policies",
        "Listing all policies for an account",
        "Paginating through policies with cursor pagination",
        "Find all policies by selected ids",
        "Find policy by id",
        "Create a policy",
        "Update a policy",
        "Delete a policy"
      ],
      "title": "NerdGraph tutorial: Alerts policies",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alerts and Nerdgraph"
      ],
      "external_id": "d97a35e39ebb43295a122ed4f89c8982606a73a5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-alerts-policies/",
      "published_at": "2021-05-28T18:40:20Z",
      "updated_at": "2021-04-22T10:47:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can manage your alerts policies using our GraphQL NerdGraph API. Here are some queries and mutations you can develop in our NerdGraph API explorer. Tip See the NerdGraph introduction for help getting started with NerdGraph API explorer. List and filter policies The policiesSearch query allows you to paginate through all of your policies per account. It also allows some filtering functionality on the account policies. Listing all policies for an account Here's an example: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { policiesSearch { policies { id name incidentPreference } } } } } } Copy Paginating through policies with cursor pagination In order to paginate through your policies, you must request the nextCursor field on your initial query. With cursor pagination, you continue to make a request through the result set until the nextCursor that is returned from the response comes back empty. This signifies that you reached the end of your results. Here's an example: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { policiesSearch { nextCursor policies { id name incidentPreference } totalCount } } } } } Copy The code above returns a set of results like this: { \"data\": { \"actor\": { \"account\": { \"alerts\": { \"policiesSearch\": { \"nextCursor\": \"/8o0y2qiR54m6thkdgHgwg==:jZTXDFKbTkhKwvMx+CtsPVM=\", \"policies\": [ { \"id\": \"3455\", \"incidentPreference\": \"PER_POLICY\", \"name\": \"First Policy Name\" }, { \"id\": \"2123\", \"incidentPreference\": \"PER_POLICY\", \"name\": \"Another Policy\" }, // ... more policies here in reality ], \"totalCount\": 745 } } } } } } Copy So, in your subsequent request, provide the cursor like so, until the cursor is empty: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { policiesSearch(cursor: \"/8o0y2qiR54m6thkdgHgwg==:jZTXDFKbTkhKwvMx+CtsPVM=\") { nextCursor policies { id name incidentPreference } totalCount } } } } } Copy Find all policies by selected ids The API allows policy queries by a sub-select of ids. This will only return the information for these policies that you provide. { actor { account(id: YOUR_ACCOUNT_ID) { alerts { policiesSearch(searchCriteria: { ids: [A_POLICY_ID, ANOTHER_POLICY_ID] }) { policies { id name incidentPreference } } } } } } Copy Find policy by id The API lets you query by policy id: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { policy(id: YOUR_POLICY_ID) { id name incidentPreference } } } } } Copy Create a policy In order to create a policy, supply a name and an incidentPreference. The incident preference will configure how incidents get created for each condition created in the policy. For more information, refer to the documentation about choosing your incident preference. mutation { alertsPolicyCreate(accountId: YOUR_ACCOUNT_ID, policy: { name: \"Your Policy Name\" incidentPreference: PER_CONDITION }) { id name incidentPreference } } Copy Update a policy When you update a policy, note that you don't need to supply all of the attributes on the policy. For example, you only need to supply the name if you only intend to update the name: mutation { alertsPolicyUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_POLICY_ID, policy: { name: \"Updated Policy Name\" }) { id name incidentPreference } } Copy Delete a policy You can delete policies via the NerdGraph API. Note that only the id may be requested back from a deleted resource: mutation { alertsPolicyDelete(accountId: YOUR_ACCOUNT_ID, id: YOUR_POLICY_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 191.22635,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: <em>Alerts</em> policies",
        "sections": "<em>NerdGraph</em> tutorial: <em>Alerts</em> policies",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "You can manage your <em>alerts</em> policies using our GraphQL <em>NerdGraph</em> API. Here are some queries and mutations you can develop in our <em>NerdGraph</em> API explorer. Tip See the <em>NerdGraph</em> introduction for help getting started with <em>NerdGraph</em> API explorer. List and filter policies The policiesSearch query allows"
      },
      "id": "6043fcb7196a678173960f21"
    },
    {
      "sections": [
        "NerdGraph tutorial: NRQL condition alerts",
        "Tip",
        "Steps to create a NRQL condition",
        "NRQL static condition",
        "NRQL baseline condition",
        "NRQL outlier condition",
        "Update a condition",
        "Update mutations",
        "List and filter NRQL conditions",
        "Use cursor pagination",
        "Request type-specific fields",
        "Filter NRQL conditions",
        "Singular NRQL condition queries",
        "Update the description",
        "Delete conditions"
      ],
      "title": "NerdGraph tutorial: NRQL condition alerts",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alerts and Nerdgraph"
      ],
      "external_id": "85399f92d659094c72d6565f258061a0161e751d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-nrql-condition-alerts/",
      "published_at": "2021-05-28T11:11:27Z",
      "updated_at": "2021-04-21T16:20:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can manage alerts conditions using our GraphQL NerdGraph API. Here are some conditions queries and mutations you can develop in our NerdGraph API explorer. Tip See the NerdGraph introduction for help getting started with NerdGraph API explorer. This document covers the following: Steps to create a NRQL condition NRQL static condition NRQL baseline condition NRQL outlier condition Update a condition Update mutations List and filter NRQL conditions Singular NRQL condition queries Create a description Delete conditions Steps to create a NRQL condition Follow these steps: Decide which condition type you want to create (see NRQL Condition threshold types). Find your relevant policyID by doing one of the following: Use the NerdGraph policies API. Go to one.newrelic.com, in the top nav click Alerts & AI, then click Policies. Choose a policy. Find the ID under the policy name. Provide the appropriate mutation for your NRQL condition type and the relevant values. Tip The NerdGraph GraphiQL explorer is the best place to find up-to-date documentation about the per-field specifics of the NerdGraph NRQL Conditions API. For example, questions like \"What does the valueFunction field accept?\" are best answered with the inline NerdGraph documentation. NRQL static condition Here's an example of creating a static condition: mutation { alertsNrqlConditionStaticCreate(accountId: YOUR_ACCOUNT_ID, policyId: YOUR_POLICY_ID, condition: { name: \"Low Host Count - Catastrophic\" enabled: true nrql: { query: \"SELECT uniqueCount(host) from Transaction where appName='my-app-name'\" } signal: { aggregationWindow: 60 evaluationOffset: 3 } terms: { threshold: 2 thresholdOccurrences: AT_LEAST_ONCE thresholdDuration: 600 operator: BELOW priority: CRITICAL } valueFunction: SINGLE_VALUE violationTimeLimitSeconds: 86400 }) { id name } } Copy NRQL baseline condition Here's an example of creating a baseline condition: mutation { alertsNrqlConditionBaselineCreate(accountId: YOUR_ACCOUNT_ID, policyId: YOUR_POLICY_ID, condition: { name: \"Baseline Condition\" enabled: true baselineDirection: UPPER_ONLY nrql: { query: \"SELECT average(duration) FROM Transaction\" } signal: { aggregationWindow: 60 evaluationOffset: 3 } terms: { threshold: 13 thresholdDuration: 180 thresholdOccurrences: ALL operator: ABOVE priority: CRITICAL } violationTimeLimitSeconds: 86400 }) { id name baselineDirection } } Copy NRQL outlier condition Here's an example of creating an outlier condition: mutation { alertsNrqlConditionOutlierCreate(accountId: YOUR_ACCOUNT_ID, policyId: YOUR_POLICY_ID, condition: { name: \"Outlier Condition\" enabled: true expectedGroups: 4 openViolationOnGroupOverlap: false nrql: { query: \"SELECT average(duration) FROM Transaction FACET httpResponseCode\" } signal: { aggregationWindow: 60 evaluationOffset: 3 } terms: { threshold: 1 thresholdDuration: 300 thresholdOccurrences: ALL operator: ABOVE priority: CRITICAL } violationTimeLimitSeconds: 86400 }) { id name expectedGroups openViolationOnGroupOverlap } } Copy Update a condition Complete the following: Determine the type of your existing condition by requesting the type field in a nrqlConditionsSearch query like this: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch { nrqlConditions { id type } } } } } } Copy Tip The type returned is what you use for your update mutation. For example, if the type returned is STATIC, use alertsNrqlConditionStaticUpdate. If the type returned is BASELINE, use alertsNrqlConditionBaselineUpdate. If the type returned is OUTLIER, use alertsNrqlConditionOutlierUpdate. Provide the id of your condition to your relevant condition type mutation. Note that you can only update conditions of the relevant type. Only provide update mutations for the fields you want to update. Fields you don't provide in the update are not touched. Update mutations Only fields that you provide in the update are changed. In the following example, baselineDirection returns unchanged, but name is updated. mutation { alertsNrqlConditionBaselineUpdate(id: YOUR_CONDITION_ID, accountId: YOUR_ACCOUNT_ID, condition: { name: \"Your updated name\" }) { id name baselineDirection } } Copy List and filter NRQL conditions To list or filter your NRQL conditions, use the nrqlConditionsSearch query in NerdGraph. Use cursor pagination The basic of list functionality for NRQL conditions allows you to paginate through your NRQL conditions as well as request the total count of conditions per account. The nrqlConditionsSearch query utilizes cursor pagination to paginate through resources. The idea behind cursor pagination is that the client will request a cursor in a programmatic loop until the cursor comes back empty. An initial list response will look something like this: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch { nextCursor nrqlConditions { id name type } totalCount } } } } } Copy This example returns a JSON response like this: { \"data\": { \"actor\": { \"account\": { \"alerts\": { \"nrqlConditionsSearch\": { \"nextCursor\": \"WOwfJ4+TWm9QTFeKMGyg+w==:QqkI8S4+Wwnpno6z+uk8kQ==\", \"nrqlConditions\": [ { \"id\": \"4432\", \"name\": \"Baseline Condition\", \"type\": \"BASELINE\" }, { \"id\": \"443\", \"name\": \"A static condition\", \"type\": \"STATIC\" }, // more conditions here in reality ], \"totalCount\": 435 } } } } }, } Copy In order to paginate through conditions in the response, have the client request the cursor to be returned until the nextCursor returns from the response as null: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch(cursor: \"WOwfJ4+TWm9QTFeKMGyg+w==:QqkI8S4+Wwnpno6z+uk8kQ==\", ) { nextCursor nrqlConditions { id name type } totalCount } } } } } Copy Request type-specific fields Certain fields are only available on specific NRQL condition types. The main reason that mutations are split between the different condition types is because they have minor differences between the fields they accept. For example, valueFunction is only relevant for static NRQL conditions and baselineDirection is only relevant on baseline NRQL conditions. But if these fields are only available on these certain condition types, how do we return them in a list of all of our condition types? The answer is a GraphQL convention known as inline fragments. Inline fragments allow you to access the data on a specific type of NRQL condition: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch { nrqlConditions { id name type ...on AlertsNrqlStaticCondition { valueFunction } ...on AlertsNrqlBaselineCondition { baselineDirection } ...on AlertsNrqlOutlierCondition { expectedGroups } } } } } } } Copy In the previous example query, we are asking GraphQL to do the hard work for us to determine which NRQL conditions are the correct type. So, when the returned type is a static condition, it will return the valueFunction in the object. When the returned type is a baseline condition, it will return baselineDirection instead, and when the type is an outlier condition, it will return expectedGroups. Here is an example response: { \"data\": { \"actor\": { \"account\": { \"alerts\": { \"nrqlConditionsSearch\": { \"nrqlConditions\": [ { \"baselineDirection\": \"UPPER_ONLY\", \"id\": \"342\", \"name\": \"My baseline condition\", \"type\": \"BASELINE\" }, { \"id\": \"553\", \"name\": \"My static condition\", \"type\": \"STATIC\", \"valueFunction\": \"SINGLE_VALUE\" }, { \"expectedGroups\": 4, \"id\": \"802\", \"name\": \"My outlier condition\", \"type\": \"OUTLIER\" } ] } } } } } } Copy Filter NRQL conditions You can filter NRQL conditions with the searchCriteria argument of the nrqlConditionsSearch query: Here's an example of filtering NRQL conditions with matching by name. This query returns NRQL conditions that match the provided name. Note that this match is case insensitive. { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch(searchCriteria: { name: \"Baseline Condition\" }) { nrqlConditions { id name type } } } } } } Copy Singular NRQL condition queries You can use the NRQL condition API to query for a singular condition. Run the nrqlCondition query in the alerts namespace. Similar to type specific fields on the nrqlConditionSearch query, you can also use these inline fragments to request fields that are restricted to a NRQL condition type. { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlCondition(id: YOUR_CONDITION_ID) { id name ...on AlertsNrqlStaticCondition { valueFunction } } } } } } Copy Update the description This will walk you through the procedure to create a description for a NRQL alert condition. Get all the conditions for a policy: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditions(policyId: YOUR_POLICY_ID) { nextCursor results { id name description enabled nrql { query } signal { aggregationWindow evaluationOffset } policyId runbookUrl terms { duration operator priority timeFunction threshold } type violationTimeLimitSeconds } } } } } } Copy Get the details for a single condition: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlCondition(id: \"YOUR_CONDITION_ID\") { description id enabled name nrql { query } signal { aggregationWindow evaluationOffset } policyId runbookUrl terms { operator priority threshold thresholdDuration thresholdOccurrences } type violationTimeLimitSeconds } } } } } Copy Create a mutation with the description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { description } } Copy Here's an example mutation with an included example description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tag.commandLine}} \\n entityGuid : {{tag.entityGuid}} \\n entityName : {{tag.entityName}} \\n fullHostname : {{tag.fullHostname}} \\n instanceType : {{tag.instanceType}} \\n processDisplayName : {{tag.processDisplayName}}\"}) { description } } Copy Delete conditions You can use the alertsConditionDelete mutation to delete any type of condition. You can only request the id field on a delete mutation; for example: mutation { alertsConditionDelete(accountId: YOUR_ACCOUNT_ID, id: YOUR_CONDITION_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 190.68335,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: NRQL condition <em>alerts</em>",
        "sections": "<em>NerdGraph</em> tutorial: NRQL condition <em>alerts</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "You can manage <em>alerts</em> conditions using our GraphQL <em>NerdGraph</em> API. Here are some conditions queries and mutations you can develop in our <em>NerdGraph</em> API explorer. Tip See the <em>NerdGraph</em> introduction for help getting started with <em>NerdGraph</em> API explorer. This document covers the following: Steps"
      },
      "id": "60440540196a678165960f6a"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-loss-signal-gap-filling": [
    {
      "sections": [
        "NerdGraph tutorial: Alerts policies",
        "Tip",
        "List and filter policies",
        "Listing all policies for an account",
        "Paginating through policies with cursor pagination",
        "Find all policies by selected ids",
        "Find policy by id",
        "Create a policy",
        "Update a policy",
        "Delete a policy"
      ],
      "title": "NerdGraph tutorial: Alerts policies",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alerts and Nerdgraph"
      ],
      "external_id": "d97a35e39ebb43295a122ed4f89c8982606a73a5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-alerts-policies/",
      "published_at": "2021-05-28T18:40:20Z",
      "updated_at": "2021-04-22T10:47:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can manage your alerts policies using our GraphQL NerdGraph API. Here are some queries and mutations you can develop in our NerdGraph API explorer. Tip See the NerdGraph introduction for help getting started with NerdGraph API explorer. List and filter policies The policiesSearch query allows you to paginate through all of your policies per account. It also allows some filtering functionality on the account policies. Listing all policies for an account Here's an example: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { policiesSearch { policies { id name incidentPreference } } } } } } Copy Paginating through policies with cursor pagination In order to paginate through your policies, you must request the nextCursor field on your initial query. With cursor pagination, you continue to make a request through the result set until the nextCursor that is returned from the response comes back empty. This signifies that you reached the end of your results. Here's an example: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { policiesSearch { nextCursor policies { id name incidentPreference } totalCount } } } } } Copy The code above returns a set of results like this: { \"data\": { \"actor\": { \"account\": { \"alerts\": { \"policiesSearch\": { \"nextCursor\": \"/8o0y2qiR54m6thkdgHgwg==:jZTXDFKbTkhKwvMx+CtsPVM=\", \"policies\": [ { \"id\": \"3455\", \"incidentPreference\": \"PER_POLICY\", \"name\": \"First Policy Name\" }, { \"id\": \"2123\", \"incidentPreference\": \"PER_POLICY\", \"name\": \"Another Policy\" }, // ... more policies here in reality ], \"totalCount\": 745 } } } } } } Copy So, in your subsequent request, provide the cursor like so, until the cursor is empty: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { policiesSearch(cursor: \"/8o0y2qiR54m6thkdgHgwg==:jZTXDFKbTkhKwvMx+CtsPVM=\") { nextCursor policies { id name incidentPreference } totalCount } } } } } Copy Find all policies by selected ids The API allows policy queries by a sub-select of ids. This will only return the information for these policies that you provide. { actor { account(id: YOUR_ACCOUNT_ID) { alerts { policiesSearch(searchCriteria: { ids: [A_POLICY_ID, ANOTHER_POLICY_ID] }) { policies { id name incidentPreference } } } } } } Copy Find policy by id The API lets you query by policy id: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { policy(id: YOUR_POLICY_ID) { id name incidentPreference } } } } } Copy Create a policy In order to create a policy, supply a name and an incidentPreference. The incident preference will configure how incidents get created for each condition created in the policy. For more information, refer to the documentation about choosing your incident preference. mutation { alertsPolicyCreate(accountId: YOUR_ACCOUNT_ID, policy: { name: \"Your Policy Name\" incidentPreference: PER_CONDITION }) { id name incidentPreference } } Copy Update a policy When you update a policy, note that you don't need to supply all of the attributes on the policy. For example, you only need to supply the name if you only intend to update the name: mutation { alertsPolicyUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_POLICY_ID, policy: { name: \"Updated Policy Name\" }) { id name incidentPreference } } Copy Delete a policy You can delete policies via the NerdGraph API. Note that only the id may be requested back from a deleted resource: mutation { alertsPolicyDelete(accountId: YOUR_ACCOUNT_ID, id: YOUR_POLICY_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 191.22633,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: <em>Alerts</em> policies",
        "sections": "<em>NerdGraph</em> tutorial: <em>Alerts</em> policies",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "You can manage your <em>alerts</em> policies using our GraphQL <em>NerdGraph</em> API. Here are some queries and mutations you can develop in our <em>NerdGraph</em> API explorer. Tip See the <em>NerdGraph</em> introduction for help getting started with <em>NerdGraph</em> API explorer. List and filter policies The policiesSearch query allows"
      },
      "id": "6043fcb7196a678173960f21"
    },
    {
      "sections": [
        "NerdGraph tutorial: NRQL condition alerts",
        "Tip",
        "Steps to create a NRQL condition",
        "NRQL static condition",
        "NRQL baseline condition",
        "NRQL outlier condition",
        "Update a condition",
        "Update mutations",
        "List and filter NRQL conditions",
        "Use cursor pagination",
        "Request type-specific fields",
        "Filter NRQL conditions",
        "Singular NRQL condition queries",
        "Update the description",
        "Delete conditions"
      ],
      "title": "NerdGraph tutorial: NRQL condition alerts",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alerts and Nerdgraph"
      ],
      "external_id": "85399f92d659094c72d6565f258061a0161e751d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-nrql-condition-alerts/",
      "published_at": "2021-05-28T11:11:27Z",
      "updated_at": "2021-04-21T16:20:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can manage alerts conditions using our GraphQL NerdGraph API. Here are some conditions queries and mutations you can develop in our NerdGraph API explorer. Tip See the NerdGraph introduction for help getting started with NerdGraph API explorer. This document covers the following: Steps to create a NRQL condition NRQL static condition NRQL baseline condition NRQL outlier condition Update a condition Update mutations List and filter NRQL conditions Singular NRQL condition queries Create a description Delete conditions Steps to create a NRQL condition Follow these steps: Decide which condition type you want to create (see NRQL Condition threshold types). Find your relevant policyID by doing one of the following: Use the NerdGraph policies API. Go to one.newrelic.com, in the top nav click Alerts & AI, then click Policies. Choose a policy. Find the ID under the policy name. Provide the appropriate mutation for your NRQL condition type and the relevant values. Tip The NerdGraph GraphiQL explorer is the best place to find up-to-date documentation about the per-field specifics of the NerdGraph NRQL Conditions API. For example, questions like \"What does the valueFunction field accept?\" are best answered with the inline NerdGraph documentation. NRQL static condition Here's an example of creating a static condition: mutation { alertsNrqlConditionStaticCreate(accountId: YOUR_ACCOUNT_ID, policyId: YOUR_POLICY_ID, condition: { name: \"Low Host Count - Catastrophic\" enabled: true nrql: { query: \"SELECT uniqueCount(host) from Transaction where appName='my-app-name'\" } signal: { aggregationWindow: 60 evaluationOffset: 3 } terms: { threshold: 2 thresholdOccurrences: AT_LEAST_ONCE thresholdDuration: 600 operator: BELOW priority: CRITICAL } valueFunction: SINGLE_VALUE violationTimeLimitSeconds: 86400 }) { id name } } Copy NRQL baseline condition Here's an example of creating a baseline condition: mutation { alertsNrqlConditionBaselineCreate(accountId: YOUR_ACCOUNT_ID, policyId: YOUR_POLICY_ID, condition: { name: \"Baseline Condition\" enabled: true baselineDirection: UPPER_ONLY nrql: { query: \"SELECT average(duration) FROM Transaction\" } signal: { aggregationWindow: 60 evaluationOffset: 3 } terms: { threshold: 13 thresholdDuration: 180 thresholdOccurrences: ALL operator: ABOVE priority: CRITICAL } violationTimeLimitSeconds: 86400 }) { id name baselineDirection } } Copy NRQL outlier condition Here's an example of creating an outlier condition: mutation { alertsNrqlConditionOutlierCreate(accountId: YOUR_ACCOUNT_ID, policyId: YOUR_POLICY_ID, condition: { name: \"Outlier Condition\" enabled: true expectedGroups: 4 openViolationOnGroupOverlap: false nrql: { query: \"SELECT average(duration) FROM Transaction FACET httpResponseCode\" } signal: { aggregationWindow: 60 evaluationOffset: 3 } terms: { threshold: 1 thresholdDuration: 300 thresholdOccurrences: ALL operator: ABOVE priority: CRITICAL } violationTimeLimitSeconds: 86400 }) { id name expectedGroups openViolationOnGroupOverlap } } Copy Update a condition Complete the following: Determine the type of your existing condition by requesting the type field in a nrqlConditionsSearch query like this: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch { nrqlConditions { id type } } } } } } Copy Tip The type returned is what you use for your update mutation. For example, if the type returned is STATIC, use alertsNrqlConditionStaticUpdate. If the type returned is BASELINE, use alertsNrqlConditionBaselineUpdate. If the type returned is OUTLIER, use alertsNrqlConditionOutlierUpdate. Provide the id of your condition to your relevant condition type mutation. Note that you can only update conditions of the relevant type. Only provide update mutations for the fields you want to update. Fields you don't provide in the update are not touched. Update mutations Only fields that you provide in the update are changed. In the following example, baselineDirection returns unchanged, but name is updated. mutation { alertsNrqlConditionBaselineUpdate(id: YOUR_CONDITION_ID, accountId: YOUR_ACCOUNT_ID, condition: { name: \"Your updated name\" }) { id name baselineDirection } } Copy List and filter NRQL conditions To list or filter your NRQL conditions, use the nrqlConditionsSearch query in NerdGraph. Use cursor pagination The basic of list functionality for NRQL conditions allows you to paginate through your NRQL conditions as well as request the total count of conditions per account. The nrqlConditionsSearch query utilizes cursor pagination to paginate through resources. The idea behind cursor pagination is that the client will request a cursor in a programmatic loop until the cursor comes back empty. An initial list response will look something like this: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch { nextCursor nrqlConditions { id name type } totalCount } } } } } Copy This example returns a JSON response like this: { \"data\": { \"actor\": { \"account\": { \"alerts\": { \"nrqlConditionsSearch\": { \"nextCursor\": \"WOwfJ4+TWm9QTFeKMGyg+w==:QqkI8S4+Wwnpno6z+uk8kQ==\", \"nrqlConditions\": [ { \"id\": \"4432\", \"name\": \"Baseline Condition\", \"type\": \"BASELINE\" }, { \"id\": \"443\", \"name\": \"A static condition\", \"type\": \"STATIC\" }, // more conditions here in reality ], \"totalCount\": 435 } } } } }, } Copy In order to paginate through conditions in the response, have the client request the cursor to be returned until the nextCursor returns from the response as null: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch(cursor: \"WOwfJ4+TWm9QTFeKMGyg+w==:QqkI8S4+Wwnpno6z+uk8kQ==\", ) { nextCursor nrqlConditions { id name type } totalCount } } } } } Copy Request type-specific fields Certain fields are only available on specific NRQL condition types. The main reason that mutations are split between the different condition types is because they have minor differences between the fields they accept. For example, valueFunction is only relevant for static NRQL conditions and baselineDirection is only relevant on baseline NRQL conditions. But if these fields are only available on these certain condition types, how do we return them in a list of all of our condition types? The answer is a GraphQL convention known as inline fragments. Inline fragments allow you to access the data on a specific type of NRQL condition: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch { nrqlConditions { id name type ...on AlertsNrqlStaticCondition { valueFunction } ...on AlertsNrqlBaselineCondition { baselineDirection } ...on AlertsNrqlOutlierCondition { expectedGroups } } } } } } } Copy In the previous example query, we are asking GraphQL to do the hard work for us to determine which NRQL conditions are the correct type. So, when the returned type is a static condition, it will return the valueFunction in the object. When the returned type is a baseline condition, it will return baselineDirection instead, and when the type is an outlier condition, it will return expectedGroups. Here is an example response: { \"data\": { \"actor\": { \"account\": { \"alerts\": { \"nrqlConditionsSearch\": { \"nrqlConditions\": [ { \"baselineDirection\": \"UPPER_ONLY\", \"id\": \"342\", \"name\": \"My baseline condition\", \"type\": \"BASELINE\" }, { \"id\": \"553\", \"name\": \"My static condition\", \"type\": \"STATIC\", \"valueFunction\": \"SINGLE_VALUE\" }, { \"expectedGroups\": 4, \"id\": \"802\", \"name\": \"My outlier condition\", \"type\": \"OUTLIER\" } ] } } } } } } Copy Filter NRQL conditions You can filter NRQL conditions with the searchCriteria argument of the nrqlConditionsSearch query: Here's an example of filtering NRQL conditions with matching by name. This query returns NRQL conditions that match the provided name. Note that this match is case insensitive. { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditionsSearch(searchCriteria: { name: \"Baseline Condition\" }) { nrqlConditions { id name type } } } } } } Copy Singular NRQL condition queries You can use the NRQL condition API to query for a singular condition. Run the nrqlCondition query in the alerts namespace. Similar to type specific fields on the nrqlConditionSearch query, you can also use these inline fragments to request fields that are restricted to a NRQL condition type. { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlCondition(id: YOUR_CONDITION_ID) { id name ...on AlertsNrqlStaticCondition { valueFunction } } } } } } Copy Update the description This will walk you through the procedure to create a description for a NRQL alert condition. Get all the conditions for a policy: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlConditions(policyId: YOUR_POLICY_ID) { nextCursor results { id name description enabled nrql { query } signal { aggregationWindow evaluationOffset } policyId runbookUrl terms { duration operator priority timeFunction threshold } type violationTimeLimitSeconds } } } } } } Copy Get the details for a single condition: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlCondition(id: \"YOUR_CONDITION_ID\") { description id enabled name nrql { query } signal { aggregationWindow evaluationOffset } policyId runbookUrl terms { operator priority threshold thresholdDuration thresholdOccurrences } type violationTimeLimitSeconds } } } } } Copy Create a mutation with the description. Here's an empty mutation template: mutation { alertsNrqlConditionStaticUpdate(accountId: YOUR_ACCOUNT_ID, id: \"YOUR_CONDITION_ID\", condition: {description: \"\"}) { description } } Copy Here's an example mutation with an included example description: mutation { alertsNrqlConditionStaticUpdate(accountId: 123456, id: \"123456\", condition: {description: \"timestamp : {{timestamp}} \\n accountId : {{accountId}} \\n type : {{type}} \\n event : {{event}} \\n description : {{description}} \\n policyId : {{policyId}} \\n policyName: {{policyName}} \\n conditionName : {{conditionName}} \\n conditionId : {{conditionId}} \\n product : {{product}} \\n conditionType : {{conditionType}} \\n RunbookUrl : {{runbookUrl}} \\n nrqlQuery : {{nrqlQuery}} \\n nrqlEventType : {{nrqlEventType}} \\n targetID : {{targetId}} \\n targetName : {{targetName}} \\n commandLine : {{tag.commandLine}} \\n entityGuid : {{tag.entityGuid}} \\n entityName : {{tag.entityName}} \\n fullHostname : {{tag.fullHostname}} \\n instanceType : {{tag.instanceType}} \\n processDisplayName : {{tag.processDisplayName}}\"}) { description } } Copy Delete conditions You can use the alertsConditionDelete mutation to delete any type of condition. You can only request the id field on a delete mutation; for example: mutation { alertsConditionDelete(accountId: YOUR_ACCOUNT_ID, id: YOUR_CONDITION_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 190.68335,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: NRQL condition <em>alerts</em>",
        "sections": "<em>NerdGraph</em> tutorial: NRQL condition <em>alerts</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "You can manage <em>alerts</em> conditions using our GraphQL <em>NerdGraph</em> API. Here are some conditions queries and mutations you can develop in our <em>NerdGraph</em> API explorer. Tip See the <em>NerdGraph</em> introduction for help getting started with <em>NerdGraph</em> API explorer. This document covers the following: Steps"
      },
      "id": "60440540196a678165960f6a"
    },
    {
      "sections": [
        "Intro to using Alerts via NerdGraph API",
        "Alerts features you can manage with NerdGraph",
        "NerdGraph API explorer",
        "Tip",
        "Queries",
        "Mutations"
      ],
      "title": "Intro to using Alerts via NerdGraph API",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alerts and Nerdgraph"
      ],
      "external_id": "62c3f9bdca2acc3e9257b07970a717ee2ab0548f",
      "image": "https://docs.newrelic.com/static/6551638ff382e1ef38324cd82dca1214/e2c15/alerts_query_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-examples/",
      "published_at": "2021-05-28T18:40:20Z",
      "updated_at": "2021-04-21T16:08:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can manage your policies, conditions, and muting rules programmatically using our GraphQL NerdGraph API. This is a powerful alternative to managing them in New Relic One or through the REST API. Alerts features you can manage with NerdGraph Here's what you can do in NerdGraph: Manage policies Use NRQL conditions Muting rules: suppress notifications The easiest way to discover alerts queries and mutations is through the NerdGraph API explorer. NerdGraph API explorer Our NerdGraph API explorer is a GraphiQL editor where you can prototype queries and mutations. Here are some examples showing how to find fields for queries and mutations. Tip For general information about NerdGraph, see Introduction to NerdGraph. Queries To explore the various queries, look for the available queries under the actor.account.alerts namespace in NerdGraph API explorer: Mutations To explore various mutations, look in the alerts dropdown in the NerdGraph API explorer:",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 190.6771,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to using <em>Alerts</em> via <em>NerdGraph</em> API",
        "sections": "Intro to using <em>Alerts</em> via <em>NerdGraph</em> API",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "You can manage your policies, conditions, and muting rules programmatically using our GraphQL <em>NerdGraph</em> API. This is a powerful alternative to managing them in <em>New</em> <em>Relic</em> One or through the REST API. <em>Alerts</em> features you can manage with <em>NerdGraph</em> Here&#x27;s what you can do in <em>NerdGraph</em>: Manage policies"
      },
      "id": "6043fe3864441f2dd2378ee8"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-nrql-condition-alerts": [
    {
      "sections": [
        "NerdGraph tutorial: Loss of signal and gap filling",
        "Tip",
        "Customize your loss of signal detection",
        "View loss of signal settings for an existing condition",
        "Create a new condition with loss of signal settings",
        "Update the loss of signal settings of a condition",
        "Customize gap filling",
        "Important"
      ],
      "title": "NerdGraph tutorial: Loss of signal and gap filling",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alerts and Nerdgraph"
      ],
      "external_id": "ff33c468e6df0d99acc13f7a8827da5bbf07d341",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-loss-signal-gap-filling/",
      "published_at": "2021-05-28T18:13:13Z",
      "updated_at": "2021-04-22T10:48:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Loss of signal occurs when New Relic stops receiving data for a while; technically, we detect loss of signal after a significant amount of time has elapsed since data was last received in a time series. Loss of signal can be used to trigger or resolve a violation, which you can use to set up alerts. Gap filling can help you solve issues caused by lost data points. When gaps are detected between valid data points, we automatically fill those gaps with replacement values, such as the last known values or a static value. Gap filling can prevent alerts from triggering or resolving when they shouldn't. Tip To learn more about signal loss, gap filling, and how to request access to these features, see this announcement. You can customize loss of signal detection and gap filling using NerdGraph. For example, you can configure how long to wait before considering the signal lost, or what value should be used for filling gaps in the time series. Here are some queries and examples you can use in our NerdGraph API explorer. In this guide we cover the following: Customize loss of signal detection Customize gap filling Customize your loss of signal detection Loss of signal detection opens or closes violations if no data is received after a certain amount of time. For example, if you set the duration of the expiration period to 60 seconds and an integration doesn't seem to send data for more than a minute, a loss of signal violation would be triggered. You can configure the duration of the signal loss and whether to open a violation or close it by using these three fields in NerdGraph: expiration.expirationDuration: How long to wait, in seconds, after the last data point is received by our platform before considering the signal as lost. This is based on the time when data arrives at our platform and not on data timestamps. The default is to leave this null, and therefore this wouldn't enable Loss of Signal Detection. expiration.openViolationOnExpiration: If true, a new violation is opened when a signal is lost. Default is false. To use this field, a duration must be specified. expiration.closeViolationsOnExpiration: If true, open violations related to the signal are closed on expiration. Default is false. To use this field, a duration must be specified. View loss of signal settings for an existing condition Existing NRQL conditions may have their loss of signal settings already configured. To view the existing condition settings, select the fields under nrqlCondition > expiration: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { nrqlCondition(id: NRQL_CONDITION_ID) { ... on AlertsNrqlStaticCondition { id name nrql { query } expiration { closeViolationsOnExpiration expirationDuration openViolationOnExpiration } } } } } } } Copy You should see a result like this: { \"data\": { \"actor\": { \"account\": { \"alerts\": { \"nrqlCondition\": { \"expiration\": { \" closeViolationsOnExpiration \": false, \" expirationDuration \": 300, \" openViolationOnExpiration \": true }, \"id\": \"YOUR_ACCOUNT_ID\", \"name\": \"Any less than - Extrapolation\", \"nrql\": { \"query\": \"SELECT average(value) FROM AlertsSmokeTestSignals WHERE wave_type IN ('min-max', 'single-gap') FACET wave_type\" } } } } } }, ... Copy Create a new condition with loss of signal settings Let's say that you want to create a new create a NRQL static condition that triggers a loss of signal violation after no data is received for two minutes. You would set expirationDuration to 120 seconds and set openViolationOnExpiration to true, like in the example below. mutation { alertsNrqlConditionStaticCreate( accountId: YOUR_ACCOUNT_ID policyId: YOUR_POLICY_ID condition: { name: \"Low Host Count - Catastrophic\" enabled: true nrql: { query: \"SELECT uniqueCount(host) from Transaction where appName='my-app-name'\" } signal { aggregationWindow: 60 evaluationOffset: 3 } terms: [{ threshold: 2 thresholdOccurrences: AT_LEAST_ONCE thresholdDuration: 600 operator: BELOW priority: CRITICAL }] valueFunction: SINGLE_VALUE violationTimeLimitSeconds: 86400 expiration : { expirationDuration : 120 openViolationOnExpiration : true } } ) { id name } } Copy Update the loss of signal settings of a condition What if you want to update loss of signal parameters for an alert condition? The following mutation allows you to update a NRQL static condition with new expiration values. mutation { alertsNrqlConditionStaticUpdate( accountId: YOUR_ACCOUNT_ID id: YOUR_STATIC_CONDITION_ID condition: { expiration: { closeViolationsOnExpiration : BOOLEAN expirationDuration : DURATION_IN_SECONDS openViolationOnExpiration : BOOLEAN } } ) { id expiration { closeViolationsOnExpiration expirationDuration openViolationOnExpiration } } } Copy Customize gap filling Gap filling replaces gap values in a time series with either the last value found or a static, arbitrary value of your choice. We fill gaps only after another data point has been received after the gaps in signal (after data reception has been restored). You can configure both the type of filling and the value, if the type is set to static: signal.fillOption: Type of replacement value for lost data points. Values can be: NONE: Gap filling is disabled. LAST_VALUE: The last value seen in the time series. STATIC: An arbitrary value, defined in fillValue. signal.fillValue: Value to use for replacing lost data points when fillOption is set to STATIC. Important Gap filling is also affected by expiration.expirationDuration. When a gap is longer than the expiration duration, the signal is considered expired and the gap will no longer be filled. For example, here's how to create a static NRQL condition with gap filling configured: mutation { alertsNrqlConditionStaticCreate( accountId: YOUR_ACCOUNT_ID policyId: YOUR_POLICY_ID condition: { enabled: true name: \"Example Gap Filling Condition\" nrql: { query: \"select count(*) from Transaction\" } terms: { operator: ABOVE priority: CRITICAL threshold: 1000 thresholdDuration: 300 thresholdOccurrences: ALL } valueFunction: SINGLE_VALUE violationTimeLimitSeconds: 28800 signal: { aggregationWindow: 60, evaluationOffset: 3, fillOption: STATIC, fillValue: 1 } } ) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 191.22678,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: Loss of signal <em>and</em> gap filling",
        "sections": "<em>NerdGraph</em> tutorial: Loss of signal <em>and</em> gap filling",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "Loss of signal occurs when <em>New</em> <em>Relic</em> stops receiving data for a while; technically, we detect loss of signal after a significant amount of time has elapsed since data was last received in a time series. Loss of signal can be used to trigger or resolve a violation, which you can use to set up <em>alerts</em>"
      },
      "id": "603f1f24196a67f381a83da8"
    },
    {
      "sections": [
        "NerdGraph tutorial: Alerts policies",
        "Tip",
        "List and filter policies",
        "Listing all policies for an account",
        "Paginating through policies with cursor pagination",
        "Find all policies by selected ids",
        "Find policy by id",
        "Create a policy",
        "Update a policy",
        "Delete a policy"
      ],
      "title": "NerdGraph tutorial: Alerts policies",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alerts and Nerdgraph"
      ],
      "external_id": "d97a35e39ebb43295a122ed4f89c8982606a73a5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-alerts-policies/",
      "published_at": "2021-05-28T18:40:20Z",
      "updated_at": "2021-04-22T10:47:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can manage your alerts policies using our GraphQL NerdGraph API. Here are some queries and mutations you can develop in our NerdGraph API explorer. Tip See the NerdGraph introduction for help getting started with NerdGraph API explorer. List and filter policies The policiesSearch query allows you to paginate through all of your policies per account. It also allows some filtering functionality on the account policies. Listing all policies for an account Here's an example: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { policiesSearch { policies { id name incidentPreference } } } } } } Copy Paginating through policies with cursor pagination In order to paginate through your policies, you must request the nextCursor field on your initial query. With cursor pagination, you continue to make a request through the result set until the nextCursor that is returned from the response comes back empty. This signifies that you reached the end of your results. Here's an example: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { policiesSearch { nextCursor policies { id name incidentPreference } totalCount } } } } } Copy The code above returns a set of results like this: { \"data\": { \"actor\": { \"account\": { \"alerts\": { \"policiesSearch\": { \"nextCursor\": \"/8o0y2qiR54m6thkdgHgwg==:jZTXDFKbTkhKwvMx+CtsPVM=\", \"policies\": [ { \"id\": \"3455\", \"incidentPreference\": \"PER_POLICY\", \"name\": \"First Policy Name\" }, { \"id\": \"2123\", \"incidentPreference\": \"PER_POLICY\", \"name\": \"Another Policy\" }, // ... more policies here in reality ], \"totalCount\": 745 } } } } } } Copy So, in your subsequent request, provide the cursor like so, until the cursor is empty: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { policiesSearch(cursor: \"/8o0y2qiR54m6thkdgHgwg==:jZTXDFKbTkhKwvMx+CtsPVM=\") { nextCursor policies { id name incidentPreference } totalCount } } } } } Copy Find all policies by selected ids The API allows policy queries by a sub-select of ids. This will only return the information for these policies that you provide. { actor { account(id: YOUR_ACCOUNT_ID) { alerts { policiesSearch(searchCriteria: { ids: [A_POLICY_ID, ANOTHER_POLICY_ID] }) { policies { id name incidentPreference } } } } } } Copy Find policy by id The API lets you query by policy id: { actor { account(id: YOUR_ACCOUNT_ID) { alerts { policy(id: YOUR_POLICY_ID) { id name incidentPreference } } } } } Copy Create a policy In order to create a policy, supply a name and an incidentPreference. The incident preference will configure how incidents get created for each condition created in the policy. For more information, refer to the documentation about choosing your incident preference. mutation { alertsPolicyCreate(accountId: YOUR_ACCOUNT_ID, policy: { name: \"Your Policy Name\" incidentPreference: PER_CONDITION }) { id name incidentPreference } } Copy Update a policy When you update a policy, note that you don't need to supply all of the attributes on the policy. For example, you only need to supply the name if you only intend to update the name: mutation { alertsPolicyUpdate(accountId: YOUR_ACCOUNT_ID, id: YOUR_POLICY_ID, policy: { name: \"Updated Policy Name\" }) { id name incidentPreference } } Copy Delete a policy You can delete policies via the NerdGraph API. Note that only the id may be requested back from a deleted resource: mutation { alertsPolicyDelete(accountId: YOUR_ACCOUNT_ID, id: YOUR_POLICY_ID) { id } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 191.22633,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>NerdGraph</em> tutorial: <em>Alerts</em> policies",
        "sections": "<em>NerdGraph</em> tutorial: <em>Alerts</em> policies",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "You can manage your <em>alerts</em> policies using our GraphQL <em>NerdGraph</em> API. Here are some queries and mutations you can develop in our <em>NerdGraph</em> API explorer. Tip See the <em>NerdGraph</em> introduction for help getting started with <em>NerdGraph</em> API explorer. List and filter policies The policiesSearch query allows"
      },
      "id": "6043fcb7196a678173960f21"
    },
    {
      "sections": [
        "Intro to using Alerts via NerdGraph API",
        "Alerts features you can manage with NerdGraph",
        "NerdGraph API explorer",
        "Tip",
        "Queries",
        "Mutations"
      ],
      "title": "Intro to using Alerts via NerdGraph API",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alerts and Nerdgraph"
      ],
      "external_id": "62c3f9bdca2acc3e9257b07970a717ee2ab0548f",
      "image": "https://docs.newrelic.com/static/6551638ff382e1ef38324cd82dca1214/e2c15/alerts_query_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-examples/",
      "published_at": "2021-05-28T18:40:20Z",
      "updated_at": "2021-04-21T16:08:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can manage your policies, conditions, and muting rules programmatically using our GraphQL NerdGraph API. This is a powerful alternative to managing them in New Relic One or through the REST API. Alerts features you can manage with NerdGraph Here's what you can do in NerdGraph: Manage policies Use NRQL conditions Muting rules: suppress notifications The easiest way to discover alerts queries and mutations is through the NerdGraph API explorer. NerdGraph API explorer Our NerdGraph API explorer is a GraphiQL editor where you can prototype queries and mutations. Here are some examples showing how to find fields for queries and mutations. Tip For general information about NerdGraph, see Introduction to NerdGraph. Queries To explore the various queries, look for the available queries under the actor.account.alerts namespace in NerdGraph API explorer: Mutations To explore various mutations, look in the alerts dropdown in the NerdGraph API explorer:",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 190.6771,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to using <em>Alerts</em> via <em>NerdGraph</em> API",
        "sections": "Intro to using <em>Alerts</em> via <em>NerdGraph</em> API",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "You can manage your policies, conditions, and muting rules programmatically using our GraphQL <em>NerdGraph</em> API. This is a powerful alternative to managing them in <em>New</em> <em>Relic</em> One or through the REST API. <em>Alerts</em> features you can manage with <em>NerdGraph</em> Here&#x27;s what you can do in <em>NerdGraph</em>: Manage policies"
      },
      "id": "6043fe3864441f2dd2378ee8"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/get-started/alerts-ai-overview-page": [
    {
      "sections": [
        "Expanded anomaly detection",
        "Requirements",
        "Why it matters",
        "Get started with anomaly detection",
        "Detect anomalies with a faceted NRQL query",
        "See your anomalies in one place",
        "Tip",
        "Query anomaly data",
        "Reduce the number of detected anomalies"
      ],
      "title": "Expanded anomaly detection",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Proactive detection"
      ],
      "external_id": "0b07c0b6ce27f39b5edb3e112a0f949835cbb8c6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/proactive-detection/expanded-anomaly-detection/",
      "published_at": "2021-06-02T18:27:12Z",
      "updated_at": "2021-05-31T16:43:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We’ve expanded anomaly detection coverage beyond your APM applications. Configure anomaly detection for your browser applications, mobile applications, infrastructure hosts, and nearly anything you want to monitor. Requirements Expanded anomaly detection is available as a limited beta. You can request access here. Why it matters When starting to configure alert conditions for a variety of applications and hosts, it can be difficult to know what you’ll want to be notified about ahead of time. Anomaly detection helps you distinguish between what’s typical performance in your system and where you’re starting to have trouble. Instead of creating your alert conditions manually, you can simply tell us what you want to monitor. Anomaly detection will help you identify baseline performance in your system and flags anomalous activity in your system. Get started with anomaly detection To get started with expanded anomaly detection: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Select the account you want to use to record anomaly data, then select the workload or entities you’d like to monitor. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name your configuration and save. Detect anomalies with a faceted NRQL query To detect anomalies with a faceted NRQL query: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Click Use a query instead. You may need to select an account, if you have more than one. Add one or more queries with a FACET clause. Name the query and confirm the facets you want to monitor for anomalies. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name the configuration and save. See your anomalies in one place When you set up anomaly detection, New Relic starts analyzing the golden signals of your entities and workloads. Anomalies appear in your activity feeds throughout New Relic One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL alert condition for the NrAiAnomaly event. To view anomalies, from one.newrelic.com, go to Alerts & AI > Issues & activity > Anomalies. Query anomaly data Detected anomalies are written to the NrAiAnomaly event in your NRDB account. You can learn more about this event and how to query it here. Reduce the number of detected anomalies If you’re seeing too many anomalies, the first step is to make sure your sensitivity level is set to Low. If it’s already set to Low, you can define specific thresholds to distinguish between normal and anomalous behavior. To define custom thresholds: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab and the configuration you want to modify. Select an entity or workload, and then change the sensitivity level. You can use custom sensitivity to define specific thresholds for different entity types.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 188.82616,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Get</em> <em>started</em> with anomaly detection",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " feeds throughout <em>New</em> <em>Relic</em> One and the Anomalies tab as soon as they’re detected. Click any anomaly to <em>get</em> more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL <em>alert</em>"
      },
      "id": "60b5124064441ff965e2cb01"
    },
    {
      "sections": [
        "Incident Intelligence destination examples",
        "Destination template examples",
        "Suggested OpsGenie template example",
        "Suggested ServiceNow template example",
        "Suggested Slack template example",
        "Suggested VictorOps template example",
        "Webhook and JSON format examples",
        "Webhook format and JSON example",
        "Jinja2 Default Payload",
        "Jinja2 Useful Syntax",
        "JSON schema",
        "JSON schema template"
      ],
      "title": "Incident Intelligence destination examples",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "a516d04f8b75541a6dc9338fa3ce9645ba87d620",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/incident-intelligence-destination-examples/",
      "published_at": "2021-06-02T18:22:22Z",
      "updated_at": "2021-06-02T18:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Destinations are the data outputs to Applied Intelligence, where you can view your automatically correlated incidents. You can configure Incident Intelligence destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema. Destination template examples The following template example destinations are formatted in Jinja2. Suggested OpsGenie template example { \"alias\": {{ id }}, \"message\": {{ ui_name }}, \"source\": '{{ sources }}', \"priority\": {{ priority }}, \"details\": { \"self_url\": {{ url }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"is_correlated\": {{ is_correlated }} }, \"description\": \"\"\"Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]\"\"\" } Copy Suggested ServiceNow template example { \"short_description\": {{ ui_name }}, \"description\": 'Issue Id: {{ id }}, \\n Description: {{ description }}, \\n Sources: {{ sources }}, \\n Priority: {{ priority }}, \\n Details: { \\n self_url: {{ url }}, \\n state: {{ state }}, \\n is_correlated: {{ is_correlated }}, \\n created_on: {{ created_on }}, \\n modified_on: {{ modified_on }}, \\n activated_on: {{ active_since }}, \\n closed_on: {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \\n is_correlated: {{is_correlated}} }, \\n\\n incidents: {{ incidents }}, \\n\\n pathways: {{ pathways }}' } Copy Suggested Slack template example Go to Slack incoming WebHooks Choose the right Slack workspace and click \"Add to Slack\" Select the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In New Relic Applied Intelligence, under Incident Intelligence click Destinations Add a WebHook In the end point paste the WebHook url from slack. In the custom payload, paste the following JSON: { \"blocks\": [ { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*New Relic Incident Intelligence Alert*\" } }, { \"type\": \"divider\" }, { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*CUSTOM FIELDS*:\" }, \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue ID*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Issue Title*\" }, { \"type\": \"plain_text\", \"text\": {{ id }} }, { \"type\": \"plain_text\", \"text\": {{ ui_name }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue URL*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Description*\" }, { \"type\": \"mrkdwn\", \"text\": {{ url }} }, { \"type\": \"plain_text\", \"text\": {{ description }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*State*\" }, { \"type\": \"mrkdwn\", \"text\": \"*is_correlated*\" }, { \"type\": \"plain_text\", \"text\": {{ state }} }, { \"type\": \"plain_text\", \"text\": \"{{ is_correlated }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Created On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Modified On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ created_on }}\" }, { \"type\": \"plain_text\", \"text\": \"{{ modified_on }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Activated On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Closed On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ active_since }}\" }, { \"type\": \"plain_text\", \"text\": \"{% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Aggregated Incidents*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Monitoring Tool*\" }, { \"type\": \"plain_text\", \"text\": \"{{ incident_count }}\" }, { \"type\": \"plain_text\", \"text\": {{ sources|join(', ') }} } ] } ] } Copy Suggested VictorOps template example { \"monitoring_tool\": {{ sources }}, {% if state == 'closed' %} \"message_type\": \"OK\", {% else %} \"message_type\": {{ priority }}, {% endif %} \"custom_fields\": { \"issue_url\": {{ url }}, \"description\": {{ description }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"related_incidents\": [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %} {% endfor %} ] }, \"state_message\": {{ description }}, \"entity_id\": {{ id }}, \"entity_display_name\": {{ ui_name }}, \"vo_annotate.u.NRAI_Link\": {{ url }} } Copy Webhook and JSON format examples Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). If you use webhooks to configure Incident Intelligence destinations, use these examples of the webhook body format and JSON schema. Webhook format and JSON example Webhook format: Name Description url Href A link to the UI where the issue can be seen. id String Unique identifier for the issue. title String The issue title. description String The description of the issue. priority Enum The issue priority. Can be Critical, High, Medium, or Low. state Enum The issue status. Can be Active, Closed, or Acknowledged. is_correlated Boolean True if the issue is based on correlated data. created_on String The date and time the issue was created (in ISO format). modified_on String The date and time the issue was modified (in ISO format). active_since String The date and time the issue was activated (in ISO format). closed_on String The date and time the issue was closed (in ISO format). sources List(String) List of the different sources that were used to send the events into Applied Intelligence (for example: PagerDuty). pathways List(Pathways) List of pathways that are associated with the issue. Each pathway contains an id and name: [{“id”: “pathway id”, “name”: “pathway name”}]. pathways[].id String The pathway ID. pathways[].name String The pathway name. incidents List(Incident) List of incidents that are attached to the issue. The list contains only the latest 100 incidents. incidents[].id String The incident ID. incidents[].events_count Integer The number of events used to create the incident. incidents[].title String The incident title. incidents[].description String The incident description. incidents[].labels Dictionary (String) A string to string mapping of the incident labels. Labels represent the unique entities that are used to describe the incident. incidents[].priority Enum The incident priority. Can be Critical, High, Medium, or Low. incidents[].sources List(String) The incident source. incidents[].state Enum(open, closed) The incident state. incidents[].opened_on String The date and time the incident was opened (in ISO format). incidents[].closed_on String The date and time the incident was closed (in ISO format). ui_name String Issue title. accumulations['alert/signal'] String Issue analysis summary golden signal/s (if applicable). accumulations['alert/components'] String Issue analysis summary golden components (if applicable). Jinja2 Default Payload Applied Intelligence uses a templating framework called Jinja2 in the Webhook interface. Here is a default Jinja2 payload to use: { \"id\": {{ id }}, \"url\": {{ url }}, \"ui_name\": {{ ui_name }}, \"description\": {{ description }}, \"priority\": {{ priority }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"active_since\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"sources\": {{ sources }}, \"incidents\": {{ incidents }}, \"pathways\": {{ pathways }}, } Copy Jinja2 Useful Syntax Below are a few useful Jinja2 commands to help you format your output. Casting a value to integer Example: “severity”: {{ priority | int }} Copy If clause to check if an attribute’s value is set Example: \"golden_signals\": {% if accumulations['alert/signal'] is defined %} {{ accumulations['alert/signal'] }} {% else %} None {% endif %} Copy For loop to iterate of an array of values: Example: \"description\": 'Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]' Copy Check if an array attribute's value is set: Example: \"hostname_field\": {% if incidents[0].labels['newrelic/tag/hostname'] is defined %} {{ incidents[0].labels['newrelic/tag/hostname'] }} {% else %} None {% endif %} Copy JSON schema Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). JSON schema template JSON schema: { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"definitions\": { \"Labels\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"LabelsSet\": { \"type\": \"array\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"$ref\": \"#/definitions/Labels\" }, \"uniqueItems\": true }, }, \"Annotations\": { \"type\": \"object\", \"title\": \"Additional contextual information about the Entity\", \"description\": \"Fields like title, description and priority can be described as annotations since\\nthey represent some additional information about the Incident.\\nFor example, the rule that creates the entity can have some logic that will create a title annotation field.\\nThe title will change according to the latest event received by the entity and as more\\nevent will keep coming the field may change, all this as a decision by the rule.\\nA different rule may decide not to populate the title at all.\\nSince a title can also be produced from the labels themselves.\", \"properties\": { \"title\": { \"type\": \"string\", \"maxLength\": 10000 }, \"description\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"patternProperties\": { \".*\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"Accumulations\": { \"type\": \"object\", \"title\": \"Accumulated data about the Incident\", \"description\": \"For example an entity with the label: host_name: foo will include a accumulated list of the\\nrelevant process names that are relevant to the entity. Accumulations will be derived from the events\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"type\": \"string\", \"maxLength\": 10000 } } }, \"IssueState\": { \"type\": \"string\", \"enum\": [ \"created\", \"active\", \"acknowledged\", \"closed\" ], \"properties\": {}, \"additionalProperties\": false }, \"Priority\": { \"type\": \"string\", \"enum\": [ \"critical\", \"high\", \"medium\", \"low\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueClosingReason\": { \"type\": \"string\", \"enum\": [ \"nacked\", \"resolved\", \"system\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueAction\": { \"type\": \"string\", \"enum\": [ \"ack\", \"snooze\", \"nack\", \"end_snooze\", \"expire_snooze\", \"star\", \"un_snooze\", \"unstar\", \"archive\", \"unarchive\", \"resolve\", \"reopen\", \"open\", \"feedback\", \"feedback_file\", \"open_ticket\", \"merge_issues\", \"active\", \"create\", \"close\", \"incident_updated\", \"confidence_changed\", \"diagnoses_changed\", \"rule_properties_changed\", \"flapping\", \"notification\", \"incident_events_limit_reached\", \"follow\", \"unfollow\", \"priority_updated\", \"comment\", \"incident_appended\", \"diagnosis_feedback\", \"flapping_delay_close\" ], \"properties\": {}, \"additionalProperties\": false }, \"StringKeyValue\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\" } }, \"JavaOptionalUuid\": { \"type\": \"string\", \"properties\": {}, \"additionalProperties\": false, \"format\": \"string-uuid\" } }, \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"customer_id\": { \"type\": \"integer\" }, \"labels_set\": { \"$ref\": \"#/definitions/LabelsSet\" }, \"annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations_version\": { \"type\": \"integer\" }, \"accumulations\": { \"$ref\": \"#/definitions/Accumulations\" }, \"state\": { \"$ref\": \"#/definitions/IssueState\" }, \"previous_state\": { \"$ref\": \"#/definitions/IssueState\" }, \"priority\": { \"$ref\": \"#/definitions/Priority\" }, \"closing_reason\": { \"oneOf\": [ { \"$ref\": \"#/definitions/IssueClosingReason\" }, { \"type\": \"null\" } ] }, \"modified_on\": { \"type\": \"integer\" }, \"created_on\": { \"type\": \"integer\" }, \"closed_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"acknowledged_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"active_since\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"assigned_to\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"created_by\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"progress_report\": { \"type\": \"array\", \"default\": [], \"items\": { \"type\": \"object\", \"properties\": { \"origin_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1 }, { \"type\": \"null\" } ] }, \"timestamp\": { \"type\": \"integer\" }, \"action_timestamp\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"origin_type\": { \"type\": \"string\", \"enum\": [ \"user\", \"system\" ] }, \"event_type\": { \"$ref\": \"#/definitions/IssueAction\" }, \"issue_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"format\": \"string-uuid\" }, { \"type\": \"null\" } ] }, \"attributes\": { \"oneOf\": [ { \"$ref\": \"#/definitions/StringKeyValue\" }, { \"type\": \"null\" } ] }, \"team_id\": { \"$ref\": \"#/definitions/JavaOptionalUuid\" } }, \"required\": [ \"timestamp\", \"origin_type\", \"event_type\" ], \"additionalProperties\": false }, \"uniqueItems\": true }, \"rule_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"maxLength\": 255 }, { \"type\": \"null\" } ] }, \"incident_ids\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"confidence\": { \"type\": \"number\", \"default\": 1.0, \"minimum\": 0.0, \"maximum\": 1.0 } }, \"required\": [ \"id\", \"customer_id\", \"labels_set\", \"annotations\", \"priority\", \"modified_on\", \"created_on\", \"confidence\" ], \"additionalProperties\": true } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.20842,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Incident <em>Intelligence</em> destination examples",
        "sections": "Incident <em>Intelligence</em> destination examples",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In <em>New</em> <em>Relic</em> <em>Applied</em> <em>Intelligence</em>, under Incident <em>Intelligence</em> click Destinations Add a WebHook In the end point paste the WebHook url"
      },
      "id": "6044280d64441f4af5378ed3"
    },
    {
      "sections": [
        "Use Incident Intelligence",
        "Issue summary",
        "Impacted entities map",
        "Use suggested responders",
        "Important",
        "Tip",
        "Root cause analysis",
        "Issue timeline",
        "Related activity",
        "Use decisions"
      ],
      "title": "Use Incident Intelligence",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "f7b852fa406a6e9ff88b791e4cbccc2bd20a5962",
      "image": "https://docs.newrelic.com/static/6e37cc77304398121e1a0080a57e47bb/8c557/screenshot_incident_intelligence_timeline_event_detail.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/use-incident-intelligence/",
      "published_at": "2021-06-02T18:23:21Z",
      "updated_at": "2021-05-28T11:09:29Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you set up Incident Intelligence, our system will begin finding issues from your data sources. In the issue feed, you can find an overview of all your issues, along with helpful information about them. You can also click any individual issue for more detail, including its analysis summary, event log, and details about correlated issues. This screenshot shows an example issue feed, which describes your issues' statuses, correlations, and more. What's the difference between an issue, incident, and event? In short, these terms are like building blocks. Events are raw data from your sources. Incidents are made up of one or more events. Issues are composed of one or more incidents. In more detail: Events indicate a state change or trigger defined by your monitoring systems. An event contains information about the affected entity, and they are almost always triggered automatically by the system. Incidents are groups of events that describe the \"symptoms\" of your system over time. These symptoms are detected by your monitoring tools, which evaluate your data streams and events. Issues are groups of incidents that describe the underlying problem of your symptoms. When a new incident is created, Incident Intelligence opens an issue and evaluates other open issues for correlations. Issue summary The Issue page is built to provide you with bottom line insights first to understand the problem, and then to minimize the time you need to resolve it. The Issue page includes the following sections: Issue summary: This section has two machine learning modules, the golden signals and the related components. Suggested responders: This section will tell you who to potentially reach out to on your team to solve a specific problem. Label sets: Label sets are focused on incidents that come from 3rd party sources, such as PagerDuty, AWS Cloudwatch, REST APIs, etc., as well as for NRQL queries. They come in the form of key:value pairs. Impacted entities: An entity is anything that has data you can monitor. Specifically, these are focused on incidents from New Relic sources, extracting the entities and providing a summary. Each entity is unique. You can see your entities in a list or on a map. Depending on the data in an issue, all four of these sections can show up together for each issue or separately. If you hover over an impacted entity application, you’ll notice a few calls to action: relevant dashboards, anomaly overview, deployment events, and entity overview. Relevant dashboards helps users in your account look at and interact with dashboards you've created that are related to an entity. The queries you've run to power the various widgets are automatically mapped to entities whenever possible and are presented back to you here for quick access and discovery. Anomaly overview will open the application's anomalies page. This is only available for applications that are set up for Proactive Detection. There are two types of deployment events: deployments and related deployments. Click Show all deployments to see all your deployment events when they arrive, or click a specific deployment to see its APM deployments page. The APM deployment page lists recent deployments and their impact on your end user and app server's Apdex scores, response times, throughput, and errors. This section will only show up if New Relic has identified applications under the impacted entities that have deployments. Impacted entities map Hover over an entity to see more information about it. An impacted entities map is available for any issue involving two or more entities. The map shows not only the affected entities, but also the services and resources directly related to those entities. Use suggested responders If you’re using PagerDuty or New Relic alerts violations as your incident notification tools, Incident Intelligence suggests relevant team members that can help resolve your issues. Incident Intelligence learns from your PagerDuty and alerts violations data to provide suggestions for each new incident. Once you receive a suggestion, you can contact the responder or search for relevant documentation that person may have written. To get started, enable PagerDuty or alerts violations as a source for Incident Intelligence. Afterwards, you can view the suggestions in two places: The issue feed, where you can also provide feedback on the suggestions. Directly within PagerDuty (both UI and API.) If you’re also using PagerDuty as a destination, the suggestions will appear in your issue notifications payload. Important This feature doesn't account for on-call availability at the time of incident. Tip In order to train the model, we use the information PagerDuty provides about individuals. We ingest incident information only, not users’ contact details. Root cause analysis Root cause analysis automatically finds potential causes for an issue and its impacted entities. It shows you why open issues occurred, which deployments contributed, and relevant error logs and attributes. With this, you can investigate the problem and reduce your mean time to resolution (MTTR). Tip Note that root cause analysis is dependent on other New Relic data sources and features. This is why root cause analysis information may not always be present for every issue. When you select an issue, you may see Root cause analysis information. Root cause analysis includes three main UI sections: Deployment events: When you set up deployments, we provide the deployment nearest to the issue creation. Changes, such as deployments, account for a high percentage of the root causes of incidents and having that information at hand can help diagnose and resolve issues. Error logs: You can explore millions of log messages with a single click and use manual querying to help you find anomalous patterns and hard-to-find problems. Attributes to investigate: We scan the distribution of attributes and surface possible causes by finding significant changes in the distribution. This section also shows changes in database and external metrics. You can also query interesting attributes. Issue timeline The issue timeline, as presented below, shows you a breakdown of: Incidents The trends taking place What incidents are active What incidents are resolved What is correlated to each other Various milestones at different issue levels In addition, you’ll see a grey line at the top of the timeline. In comparison to the visual timeline that shows the changes to each incident, the grey line represents changes to the issue. Mouse over the grey line to see details of the event. Finally, mouse over the incident to see information on the location, timing, and level of importance of a specific incident. This figure shows a particular incident populated on January 11th with a level of Critical. To view the issues in a text format, in the right hand corner, click Switch to issue log view. Related activity The issue page includes a Related activity section, which is a table displaying activity related to the incident or anomally you are are trying to analyze. You can click each line item in the table to view a unique dashboard that displays data for the entity the incident or anomally came from. The related activity section aggregates a set of incidents into a single issue, according to a rule-based system. Use decisions To further reduce noise or get improved incident correlation, you can change or customize your decisions. Decisions determine how Incident Intelligence groups incidents together. To get started, see Decisions.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 169.97278,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use Incident <em>Intelligence</em>",
        "sections": "Use Incident <em>Intelligence</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " help resolve your issues. Incident <em>Intelligence</em> learns from your PagerDuty and <em>alerts</em> violations data to provide suggestions for each <em>new</em> incident. Once you receive a suggestion, you can contact the responder or search for relevant documentation that person may have written. To <em>get</em> <em>started</em>, enable"
      },
      "id": "6080293564441fd0669d8580"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/get-started/alerts-concepts-workflow": [
    {
      "sections": [
        "Expanded anomaly detection",
        "Requirements",
        "Why it matters",
        "Get started with anomaly detection",
        "Detect anomalies with a faceted NRQL query",
        "See your anomalies in one place",
        "Tip",
        "Query anomaly data",
        "Reduce the number of detected anomalies"
      ],
      "title": "Expanded anomaly detection",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Proactive detection"
      ],
      "external_id": "0b07c0b6ce27f39b5edb3e112a0f949835cbb8c6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/proactive-detection/expanded-anomaly-detection/",
      "published_at": "2021-06-02T18:27:12Z",
      "updated_at": "2021-05-31T16:43:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We’ve expanded anomaly detection coverage beyond your APM applications. Configure anomaly detection for your browser applications, mobile applications, infrastructure hosts, and nearly anything you want to monitor. Requirements Expanded anomaly detection is available as a limited beta. You can request access here. Why it matters When starting to configure alert conditions for a variety of applications and hosts, it can be difficult to know what you’ll want to be notified about ahead of time. Anomaly detection helps you distinguish between what’s typical performance in your system and where you’re starting to have trouble. Instead of creating your alert conditions manually, you can simply tell us what you want to monitor. Anomaly detection will help you identify baseline performance in your system and flags anomalous activity in your system. Get started with anomaly detection To get started with expanded anomaly detection: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Select the account you want to use to record anomaly data, then select the workload or entities you’d like to monitor. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name your configuration and save. Detect anomalies with a faceted NRQL query To detect anomalies with a faceted NRQL query: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Click Use a query instead. You may need to select an account, if you have more than one. Add one or more queries with a FACET clause. Name the query and confirm the facets you want to monitor for anomalies. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name the configuration and save. See your anomalies in one place When you set up anomaly detection, New Relic starts analyzing the golden signals of your entities and workloads. Anomalies appear in your activity feeds throughout New Relic One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL alert condition for the NrAiAnomaly event. To view anomalies, from one.newrelic.com, go to Alerts & AI > Issues & activity > Anomalies. Query anomaly data Detected anomalies are written to the NrAiAnomaly event in your NRDB account. You can learn more about this event and how to query it here. Reduce the number of detected anomalies If you’re seeing too many anomalies, the first step is to make sure your sensitivity level is set to Low. If it’s already set to Low, you can define specific thresholds to distinguish between normal and anomalous behavior. To define custom thresholds: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab and the configuration you want to modify. Select an entity or workload, and then change the sensitivity level. You can use custom sensitivity to define specific thresholds for different entity types.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 188.82616,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Get</em> <em>started</em> with anomaly detection",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " feeds throughout <em>New</em> <em>Relic</em> One and the Anomalies tab as soon as they’re detected. Click any anomaly to <em>get</em> more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL <em>alert</em>"
      },
      "id": "60b5124064441ff965e2cb01"
    },
    {
      "sections": [
        "Incident Intelligence destination examples",
        "Destination template examples",
        "Suggested OpsGenie template example",
        "Suggested ServiceNow template example",
        "Suggested Slack template example",
        "Suggested VictorOps template example",
        "Webhook and JSON format examples",
        "Webhook format and JSON example",
        "Jinja2 Default Payload",
        "Jinja2 Useful Syntax",
        "JSON schema",
        "JSON schema template"
      ],
      "title": "Incident Intelligence destination examples",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "a516d04f8b75541a6dc9338fa3ce9645ba87d620",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/incident-intelligence-destination-examples/",
      "published_at": "2021-06-02T18:22:22Z",
      "updated_at": "2021-06-02T18:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Destinations are the data outputs to Applied Intelligence, where you can view your automatically correlated incidents. You can configure Incident Intelligence destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema. Destination template examples The following template example destinations are formatted in Jinja2. Suggested OpsGenie template example { \"alias\": {{ id }}, \"message\": {{ ui_name }}, \"source\": '{{ sources }}', \"priority\": {{ priority }}, \"details\": { \"self_url\": {{ url }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"is_correlated\": {{ is_correlated }} }, \"description\": \"\"\"Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]\"\"\" } Copy Suggested ServiceNow template example { \"short_description\": {{ ui_name }}, \"description\": 'Issue Id: {{ id }}, \\n Description: {{ description }}, \\n Sources: {{ sources }}, \\n Priority: {{ priority }}, \\n Details: { \\n self_url: {{ url }}, \\n state: {{ state }}, \\n is_correlated: {{ is_correlated }}, \\n created_on: {{ created_on }}, \\n modified_on: {{ modified_on }}, \\n activated_on: {{ active_since }}, \\n closed_on: {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \\n is_correlated: {{is_correlated}} }, \\n\\n incidents: {{ incidents }}, \\n\\n pathways: {{ pathways }}' } Copy Suggested Slack template example Go to Slack incoming WebHooks Choose the right Slack workspace and click \"Add to Slack\" Select the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In New Relic Applied Intelligence, under Incident Intelligence click Destinations Add a WebHook In the end point paste the WebHook url from slack. In the custom payload, paste the following JSON: { \"blocks\": [ { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*New Relic Incident Intelligence Alert*\" } }, { \"type\": \"divider\" }, { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*CUSTOM FIELDS*:\" }, \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue ID*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Issue Title*\" }, { \"type\": \"plain_text\", \"text\": {{ id }} }, { \"type\": \"plain_text\", \"text\": {{ ui_name }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue URL*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Description*\" }, { \"type\": \"mrkdwn\", \"text\": {{ url }} }, { \"type\": \"plain_text\", \"text\": {{ description }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*State*\" }, { \"type\": \"mrkdwn\", \"text\": \"*is_correlated*\" }, { \"type\": \"plain_text\", \"text\": {{ state }} }, { \"type\": \"plain_text\", \"text\": \"{{ is_correlated }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Created On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Modified On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ created_on }}\" }, { \"type\": \"plain_text\", \"text\": \"{{ modified_on }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Activated On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Closed On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ active_since }}\" }, { \"type\": \"plain_text\", \"text\": \"{% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Aggregated Incidents*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Monitoring Tool*\" }, { \"type\": \"plain_text\", \"text\": \"{{ incident_count }}\" }, { \"type\": \"plain_text\", \"text\": {{ sources|join(', ') }} } ] } ] } Copy Suggested VictorOps template example { \"monitoring_tool\": {{ sources }}, {% if state == 'closed' %} \"message_type\": \"OK\", {% else %} \"message_type\": {{ priority }}, {% endif %} \"custom_fields\": { \"issue_url\": {{ url }}, \"description\": {{ description }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"related_incidents\": [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %} {% endfor %} ] }, \"state_message\": {{ description }}, \"entity_id\": {{ id }}, \"entity_display_name\": {{ ui_name }}, \"vo_annotate.u.NRAI_Link\": {{ url }} } Copy Webhook and JSON format examples Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). If you use webhooks to configure Incident Intelligence destinations, use these examples of the webhook body format and JSON schema. Webhook format and JSON example Webhook format: Name Description url Href A link to the UI where the issue can be seen. id String Unique identifier for the issue. title String The issue title. description String The description of the issue. priority Enum The issue priority. Can be Critical, High, Medium, or Low. state Enum The issue status. Can be Active, Closed, or Acknowledged. is_correlated Boolean True if the issue is based on correlated data. created_on String The date and time the issue was created (in ISO format). modified_on String The date and time the issue was modified (in ISO format). active_since String The date and time the issue was activated (in ISO format). closed_on String The date and time the issue was closed (in ISO format). sources List(String) List of the different sources that were used to send the events into Applied Intelligence (for example: PagerDuty). pathways List(Pathways) List of pathways that are associated with the issue. Each pathway contains an id and name: [{“id”: “pathway id”, “name”: “pathway name”}]. pathways[].id String The pathway ID. pathways[].name String The pathway name. incidents List(Incident) List of incidents that are attached to the issue. The list contains only the latest 100 incidents. incidents[].id String The incident ID. incidents[].events_count Integer The number of events used to create the incident. incidents[].title String The incident title. incidents[].description String The incident description. incidents[].labels Dictionary (String) A string to string mapping of the incident labels. Labels represent the unique entities that are used to describe the incident. incidents[].priority Enum The incident priority. Can be Critical, High, Medium, or Low. incidents[].sources List(String) The incident source. incidents[].state Enum(open, closed) The incident state. incidents[].opened_on String The date and time the incident was opened (in ISO format). incidents[].closed_on String The date and time the incident was closed (in ISO format). ui_name String Issue title. accumulations['alert/signal'] String Issue analysis summary golden signal/s (if applicable). accumulations['alert/components'] String Issue analysis summary golden components (if applicable). Jinja2 Default Payload Applied Intelligence uses a templating framework called Jinja2 in the Webhook interface. Here is a default Jinja2 payload to use: { \"id\": {{ id }}, \"url\": {{ url }}, \"ui_name\": {{ ui_name }}, \"description\": {{ description }}, \"priority\": {{ priority }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"active_since\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"sources\": {{ sources }}, \"incidents\": {{ incidents }}, \"pathways\": {{ pathways }}, } Copy Jinja2 Useful Syntax Below are a few useful Jinja2 commands to help you format your output. Casting a value to integer Example: “severity”: {{ priority | int }} Copy If clause to check if an attribute’s value is set Example: \"golden_signals\": {% if accumulations['alert/signal'] is defined %} {{ accumulations['alert/signal'] }} {% else %} None {% endif %} Copy For loop to iterate of an array of values: Example: \"description\": 'Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]' Copy Check if an array attribute's value is set: Example: \"hostname_field\": {% if incidents[0].labels['newrelic/tag/hostname'] is defined %} {{ incidents[0].labels['newrelic/tag/hostname'] }} {% else %} None {% endif %} Copy JSON schema Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). JSON schema template JSON schema: { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"definitions\": { \"Labels\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"LabelsSet\": { \"type\": \"array\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"$ref\": \"#/definitions/Labels\" }, \"uniqueItems\": true }, }, \"Annotations\": { \"type\": \"object\", \"title\": \"Additional contextual information about the Entity\", \"description\": \"Fields like title, description and priority can be described as annotations since\\nthey represent some additional information about the Incident.\\nFor example, the rule that creates the entity can have some logic that will create a title annotation field.\\nThe title will change according to the latest event received by the entity and as more\\nevent will keep coming the field may change, all this as a decision by the rule.\\nA different rule may decide not to populate the title at all.\\nSince a title can also be produced from the labels themselves.\", \"properties\": { \"title\": { \"type\": \"string\", \"maxLength\": 10000 }, \"description\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"patternProperties\": { \".*\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"Accumulations\": { \"type\": \"object\", \"title\": \"Accumulated data about the Incident\", \"description\": \"For example an entity with the label: host_name: foo will include a accumulated list of the\\nrelevant process names that are relevant to the entity. Accumulations will be derived from the events\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"type\": \"string\", \"maxLength\": 10000 } } }, \"IssueState\": { \"type\": \"string\", \"enum\": [ \"created\", \"active\", \"acknowledged\", \"closed\" ], \"properties\": {}, \"additionalProperties\": false }, \"Priority\": { \"type\": \"string\", \"enum\": [ \"critical\", \"high\", \"medium\", \"low\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueClosingReason\": { \"type\": \"string\", \"enum\": [ \"nacked\", \"resolved\", \"system\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueAction\": { \"type\": \"string\", \"enum\": [ \"ack\", \"snooze\", \"nack\", \"end_snooze\", \"expire_snooze\", \"star\", \"un_snooze\", \"unstar\", \"archive\", \"unarchive\", \"resolve\", \"reopen\", \"open\", \"feedback\", \"feedback_file\", \"open_ticket\", \"merge_issues\", \"active\", \"create\", \"close\", \"incident_updated\", \"confidence_changed\", \"diagnoses_changed\", \"rule_properties_changed\", \"flapping\", \"notification\", \"incident_events_limit_reached\", \"follow\", \"unfollow\", \"priority_updated\", \"comment\", \"incident_appended\", \"diagnosis_feedback\", \"flapping_delay_close\" ], \"properties\": {}, \"additionalProperties\": false }, \"StringKeyValue\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\" } }, \"JavaOptionalUuid\": { \"type\": \"string\", \"properties\": {}, \"additionalProperties\": false, \"format\": \"string-uuid\" } }, \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"customer_id\": { \"type\": \"integer\" }, \"labels_set\": { \"$ref\": \"#/definitions/LabelsSet\" }, \"annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations_version\": { \"type\": \"integer\" }, \"accumulations\": { \"$ref\": \"#/definitions/Accumulations\" }, \"state\": { \"$ref\": \"#/definitions/IssueState\" }, \"previous_state\": { \"$ref\": \"#/definitions/IssueState\" }, \"priority\": { \"$ref\": \"#/definitions/Priority\" }, \"closing_reason\": { \"oneOf\": [ { \"$ref\": \"#/definitions/IssueClosingReason\" }, { \"type\": \"null\" } ] }, \"modified_on\": { \"type\": \"integer\" }, \"created_on\": { \"type\": \"integer\" }, \"closed_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"acknowledged_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"active_since\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"assigned_to\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"created_by\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"progress_report\": { \"type\": \"array\", \"default\": [], \"items\": { \"type\": \"object\", \"properties\": { \"origin_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1 }, { \"type\": \"null\" } ] }, \"timestamp\": { \"type\": \"integer\" }, \"action_timestamp\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"origin_type\": { \"type\": \"string\", \"enum\": [ \"user\", \"system\" ] }, \"event_type\": { \"$ref\": \"#/definitions/IssueAction\" }, \"issue_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"format\": \"string-uuid\" }, { \"type\": \"null\" } ] }, \"attributes\": { \"oneOf\": [ { \"$ref\": \"#/definitions/StringKeyValue\" }, { \"type\": \"null\" } ] }, \"team_id\": { \"$ref\": \"#/definitions/JavaOptionalUuid\" } }, \"required\": [ \"timestamp\", \"origin_type\", \"event_type\" ], \"additionalProperties\": false }, \"uniqueItems\": true }, \"rule_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"maxLength\": 255 }, { \"type\": \"null\" } ] }, \"incident_ids\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"confidence\": { \"type\": \"number\", \"default\": 1.0, \"minimum\": 0.0, \"maximum\": 1.0 } }, \"required\": [ \"id\", \"customer_id\", \"labels_set\", \"annotations\", \"priority\", \"modified_on\", \"created_on\", \"confidence\" ], \"additionalProperties\": true } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.20842,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Incident <em>Intelligence</em> destination examples",
        "sections": "Incident <em>Intelligence</em> destination examples",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In <em>New</em> <em>Relic</em> <em>Applied</em> <em>Intelligence</em>, under Incident <em>Intelligence</em> click Destinations Add a WebHook In the end point paste the WebHook url"
      },
      "id": "6044280d64441f4af5378ed3"
    },
    {
      "sections": [
        "Alerts & AI overview page",
        "Why it matters",
        "Overview page",
        "Issues",
        "Issue feed columns",
        "Incidents",
        "Default behavior",
        "Incident feed columns",
        "Anomalies",
        "Anomaly feed columns"
      ],
      "title": "Alerts & AI overview page",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Get started"
      ],
      "external_id": "1c5777d18861518220abc090482f7536de039271",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/get-started/alerts-ai-overview-page/",
      "published_at": "2021-05-28T03:31:15Z",
      "updated_at": "2021-05-11T06:46:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "On the Alerts & Applied Intelligence Overview page, you’ll find a consolidated view of your current alerts violations. The Issues & activity page has views of your active issues, recent incidents, and anomalies. Why it matters The Overview and Issues and activity pages provide analytics on how your system is (or isn't) performing. You can quickly switch between the Overview, Issues, Incidents, and Anomalies to scan for critical problems affecting your systems. Overview page The overview page shows a high-level view of recent and current alerts violations. With this page, you'll get quick insight into how many critical violations you have, how many have been closed, and which policies are creating the most violations. This page also shows the top sources of your muted violations. Dashboard title What it is Opened violations by priority (time series) A time series view that counts the number of violations opened during a time period. This chart only tracks open events. It doesn't track the open or closed state of the violation. Opened violations by priority (pie) This chart uses the same data as the time series chart of the same name. It quickly shows you the breakdown between warning and critical violations. Click the pie chart to filter the whole page by warning or critical violations. Closed violation durations A distribution of how long each violation was open (duration), before being closed. Generally, it's better to have shorter durations for your violations. If you're seeing a lot of long duration violations, you may want to write a custom filter to investigate those more deeply. Muted violations If you've written some muting rules, you'll see them here. If you're not using any muting rules, you'll see 100% “Not muted” violations. Click this chart to filter by muted violations to quickly see where they're coming from. Top policies creating violations A chart of the top five policies generating the most violations. Click a policy name to filter the whole page by that policy's violations. Top conditions creating violations A chart of the top five conditions generating the most violations. Click a policy name to filter the whole page by that condition's violations. Top sources of violations A chart of the entities generating the most violations. If available, it uses the entity name. Otherwise, it will use the event type. Click an entity to filter the whole page by that entity's violations. Issues On the Issues and activity page, issues are groups of incidents that describe the underlying problem of your symptoms. When a new incident is created, Incident Intelligence opens an issue and evaluates other open issues for correlations. The issues feed includes all of your environment's issues and can be searched and filtered using the top of page component. By default, the issues feed is filtered to only show the active issues. You can also filter by issue priority and source. By default, issues are sorted by most recently created issue. Click an issue to open its issue page. Issue feed columns Column name Values State Created, active, acknowledged, closed Priority Low, medium, high, critical Issue name The issue's name Created When the issue was created (in absolute or relative time) Duration How much time has passed since the issue was created Entities A list of the impacted entities. If the list is too long to be shown, mouseover the value to see the list. Analysis summary The machine learning module's output for the issue Path The Sources -> Destination path Incidents The number of related incidents Incidents On the Issues and activity page, incidents are groups of events that describe the symptoms affecting your system over time. These symptoms are detected by your monitoring tools, which evaluate your data streams and events. The incident feed includes all of your environment’s issues. These include incidents coming from New Relic, PagerDuty, and all of our other supported sources. You can filter the feed by source, incident state, and priority. Default behavior By default, the feed is sorted by last updated at the top. Click an incident's row to see the incident's details. Incident feed columns Column name Values State Open, Closed Priority Low, Medium, High, Critical Incident name The incident's name Created When the incident was created (in absolute or relative time) Duration How much time has passed since the incident was created Entities A list of the entities impacted by the incident. If the list is too long to be displayed, mouseover the value to see the list. Analysis summary The machine learning module's output for the incident Source The source system of the incident Events The number of events aggregated in the incident Anomalies On the Issues and activity page, anomalies are outliers in your system's performance and operation that might be the sign of a problem. See every anomaly for the last seven days in one place. You can filter your anomalies by anomaly state, application, configuration, configuation type, and category. By default, this page shows a list of all your recent anomalies from every configuration in the selected account. Select an anomaly to view a detailed analysis and more context. Anomaly feed columns Column name Explanation State of anomaly Values: open or closed. Anomaly category Values: error rate, web throughput, non-web throughput. (no column name) A graph to illustrate the anomaly. Start time How long ago the anomaly started. Duration How long the anomaly lasted. Entity Name of the entity.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.052,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> &amp; AI overview page",
        "sections": "<em>Alerts</em> &amp; AI overview page",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "On the <em>Alerts</em> &amp; <em>Applied</em> <em>Intelligence</em> Overview page, you’ll find a consolidated view of your current <em>alerts</em> violations. The Issues &amp; activity page has views of your active issues, recent incidents, and anomalies. Why it matters The Overview and Issues and activity pages provide analytics on how your"
      },
      "id": "603e99e264441f66664e8878"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/get-started/introduction-alerts": [
    {
      "sections": [
        "Expanded anomaly detection",
        "Requirements",
        "Why it matters",
        "Get started with anomaly detection",
        "Detect anomalies with a faceted NRQL query",
        "See your anomalies in one place",
        "Tip",
        "Query anomaly data",
        "Reduce the number of detected anomalies"
      ],
      "title": "Expanded anomaly detection",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Proactive detection"
      ],
      "external_id": "0b07c0b6ce27f39b5edb3e112a0f949835cbb8c6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/proactive-detection/expanded-anomaly-detection/",
      "published_at": "2021-06-02T18:27:12Z",
      "updated_at": "2021-05-31T16:43:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We’ve expanded anomaly detection coverage beyond your APM applications. Configure anomaly detection for your browser applications, mobile applications, infrastructure hosts, and nearly anything you want to monitor. Requirements Expanded anomaly detection is available as a limited beta. You can request access here. Why it matters When starting to configure alert conditions for a variety of applications and hosts, it can be difficult to know what you’ll want to be notified about ahead of time. Anomaly detection helps you distinguish between what’s typical performance in your system and where you’re starting to have trouble. Instead of creating your alert conditions manually, you can simply tell us what you want to monitor. Anomaly detection will help you identify baseline performance in your system and flags anomalous activity in your system. Get started with anomaly detection To get started with expanded anomaly detection: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Select the account you want to use to record anomaly data, then select the workload or entities you’d like to monitor. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name your configuration and save. Detect anomalies with a faceted NRQL query To detect anomalies with a faceted NRQL query: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Click Use a query instead. You may need to select an account, if you have more than one. Add one or more queries with a FACET clause. Name the query and confirm the facets you want to monitor for anomalies. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name the configuration and save. See your anomalies in one place When you set up anomaly detection, New Relic starts analyzing the golden signals of your entities and workloads. Anomalies appear in your activity feeds throughout New Relic One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL alert condition for the NrAiAnomaly event. To view anomalies, from one.newrelic.com, go to Alerts & AI > Issues & activity > Anomalies. Query anomaly data Detected anomalies are written to the NrAiAnomaly event in your NRDB account. You can learn more about this event and how to query it here. Reduce the number of detected anomalies If you’re seeing too many anomalies, the first step is to make sure your sensitivity level is set to Low. If it’s already set to Low, you can define specific thresholds to distinguish between normal and anomalous behavior. To define custom thresholds: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab and the configuration you want to modify. Select an entity or workload, and then change the sensitivity level. You can use custom sensitivity to define specific thresholds for different entity types.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 188.82603,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Get</em> <em>started</em> with anomaly detection",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " feeds throughout <em>New</em> <em>Relic</em> One and the Anomalies tab as soon as they’re detected. Click any anomaly to <em>get</em> more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL <em>alert</em>"
      },
      "id": "60b5124064441ff965e2cb01"
    },
    {
      "sections": [
        "Incident Intelligence destination examples",
        "Destination template examples",
        "Suggested OpsGenie template example",
        "Suggested ServiceNow template example",
        "Suggested Slack template example",
        "Suggested VictorOps template example",
        "Webhook and JSON format examples",
        "Webhook format and JSON example",
        "Jinja2 Default Payload",
        "Jinja2 Useful Syntax",
        "JSON schema",
        "JSON schema template"
      ],
      "title": "Incident Intelligence destination examples",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "a516d04f8b75541a6dc9338fa3ce9645ba87d620",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/incident-intelligence-destination-examples/",
      "published_at": "2021-06-02T18:22:22Z",
      "updated_at": "2021-06-02T18:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Destinations are the data outputs to Applied Intelligence, where you can view your automatically correlated incidents. You can configure Incident Intelligence destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema. Destination template examples The following template example destinations are formatted in Jinja2. Suggested OpsGenie template example { \"alias\": {{ id }}, \"message\": {{ ui_name }}, \"source\": '{{ sources }}', \"priority\": {{ priority }}, \"details\": { \"self_url\": {{ url }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"is_correlated\": {{ is_correlated }} }, \"description\": \"\"\"Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]\"\"\" } Copy Suggested ServiceNow template example { \"short_description\": {{ ui_name }}, \"description\": 'Issue Id: {{ id }}, \\n Description: {{ description }}, \\n Sources: {{ sources }}, \\n Priority: {{ priority }}, \\n Details: { \\n self_url: {{ url }}, \\n state: {{ state }}, \\n is_correlated: {{ is_correlated }}, \\n created_on: {{ created_on }}, \\n modified_on: {{ modified_on }}, \\n activated_on: {{ active_since }}, \\n closed_on: {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \\n is_correlated: {{is_correlated}} }, \\n\\n incidents: {{ incidents }}, \\n\\n pathways: {{ pathways }}' } Copy Suggested Slack template example Go to Slack incoming WebHooks Choose the right Slack workspace and click \"Add to Slack\" Select the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In New Relic Applied Intelligence, under Incident Intelligence click Destinations Add a WebHook In the end point paste the WebHook url from slack. In the custom payload, paste the following JSON: { \"blocks\": [ { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*New Relic Incident Intelligence Alert*\" } }, { \"type\": \"divider\" }, { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*CUSTOM FIELDS*:\" }, \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue ID*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Issue Title*\" }, { \"type\": \"plain_text\", \"text\": {{ id }} }, { \"type\": \"plain_text\", \"text\": {{ ui_name }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue URL*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Description*\" }, { \"type\": \"mrkdwn\", \"text\": {{ url }} }, { \"type\": \"plain_text\", \"text\": {{ description }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*State*\" }, { \"type\": \"mrkdwn\", \"text\": \"*is_correlated*\" }, { \"type\": \"plain_text\", \"text\": {{ state }} }, { \"type\": \"plain_text\", \"text\": \"{{ is_correlated }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Created On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Modified On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ created_on }}\" }, { \"type\": \"plain_text\", \"text\": \"{{ modified_on }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Activated On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Closed On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ active_since }}\" }, { \"type\": \"plain_text\", \"text\": \"{% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Aggregated Incidents*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Monitoring Tool*\" }, { \"type\": \"plain_text\", \"text\": \"{{ incident_count }}\" }, { \"type\": \"plain_text\", \"text\": {{ sources|join(', ') }} } ] } ] } Copy Suggested VictorOps template example { \"monitoring_tool\": {{ sources }}, {% if state == 'closed' %} \"message_type\": \"OK\", {% else %} \"message_type\": {{ priority }}, {% endif %} \"custom_fields\": { \"issue_url\": {{ url }}, \"description\": {{ description }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"related_incidents\": [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %} {% endfor %} ] }, \"state_message\": {{ description }}, \"entity_id\": {{ id }}, \"entity_display_name\": {{ ui_name }}, \"vo_annotate.u.NRAI_Link\": {{ url }} } Copy Webhook and JSON format examples Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). If you use webhooks to configure Incident Intelligence destinations, use these examples of the webhook body format and JSON schema. Webhook format and JSON example Webhook format: Name Description url Href A link to the UI where the issue can be seen. id String Unique identifier for the issue. title String The issue title. description String The description of the issue. priority Enum The issue priority. Can be Critical, High, Medium, or Low. state Enum The issue status. Can be Active, Closed, or Acknowledged. is_correlated Boolean True if the issue is based on correlated data. created_on String The date and time the issue was created (in ISO format). modified_on String The date and time the issue was modified (in ISO format). active_since String The date and time the issue was activated (in ISO format). closed_on String The date and time the issue was closed (in ISO format). sources List(String) List of the different sources that were used to send the events into Applied Intelligence (for example: PagerDuty). pathways List(Pathways) List of pathways that are associated with the issue. Each pathway contains an id and name: [{“id”: “pathway id”, “name”: “pathway name”}]. pathways[].id String The pathway ID. pathways[].name String The pathway name. incidents List(Incident) List of incidents that are attached to the issue. The list contains only the latest 100 incidents. incidents[].id String The incident ID. incidents[].events_count Integer The number of events used to create the incident. incidents[].title String The incident title. incidents[].description String The incident description. incidents[].labels Dictionary (String) A string to string mapping of the incident labels. Labels represent the unique entities that are used to describe the incident. incidents[].priority Enum The incident priority. Can be Critical, High, Medium, or Low. incidents[].sources List(String) The incident source. incidents[].state Enum(open, closed) The incident state. incidents[].opened_on String The date and time the incident was opened (in ISO format). incidents[].closed_on String The date and time the incident was closed (in ISO format). ui_name String Issue title. accumulations['alert/signal'] String Issue analysis summary golden signal/s (if applicable). accumulations['alert/components'] String Issue analysis summary golden components (if applicable). Jinja2 Default Payload Applied Intelligence uses a templating framework called Jinja2 in the Webhook interface. Here is a default Jinja2 payload to use: { \"id\": {{ id }}, \"url\": {{ url }}, \"ui_name\": {{ ui_name }}, \"description\": {{ description }}, \"priority\": {{ priority }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"active_since\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"sources\": {{ sources }}, \"incidents\": {{ incidents }}, \"pathways\": {{ pathways }}, } Copy Jinja2 Useful Syntax Below are a few useful Jinja2 commands to help you format your output. Casting a value to integer Example: “severity”: {{ priority | int }} Copy If clause to check if an attribute’s value is set Example: \"golden_signals\": {% if accumulations['alert/signal'] is defined %} {{ accumulations['alert/signal'] }} {% else %} None {% endif %} Copy For loop to iterate of an array of values: Example: \"description\": 'Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]' Copy Check if an array attribute's value is set: Example: \"hostname_field\": {% if incidents[0].labels['newrelic/tag/hostname'] is defined %} {{ incidents[0].labels['newrelic/tag/hostname'] }} {% else %} None {% endif %} Copy JSON schema Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). JSON schema template JSON schema: { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"definitions\": { \"Labels\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"LabelsSet\": { \"type\": \"array\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"$ref\": \"#/definitions/Labels\" }, \"uniqueItems\": true }, }, \"Annotations\": { \"type\": \"object\", \"title\": \"Additional contextual information about the Entity\", \"description\": \"Fields like title, description and priority can be described as annotations since\\nthey represent some additional information about the Incident.\\nFor example, the rule that creates the entity can have some logic that will create a title annotation field.\\nThe title will change according to the latest event received by the entity and as more\\nevent will keep coming the field may change, all this as a decision by the rule.\\nA different rule may decide not to populate the title at all.\\nSince a title can also be produced from the labels themselves.\", \"properties\": { \"title\": { \"type\": \"string\", \"maxLength\": 10000 }, \"description\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"patternProperties\": { \".*\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"Accumulations\": { \"type\": \"object\", \"title\": \"Accumulated data about the Incident\", \"description\": \"For example an entity with the label: host_name: foo will include a accumulated list of the\\nrelevant process names that are relevant to the entity. Accumulations will be derived from the events\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"type\": \"string\", \"maxLength\": 10000 } } }, \"IssueState\": { \"type\": \"string\", \"enum\": [ \"created\", \"active\", \"acknowledged\", \"closed\" ], \"properties\": {}, \"additionalProperties\": false }, \"Priority\": { \"type\": \"string\", \"enum\": [ \"critical\", \"high\", \"medium\", \"low\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueClosingReason\": { \"type\": \"string\", \"enum\": [ \"nacked\", \"resolved\", \"system\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueAction\": { \"type\": \"string\", \"enum\": [ \"ack\", \"snooze\", \"nack\", \"end_snooze\", \"expire_snooze\", \"star\", \"un_snooze\", \"unstar\", \"archive\", \"unarchive\", \"resolve\", \"reopen\", \"open\", \"feedback\", \"feedback_file\", \"open_ticket\", \"merge_issues\", \"active\", \"create\", \"close\", \"incident_updated\", \"confidence_changed\", \"diagnoses_changed\", \"rule_properties_changed\", \"flapping\", \"notification\", \"incident_events_limit_reached\", \"follow\", \"unfollow\", \"priority_updated\", \"comment\", \"incident_appended\", \"diagnosis_feedback\", \"flapping_delay_close\" ], \"properties\": {}, \"additionalProperties\": false }, \"StringKeyValue\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\" } }, \"JavaOptionalUuid\": { \"type\": \"string\", \"properties\": {}, \"additionalProperties\": false, \"format\": \"string-uuid\" } }, \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"customer_id\": { \"type\": \"integer\" }, \"labels_set\": { \"$ref\": \"#/definitions/LabelsSet\" }, \"annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations_version\": { \"type\": \"integer\" }, \"accumulations\": { \"$ref\": \"#/definitions/Accumulations\" }, \"state\": { \"$ref\": \"#/definitions/IssueState\" }, \"previous_state\": { \"$ref\": \"#/definitions/IssueState\" }, \"priority\": { \"$ref\": \"#/definitions/Priority\" }, \"closing_reason\": { \"oneOf\": [ { \"$ref\": \"#/definitions/IssueClosingReason\" }, { \"type\": \"null\" } ] }, \"modified_on\": { \"type\": \"integer\" }, \"created_on\": { \"type\": \"integer\" }, \"closed_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"acknowledged_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"active_since\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"assigned_to\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"created_by\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"progress_report\": { \"type\": \"array\", \"default\": [], \"items\": { \"type\": \"object\", \"properties\": { \"origin_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1 }, { \"type\": \"null\" } ] }, \"timestamp\": { \"type\": \"integer\" }, \"action_timestamp\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"origin_type\": { \"type\": \"string\", \"enum\": [ \"user\", \"system\" ] }, \"event_type\": { \"$ref\": \"#/definitions/IssueAction\" }, \"issue_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"format\": \"string-uuid\" }, { \"type\": \"null\" } ] }, \"attributes\": { \"oneOf\": [ { \"$ref\": \"#/definitions/StringKeyValue\" }, { \"type\": \"null\" } ] }, \"team_id\": { \"$ref\": \"#/definitions/JavaOptionalUuid\" } }, \"required\": [ \"timestamp\", \"origin_type\", \"event_type\" ], \"additionalProperties\": false }, \"uniqueItems\": true }, \"rule_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"maxLength\": 255 }, { \"type\": \"null\" } ] }, \"incident_ids\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"confidence\": { \"type\": \"number\", \"default\": 1.0, \"minimum\": 0.0, \"maximum\": 1.0 } }, \"required\": [ \"id\", \"customer_id\", \"labels_set\", \"annotations\", \"priority\", \"modified_on\", \"created_on\", \"confidence\" ], \"additionalProperties\": true } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.20825,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Incident <em>Intelligence</em> destination examples",
        "sections": "Incident <em>Intelligence</em> destination examples",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In <em>New</em> <em>Relic</em> <em>Applied</em> <em>Intelligence</em>, under Incident <em>Intelligence</em> click Destinations Add a WebHook In the end point paste the WebHook url"
      },
      "id": "6044280d64441f4af5378ed3"
    },
    {
      "sections": [
        "Alerts & AI overview page",
        "Why it matters",
        "Overview page",
        "Issues",
        "Issue feed columns",
        "Incidents",
        "Default behavior",
        "Incident feed columns",
        "Anomalies",
        "Anomaly feed columns"
      ],
      "title": "Alerts & AI overview page",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Get started"
      ],
      "external_id": "1c5777d18861518220abc090482f7536de039271",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/get-started/alerts-ai-overview-page/",
      "published_at": "2021-05-28T03:31:15Z",
      "updated_at": "2021-05-11T06:46:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "On the Alerts & Applied Intelligence Overview page, you’ll find a consolidated view of your current alerts violations. The Issues & activity page has views of your active issues, recent incidents, and anomalies. Why it matters The Overview and Issues and activity pages provide analytics on how your system is (or isn't) performing. You can quickly switch between the Overview, Issues, Incidents, and Anomalies to scan for critical problems affecting your systems. Overview page The overview page shows a high-level view of recent and current alerts violations. With this page, you'll get quick insight into how many critical violations you have, how many have been closed, and which policies are creating the most violations. This page also shows the top sources of your muted violations. Dashboard title What it is Opened violations by priority (time series) A time series view that counts the number of violations opened during a time period. This chart only tracks open events. It doesn't track the open or closed state of the violation. Opened violations by priority (pie) This chart uses the same data as the time series chart of the same name. It quickly shows you the breakdown between warning and critical violations. Click the pie chart to filter the whole page by warning or critical violations. Closed violation durations A distribution of how long each violation was open (duration), before being closed. Generally, it's better to have shorter durations for your violations. If you're seeing a lot of long duration violations, you may want to write a custom filter to investigate those more deeply. Muted violations If you've written some muting rules, you'll see them here. If you're not using any muting rules, you'll see 100% “Not muted” violations. Click this chart to filter by muted violations to quickly see where they're coming from. Top policies creating violations A chart of the top five policies generating the most violations. Click a policy name to filter the whole page by that policy's violations. Top conditions creating violations A chart of the top five conditions generating the most violations. Click a policy name to filter the whole page by that condition's violations. Top sources of violations A chart of the entities generating the most violations. If available, it uses the entity name. Otherwise, it will use the event type. Click an entity to filter the whole page by that entity's violations. Issues On the Issues and activity page, issues are groups of incidents that describe the underlying problem of your symptoms. When a new incident is created, Incident Intelligence opens an issue and evaluates other open issues for correlations. The issues feed includes all of your environment's issues and can be searched and filtered using the top of page component. By default, the issues feed is filtered to only show the active issues. You can also filter by issue priority and source. By default, issues are sorted by most recently created issue. Click an issue to open its issue page. Issue feed columns Column name Values State Created, active, acknowledged, closed Priority Low, medium, high, critical Issue name The issue's name Created When the issue was created (in absolute or relative time) Duration How much time has passed since the issue was created Entities A list of the impacted entities. If the list is too long to be shown, mouseover the value to see the list. Analysis summary The machine learning module's output for the issue Path The Sources -> Destination path Incidents The number of related incidents Incidents On the Issues and activity page, incidents are groups of events that describe the symptoms affecting your system over time. These symptoms are detected by your monitoring tools, which evaluate your data streams and events. The incident feed includes all of your environment’s issues. These include incidents coming from New Relic, PagerDuty, and all of our other supported sources. You can filter the feed by source, incident state, and priority. Default behavior By default, the feed is sorted by last updated at the top. Click an incident's row to see the incident's details. Incident feed columns Column name Values State Open, Closed Priority Low, Medium, High, Critical Incident name The incident's name Created When the incident was created (in absolute or relative time) Duration How much time has passed since the incident was created Entities A list of the entities impacted by the incident. If the list is too long to be displayed, mouseover the value to see the list. Analysis summary The machine learning module's output for the incident Source The source system of the incident Events The number of events aggregated in the incident Anomalies On the Issues and activity page, anomalies are outliers in your system's performance and operation that might be the sign of a problem. See every anomaly for the last seven days in one place. You can filter your anomalies by anomaly state, application, configuration, configuation type, and category. By default, this page shows a list of all your recent anomalies from every configuration in the selected account. Select an anomaly to view a detailed analysis and more context. Anomaly feed columns Column name Explanation State of anomaly Values: open or closed. Anomaly category Values: error rate, web throughput, non-web throughput. (no column name) A graph to illustrate the anomaly. Start time How long ago the anomaly started. Duration How long the anomaly lasted. Entity Name of the entity.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.05197,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> &amp; AI overview page",
        "sections": "<em>Alerts</em> &amp; AI overview page",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "On the <em>Alerts</em> &amp; <em>Applied</em> <em>Intelligence</em> Overview page, you’ll find a consolidated view of your current <em>alerts</em> violations. The Issues &amp; activity page has views of your active issues, recent incidents, and anomalies. Why it matters The Overview and Issues and activity pages provide analytics on how your"
      },
      "id": "603e99e264441f66664e8878"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/get-started/introduction-applied-intelligence": [
    {
      "sections": [
        "Expanded anomaly detection",
        "Requirements",
        "Why it matters",
        "Get started with anomaly detection",
        "Detect anomalies with a faceted NRQL query",
        "See your anomalies in one place",
        "Tip",
        "Query anomaly data",
        "Reduce the number of detected anomalies"
      ],
      "title": "Expanded anomaly detection",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Proactive detection"
      ],
      "external_id": "0b07c0b6ce27f39b5edb3e112a0f949835cbb8c6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/proactive-detection/expanded-anomaly-detection/",
      "published_at": "2021-06-02T18:27:12Z",
      "updated_at": "2021-05-31T16:43:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We’ve expanded anomaly detection coverage beyond your APM applications. Configure anomaly detection for your browser applications, mobile applications, infrastructure hosts, and nearly anything you want to monitor. Requirements Expanded anomaly detection is available as a limited beta. You can request access here. Why it matters When starting to configure alert conditions for a variety of applications and hosts, it can be difficult to know what you’ll want to be notified about ahead of time. Anomaly detection helps you distinguish between what’s typical performance in your system and where you’re starting to have trouble. Instead of creating your alert conditions manually, you can simply tell us what you want to monitor. Anomaly detection will help you identify baseline performance in your system and flags anomalous activity in your system. Get started with anomaly detection To get started with expanded anomaly detection: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Select the account you want to use to record anomaly data, then select the workload or entities you’d like to monitor. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name your configuration and save. Detect anomalies with a faceted NRQL query To detect anomalies with a faceted NRQL query: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Click Use a query instead. You may need to select an account, if you have more than one. Add one or more queries with a FACET clause. Name the query and confirm the facets you want to monitor for anomalies. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name the configuration and save. See your anomalies in one place When you set up anomaly detection, New Relic starts analyzing the golden signals of your entities and workloads. Anomalies appear in your activity feeds throughout New Relic One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL alert condition for the NrAiAnomaly event. To view anomalies, from one.newrelic.com, go to Alerts & AI > Issues & activity > Anomalies. Query anomaly data Detected anomalies are written to the NrAiAnomaly event in your NRDB account. You can learn more about this event and how to query it here. Reduce the number of detected anomalies If you’re seeing too many anomalies, the first step is to make sure your sensitivity level is set to Low. If it’s already set to Low, you can define specific thresholds to distinguish between normal and anomalous behavior. To define custom thresholds: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab and the configuration you want to modify. Select an entity or workload, and then change the sensitivity level. You can use custom sensitivity to define specific thresholds for different entity types.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 188.82603,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Get</em> <em>started</em> with anomaly detection",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " feeds throughout <em>New</em> <em>Relic</em> One and the Anomalies tab as soon as they’re detected. Click any anomaly to <em>get</em> more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL <em>alert</em>"
      },
      "id": "60b5124064441ff965e2cb01"
    },
    {
      "sections": [
        "Incident Intelligence destination examples",
        "Destination template examples",
        "Suggested OpsGenie template example",
        "Suggested ServiceNow template example",
        "Suggested Slack template example",
        "Suggested VictorOps template example",
        "Webhook and JSON format examples",
        "Webhook format and JSON example",
        "Jinja2 Default Payload",
        "Jinja2 Useful Syntax",
        "JSON schema",
        "JSON schema template"
      ],
      "title": "Incident Intelligence destination examples",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "a516d04f8b75541a6dc9338fa3ce9645ba87d620",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/incident-intelligence-destination-examples/",
      "published_at": "2021-06-02T18:22:22Z",
      "updated_at": "2021-06-02T18:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Destinations are the data outputs to Applied Intelligence, where you can view your automatically correlated incidents. You can configure Incident Intelligence destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema. Destination template examples The following template example destinations are formatted in Jinja2. Suggested OpsGenie template example { \"alias\": {{ id }}, \"message\": {{ ui_name }}, \"source\": '{{ sources }}', \"priority\": {{ priority }}, \"details\": { \"self_url\": {{ url }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"is_correlated\": {{ is_correlated }} }, \"description\": \"\"\"Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]\"\"\" } Copy Suggested ServiceNow template example { \"short_description\": {{ ui_name }}, \"description\": 'Issue Id: {{ id }}, \\n Description: {{ description }}, \\n Sources: {{ sources }}, \\n Priority: {{ priority }}, \\n Details: { \\n self_url: {{ url }}, \\n state: {{ state }}, \\n is_correlated: {{ is_correlated }}, \\n created_on: {{ created_on }}, \\n modified_on: {{ modified_on }}, \\n activated_on: {{ active_since }}, \\n closed_on: {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \\n is_correlated: {{is_correlated}} }, \\n\\n incidents: {{ incidents }}, \\n\\n pathways: {{ pathways }}' } Copy Suggested Slack template example Go to Slack incoming WebHooks Choose the right Slack workspace and click \"Add to Slack\" Select the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In New Relic Applied Intelligence, under Incident Intelligence click Destinations Add a WebHook In the end point paste the WebHook url from slack. In the custom payload, paste the following JSON: { \"blocks\": [ { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*New Relic Incident Intelligence Alert*\" } }, { \"type\": \"divider\" }, { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*CUSTOM FIELDS*:\" }, \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue ID*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Issue Title*\" }, { \"type\": \"plain_text\", \"text\": {{ id }} }, { \"type\": \"plain_text\", \"text\": {{ ui_name }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue URL*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Description*\" }, { \"type\": \"mrkdwn\", \"text\": {{ url }} }, { \"type\": \"plain_text\", \"text\": {{ description }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*State*\" }, { \"type\": \"mrkdwn\", \"text\": \"*is_correlated*\" }, { \"type\": \"plain_text\", \"text\": {{ state }} }, { \"type\": \"plain_text\", \"text\": \"{{ is_correlated }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Created On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Modified On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ created_on }}\" }, { \"type\": \"plain_text\", \"text\": \"{{ modified_on }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Activated On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Closed On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ active_since }}\" }, { \"type\": \"plain_text\", \"text\": \"{% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Aggregated Incidents*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Monitoring Tool*\" }, { \"type\": \"plain_text\", \"text\": \"{{ incident_count }}\" }, { \"type\": \"plain_text\", \"text\": {{ sources|join(', ') }} } ] } ] } Copy Suggested VictorOps template example { \"monitoring_tool\": {{ sources }}, {% if state == 'closed' %} \"message_type\": \"OK\", {% else %} \"message_type\": {{ priority }}, {% endif %} \"custom_fields\": { \"issue_url\": {{ url }}, \"description\": {{ description }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"related_incidents\": [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %} {% endfor %} ] }, \"state_message\": {{ description }}, \"entity_id\": {{ id }}, \"entity_display_name\": {{ ui_name }}, \"vo_annotate.u.NRAI_Link\": {{ url }} } Copy Webhook and JSON format examples Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). If you use webhooks to configure Incident Intelligence destinations, use these examples of the webhook body format and JSON schema. Webhook format and JSON example Webhook format: Name Description url Href A link to the UI where the issue can be seen. id String Unique identifier for the issue. title String The issue title. description String The description of the issue. priority Enum The issue priority. Can be Critical, High, Medium, or Low. state Enum The issue status. Can be Active, Closed, or Acknowledged. is_correlated Boolean True if the issue is based on correlated data. created_on String The date and time the issue was created (in ISO format). modified_on String The date and time the issue was modified (in ISO format). active_since String The date and time the issue was activated (in ISO format). closed_on String The date and time the issue was closed (in ISO format). sources List(String) List of the different sources that were used to send the events into Applied Intelligence (for example: PagerDuty). pathways List(Pathways) List of pathways that are associated with the issue. Each pathway contains an id and name: [{“id”: “pathway id”, “name”: “pathway name”}]. pathways[].id String The pathway ID. pathways[].name String The pathway name. incidents List(Incident) List of incidents that are attached to the issue. The list contains only the latest 100 incidents. incidents[].id String The incident ID. incidents[].events_count Integer The number of events used to create the incident. incidents[].title String The incident title. incidents[].description String The incident description. incidents[].labels Dictionary (String) A string to string mapping of the incident labels. Labels represent the unique entities that are used to describe the incident. incidents[].priority Enum The incident priority. Can be Critical, High, Medium, or Low. incidents[].sources List(String) The incident source. incidents[].state Enum(open, closed) The incident state. incidents[].opened_on String The date and time the incident was opened (in ISO format). incidents[].closed_on String The date and time the incident was closed (in ISO format). ui_name String Issue title. accumulations['alert/signal'] String Issue analysis summary golden signal/s (if applicable). accumulations['alert/components'] String Issue analysis summary golden components (if applicable). Jinja2 Default Payload Applied Intelligence uses a templating framework called Jinja2 in the Webhook interface. Here is a default Jinja2 payload to use: { \"id\": {{ id }}, \"url\": {{ url }}, \"ui_name\": {{ ui_name }}, \"description\": {{ description }}, \"priority\": {{ priority }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"active_since\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"sources\": {{ sources }}, \"incidents\": {{ incidents }}, \"pathways\": {{ pathways }}, } Copy Jinja2 Useful Syntax Below are a few useful Jinja2 commands to help you format your output. Casting a value to integer Example: “severity”: {{ priority | int }} Copy If clause to check if an attribute’s value is set Example: \"golden_signals\": {% if accumulations['alert/signal'] is defined %} {{ accumulations['alert/signal'] }} {% else %} None {% endif %} Copy For loop to iterate of an array of values: Example: \"description\": 'Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]' Copy Check if an array attribute's value is set: Example: \"hostname_field\": {% if incidents[0].labels['newrelic/tag/hostname'] is defined %} {{ incidents[0].labels['newrelic/tag/hostname'] }} {% else %} None {% endif %} Copy JSON schema Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). JSON schema template JSON schema: { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"definitions\": { \"Labels\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"LabelsSet\": { \"type\": \"array\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"$ref\": \"#/definitions/Labels\" }, \"uniqueItems\": true }, }, \"Annotations\": { \"type\": \"object\", \"title\": \"Additional contextual information about the Entity\", \"description\": \"Fields like title, description and priority can be described as annotations since\\nthey represent some additional information about the Incident.\\nFor example, the rule that creates the entity can have some logic that will create a title annotation field.\\nThe title will change according to the latest event received by the entity and as more\\nevent will keep coming the field may change, all this as a decision by the rule.\\nA different rule may decide not to populate the title at all.\\nSince a title can also be produced from the labels themselves.\", \"properties\": { \"title\": { \"type\": \"string\", \"maxLength\": 10000 }, \"description\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"patternProperties\": { \".*\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"Accumulations\": { \"type\": \"object\", \"title\": \"Accumulated data about the Incident\", \"description\": \"For example an entity with the label: host_name: foo will include a accumulated list of the\\nrelevant process names that are relevant to the entity. Accumulations will be derived from the events\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"type\": \"string\", \"maxLength\": 10000 } } }, \"IssueState\": { \"type\": \"string\", \"enum\": [ \"created\", \"active\", \"acknowledged\", \"closed\" ], \"properties\": {}, \"additionalProperties\": false }, \"Priority\": { \"type\": \"string\", \"enum\": [ \"critical\", \"high\", \"medium\", \"low\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueClosingReason\": { \"type\": \"string\", \"enum\": [ \"nacked\", \"resolved\", \"system\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueAction\": { \"type\": \"string\", \"enum\": [ \"ack\", \"snooze\", \"nack\", \"end_snooze\", \"expire_snooze\", \"star\", \"un_snooze\", \"unstar\", \"archive\", \"unarchive\", \"resolve\", \"reopen\", \"open\", \"feedback\", \"feedback_file\", \"open_ticket\", \"merge_issues\", \"active\", \"create\", \"close\", \"incident_updated\", \"confidence_changed\", \"diagnoses_changed\", \"rule_properties_changed\", \"flapping\", \"notification\", \"incident_events_limit_reached\", \"follow\", \"unfollow\", \"priority_updated\", \"comment\", \"incident_appended\", \"diagnosis_feedback\", \"flapping_delay_close\" ], \"properties\": {}, \"additionalProperties\": false }, \"StringKeyValue\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\" } }, \"JavaOptionalUuid\": { \"type\": \"string\", \"properties\": {}, \"additionalProperties\": false, \"format\": \"string-uuid\" } }, \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"customer_id\": { \"type\": \"integer\" }, \"labels_set\": { \"$ref\": \"#/definitions/LabelsSet\" }, \"annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations_version\": { \"type\": \"integer\" }, \"accumulations\": { \"$ref\": \"#/definitions/Accumulations\" }, \"state\": { \"$ref\": \"#/definitions/IssueState\" }, \"previous_state\": { \"$ref\": \"#/definitions/IssueState\" }, \"priority\": { \"$ref\": \"#/definitions/Priority\" }, \"closing_reason\": { \"oneOf\": [ { \"$ref\": \"#/definitions/IssueClosingReason\" }, { \"type\": \"null\" } ] }, \"modified_on\": { \"type\": \"integer\" }, \"created_on\": { \"type\": \"integer\" }, \"closed_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"acknowledged_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"active_since\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"assigned_to\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"created_by\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"progress_report\": { \"type\": \"array\", \"default\": [], \"items\": { \"type\": \"object\", \"properties\": { \"origin_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1 }, { \"type\": \"null\" } ] }, \"timestamp\": { \"type\": \"integer\" }, \"action_timestamp\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"origin_type\": { \"type\": \"string\", \"enum\": [ \"user\", \"system\" ] }, \"event_type\": { \"$ref\": \"#/definitions/IssueAction\" }, \"issue_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"format\": \"string-uuid\" }, { \"type\": \"null\" } ] }, \"attributes\": { \"oneOf\": [ { \"$ref\": \"#/definitions/StringKeyValue\" }, { \"type\": \"null\" } ] }, \"team_id\": { \"$ref\": \"#/definitions/JavaOptionalUuid\" } }, \"required\": [ \"timestamp\", \"origin_type\", \"event_type\" ], \"additionalProperties\": false }, \"uniqueItems\": true }, \"rule_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"maxLength\": 255 }, { \"type\": \"null\" } ] }, \"incident_ids\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"confidence\": { \"type\": \"number\", \"default\": 1.0, \"minimum\": 0.0, \"maximum\": 1.0 } }, \"required\": [ \"id\", \"customer_id\", \"labels_set\", \"annotations\", \"priority\", \"modified_on\", \"created_on\", \"confidence\" ], \"additionalProperties\": true } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.20825,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Incident <em>Intelligence</em> destination examples",
        "sections": "Incident <em>Intelligence</em> destination examples",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In <em>New</em> <em>Relic</em> <em>Applied</em> <em>Intelligence</em>, under Incident <em>Intelligence</em> click Destinations Add a WebHook In the end point paste the WebHook url"
      },
      "id": "6044280d64441f4af5378ed3"
    },
    {
      "sections": [
        "Alerts & AI overview page",
        "Why it matters",
        "Overview page",
        "Issues",
        "Issue feed columns",
        "Incidents",
        "Default behavior",
        "Incident feed columns",
        "Anomalies",
        "Anomaly feed columns"
      ],
      "title": "Alerts & AI overview page",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Get started"
      ],
      "external_id": "1c5777d18861518220abc090482f7536de039271",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/get-started/alerts-ai-overview-page/",
      "published_at": "2021-05-28T03:31:15Z",
      "updated_at": "2021-05-11T06:46:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "On the Alerts & Applied Intelligence Overview page, you’ll find a consolidated view of your current alerts violations. The Issues & activity page has views of your active issues, recent incidents, and anomalies. Why it matters The Overview and Issues and activity pages provide analytics on how your system is (or isn't) performing. You can quickly switch between the Overview, Issues, Incidents, and Anomalies to scan for critical problems affecting your systems. Overview page The overview page shows a high-level view of recent and current alerts violations. With this page, you'll get quick insight into how many critical violations you have, how many have been closed, and which policies are creating the most violations. This page also shows the top sources of your muted violations. Dashboard title What it is Opened violations by priority (time series) A time series view that counts the number of violations opened during a time period. This chart only tracks open events. It doesn't track the open or closed state of the violation. Opened violations by priority (pie) This chart uses the same data as the time series chart of the same name. It quickly shows you the breakdown between warning and critical violations. Click the pie chart to filter the whole page by warning or critical violations. Closed violation durations A distribution of how long each violation was open (duration), before being closed. Generally, it's better to have shorter durations for your violations. If you're seeing a lot of long duration violations, you may want to write a custom filter to investigate those more deeply. Muted violations If you've written some muting rules, you'll see them here. If you're not using any muting rules, you'll see 100% “Not muted” violations. Click this chart to filter by muted violations to quickly see where they're coming from. Top policies creating violations A chart of the top five policies generating the most violations. Click a policy name to filter the whole page by that policy's violations. Top conditions creating violations A chart of the top five conditions generating the most violations. Click a policy name to filter the whole page by that condition's violations. Top sources of violations A chart of the entities generating the most violations. If available, it uses the entity name. Otherwise, it will use the event type. Click an entity to filter the whole page by that entity's violations. Issues On the Issues and activity page, issues are groups of incidents that describe the underlying problem of your symptoms. When a new incident is created, Incident Intelligence opens an issue and evaluates other open issues for correlations. The issues feed includes all of your environment's issues and can be searched and filtered using the top of page component. By default, the issues feed is filtered to only show the active issues. You can also filter by issue priority and source. By default, issues are sorted by most recently created issue. Click an issue to open its issue page. Issue feed columns Column name Values State Created, active, acknowledged, closed Priority Low, medium, high, critical Issue name The issue's name Created When the issue was created (in absolute or relative time) Duration How much time has passed since the issue was created Entities A list of the impacted entities. If the list is too long to be shown, mouseover the value to see the list. Analysis summary The machine learning module's output for the issue Path The Sources -> Destination path Incidents The number of related incidents Incidents On the Issues and activity page, incidents are groups of events that describe the symptoms affecting your system over time. These symptoms are detected by your monitoring tools, which evaluate your data streams and events. The incident feed includes all of your environment’s issues. These include incidents coming from New Relic, PagerDuty, and all of our other supported sources. You can filter the feed by source, incident state, and priority. Default behavior By default, the feed is sorted by last updated at the top. Click an incident's row to see the incident's details. Incident feed columns Column name Values State Open, Closed Priority Low, Medium, High, Critical Incident name The incident's name Created When the incident was created (in absolute or relative time) Duration How much time has passed since the incident was created Entities A list of the entities impacted by the incident. If the list is too long to be displayed, mouseover the value to see the list. Analysis summary The machine learning module's output for the incident Source The source system of the incident Events The number of events aggregated in the incident Anomalies On the Issues and activity page, anomalies are outliers in your system's performance and operation that might be the sign of a problem. See every anomaly for the last seven days in one place. You can filter your anomalies by anomaly state, application, configuration, configuation type, and category. By default, this page shows a list of all your recent anomalies from every configuration in the selected account. Select an anomaly to view a detailed analysis and more context. Anomaly feed columns Column name Explanation State of anomaly Values: open or closed. Anomaly category Values: error rate, web throughput, non-web throughput. (no column name) A graph to illustrate the anomaly. Start time How long ago the anomaly started. Duration How long the anomaly lasted. Entity Name of the entity.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.05197,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> &amp; AI overview page",
        "sections": "<em>Alerts</em> &amp; AI overview page",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "On the <em>Alerts</em> &amp; <em>Applied</em> <em>Intelligence</em> Overview page, you’ll find a consolidated view of your current <em>alerts</em> violations. The Issues &amp; activity page has views of your active issues, recent incidents, and anomalies. Why it matters The Overview and Issues and activity pages provide analytics on how your"
      },
      "id": "603e99e264441f66664e8878"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/get-started/streaming-alerts-key-terms-concepts": [
    {
      "sections": [
        "Expanded anomaly detection",
        "Requirements",
        "Why it matters",
        "Get started with anomaly detection",
        "Detect anomalies with a faceted NRQL query",
        "See your anomalies in one place",
        "Tip",
        "Query anomaly data",
        "Reduce the number of detected anomalies"
      ],
      "title": "Expanded anomaly detection",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Proactive detection"
      ],
      "external_id": "0b07c0b6ce27f39b5edb3e112a0f949835cbb8c6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/proactive-detection/expanded-anomaly-detection/",
      "published_at": "2021-06-02T18:27:12Z",
      "updated_at": "2021-05-31T16:43:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We’ve expanded anomaly detection coverage beyond your APM applications. Configure anomaly detection for your browser applications, mobile applications, infrastructure hosts, and nearly anything you want to monitor. Requirements Expanded anomaly detection is available as a limited beta. You can request access here. Why it matters When starting to configure alert conditions for a variety of applications and hosts, it can be difficult to know what you’ll want to be notified about ahead of time. Anomaly detection helps you distinguish between what’s typical performance in your system and where you’re starting to have trouble. Instead of creating your alert conditions manually, you can simply tell us what you want to monitor. Anomaly detection will help you identify baseline performance in your system and flags anomalous activity in your system. Get started with anomaly detection To get started with expanded anomaly detection: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Select the account you want to use to record anomaly data, then select the workload or entities you’d like to monitor. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name your configuration and save. Detect anomalies with a faceted NRQL query To detect anomalies with a faceted NRQL query: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Click Use a query instead. You may need to select an account, if you have more than one. Add one or more queries with a FACET clause. Name the query and confirm the facets you want to monitor for anomalies. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name the configuration and save. See your anomalies in one place When you set up anomaly detection, New Relic starts analyzing the golden signals of your entities and workloads. Anomalies appear in your activity feeds throughout New Relic One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL alert condition for the NrAiAnomaly event. To view anomalies, from one.newrelic.com, go to Alerts & AI > Issues & activity > Anomalies. Query anomaly data Detected anomalies are written to the NrAiAnomaly event in your NRDB account. You can learn more about this event and how to query it here. Reduce the number of detected anomalies If you’re seeing too many anomalies, the first step is to make sure your sensitivity level is set to Low. If it’s already set to Low, you can define specific thresholds to distinguish between normal and anomalous behavior. To define custom thresholds: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab and the configuration you want to modify. Select an entity or workload, and then change the sensitivity level. You can use custom sensitivity to define specific thresholds for different entity types.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 188.82591,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Get</em> <em>started</em> with anomaly detection",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " feeds throughout <em>New</em> <em>Relic</em> One and the Anomalies tab as soon as they’re detected. Click any anomaly to <em>get</em> more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL <em>alert</em>"
      },
      "id": "60b5124064441ff965e2cb01"
    },
    {
      "sections": [
        "Incident Intelligence destination examples",
        "Destination template examples",
        "Suggested OpsGenie template example",
        "Suggested ServiceNow template example",
        "Suggested Slack template example",
        "Suggested VictorOps template example",
        "Webhook and JSON format examples",
        "Webhook format and JSON example",
        "Jinja2 Default Payload",
        "Jinja2 Useful Syntax",
        "JSON schema",
        "JSON schema template"
      ],
      "title": "Incident Intelligence destination examples",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "a516d04f8b75541a6dc9338fa3ce9645ba87d620",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/incident-intelligence-destination-examples/",
      "published_at": "2021-06-02T18:22:22Z",
      "updated_at": "2021-06-02T18:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Destinations are the data outputs to Applied Intelligence, where you can view your automatically correlated incidents. You can configure Incident Intelligence destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema. Destination template examples The following template example destinations are formatted in Jinja2. Suggested OpsGenie template example { \"alias\": {{ id }}, \"message\": {{ ui_name }}, \"source\": '{{ sources }}', \"priority\": {{ priority }}, \"details\": { \"self_url\": {{ url }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"is_correlated\": {{ is_correlated }} }, \"description\": \"\"\"Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]\"\"\" } Copy Suggested ServiceNow template example { \"short_description\": {{ ui_name }}, \"description\": 'Issue Id: {{ id }}, \\n Description: {{ description }}, \\n Sources: {{ sources }}, \\n Priority: {{ priority }}, \\n Details: { \\n self_url: {{ url }}, \\n state: {{ state }}, \\n is_correlated: {{ is_correlated }}, \\n created_on: {{ created_on }}, \\n modified_on: {{ modified_on }}, \\n activated_on: {{ active_since }}, \\n closed_on: {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \\n is_correlated: {{is_correlated}} }, \\n\\n incidents: {{ incidents }}, \\n\\n pathways: {{ pathways }}' } Copy Suggested Slack template example Go to Slack incoming WebHooks Choose the right Slack workspace and click \"Add to Slack\" Select the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In New Relic Applied Intelligence, under Incident Intelligence click Destinations Add a WebHook In the end point paste the WebHook url from slack. In the custom payload, paste the following JSON: { \"blocks\": [ { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*New Relic Incident Intelligence Alert*\" } }, { \"type\": \"divider\" }, { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*CUSTOM FIELDS*:\" }, \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue ID*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Issue Title*\" }, { \"type\": \"plain_text\", \"text\": {{ id }} }, { \"type\": \"plain_text\", \"text\": {{ ui_name }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue URL*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Description*\" }, { \"type\": \"mrkdwn\", \"text\": {{ url }} }, { \"type\": \"plain_text\", \"text\": {{ description }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*State*\" }, { \"type\": \"mrkdwn\", \"text\": \"*is_correlated*\" }, { \"type\": \"plain_text\", \"text\": {{ state }} }, { \"type\": \"plain_text\", \"text\": \"{{ is_correlated }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Created On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Modified On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ created_on }}\" }, { \"type\": \"plain_text\", \"text\": \"{{ modified_on }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Activated On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Closed On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ active_since }}\" }, { \"type\": \"plain_text\", \"text\": \"{% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Aggregated Incidents*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Monitoring Tool*\" }, { \"type\": \"plain_text\", \"text\": \"{{ incident_count }}\" }, { \"type\": \"plain_text\", \"text\": {{ sources|join(', ') }} } ] } ] } Copy Suggested VictorOps template example { \"monitoring_tool\": {{ sources }}, {% if state == 'closed' %} \"message_type\": \"OK\", {% else %} \"message_type\": {{ priority }}, {% endif %} \"custom_fields\": { \"issue_url\": {{ url }}, \"description\": {{ description }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"related_incidents\": [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %} {% endfor %} ] }, \"state_message\": {{ description }}, \"entity_id\": {{ id }}, \"entity_display_name\": {{ ui_name }}, \"vo_annotate.u.NRAI_Link\": {{ url }} } Copy Webhook and JSON format examples Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). If you use webhooks to configure Incident Intelligence destinations, use these examples of the webhook body format and JSON schema. Webhook format and JSON example Webhook format: Name Description url Href A link to the UI where the issue can be seen. id String Unique identifier for the issue. title String The issue title. description String The description of the issue. priority Enum The issue priority. Can be Critical, High, Medium, or Low. state Enum The issue status. Can be Active, Closed, or Acknowledged. is_correlated Boolean True if the issue is based on correlated data. created_on String The date and time the issue was created (in ISO format). modified_on String The date and time the issue was modified (in ISO format). active_since String The date and time the issue was activated (in ISO format). closed_on String The date and time the issue was closed (in ISO format). sources List(String) List of the different sources that were used to send the events into Applied Intelligence (for example: PagerDuty). pathways List(Pathways) List of pathways that are associated with the issue. Each pathway contains an id and name: [{“id”: “pathway id”, “name”: “pathway name”}]. pathways[].id String The pathway ID. pathways[].name String The pathway name. incidents List(Incident) List of incidents that are attached to the issue. The list contains only the latest 100 incidents. incidents[].id String The incident ID. incidents[].events_count Integer The number of events used to create the incident. incidents[].title String The incident title. incidents[].description String The incident description. incidents[].labels Dictionary (String) A string to string mapping of the incident labels. Labels represent the unique entities that are used to describe the incident. incidents[].priority Enum The incident priority. Can be Critical, High, Medium, or Low. incidents[].sources List(String) The incident source. incidents[].state Enum(open, closed) The incident state. incidents[].opened_on String The date and time the incident was opened (in ISO format). incidents[].closed_on String The date and time the incident was closed (in ISO format). ui_name String Issue title. accumulations['alert/signal'] String Issue analysis summary golden signal/s (if applicable). accumulations['alert/components'] String Issue analysis summary golden components (if applicable). Jinja2 Default Payload Applied Intelligence uses a templating framework called Jinja2 in the Webhook interface. Here is a default Jinja2 payload to use: { \"id\": {{ id }}, \"url\": {{ url }}, \"ui_name\": {{ ui_name }}, \"description\": {{ description }}, \"priority\": {{ priority }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"active_since\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"sources\": {{ sources }}, \"incidents\": {{ incidents }}, \"pathways\": {{ pathways }}, } Copy Jinja2 Useful Syntax Below are a few useful Jinja2 commands to help you format your output. Casting a value to integer Example: “severity”: {{ priority | int }} Copy If clause to check if an attribute’s value is set Example: \"golden_signals\": {% if accumulations['alert/signal'] is defined %} {{ accumulations['alert/signal'] }} {% else %} None {% endif %} Copy For loop to iterate of an array of values: Example: \"description\": 'Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]' Copy Check if an array attribute's value is set: Example: \"hostname_field\": {% if incidents[0].labels['newrelic/tag/hostname'] is defined %} {{ incidents[0].labels['newrelic/tag/hostname'] }} {% else %} None {% endif %} Copy JSON schema Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). JSON schema template JSON schema: { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"definitions\": { \"Labels\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"LabelsSet\": { \"type\": \"array\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"$ref\": \"#/definitions/Labels\" }, \"uniqueItems\": true }, }, \"Annotations\": { \"type\": \"object\", \"title\": \"Additional contextual information about the Entity\", \"description\": \"Fields like title, description and priority can be described as annotations since\\nthey represent some additional information about the Incident.\\nFor example, the rule that creates the entity can have some logic that will create a title annotation field.\\nThe title will change according to the latest event received by the entity and as more\\nevent will keep coming the field may change, all this as a decision by the rule.\\nA different rule may decide not to populate the title at all.\\nSince a title can also be produced from the labels themselves.\", \"properties\": { \"title\": { \"type\": \"string\", \"maxLength\": 10000 }, \"description\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"patternProperties\": { \".*\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"Accumulations\": { \"type\": \"object\", \"title\": \"Accumulated data about the Incident\", \"description\": \"For example an entity with the label: host_name: foo will include a accumulated list of the\\nrelevant process names that are relevant to the entity. Accumulations will be derived from the events\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"type\": \"string\", \"maxLength\": 10000 } } }, \"IssueState\": { \"type\": \"string\", \"enum\": [ \"created\", \"active\", \"acknowledged\", \"closed\" ], \"properties\": {}, \"additionalProperties\": false }, \"Priority\": { \"type\": \"string\", \"enum\": [ \"critical\", \"high\", \"medium\", \"low\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueClosingReason\": { \"type\": \"string\", \"enum\": [ \"nacked\", \"resolved\", \"system\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueAction\": { \"type\": \"string\", \"enum\": [ \"ack\", \"snooze\", \"nack\", \"end_snooze\", \"expire_snooze\", \"star\", \"un_snooze\", \"unstar\", \"archive\", \"unarchive\", \"resolve\", \"reopen\", \"open\", \"feedback\", \"feedback_file\", \"open_ticket\", \"merge_issues\", \"active\", \"create\", \"close\", \"incident_updated\", \"confidence_changed\", \"diagnoses_changed\", \"rule_properties_changed\", \"flapping\", \"notification\", \"incident_events_limit_reached\", \"follow\", \"unfollow\", \"priority_updated\", \"comment\", \"incident_appended\", \"diagnosis_feedback\", \"flapping_delay_close\" ], \"properties\": {}, \"additionalProperties\": false }, \"StringKeyValue\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\" } }, \"JavaOptionalUuid\": { \"type\": \"string\", \"properties\": {}, \"additionalProperties\": false, \"format\": \"string-uuid\" } }, \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"customer_id\": { \"type\": \"integer\" }, \"labels_set\": { \"$ref\": \"#/definitions/LabelsSet\" }, \"annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations_version\": { \"type\": \"integer\" }, \"accumulations\": { \"$ref\": \"#/definitions/Accumulations\" }, \"state\": { \"$ref\": \"#/definitions/IssueState\" }, \"previous_state\": { \"$ref\": \"#/definitions/IssueState\" }, \"priority\": { \"$ref\": \"#/definitions/Priority\" }, \"closing_reason\": { \"oneOf\": [ { \"$ref\": \"#/definitions/IssueClosingReason\" }, { \"type\": \"null\" } ] }, \"modified_on\": { \"type\": \"integer\" }, \"created_on\": { \"type\": \"integer\" }, \"closed_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"acknowledged_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"active_since\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"assigned_to\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"created_by\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"progress_report\": { \"type\": \"array\", \"default\": [], \"items\": { \"type\": \"object\", \"properties\": { \"origin_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1 }, { \"type\": \"null\" } ] }, \"timestamp\": { \"type\": \"integer\" }, \"action_timestamp\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"origin_type\": { \"type\": \"string\", \"enum\": [ \"user\", \"system\" ] }, \"event_type\": { \"$ref\": \"#/definitions/IssueAction\" }, \"issue_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"format\": \"string-uuid\" }, { \"type\": \"null\" } ] }, \"attributes\": { \"oneOf\": [ { \"$ref\": \"#/definitions/StringKeyValue\" }, { \"type\": \"null\" } ] }, \"team_id\": { \"$ref\": \"#/definitions/JavaOptionalUuid\" } }, \"required\": [ \"timestamp\", \"origin_type\", \"event_type\" ], \"additionalProperties\": false }, \"uniqueItems\": true }, \"rule_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"maxLength\": 255 }, { \"type\": \"null\" } ] }, \"incident_ids\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"confidence\": { \"type\": \"number\", \"default\": 1.0, \"minimum\": 0.0, \"maximum\": 1.0 } }, \"required\": [ \"id\", \"customer_id\", \"labels_set\", \"annotations\", \"priority\", \"modified_on\", \"created_on\", \"confidence\" ], \"additionalProperties\": true } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.2081,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Incident <em>Intelligence</em> destination examples",
        "sections": "Incident <em>Intelligence</em> destination examples",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In <em>New</em> <em>Relic</em> <em>Applied</em> <em>Intelligence</em>, under Incident <em>Intelligence</em> click Destinations Add a WebHook In the end point paste the WebHook url"
      },
      "id": "6044280d64441f4af5378ed3"
    },
    {
      "sections": [
        "Alerts & AI overview page",
        "Why it matters",
        "Overview page",
        "Issues",
        "Issue feed columns",
        "Incidents",
        "Default behavior",
        "Incident feed columns",
        "Anomalies",
        "Anomaly feed columns"
      ],
      "title": "Alerts & AI overview page",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Get started"
      ],
      "external_id": "1c5777d18861518220abc090482f7536de039271",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/get-started/alerts-ai-overview-page/",
      "published_at": "2021-05-28T03:31:15Z",
      "updated_at": "2021-05-11T06:46:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "On the Alerts & Applied Intelligence Overview page, you’ll find a consolidated view of your current alerts violations. The Issues & activity page has views of your active issues, recent incidents, and anomalies. Why it matters The Overview and Issues and activity pages provide analytics on how your system is (or isn't) performing. You can quickly switch between the Overview, Issues, Incidents, and Anomalies to scan for critical problems affecting your systems. Overview page The overview page shows a high-level view of recent and current alerts violations. With this page, you'll get quick insight into how many critical violations you have, how many have been closed, and which policies are creating the most violations. This page also shows the top sources of your muted violations. Dashboard title What it is Opened violations by priority (time series) A time series view that counts the number of violations opened during a time period. This chart only tracks open events. It doesn't track the open or closed state of the violation. Opened violations by priority (pie) This chart uses the same data as the time series chart of the same name. It quickly shows you the breakdown between warning and critical violations. Click the pie chart to filter the whole page by warning or critical violations. Closed violation durations A distribution of how long each violation was open (duration), before being closed. Generally, it's better to have shorter durations for your violations. If you're seeing a lot of long duration violations, you may want to write a custom filter to investigate those more deeply. Muted violations If you've written some muting rules, you'll see them here. If you're not using any muting rules, you'll see 100% “Not muted” violations. Click this chart to filter by muted violations to quickly see where they're coming from. Top policies creating violations A chart of the top five policies generating the most violations. Click a policy name to filter the whole page by that policy's violations. Top conditions creating violations A chart of the top five conditions generating the most violations. Click a policy name to filter the whole page by that condition's violations. Top sources of violations A chart of the entities generating the most violations. If available, it uses the entity name. Otherwise, it will use the event type. Click an entity to filter the whole page by that entity's violations. Issues On the Issues and activity page, issues are groups of incidents that describe the underlying problem of your symptoms. When a new incident is created, Incident Intelligence opens an issue and evaluates other open issues for correlations. The issues feed includes all of your environment's issues and can be searched and filtered using the top of page component. By default, the issues feed is filtered to only show the active issues. You can also filter by issue priority and source. By default, issues are sorted by most recently created issue. Click an issue to open its issue page. Issue feed columns Column name Values State Created, active, acknowledged, closed Priority Low, medium, high, critical Issue name The issue's name Created When the issue was created (in absolute or relative time) Duration How much time has passed since the issue was created Entities A list of the impacted entities. If the list is too long to be shown, mouseover the value to see the list. Analysis summary The machine learning module's output for the issue Path The Sources -> Destination path Incidents The number of related incidents Incidents On the Issues and activity page, incidents are groups of events that describe the symptoms affecting your system over time. These symptoms are detected by your monitoring tools, which evaluate your data streams and events. The incident feed includes all of your environment’s issues. These include incidents coming from New Relic, PagerDuty, and all of our other supported sources. You can filter the feed by source, incident state, and priority. Default behavior By default, the feed is sorted by last updated at the top. Click an incident's row to see the incident's details. Incident feed columns Column name Values State Open, Closed Priority Low, Medium, High, Critical Incident name The incident's name Created When the incident was created (in absolute or relative time) Duration How much time has passed since the incident was created Entities A list of the entities impacted by the incident. If the list is too long to be displayed, mouseover the value to see the list. Analysis summary The machine learning module's output for the incident Source The source system of the incident Events The number of events aggregated in the incident Anomalies On the Issues and activity page, anomalies are outliers in your system's performance and operation that might be the sign of a problem. See every anomaly for the last seven days in one place. You can filter your anomalies by anomaly state, application, configuration, configuation type, and category. By default, this page shows a list of all your recent anomalies from every configuration in the selected account. Select an anomaly to view a detailed analysis and more context. Anomaly feed columns Column name Explanation State of anomaly Values: open or closed. Anomaly category Values: error rate, web throughput, non-web throughput. (no column name) A graph to illustrate the anomaly. Start time How long ago the anomaly started. Duration How long the anomaly lasted. Entity Name of the entity.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.05197,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> &amp; AI overview page",
        "sections": "<em>Alerts</em> &amp; AI overview page",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "On the <em>Alerts</em> &amp; <em>Applied</em> <em>Intelligence</em> Overview page, you’ll find a consolidated view of your current <em>alerts</em> violations. The Issues &amp; activity page has views of your active issues, recent incidents, and anomalies. Why it matters The Overview and Issues and activity pages provide analytics on how your"
      },
      "id": "603e99e264441f66664e8878"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/rest-api-alerts/alerts-conditions-api-field-names": [
    {
      "sections": [
        "REST API calls for alerts",
        "Important",
        "Available data and functions via API",
        "Conditions excluded from the REST API",
        "Alert policies",
        "Create new policies",
        "Update policies",
        "Delete existing policies",
        "List existing policies",
        "Notification channels",
        "Create new notification channels",
        "Email channel",
        "OpsGenie channel",
        "Slack channel",
        "VictorOps channel",
        "PagerDuty channel",
        "Webhook (json) channel",
        "Webhook (x-www-form-urlencoded) channel",
        "Delete existing notification channels",
        "List existing notification channels",
        "Update notification channels associated with policies",
        "Delete notification channels associated with policies",
        "Conditions for APM, Browser, Mobile",
        "Create conditions for policies",
        "Update conditions for policies",
        "Delete conditions from policies",
        "List existing conditions for policies",
        "Conditions for NRQL",
        "Create NRQL conditions for policies",
        "Update NRQL conditions for policies",
        "Delete NRQL conditions for policies",
        "List existing NRQL conditions for policies",
        "Conditions for external services",
        "External services: Create conditions for policies",
        "External services: Update conditions for policies",
        "External services: Delete conditions from policies",
        "External services: List existing conditions for policies",
        "Conditions for Synthetic monitoring",
        "Synthetics: Create conditions for policies",
        "Synthetic monitoring: Update conditions for policies",
        "Synthetic monitoring: Delete conditions from policies",
        "Synthetic monitoring: List existing conditions for policies",
        "Conditions for plugins",
        "Plugins: Create conditions for policies",
        "Plugins: Update conditions for policies",
        "Plugins: Delete conditions from policies",
        "Plugins: List existing conditions for policies",
        "Alert activity: Events, violations, incidents",
        "List Events",
        "List Violations",
        "Tip",
        "List Incidents",
        "Show Incident",
        "Acknowledge Incident",
        "Close Incident",
        "Alert entity conditions",
        "List condition by entity",
        "Add an entity to a condition",
        "Remove an entity from a condition"
      ],
      "title": "REST API calls for alerts",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "REST API alerts"
      ],
      "external_id": "7e36876e5725bfa63cbd6aadd543e98060f5e118",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/rest-api-alerts/rest-api-calls-alerts/",
      "published_at": "2021-05-28T12:32:31Z",
      "updated_at": "2021-04-05T23:18:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our REST API (v2) allows you to configure settings for alerts. The API Explorer also includes the curl request format, available parameters, potential response status codes, and JSON response structure for each of the available API calls. You can also create alert conditions in the UI. Important For infrastructure alerting, see REST API for infrastructure monitoring alerts. Available data and functions via API REST API functions Comments View account data In general, any role can use a user key or REST API key with GET > List functions to view alerts data. The account Owner and Admins may use their API key. List output will be paginated. Available functions include: Alert policies Notification channels Conditions for APM, Browser, and Mobile (Some limitations apply.) Conditions for external services Conditions for Synthetic monitoring Conditions for Plugins Conditions for NRQL (Some limitations apply.) Events Violations Incidents Maintain account data You may have an Owner or Admin role in your account and a user key or have a custom role that grants permissions to manage Alerts and a user key in order to use any maintenance function, including POST > Create, PUT > Add, PUT > Update, and DELETE. Conditions excluded from the REST API These types of conditions do not have available endpoints in the API: APM: Web transaction percentiles, conditions targeting labels, and baselines NRQL: Baselines Alert policies These API functions include links to the API Explorer, where you can create, delete, or list policies. Important If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. Create new policies To add new policies, use your user key and include these two values in the API call: Required values Definition Incident incident_preference Determines how Alerts will create incidents and group violations. This must be one of the following: PER_POLICY (default): Roll up by policy. PER_CONDITION: Roll up by condition. PER_CONDITION_AND_TARGET: Roll up by target and condition. Policy name The policy name is required. Leaving it unchanged will create a policy called string. API Explorer: Alerts Policies > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_policies.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"policy\": { \"incident_preference\": \"string\", \"name\": \"string\" } }' Copy Update policies Use this API to update an existing policy's name and incident_preference. You'll need your user key. Required values Definition id Required. To find a policy's ID, use either of these options: From the UI: On a policy's UI page, find the ID under the policy name. With the API: Use the List policies API. Incident incident_preference Determines how alerts will create incidents and group violations. Must be one of the following: PER_POLICY (default): Roll up by policy. PER_CONDITION: Roll up by condition. PER_CONDITION_AND_TARGET: Roll up by target and condition. Policy name Required. If you do not change the name, it defaults to a policy called string. To find a policy's exact name, use the List policies API. API Explorer: Alerts Policies > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_policies/{id}.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"policy\": { \"incident_preference\": \"string\", \"name\": \"string\" } }' Copy Delete existing policies To delete an existing policy, use your user key, and include the policy_id (available from API Explorer: Alerts Policies > GET > List) in the API call: API Explorer: Alerts Policies > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy List existing policies To view a list of existing policies for your account, use your user key, and include these optional values in the API call: Optional policy name filter Optional pagination value API Explorer: Alerts Policies > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_policies.json' \\ -H 'Api-Key:$API_KEY' -i Copy Notification channels These API functions include links to the API Explorer, where you can create, delete, or list Alerts notification channels. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. Create new notification channels To add new notification channels, use your user key and include these values in the API call: New channel's name Type of channel Configuration values The API Explorer shows the format for required configuration values for each type of notification channel. API Explorer: Alerts Channels > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_channels.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"channel\": { \"name\": \"string\", \"type\": \"string\", \"configuration\": \"hash\" } }' Copy The \"hash\" place holder in this example must be replaced by one of the following JSON blocks with the appropriate values substituted: Email channel { \"recipients\" : \"test@google.com\", \"include_json_attachment\" : true } Copy OpsGenie channel { \"api_key\": \"abc123\", \"teams\": \"team1\", \"tags\": \"tag1\", \"recipients\": \"me@me.com\" } Copy Slack channel { \"url\": \"http://test.com\", \"channel\": \"channel1\" } Copy VictorOps channel { \"key\": \"mykey\", \"route_key\": \"theroute\" } Copy PagerDuty channel { \"service_key\": \"myservicekey\" } Copy Webhook (json) channel This example shows the default payload inserted. (The payload attribute is optional.) The payload can be customized to have different keys than the ones shown and will be sent with the $ prefixed attributes interpolated prior to delivery. Important The condition_id is deprecated. Instead, use condition_family_id. { \"base_url\": \"http://test.com\", \"auth_username\": \"username\", \"auth_password\": \"password\", \"payload_type\": \"application/json\", \"headers\": { \"header1\": \"test\", \"header2\": \"test\" } \"payload\": { \"account_id\": \"$ACCOUNT_ID\", \"account_name\": \"$ACCOUNT_NAME\", \"closed_violations_count_critical\": \"$CLOSED_VIOLATIONS_COUNT_CRITICAL\", \"closed_violations_count_warning\": \"$CLOSED_VIOLATIONS_COUNT_WARNING\", \"condition_family_id\": \"$CONDITION_FAMILY_ID\", \"condition_id\": \"$CONDITION_ID\", \"condition_name\": \"$CONDITION_NAME\", \"current_state\": \"$EVENT_STATE\", \"details\": \"$EVENT_DETAILS\", \"duration\": \"$DURATION\", \"event_type\": \"$EVENT_TYPE\", \"incident_acknowledge_url\": \"$INCIDENT_ACKNOWLEDGE_URL\", \"incident_id\": \"$INCIDENT_ID\", \"incident_url\": \"$INCIDENT_URL\", \"open_violations_count_critical\": \"$OPEN_VIOLATIONS_COUNT_CRITICAL\", \"open_violations_count_warning\": \"$OPEN_VIOLATIONS_COUNT_WARNING\", \"owner\": \"$EVENT_OWNER\", \"policy_name\": \"$POLICY_NAME\", \"policy_url\": \"$POLICY_URL\", \"runbook_url\": \"$RUNBOOK_URL\", \"severity\": \"$SEVERITY\", \"targets\": \"$TARGETS\", \"timestamp\": \"$TIMESTAMP\", \"violation_callback_url\": \"$VIOLATION_CALLBACK_URL\", \"violation_chart_url\": \"$VIOLATION_CHART_URL\" } } Copy Webhook (x-www-form-urlencoded) channel This example shows the default payload inserted. (The payload attribute is optional.) The payload can be customized to have different keys than the ones shown and will be sent with the $ prefixed attributes interpolated prior to delivery. Important The condition_id is deprecated. Instead, use condition_family_id. { \"base_url\": \"http://test.com\", \"auth_username\": \"username\", \"auth_password\": \"password\", \"payload_type\": \"application/x-www-form-urlencoded\", \"headers\": { \"header1\": \"test\", \"header2\": \"test\" }, \"payload\": { \"account_id\": \"$ACCOUNT_ID\", \"account_name\": \"$ACCOUNT_NAME\", \"closed_violations_count_critical\": \"$CLOSED_VIOLATIONS_COUNT_CRITICAL\", \"closed_violations_count_warning\": \"$CLOSED_VIOLATIONS_COUNT_WARNING\", \"condition_family_id\": \"$CONDITION_FAMILY_ID\", \"condition_id\": \"$CONDITION_ID\", \"condition_name\": \"$CONDITION_NAME\", \"current_state\": \"$EVENT_STATE\", \"details\": \"$EVENT_DETAILS\", \"duration\": \"$DURATION\", \"event_type\": \"$EVENT_TYPE\", \"incident_acknowledge_url\": \"$INCIDENT_ACKNOWLEDGE_URL\", \"incident_id\": \"$INCIDENT_ID\", \"incident_url\": \"$INCIDENT_URL\", \"open_violations_count_critical\": \"$OPEN_VIOLATIONS_COUNT_CRITICAL\", \"open_violations_count_warning\": \"$OPEN_VIOLATIONS_COUNT_WARNING\", \"owner\": \"$EVENT_OWNER\", \"policy_name\": \"$POLICY_NAME\", \"policy_url\": \"$POLICY_URL\", \"runbook_url\": \"$RUNBOOK_URL\", \"severity\": \"$SEVERITY\", \"targets\": \"$TARGETS\", \"timestamp\": \"$TIMESTAMP\", \"violation_callback_url\": \"$VIOLATION_CALLBACK_URL\", \"violation_chart_url\": \"$VIOLATION_CHART_URL\" } } Copy Delete existing notification channels To delete an existing notification channels, use your user key, and include the channel_id (available from API Explorer: Alerts Channels > GET > List) in the API call: API Explorer: Alerts Channels > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_channels/{channel_id}.json' \\ -H 'Api-Key:$API_KEY' -i Copy List existing notification channels To view a list of existing notification channels for your account, use your user key and an optional pagination value in the API call. API Explorer: Alerts Channels > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_channels.json' \\ -H 'Api-Key:$API_KEY' -i Copy Update notification channels associated with policies You can associate a policy with one or more notification channels. You can also associate a notification channel with one or more policies. To add notification channels to policies, use your user key and these values in the API call: A policy_id value (available from API Explorer: Alerts Policies > GET > List) One or more channel_id values in an array, separated by commas or a new line (available from API Explorer: Alerts Channels > GET > List) API Explorer: Alerts Policy Channels > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_policy_channels.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -G -d 'policy_id=$POLICY_ID&channel_ids=channel_id' Copy Delete notification channels associated with policies You can associate a policy with one or more notification channels. You can also associate a notification channel with one or more alert policies. To remove a policy from a channel, or to remove a channel from a policy, use your user key and these values in the API call: The policy_id (available from API Explorer: Alerts Policies > GET > List) The channel_id (available from API Explorer: Alerts Channels > GET > List) API Explorer: Alerts Policy Channels > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_policy_channels.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'channel_id=CHANNEL_ID&policy_id=POLICY_ID' Copy Conditions for APM, Browser, Mobile These API functions include links to the API Explorer, where you can create, update, delete, or list policy conditions. These calls are for conditions with these types of entities: APM: Apps and key transactions Browser: Apps and key transactions Mobile: Mobile apps Exception: The following APM conditions are not available from this API endpoint: Conditions targeting labels (dynamic targeting) Web transaction percentile conditions Baseline conditions Important The API Explorer provides information about other types of conditions using separate endpoints, including external services (APM and Mobile), plugins, and Synthetic monitoring. Consider all types of alert conditions when searching or updating. If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. Create conditions for policies To add conditions to policies, include these values in the API call: Your user key The policy_id (available from API Explorer: Alerts Policies > GET > List) The required condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Conditions > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"condition\": { \"type\": \"string\", \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"metric\": \"string\", \"gc_metric\": \"string\", \"condition_scope\": \"string\", \"violation_close_timer\": integer, \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"user_defined\": { \"metric\": \"string\", \"value_function\": \"string\" } } }' Copy The JSON response returns a condition id, which you will need to update or delete the condition. You can also view the condition id from API Explorer: Alerts Conditions > GET > List. Update conditions for policies To update conditions for policies, include these values in the API call: Your user key The condition's id (available from API Explorer: Alerts Conditions > GET > List) The required condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"condition\": { \"type\": \"string\", \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"metric\": \"string\", \"metric\": \"string\", \"gc_metric\": \"string\", \"condition_scope\": \"string\", \"violation_close_timer\": integer, \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"user_defined\": { \"metric\": \"string\", \"value_function\": \"string\" } } }' Copy Delete conditions from policies To delete conditions from policies, include these values in the API call: Your user key The condition_id (available from API Explorer: Alerts Conditions > GET > List) API Explorer: Alerts Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy List existing conditions for policies To view a list of existing conditions for your policy, use your REST API key or user key, and the associated policy_id in the API call. API Explorer: Alerts Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Conditions for NRQL These API functions include links to the API Explorer, where you can create, update, delete, or list NRQL conditions for your policies. Exception: NRQL baseline conditions are not available from this endpoint. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. Create NRQL conditions for policies Recommendation: Due to the way NRQL data is aggregated, set the nrql[since_value] to 3 or higher to prevent false positives. This equates to the Evaluation Offset value in the Alerts Condition UI. API Explorer: Alerts Nrql Conditions > POST > Create To create NRQL conditions for policies: curl -X POST 'https://api.newrelic.com/v2/alerts_nrql_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"nrql_condition\": { \"type\": \"string\", \"name\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean, \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"value_function\": \"string\", \"nrql\": { \"query\": \"string\", \"since_value\": \"string\" }, \"signal\": { \"aggregation_window\": \"string\", \"evaluation_offset\": \"string\", \"fill_option\": \"string\", \"fill_value\": \"string\" }, \"expiration\": { \"expiration_duration\": \"string\", \"open_violation_on_expiration\": boolean, \"close_violations_on_expiration\": boolean } } }' Copy If you set nrql[since_value] to 3 and nrql[query] to SELECT count FROM myEvent, New Relic evaluates the following query against the terms[threshold] value once per minute: SELECT count FROM myEvent SINCE 3 minutes ago UNTIL 2 minutes ago Copy If you set type as outlier, you can omit the value_function. However, two additional fields are required: expected_groups and ignore_overlap. For more information, see Alerts Conditions API field names. If you omit type or set it as static, it will default to standard NRQL alerting. Update NRQL conditions for policies Recommendation: Due to the way NRQL data is aggregated, set the nrql[since_value] to 3 or higher to prevent false positives. This allows three minutes to aggregate data, and equates to the Evaluation Offset value in the Alerts Condition UI. To update NRQL conditions for policies, include these values in the API call: Your user key The condition's id (available from API Explorer: Alerts Nrql Conditions > GET > List) The required condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Nrql Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_nrql_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"nrql_condition\": { \"name\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean, \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"value_function\": \"string\", \"nrql\": { \"query\": \"string\", \"since_value\": \"string\" } } }' Copy Delete NRQL conditions for policies To delete NRQL conditions from policies, include these values in the API call: Your user key The condition's id (available from API Explorer: Alerts Nrql Conditions > GET > List) API Explorer: Alerts Nrql Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_nrql_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy List existing NRQL conditions for policies To view a list of existing conditions for your alert policy, use your user key or REST API key, and the associated policy_id in the API call. API Explorer: Alerts Nrql Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_nrql_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Conditions for external services These API functions include links to the API Explorer, where you can create, update, delete, or list policy conditions. These calls are for conditions for external services. The API calls can be used with APM and Mobile apps. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. External services: Create conditions for policies To add conditions for external services to policies that have APM or Mobile apps, include these values in the API call: Your user key The policy_id (available from API Explorer: Alerts Policies > GET > List) The required external_service_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts External Service Conditions > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_external_service_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"external_service_condition\": { \"type\": \"string\", \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"external_service_url\": \"string\", \"metric\": \"string\", \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ] } }' Copy The JSON response returns a condition id, which you will need to update or delete the condition. You can also view the condition id from API Explorer: Alerts External Service Conditions > GET > List. External services: Update conditions for policies To update conditions for external services to policies that have APM or Mobile apps, include these values in the API call: Your user key The external service condition's id (available from API Explorer: Alerts External Service Conditions > GET > List) The required external_service_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts External Service Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_external_service_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"external_service_condition\": { \"type\": \"string\", \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"external_service_url\": \"string\", \"metric\": \"string\", \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ] } }' Copy External services: Delete conditions from policies To delete conditions for external services from policies with APM or Mobile apps, include these values in the API call: Your user key The condition_id (available from API Explorer: Alerts External Service Conditions > GET > List) API Explorer: Alerts External Service Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_external_service_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy External services: List existing conditions for policies To view a list of existing conditions for policies with external service apps (APM or Mobile), use your user key or REST API key and the associated policy_id in the API call. API Explorer: Alerts External Service Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_external_service_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Conditions for Synthetic monitoring These API functions include links to the API Explorer, where you can create, update, delete, or list conditions for your alert policies. The API calls can be used with Synthetic monitoring. Synthetics: Create conditions for policies To add conditions to policies for Synthetic monitoring, include these values in the API call: Your user key The policy_id (available from API Explorer: Alerts Policies > GET > List) The required synthetics_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Synthetics Conditions > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_synthetics_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"synthetics_condition\": { \"name\": \"string\", \"monitor_id\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean } }' Copy The JSON response returns a condition id, which you will need to update or delete the condition. You can also view the condition id from API Explorer: Alerts Synthetics Conditions > GET > List. Synthetic monitoring: Update conditions for policies To update policy conditions for Synthetic monitoring, include these values in the API call: Your user key The condition id (available from API Explorer: Alerts Synthetics Conditions > GET > List) The required synthetics_condition values in the API call (described in the API Explorer page to create alert conditions for Synthetics and in the Alerts conditions API glossary) API Explorer: Alerts Synthetics Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_synthetics_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"synthetics_condition\": { \"name\": \"string\", \"monitor_id\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean } }' Copy Synthetic monitoring: Delete conditions from policies To delete policy conditions for Synthetic monitoring, include these values in the API call: Your user key The condition_id (available from API Explorer: Alerts Synthetics Conditions > GET > List) API Explorer: Alerts Synthetics Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_synthetics_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy Synthetic monitoring: List existing conditions for policies To view a list of existing policy conditions for Synthetic monitoring, use your user key or REST API key, and the associated policy_id in the API call. API Explorer: Alerts Synthetics Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_synthetics_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Conditions for plugins These API functions include links to the API Explorer, where you can create, update, delete, or list conditions for your alert policies. The API calls can be used with plugins from New Relic's Plugin Central. Plugins: Create conditions for policies To add conditions to policies for plugin components or instances, include these values in the API call: Your user key The policy_id (available from API Explorer: Alerts Policies > GET > List) The required plugins_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Plugins Conditions > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_plugins_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"plugins_condition\": { \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"metric_description\": \"string\", \"metric\": \"string\", \"value_function\": \"string\", \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"plugin\": { \"id\": \"string\", \"guid\": \"string\" } } }' Copy The JSON response returns a condition id, which you will need to update or delete the condition. You can also view the condition id from API Explorer: Alerts Plugins Conditions > GET > List. Plugins: Update conditions for policies To update policy conditions for plugin components or instances, include these values in the API call: Your user key The condition id (available from API Explorer: Alerts Plugins Conditions > GET > List) The required plugins_condition values in the API call (described in the API Explorer page to create alert conditions for plugins and in the Alerts conditions API glossary) API Explorer: Alerts Plugins Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_plugins_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"plugins_condition\": { \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"metric_description\": \"string\", \"metric\": \"string\", \"value_function\": \"string\", \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"plugin\": { \"id\": \"string\", \"guid\": \"string\" } } }' Copy Plugins: Delete conditions from policies To delete conditions from policies for plugin components or instances, include these values in the API call: Your user key The condition id (available from API Explorer: Alerts Plugins Conditions > GET > List) API Explorer: Alerts Plugins Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_plugins_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy Plugins: List existing conditions for policies To view a list of existing conditions for policies with plugin components or instances, use your user key or REST API key, and the associated policy_id in the API call. API Explorer: Alerts Plugins Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_plugins_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Alert activity: Events, violations, incidents These API functions include links to the API Explorer, where you can view information about events, violations, and incidents for your alert policies. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. List Events To view events for entities monitored by APM, Browser, Mobile, Plugins, Synthetic monitoring, and Alerts, include these values in the API call: Your user key or REST API key Other optional values to use as filters (described in the API Explorer page) that depend on the type of product (browser monitoring, mobile monitoring, etc.), entity (as apps or key transactions for APM, synthetic monitoring, etc.), and type of event (notification, deployment, instrumentation, etc.) An optional pagination value API Explorer: Alerts Events > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_events.json' \\ -H 'Api-Key:$API_KEY' -i Copy List Violations To view violations for any entity monitored for your account, include these values in the API call: Your user key or REST API key An optional flag to show only those violations that are currently open An optional pagination value API Explorer: Alerts Violations > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_violations.json' \\ -H 'Api-Key:$API_KEY' -i Copy Tip To find policy, condition, and incident information: take the IDs found in the links section in the violations property and place them into the URLs contained in the outer links property of the payload. List Incidents To view incidents for any entity monitored for your account, include these values in the API call: Your user key or REST API key An optional flag to show only those incidents that are currently open An optional flag to exclude violation data from response An optional pagination value API Explorer: Alerts Incidents > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_incidents.json' \\ -H 'Api-Key:$API_KEY' -i Copy Show Incident To show a single incident associated with your account, include these values in the API call: Your user key or REST API key An incident ID API Explorer: Alerts Incidents > GET > Show curl -X GET 'https://api.newrelic.com/v2/alerts_incidents/{id}.json' \\ -H 'Api-Key:$API_KEY' -i Copy Acknowledge Incident To acknowledge an incident associated with your account, include these values in the API call: Your user key An incident ID API Explorer: Alerts Incidents > PUT > Acknowledge curl -X PUT 'https://api.newrelic.com/v2/alerts_incidents/{id}/acknowledge.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' Copy Close Incident To close an incident associated with your account, include these values in the API call: Your user key An incident ID API Explorer: Alerts Incidents > PUT > Close curl -X PUT 'https://api.newrelic.com/v2/alerts_incidents/{id}/close.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' Copy Alert entity conditions These API functions include links to the API Explorer, where you can list, add and remove entities in the conditions for your alert policies. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. List condition by entity To view the conditions an entity is part of for APM, Browser, Mobile, key transactions, and Plugins, include these values in the API call: Your user key or REST API key The entity_id This is the specific entity (alert target) to be monitored. The entity_type, which must be one of the following: Application BrowserApplication MobileApplication KeyTransaction Plugin API Explorer: Alerts Entity Conditions > GET > list curl -X GET 'https://api.newrelic.com/v2/alerts_entity_conditions/$ENTITY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -G -d 'entity_type=$ENTITY_TYPE' Copy Add an entity to a condition To add an entity to a condition, include these values in the API call: Your user key The entity_id This is the entity (alert target) to be monitored. It is the numeric ID for the APM application, browser app, plugin, key transaction, or mobile app. The condition_id (available from API Explorer: Alerts Conditions > GET > List) The entity_type, which must be one of the following: Application BrowserApplication MobileApplication KeyTransaction Plugin API Explorer: Alerts Entity Conditions > PUT > Add curl -X PUT 'https://api.newrelic.com/v2/alerts_entity_conditions/$ENTITY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -G -d 'entity_type=$ENTITY_TYPE&condition_id=$CONDITION_ID' Copy Remove an entity from a condition To remove an entity being monitored from a condition, include these values in the API call: Your user key The entity_id This is the specific monitored entity (alert target) to be removed. It is the numeric ID for the APM application, browser app, plugin, key transaction, or mobile app. The condition_id (available from API Explorer: Alerts Conditions > GET > List) The entity_type, which must be one of the following: Application BrowserApplication MobileApplication KeyTransaction Plugin API Explorer: Alerts Entity Conditions > DELETE > Remove curl -X DELETE 'https://api.newrelic.com/v2/alerts_entity_conditions/$ENTITY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -G -d 'entity_type=$ENTITY_ID&condition_id=$CONDITION_ID' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 181.5088,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>REST</em> <em>API</em> calls for <em>alerts</em>",
        "sections": "<em>REST</em> <em>API</em> calls for <em>alerts</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "Our <em>REST</em> <em>API</em> (v2) allows you to configure settings for <em>alerts</em>. The <em>API</em> Explorer also includes the curl request format, available parameters, potential response status codes, and JSON response structure for each of the available <em>API</em> calls. You can also create <em>alert</em> conditions in the UI. Important"
      },
      "id": "603ec3d064441f50e94e8847"
    },
    {
      "sections": [
        "Intro to using Alerts via NerdGraph API",
        "Alerts features you can manage with NerdGraph",
        "NerdGraph API explorer",
        "Tip",
        "Queries",
        "Mutations"
      ],
      "title": "Intro to using Alerts via NerdGraph API",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alerts and Nerdgraph"
      ],
      "external_id": "62c3f9bdca2acc3e9257b07970a717ee2ab0548f",
      "image": "https://docs.newrelic.com/static/6551638ff382e1ef38324cd82dca1214/e2c15/alerts_query_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-examples/",
      "published_at": "2021-05-28T18:40:20Z",
      "updated_at": "2021-04-21T16:08:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can manage your policies, conditions, and muting rules programmatically using our GraphQL NerdGraph API. This is a powerful alternative to managing them in New Relic One or through the REST API. Alerts features you can manage with NerdGraph Here's what you can do in NerdGraph: Manage policies Use NRQL conditions Muting rules: suppress notifications The easiest way to discover alerts queries and mutations is through the NerdGraph API explorer. NerdGraph API explorer Our NerdGraph API explorer is a GraphiQL editor where you can prototype queries and mutations. Here are some examples showing how to find fields for queries and mutations. Tip For general information about NerdGraph, see Introduction to NerdGraph. Queries To explore the various queries, look for the available queries under the actor.account.alerts namespace in NerdGraph API explorer: Mutations To explore various mutations, look in the alerts dropdown in the NerdGraph API explorer:",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.139,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to using <em>Alerts</em> via NerdGraph <em>API</em>",
        "sections": "Intro to using <em>Alerts</em> via NerdGraph <em>API</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "You can manage your policies, conditions, and muting rules programmatically using our GraphQL NerdGraph <em>API</em>. This is a powerful alternative to managing them in <em>New</em> <em>Relic</em> One or through the <em>REST</em> <em>API</em>. <em>Alerts</em> features you can manage with NerdGraph Here&#x27;s what you can do in NerdGraph: Manage policies"
      },
      "id": "6043fe3864441f2dd2378ee8"
    },
    {
      "sections": [
        "Disable and enable alerts conditions using the API",
        "Requirements",
        "Enable and disable a condition",
        "Details on searching for condition ID",
        "Details on Update API requests",
        "Tip",
        "Example: Disable an APM condition",
        "For more help"
      ],
      "title": "Disable and enable alerts conditions using the API",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "REST API alerts"
      ],
      "external_id": "b0495cb75c078289751e98c434b9ba4caf73b26f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/rest-api-alerts/disable-enable-alerts-conditions-using-api/",
      "published_at": "2021-05-27T19:24:41Z",
      "updated_at": "2021-03-13T03:08:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In a policy, a condition identifies what triggers an alert. You can use the REST API to disable and enable conditions. You can also disable and enable conditions in New Relic One. Policies can't be enabled or disabled, whether via the API or the UI. Policies can only be created, deleted, or have their conditions changed. Requirements Modifying any attribute in a condition using the API requires: An API key and permissions to manage Alerts The condition's id (available from API Explorer: Alerts Conditions > GET > List) If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. Enable and disable a condition The process for disabling or enabling a condition is the same general process for changing any attribute in a condition. A more detailed example comes after this general procedure: Find the ID for the policy that contains the condition you want to change. If the policy's ID is unknown, use the policy's name or type to make an API call and find the policy's ID. For more on this process, see List a single policy. With the policy ID, make an API call that returns the conditions associated with that policy. There are four different condition categories. If you don't know the category, this may require making up to four API calls in order to find the condition. Details on searching for condition ID If you don't know the category of the condition you want to change, you must search for it by making API calls using the four condition categories. Here are the different API call formats for the various condition categories. APM, Browser, and Mobile Conditions available: apm_app_metric, apm_kt_metric, browser_metric, and mobile_metric API Explorer link Get>List External services Conditions available: apm_external_service, mobile_external_service API Explorer link Get>List Synthetic monitoring API Explorer link Get>List Plugins API Explorer link Get>List For the returned JSON, find the JSON object of the condition you want to change. Copy and paste the condition's JSON in a text editor of your choice and edit the JSON. To enable the condition, set \"enabled\" to true. To disable the condition, set \"enabled\" to false. Update the condition by submitting your edited JSON via an Update API request. Our different products require different API requests. Details on Update API requests Use the Update API request that corresponds to the product in question: Conditions for APM, Browser, and Mobile Conditions available: apm_app_metric, apm_kt_metric, browser_metric, and mobile_metric API Explorer PUT>Update link Conditions for external services Conditions available: apm_external_service, mobile_external_service API Explorer PUT>Update Conditions for Synthetic monitoring) API Explorer PUT>Update Conditions for Plugins API Explorer PUT>Update Tip An Update API request can only change one condition at a time, it cannot update a vector of objects. For example, to change three conditions, you will have to make three separate requests. Example: Disable an APM condition The following example shows how to disable a condition for an apm_app_metric condition. With the exception of the types of API calls required, the process is similar to the process for changing other condition types. Obtain the policy_id of the policy you want to update. For an imaginary policy named Logjam Alert, the command would be: curl -X GET 'https://api.newrelic.com/v2/alerts_policies.json' \\ -H 'Api-Key:$API_KEY' -i \\ -G --data-urlencode 'filter[name]= Logjam Alert' <---<<< {policy_name} Copy The output for this request might look like: { \"policies\": [ { \"id\": 85, <---<<< $POLICY_ID \"incident_preference\": \"PER_POLICY\", \"name\": \"Logjam Alert\", \"created_at\": 1461176510393, \"updated_at\": 1461176510393 } ] } Copy List all of this policy's conditions and locate the {condition_id}: curl -X GET 'https://api.newrelic.com/v2/alerts_conditions.json' \\ -H 'X-Api-Key:$API_KEY' -i \\ -G -d 'policy_id=85' Copy The output for this request might look like: { \"conditions\": [ { \"id\": 12345, <---<<< $CONDITION_ID \"type\": \"apm_app_metric\", \"name\": \"Apdex (Low)\", \"enabled\": true, <---<<< Note the condition is enabled \"entities\": [ \"8288171\" ], \"metric\": \"apdex\", \"terms\": [ { \"duration\": \"5\", \"operator\": \"below\", \"priority\": \"critical\", \"threshold\": \"1\", \"time_function\": \"any\" } ] }, { \"id\": 2468, <---<<< another condition_id \"type\": \"apm_app_metric\", \"name\": \"Throughput (Low)\", ... } ] } Copy Copy the JSON for only the condition in question and paste it in a text editor. Change \"enabled\": true to \"enabled\": false. The edited JSON would look like: curl -X PUT 'https://api.newrelic.com/v2/alerts_conditions/12345.json' \\ -H 'X-Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"condition\": { \"type\": \"apm_app_metric\", \"name\": \"Apdex (Low)\", \"enabled\": false, <---<<< Changed to false \"entities\": [ \"8288171\" ], \"metric\": \"apdex\", \"terms\": [ { \"duration\": \"5\", \"operator\": \"below\", \"priority\": \"critical\", \"threshold\": \"1\", \"time_function\": \"any\" } ] } }' Copy Update the condition by submitting the edited condition JSON via an Update API request. For this specific condition, you would follow the steps in Update conditions for APM policies. Other product conditions would have other API requests, as detailed in Update API requests. For more help Additional documentation resources include: API calls for alerts (list of all API calls available) Using the API Explorer (using the API Explorer's user interface to get data in and data out of New Relic) Parts of the API Explorer (a quick reference for how to use each section of the API Explorer)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.5287,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Disable <em>and</em> enable <em>alerts</em> conditions using the <em>API</em>",
        "sections": "Disable <em>and</em> enable <em>alerts</em> conditions using the <em>API</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "In a policy, a condition identifies what triggers an <em>alert</em>. You can use the <em>REST</em> <em>API</em> to disable and enable conditions. You can also disable and enable conditions in <em>New</em> <em>Relic</em> One. Policies can&#x27;t be enabled or disabled, whether via the <em>API</em> or the UI. Policies can only be created, deleted, or have"
      },
      "id": "60442938196a67d2ed960f24"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/rest-api-alerts/disable-enable-alerts-conditions-using-api": [
    {
      "sections": [
        "Alerts conditions API field names",
        "Required and optional fields",
        "Field definitions",
        "aggregation_window",
        "close_violations_on_expiration",
        "condition_scope",
        "enabled",
        "entities",
        "evaluation_offset",
        "expected_groups",
        "expiration_duration",
        "external_service_url",
        "fill_option",
        "fill_value",
        "ignore_overlap",
        "metric",
        "Alerts plugin conditions",
        "Alerts conditions",
        "Alerts external service conditions",
        "metric_description",
        "monitor_id",
        "name",
        "nrql[query]",
        "nrql[since_value]",
        "open_violation_on_expiration",
        "plugin[guid]",
        "plugin[id]",
        "runbook_url",
        "terms[duration]",
        "terms[operator]",
        "terms[priority]",
        "terms[threshold]",
        "terms[time_function]",
        "type",
        "user_defined[metric] (optional)",
        "user_defined[value_function] (optional)",
        "value_function",
        "violation_time_limit_seconds",
        "violation_close_timer"
      ],
      "title": "Alerts conditions API field names",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "REST API alerts"
      ],
      "external_id": "5b098758aa368fade60befbff92ce025f8022f51",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/rest-api-alerts/alerts-conditions-api-field-names/",
      "published_at": "2021-05-28T10:42:07Z",
      "updated_at": "2021-05-11T06:48:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The REST API endpoints allow you to create conditions for your policies. This glossary contains the names and descriptions of each of the fields that you can use to define or update a condition. Required and optional fields The API includes four types of New Relic Alerts conditions: APM External services Synthetic monitoring Plugins All of the fields used with a specific condition type are required except for these optional fields: enabled (defaults to false) runbook_url user_defined Field definitions Not every field listed in this glossary is required for every condition type. The condition type for which a field must be used is listed in each description. aggregation_window Streaming alerts gathers data together into specific amounts of time before running the function in the NRQL query. These windows of time are customizable. The default is 1 minute. The maximum is 15 minutes. Data points are collected together based their timestamps and reported as a batch. The customizable aggregation window provides greater flexibility and fewer false violations when alerting on irregular or less frequent data points. In the UI, under Advanced signal settings, this is the Aggregation window field. close_violations_on_expiration When true, this closes all currently open violations when no signal is heard within the expiration_duration time. The default is False. condition_scope This field allows you to scope a condition to either a JVM instance or to a whole application. This may be one of the strings: instance application Used for: Conditions Entity conditions For instance-based and JVM health metrics, see also violation_close_timer. enabled This is the status of your alert condition and is optional. The default is false. This field may be used to enable or disable a condition for maintenance or testing periods. Used for: Conditions External service conditions Synthetic monitoring conditions Plugin conditions entities This is an array of entity IDs identifying the objects which will be monitored with your condition. These may be application IDs, browser IDs, plugin IDs, key transaction IDs, external service IDs, etc. These are entered as a series of comma separated integers if there is more than one. Used for: Conditions External service conditions Plugin conditions evaluation_offset The offset is how long we wait for late data before evaluating each aggregation window. Waiting longer gives a more accurate signal but increases latency. The default is 3 minutes. In the UI, under Advanced signal settings, this is the Offset evaluation by field. expected_groups This is the number of groups you expect to see at any given time. It is used in combination with the ignore_overlap option. Used for: NRQL outlier conditions expiration_duration How long to wait, in seconds, after the last data point is received by our platform before considering the signal as lost. This is based on the time when data arrives and not on data timestamps. The default is null. Add a value to enable loss of signal detection. external_service_url This is the URL of the external service to be monitored. This string must not include the protocol. For example, use example.com, not https://example.com. Used for: External service conditions fill_option For sporadic data, you can avoid false alerts by filling the gaps (empty windows) with synthetic data. none: (Default) Use this if you don’t want to take any action on empty aggregation windows. On evaluation, an empty aggregation window will reset the threshold duration timer. For example, if a condition says that all aggregation windows must have data points above the threshold for 5 minutes, and 1 of the 5 aggregation windows is empty, then the condition won’t be in violation. static: Use this if you’d like to insert a custom static value into the empty aggregation windows before they’re evaluated. This option has an additional, required parameter of fillValue that specifies what static value should be used. This defaults to 0. last_value: Use this to insert the last seen value before evaluation occurs. We maintain the state of the last seen value for 2 hours. In the UI, under Advanced signal settings, this is the Fill data gaps with field. fill_value This is the value used by the fill_option custom value. The default is 0. ignore_overlap If disabled, this looks for a convergence (or overlapping) of groups. If the condition is looking for two or more groups, and the returned values can't be separated into that number of distinct groups, then that will also produce a violation. This type of overlap event is represented on a chart by group bands touching. Used for: NRQL outlier conditions metric The metric field is used for three alert categories. The exact parameters available for use depend on the setting in the type field. These are listed below according to their alert type field. Alerts plugin conditions For Plugin conditions this is the metric, which has been defined in a plugin, that will be used to trigger a notification. Alerts conditions The value specified in the type field controls which of the parameters may be specified. The type field and corresponding available parameter names are listed in the following table. Only one may be specified. type Parameter apm_app_metric apdex error_percentage response_time_web response_time_background throughput_web throughput_background user_defined apm_kt_metric apdex error_percentage error_count response_time throughput browser_metric end_user_apdex total_page_load page_rendering web_application network dom_processing request_queuing ajax_response_time page_views_with_js_errors page_view_throughput ajax_throughput user_defined browser_metric_baseline page_view_throughput average_response_time ajax_response_time ajax_application_time mobile_metric database images json, network view_loading network_error_percentage status_error_percentage user_defined Alerts external service conditions The value specified in the type field controls which of the parameters may be specified. The type field and corresponding available parameter names are listed in the following table. Only one may be specified. type Parameter apm_external_service apdex error_percentage response_time_web response_time_background throughput_web throughput_background user_defined apm_app_metric_baseline external_service_transaction_time error_count database_transaction_time throughput_web response_time_web non_web_transaction_time web_transaction_database_time non_web_transaction_database_time mobile_external_service response_time_average response_time_minimum response_time_maximum throughput network_failure_percentage http_status_error_percentage metric_description This is a title for the metric which is displayed in notifications. Make this descriptive and unique so the reader will understand the nature of plugin metric being used to trigger an alert. Used for: Plugin conditions monitor_id This is the GUID of the Synthetic monitoring to alert on. Used for: Synthetic monitoring conditions name This condition title will allow to you identify it in the UI. Follow the guidelines for making this descriptive but short. Used for: Conditions External service conditions Synthetic monitoring conditions Plugin conditions nrql[query] This is the NRQL query that alerts monitors as part of a NRQL condition. Used for: NRQL conditions nrql[since_value] This is the timeframe (in minutes) in which to evaluate the specified NRQL query. since_value must be between 1 and 20. Used for: NRQL conditions open_violation_on_expiration When true, this opens a loss of signal violation when no signal within the expiration_duration time. The default is False. plugin[guid] This is the GUID of the plugin for which the trigger is being defined. Used for: Plugin conditions plugin[id] This is the ID of the plugin for which the trigger is being defined. Used for: Plugin conditions runbook_url The runbook URL to display in notifications. This field is optional. Used for: Conditions External service conditions Synthetic monitoring conditions Plugin conditions terms[duration] This is the time (in minutes) for the condition to persist before triggering an event. It corresponds to the duration set when adding a threshold in the UI. Used for: Conditions terms[operator] This determines what comparison will be used between the value_function and the terms [ threshold] value to trigger an event. It corresponds to the operation selected when adding a threshold in the UI. It must be one of the following strings: above below equal Used for: Conditions External service conditions Plugin conditions terms[priority] This corresponds to the severity level selected when setting the threshold values for the condition in the UI. This must be one of the following strings: critical warning Used for: Conditions External service conditions Plugin conditions terms[threshold] This is the threshold that the value_function must be compared to using the terms [ operator] for an event to be triggered. It corresponds to the numeric value specified in the UI when adding the threshold values. This is a numeric value and must be 0 (zero) or greater. Used for: Conditions External service conditions Plugin conditions terms[time_function] This corresponds to the settings made in the UI when adding the threshold values. The choices are: all (corresponding to for at least in the UI) any (corresponding to at least once in in the UI) Used for: Conditions External service conditions Plugin conditions type This defines the type of metric that will be used for the alert. Allowable content for the metric field depends on the type value chosen. There are two product categories : Alerts conditions For this category, type is set to one of the following strings indicating the type of alerts condition. type Use apm_app_metric APM application metric will trigger an alert. apm_app_metric_baseline APM application metric will trigger an alert (using a baseline threshold). apm_kt_metric APM key transaction metric will trigger an alert. browser_metric Browser metric will trigger an alert. browser_metric_baseline Browser metric will trigger an alert (using a baseline threshold). mobile_metric Mobile metric will trigger an alert. Used for: Conditions Alerts external service conditions For this category, type is set to one of the following strings indicating the type of external service condition. type Use apm_external_service APM external metric will trigger an alert. mobile_external_service Mobile external metric will trigger an alert. Used for: External service conditions user_defined[metric] (optional) This is the name of a user defined custom metric to be used to determine if an event should be triggered. The user_defined [ value_function] associated with the metric is compared with the terms [ threshold] value when evaluating if an incident should be triggered. The comparison is performed using the operator defined by terms [ operator]. Used for: Conditions External service conditions Synthetic monitoring conditions Plugin conditions user_defined[value_function] (optional) This is the numeric value obtained from the custom metric specified by user_defined [ metric]. It is compared with the terms [ threshold] value when evaluating if an incident should be triggered. The comparison is performed using the operator defined by terms [ operator]. One of these value functions must be specified: average min max total sample_size Used for: Conditions value_function This is the value function used from the plugin metric. This may be one of the strings: min max average sample_size total percent Used for: Plugin conditions When used for a NRQL condition, the options are: single_value (condition is evaluated based on each query's returned value) sum (condition is evaluated based on the sum of each query's returned values over the specified duration) violation_time_limit_seconds Use to automatically close instance-based violations after the number of seconds specified. Must be one of these values: 3600 7200 14400 28800 43200 86400 Used for: Location conditions NRQL conditions violation_close_timer Use to automatically close instance-based violations, including JVM health metric violations, after the number of hours specified. Must be one of these values: 1 2 4 8 12 24 Used for: apm_app_metric (with condition_scope set to instance) apm_jvm_metric",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 212.19582,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> conditions <em>API</em> field names",
        "sections": "<em>Alerts</em> conditions <em>API</em> field names",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "The <em>REST</em> <em>API</em> endpoints allow you to create conditions for your policies. This glossary contains the names and descriptions of each of the fields that you can use to define or update a condition. Required and optional fields The <em>API</em> includes four types of <em>New</em> <em>Relic</em> <em>Alerts</em> conditions: APM External"
      },
      "id": "604428f5e7b9d22c3a579a05"
    },
    {
      "sections": [
        "REST API calls for alerts",
        "Important",
        "Available data and functions via API",
        "Conditions excluded from the REST API",
        "Alert policies",
        "Create new policies",
        "Update policies",
        "Delete existing policies",
        "List existing policies",
        "Notification channels",
        "Create new notification channels",
        "Email channel",
        "OpsGenie channel",
        "Slack channel",
        "VictorOps channel",
        "PagerDuty channel",
        "Webhook (json) channel",
        "Webhook (x-www-form-urlencoded) channel",
        "Delete existing notification channels",
        "List existing notification channels",
        "Update notification channels associated with policies",
        "Delete notification channels associated with policies",
        "Conditions for APM, Browser, Mobile",
        "Create conditions for policies",
        "Update conditions for policies",
        "Delete conditions from policies",
        "List existing conditions for policies",
        "Conditions for NRQL",
        "Create NRQL conditions for policies",
        "Update NRQL conditions for policies",
        "Delete NRQL conditions for policies",
        "List existing NRQL conditions for policies",
        "Conditions for external services",
        "External services: Create conditions for policies",
        "External services: Update conditions for policies",
        "External services: Delete conditions from policies",
        "External services: List existing conditions for policies",
        "Conditions for Synthetic monitoring",
        "Synthetics: Create conditions for policies",
        "Synthetic monitoring: Update conditions for policies",
        "Synthetic monitoring: Delete conditions from policies",
        "Synthetic monitoring: List existing conditions for policies",
        "Conditions for plugins",
        "Plugins: Create conditions for policies",
        "Plugins: Update conditions for policies",
        "Plugins: Delete conditions from policies",
        "Plugins: List existing conditions for policies",
        "Alert activity: Events, violations, incidents",
        "List Events",
        "List Violations",
        "Tip",
        "List Incidents",
        "Show Incident",
        "Acknowledge Incident",
        "Close Incident",
        "Alert entity conditions",
        "List condition by entity",
        "Add an entity to a condition",
        "Remove an entity from a condition"
      ],
      "title": "REST API calls for alerts",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "REST API alerts"
      ],
      "external_id": "7e36876e5725bfa63cbd6aadd543e98060f5e118",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/rest-api-alerts/rest-api-calls-alerts/",
      "published_at": "2021-05-28T12:32:31Z",
      "updated_at": "2021-04-05T23:18:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our REST API (v2) allows you to configure settings for alerts. The API Explorer also includes the curl request format, available parameters, potential response status codes, and JSON response structure for each of the available API calls. You can also create alert conditions in the UI. Important For infrastructure alerting, see REST API for infrastructure monitoring alerts. Available data and functions via API REST API functions Comments View account data In general, any role can use a user key or REST API key with GET > List functions to view alerts data. The account Owner and Admins may use their API key. List output will be paginated. Available functions include: Alert policies Notification channels Conditions for APM, Browser, and Mobile (Some limitations apply.) Conditions for external services Conditions for Synthetic monitoring Conditions for Plugins Conditions for NRQL (Some limitations apply.) Events Violations Incidents Maintain account data You may have an Owner or Admin role in your account and a user key or have a custom role that grants permissions to manage Alerts and a user key in order to use any maintenance function, including POST > Create, PUT > Add, PUT > Update, and DELETE. Conditions excluded from the REST API These types of conditions do not have available endpoints in the API: APM: Web transaction percentiles, conditions targeting labels, and baselines NRQL: Baselines Alert policies These API functions include links to the API Explorer, where you can create, delete, or list policies. Important If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. Create new policies To add new policies, use your user key and include these two values in the API call: Required values Definition Incident incident_preference Determines how Alerts will create incidents and group violations. This must be one of the following: PER_POLICY (default): Roll up by policy. PER_CONDITION: Roll up by condition. PER_CONDITION_AND_TARGET: Roll up by target and condition. Policy name The policy name is required. Leaving it unchanged will create a policy called string. API Explorer: Alerts Policies > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_policies.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"policy\": { \"incident_preference\": \"string\", \"name\": \"string\" } }' Copy Update policies Use this API to update an existing policy's name and incident_preference. You'll need your user key. Required values Definition id Required. To find a policy's ID, use either of these options: From the UI: On a policy's UI page, find the ID under the policy name. With the API: Use the List policies API. Incident incident_preference Determines how alerts will create incidents and group violations. Must be one of the following: PER_POLICY (default): Roll up by policy. PER_CONDITION: Roll up by condition. PER_CONDITION_AND_TARGET: Roll up by target and condition. Policy name Required. If you do not change the name, it defaults to a policy called string. To find a policy's exact name, use the List policies API. API Explorer: Alerts Policies > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_policies/{id}.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"policy\": { \"incident_preference\": \"string\", \"name\": \"string\" } }' Copy Delete existing policies To delete an existing policy, use your user key, and include the policy_id (available from API Explorer: Alerts Policies > GET > List) in the API call: API Explorer: Alerts Policies > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy List existing policies To view a list of existing policies for your account, use your user key, and include these optional values in the API call: Optional policy name filter Optional pagination value API Explorer: Alerts Policies > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_policies.json' \\ -H 'Api-Key:$API_KEY' -i Copy Notification channels These API functions include links to the API Explorer, where you can create, delete, or list Alerts notification channels. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. Create new notification channels To add new notification channels, use your user key and include these values in the API call: New channel's name Type of channel Configuration values The API Explorer shows the format for required configuration values for each type of notification channel. API Explorer: Alerts Channels > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_channels.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"channel\": { \"name\": \"string\", \"type\": \"string\", \"configuration\": \"hash\" } }' Copy The \"hash\" place holder in this example must be replaced by one of the following JSON blocks with the appropriate values substituted: Email channel { \"recipients\" : \"test@google.com\", \"include_json_attachment\" : true } Copy OpsGenie channel { \"api_key\": \"abc123\", \"teams\": \"team1\", \"tags\": \"tag1\", \"recipients\": \"me@me.com\" } Copy Slack channel { \"url\": \"http://test.com\", \"channel\": \"channel1\" } Copy VictorOps channel { \"key\": \"mykey\", \"route_key\": \"theroute\" } Copy PagerDuty channel { \"service_key\": \"myservicekey\" } Copy Webhook (json) channel This example shows the default payload inserted. (The payload attribute is optional.) The payload can be customized to have different keys than the ones shown and will be sent with the $ prefixed attributes interpolated prior to delivery. Important The condition_id is deprecated. Instead, use condition_family_id. { \"base_url\": \"http://test.com\", \"auth_username\": \"username\", \"auth_password\": \"password\", \"payload_type\": \"application/json\", \"headers\": { \"header1\": \"test\", \"header2\": \"test\" } \"payload\": { \"account_id\": \"$ACCOUNT_ID\", \"account_name\": \"$ACCOUNT_NAME\", \"closed_violations_count_critical\": \"$CLOSED_VIOLATIONS_COUNT_CRITICAL\", \"closed_violations_count_warning\": \"$CLOSED_VIOLATIONS_COUNT_WARNING\", \"condition_family_id\": \"$CONDITION_FAMILY_ID\", \"condition_id\": \"$CONDITION_ID\", \"condition_name\": \"$CONDITION_NAME\", \"current_state\": \"$EVENT_STATE\", \"details\": \"$EVENT_DETAILS\", \"duration\": \"$DURATION\", \"event_type\": \"$EVENT_TYPE\", \"incident_acknowledge_url\": \"$INCIDENT_ACKNOWLEDGE_URL\", \"incident_id\": \"$INCIDENT_ID\", \"incident_url\": \"$INCIDENT_URL\", \"open_violations_count_critical\": \"$OPEN_VIOLATIONS_COUNT_CRITICAL\", \"open_violations_count_warning\": \"$OPEN_VIOLATIONS_COUNT_WARNING\", \"owner\": \"$EVENT_OWNER\", \"policy_name\": \"$POLICY_NAME\", \"policy_url\": \"$POLICY_URL\", \"runbook_url\": \"$RUNBOOK_URL\", \"severity\": \"$SEVERITY\", \"targets\": \"$TARGETS\", \"timestamp\": \"$TIMESTAMP\", \"violation_callback_url\": \"$VIOLATION_CALLBACK_URL\", \"violation_chart_url\": \"$VIOLATION_CHART_URL\" } } Copy Webhook (x-www-form-urlencoded) channel This example shows the default payload inserted. (The payload attribute is optional.) The payload can be customized to have different keys than the ones shown and will be sent with the $ prefixed attributes interpolated prior to delivery. Important The condition_id is deprecated. Instead, use condition_family_id. { \"base_url\": \"http://test.com\", \"auth_username\": \"username\", \"auth_password\": \"password\", \"payload_type\": \"application/x-www-form-urlencoded\", \"headers\": { \"header1\": \"test\", \"header2\": \"test\" }, \"payload\": { \"account_id\": \"$ACCOUNT_ID\", \"account_name\": \"$ACCOUNT_NAME\", \"closed_violations_count_critical\": \"$CLOSED_VIOLATIONS_COUNT_CRITICAL\", \"closed_violations_count_warning\": \"$CLOSED_VIOLATIONS_COUNT_WARNING\", \"condition_family_id\": \"$CONDITION_FAMILY_ID\", \"condition_id\": \"$CONDITION_ID\", \"condition_name\": \"$CONDITION_NAME\", \"current_state\": \"$EVENT_STATE\", \"details\": \"$EVENT_DETAILS\", \"duration\": \"$DURATION\", \"event_type\": \"$EVENT_TYPE\", \"incident_acknowledge_url\": \"$INCIDENT_ACKNOWLEDGE_URL\", \"incident_id\": \"$INCIDENT_ID\", \"incident_url\": \"$INCIDENT_URL\", \"open_violations_count_critical\": \"$OPEN_VIOLATIONS_COUNT_CRITICAL\", \"open_violations_count_warning\": \"$OPEN_VIOLATIONS_COUNT_WARNING\", \"owner\": \"$EVENT_OWNER\", \"policy_name\": \"$POLICY_NAME\", \"policy_url\": \"$POLICY_URL\", \"runbook_url\": \"$RUNBOOK_URL\", \"severity\": \"$SEVERITY\", \"targets\": \"$TARGETS\", \"timestamp\": \"$TIMESTAMP\", \"violation_callback_url\": \"$VIOLATION_CALLBACK_URL\", \"violation_chart_url\": \"$VIOLATION_CHART_URL\" } } Copy Delete existing notification channels To delete an existing notification channels, use your user key, and include the channel_id (available from API Explorer: Alerts Channels > GET > List) in the API call: API Explorer: Alerts Channels > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_channels/{channel_id}.json' \\ -H 'Api-Key:$API_KEY' -i Copy List existing notification channels To view a list of existing notification channels for your account, use your user key and an optional pagination value in the API call. API Explorer: Alerts Channels > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_channels.json' \\ -H 'Api-Key:$API_KEY' -i Copy Update notification channels associated with policies You can associate a policy with one or more notification channels. You can also associate a notification channel with one or more policies. To add notification channels to policies, use your user key and these values in the API call: A policy_id value (available from API Explorer: Alerts Policies > GET > List) One or more channel_id values in an array, separated by commas or a new line (available from API Explorer: Alerts Channels > GET > List) API Explorer: Alerts Policy Channels > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_policy_channels.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -G -d 'policy_id=$POLICY_ID&channel_ids=channel_id' Copy Delete notification channels associated with policies You can associate a policy with one or more notification channels. You can also associate a notification channel with one or more alert policies. To remove a policy from a channel, or to remove a channel from a policy, use your user key and these values in the API call: The policy_id (available from API Explorer: Alerts Policies > GET > List) The channel_id (available from API Explorer: Alerts Channels > GET > List) API Explorer: Alerts Policy Channels > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_policy_channels.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'channel_id=CHANNEL_ID&policy_id=POLICY_ID' Copy Conditions for APM, Browser, Mobile These API functions include links to the API Explorer, where you can create, update, delete, or list policy conditions. These calls are for conditions with these types of entities: APM: Apps and key transactions Browser: Apps and key transactions Mobile: Mobile apps Exception: The following APM conditions are not available from this API endpoint: Conditions targeting labels (dynamic targeting) Web transaction percentile conditions Baseline conditions Important The API Explorer provides information about other types of conditions using separate endpoints, including external services (APM and Mobile), plugins, and Synthetic monitoring. Consider all types of alert conditions when searching or updating. If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. Create conditions for policies To add conditions to policies, include these values in the API call: Your user key The policy_id (available from API Explorer: Alerts Policies > GET > List) The required condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Conditions > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"condition\": { \"type\": \"string\", \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"metric\": \"string\", \"gc_metric\": \"string\", \"condition_scope\": \"string\", \"violation_close_timer\": integer, \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"user_defined\": { \"metric\": \"string\", \"value_function\": \"string\" } } }' Copy The JSON response returns a condition id, which you will need to update or delete the condition. You can also view the condition id from API Explorer: Alerts Conditions > GET > List. Update conditions for policies To update conditions for policies, include these values in the API call: Your user key The condition's id (available from API Explorer: Alerts Conditions > GET > List) The required condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"condition\": { \"type\": \"string\", \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"metric\": \"string\", \"metric\": \"string\", \"gc_metric\": \"string\", \"condition_scope\": \"string\", \"violation_close_timer\": integer, \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"user_defined\": { \"metric\": \"string\", \"value_function\": \"string\" } } }' Copy Delete conditions from policies To delete conditions from policies, include these values in the API call: Your user key The condition_id (available from API Explorer: Alerts Conditions > GET > List) API Explorer: Alerts Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy List existing conditions for policies To view a list of existing conditions for your policy, use your REST API key or user key, and the associated policy_id in the API call. API Explorer: Alerts Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Conditions for NRQL These API functions include links to the API Explorer, where you can create, update, delete, or list NRQL conditions for your policies. Exception: NRQL baseline conditions are not available from this endpoint. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. Create NRQL conditions for policies Recommendation: Due to the way NRQL data is aggregated, set the nrql[since_value] to 3 or higher to prevent false positives. This equates to the Evaluation Offset value in the Alerts Condition UI. API Explorer: Alerts Nrql Conditions > POST > Create To create NRQL conditions for policies: curl -X POST 'https://api.newrelic.com/v2/alerts_nrql_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"nrql_condition\": { \"type\": \"string\", \"name\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean, \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"value_function\": \"string\", \"nrql\": { \"query\": \"string\", \"since_value\": \"string\" }, \"signal\": { \"aggregation_window\": \"string\", \"evaluation_offset\": \"string\", \"fill_option\": \"string\", \"fill_value\": \"string\" }, \"expiration\": { \"expiration_duration\": \"string\", \"open_violation_on_expiration\": boolean, \"close_violations_on_expiration\": boolean } } }' Copy If you set nrql[since_value] to 3 and nrql[query] to SELECT count FROM myEvent, New Relic evaluates the following query against the terms[threshold] value once per minute: SELECT count FROM myEvent SINCE 3 minutes ago UNTIL 2 minutes ago Copy If you set type as outlier, you can omit the value_function. However, two additional fields are required: expected_groups and ignore_overlap. For more information, see Alerts Conditions API field names. If you omit type or set it as static, it will default to standard NRQL alerting. Update NRQL conditions for policies Recommendation: Due to the way NRQL data is aggregated, set the nrql[since_value] to 3 or higher to prevent false positives. This allows three minutes to aggregate data, and equates to the Evaluation Offset value in the Alerts Condition UI. To update NRQL conditions for policies, include these values in the API call: Your user key The condition's id (available from API Explorer: Alerts Nrql Conditions > GET > List) The required condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Nrql Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_nrql_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"nrql_condition\": { \"name\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean, \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"value_function\": \"string\", \"nrql\": { \"query\": \"string\", \"since_value\": \"string\" } } }' Copy Delete NRQL conditions for policies To delete NRQL conditions from policies, include these values in the API call: Your user key The condition's id (available from API Explorer: Alerts Nrql Conditions > GET > List) API Explorer: Alerts Nrql Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_nrql_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy List existing NRQL conditions for policies To view a list of existing conditions for your alert policy, use your user key or REST API key, and the associated policy_id in the API call. API Explorer: Alerts Nrql Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_nrql_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Conditions for external services These API functions include links to the API Explorer, where you can create, update, delete, or list policy conditions. These calls are for conditions for external services. The API calls can be used with APM and Mobile apps. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. External services: Create conditions for policies To add conditions for external services to policies that have APM or Mobile apps, include these values in the API call: Your user key The policy_id (available from API Explorer: Alerts Policies > GET > List) The required external_service_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts External Service Conditions > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_external_service_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"external_service_condition\": { \"type\": \"string\", \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"external_service_url\": \"string\", \"metric\": \"string\", \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ] } }' Copy The JSON response returns a condition id, which you will need to update or delete the condition. You can also view the condition id from API Explorer: Alerts External Service Conditions > GET > List. External services: Update conditions for policies To update conditions for external services to policies that have APM or Mobile apps, include these values in the API call: Your user key The external service condition's id (available from API Explorer: Alerts External Service Conditions > GET > List) The required external_service_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts External Service Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_external_service_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"external_service_condition\": { \"type\": \"string\", \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"external_service_url\": \"string\", \"metric\": \"string\", \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ] } }' Copy External services: Delete conditions from policies To delete conditions for external services from policies with APM or Mobile apps, include these values in the API call: Your user key The condition_id (available from API Explorer: Alerts External Service Conditions > GET > List) API Explorer: Alerts External Service Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_external_service_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy External services: List existing conditions for policies To view a list of existing conditions for policies with external service apps (APM or Mobile), use your user key or REST API key and the associated policy_id in the API call. API Explorer: Alerts External Service Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_external_service_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Conditions for Synthetic monitoring These API functions include links to the API Explorer, where you can create, update, delete, or list conditions for your alert policies. The API calls can be used with Synthetic monitoring. Synthetics: Create conditions for policies To add conditions to policies for Synthetic monitoring, include these values in the API call: Your user key The policy_id (available from API Explorer: Alerts Policies > GET > List) The required synthetics_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Synthetics Conditions > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_synthetics_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"synthetics_condition\": { \"name\": \"string\", \"monitor_id\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean } }' Copy The JSON response returns a condition id, which you will need to update or delete the condition. You can also view the condition id from API Explorer: Alerts Synthetics Conditions > GET > List. Synthetic monitoring: Update conditions for policies To update policy conditions for Synthetic monitoring, include these values in the API call: Your user key The condition id (available from API Explorer: Alerts Synthetics Conditions > GET > List) The required synthetics_condition values in the API call (described in the API Explorer page to create alert conditions for Synthetics and in the Alerts conditions API glossary) API Explorer: Alerts Synthetics Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_synthetics_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"synthetics_condition\": { \"name\": \"string\", \"monitor_id\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean } }' Copy Synthetic monitoring: Delete conditions from policies To delete policy conditions for Synthetic monitoring, include these values in the API call: Your user key The condition_id (available from API Explorer: Alerts Synthetics Conditions > GET > List) API Explorer: Alerts Synthetics Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_synthetics_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy Synthetic monitoring: List existing conditions for policies To view a list of existing policy conditions for Synthetic monitoring, use your user key or REST API key, and the associated policy_id in the API call. API Explorer: Alerts Synthetics Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_synthetics_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Conditions for plugins These API functions include links to the API Explorer, where you can create, update, delete, or list conditions for your alert policies. The API calls can be used with plugins from New Relic's Plugin Central. Plugins: Create conditions for policies To add conditions to policies for plugin components or instances, include these values in the API call: Your user key The policy_id (available from API Explorer: Alerts Policies > GET > List) The required plugins_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Plugins Conditions > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_plugins_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"plugins_condition\": { \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"metric_description\": \"string\", \"metric\": \"string\", \"value_function\": \"string\", \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"plugin\": { \"id\": \"string\", \"guid\": \"string\" } } }' Copy The JSON response returns a condition id, which you will need to update or delete the condition. You can also view the condition id from API Explorer: Alerts Plugins Conditions > GET > List. Plugins: Update conditions for policies To update policy conditions for plugin components or instances, include these values in the API call: Your user key The condition id (available from API Explorer: Alerts Plugins Conditions > GET > List) The required plugins_condition values in the API call (described in the API Explorer page to create alert conditions for plugins and in the Alerts conditions API glossary) API Explorer: Alerts Plugins Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_plugins_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"plugins_condition\": { \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"metric_description\": \"string\", \"metric\": \"string\", \"value_function\": \"string\", \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"plugin\": { \"id\": \"string\", \"guid\": \"string\" } } }' Copy Plugins: Delete conditions from policies To delete conditions from policies for plugin components or instances, include these values in the API call: Your user key The condition id (available from API Explorer: Alerts Plugins Conditions > GET > List) API Explorer: Alerts Plugins Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_plugins_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy Plugins: List existing conditions for policies To view a list of existing conditions for policies with plugin components or instances, use your user key or REST API key, and the associated policy_id in the API call. API Explorer: Alerts Plugins Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_plugins_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Alert activity: Events, violations, incidents These API functions include links to the API Explorer, where you can view information about events, violations, and incidents for your alert policies. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. List Events To view events for entities monitored by APM, Browser, Mobile, Plugins, Synthetic monitoring, and Alerts, include these values in the API call: Your user key or REST API key Other optional values to use as filters (described in the API Explorer page) that depend on the type of product (browser monitoring, mobile monitoring, etc.), entity (as apps or key transactions for APM, synthetic monitoring, etc.), and type of event (notification, deployment, instrumentation, etc.) An optional pagination value API Explorer: Alerts Events > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_events.json' \\ -H 'Api-Key:$API_KEY' -i Copy List Violations To view violations for any entity monitored for your account, include these values in the API call: Your user key or REST API key An optional flag to show only those violations that are currently open An optional pagination value API Explorer: Alerts Violations > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_violations.json' \\ -H 'Api-Key:$API_KEY' -i Copy Tip To find policy, condition, and incident information: take the IDs found in the links section in the violations property and place them into the URLs contained in the outer links property of the payload. List Incidents To view incidents for any entity monitored for your account, include these values in the API call: Your user key or REST API key An optional flag to show only those incidents that are currently open An optional flag to exclude violation data from response An optional pagination value API Explorer: Alerts Incidents > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_incidents.json' \\ -H 'Api-Key:$API_KEY' -i Copy Show Incident To show a single incident associated with your account, include these values in the API call: Your user key or REST API key An incident ID API Explorer: Alerts Incidents > GET > Show curl -X GET 'https://api.newrelic.com/v2/alerts_incidents/{id}.json' \\ -H 'Api-Key:$API_KEY' -i Copy Acknowledge Incident To acknowledge an incident associated with your account, include these values in the API call: Your user key An incident ID API Explorer: Alerts Incidents > PUT > Acknowledge curl -X PUT 'https://api.newrelic.com/v2/alerts_incidents/{id}/acknowledge.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' Copy Close Incident To close an incident associated with your account, include these values in the API call: Your user key An incident ID API Explorer: Alerts Incidents > PUT > Close curl -X PUT 'https://api.newrelic.com/v2/alerts_incidents/{id}/close.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' Copy Alert entity conditions These API functions include links to the API Explorer, where you can list, add and remove entities in the conditions for your alert policies. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. List condition by entity To view the conditions an entity is part of for APM, Browser, Mobile, key transactions, and Plugins, include these values in the API call: Your user key or REST API key The entity_id This is the specific entity (alert target) to be monitored. The entity_type, which must be one of the following: Application BrowserApplication MobileApplication KeyTransaction Plugin API Explorer: Alerts Entity Conditions > GET > list curl -X GET 'https://api.newrelic.com/v2/alerts_entity_conditions/$ENTITY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -G -d 'entity_type=$ENTITY_TYPE' Copy Add an entity to a condition To add an entity to a condition, include these values in the API call: Your user key The entity_id This is the entity (alert target) to be monitored. It is the numeric ID for the APM application, browser app, plugin, key transaction, or mobile app. The condition_id (available from API Explorer: Alerts Conditions > GET > List) The entity_type, which must be one of the following: Application BrowserApplication MobileApplication KeyTransaction Plugin API Explorer: Alerts Entity Conditions > PUT > Add curl -X PUT 'https://api.newrelic.com/v2/alerts_entity_conditions/$ENTITY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -G -d 'entity_type=$ENTITY_TYPE&condition_id=$CONDITION_ID' Copy Remove an entity from a condition To remove an entity being monitored from a condition, include these values in the API call: Your user key The entity_id This is the specific monitored entity (alert target) to be removed. It is the numeric ID for the APM application, browser app, plugin, key transaction, or mobile app. The condition_id (available from API Explorer: Alerts Conditions > GET > List) The entity_type, which must be one of the following: Application BrowserApplication MobileApplication KeyTransaction Plugin API Explorer: Alerts Entity Conditions > DELETE > Remove curl -X DELETE 'https://api.newrelic.com/v2/alerts_entity_conditions/$ENTITY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -G -d 'entity_type=$ENTITY_ID&condition_id=$CONDITION_ID' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 181.5088,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>REST</em> <em>API</em> calls for <em>alerts</em>",
        "sections": "<em>REST</em> <em>API</em> calls for <em>alerts</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "Our <em>REST</em> <em>API</em> (v2) allows you to configure settings for <em>alerts</em>. The <em>API</em> Explorer also includes the curl request format, available parameters, potential response status codes, and JSON response structure for each of the available <em>API</em> calls. You can also create <em>alert</em> conditions in the UI. Important"
      },
      "id": "603ec3d064441f50e94e8847"
    },
    {
      "sections": [
        "Intro to using Alerts via NerdGraph API",
        "Alerts features you can manage with NerdGraph",
        "NerdGraph API explorer",
        "Tip",
        "Queries",
        "Mutations"
      ],
      "title": "Intro to using Alerts via NerdGraph API",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alerts and Nerdgraph"
      ],
      "external_id": "62c3f9bdca2acc3e9257b07970a717ee2ab0548f",
      "image": "https://docs.newrelic.com/static/6551638ff382e1ef38324cd82dca1214/e2c15/alerts_query_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-examples/",
      "published_at": "2021-05-28T18:40:20Z",
      "updated_at": "2021-04-21T16:08:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can manage your policies, conditions, and muting rules programmatically using our GraphQL NerdGraph API. This is a powerful alternative to managing them in New Relic One or through the REST API. Alerts features you can manage with NerdGraph Here's what you can do in NerdGraph: Manage policies Use NRQL conditions Muting rules: suppress notifications The easiest way to discover alerts queries and mutations is through the NerdGraph API explorer. NerdGraph API explorer Our NerdGraph API explorer is a GraphiQL editor where you can prototype queries and mutations. Here are some examples showing how to find fields for queries and mutations. Tip For general information about NerdGraph, see Introduction to NerdGraph. Queries To explore the various queries, look for the available queries under the actor.account.alerts namespace in NerdGraph API explorer: Mutations To explore various mutations, look in the alerts dropdown in the NerdGraph API explorer:",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.139,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to using <em>Alerts</em> via NerdGraph <em>API</em>",
        "sections": "Intro to using <em>Alerts</em> via NerdGraph <em>API</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "You can manage your policies, conditions, and muting rules programmatically using our GraphQL NerdGraph <em>API</em>. This is a powerful alternative to managing them in <em>New</em> <em>Relic</em> One or through the <em>REST</em> <em>API</em>. <em>Alerts</em> features you can manage with NerdGraph Here&#x27;s what you can do in NerdGraph: Manage policies"
      },
      "id": "6043fe3864441f2dd2378ee8"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/rest-api-alerts/manage-entities-alerts-conditions": [
    {
      "sections": [
        "Alerts conditions API field names",
        "Required and optional fields",
        "Field definitions",
        "aggregation_window",
        "close_violations_on_expiration",
        "condition_scope",
        "enabled",
        "entities",
        "evaluation_offset",
        "expected_groups",
        "expiration_duration",
        "external_service_url",
        "fill_option",
        "fill_value",
        "ignore_overlap",
        "metric",
        "Alerts plugin conditions",
        "Alerts conditions",
        "Alerts external service conditions",
        "metric_description",
        "monitor_id",
        "name",
        "nrql[query]",
        "nrql[since_value]",
        "open_violation_on_expiration",
        "plugin[guid]",
        "plugin[id]",
        "runbook_url",
        "terms[duration]",
        "terms[operator]",
        "terms[priority]",
        "terms[threshold]",
        "terms[time_function]",
        "type",
        "user_defined[metric] (optional)",
        "user_defined[value_function] (optional)",
        "value_function",
        "violation_time_limit_seconds",
        "violation_close_timer"
      ],
      "title": "Alerts conditions API field names",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "REST API alerts"
      ],
      "external_id": "5b098758aa368fade60befbff92ce025f8022f51",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/rest-api-alerts/alerts-conditions-api-field-names/",
      "published_at": "2021-05-28T10:42:07Z",
      "updated_at": "2021-05-11T06:48:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The REST API endpoints allow you to create conditions for your policies. This glossary contains the names and descriptions of each of the fields that you can use to define or update a condition. Required and optional fields The API includes four types of New Relic Alerts conditions: APM External services Synthetic monitoring Plugins All of the fields used with a specific condition type are required except for these optional fields: enabled (defaults to false) runbook_url user_defined Field definitions Not every field listed in this glossary is required for every condition type. The condition type for which a field must be used is listed in each description. aggregation_window Streaming alerts gathers data together into specific amounts of time before running the function in the NRQL query. These windows of time are customizable. The default is 1 minute. The maximum is 15 minutes. Data points are collected together based their timestamps and reported as a batch. The customizable aggregation window provides greater flexibility and fewer false violations when alerting on irregular or less frequent data points. In the UI, under Advanced signal settings, this is the Aggregation window field. close_violations_on_expiration When true, this closes all currently open violations when no signal is heard within the expiration_duration time. The default is False. condition_scope This field allows you to scope a condition to either a JVM instance or to a whole application. This may be one of the strings: instance application Used for: Conditions Entity conditions For instance-based and JVM health metrics, see also violation_close_timer. enabled This is the status of your alert condition and is optional. The default is false. This field may be used to enable or disable a condition for maintenance or testing periods. Used for: Conditions External service conditions Synthetic monitoring conditions Plugin conditions entities This is an array of entity IDs identifying the objects which will be monitored with your condition. These may be application IDs, browser IDs, plugin IDs, key transaction IDs, external service IDs, etc. These are entered as a series of comma separated integers if there is more than one. Used for: Conditions External service conditions Plugin conditions evaluation_offset The offset is how long we wait for late data before evaluating each aggregation window. Waiting longer gives a more accurate signal but increases latency. The default is 3 minutes. In the UI, under Advanced signal settings, this is the Offset evaluation by field. expected_groups This is the number of groups you expect to see at any given time. It is used in combination with the ignore_overlap option. Used for: NRQL outlier conditions expiration_duration How long to wait, in seconds, after the last data point is received by our platform before considering the signal as lost. This is based on the time when data arrives and not on data timestamps. The default is null. Add a value to enable loss of signal detection. external_service_url This is the URL of the external service to be monitored. This string must not include the protocol. For example, use example.com, not https://example.com. Used for: External service conditions fill_option For sporadic data, you can avoid false alerts by filling the gaps (empty windows) with synthetic data. none: (Default) Use this if you don’t want to take any action on empty aggregation windows. On evaluation, an empty aggregation window will reset the threshold duration timer. For example, if a condition says that all aggregation windows must have data points above the threshold for 5 minutes, and 1 of the 5 aggregation windows is empty, then the condition won’t be in violation. static: Use this if you’d like to insert a custom static value into the empty aggregation windows before they’re evaluated. This option has an additional, required parameter of fillValue that specifies what static value should be used. This defaults to 0. last_value: Use this to insert the last seen value before evaluation occurs. We maintain the state of the last seen value for 2 hours. In the UI, under Advanced signal settings, this is the Fill data gaps with field. fill_value This is the value used by the fill_option custom value. The default is 0. ignore_overlap If disabled, this looks for a convergence (or overlapping) of groups. If the condition is looking for two or more groups, and the returned values can't be separated into that number of distinct groups, then that will also produce a violation. This type of overlap event is represented on a chart by group bands touching. Used for: NRQL outlier conditions metric The metric field is used for three alert categories. The exact parameters available for use depend on the setting in the type field. These are listed below according to their alert type field. Alerts plugin conditions For Plugin conditions this is the metric, which has been defined in a plugin, that will be used to trigger a notification. Alerts conditions The value specified in the type field controls which of the parameters may be specified. The type field and corresponding available parameter names are listed in the following table. Only one may be specified. type Parameter apm_app_metric apdex error_percentage response_time_web response_time_background throughput_web throughput_background user_defined apm_kt_metric apdex error_percentage error_count response_time throughput browser_metric end_user_apdex total_page_load page_rendering web_application network dom_processing request_queuing ajax_response_time page_views_with_js_errors page_view_throughput ajax_throughput user_defined browser_metric_baseline page_view_throughput average_response_time ajax_response_time ajax_application_time mobile_metric database images json, network view_loading network_error_percentage status_error_percentage user_defined Alerts external service conditions The value specified in the type field controls which of the parameters may be specified. The type field and corresponding available parameter names are listed in the following table. Only one may be specified. type Parameter apm_external_service apdex error_percentage response_time_web response_time_background throughput_web throughput_background user_defined apm_app_metric_baseline external_service_transaction_time error_count database_transaction_time throughput_web response_time_web non_web_transaction_time web_transaction_database_time non_web_transaction_database_time mobile_external_service response_time_average response_time_minimum response_time_maximum throughput network_failure_percentage http_status_error_percentage metric_description This is a title for the metric which is displayed in notifications. Make this descriptive and unique so the reader will understand the nature of plugin metric being used to trigger an alert. Used for: Plugin conditions monitor_id This is the GUID of the Synthetic monitoring to alert on. Used for: Synthetic monitoring conditions name This condition title will allow to you identify it in the UI. Follow the guidelines for making this descriptive but short. Used for: Conditions External service conditions Synthetic monitoring conditions Plugin conditions nrql[query] This is the NRQL query that alerts monitors as part of a NRQL condition. Used for: NRQL conditions nrql[since_value] This is the timeframe (in minutes) in which to evaluate the specified NRQL query. since_value must be between 1 and 20. Used for: NRQL conditions open_violation_on_expiration When true, this opens a loss of signal violation when no signal within the expiration_duration time. The default is False. plugin[guid] This is the GUID of the plugin for which the trigger is being defined. Used for: Plugin conditions plugin[id] This is the ID of the plugin for which the trigger is being defined. Used for: Plugin conditions runbook_url The runbook URL to display in notifications. This field is optional. Used for: Conditions External service conditions Synthetic monitoring conditions Plugin conditions terms[duration] This is the time (in minutes) for the condition to persist before triggering an event. It corresponds to the duration set when adding a threshold in the UI. Used for: Conditions terms[operator] This determines what comparison will be used between the value_function and the terms [ threshold] value to trigger an event. It corresponds to the operation selected when adding a threshold in the UI. It must be one of the following strings: above below equal Used for: Conditions External service conditions Plugin conditions terms[priority] This corresponds to the severity level selected when setting the threshold values for the condition in the UI. This must be one of the following strings: critical warning Used for: Conditions External service conditions Plugin conditions terms[threshold] This is the threshold that the value_function must be compared to using the terms [ operator] for an event to be triggered. It corresponds to the numeric value specified in the UI when adding the threshold values. This is a numeric value and must be 0 (zero) or greater. Used for: Conditions External service conditions Plugin conditions terms[time_function] This corresponds to the settings made in the UI when adding the threshold values. The choices are: all (corresponding to for at least in the UI) any (corresponding to at least once in in the UI) Used for: Conditions External service conditions Plugin conditions type This defines the type of metric that will be used for the alert. Allowable content for the metric field depends on the type value chosen. There are two product categories : Alerts conditions For this category, type is set to one of the following strings indicating the type of alerts condition. type Use apm_app_metric APM application metric will trigger an alert. apm_app_metric_baseline APM application metric will trigger an alert (using a baseline threshold). apm_kt_metric APM key transaction metric will trigger an alert. browser_metric Browser metric will trigger an alert. browser_metric_baseline Browser metric will trigger an alert (using a baseline threshold). mobile_metric Mobile metric will trigger an alert. Used for: Conditions Alerts external service conditions For this category, type is set to one of the following strings indicating the type of external service condition. type Use apm_external_service APM external metric will trigger an alert. mobile_external_service Mobile external metric will trigger an alert. Used for: External service conditions user_defined[metric] (optional) This is the name of a user defined custom metric to be used to determine if an event should be triggered. The user_defined [ value_function] associated with the metric is compared with the terms [ threshold] value when evaluating if an incident should be triggered. The comparison is performed using the operator defined by terms [ operator]. Used for: Conditions External service conditions Synthetic monitoring conditions Plugin conditions user_defined[value_function] (optional) This is the numeric value obtained from the custom metric specified by user_defined [ metric]. It is compared with the terms [ threshold] value when evaluating if an incident should be triggered. The comparison is performed using the operator defined by terms [ operator]. One of these value functions must be specified: average min max total sample_size Used for: Conditions value_function This is the value function used from the plugin metric. This may be one of the strings: min max average sample_size total percent Used for: Plugin conditions When used for a NRQL condition, the options are: single_value (condition is evaluated based on each query's returned value) sum (condition is evaluated based on the sum of each query's returned values over the specified duration) violation_time_limit_seconds Use to automatically close instance-based violations after the number of seconds specified. Must be one of these values: 3600 7200 14400 28800 43200 86400 Used for: Location conditions NRQL conditions violation_close_timer Use to automatically close instance-based violations, including JVM health metric violations, after the number of hours specified. Must be one of these values: 1 2 4 8 12 24 Used for: apm_app_metric (with condition_scope set to instance) apm_jvm_metric",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 212.19582,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> conditions <em>API</em> field names",
        "sections": "<em>Alerts</em> conditions <em>API</em> field names",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "The <em>REST</em> <em>API</em> endpoints allow you to create conditions for your policies. This glossary contains the names and descriptions of each of the fields that you can use to define or update a condition. Required and optional fields The <em>API</em> includes four types of <em>New</em> <em>Relic</em> <em>Alerts</em> conditions: APM External"
      },
      "id": "604428f5e7b9d22c3a579a05"
    },
    {
      "sections": [
        "REST API calls for alerts",
        "Important",
        "Available data and functions via API",
        "Conditions excluded from the REST API",
        "Alert policies",
        "Create new policies",
        "Update policies",
        "Delete existing policies",
        "List existing policies",
        "Notification channels",
        "Create new notification channels",
        "Email channel",
        "OpsGenie channel",
        "Slack channel",
        "VictorOps channel",
        "PagerDuty channel",
        "Webhook (json) channel",
        "Webhook (x-www-form-urlencoded) channel",
        "Delete existing notification channels",
        "List existing notification channels",
        "Update notification channels associated with policies",
        "Delete notification channels associated with policies",
        "Conditions for APM, Browser, Mobile",
        "Create conditions for policies",
        "Update conditions for policies",
        "Delete conditions from policies",
        "List existing conditions for policies",
        "Conditions for NRQL",
        "Create NRQL conditions for policies",
        "Update NRQL conditions for policies",
        "Delete NRQL conditions for policies",
        "List existing NRQL conditions for policies",
        "Conditions for external services",
        "External services: Create conditions for policies",
        "External services: Update conditions for policies",
        "External services: Delete conditions from policies",
        "External services: List existing conditions for policies",
        "Conditions for Synthetic monitoring",
        "Synthetics: Create conditions for policies",
        "Synthetic monitoring: Update conditions for policies",
        "Synthetic monitoring: Delete conditions from policies",
        "Synthetic monitoring: List existing conditions for policies",
        "Conditions for plugins",
        "Plugins: Create conditions for policies",
        "Plugins: Update conditions for policies",
        "Plugins: Delete conditions from policies",
        "Plugins: List existing conditions for policies",
        "Alert activity: Events, violations, incidents",
        "List Events",
        "List Violations",
        "Tip",
        "List Incidents",
        "Show Incident",
        "Acknowledge Incident",
        "Close Incident",
        "Alert entity conditions",
        "List condition by entity",
        "Add an entity to a condition",
        "Remove an entity from a condition"
      ],
      "title": "REST API calls for alerts",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "REST API alerts"
      ],
      "external_id": "7e36876e5725bfa63cbd6aadd543e98060f5e118",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/rest-api-alerts/rest-api-calls-alerts/",
      "published_at": "2021-05-28T12:32:31Z",
      "updated_at": "2021-04-05T23:18:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our REST API (v2) allows you to configure settings for alerts. The API Explorer also includes the curl request format, available parameters, potential response status codes, and JSON response structure for each of the available API calls. You can also create alert conditions in the UI. Important For infrastructure alerting, see REST API for infrastructure monitoring alerts. Available data and functions via API REST API functions Comments View account data In general, any role can use a user key or REST API key with GET > List functions to view alerts data. The account Owner and Admins may use their API key. List output will be paginated. Available functions include: Alert policies Notification channels Conditions for APM, Browser, and Mobile (Some limitations apply.) Conditions for external services Conditions for Synthetic monitoring Conditions for Plugins Conditions for NRQL (Some limitations apply.) Events Violations Incidents Maintain account data You may have an Owner or Admin role in your account and a user key or have a custom role that grants permissions to manage Alerts and a user key in order to use any maintenance function, including POST > Create, PUT > Add, PUT > Update, and DELETE. Conditions excluded from the REST API These types of conditions do not have available endpoints in the API: APM: Web transaction percentiles, conditions targeting labels, and baselines NRQL: Baselines Alert policies These API functions include links to the API Explorer, where you can create, delete, or list policies. Important If your account hosts data in the EU data center, ensure you're using the proper API endpoints for EU region accounts. Create new policies To add new policies, use your user key and include these two values in the API call: Required values Definition Incident incident_preference Determines how Alerts will create incidents and group violations. This must be one of the following: PER_POLICY (default): Roll up by policy. PER_CONDITION: Roll up by condition. PER_CONDITION_AND_TARGET: Roll up by target and condition. Policy name The policy name is required. Leaving it unchanged will create a policy called string. API Explorer: Alerts Policies > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_policies.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"policy\": { \"incident_preference\": \"string\", \"name\": \"string\" } }' Copy Update policies Use this API to update an existing policy's name and incident_preference. You'll need your user key. Required values Definition id Required. To find a policy's ID, use either of these options: From the UI: On a policy's UI page, find the ID under the policy name. With the API: Use the List policies API. Incident incident_preference Determines how alerts will create incidents and group violations. Must be one of the following: PER_POLICY (default): Roll up by policy. PER_CONDITION: Roll up by condition. PER_CONDITION_AND_TARGET: Roll up by target and condition. Policy name Required. If you do not change the name, it defaults to a policy called string. To find a policy's exact name, use the List policies API. API Explorer: Alerts Policies > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_policies/{id}.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"policy\": { \"incident_preference\": \"string\", \"name\": \"string\" } }' Copy Delete existing policies To delete an existing policy, use your user key, and include the policy_id (available from API Explorer: Alerts Policies > GET > List) in the API call: API Explorer: Alerts Policies > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy List existing policies To view a list of existing policies for your account, use your user key, and include these optional values in the API call: Optional policy name filter Optional pagination value API Explorer: Alerts Policies > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_policies.json' \\ -H 'Api-Key:$API_KEY' -i Copy Notification channels These API functions include links to the API Explorer, where you can create, delete, or list Alerts notification channels. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. Create new notification channels To add new notification channels, use your user key and include these values in the API call: New channel's name Type of channel Configuration values The API Explorer shows the format for required configuration values for each type of notification channel. API Explorer: Alerts Channels > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_channels.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"channel\": { \"name\": \"string\", \"type\": \"string\", \"configuration\": \"hash\" } }' Copy The \"hash\" place holder in this example must be replaced by one of the following JSON blocks with the appropriate values substituted: Email channel { \"recipients\" : \"test@google.com\", \"include_json_attachment\" : true } Copy OpsGenie channel { \"api_key\": \"abc123\", \"teams\": \"team1\", \"tags\": \"tag1\", \"recipients\": \"me@me.com\" } Copy Slack channel { \"url\": \"http://test.com\", \"channel\": \"channel1\" } Copy VictorOps channel { \"key\": \"mykey\", \"route_key\": \"theroute\" } Copy PagerDuty channel { \"service_key\": \"myservicekey\" } Copy Webhook (json) channel This example shows the default payload inserted. (The payload attribute is optional.) The payload can be customized to have different keys than the ones shown and will be sent with the $ prefixed attributes interpolated prior to delivery. Important The condition_id is deprecated. Instead, use condition_family_id. { \"base_url\": \"http://test.com\", \"auth_username\": \"username\", \"auth_password\": \"password\", \"payload_type\": \"application/json\", \"headers\": { \"header1\": \"test\", \"header2\": \"test\" } \"payload\": { \"account_id\": \"$ACCOUNT_ID\", \"account_name\": \"$ACCOUNT_NAME\", \"closed_violations_count_critical\": \"$CLOSED_VIOLATIONS_COUNT_CRITICAL\", \"closed_violations_count_warning\": \"$CLOSED_VIOLATIONS_COUNT_WARNING\", \"condition_family_id\": \"$CONDITION_FAMILY_ID\", \"condition_id\": \"$CONDITION_ID\", \"condition_name\": \"$CONDITION_NAME\", \"current_state\": \"$EVENT_STATE\", \"details\": \"$EVENT_DETAILS\", \"duration\": \"$DURATION\", \"event_type\": \"$EVENT_TYPE\", \"incident_acknowledge_url\": \"$INCIDENT_ACKNOWLEDGE_URL\", \"incident_id\": \"$INCIDENT_ID\", \"incident_url\": \"$INCIDENT_URL\", \"open_violations_count_critical\": \"$OPEN_VIOLATIONS_COUNT_CRITICAL\", \"open_violations_count_warning\": \"$OPEN_VIOLATIONS_COUNT_WARNING\", \"owner\": \"$EVENT_OWNER\", \"policy_name\": \"$POLICY_NAME\", \"policy_url\": \"$POLICY_URL\", \"runbook_url\": \"$RUNBOOK_URL\", \"severity\": \"$SEVERITY\", \"targets\": \"$TARGETS\", \"timestamp\": \"$TIMESTAMP\", \"violation_callback_url\": \"$VIOLATION_CALLBACK_URL\", \"violation_chart_url\": \"$VIOLATION_CHART_URL\" } } Copy Webhook (x-www-form-urlencoded) channel This example shows the default payload inserted. (The payload attribute is optional.) The payload can be customized to have different keys than the ones shown and will be sent with the $ prefixed attributes interpolated prior to delivery. Important The condition_id is deprecated. Instead, use condition_family_id. { \"base_url\": \"http://test.com\", \"auth_username\": \"username\", \"auth_password\": \"password\", \"payload_type\": \"application/x-www-form-urlencoded\", \"headers\": { \"header1\": \"test\", \"header2\": \"test\" }, \"payload\": { \"account_id\": \"$ACCOUNT_ID\", \"account_name\": \"$ACCOUNT_NAME\", \"closed_violations_count_critical\": \"$CLOSED_VIOLATIONS_COUNT_CRITICAL\", \"closed_violations_count_warning\": \"$CLOSED_VIOLATIONS_COUNT_WARNING\", \"condition_family_id\": \"$CONDITION_FAMILY_ID\", \"condition_id\": \"$CONDITION_ID\", \"condition_name\": \"$CONDITION_NAME\", \"current_state\": \"$EVENT_STATE\", \"details\": \"$EVENT_DETAILS\", \"duration\": \"$DURATION\", \"event_type\": \"$EVENT_TYPE\", \"incident_acknowledge_url\": \"$INCIDENT_ACKNOWLEDGE_URL\", \"incident_id\": \"$INCIDENT_ID\", \"incident_url\": \"$INCIDENT_URL\", \"open_violations_count_critical\": \"$OPEN_VIOLATIONS_COUNT_CRITICAL\", \"open_violations_count_warning\": \"$OPEN_VIOLATIONS_COUNT_WARNING\", \"owner\": \"$EVENT_OWNER\", \"policy_name\": \"$POLICY_NAME\", \"policy_url\": \"$POLICY_URL\", \"runbook_url\": \"$RUNBOOK_URL\", \"severity\": \"$SEVERITY\", \"targets\": \"$TARGETS\", \"timestamp\": \"$TIMESTAMP\", \"violation_callback_url\": \"$VIOLATION_CALLBACK_URL\", \"violation_chart_url\": \"$VIOLATION_CHART_URL\" } } Copy Delete existing notification channels To delete an existing notification channels, use your user key, and include the channel_id (available from API Explorer: Alerts Channels > GET > List) in the API call: API Explorer: Alerts Channels > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_channels/{channel_id}.json' \\ -H 'Api-Key:$API_KEY' -i Copy List existing notification channels To view a list of existing notification channels for your account, use your user key and an optional pagination value in the API call. API Explorer: Alerts Channels > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_channels.json' \\ -H 'Api-Key:$API_KEY' -i Copy Update notification channels associated with policies You can associate a policy with one or more notification channels. You can also associate a notification channel with one or more policies. To add notification channels to policies, use your user key and these values in the API call: A policy_id value (available from API Explorer: Alerts Policies > GET > List) One or more channel_id values in an array, separated by commas or a new line (available from API Explorer: Alerts Channels > GET > List) API Explorer: Alerts Policy Channels > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_policy_channels.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -G -d 'policy_id=$POLICY_ID&channel_ids=channel_id' Copy Delete notification channels associated with policies You can associate a policy with one or more notification channels. You can also associate a notification channel with one or more alert policies. To remove a policy from a channel, or to remove a channel from a policy, use your user key and these values in the API call: The policy_id (available from API Explorer: Alerts Policies > GET > List) The channel_id (available from API Explorer: Alerts Channels > GET > List) API Explorer: Alerts Policy Channels > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_policy_channels.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'channel_id=CHANNEL_ID&policy_id=POLICY_ID' Copy Conditions for APM, Browser, Mobile These API functions include links to the API Explorer, where you can create, update, delete, or list policy conditions. These calls are for conditions with these types of entities: APM: Apps and key transactions Browser: Apps and key transactions Mobile: Mobile apps Exception: The following APM conditions are not available from this API endpoint: Conditions targeting labels (dynamic targeting) Web transaction percentile conditions Baseline conditions Important The API Explorer provides information about other types of conditions using separate endpoints, including external services (APM and Mobile), plugins, and Synthetic monitoring. Consider all types of alert conditions when searching or updating. If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. Create conditions for policies To add conditions to policies, include these values in the API call: Your user key The policy_id (available from API Explorer: Alerts Policies > GET > List) The required condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Conditions > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"condition\": { \"type\": \"string\", \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"metric\": \"string\", \"gc_metric\": \"string\", \"condition_scope\": \"string\", \"violation_close_timer\": integer, \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"user_defined\": { \"metric\": \"string\", \"value_function\": \"string\" } } }' Copy The JSON response returns a condition id, which you will need to update or delete the condition. You can also view the condition id from API Explorer: Alerts Conditions > GET > List. Update conditions for policies To update conditions for policies, include these values in the API call: Your user key The condition's id (available from API Explorer: Alerts Conditions > GET > List) The required condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"condition\": { \"type\": \"string\", \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"metric\": \"string\", \"metric\": \"string\", \"gc_metric\": \"string\", \"condition_scope\": \"string\", \"violation_close_timer\": integer, \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"user_defined\": { \"metric\": \"string\", \"value_function\": \"string\" } } }' Copy Delete conditions from policies To delete conditions from policies, include these values in the API call: Your user key The condition_id (available from API Explorer: Alerts Conditions > GET > List) API Explorer: Alerts Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy List existing conditions for policies To view a list of existing conditions for your policy, use your REST API key or user key, and the associated policy_id in the API call. API Explorer: Alerts Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Conditions for NRQL These API functions include links to the API Explorer, where you can create, update, delete, or list NRQL conditions for your policies. Exception: NRQL baseline conditions are not available from this endpoint. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. Create NRQL conditions for policies Recommendation: Due to the way NRQL data is aggregated, set the nrql[since_value] to 3 or higher to prevent false positives. This equates to the Evaluation Offset value in the Alerts Condition UI. API Explorer: Alerts Nrql Conditions > POST > Create To create NRQL conditions for policies: curl -X POST 'https://api.newrelic.com/v2/alerts_nrql_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"nrql_condition\": { \"type\": \"string\", \"name\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean, \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"value_function\": \"string\", \"nrql\": { \"query\": \"string\", \"since_value\": \"string\" }, \"signal\": { \"aggregation_window\": \"string\", \"evaluation_offset\": \"string\", \"fill_option\": \"string\", \"fill_value\": \"string\" }, \"expiration\": { \"expiration_duration\": \"string\", \"open_violation_on_expiration\": boolean, \"close_violations_on_expiration\": boolean } } }' Copy If you set nrql[since_value] to 3 and nrql[query] to SELECT count FROM myEvent, New Relic evaluates the following query against the terms[threshold] value once per minute: SELECT count FROM myEvent SINCE 3 minutes ago UNTIL 2 minutes ago Copy If you set type as outlier, you can omit the value_function. However, two additional fields are required: expected_groups and ignore_overlap. For more information, see Alerts Conditions API field names. If you omit type or set it as static, it will default to standard NRQL alerting. Update NRQL conditions for policies Recommendation: Due to the way NRQL data is aggregated, set the nrql[since_value] to 3 or higher to prevent false positives. This allows three minutes to aggregate data, and equates to the Evaluation Offset value in the Alerts Condition UI. To update NRQL conditions for policies, include these values in the API call: Your user key The condition's id (available from API Explorer: Alerts Nrql Conditions > GET > List) The required condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Nrql Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_nrql_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"nrql_condition\": { \"name\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean, \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"value_function\": \"string\", \"nrql\": { \"query\": \"string\", \"since_value\": \"string\" } } }' Copy Delete NRQL conditions for policies To delete NRQL conditions from policies, include these values in the API call: Your user key The condition's id (available from API Explorer: Alerts Nrql Conditions > GET > List) API Explorer: Alerts Nrql Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_nrql_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy List existing NRQL conditions for policies To view a list of existing conditions for your alert policy, use your user key or REST API key, and the associated policy_id in the API call. API Explorer: Alerts Nrql Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_nrql_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Conditions for external services These API functions include links to the API Explorer, where you can create, update, delete, or list policy conditions. These calls are for conditions for external services. The API calls can be used with APM and Mobile apps. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. External services: Create conditions for policies To add conditions for external services to policies that have APM or Mobile apps, include these values in the API call: Your user key The policy_id (available from API Explorer: Alerts Policies > GET > List) The required external_service_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts External Service Conditions > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_external_service_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"external_service_condition\": { \"type\": \"string\", \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"external_service_url\": \"string\", \"metric\": \"string\", \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ] } }' Copy The JSON response returns a condition id, which you will need to update or delete the condition. You can also view the condition id from API Explorer: Alerts External Service Conditions > GET > List. External services: Update conditions for policies To update conditions for external services to policies that have APM or Mobile apps, include these values in the API call: Your user key The external service condition's id (available from API Explorer: Alerts External Service Conditions > GET > List) The required external_service_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts External Service Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_external_service_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"external_service_condition\": { \"type\": \"string\", \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"external_service_url\": \"string\", \"metric\": \"string\", \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ] } }' Copy External services: Delete conditions from policies To delete conditions for external services from policies with APM or Mobile apps, include these values in the API call: Your user key The condition_id (available from API Explorer: Alerts External Service Conditions > GET > List) API Explorer: Alerts External Service Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_external_service_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy External services: List existing conditions for policies To view a list of existing conditions for policies with external service apps (APM or Mobile), use your user key or REST API key and the associated policy_id in the API call. API Explorer: Alerts External Service Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_external_service_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Conditions for Synthetic monitoring These API functions include links to the API Explorer, where you can create, update, delete, or list conditions for your alert policies. The API calls can be used with Synthetic monitoring. Synthetics: Create conditions for policies To add conditions to policies for Synthetic monitoring, include these values in the API call: Your user key The policy_id (available from API Explorer: Alerts Policies > GET > List) The required synthetics_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Synthetics Conditions > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_synthetics_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"synthetics_condition\": { \"name\": \"string\", \"monitor_id\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean } }' Copy The JSON response returns a condition id, which you will need to update or delete the condition. You can also view the condition id from API Explorer: Alerts Synthetics Conditions > GET > List. Synthetic monitoring: Update conditions for policies To update policy conditions for Synthetic monitoring, include these values in the API call: Your user key The condition id (available from API Explorer: Alerts Synthetics Conditions > GET > List) The required synthetics_condition values in the API call (described in the API Explorer page to create alert conditions for Synthetics and in the Alerts conditions API glossary) API Explorer: Alerts Synthetics Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_synthetics_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"synthetics_condition\": { \"name\": \"string\", \"monitor_id\": \"string\", \"runbook_url\": \"string\", \"enabled\": boolean } }' Copy Synthetic monitoring: Delete conditions from policies To delete policy conditions for Synthetic monitoring, include these values in the API call: Your user key The condition_id (available from API Explorer: Alerts Synthetics Conditions > GET > List) API Explorer: Alerts Synthetics Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_synthetics_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy Synthetic monitoring: List existing conditions for policies To view a list of existing policy conditions for Synthetic monitoring, use your user key or REST API key, and the associated policy_id in the API call. API Explorer: Alerts Synthetics Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_synthetics_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Conditions for plugins These API functions include links to the API Explorer, where you can create, update, delete, or list conditions for your alert policies. The API calls can be used with plugins from New Relic's Plugin Central. Plugins: Create conditions for policies To add conditions to policies for plugin components or instances, include these values in the API call: Your user key The policy_id (available from API Explorer: Alerts Policies > GET > List) The required plugins_condition values in the API call (described in the API Explorer page and in the Alerts conditions API glossary) API Explorer: Alerts Plugins Conditions > POST > Create curl -X POST 'https://api.newrelic.com/v2/alerts_plugins_conditions/policies/$POLICY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"plugins_condition\": { \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"metric_description\": \"string\", \"metric\": \"string\", \"value_function\": \"string\", \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"plugin\": { \"id\": \"string\", \"guid\": \"string\" } } }' Copy The JSON response returns a condition id, which you will need to update or delete the condition. You can also view the condition id from API Explorer: Alerts Plugins Conditions > GET > List. Plugins: Update conditions for policies To update policy conditions for plugin components or instances, include these values in the API call: Your user key The condition id (available from API Explorer: Alerts Plugins Conditions > GET > List) The required plugins_condition values in the API call (described in the API Explorer page to create alert conditions for plugins and in the Alerts conditions API glossary) API Explorer: Alerts Plugins Conditions > PUT > Update curl -X PUT 'https://api.newrelic.com/v2/alerts_plugins_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"plugins_condition\": { \"name\": \"string\", \"enabled\": boolean, \"entities\": [ integer ], \"metric_description\": \"string\", \"metric\": \"string\", \"value_function\": \"string\", \"runbook_url\": \"string\", \"terms\": [ { \"duration\": \"string\", \"operator\": \"string\", \"priority\": \"string\", \"threshold\": \"string\", \"time_function\": \"string\" } ], \"plugin\": { \"id\": \"string\", \"guid\": \"string\" } } }' Copy Plugins: Delete conditions from policies To delete conditions from policies for plugin components or instances, include these values in the API call: Your user key The condition id (available from API Explorer: Alerts Plugins Conditions > GET > List) API Explorer: Alerts Plugins Conditions > DELETE > Delete curl -X DELETE 'https://api.newrelic.com/v2/alerts_plugins_conditions/$CONDITION_ID.json' \\ -H 'Api-Key:$API_KEY' -i Copy Plugins: List existing conditions for policies To view a list of existing conditions for policies with plugin components or instances, use your user key or REST API key, and the associated policy_id in the API call. API Explorer: Alerts Plugins Conditions > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_plugins_conditions.json' \\ -H 'Api-Key:$API_KEY' -i \\ -d 'policy_id=$POLICY_ID' Copy Alert activity: Events, violations, incidents These API functions include links to the API Explorer, where you can view information about events, violations, and incidents for your alert policies. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. List Events To view events for entities monitored by APM, Browser, Mobile, Plugins, Synthetic monitoring, and Alerts, include these values in the API call: Your user key or REST API key Other optional values to use as filters (described in the API Explorer page) that depend on the type of product (browser monitoring, mobile monitoring, etc.), entity (as apps or key transactions for APM, synthetic monitoring, etc.), and type of event (notification, deployment, instrumentation, etc.) An optional pagination value API Explorer: Alerts Events > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_events.json' \\ -H 'Api-Key:$API_KEY' -i Copy List Violations To view violations for any entity monitored for your account, include these values in the API call: Your user key or REST API key An optional flag to show only those violations that are currently open An optional pagination value API Explorer: Alerts Violations > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_violations.json' \\ -H 'Api-Key:$API_KEY' -i Copy Tip To find policy, condition, and incident information: take the IDs found in the links section in the violations property and place them into the URLs contained in the outer links property of the payload. List Incidents To view incidents for any entity monitored for your account, include these values in the API call: Your user key or REST API key An optional flag to show only those incidents that are currently open An optional flag to exclude violation data from response An optional pagination value API Explorer: Alerts Incidents > GET > List curl -X GET 'https://api.newrelic.com/v2/alerts_incidents.json' \\ -H 'Api-Key:$API_KEY' -i Copy Show Incident To show a single incident associated with your account, include these values in the API call: Your user key or REST API key An incident ID API Explorer: Alerts Incidents > GET > Show curl -X GET 'https://api.newrelic.com/v2/alerts_incidents/{id}.json' \\ -H 'Api-Key:$API_KEY' -i Copy Acknowledge Incident To acknowledge an incident associated with your account, include these values in the API call: Your user key An incident ID API Explorer: Alerts Incidents > PUT > Acknowledge curl -X PUT 'https://api.newrelic.com/v2/alerts_incidents/{id}/acknowledge.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' Copy Close Incident To close an incident associated with your account, include these values in the API call: Your user key An incident ID API Explorer: Alerts Incidents > PUT > Close curl -X PUT 'https://api.newrelic.com/v2/alerts_incidents/{id}/close.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' Copy Alert entity conditions These API functions include links to the API Explorer, where you can list, add and remove entities in the conditions for your alert policies. Important If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. List condition by entity To view the conditions an entity is part of for APM, Browser, Mobile, key transactions, and Plugins, include these values in the API call: Your user key or REST API key The entity_id This is the specific entity (alert target) to be monitored. The entity_type, which must be one of the following: Application BrowserApplication MobileApplication KeyTransaction Plugin API Explorer: Alerts Entity Conditions > GET > list curl -X GET 'https://api.newrelic.com/v2/alerts_entity_conditions/$ENTITY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -G -d 'entity_type=$ENTITY_TYPE' Copy Add an entity to a condition To add an entity to a condition, include these values in the API call: Your user key The entity_id This is the entity (alert target) to be monitored. It is the numeric ID for the APM application, browser app, plugin, key transaction, or mobile app. The condition_id (available from API Explorer: Alerts Conditions > GET > List) The entity_type, which must be one of the following: Application BrowserApplication MobileApplication KeyTransaction Plugin API Explorer: Alerts Entity Conditions > PUT > Add curl -X PUT 'https://api.newrelic.com/v2/alerts_entity_conditions/$ENTITY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -G -d 'entity_type=$ENTITY_TYPE&condition_id=$CONDITION_ID' Copy Remove an entity from a condition To remove an entity being monitored from a condition, include these values in the API call: Your user key The entity_id This is the specific monitored entity (alert target) to be removed. It is the numeric ID for the APM application, browser app, plugin, key transaction, or mobile app. The condition_id (available from API Explorer: Alerts Conditions > GET > List) The entity_type, which must be one of the following: Application BrowserApplication MobileApplication KeyTransaction Plugin API Explorer: Alerts Entity Conditions > DELETE > Remove curl -X DELETE 'https://api.newrelic.com/v2/alerts_entity_conditions/$ENTITY_ID.json' \\ -H 'Api-Key:$API_KEY' -i \\ -G -d 'entity_type=$ENTITY_ID&condition_id=$CONDITION_ID' Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 181.5088,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>REST</em> <em>API</em> calls for <em>alerts</em>",
        "sections": "<em>REST</em> <em>API</em> calls for <em>alerts</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "Our <em>REST</em> <em>API</em> (v2) allows you to configure settings for <em>alerts</em>. The <em>API</em> Explorer also includes the curl request format, available parameters, potential response status codes, and JSON response structure for each of the available <em>API</em> calls. You can also create <em>alert</em> conditions in the UI. Important"
      },
      "id": "603ec3d064441f50e94e8847"
    },
    {
      "sections": [
        "Intro to using Alerts via NerdGraph API",
        "Alerts features you can manage with NerdGraph",
        "NerdGraph API explorer",
        "Tip",
        "Queries",
        "Mutations"
      ],
      "title": "Intro to using Alerts via NerdGraph API",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alerts and Nerdgraph"
      ],
      "external_id": "62c3f9bdca2acc3e9257b07970a717ee2ab0548f",
      "image": "https://docs.newrelic.com/static/6551638ff382e1ef38324cd82dca1214/e2c15/alerts_query_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-examples/",
      "published_at": "2021-05-28T18:40:20Z",
      "updated_at": "2021-04-21T16:08:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can manage your policies, conditions, and muting rules programmatically using our GraphQL NerdGraph API. This is a powerful alternative to managing them in New Relic One or through the REST API. Alerts features you can manage with NerdGraph Here's what you can do in NerdGraph: Manage policies Use NRQL conditions Muting rules: suppress notifications The easiest way to discover alerts queries and mutations is through the NerdGraph API explorer. NerdGraph API explorer Our NerdGraph API explorer is a GraphiQL editor where you can prototype queries and mutations. Here are some examples showing how to find fields for queries and mutations. Tip For general information about NerdGraph, see Introduction to NerdGraph. Queries To explore the various queries, look for the available queries under the actor.account.alerts namespace in NerdGraph API explorer: Mutations To explore various mutations, look in the alerts dropdown in the NerdGraph API explorer:",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.139,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to using <em>Alerts</em> via NerdGraph <em>API</em>",
        "sections": "Intro to using <em>Alerts</em> via NerdGraph <em>API</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "You can manage your policies, conditions, and muting rules programmatically using our GraphQL NerdGraph <em>API</em>. This is a powerful alternative to managing them in <em>New</em> <em>Relic</em> One or through the <em>REST</em> <em>API</em>. <em>Alerts</em> features you can manage with NerdGraph Here&#x27;s what you can do in NerdGraph: Manage policies"
      },
      "id": "6043fe3864441f2dd2378ee8"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/rest-api-alerts/rest-api-calls-alerts": [
    {
      "sections": [
        "Alerts conditions API field names",
        "Required and optional fields",
        "Field definitions",
        "aggregation_window",
        "close_violations_on_expiration",
        "condition_scope",
        "enabled",
        "entities",
        "evaluation_offset",
        "expected_groups",
        "expiration_duration",
        "external_service_url",
        "fill_option",
        "fill_value",
        "ignore_overlap",
        "metric",
        "Alerts plugin conditions",
        "Alerts conditions",
        "Alerts external service conditions",
        "metric_description",
        "monitor_id",
        "name",
        "nrql[query]",
        "nrql[since_value]",
        "open_violation_on_expiration",
        "plugin[guid]",
        "plugin[id]",
        "runbook_url",
        "terms[duration]",
        "terms[operator]",
        "terms[priority]",
        "terms[threshold]",
        "terms[time_function]",
        "type",
        "user_defined[metric] (optional)",
        "user_defined[value_function] (optional)",
        "value_function",
        "violation_time_limit_seconds",
        "violation_close_timer"
      ],
      "title": "Alerts conditions API field names",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "REST API alerts"
      ],
      "external_id": "5b098758aa368fade60befbff92ce025f8022f51",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/rest-api-alerts/alerts-conditions-api-field-names/",
      "published_at": "2021-05-28T10:42:07Z",
      "updated_at": "2021-05-11T06:48:57Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The REST API endpoints allow you to create conditions for your policies. This glossary contains the names and descriptions of each of the fields that you can use to define or update a condition. Required and optional fields The API includes four types of New Relic Alerts conditions: APM External services Synthetic monitoring Plugins All of the fields used with a specific condition type are required except for these optional fields: enabled (defaults to false) runbook_url user_defined Field definitions Not every field listed in this glossary is required for every condition type. The condition type for which a field must be used is listed in each description. aggregation_window Streaming alerts gathers data together into specific amounts of time before running the function in the NRQL query. These windows of time are customizable. The default is 1 minute. The maximum is 15 minutes. Data points are collected together based their timestamps and reported as a batch. The customizable aggregation window provides greater flexibility and fewer false violations when alerting on irregular or less frequent data points. In the UI, under Advanced signal settings, this is the Aggregation window field. close_violations_on_expiration When true, this closes all currently open violations when no signal is heard within the expiration_duration time. The default is False. condition_scope This field allows you to scope a condition to either a JVM instance or to a whole application. This may be one of the strings: instance application Used for: Conditions Entity conditions For instance-based and JVM health metrics, see also violation_close_timer. enabled This is the status of your alert condition and is optional. The default is false. This field may be used to enable or disable a condition for maintenance or testing periods. Used for: Conditions External service conditions Synthetic monitoring conditions Plugin conditions entities This is an array of entity IDs identifying the objects which will be monitored with your condition. These may be application IDs, browser IDs, plugin IDs, key transaction IDs, external service IDs, etc. These are entered as a series of comma separated integers if there is more than one. Used for: Conditions External service conditions Plugin conditions evaluation_offset The offset is how long we wait for late data before evaluating each aggregation window. Waiting longer gives a more accurate signal but increases latency. The default is 3 minutes. In the UI, under Advanced signal settings, this is the Offset evaluation by field. expected_groups This is the number of groups you expect to see at any given time. It is used in combination with the ignore_overlap option. Used for: NRQL outlier conditions expiration_duration How long to wait, in seconds, after the last data point is received by our platform before considering the signal as lost. This is based on the time when data arrives and not on data timestamps. The default is null. Add a value to enable loss of signal detection. external_service_url This is the URL of the external service to be monitored. This string must not include the protocol. For example, use example.com, not https://example.com. Used for: External service conditions fill_option For sporadic data, you can avoid false alerts by filling the gaps (empty windows) with synthetic data. none: (Default) Use this if you don’t want to take any action on empty aggregation windows. On evaluation, an empty aggregation window will reset the threshold duration timer. For example, if a condition says that all aggregation windows must have data points above the threshold for 5 minutes, and 1 of the 5 aggregation windows is empty, then the condition won’t be in violation. static: Use this if you’d like to insert a custom static value into the empty aggregation windows before they’re evaluated. This option has an additional, required parameter of fillValue that specifies what static value should be used. This defaults to 0. last_value: Use this to insert the last seen value before evaluation occurs. We maintain the state of the last seen value for 2 hours. In the UI, under Advanced signal settings, this is the Fill data gaps with field. fill_value This is the value used by the fill_option custom value. The default is 0. ignore_overlap If disabled, this looks for a convergence (or overlapping) of groups. If the condition is looking for two or more groups, and the returned values can't be separated into that number of distinct groups, then that will also produce a violation. This type of overlap event is represented on a chart by group bands touching. Used for: NRQL outlier conditions metric The metric field is used for three alert categories. The exact parameters available for use depend on the setting in the type field. These are listed below according to their alert type field. Alerts plugin conditions For Plugin conditions this is the metric, which has been defined in a plugin, that will be used to trigger a notification. Alerts conditions The value specified in the type field controls which of the parameters may be specified. The type field and corresponding available parameter names are listed in the following table. Only one may be specified. type Parameter apm_app_metric apdex error_percentage response_time_web response_time_background throughput_web throughput_background user_defined apm_kt_metric apdex error_percentage error_count response_time throughput browser_metric end_user_apdex total_page_load page_rendering web_application network dom_processing request_queuing ajax_response_time page_views_with_js_errors page_view_throughput ajax_throughput user_defined browser_metric_baseline page_view_throughput average_response_time ajax_response_time ajax_application_time mobile_metric database images json, network view_loading network_error_percentage status_error_percentage user_defined Alerts external service conditions The value specified in the type field controls which of the parameters may be specified. The type field and corresponding available parameter names are listed in the following table. Only one may be specified. type Parameter apm_external_service apdex error_percentage response_time_web response_time_background throughput_web throughput_background user_defined apm_app_metric_baseline external_service_transaction_time error_count database_transaction_time throughput_web response_time_web non_web_transaction_time web_transaction_database_time non_web_transaction_database_time mobile_external_service response_time_average response_time_minimum response_time_maximum throughput network_failure_percentage http_status_error_percentage metric_description This is a title for the metric which is displayed in notifications. Make this descriptive and unique so the reader will understand the nature of plugin metric being used to trigger an alert. Used for: Plugin conditions monitor_id This is the GUID of the Synthetic monitoring to alert on. Used for: Synthetic monitoring conditions name This condition title will allow to you identify it in the UI. Follow the guidelines for making this descriptive but short. Used for: Conditions External service conditions Synthetic monitoring conditions Plugin conditions nrql[query] This is the NRQL query that alerts monitors as part of a NRQL condition. Used for: NRQL conditions nrql[since_value] This is the timeframe (in minutes) in which to evaluate the specified NRQL query. since_value must be between 1 and 20. Used for: NRQL conditions open_violation_on_expiration When true, this opens a loss of signal violation when no signal within the expiration_duration time. The default is False. plugin[guid] This is the GUID of the plugin for which the trigger is being defined. Used for: Plugin conditions plugin[id] This is the ID of the plugin for which the trigger is being defined. Used for: Plugin conditions runbook_url The runbook URL to display in notifications. This field is optional. Used for: Conditions External service conditions Synthetic monitoring conditions Plugin conditions terms[duration] This is the time (in minutes) for the condition to persist before triggering an event. It corresponds to the duration set when adding a threshold in the UI. Used for: Conditions terms[operator] This determines what comparison will be used between the value_function and the terms [ threshold] value to trigger an event. It corresponds to the operation selected when adding a threshold in the UI. It must be one of the following strings: above below equal Used for: Conditions External service conditions Plugin conditions terms[priority] This corresponds to the severity level selected when setting the threshold values for the condition in the UI. This must be one of the following strings: critical warning Used for: Conditions External service conditions Plugin conditions terms[threshold] This is the threshold that the value_function must be compared to using the terms [ operator] for an event to be triggered. It corresponds to the numeric value specified in the UI when adding the threshold values. This is a numeric value and must be 0 (zero) or greater. Used for: Conditions External service conditions Plugin conditions terms[time_function] This corresponds to the settings made in the UI when adding the threshold values. The choices are: all (corresponding to for at least in the UI) any (corresponding to at least once in in the UI) Used for: Conditions External service conditions Plugin conditions type This defines the type of metric that will be used for the alert. Allowable content for the metric field depends on the type value chosen. There are two product categories : Alerts conditions For this category, type is set to one of the following strings indicating the type of alerts condition. type Use apm_app_metric APM application metric will trigger an alert. apm_app_metric_baseline APM application metric will trigger an alert (using a baseline threshold). apm_kt_metric APM key transaction metric will trigger an alert. browser_metric Browser metric will trigger an alert. browser_metric_baseline Browser metric will trigger an alert (using a baseline threshold). mobile_metric Mobile metric will trigger an alert. Used for: Conditions Alerts external service conditions For this category, type is set to one of the following strings indicating the type of external service condition. type Use apm_external_service APM external metric will trigger an alert. mobile_external_service Mobile external metric will trigger an alert. Used for: External service conditions user_defined[metric] (optional) This is the name of a user defined custom metric to be used to determine if an event should be triggered. The user_defined [ value_function] associated with the metric is compared with the terms [ threshold] value when evaluating if an incident should be triggered. The comparison is performed using the operator defined by terms [ operator]. Used for: Conditions External service conditions Synthetic monitoring conditions Plugin conditions user_defined[value_function] (optional) This is the numeric value obtained from the custom metric specified by user_defined [ metric]. It is compared with the terms [ threshold] value when evaluating if an incident should be triggered. The comparison is performed using the operator defined by terms [ operator]. One of these value functions must be specified: average min max total sample_size Used for: Conditions value_function This is the value function used from the plugin metric. This may be one of the strings: min max average sample_size total percent Used for: Plugin conditions When used for a NRQL condition, the options are: single_value (condition is evaluated based on each query's returned value) sum (condition is evaluated based on the sum of each query's returned values over the specified duration) violation_time_limit_seconds Use to automatically close instance-based violations after the number of seconds specified. Must be one of these values: 3600 7200 14400 28800 43200 86400 Used for: Location conditions NRQL conditions violation_close_timer Use to automatically close instance-based violations, including JVM health metric violations, after the number of hours specified. Must be one of these values: 1 2 4 8 12 24 Used for: apm_app_metric (with condition_scope set to instance) apm_jvm_metric",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 212.1958,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Alerts</em> conditions <em>API</em> field names",
        "sections": "<em>Alerts</em> conditions <em>API</em> field names",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "The <em>REST</em> <em>API</em> endpoints allow you to create conditions for your policies. This glossary contains the names and descriptions of each of the fields that you can use to define or update a condition. Required and optional fields The <em>API</em> includes four types of <em>New</em> <em>Relic</em> <em>Alerts</em> conditions: APM External"
      },
      "id": "604428f5e7b9d22c3a579a05"
    },
    {
      "sections": [
        "Intro to using Alerts via NerdGraph API",
        "Alerts features you can manage with NerdGraph",
        "NerdGraph API explorer",
        "Tip",
        "Queries",
        "Mutations"
      ],
      "title": "Intro to using Alerts via NerdGraph API",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alerts and Nerdgraph"
      ],
      "external_id": "62c3f9bdca2acc3e9257b07970a717ee2ab0548f",
      "image": "https://docs.newrelic.com/static/6551638ff382e1ef38324cd82dca1214/e2c15/alerts_query_0.png",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alerts-nerdgraph/nerdgraph-api-examples/",
      "published_at": "2021-05-28T18:40:20Z",
      "updated_at": "2021-04-21T16:08:00Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can manage your policies, conditions, and muting rules programmatically using our GraphQL NerdGraph API. This is a powerful alternative to managing them in New Relic One or through the REST API. Alerts features you can manage with NerdGraph Here's what you can do in NerdGraph: Manage policies Use NRQL conditions Muting rules: suppress notifications The easiest way to discover alerts queries and mutations is through the NerdGraph API explorer. NerdGraph API explorer Our NerdGraph API explorer is a GraphiQL editor where you can prototype queries and mutations. Here are some examples showing how to find fields for queries and mutations. Tip For general information about NerdGraph, see Introduction to NerdGraph. Queries To explore the various queries, look for the available queries under the actor.account.alerts namespace in NerdGraph API explorer: Mutations To explore various mutations, look in the alerts dropdown in the NerdGraph API explorer:",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 178.139,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Intro to using <em>Alerts</em> via NerdGraph <em>API</em>",
        "sections": "Intro to using <em>Alerts</em> via NerdGraph <em>API</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "You can manage your policies, conditions, and muting rules programmatically using our GraphQL NerdGraph <em>API</em>. This is a powerful alternative to managing them in <em>New</em> <em>Relic</em> One or through the <em>REST</em> <em>API</em>. <em>Alerts</em> features you can manage with NerdGraph Here&#x27;s what you can do in NerdGraph: Manage policies"
      },
      "id": "6043fe3864441f2dd2378ee8"
    },
    {
      "sections": [
        "Disable and enable alerts conditions using the API",
        "Requirements",
        "Enable and disable a condition",
        "Details on searching for condition ID",
        "Details on Update API requests",
        "Tip",
        "Example: Disable an APM condition",
        "For more help"
      ],
      "title": "Disable and enable alerts conditions using the API",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "REST API alerts"
      ],
      "external_id": "b0495cb75c078289751e98c434b9ba4caf73b26f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/rest-api-alerts/disable-enable-alerts-conditions-using-api/",
      "published_at": "2021-05-27T19:24:41Z",
      "updated_at": "2021-03-13T03:08:52Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In a policy, a condition identifies what triggers an alert. You can use the REST API to disable and enable conditions. You can also disable and enable conditions in New Relic One. Policies can't be enabled or disabled, whether via the API or the UI. Policies can only be created, deleted, or have their conditions changed. Requirements Modifying any attribute in a condition using the API requires: An API key and permissions to manage Alerts The condition's id (available from API Explorer: Alerts Conditions > GET > List) If your account hosts data in the EU data center, ensure you are using the proper API endpoints for EU region accounts. Enable and disable a condition The process for disabling or enabling a condition is the same general process for changing any attribute in a condition. A more detailed example comes after this general procedure: Find the ID for the policy that contains the condition you want to change. If the policy's ID is unknown, use the policy's name or type to make an API call and find the policy's ID. For more on this process, see List a single policy. With the policy ID, make an API call that returns the conditions associated with that policy. There are four different condition categories. If you don't know the category, this may require making up to four API calls in order to find the condition. Details on searching for condition ID If you don't know the category of the condition you want to change, you must search for it by making API calls using the four condition categories. Here are the different API call formats for the various condition categories. APM, Browser, and Mobile Conditions available: apm_app_metric, apm_kt_metric, browser_metric, and mobile_metric API Explorer link Get>List External services Conditions available: apm_external_service, mobile_external_service API Explorer link Get>List Synthetic monitoring API Explorer link Get>List Plugins API Explorer link Get>List For the returned JSON, find the JSON object of the condition you want to change. Copy and paste the condition's JSON in a text editor of your choice and edit the JSON. To enable the condition, set \"enabled\" to true. To disable the condition, set \"enabled\" to false. Update the condition by submitting your edited JSON via an Update API request. Our different products require different API requests. Details on Update API requests Use the Update API request that corresponds to the product in question: Conditions for APM, Browser, and Mobile Conditions available: apm_app_metric, apm_kt_metric, browser_metric, and mobile_metric API Explorer PUT>Update link Conditions for external services Conditions available: apm_external_service, mobile_external_service API Explorer PUT>Update Conditions for Synthetic monitoring) API Explorer PUT>Update Conditions for Plugins API Explorer PUT>Update Tip An Update API request can only change one condition at a time, it cannot update a vector of objects. For example, to change three conditions, you will have to make three separate requests. Example: Disable an APM condition The following example shows how to disable a condition for an apm_app_metric condition. With the exception of the types of API calls required, the process is similar to the process for changing other condition types. Obtain the policy_id of the policy you want to update. For an imaginary policy named Logjam Alert, the command would be: curl -X GET 'https://api.newrelic.com/v2/alerts_policies.json' \\ -H 'Api-Key:$API_KEY' -i \\ -G --data-urlencode 'filter[name]= Logjam Alert' <---<<< {policy_name} Copy The output for this request might look like: { \"policies\": [ { \"id\": 85, <---<<< $POLICY_ID \"incident_preference\": \"PER_POLICY\", \"name\": \"Logjam Alert\", \"created_at\": 1461176510393, \"updated_at\": 1461176510393 } ] } Copy List all of this policy's conditions and locate the {condition_id}: curl -X GET 'https://api.newrelic.com/v2/alerts_conditions.json' \\ -H 'X-Api-Key:$API_KEY' -i \\ -G -d 'policy_id=85' Copy The output for this request might look like: { \"conditions\": [ { \"id\": 12345, <---<<< $CONDITION_ID \"type\": \"apm_app_metric\", \"name\": \"Apdex (Low)\", \"enabled\": true, <---<<< Note the condition is enabled \"entities\": [ \"8288171\" ], \"metric\": \"apdex\", \"terms\": [ { \"duration\": \"5\", \"operator\": \"below\", \"priority\": \"critical\", \"threshold\": \"1\", \"time_function\": \"any\" } ] }, { \"id\": 2468, <---<<< another condition_id \"type\": \"apm_app_metric\", \"name\": \"Throughput (Low)\", ... } ] } Copy Copy the JSON for only the condition in question and paste it in a text editor. Change \"enabled\": true to \"enabled\": false. The edited JSON would look like: curl -X PUT 'https://api.newrelic.com/v2/alerts_conditions/12345.json' \\ -H 'X-Api-Key:$API_KEY' -i \\ -H 'Content-Type: application/json' \\ -d \\ '{ \"condition\": { \"type\": \"apm_app_metric\", \"name\": \"Apdex (Low)\", \"enabled\": false, <---<<< Changed to false \"entities\": [ \"8288171\" ], \"metric\": \"apdex\", \"terms\": [ { \"duration\": \"5\", \"operator\": \"below\", \"priority\": \"critical\", \"threshold\": \"1\", \"time_function\": \"any\" } ] } }' Copy Update the condition by submitting the edited condition JSON via an Update API request. For this specific condition, you would follow the steps in Update conditions for APM policies. Other product conditions would have other API requests, as detailed in Update API requests. For more help Additional documentation resources include: API calls for alerts (list of all API calls available) Using the API Explorer (using the API Explorer's user interface to get data in and data out of New Relic) Parts of the API Explorer (a quick reference for how to use each section of the API Explorer)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 174.52869,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Disable <em>and</em> enable <em>alerts</em> conditions using the <em>API</em>",
        "sections": "Disable <em>and</em> enable <em>alerts</em> conditions using the <em>API</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": "In a policy, a condition identifies what triggers an <em>alert</em>. You can use the <em>REST</em> <em>API</em> to disable and enable conditions. You can also disable and enable conditions in <em>New</em> <em>Relic</em> One. Policies can&#x27;t be enabled or disabled, whether via the <em>API</em> or the UI. Policies can only be created, deleted, or have"
      },
      "id": "60442938196a67d2ed960f24"
    }
  ],
  "/docs/alerts-applied-intelligence/new-relic-alerts/rules-limits-glossary/rules-limits-alerts": [
    {
      "sections": [
        "Incident Intelligence destination examples",
        "Destination template examples",
        "Suggested OpsGenie template example",
        "Suggested ServiceNow template example",
        "Suggested Slack template example",
        "Suggested VictorOps template example",
        "Webhook and JSON format examples",
        "Webhook format and JSON example",
        "Jinja2 Default Payload",
        "Jinja2 Useful Syntax",
        "JSON schema",
        "JSON schema template"
      ],
      "title": "Incident Intelligence destination examples",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Incident intelligence"
      ],
      "external_id": "a516d04f8b75541a6dc9338fa3ce9645ba87d620",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/incident-intelligence/incident-intelligence-destination-examples/",
      "published_at": "2021-06-02T18:22:22Z",
      "updated_at": "2021-06-02T18:22:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Destinations are the data outputs to Applied Intelligence, where you can view your automatically correlated incidents. You can configure Incident Intelligence destinations to send data to PagerDuty or webhooks. This document gives examples of destination templates, webhook formats, and JSON schema. Destination template examples The following template example destinations are formatted in Jinja2. Suggested OpsGenie template example { \"alias\": {{ id }}, \"message\": {{ ui_name }}, \"source\": '{{ sources }}', \"priority\": {{ priority }}, \"details\": { \"self_url\": {{ url }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"is_correlated\": {{ is_correlated }} }, \"description\": \"\"\"Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]\"\"\" } Copy Suggested ServiceNow template example { \"short_description\": {{ ui_name }}, \"description\": 'Issue Id: {{ id }}, \\n Description: {{ description }}, \\n Sources: {{ sources }}, \\n Priority: {{ priority }}, \\n Details: { \\n self_url: {{ url }}, \\n state: {{ state }}, \\n is_correlated: {{ is_correlated }}, \\n created_on: {{ created_on }}, \\n modified_on: {{ modified_on }}, \\n activated_on: {{ active_since }}, \\n closed_on: {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \\n is_correlated: {{is_correlated}} }, \\n\\n incidents: {{ incidents }}, \\n\\n pathways: {{ pathways }}' } Copy Suggested Slack template example Go to Slack incoming WebHooks Choose the right Slack workspace and click \"Add to Slack\" Select the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In New Relic Applied Intelligence, under Incident Intelligence click Destinations Add a WebHook In the end point paste the WebHook url from slack. In the custom payload, paste the following JSON: { \"blocks\": [ { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*New Relic Incident Intelligence Alert*\" } }, { \"type\": \"divider\" }, { \"type\": \"section\", \"text\": { \"type\": \"mrkdwn\", \"text\": \"*CUSTOM FIELDS*:\" }, \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue ID*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Issue Title*\" }, { \"type\": \"plain_text\", \"text\": {{ id }} }, { \"type\": \"plain_text\", \"text\": {{ ui_name }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Issue URL*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Description*\" }, { \"type\": \"mrkdwn\", \"text\": {{ url }} }, { \"type\": \"plain_text\", \"text\": {{ description }} } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*State*\" }, { \"type\": \"mrkdwn\", \"text\": \"*is_correlated*\" }, { \"type\": \"plain_text\", \"text\": {{ state }} }, { \"type\": \"plain_text\", \"text\": \"{{ is_correlated }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Created On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Modified On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ created_on }}\" }, { \"type\": \"plain_text\", \"text\": \"{{ modified_on }}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Activated On*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Closed On*\" }, { \"type\": \"plain_text\", \"text\": \"{{ active_since }}\" }, { \"type\": \"plain_text\", \"text\": \"{% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}\" } ] }, { \"type\": \"section\", \"fields\": [ { \"type\": \"mrkdwn\", \"text\": \"*Aggregated Incidents*\" }, { \"type\": \"mrkdwn\", \"text\": \"*Monitoring Tool*\" }, { \"type\": \"plain_text\", \"text\": \"{{ incident_count }}\" }, { \"type\": \"plain_text\", \"text\": {{ sources|join(', ') }} } ] } ] } Copy Suggested VictorOps template example { \"monitoring_tool\": {{ sources }}, {% if state == 'closed' %} \"message_type\": \"OK\", {% else %} \"message_type\": {{ priority }}, {% endif %} \"custom_fields\": { \"issue_url\": {{ url }}, \"description\": {{ description }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"activated_on\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"related_incidents\": [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %} {% endfor %} ] }, \"state_message\": {{ description }}, \"entity_id\": {{ id }}, \"entity_display_name\": {{ ui_name }}, \"vo_annotate.u.NRAI_Link\": {{ url }} } Copy Webhook and JSON format examples Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). If you use webhooks to configure Incident Intelligence destinations, use these examples of the webhook body format and JSON schema. Webhook format and JSON example Webhook format: Name Description url Href A link to the UI where the issue can be seen. id String Unique identifier for the issue. title String The issue title. description String The description of the issue. priority Enum The issue priority. Can be Critical, High, Medium, or Low. state Enum The issue status. Can be Active, Closed, or Acknowledged. is_correlated Boolean True if the issue is based on correlated data. created_on String The date and time the issue was created (in ISO format). modified_on String The date and time the issue was modified (in ISO format). active_since String The date and time the issue was activated (in ISO format). closed_on String The date and time the issue was closed (in ISO format). sources List(String) List of the different sources that were used to send the events into Applied Intelligence (for example: PagerDuty). pathways List(Pathways) List of pathways that are associated with the issue. Each pathway contains an id and name: [{“id”: “pathway id”, “name”: “pathway name”}]. pathways[].id String The pathway ID. pathways[].name String The pathway name. incidents List(Incident) List of incidents that are attached to the issue. The list contains only the latest 100 incidents. incidents[].id String The incident ID. incidents[].events_count Integer The number of events used to create the incident. incidents[].title String The incident title. incidents[].description String The incident description. incidents[].labels Dictionary (String) A string to string mapping of the incident labels. Labels represent the unique entities that are used to describe the incident. incidents[].priority Enum The incident priority. Can be Critical, High, Medium, or Low. incidents[].sources List(String) The incident source. incidents[].state Enum(open, closed) The incident state. incidents[].opened_on String The date and time the incident was opened (in ISO format). incidents[].closed_on String The date and time the incident was closed (in ISO format). ui_name String Issue title. accumulations['alert/signal'] String Issue analysis summary golden signal/s (if applicable). accumulations['alert/components'] String Issue analysis summary golden components (if applicable). Jinja2 Default Payload Applied Intelligence uses a templating framework called Jinja2 in the Webhook interface. Here is a default Jinja2 payload to use: { \"id\": {{ id }}, \"url\": {{ url }}, \"ui_name\": {{ ui_name }}, \"description\": {{ description }}, \"priority\": {{ priority }}, \"state\": {{ state }}, \"is_correlated\": {{ is_correlated }}, \"created_on\": {{ created_on }}, \"modified_on\": {{ modified_on }}, \"active_since\": {{ active_since }}, \"closed_on\": {% if closed_on is defined %} {{ closed_on }} {% else %} None {% endif %}, \"sources\": {{ sources }}, \"incidents\": {{ incidents }}, \"pathways\": {{ pathways }}, } Copy Jinja2 Useful Syntax Below are a few useful Jinja2 commands to help you format your output. Casting a value to integer Example: “severity”: {{ priority | int }} Copy If clause to check if an attribute’s value is set Example: \"golden_signals\": {% if accumulations['alert/signal'] is defined %} {{ accumulations['alert/signal'] }} {% else %} None {% endif %} Copy For loop to iterate of an array of values: Example: \"description\": 'Incidents [ {% for incident in incidents %} { \"id\": {{ incident.id }}, \"events_count\": {{ incident.events_count }}, \"labels\": {{ incident.labels }}, \"title\": {{ incident.title }}, \"description\": {{ incident.description }}, \"state\": {{ incident.state }}, \"sources\": {{ incident.sources }}, \"modified_on\": {{ incident.modified_on }}, \"opened_on\": {{ incident.opened_on }}, \"closed_on\": {{ incident.closed_on }} } {% if not loop.last %},{% endif %}{% endfor %} ]' Copy Check if an array attribute's value is set: Example: \"hostname_field\": {% if incidents[0].labels['newrelic/tag/hostname'] is defined %} {{ incidents[0].labels['newrelic/tag/hostname'] }} {% else %} None {% endif %} Copy JSON schema Applied Intelligence will send the event body in JSON format via HTTPS POST. The system expects the endpoint to return a successful HTTP code (2xx). JSON schema template JSON schema: { \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"definitions\": { \"Labels\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"LabelsSet\": { \"type\": \"array\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"$ref\": \"#/definitions/Labels\" }, \"uniqueItems\": true }, }, \"Annotations\": { \"type\": \"object\", \"title\": \"Additional contextual information about the Entity\", \"description\": \"Fields like title, description and priority can be described as annotations since\\nthey represent some additional information about the Incident.\\nFor example, the rule that creates the entity can have some logic that will create a title annotation field.\\nThe title will change according to the latest event received by the entity and as more\\nevent will keep coming the field may change, all this as a decision by the rule.\\nA different rule may decide not to populate the title at all.\\nSince a title can also be produced from the labels themselves.\", \"properties\": { \"title\": { \"type\": \"string\", \"maxLength\": 10000 }, \"description\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"patternProperties\": { \".*\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"additionalProperties\": { \"type\": \"string\", \"maxLength\": 10000 } }, \"Accumulations\": { \"type\": \"object\", \"title\": \"Accumulated data about the Incident\", \"description\": \"For example an entity with the label: host_name: foo will include a accumulated list of the\\nrelevant process names that are relevant to the entity. Accumulations will be derived from the events\", \"properties\": {}, \"additionalProperties\": { \"type\": \"array\", \"items\": { \"type\": \"string\", \"maxLength\": 10000 } } }, \"IssueState\": { \"type\": \"string\", \"enum\": [ \"created\", \"active\", \"acknowledged\", \"closed\" ], \"properties\": {}, \"additionalProperties\": false }, \"Priority\": { \"type\": \"string\", \"enum\": [ \"critical\", \"high\", \"medium\", \"low\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueClosingReason\": { \"type\": \"string\", \"enum\": [ \"nacked\", \"resolved\", \"system\" ], \"properties\": {}, \"additionalProperties\": false }, \"IssueAction\": { \"type\": \"string\", \"enum\": [ \"ack\", \"snooze\", \"nack\", \"end_snooze\", \"expire_snooze\", \"star\", \"un_snooze\", \"unstar\", \"archive\", \"unarchive\", \"resolve\", \"reopen\", \"open\", \"feedback\", \"feedback_file\", \"open_ticket\", \"merge_issues\", \"active\", \"create\", \"close\", \"incident_updated\", \"confidence_changed\", \"diagnoses_changed\", \"rule_properties_changed\", \"flapping\", \"notification\", \"incident_events_limit_reached\", \"follow\", \"unfollow\", \"priority_updated\", \"comment\", \"incident_appended\", \"diagnosis_feedback\", \"flapping_delay_close\" ], \"properties\": {}, \"additionalProperties\": false }, \"StringKeyValue\": { \"type\": \"object\", \"properties\": {}, \"additionalProperties\": { \"type\": \"string\" } }, \"JavaOptionalUuid\": { \"type\": \"string\", \"properties\": {}, \"additionalProperties\": false, \"format\": \"string-uuid\" } }, \"type\": \"object\", \"properties\": { \"id\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"customer_id\": { \"type\": \"integer\" }, \"labels_set\": { \"$ref\": \"#/definitions/LabelsSet\" }, \"annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations\": { \"$ref\": \"#/definitions/Annotations\" }, \"user_annotations_version\": { \"type\": \"integer\" }, \"accumulations\": { \"$ref\": \"#/definitions/Accumulations\" }, \"state\": { \"$ref\": \"#/definitions/IssueState\" }, \"previous_state\": { \"$ref\": \"#/definitions/IssueState\" }, \"priority\": { \"$ref\": \"#/definitions/Priority\" }, \"closing_reason\": { \"oneOf\": [ { \"$ref\": \"#/definitions/IssueClosingReason\" }, { \"type\": \"null\" } ] }, \"modified_on\": { \"type\": \"integer\" }, \"created_on\": { \"type\": \"integer\" }, \"closed_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"acknowledged_on\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"active_since\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"assigned_to\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"created_by\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"minLength\": 1 }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"progress_report\": { \"type\": \"array\", \"default\": [], \"items\": { \"type\": \"object\", \"properties\": { \"origin_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1 }, { \"type\": \"null\" } ] }, \"timestamp\": { \"type\": \"integer\" }, \"action_timestamp\": { \"oneOf\": [ { \"type\": \"integer\" }, { \"type\": \"null\" } ] }, \"origin_type\": { \"type\": \"string\", \"enum\": [ \"user\", \"system\" ] }, \"event_type\": { \"$ref\": \"#/definitions/IssueAction\" }, \"issue_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"format\": \"string-uuid\" }, { \"type\": \"null\" } ] }, \"attributes\": { \"oneOf\": [ { \"$ref\": \"#/definitions/StringKeyValue\" }, { \"type\": \"null\" } ] }, \"team_id\": { \"$ref\": \"#/definitions/JavaOptionalUuid\" } }, \"required\": [ \"timestamp\", \"origin_type\", \"event_type\" ], \"additionalProperties\": false }, \"uniqueItems\": true }, \"rule_id\": { \"oneOf\": [ { \"type\": \"string\", \"minLength\": 1, \"maxLength\": 255 }, { \"type\": \"null\" } ] }, \"incident_ids\": { \"oneOf\": [ { \"type\": \"array\", \"items\": { \"type\": \"string\", \"format\": \"string-uuid\" }, \"uniqueItems\": true }, { \"type\": \"null\" } ] }, \"confidence\": { \"type\": \"number\", \"default\": 1.0, \"minimum\": 0.0, \"maximum\": 1.0 } }, \"required\": [ \"id\", \"customer_id\", \"labels_set\", \"annotations\", \"priority\", \"modified_on\", \"created_on\", \"confidence\" ], \"additionalProperties\": true } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 171.2078,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Incident <em>Intelligence</em> destination examples",
        "sections": "Incident <em>Intelligence</em> destination examples",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " the destination channel to receive the notifications to Click “Add Incoming WebHooks Integration” Copy the WebHook URL In the next screen, click “Save settings” at the bottom. In <em>New</em> <em>Relic</em> <em>Applied</em> <em>Intelligence</em>, under Incident <em>Intelligence</em> click Destinations Add a WebHook In the end point paste the WebHook url"
      },
      "id": "6044280d64441f4af5378ed3"
    },
    {
      "sections": [
        "Update or disable policies and conditions",
        "Policy maintenance quick reference",
        "Add or remove policies assigned to a channel",
        "Change a policy name",
        "Check policy user assignment",
        "Check policy channel assignment",
        "Create a new policy",
        "Condition maintenance quick reference",
        "Add more conditions",
        "Copy a condition",
        "Change how threshold violations roll up into incidents",
        "Check for entities (targets) assigned to a policy",
        "Tip",
        "Change a condition",
        "Link to Incident Intelligence",
        "Disable or delete policies and conditions",
        "Disable or re-enable a condition",
        "Disable a policy",
        "Delete policy conditions",
        "Delete a policy"
      ],
      "title": "Update or disable policies and conditions",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "New Relic Alerts",
        "Alert policies"
      ],
      "external_id": "4a6c5107cd6af696df6a3fb0651c6a1bde7daf36",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/new-relic-alerts/alert-policies/update-or-disable-policies-conditions/",
      "published_at": "2021-05-28T11:10:28Z",
      "updated_at": "2021-05-21T15:35:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "After you create a policy, you can: Add more conditions to the policy. Edit the conditions' names, targets, or thresholds. Disable conditions. Continue the policy setup process by adding one or more notification channels to it. Rename or delete the policy. The user interface shows a Last modified timestamp for any changes to policies, including their conditions and notification channels. Policy maintenance quick reference Here is a quick reference which also includes links to more detailed information and procedures for maintaining your policies. Add or remove policies assigned to a channel To add or remove policies assigned to a channel: In the one.newrelic.com top nav, click Alerts & AI, click Notification channels, then (select a channel). Click Alert policies, then (select a policy). From the selected policy, use the windows to select, remove, or clear all. Change a policy name To rename a policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Click the policy name to edit it, then type a meaningful name for the policy (maximum 64 characters). Check policy user assignment To check whether an account user has been assigned any policies: In the one.newrelic.com top nav, click Alerts & AI, click Policies, (select a policy), then click Notification channels. Select a user, and then click Alert policies. Check policy channel assignment To check whether a notification channel has any policies assigned to it: In the one.newrelic.com top nav, click Alerts & AI, click Notification channels. The Policy subscriptions column lists how many policies are assigned to the channel. Create a new policy To create a new alert policy: In the one.newrelic.com top nav, click Alerts & AI, click Policies. Click New alert policy. Follow standard procedures to complete the basic setup process. Condition maintenance quick reference Here's a quick reference for maintaining a policy conditions. This includes the condition's entities (targets), Warning (yellow) and Critical (red) thresholds, and runbook URL. Add more conditions To add more conditions to a policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then click Add a condition. OR To copy a condition from any policy and add it to another policy: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, (select a policy), then click Copy. Copy a condition To copy an existing condition, including its targets and thresholds, and add it to another policy for the selected account: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). From the policy's list of one or more Alert conditions, click Copy. From the Copy alert condition list, search or scroll the list to select the policy where you want to add this condition. Optional: Change the condition's name if necessary. Select Save. By default, the copied condition will be added to the selected alert policy in a Disabled state. Follow standard procedures to add or copy additional conditions to the alert policy, and then Enable the condition as needed. Change how threshold violations roll up into incidents To select how violations to your thresholds are grouped into incident records (by policy, by condition, or by target and condition): In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Click Incident preference. Check for entities (targets) assigned to a policy To check whether an entity (target) has any policies assigned: Go to the product (APM, Browser, etc.). From the selected product's index, check whether the entity's color-coded health status is light green with an icon. Tip Exception: Infrastructure does not use this feature. Change a condition To change a policy condition: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Then, from the list of Alert conditions for the selected policy: To change the condition's name, click Edit. To add, change, or remove targets (entities), select the name or number of targets for the condition, and then select Browse and select targets. To update the values for the required Critical (red) or optional Warning (yellow) thresholds, select the existing value. To update the condition's runbook URL, select the condition's Thresholds. Link to Incident Intelligence If you use Applied Intelligence, you can connect your conditions to Incident Intelligence. To do this, switch the Connect to Incident Intelligence to ON. Disable or delete policies and conditions If you disable or delete a policy, we'll continue to apply any other policies assigned to the product entity (target). If you remove all policies for the entity, its color-coded health status indicator will appear light green with an icon. Disable or re-enable a condition You can enable or disable any policy conditions, and the policy will continue to apply. To disable or re-enable a condition: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). Then, from the list of Alert conditions, (select a condition). Click the On/Off switch to toggle it. Tip For Infrastructure conditions, use the checkbox at the bottom of the condition edit screen, then save the condition. If you copy a condition, it is automatically saved in the new policy as disabled (Off), even if the condition was enabled (On) in the original policy. Disable a policy You can't disable a policy directly. However, you can disable all of the policy's conditions. When you disable all of the conditions, the policy will continue to appear on the Alert policies index. The policy itself isn't disabled, and you can re-enable any or all of its conditions at any time. Delete policy conditions If a policy has multiple conditions, you can delete any or all of them, and the remaining conditions for the policy will continue to apply. To turn a condition off but keep it with the policy, disable it. To delete one or more conditions: In the one.newrelic.com top nav, click Alerts & AI, click Alert policies, then (select a policy). From the list of Alert conditions, (select a condition), then click Delete. Tip If you don't see the delete button, your account admin may have disabled condition deletion for your organization. Delete a policy If you delete any of your account's policies, you can't restore them. Instead, you must re-create them if necessary. To delete a policy completely: In the one.newrelic.com top nav, click Alerts & AI, then click Alert policies. From the policy row, click the delete icon. Any notification channels associated with a deleted or disabled policy will remain. You must delete notification channels or remove them individually as necessary. You will still be able to view incidents and event violations related to the deleted policy. However, these records will be read only.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 152.82974,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Update or disable policies <em>and</em> conditions",
        "sections": "Link to Incident <em>Intelligence</em>",
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " to it: In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click Notification channels. The Policy subscriptions column lists how many policies are assigned to the channel. Create a <em>new</em> policy To create a <em>new</em> <em>alert</em> policy: In the one.newrelic.com top nav, click <em>Alerts</em> &amp; AI, click Policies. Click <em>New</em> <em>alert</em> policy. Follow"
      },
      "id": "604404ec28ccbc62492c6098"
    },
    {
      "sections": [
        "Expanded anomaly detection",
        "Requirements",
        "Why it matters",
        "Get started with anomaly detection",
        "Detect anomalies with a faceted NRQL query",
        "See your anomalies in one place",
        "Tip",
        "Query anomaly data",
        "Reduce the number of detected anomalies"
      ],
      "title": "Expanded anomaly detection",
      "type": "docs",
      "tags": [
        "Alerts and Applied Intelligence",
        "Applied intelligence",
        "Proactive detection"
      ],
      "external_id": "0b07c0b6ce27f39b5edb3e112a0f949835cbb8c6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/alerts-applied-intelligence/applied-intelligence/proactive-detection/expanded-anomaly-detection/",
      "published_at": "2021-06-02T18:27:12Z",
      "updated_at": "2021-05-31T16:43:44Z",
      "document_type": "page",
      "popularity": 1,
      "body": "We’ve expanded anomaly detection coverage beyond your APM applications. Configure anomaly detection for your browser applications, mobile applications, infrastructure hosts, and nearly anything you want to monitor. Requirements Expanded anomaly detection is available as a limited beta. You can request access here. Why it matters When starting to configure alert conditions for a variety of applications and hosts, it can be difficult to know what you’ll want to be notified about ahead of time. Anomaly detection helps you distinguish between what’s typical performance in your system and where you’re starting to have trouble. Instead of creating your alert conditions manually, you can simply tell us what you want to monitor. Anomaly detection will help you identify baseline performance in your system and flags anomalous activity in your system. Get started with anomaly detection To get started with expanded anomaly detection: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Select the account you want to use to record anomaly data, then select the workload or entities you’d like to monitor. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name your configuration and save. Detect anomalies with a faceted NRQL query To detect anomalies with a faceted NRQL query: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab, and then click + Add a configuration. Click Use a query instead. You may need to select an account, if you have more than one. Add one or more queries with a FACET clause. Name the query and confirm the facets you want to monitor for anomalies. Select the detection sensitivity. We recommend Low sensitivity so that you don’t see too many anomalies. Finally, name the configuration and save. See your anomalies in one place When you set up anomaly detection, New Relic starts analyzing the golden signals of your entities and workloads. Anomalies appear in your activity feeds throughout New Relic One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL alert condition for the NrAiAnomaly event. To view anomalies, from one.newrelic.com, go to Alerts & AI > Issues & activity > Anomalies. Query anomaly data Detected anomalies are written to the NrAiAnomaly event in your NRDB account. You can learn more about this event and how to query it here. Reduce the number of detected anomalies If you’re seeing too many anomalies, the first step is to make sure your sensitivity level is set to Low. If it’s already set to Low, you can define specific thresholds to distinguish between normal and anomalous behavior. To define custom thresholds: From one.newrelic.com, go to Alerts & AI > Proactive Detection > Settings. Click the Custom tab and the configuration you want to modify. Select an entity or workload, and then change the sensitivity level. You can use custom sensitivity to define specific thresholds for different entity types.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 149.47096,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Alerts</em> <em>and</em> <em>Applied</em> <em>Intelligence</em>",
        "body": " feeds throughout <em>New</em> <em>Relic</em> One and the Anomalies tab as soon as they’re detected. Click any anomaly to get more detail about it, including analysis and context for the anomaly. Tip For this limited release, anomaly detection won’t generate notifications. However, you can configure a NRQL <em>alert</em>"
      },
      "id": "60b5124064441ff965e2cb01"
    }
  ]
}