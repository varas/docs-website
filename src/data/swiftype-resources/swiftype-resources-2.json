{
  "/docs/agents/java-agent/additional-installation/ibm-websphere-application-server": [
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.68128,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "<em>Installation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic <em>Java</em> <em>agent</em>. If the <em>Java</em> <em>agent</em> is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the <em>agent</em> will then report to the same"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "WildFly installation for Java",
        "Install WildFly versions earlier than 11",
        "Install WildFly version 11 or higher"
      ],
      "title": "WildFly installation for Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "7f9259f3b77efb78cd4861a9d7b519fe44191e3c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/wildfly-installation-java/",
      "published_at": "2021-06-02T15:31:27Z",
      "updated_at": "2021-03-16T14:29:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install New Relic's Java agent, make sure your WildFly version is supported. Depending on which WildFly version your application uses, additional configuration steps may be required. Install WildFly versions earlier than 11 If your supported WildFly version is earlier than v11, follow standard Java installation procedures. You do not need to do any additional configuration. Install WildFly version 11 or higher If you use WildFly version 11 or higher, New Relic's Java agent requires additional configuration after you install it. Install the Java agent. If you already have it installed, update to the latest Java agent version. Versions 5.0.0 and higher include fixes for later WildFly versions 11 and higher. Open the standalone configuration file appropriate for your operating system and add the -javaagent property to JAVA_OPTS. For example, if you use Linux, edit the /bin/standalone.conf file or /bin/standalone.conf.bat for Windows. Make sure the agent jar is visible to all JBoss modules by adding com.newrelic to the JBoss modules system packages using either of these options in the standalone script: Recommended: Option 1 (same as adding -javaagent property): JAVA_OPTS=\"$JAVA_OPTS -Djboss.modules.system.pkgs=$JBOSS_MODULES_SYSTEM_PKGS,com.newrelic Copy Option 2: if [ \"x$JBOSS_MODULES_SYSTEM_PKGS\" = \"x\" ]; then JBOSS_MODULES_SYSTEM_PKGS=\"org.jboss.byteman,com.newrelic\" fi Copy Restart your application server.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.519394,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "WildFly <em>installation</em> for <em>Java</em>",
        "sections": "WildFly <em>installation</em> for <em>Java</em>",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": " standard <em>Java</em> <em>installation</em> procedures. You do not need to do any <em>additional</em> configuration. Install WildFly version 11 or higher If you use WildFly version 11 or higher, New Relic&#x27;s <em>Java</em> <em>agent</em> requires <em>additional</em> configuration after you install it. Install the <em>Java</em> <em>agent</em>. If you already have"
      },
      "id": "603e791764441f18724e88ab"
    },
    {
      "sections": [
        "Install New Relic Java agent for Docker",
        "Tip",
        "Get the Java agent",
        "Download using curl",
        "Download using Invoke-WebRequest (PowerShell)",
        "Download from the New Relic UI",
        "Set up the installation directory",
        "Modify startup scripts",
        "Set agent configurations",
        "Application name",
        "License key",
        "Logs",
        "Environment (optional)",
        "Important",
        "Enabled (optional)",
        "Additional Tomcat Dockerfile examples",
        "Tomcat with environment and Java system properties",
        "How to start an application with the Java agent",
        "Next steps"
      ],
      "title": "Install New Relic Java agent for Docker",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "4de0ccd173c9851b045cfa036089e2f703b4a0f7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-new-relic-java-agent-docker/",
      "published_at": "2021-06-02T18:13:26Z",
      "updated_at": "2021-03-16T14:29:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains a basic installation of the APM agent for Java applications in a Docker container. We discuss required configurations and also explore some optional configurations, including: How to use identical New Relic configuration files for each container, regardless of the environment where the containers are used How to use the Docker layer when every agent in every environment needs slightly different configuration data How to disable the New Relic agent in some environments and enable it in others Although we don't discuss advanced options here, you can install the Java agent in Docker volumes and use your Docker container image in other software such as Swarm, ECS, AKS, EKS, OpenShift, and Kubernetes. Our Docker examples refer to Tomcat, so if you are using another application server, refer to your vendor’s documentation. Tip To use Java or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Get the Java agent Download newrelic-java.zip using curl, Invoke-WebRequest (PowerShell), or the New Relic UI: Download using curl Complete the following: Start a command-line session. Change to a temporary directory where you can download the zip file. Execute this curl command: curl -O https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip Copy Unzip newrelic-java.zip Download using Invoke-WebRequest (PowerShell) Complete the following: Start a PowerShell session. Change to a temporary directory where you can download the zip file. Execute this PowerShell command: Invoke-WebRequest -Uri https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip -OutFile newrelic-java.zip Copy Unzip newrelic-java.zip: Expand-Archive -Path newrelic-java.zip -DestinationPath DESTINATION_PATH Copy Download from the New Relic UI Complete the following: Log in to New Relic. From the account dropdown in the New Relic UI, select Account settings. In the right sidebar under Most recent, select the Java agent, and save the newrelic-java.zip to a temporary directory. Unzip newrelic-java.zip. Set up the installation directory You can unzip the newrelic-java.zip file wherever it is convenient for you. In the subsequent sections we assume you extracted it in the current working directory, which puts the files we need in ./newrelic. Modify startup scripts The startup script that contains the command to start your application server must include Java’s built-in argument -javaagent. We recommend that you set this argument with the JAVA_OPTS environment variable. The value of that argument must contain the location where you ADD the Java APM agent’s jar file to the image. For example, with Tomcat, use commands like these in the Dockerfile: RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/newrelic.jar ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" Copy Set agent configurations By default, agent behavior is controlled by configuration entries in newrelic.yml, which is typically located in the same directory as the agent. This section explains how to override these newrelic.yml configurations by using environment variables or Java system properties in the Dockerfile. Before we look at some specific configurations, here’s how to load newrelic.yml using the Dockerfile: ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/newrelic.yml Copy For a basic Docker installation, complete these configurations: Application name License key Logs Environment (optional) Enabled (optional) Application name The application name is a configuration you set to identify your application in New Relic. Tip You can reuse an application name for multiple apps serving the same role so that all the data from those apps rolls up into the same logical application in New Relic. For more detail about additional grouping options, see Use multiple names for an app. Replace MY_APP_NAME with your application name in one of these Dockerfile commands: Option Command Environment variable ENV NEW_RELIC_APP_NAME=\"MY_APP_NAME\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='MY_APP_NAME'\" Copy After you boot the container, your application name appears in New Relic. License key This configuration is required for you to report on any data in your New Relic Account. To copy your license key: Go to one.newrelic.com > (account dropdown) > Account settings. Under Account information, copy the license key. In one of these Dockerfile commands, replace MY_LICENSE_KEY with your license key: Option Command Environment variable ENV NEW_RELIC_LICENSE_KEY=\"MY_LICENSE_KEY\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.license_key='MY_LICENSE_KEY'\" Copy Logs By default, logs are written into the logs directory relative to the location of newrelic.jar. Make sure that the user account that starts your application server also has the right to perform tasks such as: Creating the logs directory. Creating and appending to the log files in that directory. Here’s a Dockerfile example where tomcat is the user who starts Tomcat: RUN mkdir -p /usr/local/tomcat/newrelic/logs RUN chown -R tomcat:tomcat /usr/local/tomcat/newrelic/logs Copy You can also send the logs to STDOUT by adding one of the following to the Dockerfile: Option Command Environment Variable ENV NEW_RELIC_LOG_FILE_NAME=STDOUT Copy Java system property ENV JAVA_OPTS=-Dnewrelic.config.log_file_name=STDOUT Copy Environment (optional) You can pass either a Java property or an environment variable to determine which of the environment-specific stanzas the agent uses in newrelic.yml. Use this approach if you prefer to have the newrelic.yml file control environment-specific configurations instead of passing all the configurations via Docker. Here’s a Dockerfile example of passing the newrelic.environment Java system property via Docker to use the custom value dev in the environment stanza of newrelic.yml: Using the shell form of the CMD instruction, include a reference to a new environment variable you choose (for example, ENV): CMD java -Dnewrelic.environment=$ENV -jar myjar.jar Copy In your docker run command line, include an argument to set the environment variable in the container: docker run -it -e \"ENV=dev\" myDockerImage Copy Important If you don’t specify a value for newrelic.environment, the agent assumes it is running in your production environment and uses the values from the main body of the configuration file. Enabled (optional) This configuration controls whether the agent is enabled. Let’s say you want the same Docker image for every installation. However, you don’t want to run the New Relic agent every time an engineer spins up a test app because you don’t want to run up your instance count. This problem can be solved using the newrelic.environment Java system property. In the main body of newrelic.yml, disable the Java agent by setting enabled: false. In specific environment stanzas of newrelic.yml, set enabled: true. Then, you can run specific agents by specifying the environment at runtime. Additional Tomcat Dockerfile examples Tomcat with environment and Java system properties FROM tomcat:9 # Add the newrelic.jar and -javaagent parameters RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/ ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" # Add the configuration file ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/ # An example of setting a system property config ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='My Application'\" # An example of setting an Environment variable config ENV NEW_RELIC_LICENSE_KEY=\"license_key\" # Config to include the agent logs in Docker's stdout logging ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.log_file_name=STDOUT\" EXPOSE 8080 CMD [\"catalina.sh\", \"run\"] Copy How to start an application with the Java agent FROM openjdk:8 ADD my-application.jar /app ADD newrelic.jar /app ADD newrelic.yml /app ENV NEW_RELIC_APP_NAME=\"My Application\" ENV NEW_RELIC_LICENSE_KEY=\"license_key\" ENV NEW_RELIC_LOG_FILE_NAME=\"STDOUT\" ENTRYPOINT [\"java\",\"-javaagent:/app/newrelic.jar\",\"-jar\",\"/app/my-application.jar\"] Copy Next steps Now that you have a basic agent installation in Docker, here are some additional steps to consider: Review other configurations for the agent. Read a detailed Explorers Hub post about Docker and New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.519394,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "sections": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": "This document explains a basic <em>installation</em> of the APM <em>agent</em> for <em>Java</em> applications in a Docker container. We discuss required configurations and also explore some optional configurations, including: How to use identical New Relic configuration files for each container, regardless of the environment"
      },
      "id": "603ea3dc28ccbc8889eba765"
    }
  ],
  "/docs/agents/java-agent/additional-installation/install-java-agent-using-gradle": [
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.68123,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "<em>Installation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic <em>Java</em> <em>agent</em>. If the <em>Java</em> <em>agent</em> is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the <em>agent</em> will then report to the same"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "WildFly installation for Java",
        "Install WildFly versions earlier than 11",
        "Install WildFly version 11 or higher"
      ],
      "title": "WildFly installation for Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "7f9259f3b77efb78cd4861a9d7b519fe44191e3c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/wildfly-installation-java/",
      "published_at": "2021-06-02T15:31:27Z",
      "updated_at": "2021-03-16T14:29:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install New Relic's Java agent, make sure your WildFly version is supported. Depending on which WildFly version your application uses, additional configuration steps may be required. Install WildFly versions earlier than 11 If your supported WildFly version is earlier than v11, follow standard Java installation procedures. You do not need to do any additional configuration. Install WildFly version 11 or higher If you use WildFly version 11 or higher, New Relic's Java agent requires additional configuration after you install it. Install the Java agent. If you already have it installed, update to the latest Java agent version. Versions 5.0.0 and higher include fixes for later WildFly versions 11 and higher. Open the standalone configuration file appropriate for your operating system and add the -javaagent property to JAVA_OPTS. For example, if you use Linux, edit the /bin/standalone.conf file or /bin/standalone.conf.bat for Windows. Make sure the agent jar is visible to all JBoss modules by adding com.newrelic to the JBoss modules system packages using either of these options in the standalone script: Recommended: Option 1 (same as adding -javaagent property): JAVA_OPTS=\"$JAVA_OPTS -Djboss.modules.system.pkgs=$JBOSS_MODULES_SYSTEM_PKGS,com.newrelic Copy Option 2: if [ \"x$JBOSS_MODULES_SYSTEM_PKGS\" = \"x\" ]; then JBOSS_MODULES_SYSTEM_PKGS=\"org.jboss.byteman,com.newrelic\" fi Copy Restart your application server.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.519394,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "WildFly <em>installation</em> for <em>Java</em>",
        "sections": "WildFly <em>installation</em> for <em>Java</em>",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": " standard <em>Java</em> <em>installation</em> procedures. You do not need to do any <em>additional</em> configuration. Install WildFly version 11 or higher If you use WildFly version 11 or higher, New Relic&#x27;s <em>Java</em> <em>agent</em> requires <em>additional</em> configuration after you install it. Install the <em>Java</em> <em>agent</em>. If you already have"
      },
      "id": "603e791764441f18724e88ab"
    },
    {
      "sections": [
        "Install New Relic Java agent for Docker",
        "Tip",
        "Get the Java agent",
        "Download using curl",
        "Download using Invoke-WebRequest (PowerShell)",
        "Download from the New Relic UI",
        "Set up the installation directory",
        "Modify startup scripts",
        "Set agent configurations",
        "Application name",
        "License key",
        "Logs",
        "Environment (optional)",
        "Important",
        "Enabled (optional)",
        "Additional Tomcat Dockerfile examples",
        "Tomcat with environment and Java system properties",
        "How to start an application with the Java agent",
        "Next steps"
      ],
      "title": "Install New Relic Java agent for Docker",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "4de0ccd173c9851b045cfa036089e2f703b4a0f7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-new-relic-java-agent-docker/",
      "published_at": "2021-06-02T18:13:26Z",
      "updated_at": "2021-03-16T14:29:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains a basic installation of the APM agent for Java applications in a Docker container. We discuss required configurations and also explore some optional configurations, including: How to use identical New Relic configuration files for each container, regardless of the environment where the containers are used How to use the Docker layer when every agent in every environment needs slightly different configuration data How to disable the New Relic agent in some environments and enable it in others Although we don't discuss advanced options here, you can install the Java agent in Docker volumes and use your Docker container image in other software such as Swarm, ECS, AKS, EKS, OpenShift, and Kubernetes. Our Docker examples refer to Tomcat, so if you are using another application server, refer to your vendor’s documentation. Tip To use Java or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Get the Java agent Download newrelic-java.zip using curl, Invoke-WebRequest (PowerShell), or the New Relic UI: Download using curl Complete the following: Start a command-line session. Change to a temporary directory where you can download the zip file. Execute this curl command: curl -O https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip Copy Unzip newrelic-java.zip Download using Invoke-WebRequest (PowerShell) Complete the following: Start a PowerShell session. Change to a temporary directory where you can download the zip file. Execute this PowerShell command: Invoke-WebRequest -Uri https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip -OutFile newrelic-java.zip Copy Unzip newrelic-java.zip: Expand-Archive -Path newrelic-java.zip -DestinationPath DESTINATION_PATH Copy Download from the New Relic UI Complete the following: Log in to New Relic. From the account dropdown in the New Relic UI, select Account settings. In the right sidebar under Most recent, select the Java agent, and save the newrelic-java.zip to a temporary directory. Unzip newrelic-java.zip. Set up the installation directory You can unzip the newrelic-java.zip file wherever it is convenient for you. In the subsequent sections we assume you extracted it in the current working directory, which puts the files we need in ./newrelic. Modify startup scripts The startup script that contains the command to start your application server must include Java’s built-in argument -javaagent. We recommend that you set this argument with the JAVA_OPTS environment variable. The value of that argument must contain the location where you ADD the Java APM agent’s jar file to the image. For example, with Tomcat, use commands like these in the Dockerfile: RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/newrelic.jar ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" Copy Set agent configurations By default, agent behavior is controlled by configuration entries in newrelic.yml, which is typically located in the same directory as the agent. This section explains how to override these newrelic.yml configurations by using environment variables or Java system properties in the Dockerfile. Before we look at some specific configurations, here’s how to load newrelic.yml using the Dockerfile: ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/newrelic.yml Copy For a basic Docker installation, complete these configurations: Application name License key Logs Environment (optional) Enabled (optional) Application name The application name is a configuration you set to identify your application in New Relic. Tip You can reuse an application name for multiple apps serving the same role so that all the data from those apps rolls up into the same logical application in New Relic. For more detail about additional grouping options, see Use multiple names for an app. Replace MY_APP_NAME with your application name in one of these Dockerfile commands: Option Command Environment variable ENV NEW_RELIC_APP_NAME=\"MY_APP_NAME\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='MY_APP_NAME'\" Copy After you boot the container, your application name appears in New Relic. License key This configuration is required for you to report on any data in your New Relic Account. To copy your license key: Go to one.newrelic.com > (account dropdown) > Account settings. Under Account information, copy the license key. In one of these Dockerfile commands, replace MY_LICENSE_KEY with your license key: Option Command Environment variable ENV NEW_RELIC_LICENSE_KEY=\"MY_LICENSE_KEY\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.license_key='MY_LICENSE_KEY'\" Copy Logs By default, logs are written into the logs directory relative to the location of newrelic.jar. Make sure that the user account that starts your application server also has the right to perform tasks such as: Creating the logs directory. Creating and appending to the log files in that directory. Here’s a Dockerfile example where tomcat is the user who starts Tomcat: RUN mkdir -p /usr/local/tomcat/newrelic/logs RUN chown -R tomcat:tomcat /usr/local/tomcat/newrelic/logs Copy You can also send the logs to STDOUT by adding one of the following to the Dockerfile: Option Command Environment Variable ENV NEW_RELIC_LOG_FILE_NAME=STDOUT Copy Java system property ENV JAVA_OPTS=-Dnewrelic.config.log_file_name=STDOUT Copy Environment (optional) You can pass either a Java property or an environment variable to determine which of the environment-specific stanzas the agent uses in newrelic.yml. Use this approach if you prefer to have the newrelic.yml file control environment-specific configurations instead of passing all the configurations via Docker. Here’s a Dockerfile example of passing the newrelic.environment Java system property via Docker to use the custom value dev in the environment stanza of newrelic.yml: Using the shell form of the CMD instruction, include a reference to a new environment variable you choose (for example, ENV): CMD java -Dnewrelic.environment=$ENV -jar myjar.jar Copy In your docker run command line, include an argument to set the environment variable in the container: docker run -it -e \"ENV=dev\" myDockerImage Copy Important If you don’t specify a value for newrelic.environment, the agent assumes it is running in your production environment and uses the values from the main body of the configuration file. Enabled (optional) This configuration controls whether the agent is enabled. Let’s say you want the same Docker image for every installation. However, you don’t want to run the New Relic agent every time an engineer spins up a test app because you don’t want to run up your instance count. This problem can be solved using the newrelic.environment Java system property. In the main body of newrelic.yml, disable the Java agent by setting enabled: false. In specific environment stanzas of newrelic.yml, set enabled: true. Then, you can run specific agents by specifying the environment at runtime. Additional Tomcat Dockerfile examples Tomcat with environment and Java system properties FROM tomcat:9 # Add the newrelic.jar and -javaagent parameters RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/ ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" # Add the configuration file ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/ # An example of setting a system property config ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='My Application'\" # An example of setting an Environment variable config ENV NEW_RELIC_LICENSE_KEY=\"license_key\" # Config to include the agent logs in Docker's stdout logging ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.log_file_name=STDOUT\" EXPOSE 8080 CMD [\"catalina.sh\", \"run\"] Copy How to start an application with the Java agent FROM openjdk:8 ADD my-application.jar /app ADD newrelic.jar /app ADD newrelic.yml /app ENV NEW_RELIC_APP_NAME=\"My Application\" ENV NEW_RELIC_LICENSE_KEY=\"license_key\" ENV NEW_RELIC_LOG_FILE_NAME=\"STDOUT\" ENTRYPOINT [\"java\",\"-javaagent:/app/newrelic.jar\",\"-jar\",\"/app/my-application.jar\"] Copy Next steps Now that you have a basic agent installation in Docker, here are some additional steps to consider: Review other configurations for the agent. Read a detailed Explorers Hub post about Docker and New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.519394,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "sections": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": "This document explains a basic <em>installation</em> of the APM <em>agent</em> for <em>Java</em> applications in a Docker container. We discuss required configurations and also explore some optional configurations, including: How to use identical New Relic configuration files for each container, regardless of the environment"
      },
      "id": "603ea3dc28ccbc8889eba765"
    }
  ],
  "/docs/agents/java-agent/additional-installation/install-java-agent-using-maven": [
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.68123,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "<em>Installation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic <em>Java</em> <em>agent</em>. If the <em>Java</em> <em>agent</em> is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the <em>agent</em> will then report to the same"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "WildFly installation for Java",
        "Install WildFly versions earlier than 11",
        "Install WildFly version 11 or higher"
      ],
      "title": "WildFly installation for Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "7f9259f3b77efb78cd4861a9d7b519fe44191e3c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/wildfly-installation-java/",
      "published_at": "2021-06-02T15:31:27Z",
      "updated_at": "2021-03-16T14:29:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install New Relic's Java agent, make sure your WildFly version is supported. Depending on which WildFly version your application uses, additional configuration steps may be required. Install WildFly versions earlier than 11 If your supported WildFly version is earlier than v11, follow standard Java installation procedures. You do not need to do any additional configuration. Install WildFly version 11 or higher If you use WildFly version 11 or higher, New Relic's Java agent requires additional configuration after you install it. Install the Java agent. If you already have it installed, update to the latest Java agent version. Versions 5.0.0 and higher include fixes for later WildFly versions 11 and higher. Open the standalone configuration file appropriate for your operating system and add the -javaagent property to JAVA_OPTS. For example, if you use Linux, edit the /bin/standalone.conf file or /bin/standalone.conf.bat for Windows. Make sure the agent jar is visible to all JBoss modules by adding com.newrelic to the JBoss modules system packages using either of these options in the standalone script: Recommended: Option 1 (same as adding -javaagent property): JAVA_OPTS=\"$JAVA_OPTS -Djboss.modules.system.pkgs=$JBOSS_MODULES_SYSTEM_PKGS,com.newrelic Copy Option 2: if [ \"x$JBOSS_MODULES_SYSTEM_PKGS\" = \"x\" ]; then JBOSS_MODULES_SYSTEM_PKGS=\"org.jboss.byteman,com.newrelic\" fi Copy Restart your application server.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.519394,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "WildFly <em>installation</em> for <em>Java</em>",
        "sections": "WildFly <em>installation</em> for <em>Java</em>",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": " standard <em>Java</em> <em>installation</em> procedures. You do not need to do any <em>additional</em> configuration. Install WildFly version 11 or higher If you use WildFly version 11 or higher, New Relic&#x27;s <em>Java</em> <em>agent</em> requires <em>additional</em> configuration after you install it. Install the <em>Java</em> <em>agent</em>. If you already have"
      },
      "id": "603e791764441f18724e88ab"
    },
    {
      "sections": [
        "Install New Relic Java agent for Docker",
        "Tip",
        "Get the Java agent",
        "Download using curl",
        "Download using Invoke-WebRequest (PowerShell)",
        "Download from the New Relic UI",
        "Set up the installation directory",
        "Modify startup scripts",
        "Set agent configurations",
        "Application name",
        "License key",
        "Logs",
        "Environment (optional)",
        "Important",
        "Enabled (optional)",
        "Additional Tomcat Dockerfile examples",
        "Tomcat with environment and Java system properties",
        "How to start an application with the Java agent",
        "Next steps"
      ],
      "title": "Install New Relic Java agent for Docker",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "4de0ccd173c9851b045cfa036089e2f703b4a0f7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-new-relic-java-agent-docker/",
      "published_at": "2021-06-02T18:13:26Z",
      "updated_at": "2021-03-16T14:29:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains a basic installation of the APM agent for Java applications in a Docker container. We discuss required configurations and also explore some optional configurations, including: How to use identical New Relic configuration files for each container, regardless of the environment where the containers are used How to use the Docker layer when every agent in every environment needs slightly different configuration data How to disable the New Relic agent in some environments and enable it in others Although we don't discuss advanced options here, you can install the Java agent in Docker volumes and use your Docker container image in other software such as Swarm, ECS, AKS, EKS, OpenShift, and Kubernetes. Our Docker examples refer to Tomcat, so if you are using another application server, refer to your vendor’s documentation. Tip To use Java or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Get the Java agent Download newrelic-java.zip using curl, Invoke-WebRequest (PowerShell), or the New Relic UI: Download using curl Complete the following: Start a command-line session. Change to a temporary directory where you can download the zip file. Execute this curl command: curl -O https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip Copy Unzip newrelic-java.zip Download using Invoke-WebRequest (PowerShell) Complete the following: Start a PowerShell session. Change to a temporary directory where you can download the zip file. Execute this PowerShell command: Invoke-WebRequest -Uri https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip -OutFile newrelic-java.zip Copy Unzip newrelic-java.zip: Expand-Archive -Path newrelic-java.zip -DestinationPath DESTINATION_PATH Copy Download from the New Relic UI Complete the following: Log in to New Relic. From the account dropdown in the New Relic UI, select Account settings. In the right sidebar under Most recent, select the Java agent, and save the newrelic-java.zip to a temporary directory. Unzip newrelic-java.zip. Set up the installation directory You can unzip the newrelic-java.zip file wherever it is convenient for you. In the subsequent sections we assume you extracted it in the current working directory, which puts the files we need in ./newrelic. Modify startup scripts The startup script that contains the command to start your application server must include Java’s built-in argument -javaagent. We recommend that you set this argument with the JAVA_OPTS environment variable. The value of that argument must contain the location where you ADD the Java APM agent’s jar file to the image. For example, with Tomcat, use commands like these in the Dockerfile: RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/newrelic.jar ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" Copy Set agent configurations By default, agent behavior is controlled by configuration entries in newrelic.yml, which is typically located in the same directory as the agent. This section explains how to override these newrelic.yml configurations by using environment variables or Java system properties in the Dockerfile. Before we look at some specific configurations, here’s how to load newrelic.yml using the Dockerfile: ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/newrelic.yml Copy For a basic Docker installation, complete these configurations: Application name License key Logs Environment (optional) Enabled (optional) Application name The application name is a configuration you set to identify your application in New Relic. Tip You can reuse an application name for multiple apps serving the same role so that all the data from those apps rolls up into the same logical application in New Relic. For more detail about additional grouping options, see Use multiple names for an app. Replace MY_APP_NAME with your application name in one of these Dockerfile commands: Option Command Environment variable ENV NEW_RELIC_APP_NAME=\"MY_APP_NAME\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='MY_APP_NAME'\" Copy After you boot the container, your application name appears in New Relic. License key This configuration is required for you to report on any data in your New Relic Account. To copy your license key: Go to one.newrelic.com > (account dropdown) > Account settings. Under Account information, copy the license key. In one of these Dockerfile commands, replace MY_LICENSE_KEY with your license key: Option Command Environment variable ENV NEW_RELIC_LICENSE_KEY=\"MY_LICENSE_KEY\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.license_key='MY_LICENSE_KEY'\" Copy Logs By default, logs are written into the logs directory relative to the location of newrelic.jar. Make sure that the user account that starts your application server also has the right to perform tasks such as: Creating the logs directory. Creating and appending to the log files in that directory. Here’s a Dockerfile example where tomcat is the user who starts Tomcat: RUN mkdir -p /usr/local/tomcat/newrelic/logs RUN chown -R tomcat:tomcat /usr/local/tomcat/newrelic/logs Copy You can also send the logs to STDOUT by adding one of the following to the Dockerfile: Option Command Environment Variable ENV NEW_RELIC_LOG_FILE_NAME=STDOUT Copy Java system property ENV JAVA_OPTS=-Dnewrelic.config.log_file_name=STDOUT Copy Environment (optional) You can pass either a Java property or an environment variable to determine which of the environment-specific stanzas the agent uses in newrelic.yml. Use this approach if you prefer to have the newrelic.yml file control environment-specific configurations instead of passing all the configurations via Docker. Here’s a Dockerfile example of passing the newrelic.environment Java system property via Docker to use the custom value dev in the environment stanza of newrelic.yml: Using the shell form of the CMD instruction, include a reference to a new environment variable you choose (for example, ENV): CMD java -Dnewrelic.environment=$ENV -jar myjar.jar Copy In your docker run command line, include an argument to set the environment variable in the container: docker run -it -e \"ENV=dev\" myDockerImage Copy Important If you don’t specify a value for newrelic.environment, the agent assumes it is running in your production environment and uses the values from the main body of the configuration file. Enabled (optional) This configuration controls whether the agent is enabled. Let’s say you want the same Docker image for every installation. However, you don’t want to run the New Relic agent every time an engineer spins up a test app because you don’t want to run up your instance count. This problem can be solved using the newrelic.environment Java system property. In the main body of newrelic.yml, disable the Java agent by setting enabled: false. In specific environment stanzas of newrelic.yml, set enabled: true. Then, you can run specific agents by specifying the environment at runtime. Additional Tomcat Dockerfile examples Tomcat with environment and Java system properties FROM tomcat:9 # Add the newrelic.jar and -javaagent parameters RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/ ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" # Add the configuration file ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/ # An example of setting a system property config ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='My Application'\" # An example of setting an Environment variable config ENV NEW_RELIC_LICENSE_KEY=\"license_key\" # Config to include the agent logs in Docker's stdout logging ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.log_file_name=STDOUT\" EXPOSE 8080 CMD [\"catalina.sh\", \"run\"] Copy How to start an application with the Java agent FROM openjdk:8 ADD my-application.jar /app ADD newrelic.jar /app ADD newrelic.yml /app ENV NEW_RELIC_APP_NAME=\"My Application\" ENV NEW_RELIC_LICENSE_KEY=\"license_key\" ENV NEW_RELIC_LOG_FILE_NAME=\"STDOUT\" ENTRYPOINT [\"java\",\"-javaagent:/app/newrelic.jar\",\"-jar\",\"/app/my-application.jar\"] Copy Next steps Now that you have a basic agent installation in Docker, here are some additional steps to consider: Review other configurations for the agent. Read a detailed Explorers Hub post about Docker and New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.519394,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "sections": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": "This document explains a basic <em>installation</em> of the APM <em>agent</em> for <em>Java</em> applications in a Docker container. We discuss required configurations and also explore some optional configurations, including: How to use identical New Relic configuration files for each container, regardless of the environment"
      },
      "id": "603ea3dc28ccbc8889eba765"
    }
  ],
  "/docs/agents/java-agent/additional-installation/install-new-relic-java-agent-ansible": [
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.68117,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "<em>Installation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic <em>Java</em> <em>agent</em>. If the <em>Java</em> <em>agent</em> is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the <em>agent</em> will then report to the same"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "WildFly installation for Java",
        "Install WildFly versions earlier than 11",
        "Install WildFly version 11 or higher"
      ],
      "title": "WildFly installation for Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "7f9259f3b77efb78cd4861a9d7b519fe44191e3c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/wildfly-installation-java/",
      "published_at": "2021-06-02T15:31:27Z",
      "updated_at": "2021-03-16T14:29:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install New Relic's Java agent, make sure your WildFly version is supported. Depending on which WildFly version your application uses, additional configuration steps may be required. Install WildFly versions earlier than 11 If your supported WildFly version is earlier than v11, follow standard Java installation procedures. You do not need to do any additional configuration. Install WildFly version 11 or higher If you use WildFly version 11 or higher, New Relic's Java agent requires additional configuration after you install it. Install the Java agent. If you already have it installed, update to the latest Java agent version. Versions 5.0.0 and higher include fixes for later WildFly versions 11 and higher. Open the standalone configuration file appropriate for your operating system and add the -javaagent property to JAVA_OPTS. For example, if you use Linux, edit the /bin/standalone.conf file or /bin/standalone.conf.bat for Windows. Make sure the agent jar is visible to all JBoss modules by adding com.newrelic to the JBoss modules system packages using either of these options in the standalone script: Recommended: Option 1 (same as adding -javaagent property): JAVA_OPTS=\"$JAVA_OPTS -Djboss.modules.system.pkgs=$JBOSS_MODULES_SYSTEM_PKGS,com.newrelic Copy Option 2: if [ \"x$JBOSS_MODULES_SYSTEM_PKGS\" = \"x\" ]; then JBOSS_MODULES_SYSTEM_PKGS=\"org.jboss.byteman,com.newrelic\" fi Copy Restart your application server.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.519394,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "WildFly <em>installation</em> for <em>Java</em>",
        "sections": "WildFly <em>installation</em> for <em>Java</em>",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": " standard <em>Java</em> <em>installation</em> procedures. You do not need to do any <em>additional</em> configuration. Install WildFly version 11 or higher If you use WildFly version 11 or higher, New Relic&#x27;s <em>Java</em> <em>agent</em> requires <em>additional</em> configuration after you install it. Install the <em>Java</em> <em>agent</em>. If you already have"
      },
      "id": "603e791764441f18724e88ab"
    },
    {
      "sections": [
        "Install New Relic Java agent for Docker",
        "Tip",
        "Get the Java agent",
        "Download using curl",
        "Download using Invoke-WebRequest (PowerShell)",
        "Download from the New Relic UI",
        "Set up the installation directory",
        "Modify startup scripts",
        "Set agent configurations",
        "Application name",
        "License key",
        "Logs",
        "Environment (optional)",
        "Important",
        "Enabled (optional)",
        "Additional Tomcat Dockerfile examples",
        "Tomcat with environment and Java system properties",
        "How to start an application with the Java agent",
        "Next steps"
      ],
      "title": "Install New Relic Java agent for Docker",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "4de0ccd173c9851b045cfa036089e2f703b4a0f7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-new-relic-java-agent-docker/",
      "published_at": "2021-06-02T18:13:26Z",
      "updated_at": "2021-03-16T14:29:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains a basic installation of the APM agent for Java applications in a Docker container. We discuss required configurations and also explore some optional configurations, including: How to use identical New Relic configuration files for each container, regardless of the environment where the containers are used How to use the Docker layer when every agent in every environment needs slightly different configuration data How to disable the New Relic agent in some environments and enable it in others Although we don't discuss advanced options here, you can install the Java agent in Docker volumes and use your Docker container image in other software such as Swarm, ECS, AKS, EKS, OpenShift, and Kubernetes. Our Docker examples refer to Tomcat, so if you are using another application server, refer to your vendor’s documentation. Tip To use Java or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Get the Java agent Download newrelic-java.zip using curl, Invoke-WebRequest (PowerShell), or the New Relic UI: Download using curl Complete the following: Start a command-line session. Change to a temporary directory where you can download the zip file. Execute this curl command: curl -O https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip Copy Unzip newrelic-java.zip Download using Invoke-WebRequest (PowerShell) Complete the following: Start a PowerShell session. Change to a temporary directory where you can download the zip file. Execute this PowerShell command: Invoke-WebRequest -Uri https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip -OutFile newrelic-java.zip Copy Unzip newrelic-java.zip: Expand-Archive -Path newrelic-java.zip -DestinationPath DESTINATION_PATH Copy Download from the New Relic UI Complete the following: Log in to New Relic. From the account dropdown in the New Relic UI, select Account settings. In the right sidebar under Most recent, select the Java agent, and save the newrelic-java.zip to a temporary directory. Unzip newrelic-java.zip. Set up the installation directory You can unzip the newrelic-java.zip file wherever it is convenient for you. In the subsequent sections we assume you extracted it in the current working directory, which puts the files we need in ./newrelic. Modify startup scripts The startup script that contains the command to start your application server must include Java’s built-in argument -javaagent. We recommend that you set this argument with the JAVA_OPTS environment variable. The value of that argument must contain the location where you ADD the Java APM agent’s jar file to the image. For example, with Tomcat, use commands like these in the Dockerfile: RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/newrelic.jar ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" Copy Set agent configurations By default, agent behavior is controlled by configuration entries in newrelic.yml, which is typically located in the same directory as the agent. This section explains how to override these newrelic.yml configurations by using environment variables or Java system properties in the Dockerfile. Before we look at some specific configurations, here’s how to load newrelic.yml using the Dockerfile: ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/newrelic.yml Copy For a basic Docker installation, complete these configurations: Application name License key Logs Environment (optional) Enabled (optional) Application name The application name is a configuration you set to identify your application in New Relic. Tip You can reuse an application name for multiple apps serving the same role so that all the data from those apps rolls up into the same logical application in New Relic. For more detail about additional grouping options, see Use multiple names for an app. Replace MY_APP_NAME with your application name in one of these Dockerfile commands: Option Command Environment variable ENV NEW_RELIC_APP_NAME=\"MY_APP_NAME\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='MY_APP_NAME'\" Copy After you boot the container, your application name appears in New Relic. License key This configuration is required for you to report on any data in your New Relic Account. To copy your license key: Go to one.newrelic.com > (account dropdown) > Account settings. Under Account information, copy the license key. In one of these Dockerfile commands, replace MY_LICENSE_KEY with your license key: Option Command Environment variable ENV NEW_RELIC_LICENSE_KEY=\"MY_LICENSE_KEY\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.license_key='MY_LICENSE_KEY'\" Copy Logs By default, logs are written into the logs directory relative to the location of newrelic.jar. Make sure that the user account that starts your application server also has the right to perform tasks such as: Creating the logs directory. Creating and appending to the log files in that directory. Here’s a Dockerfile example where tomcat is the user who starts Tomcat: RUN mkdir -p /usr/local/tomcat/newrelic/logs RUN chown -R tomcat:tomcat /usr/local/tomcat/newrelic/logs Copy You can also send the logs to STDOUT by adding one of the following to the Dockerfile: Option Command Environment Variable ENV NEW_RELIC_LOG_FILE_NAME=STDOUT Copy Java system property ENV JAVA_OPTS=-Dnewrelic.config.log_file_name=STDOUT Copy Environment (optional) You can pass either a Java property or an environment variable to determine which of the environment-specific stanzas the agent uses in newrelic.yml. Use this approach if you prefer to have the newrelic.yml file control environment-specific configurations instead of passing all the configurations via Docker. Here’s a Dockerfile example of passing the newrelic.environment Java system property via Docker to use the custom value dev in the environment stanza of newrelic.yml: Using the shell form of the CMD instruction, include a reference to a new environment variable you choose (for example, ENV): CMD java -Dnewrelic.environment=$ENV -jar myjar.jar Copy In your docker run command line, include an argument to set the environment variable in the container: docker run -it -e \"ENV=dev\" myDockerImage Copy Important If you don’t specify a value for newrelic.environment, the agent assumes it is running in your production environment and uses the values from the main body of the configuration file. Enabled (optional) This configuration controls whether the agent is enabled. Let’s say you want the same Docker image for every installation. However, you don’t want to run the New Relic agent every time an engineer spins up a test app because you don’t want to run up your instance count. This problem can be solved using the newrelic.environment Java system property. In the main body of newrelic.yml, disable the Java agent by setting enabled: false. In specific environment stanzas of newrelic.yml, set enabled: true. Then, you can run specific agents by specifying the environment at runtime. Additional Tomcat Dockerfile examples Tomcat with environment and Java system properties FROM tomcat:9 # Add the newrelic.jar and -javaagent parameters RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/ ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" # Add the configuration file ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/ # An example of setting a system property config ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='My Application'\" # An example of setting an Environment variable config ENV NEW_RELIC_LICENSE_KEY=\"license_key\" # Config to include the agent logs in Docker's stdout logging ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.log_file_name=STDOUT\" EXPOSE 8080 CMD [\"catalina.sh\", \"run\"] Copy How to start an application with the Java agent FROM openjdk:8 ADD my-application.jar /app ADD newrelic.jar /app ADD newrelic.yml /app ENV NEW_RELIC_APP_NAME=\"My Application\" ENV NEW_RELIC_LICENSE_KEY=\"license_key\" ENV NEW_RELIC_LOG_FILE_NAME=\"STDOUT\" ENTRYPOINT [\"java\",\"-javaagent:/app/newrelic.jar\",\"-jar\",\"/app/my-application.jar\"] Copy Next steps Now that you have a basic agent installation in Docker, here are some additional steps to consider: Review other configurations for the agent. Read a detailed Explorers Hub post about Docker and New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.519394,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "sections": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": "This document explains a basic <em>installation</em> of the APM <em>agent</em> for <em>Java</em> applications in a Docker container. We discuss required configurations and also explore some optional configurations, including: How to use identical New Relic configuration files for each container, regardless of the environment"
      },
      "id": "603ea3dc28ccbc8889eba765"
    }
  ],
  "/docs/agents/java-agent/additional-installation/install-new-relic-java-agent-docker": [
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.68117,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "<em>Installation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic <em>Java</em> <em>agent</em>. If the <em>Java</em> <em>agent</em> is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the <em>agent</em> will then report to the same"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "WildFly installation for Java",
        "Install WildFly versions earlier than 11",
        "Install WildFly version 11 or higher"
      ],
      "title": "WildFly installation for Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "7f9259f3b77efb78cd4861a9d7b519fe44191e3c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/wildfly-installation-java/",
      "published_at": "2021-06-02T15:31:27Z",
      "updated_at": "2021-03-16T14:29:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install New Relic's Java agent, make sure your WildFly version is supported. Depending on which WildFly version your application uses, additional configuration steps may be required. Install WildFly versions earlier than 11 If your supported WildFly version is earlier than v11, follow standard Java installation procedures. You do not need to do any additional configuration. Install WildFly version 11 or higher If you use WildFly version 11 or higher, New Relic's Java agent requires additional configuration after you install it. Install the Java agent. If you already have it installed, update to the latest Java agent version. Versions 5.0.0 and higher include fixes for later WildFly versions 11 and higher. Open the standalone configuration file appropriate for your operating system and add the -javaagent property to JAVA_OPTS. For example, if you use Linux, edit the /bin/standalone.conf file or /bin/standalone.conf.bat for Windows. Make sure the agent jar is visible to all JBoss modules by adding com.newrelic to the JBoss modules system packages using either of these options in the standalone script: Recommended: Option 1 (same as adding -javaagent property): JAVA_OPTS=\"$JAVA_OPTS -Djboss.modules.system.pkgs=$JBOSS_MODULES_SYSTEM_PKGS,com.newrelic Copy Option 2: if [ \"x$JBOSS_MODULES_SYSTEM_PKGS\" = \"x\" ]; then JBOSS_MODULES_SYSTEM_PKGS=\"org.jboss.byteman,com.newrelic\" fi Copy Restart your application server.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.519394,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "WildFly <em>installation</em> for <em>Java</em>",
        "sections": "WildFly <em>installation</em> for <em>Java</em>",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": " standard <em>Java</em> <em>installation</em> procedures. You do not need to do any <em>additional</em> configuration. Install WildFly version 11 or higher If you use WildFly version 11 or higher, New Relic&#x27;s <em>Java</em> <em>agent</em> requires <em>additional</em> configuration after you install it. Install the <em>Java</em> <em>agent</em>. If you already have"
      },
      "id": "603e791764441f18724e88ab"
    },
    {
      "sections": [
        "Install New Relic Java agent with Ansible",
        "Compatibility and requirements",
        "Overview of process",
        "Step 1. Install the role",
        "Step 2. Incorporate the role into playbook",
        "Step 3. Configure the role",
        "Step 4. Configure the agent",
        "Step 5. Enable custom instrumentation (optional)",
        "For more help"
      ],
      "title": "Install New Relic Java agent with Ansible",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "328592f6b75e0eb638a0916082e034bb9782cad7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-new-relic-java-agent-ansible/",
      "published_at": "2021-06-02T18:13:25Z",
      "updated_at": "2021-03-16T14:28:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM for Java allows you to use an Ansible role for installation and configuration. Compatibility and requirements New Relic's Ansible role for the Java agent is open source and community-supported. It supports setting up our Java agent to instrument applications running under Tomcat, Jetty, and Wildfly (formerly JBoss) on Linux servers. The most common agent parameters can be configured through Ansible variables. You'll need to install Ansible to run this role. Ansible is run from a central server to configure target hosts; these hosts must be running Linux and have unzip installed. The role should be compatible with most popular Linux distributions. Overview of process There are several steps that may be involved for installation and configuration: Install the role Incorporate role in your playbook Configure the role Configure the agent Enable custom instrumentation (optional) Step 1. Install the role To install this role, use the ansible-galaxy command on the system where you run Ansible: $ ansible-galaxy install newrelic.newrelic_java_agent Copy This will download the role from Ansible Galaxy and make it available for use in Ansible playbooks. Step 2. Incorporate the role into playbook You'll need to call the role from your playbook using the include_role module. The role's GitHub repository contains an example playbook for you to start from, which looks like this: - hosts: YOUR_HOST_GROUP vars: nr_java_agent_config: license_key: YOUR_LICENSE_KEY app_name: YOUR_APP_NAME log_file_path: /tmp/newrelic server_type: tomcat server_root: /var/lib/tomcat8 jvm_conf_file: /usr/share/tomcat8/bin/setenv.sh server_user: tomcat8 server_group: tomcat8 service_name: tomcat8 restart_web_server: true tasks: - include_role: name: newrelic.newrelic_java_agent Copy The vars section contains a dictionary called nr_java_agent_config, which holds settings for the agent itself, and a number of variables for configuring the role's installation process. See the sections on agent configuration and role configuration for details. Step 3. Configure the role These variables are used to configure the install process. Most are required. For more information, see the examples on GitHub. Variable Description server_type Required. Web server used by your application. Possible values are: tomcat, jetty, and wildfly (standalone mode only). server_root Required. Location of the web server on the host. The agent's JAR, configuration, and (by default) log files will live in a subdirectory of this directory. jvm_conf_file Required. Path to the web server configuration file to reference the New Relic Java agent. For Tomcat, for instance, it's typically the setenv.sh file. If the file doesn't exist, it may be created, depending on the server_type. server_user server_group Required. User and group under which the web server runs. Used to set the ownership of the newrelic.jar and newrelic.yml files. restart_web_server Optional. Default: true. If set to false, the role does not restart the web server after installing the agent. Note that the agent is not activated until the web server is restarted. service_name Required (unless restart_web_server is set to false). Service name under which the web server runs. Used by Ansible to restart the web server after the agent is installed. nr_java_agent_version Optional; default: currentSpecifies the version of the Java agent to install. current will install the latest version. You can also install a specific version, like 5.9.0. For available versions, see Java agent downloads directory. Step 4. Configure the agent The following variables are used to configure the Java agent itself. These are just a few of the available options. For a full list of supported variables, see the README file on GitHub. For more about how to configure the agent, see Java agent configuration. Variable Description license_key Required. Your New Relic license key. app_name Required. Name of the application being instrumented. For more details, see App naming. proxy_host proxy_port proxy_user proxy_password proxy_scheme Optional. If you connect to the New Relic collector via a proxy, you can configure your proxy settings with these values. labels Optional. User-configurable custom labels for the agent. Labels are name-value pairs. Names and values are limited to 255 characters and cannot contain colons (:) nor semicolons (;). Value should be a semicolon-separated list of key-value pairs, for example Server:One;Data Center:Primary. Step 5. Enable custom instrumentation (optional) If you want to enable custom instrumentation, you can provide a list of XML files using the custom_instrumentation_files variable. For instance, you can specify that all Java agents being installed should use a file called my_instrumentation.xml by adding something like the following to your playbook: vars: custom_instrumentation_files: - /path/to/my_instrumentation.xml Copy See the README and examples on GitHub for more information. For more help If you need additional help, file an issue at newrelic/newrelic-java-agent-ansible-role on GitHub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.51928,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> with Ansible",
        "sections": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> with Ansible",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": "APM for <em>Java</em> allows you to use an Ansible role for <em>installation</em> and configuration. Compatibility and requirements New Relic&#x27;s Ansible role for the <em>Java</em> <em>agent</em> is open source and community-supported. It supports setting up our <em>Java</em> <em>agent</em> to instrument applications running under Tomcat, Jetty"
      },
      "id": "603e92dce7b9d2a5d32a080c"
    }
  ],
  "/docs/agents/java-agent/additional-installation/install-new-relic-java-agent-gae-flexible-environment": [
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.68111,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "<em>Installation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic <em>Java</em> <em>agent</em>. If the <em>Java</em> <em>agent</em> is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the <em>agent</em> will then report to the same"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "WildFly installation for Java",
        "Install WildFly versions earlier than 11",
        "Install WildFly version 11 or higher"
      ],
      "title": "WildFly installation for Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "7f9259f3b77efb78cd4861a9d7b519fe44191e3c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/wildfly-installation-java/",
      "published_at": "2021-06-02T15:31:27Z",
      "updated_at": "2021-03-16T14:29:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install New Relic's Java agent, make sure your WildFly version is supported. Depending on which WildFly version your application uses, additional configuration steps may be required. Install WildFly versions earlier than 11 If your supported WildFly version is earlier than v11, follow standard Java installation procedures. You do not need to do any additional configuration. Install WildFly version 11 or higher If you use WildFly version 11 or higher, New Relic's Java agent requires additional configuration after you install it. Install the Java agent. If you already have it installed, update to the latest Java agent version. Versions 5.0.0 and higher include fixes for later WildFly versions 11 and higher. Open the standalone configuration file appropriate for your operating system and add the -javaagent property to JAVA_OPTS. For example, if you use Linux, edit the /bin/standalone.conf file or /bin/standalone.conf.bat for Windows. Make sure the agent jar is visible to all JBoss modules by adding com.newrelic to the JBoss modules system packages using either of these options in the standalone script: Recommended: Option 1 (same as adding -javaagent property): JAVA_OPTS=\"$JAVA_OPTS -Djboss.modules.system.pkgs=$JBOSS_MODULES_SYSTEM_PKGS,com.newrelic Copy Option 2: if [ \"x$JBOSS_MODULES_SYSTEM_PKGS\" = \"x\" ]; then JBOSS_MODULES_SYSTEM_PKGS=\"org.jboss.byteman,com.newrelic\" fi Copy Restart your application server.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.51939,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "WildFly <em>installation</em> for <em>Java</em>",
        "sections": "WildFly <em>installation</em> for <em>Java</em>",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": " standard <em>Java</em> <em>installation</em> procedures. You do not need to do any <em>additional</em> configuration. Install WildFly version 11 or higher If you use WildFly version 11 or higher, New Relic&#x27;s <em>Java</em> <em>agent</em> requires <em>additional</em> configuration after you install it. Install the <em>Java</em> <em>agent</em>. If you already have"
      },
      "id": "603e791764441f18724e88ab"
    },
    {
      "sections": [
        "Install New Relic Java agent for Docker",
        "Tip",
        "Get the Java agent",
        "Download using curl",
        "Download using Invoke-WebRequest (PowerShell)",
        "Download from the New Relic UI",
        "Set up the installation directory",
        "Modify startup scripts",
        "Set agent configurations",
        "Application name",
        "License key",
        "Logs",
        "Environment (optional)",
        "Important",
        "Enabled (optional)",
        "Additional Tomcat Dockerfile examples",
        "Tomcat with environment and Java system properties",
        "How to start an application with the Java agent",
        "Next steps"
      ],
      "title": "Install New Relic Java agent for Docker",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "4de0ccd173c9851b045cfa036089e2f703b4a0f7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-new-relic-java-agent-docker/",
      "published_at": "2021-06-02T18:13:26Z",
      "updated_at": "2021-03-16T14:29:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains a basic installation of the APM agent for Java applications in a Docker container. We discuss required configurations and also explore some optional configurations, including: How to use identical New Relic configuration files for each container, regardless of the environment where the containers are used How to use the Docker layer when every agent in every environment needs slightly different configuration data How to disable the New Relic agent in some environments and enable it in others Although we don't discuss advanced options here, you can install the Java agent in Docker volumes and use your Docker container image in other software such as Swarm, ECS, AKS, EKS, OpenShift, and Kubernetes. Our Docker examples refer to Tomcat, so if you are using another application server, refer to your vendor’s documentation. Tip To use Java or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Get the Java agent Download newrelic-java.zip using curl, Invoke-WebRequest (PowerShell), or the New Relic UI: Download using curl Complete the following: Start a command-line session. Change to a temporary directory where you can download the zip file. Execute this curl command: curl -O https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip Copy Unzip newrelic-java.zip Download using Invoke-WebRequest (PowerShell) Complete the following: Start a PowerShell session. Change to a temporary directory where you can download the zip file. Execute this PowerShell command: Invoke-WebRequest -Uri https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip -OutFile newrelic-java.zip Copy Unzip newrelic-java.zip: Expand-Archive -Path newrelic-java.zip -DestinationPath DESTINATION_PATH Copy Download from the New Relic UI Complete the following: Log in to New Relic. From the account dropdown in the New Relic UI, select Account settings. In the right sidebar under Most recent, select the Java agent, and save the newrelic-java.zip to a temporary directory. Unzip newrelic-java.zip. Set up the installation directory You can unzip the newrelic-java.zip file wherever it is convenient for you. In the subsequent sections we assume you extracted it in the current working directory, which puts the files we need in ./newrelic. Modify startup scripts The startup script that contains the command to start your application server must include Java’s built-in argument -javaagent. We recommend that you set this argument with the JAVA_OPTS environment variable. The value of that argument must contain the location where you ADD the Java APM agent’s jar file to the image. For example, with Tomcat, use commands like these in the Dockerfile: RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/newrelic.jar ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" Copy Set agent configurations By default, agent behavior is controlled by configuration entries in newrelic.yml, which is typically located in the same directory as the agent. This section explains how to override these newrelic.yml configurations by using environment variables or Java system properties in the Dockerfile. Before we look at some specific configurations, here’s how to load newrelic.yml using the Dockerfile: ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/newrelic.yml Copy For a basic Docker installation, complete these configurations: Application name License key Logs Environment (optional) Enabled (optional) Application name The application name is a configuration you set to identify your application in New Relic. Tip You can reuse an application name for multiple apps serving the same role so that all the data from those apps rolls up into the same logical application in New Relic. For more detail about additional grouping options, see Use multiple names for an app. Replace MY_APP_NAME with your application name in one of these Dockerfile commands: Option Command Environment variable ENV NEW_RELIC_APP_NAME=\"MY_APP_NAME\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='MY_APP_NAME'\" Copy After you boot the container, your application name appears in New Relic. License key This configuration is required for you to report on any data in your New Relic Account. To copy your license key: Go to one.newrelic.com > (account dropdown) > Account settings. Under Account information, copy the license key. In one of these Dockerfile commands, replace MY_LICENSE_KEY with your license key: Option Command Environment variable ENV NEW_RELIC_LICENSE_KEY=\"MY_LICENSE_KEY\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.license_key='MY_LICENSE_KEY'\" Copy Logs By default, logs are written into the logs directory relative to the location of newrelic.jar. Make sure that the user account that starts your application server also has the right to perform tasks such as: Creating the logs directory. Creating and appending to the log files in that directory. Here’s a Dockerfile example where tomcat is the user who starts Tomcat: RUN mkdir -p /usr/local/tomcat/newrelic/logs RUN chown -R tomcat:tomcat /usr/local/tomcat/newrelic/logs Copy You can also send the logs to STDOUT by adding one of the following to the Dockerfile: Option Command Environment Variable ENV NEW_RELIC_LOG_FILE_NAME=STDOUT Copy Java system property ENV JAVA_OPTS=-Dnewrelic.config.log_file_name=STDOUT Copy Environment (optional) You can pass either a Java property or an environment variable to determine which of the environment-specific stanzas the agent uses in newrelic.yml. Use this approach if you prefer to have the newrelic.yml file control environment-specific configurations instead of passing all the configurations via Docker. Here’s a Dockerfile example of passing the newrelic.environment Java system property via Docker to use the custom value dev in the environment stanza of newrelic.yml: Using the shell form of the CMD instruction, include a reference to a new environment variable you choose (for example, ENV): CMD java -Dnewrelic.environment=$ENV -jar myjar.jar Copy In your docker run command line, include an argument to set the environment variable in the container: docker run -it -e \"ENV=dev\" myDockerImage Copy Important If you don’t specify a value for newrelic.environment, the agent assumes it is running in your production environment and uses the values from the main body of the configuration file. Enabled (optional) This configuration controls whether the agent is enabled. Let’s say you want the same Docker image for every installation. However, you don’t want to run the New Relic agent every time an engineer spins up a test app because you don’t want to run up your instance count. This problem can be solved using the newrelic.environment Java system property. In the main body of newrelic.yml, disable the Java agent by setting enabled: false. In specific environment stanzas of newrelic.yml, set enabled: true. Then, you can run specific agents by specifying the environment at runtime. Additional Tomcat Dockerfile examples Tomcat with environment and Java system properties FROM tomcat:9 # Add the newrelic.jar and -javaagent parameters RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/ ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" # Add the configuration file ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/ # An example of setting a system property config ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='My Application'\" # An example of setting an Environment variable config ENV NEW_RELIC_LICENSE_KEY=\"license_key\" # Config to include the agent logs in Docker's stdout logging ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.log_file_name=STDOUT\" EXPOSE 8080 CMD [\"catalina.sh\", \"run\"] Copy How to start an application with the Java agent FROM openjdk:8 ADD my-application.jar /app ADD newrelic.jar /app ADD newrelic.yml /app ENV NEW_RELIC_APP_NAME=\"My Application\" ENV NEW_RELIC_LICENSE_KEY=\"license_key\" ENV NEW_RELIC_LOG_FILE_NAME=\"STDOUT\" ENTRYPOINT [\"java\",\"-javaagent:/app/newrelic.jar\",\"-jar\",\"/app/my-application.jar\"] Copy Next steps Now that you have a basic agent installation in Docker, here are some additional steps to consider: Review other configurations for the agent. Read a detailed Explorers Hub post about Docker and New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.51939,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "sections": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": "This document explains a basic <em>installation</em> of the APM <em>agent</em> for <em>Java</em> applications in a Docker container. We discuss required configurations and also explore some optional configurations, including: How to use identical New Relic configuration files for each container, regardless of the environment"
      },
      "id": "603ea3dc28ccbc8889eba765"
    }
  ],
  "/docs/agents/java-agent/additional-installation/wildfly-installation-java": [
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.681046,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "<em>Installation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic <em>Java</em> <em>agent</em>. If the <em>Java</em> <em>agent</em> is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the <em>agent</em> will then report to the same"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "Install New Relic Java agent for Docker",
        "Tip",
        "Get the Java agent",
        "Download using curl",
        "Download using Invoke-WebRequest (PowerShell)",
        "Download from the New Relic UI",
        "Set up the installation directory",
        "Modify startup scripts",
        "Set agent configurations",
        "Application name",
        "License key",
        "Logs",
        "Environment (optional)",
        "Important",
        "Enabled (optional)",
        "Additional Tomcat Dockerfile examples",
        "Tomcat with environment and Java system properties",
        "How to start an application with the Java agent",
        "Next steps"
      ],
      "title": "Install New Relic Java agent for Docker",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "4de0ccd173c9851b045cfa036089e2f703b4a0f7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-new-relic-java-agent-docker/",
      "published_at": "2021-06-02T18:13:26Z",
      "updated_at": "2021-03-16T14:29:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains a basic installation of the APM agent for Java applications in a Docker container. We discuss required configurations and also explore some optional configurations, including: How to use identical New Relic configuration files for each container, regardless of the environment where the containers are used How to use the Docker layer when every agent in every environment needs slightly different configuration data How to disable the New Relic agent in some environments and enable it in others Although we don't discuss advanced options here, you can install the Java agent in Docker volumes and use your Docker container image in other software such as Swarm, ECS, AKS, EKS, OpenShift, and Kubernetes. Our Docker examples refer to Tomcat, so if you are using another application server, refer to your vendor’s documentation. Tip To use Java or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Get the Java agent Download newrelic-java.zip using curl, Invoke-WebRequest (PowerShell), or the New Relic UI: Download using curl Complete the following: Start a command-line session. Change to a temporary directory where you can download the zip file. Execute this curl command: curl -O https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip Copy Unzip newrelic-java.zip Download using Invoke-WebRequest (PowerShell) Complete the following: Start a PowerShell session. Change to a temporary directory where you can download the zip file. Execute this PowerShell command: Invoke-WebRequest -Uri https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip -OutFile newrelic-java.zip Copy Unzip newrelic-java.zip: Expand-Archive -Path newrelic-java.zip -DestinationPath DESTINATION_PATH Copy Download from the New Relic UI Complete the following: Log in to New Relic. From the account dropdown in the New Relic UI, select Account settings. In the right sidebar under Most recent, select the Java agent, and save the newrelic-java.zip to a temporary directory. Unzip newrelic-java.zip. Set up the installation directory You can unzip the newrelic-java.zip file wherever it is convenient for you. In the subsequent sections we assume you extracted it in the current working directory, which puts the files we need in ./newrelic. Modify startup scripts The startup script that contains the command to start your application server must include Java’s built-in argument -javaagent. We recommend that you set this argument with the JAVA_OPTS environment variable. The value of that argument must contain the location where you ADD the Java APM agent’s jar file to the image. For example, with Tomcat, use commands like these in the Dockerfile: RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/newrelic.jar ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" Copy Set agent configurations By default, agent behavior is controlled by configuration entries in newrelic.yml, which is typically located in the same directory as the agent. This section explains how to override these newrelic.yml configurations by using environment variables or Java system properties in the Dockerfile. Before we look at some specific configurations, here’s how to load newrelic.yml using the Dockerfile: ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/newrelic.yml Copy For a basic Docker installation, complete these configurations: Application name License key Logs Environment (optional) Enabled (optional) Application name The application name is a configuration you set to identify your application in New Relic. Tip You can reuse an application name for multiple apps serving the same role so that all the data from those apps rolls up into the same logical application in New Relic. For more detail about additional grouping options, see Use multiple names for an app. Replace MY_APP_NAME with your application name in one of these Dockerfile commands: Option Command Environment variable ENV NEW_RELIC_APP_NAME=\"MY_APP_NAME\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='MY_APP_NAME'\" Copy After you boot the container, your application name appears in New Relic. License key This configuration is required for you to report on any data in your New Relic Account. To copy your license key: Go to one.newrelic.com > (account dropdown) > Account settings. Under Account information, copy the license key. In one of these Dockerfile commands, replace MY_LICENSE_KEY with your license key: Option Command Environment variable ENV NEW_RELIC_LICENSE_KEY=\"MY_LICENSE_KEY\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.license_key='MY_LICENSE_KEY'\" Copy Logs By default, logs are written into the logs directory relative to the location of newrelic.jar. Make sure that the user account that starts your application server also has the right to perform tasks such as: Creating the logs directory. Creating and appending to the log files in that directory. Here’s a Dockerfile example where tomcat is the user who starts Tomcat: RUN mkdir -p /usr/local/tomcat/newrelic/logs RUN chown -R tomcat:tomcat /usr/local/tomcat/newrelic/logs Copy You can also send the logs to STDOUT by adding one of the following to the Dockerfile: Option Command Environment Variable ENV NEW_RELIC_LOG_FILE_NAME=STDOUT Copy Java system property ENV JAVA_OPTS=-Dnewrelic.config.log_file_name=STDOUT Copy Environment (optional) You can pass either a Java property or an environment variable to determine which of the environment-specific stanzas the agent uses in newrelic.yml. Use this approach if you prefer to have the newrelic.yml file control environment-specific configurations instead of passing all the configurations via Docker. Here’s a Dockerfile example of passing the newrelic.environment Java system property via Docker to use the custom value dev in the environment stanza of newrelic.yml: Using the shell form of the CMD instruction, include a reference to a new environment variable you choose (for example, ENV): CMD java -Dnewrelic.environment=$ENV -jar myjar.jar Copy In your docker run command line, include an argument to set the environment variable in the container: docker run -it -e \"ENV=dev\" myDockerImage Copy Important If you don’t specify a value for newrelic.environment, the agent assumes it is running in your production environment and uses the values from the main body of the configuration file. Enabled (optional) This configuration controls whether the agent is enabled. Let’s say you want the same Docker image for every installation. However, you don’t want to run the New Relic agent every time an engineer spins up a test app because you don’t want to run up your instance count. This problem can be solved using the newrelic.environment Java system property. In the main body of newrelic.yml, disable the Java agent by setting enabled: false. In specific environment stanzas of newrelic.yml, set enabled: true. Then, you can run specific agents by specifying the environment at runtime. Additional Tomcat Dockerfile examples Tomcat with environment and Java system properties FROM tomcat:9 # Add the newrelic.jar and -javaagent parameters RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/ ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" # Add the configuration file ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/ # An example of setting a system property config ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='My Application'\" # An example of setting an Environment variable config ENV NEW_RELIC_LICENSE_KEY=\"license_key\" # Config to include the agent logs in Docker's stdout logging ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.log_file_name=STDOUT\" EXPOSE 8080 CMD [\"catalina.sh\", \"run\"] Copy How to start an application with the Java agent FROM openjdk:8 ADD my-application.jar /app ADD newrelic.jar /app ADD newrelic.yml /app ENV NEW_RELIC_APP_NAME=\"My Application\" ENV NEW_RELIC_LICENSE_KEY=\"license_key\" ENV NEW_RELIC_LOG_FILE_NAME=\"STDOUT\" ENTRYPOINT [\"java\",\"-javaagent:/app/newrelic.jar\",\"-jar\",\"/app/my-application.jar\"] Copy Next steps Now that you have a basic agent installation in Docker, here are some additional steps to consider: Review other configurations for the agent. Read a detailed Explorers Hub post about Docker and New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.51939,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "sections": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": "This document explains a basic <em>installation</em> of the APM <em>agent</em> for <em>Java</em> applications in a Docker container. We discuss required configurations and also explore some optional configurations, including: How to use identical New Relic configuration files for each container, regardless of the environment"
      },
      "id": "603ea3dc28ccbc8889eba765"
    },
    {
      "sections": [
        "Install New Relic Java agent with Ansible",
        "Compatibility and requirements",
        "Overview of process",
        "Step 1. Install the role",
        "Step 2. Incorporate the role into playbook",
        "Step 3. Configure the role",
        "Step 4. Configure the agent",
        "Step 5. Enable custom instrumentation (optional)",
        "For more help"
      ],
      "title": "Install New Relic Java agent with Ansible",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "328592f6b75e0eb638a0916082e034bb9782cad7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-new-relic-java-agent-ansible/",
      "published_at": "2021-06-02T18:13:25Z",
      "updated_at": "2021-03-16T14:28:37Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM for Java allows you to use an Ansible role for installation and configuration. Compatibility and requirements New Relic's Ansible role for the Java agent is open source and community-supported. It supports setting up our Java agent to instrument applications running under Tomcat, Jetty, and Wildfly (formerly JBoss) on Linux servers. The most common agent parameters can be configured through Ansible variables. You'll need to install Ansible to run this role. Ansible is run from a central server to configure target hosts; these hosts must be running Linux and have unzip installed. The role should be compatible with most popular Linux distributions. Overview of process There are several steps that may be involved for installation and configuration: Install the role Incorporate role in your playbook Configure the role Configure the agent Enable custom instrumentation (optional) Step 1. Install the role To install this role, use the ansible-galaxy command on the system where you run Ansible: $ ansible-galaxy install newrelic.newrelic_java_agent Copy This will download the role from Ansible Galaxy and make it available for use in Ansible playbooks. Step 2. Incorporate the role into playbook You'll need to call the role from your playbook using the include_role module. The role's GitHub repository contains an example playbook for you to start from, which looks like this: - hosts: YOUR_HOST_GROUP vars: nr_java_agent_config: license_key: YOUR_LICENSE_KEY app_name: YOUR_APP_NAME log_file_path: /tmp/newrelic server_type: tomcat server_root: /var/lib/tomcat8 jvm_conf_file: /usr/share/tomcat8/bin/setenv.sh server_user: tomcat8 server_group: tomcat8 service_name: tomcat8 restart_web_server: true tasks: - include_role: name: newrelic.newrelic_java_agent Copy The vars section contains a dictionary called nr_java_agent_config, which holds settings for the agent itself, and a number of variables for configuring the role's installation process. See the sections on agent configuration and role configuration for details. Step 3. Configure the role These variables are used to configure the install process. Most are required. For more information, see the examples on GitHub. Variable Description server_type Required. Web server used by your application. Possible values are: tomcat, jetty, and wildfly (standalone mode only). server_root Required. Location of the web server on the host. The agent's JAR, configuration, and (by default) log files will live in a subdirectory of this directory. jvm_conf_file Required. Path to the web server configuration file to reference the New Relic Java agent. For Tomcat, for instance, it's typically the setenv.sh file. If the file doesn't exist, it may be created, depending on the server_type. server_user server_group Required. User and group under which the web server runs. Used to set the ownership of the newrelic.jar and newrelic.yml files. restart_web_server Optional. Default: true. If set to false, the role does not restart the web server after installing the agent. Note that the agent is not activated until the web server is restarted. service_name Required (unless restart_web_server is set to false). Service name under which the web server runs. Used by Ansible to restart the web server after the agent is installed. nr_java_agent_version Optional; default: currentSpecifies the version of the Java agent to install. current will install the latest version. You can also install a specific version, like 5.9.0. For available versions, see Java agent downloads directory. Step 4. Configure the agent The following variables are used to configure the Java agent itself. These are just a few of the available options. For a full list of supported variables, see the README file on GitHub. For more about how to configure the agent, see Java agent configuration. Variable Description license_key Required. Your New Relic license key. app_name Required. Name of the application being instrumented. For more details, see App naming. proxy_host proxy_port proxy_user proxy_password proxy_scheme Optional. If you connect to the New Relic collector via a proxy, you can configure your proxy settings with these values. labels Optional. User-configurable custom labels for the agent. Labels are name-value pairs. Names and values are limited to 255 characters and cannot contain colons (:) nor semicolons (;). Value should be a semicolon-separated list of key-value pairs, for example Server:One;Data Center:Primary. Step 5. Enable custom instrumentation (optional) If you want to enable custom instrumentation, you can provide a list of XML files using the custom_instrumentation_files variable. For instance, you can specify that all Java agents being installed should use a file called my_instrumentation.xml by adding something like the following to your playbook: vars: custom_instrumentation_files: - /path/to/my_instrumentation.xml Copy See the README and examples on GitHub for more information. For more help If you need additional help, file an issue at newrelic/newrelic-java-agent-ansible-role on GitHub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.51928,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> with Ansible",
        "sections": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> with Ansible",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": "APM for <em>Java</em> allows you to use an Ansible role for <em>installation</em> and configuration. Compatibility and requirements New Relic&#x27;s Ansible role for the <em>Java</em> <em>agent</em> is open source and community-supported. It supports setting up our <em>Java</em> <em>agent</em> to instrument applications running under Tomcat, Jetty"
      },
      "id": "603e92dce7b9d2a5d32a080c"
    }
  ],
  "/docs/agents/java-agent/api-guides/guide-using-java-agent-api": [
    {
      "sections": [
        "Guide to using the Python agent API",
        "Custom instrumentation or API",
        "Monitor transactions and segments",
        "Add and edit transaction metadata",
        "Report custom events and custom metric data",
        "Message-related calls",
        "Implement distributed tracing",
        "Agent configuration, initialization, shutdown",
        "Control the Browser monitoring agent"
      ],
      "title": "Guide to using the Python agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "Python agent",
        "API guides"
      ],
      "external_id": "41f2cf33977b57e872b8c69a30b77fd603b51926",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/python-agent/api-guides/guide-using-python-agent-api/",
      "published_at": "2021-06-02T13:37:41Z",
      "updated_at": "2021-06-02T13:37:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Python agent API allows you to customize and extend your monitoring. Use the Python agent API to: Manually instrument an unsupported framework or third-party system. Add instrumentation to supplement the agent's default monitoring. This document describes some of the available Python API calls. For a description of all our available APIs, see Introduction to APIs. Custom instrumentation or API If your goal is custom instrumentation, consider using the configuration file method, which allows you to add functions and class methods to the config file that will be auto-instrumented by the agent. The benefit of the config-file method is that it does not require you to change your application code. However, the Python agent API is much more powerful and is best for setting up more complex and tailored instrumentation. To ensure you have access to the full API functionality, update to the latest Python agent. Monitor transactions and segments The Python agent is compatible with most of the common WSGI web frameworks. If the agent supports your framework, web requests automatically will be captured as transactions and displayed in the New Relic One UI. A transaction can also have function-level segments that are captured as part of a transaction trace. Use these methods to monitor web transactions, non-web transactions, and transaction segments: If you want to... Do this... Monitor WSGI web transactions The Python agent automatically captures web transactions for supported frameworks. If you do not have a supported framework, you can use the wsgi_application function to monitor your WSGI entry point. Monitor non-web transactions The Python agent classifies non-web transactions as background tasks. To capture non-web transactions, use background_task. Capture more details about a transaction If your transaction traces do not have the level of detail you want: Use function_trace to capture more function-level detail in transactions. Use datastore_trace to capture more detail about datastore calls. Ignore a transaction Use any of these options: To ignore a transaction altogether, use ignore_transaction. To prevent a transaction from producing a transaction trace, use suppress_transaction_trace. To end a transaction before the agent would end it automatically, use end_of_transaction. Add and edit transaction metadata Sometimes the code you target is visible in our UI, but some details of the method are not useful. For example: The default name is not helpful, or it is causing a metric grouping issue. You want to add custom attributes to your transactions so you can filter them when querying. Use these calls when you want to change the metadata of an existing transaction: If you want to... Do this... Get reference to current transaction To return an object representing the current transaction, use current_transaction. This is required by some other Python agent API calls. Change the name of a transaction Use set_transaction_name. Add metadata (such as a customer's subscription level) to transactions Add custom attributes to your transactions using add_custom_parameter, or use other API calls to report custom data. Mark a transaction as a background job To convert a web transaction into a background task so that it appears as a non-web transaction in the UI, use set_background_task. Prevent a transaction from affecting your Apdex score Use suppress_apdex_metric. Report custom events and custom metric data The agent reports data in two primary forms: Metric data measures numeric, time-based values; for example, connections per minute. Event data captures discrete event information. Events have key-value attributes attached to them. You can analyze and query event data. Use these methods to create new event data and new metric data: If you want to... Do this... Send data about an event for use when querying your data. Use record_custom_event. Report time-based metrics on application performance To report a single metric, use record_custom_metric. To report a set of metrics, use record_custom_metrics. Report an exception as an error By default, the Python agent only reports unhandled exceptions. To report a Python exception as an error, use notice_error. Report query string parameters For security reasons, query string parameters associated with web transactions are disabled by default. Use capture_request_params to enable them. Tag events with metadata To add attributes to events for more detailed analysis in Insights or error analytics, use add_custom_parameter. Generate metrics from data sources and data factories To generate metrics with a pull-style API rather than the push-style API implemented by record_custom_metric(), use these API calls: register_data_source data_source_generator data_source_factory Message-related calls These API calls allow you to collect performance data on your message-passing architecture or service; for example, RabbitMQ. To use these calls, make sure you have Python agent version 2.88.0.72 or higher. If you want to... Do this... Report messages as a transaction Use message_transaction. Report message details as transaction trace segments Use message_trace. Implement distributed tracing These APIs require distributed tracing to be enabled. Services and applications monitored by our agents will automatically pass distributed tracing context to each other when using a supported framework. When not using a supported framework, you will need to use the distributed tracing APIs to manually accept this context. Supported web frameworks (for example, Flask, Django, Tornado) will automatically call accept_distributed_trace_payload when creating a transaction. Supported external web services libraries will automatically call create_distributed_trace_payload before making an external HTTP call. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. If you want to... Do this... Create a payload to be sent to a called service. Use create_distributed_trace_payload. Accept a payload sent from the first service; this will link these services together in a trace Use accept_distributed_trace_payload. Agent configuration, initialization, shutdown These calls help you manage Python agent behavior, such as initializing and integrating the agent, and referencing or changing configuration settings: If you want to... Do this... Initialize the agent To initialize the Python agent with a specific configuration file as part of advanced integration process, use initialize. Get a reference to the application object The application object represents an agent-monitored application and is used by some Python agent API calls. Get a reference to configuration settings To control the Python agent's behavior, you can use configuration settings. To get a reference to config file and environment variable settings and make changes to them, use global_settings. To get a reference to all settings, including server-side configuration from our UI, use application_settings. Shut down the agent To forcibly shut down the agent instead of allowing it to make the standard final attempt to upload data, use shutdown_agent. Control the Browser monitoring agent You can install the browser monitoring agent by automatically adding it to your pages or by deploying it on specific pages by copying and pasting the browser agent JavaScript snippet. You can also control the browser agent by using APM agent API calls. For more information, see Browser agent and the Python agent. If you want to... Do this... Monitor specific page views To inject the browser agent header and footer JavaScript snippets into views you want to monitor, use both get_browser_timing_header and get_browser_timing_footer. Disable monitoring of specific page views To disable browser monitoring for specific page views, use disable_browser_autorum.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.59268,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Guide</em> to using the Python <em>agent</em> <em>API</em>",
        "sections": "<em>Guide</em> to using the Python <em>agent</em> <em>API</em>",
        "tags": "<em>API</em> <em>guides</em>",
        "body": ". Control the Browser monitoring <em>agent</em> You can install the browser monitoring <em>agent</em> by automatically adding it to your pages or by deploying it on specific pages by copying and pasting the browser <em>agent</em> <em>Java</em>Script snippet. You can also control the browser <em>agent</em> by using APM <em>agent</em> <em>API</em> calls. For more"
      },
      "id": "60441c8d64441f0ec7378eff"
    },
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 101.916626,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the instrumentation package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]instrumentation.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate configuration to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    },
    {
      "sections": [
        "Java agent API: Custom instrumentation with annotation of an example app",
        "Important",
        "Complete example app using API",
        "Tip",
        "Complete API call example",
        "How the example uses the API",
        "Import the needed packages",
        "Set @Trace for transaction traces",
        "Create custom names for web transactions",
        "Bypass Apdex when collecting non-public data",
        "Record the user ID",
        "Collect promotion data",
        "Send instructions to the handler",
        "Include page load timing code in the HTTP response",
        "Complete the HTTP response"
      ],
      "title": "Java agent API: Custom instrumentation with annotation of an example app",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "a6a2aadf63f8282b7d599579f67010fbd600d183",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/java-agent-api-custom-instrumentation-annotation-example-app/",
      "published_at": "2021-06-02T16:06:19Z",
      "updated_at": "2021-03-16T14:30:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you set up custom instrumentation for your Java application. This document shows an example of using custom instrumentation with annotation in an imaginary application. Important For best results when using the API, ensure you have the latest Java agent release. Complete example app using API Below is an example of an imaginary store app's servlet using the Java agent API. Tip If you copy and paste example code, be sure to use appropriate spacing on your command lines. Complete API call example package test; import java.io.IOException; import java.io.PrintWriter; import java.util.Random; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; // Java agent API imports import com.newrelic.api.agent.NewRelic; import com.newrelic.api.agent.Trace; public class TestServlet extends HttpServlet { // instrumentation via annotation @Trace(dispatcher = true) protected void processRequest(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { saveNewRelicInfo(req); doRequestWork(req); writeResponse(resp); } private void saveNewRelicInfo(HttpServletRequest req) { String storeId = req.getParameter(\"storeId\"); if (storeId != null) { // set the name of the Transaction NewRelic.setTransactionName(null, \"/store\"); if (storeId.equals(\"betaStore\")) { // prevent the method from contributing to the Apdex score NewRelic.ignoreApdex(); } } String userId = req.getParameter(\"userId\"); if (userId != null) { // set the user name to associate with the RUM JavaScript footer // for the current web transaction NewRelic.setUserName(userId); // add a key/value pair to the current transaction NewRelic.addCustomParameter(\"userId\", userId); } String promotionId = req.getParameter(\"promotionId\"); if (promotionId != null) { // increment the metric counter for the given name NewRelic.incrementCounter(\"Custom/Promotion\"); } } protected void doRequestWork(HttpServletRequest req) { try { long millisToSleep = new Random().nextInt(5000); Thread.sleep(millisToSleep); // record a response time in milliseconds for the given metric name NewRelic.recordResponseTimeMetric(\"Custom/RandomSleep\", millisToSleep); } catch (InterruptedException e) { // report a handled exception NewRelic.noticeError(e, false); } } protected void writeResponse(HttpServletResponse resp) throws IOException { resp.setContentType(\"text/html;charset=UTF-8\"); PrintWriter out = resp.getWriter(); out.println(\"<html>\"); out.println(\"<head>\"); // get the RUM JavaScript header for the current web transaction out.println(NewRelic.getBrowserTimingHeader()); out.println(\"<title>NewRelic API example servlet</title>\"); out.println(\"</head>\"); out.println(\"<body>\"); out.println(\"<h1>API example</h1>\"); // get the RUM JavaScript footer for the current web transaction out.println(NewRelic.getBrowserTimingFooter()); out.println(\"</body>\"); out.println(\"</html>\"); out.close(); } protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { processRequest(req, resp); } protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { processRequest(req, resp); } } Copy How the example uses the API Here is the same example app divided into sections that describe how the API is used: Import the needed packages This part of the example shows the imports needed for the example application and Java agent API. package test; import java.io.IOException; import java.io.PrintWriter; import java.util.Random; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; // Java agent API imports import com.newrelic.api.agent.NewRelic; import com.newrelic.api.agent.Trace; Copy Set @Trace for transaction traces This part of the API call provides instructions to instrument this call using New Relic's trace annotation @Trace. Any requests that hit processRequest will now show a segment in APM's Transaction trace call chart. public class TestServlet extends HttpServlet { // instrumentation via annotation @Trace(dispatcher = true) protected void processRequest(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { saveNewRelicInfo(req); doRequestWork(req); writeResponse(resp); } Copy Create custom names for web transactions This part of the API call instructs web transactions containing a storeId value to appear in APM's Transactions page with the custom transaction name you set. A request to any one store will appear under the same, aggregate name. private void saveNewRelicInfo(HttpServletRequest req) { String storeId = req.getParameter(\"storeId\"); if (storeId != null) { // set the name of the Transaction NewRelic.setTransactionName(null, \"/store\"); } } Copy Bypass Apdex when collecting non-public data This part of the API call excludes the non-public beta storeID from affecting the Apdex score. if (storeId.equals(\"betaStore\")) { // prevent the method from contributing to the Apdex score NewRelic.ignoreApdex(); } Copy Record the user ID This part of the API call inserts additional metadata into the page load timing request so that browser traces can be tied with the userId. It also records the userId as a custom parameter on the transaction so that it appears in the parameter details of a transaction trace. (Page load timing sometimes is referred to as real user monitoring or RUM.) String userId = req.getParameter(\"userId\"); if (userId != null) { // set the user name to associate with the RUM JavaScript footer // for the current web transaction NewRelic.setUserName(userId); // add a key/value pair to the current transaction NewRelic.addCustomParameter(\"userId\", userId); } Copy Collect promotion data This part of the API call records the number of times a promotion was viewed so that the metrics can appear on a custom dashboard. Important For metrics you want to graph in custom dashboards, be sure to prepend Custom/ to the metric name; for example, Custom/Promotion. String promotionId = req.getParameter(\"promotionId\"); if (promotionId != null) { // increment the metric counter for the given name NewRelic.incrementCounter(\"Custom/Promotion\"); } Copy Send instructions to the handler This part of the API call sends a set of instructions to the handler for processing requests and handling exceptions. protected void doRequestWork(HttpServletRequest req) { try { long millisToSleep = new Random().nextInt(5000); Thread.sleep(millisToSleep); // record a response time in milliseconds for the given metric name NewRelic.recordResponseTimeMetric(\"Custom/RandomSleep\", millisToSleep); } catch (InterruptedException e) { // report a handled exception NewRelic.noticeError(e, false); } } protected void writeResponse(HttpServletResponse resp) throws IOException { Copy Include page load timing code in the HTTP response This part of the API call defines what to include in the HttpServletResponse. For manual instrumentation of Browser monitoring to monitor page load timing (sometimes referred to as real user monitoring or RUM): Set the header after the < head> tag. Set the footer at the end of < body> tag. resp.setContentType(\"text/html;charset=UTF-8\"); PrintWriter out = resp.getWriter(); out.println(\"<html>\"); out.println(\"<head>\"); // get the RUM JavaScript header for the current web transaction out.println(NewRelic.getBrowserTimingHeader()); out.println(\"<title>NewRelic API example servlet</title>\"); out.println(\"</head>\"); out.println(\"<body>\"); out.println(\"<h1>API example</h1>\"); // get the RUM JavaScript footer for the current web transaction out.println(NewRelic.getBrowserTimingFooter()); out.println(\"</body>\"); out.println(\"</html>\"); out.close(); } Copy Complete the HTTP response This part of the API call defines the remaining information to include in the HttpServletResponse response. protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { processRequest(req, resp); } protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { processRequest(req, resp); } } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 101.84709,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> <em>API</em>: Custom instrumentation with annotation of an example app",
        "sections": "<em>Java</em> <em>agent</em> <em>API</em>: Custom instrumentation with annotation of an example app",
        "tags": "<em>API</em> <em>guides</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> <em>API</em> lets you set up custom instrumentation for your <em>Java</em> application. This document shows an example of using custom instrumentation with annotation in an imaginary application. Important For best results when using the <em>API</em>, ensure you have the latest <em>Java</em> <em>agent</em> release"
      },
      "id": "603eb76a64441f48424e886b"
    }
  ],
  "/docs/agents/java-agent/api-guides/java-agent-api-custom-instrumentation-annotation-example-app": [
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 176.0628,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Guide</em> to using the <em>Java</em> <em>agent</em> <em>API</em> ",
        "sections": "<em>Guide</em> to using the <em>Java</em> <em>agent</em> <em>API</em>",
        "tags": "<em>API</em> <em>guides</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> <em>API</em> lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This <em>API</em> consists of: Static methods on the com.newrelic.<em>api.agent</em>.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of <em>API</em> objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    },
    {
      "sections": [
        "Guide to using the Python agent API",
        "Custom instrumentation or API",
        "Monitor transactions and segments",
        "Add and edit transaction metadata",
        "Report custom events and custom metric data",
        "Message-related calls",
        "Implement distributed tracing",
        "Agent configuration, initialization, shutdown",
        "Control the Browser monitoring agent"
      ],
      "title": "Guide to using the Python agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "Python agent",
        "API guides"
      ],
      "external_id": "41f2cf33977b57e872b8c69a30b77fd603b51926",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/python-agent/api-guides/guide-using-python-agent-api/",
      "published_at": "2021-06-02T13:37:41Z",
      "updated_at": "2021-06-02T13:37:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Python agent API allows you to customize and extend your monitoring. Use the Python agent API to: Manually instrument an unsupported framework or third-party system. Add instrumentation to supplement the agent's default monitoring. This document describes some of the available Python API calls. For a description of all our available APIs, see Introduction to APIs. Custom instrumentation or API If your goal is custom instrumentation, consider using the configuration file method, which allows you to add functions and class methods to the config file that will be auto-instrumented by the agent. The benefit of the config-file method is that it does not require you to change your application code. However, the Python agent API is much more powerful and is best for setting up more complex and tailored instrumentation. To ensure you have access to the full API functionality, update to the latest Python agent. Monitor transactions and segments The Python agent is compatible with most of the common WSGI web frameworks. If the agent supports your framework, web requests automatically will be captured as transactions and displayed in the New Relic One UI. A transaction can also have function-level segments that are captured as part of a transaction trace. Use these methods to monitor web transactions, non-web transactions, and transaction segments: If you want to... Do this... Monitor WSGI web transactions The Python agent automatically captures web transactions for supported frameworks. If you do not have a supported framework, you can use the wsgi_application function to monitor your WSGI entry point. Monitor non-web transactions The Python agent classifies non-web transactions as background tasks. To capture non-web transactions, use background_task. Capture more details about a transaction If your transaction traces do not have the level of detail you want: Use function_trace to capture more function-level detail in transactions. Use datastore_trace to capture more detail about datastore calls. Ignore a transaction Use any of these options: To ignore a transaction altogether, use ignore_transaction. To prevent a transaction from producing a transaction trace, use suppress_transaction_trace. To end a transaction before the agent would end it automatically, use end_of_transaction. Add and edit transaction metadata Sometimes the code you target is visible in our UI, but some details of the method are not useful. For example: The default name is not helpful, or it is causing a metric grouping issue. You want to add custom attributes to your transactions so you can filter them when querying. Use these calls when you want to change the metadata of an existing transaction: If you want to... Do this... Get reference to current transaction To return an object representing the current transaction, use current_transaction. This is required by some other Python agent API calls. Change the name of a transaction Use set_transaction_name. Add metadata (such as a customer's subscription level) to transactions Add custom attributes to your transactions using add_custom_parameter, or use other API calls to report custom data. Mark a transaction as a background job To convert a web transaction into a background task so that it appears as a non-web transaction in the UI, use set_background_task. Prevent a transaction from affecting your Apdex score Use suppress_apdex_metric. Report custom events and custom metric data The agent reports data in two primary forms: Metric data measures numeric, time-based values; for example, connections per minute. Event data captures discrete event information. Events have key-value attributes attached to them. You can analyze and query event data. Use these methods to create new event data and new metric data: If you want to... Do this... Send data about an event for use when querying your data. Use record_custom_event. Report time-based metrics on application performance To report a single metric, use record_custom_metric. To report a set of metrics, use record_custom_metrics. Report an exception as an error By default, the Python agent only reports unhandled exceptions. To report a Python exception as an error, use notice_error. Report query string parameters For security reasons, query string parameters associated with web transactions are disabled by default. Use capture_request_params to enable them. Tag events with metadata To add attributes to events for more detailed analysis in Insights or error analytics, use add_custom_parameter. Generate metrics from data sources and data factories To generate metrics with a pull-style API rather than the push-style API implemented by record_custom_metric(), use these API calls: register_data_source data_source_generator data_source_factory Message-related calls These API calls allow you to collect performance data on your message-passing architecture or service; for example, RabbitMQ. To use these calls, make sure you have Python agent version 2.88.0.72 or higher. If you want to... Do this... Report messages as a transaction Use message_transaction. Report message details as transaction trace segments Use message_trace. Implement distributed tracing These APIs require distributed tracing to be enabled. Services and applications monitored by our agents will automatically pass distributed tracing context to each other when using a supported framework. When not using a supported framework, you will need to use the distributed tracing APIs to manually accept this context. Supported web frameworks (for example, Flask, Django, Tornado) will automatically call accept_distributed_trace_payload when creating a transaction. Supported external web services libraries will automatically call create_distributed_trace_payload before making an external HTTP call. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. If you want to... Do this... Create a payload to be sent to a called service. Use create_distributed_trace_payload. Accept a payload sent from the first service; this will link these services together in a trace Use accept_distributed_trace_payload. Agent configuration, initialization, shutdown These calls help you manage Python agent behavior, such as initializing and integrating the agent, and referencing or changing configuration settings: If you want to... Do this... Initialize the agent To initialize the Python agent with a specific configuration file as part of advanced integration process, use initialize. Get a reference to the application object The application object represents an agent-monitored application and is used by some Python agent API calls. Get a reference to configuration settings To control the Python agent's behavior, you can use configuration settings. To get a reference to config file and environment variable settings and make changes to them, use global_settings. To get a reference to all settings, including server-side configuration from our UI, use application_settings. Shut down the agent To forcibly shut down the agent instead of allowing it to make the standard final attempt to upload data, use shutdown_agent. Control the Browser monitoring agent You can install the browser monitoring agent by automatically adding it to your pages or by deploying it on specific pages by copying and pasting the browser agent JavaScript snippet. You can also control the browser agent by using APM agent API calls. For more information, see Browser agent and the Python agent. If you want to... Do this... Monitor specific page views To inject the browser agent header and footer JavaScript snippets into views you want to monitor, use both get_browser_timing_header and get_browser_timing_footer. Disable monitoring of specific page views To disable browser monitoring for specific page views, use disable_browser_autorum.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.59262,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Guide</em> to using the Python <em>agent</em> <em>API</em>",
        "sections": "<em>Guide</em> to using the Python <em>agent</em> <em>API</em>",
        "tags": "<em>API</em> <em>guides</em>",
        "body": ". Control the Browser monitoring <em>agent</em> You can install the browser monitoring <em>agent</em> by automatically adding it to your pages or by deploying it on specific pages by copying and pasting the browser <em>agent</em> <em>Java</em>Script snippet. You can also control the browser <em>agent</em> by using APM <em>agent</em> <em>API</em> calls. For more"
      },
      "id": "60441c8d64441f0ec7378eff"
    },
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 101.91658,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the instrumentation package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]instrumentation.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate configuration to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    }
  ],
  "/docs/agents/java-agent/api-guides/java-agent-api-instrument-external-calls-messaging-datastore-web-frameworks": [
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 176.0628,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Guide</em> to using the <em>Java</em> <em>agent</em> <em>API</em> ",
        "sections": "<em>Guide</em> to using the <em>Java</em> <em>agent</em> <em>API</em>",
        "tags": "<em>API</em> <em>guides</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> <em>API</em> lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This <em>API</em> consists of: Static methods on the com.newrelic.<em>api.agent</em>.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of <em>API</em> objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    },
    {
      "sections": [
        "Guide to using the Python agent API",
        "Custom instrumentation or API",
        "Monitor transactions and segments",
        "Add and edit transaction metadata",
        "Report custom events and custom metric data",
        "Message-related calls",
        "Implement distributed tracing",
        "Agent configuration, initialization, shutdown",
        "Control the Browser monitoring agent"
      ],
      "title": "Guide to using the Python agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "Python agent",
        "API guides"
      ],
      "external_id": "41f2cf33977b57e872b8c69a30b77fd603b51926",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/python-agent/api-guides/guide-using-python-agent-api/",
      "published_at": "2021-06-02T13:37:41Z",
      "updated_at": "2021-06-02T13:37:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Python agent API allows you to customize and extend your monitoring. Use the Python agent API to: Manually instrument an unsupported framework or third-party system. Add instrumentation to supplement the agent's default monitoring. This document describes some of the available Python API calls. For a description of all our available APIs, see Introduction to APIs. Custom instrumentation or API If your goal is custom instrumentation, consider using the configuration file method, which allows you to add functions and class methods to the config file that will be auto-instrumented by the agent. The benefit of the config-file method is that it does not require you to change your application code. However, the Python agent API is much more powerful and is best for setting up more complex and tailored instrumentation. To ensure you have access to the full API functionality, update to the latest Python agent. Monitor transactions and segments The Python agent is compatible with most of the common WSGI web frameworks. If the agent supports your framework, web requests automatically will be captured as transactions and displayed in the New Relic One UI. A transaction can also have function-level segments that are captured as part of a transaction trace. Use these methods to monitor web transactions, non-web transactions, and transaction segments: If you want to... Do this... Monitor WSGI web transactions The Python agent automatically captures web transactions for supported frameworks. If you do not have a supported framework, you can use the wsgi_application function to monitor your WSGI entry point. Monitor non-web transactions The Python agent classifies non-web transactions as background tasks. To capture non-web transactions, use background_task. Capture more details about a transaction If your transaction traces do not have the level of detail you want: Use function_trace to capture more function-level detail in transactions. Use datastore_trace to capture more detail about datastore calls. Ignore a transaction Use any of these options: To ignore a transaction altogether, use ignore_transaction. To prevent a transaction from producing a transaction trace, use suppress_transaction_trace. To end a transaction before the agent would end it automatically, use end_of_transaction. Add and edit transaction metadata Sometimes the code you target is visible in our UI, but some details of the method are not useful. For example: The default name is not helpful, or it is causing a metric grouping issue. You want to add custom attributes to your transactions so you can filter them when querying. Use these calls when you want to change the metadata of an existing transaction: If you want to... Do this... Get reference to current transaction To return an object representing the current transaction, use current_transaction. This is required by some other Python agent API calls. Change the name of a transaction Use set_transaction_name. Add metadata (such as a customer's subscription level) to transactions Add custom attributes to your transactions using add_custom_parameter, or use other API calls to report custom data. Mark a transaction as a background job To convert a web transaction into a background task so that it appears as a non-web transaction in the UI, use set_background_task. Prevent a transaction from affecting your Apdex score Use suppress_apdex_metric. Report custom events and custom metric data The agent reports data in two primary forms: Metric data measures numeric, time-based values; for example, connections per minute. Event data captures discrete event information. Events have key-value attributes attached to them. You can analyze and query event data. Use these methods to create new event data and new metric data: If you want to... Do this... Send data about an event for use when querying your data. Use record_custom_event. Report time-based metrics on application performance To report a single metric, use record_custom_metric. To report a set of metrics, use record_custom_metrics. Report an exception as an error By default, the Python agent only reports unhandled exceptions. To report a Python exception as an error, use notice_error. Report query string parameters For security reasons, query string parameters associated with web transactions are disabled by default. Use capture_request_params to enable them. Tag events with metadata To add attributes to events for more detailed analysis in Insights or error analytics, use add_custom_parameter. Generate metrics from data sources and data factories To generate metrics with a pull-style API rather than the push-style API implemented by record_custom_metric(), use these API calls: register_data_source data_source_generator data_source_factory Message-related calls These API calls allow you to collect performance data on your message-passing architecture or service; for example, RabbitMQ. To use these calls, make sure you have Python agent version 2.88.0.72 or higher. If you want to... Do this... Report messages as a transaction Use message_transaction. Report message details as transaction trace segments Use message_trace. Implement distributed tracing These APIs require distributed tracing to be enabled. Services and applications monitored by our agents will automatically pass distributed tracing context to each other when using a supported framework. When not using a supported framework, you will need to use the distributed tracing APIs to manually accept this context. Supported web frameworks (for example, Flask, Django, Tornado) will automatically call accept_distributed_trace_payload when creating a transaction. Supported external web services libraries will automatically call create_distributed_trace_payload before making an external HTTP call. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. If you want to... Do this... Create a payload to be sent to a called service. Use create_distributed_trace_payload. Accept a payload sent from the first service; this will link these services together in a trace Use accept_distributed_trace_payload. Agent configuration, initialization, shutdown These calls help you manage Python agent behavior, such as initializing and integrating the agent, and referencing or changing configuration settings: If you want to... Do this... Initialize the agent To initialize the Python agent with a specific configuration file as part of advanced integration process, use initialize. Get a reference to the application object The application object represents an agent-monitored application and is used by some Python agent API calls. Get a reference to configuration settings To control the Python agent's behavior, you can use configuration settings. To get a reference to config file and environment variable settings and make changes to them, use global_settings. To get a reference to all settings, including server-side configuration from our UI, use application_settings. Shut down the agent To forcibly shut down the agent instead of allowing it to make the standard final attempt to upload data, use shutdown_agent. Control the Browser monitoring agent You can install the browser monitoring agent by automatically adding it to your pages or by deploying it on specific pages by copying and pasting the browser agent JavaScript snippet. You can also control the browser agent by using APM agent API calls. For more information, see Browser agent and the Python agent. If you want to... Do this... Monitor specific page views To inject the browser agent header and footer JavaScript snippets into views you want to monitor, use both get_browser_timing_header and get_browser_timing_footer. Disable monitoring of specific page views To disable browser monitoring for specific page views, use disable_browser_autorum.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.59262,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Guide</em> to using the Python <em>agent</em> <em>API</em>",
        "sections": "<em>Guide</em> to using the Python <em>agent</em> <em>API</em>",
        "tags": "<em>API</em> <em>guides</em>",
        "body": ". Control the Browser monitoring <em>agent</em> You can install the browser monitoring <em>agent</em> by automatically adding it to your pages or by deploying it on specific pages by copying and pasting the browser <em>agent</em> <em>Java</em>Script snippet. You can also control the browser <em>agent</em> by using APM <em>agent</em> <em>API</em> calls. For more"
      },
      "id": "60441c8d64441f0ec7378eff"
    },
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 101.91658,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the instrumentation package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]instrumentation.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate configuration to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    }
  ],
  "/docs/agents/java-agent/api-guides/java-agent-api-instrument-using-annotation": [
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 176.0628,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Guide</em> to using the <em>Java</em> <em>agent</em> <em>API</em> ",
        "sections": "<em>Guide</em> to using the <em>Java</em> <em>agent</em> <em>API</em>",
        "tags": "<em>API</em> <em>guides</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> <em>API</em> lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This <em>API</em> consists of: Static methods on the com.newrelic.<em>api.agent</em>.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of <em>API</em> objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    },
    {
      "sections": [
        "Guide to using the Python agent API",
        "Custom instrumentation or API",
        "Monitor transactions and segments",
        "Add and edit transaction metadata",
        "Report custom events and custom metric data",
        "Message-related calls",
        "Implement distributed tracing",
        "Agent configuration, initialization, shutdown",
        "Control the Browser monitoring agent"
      ],
      "title": "Guide to using the Python agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "Python agent",
        "API guides"
      ],
      "external_id": "41f2cf33977b57e872b8c69a30b77fd603b51926",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/python-agent/api-guides/guide-using-python-agent-api/",
      "published_at": "2021-06-02T13:37:41Z",
      "updated_at": "2021-06-02T13:37:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Python agent API allows you to customize and extend your monitoring. Use the Python agent API to: Manually instrument an unsupported framework or third-party system. Add instrumentation to supplement the agent's default monitoring. This document describes some of the available Python API calls. For a description of all our available APIs, see Introduction to APIs. Custom instrumentation or API If your goal is custom instrumentation, consider using the configuration file method, which allows you to add functions and class methods to the config file that will be auto-instrumented by the agent. The benefit of the config-file method is that it does not require you to change your application code. However, the Python agent API is much more powerful and is best for setting up more complex and tailored instrumentation. To ensure you have access to the full API functionality, update to the latest Python agent. Monitor transactions and segments The Python agent is compatible with most of the common WSGI web frameworks. If the agent supports your framework, web requests automatically will be captured as transactions and displayed in the New Relic One UI. A transaction can also have function-level segments that are captured as part of a transaction trace. Use these methods to monitor web transactions, non-web transactions, and transaction segments: If you want to... Do this... Monitor WSGI web transactions The Python agent automatically captures web transactions for supported frameworks. If you do not have a supported framework, you can use the wsgi_application function to monitor your WSGI entry point. Monitor non-web transactions The Python agent classifies non-web transactions as background tasks. To capture non-web transactions, use background_task. Capture more details about a transaction If your transaction traces do not have the level of detail you want: Use function_trace to capture more function-level detail in transactions. Use datastore_trace to capture more detail about datastore calls. Ignore a transaction Use any of these options: To ignore a transaction altogether, use ignore_transaction. To prevent a transaction from producing a transaction trace, use suppress_transaction_trace. To end a transaction before the agent would end it automatically, use end_of_transaction. Add and edit transaction metadata Sometimes the code you target is visible in our UI, but some details of the method are not useful. For example: The default name is not helpful, or it is causing a metric grouping issue. You want to add custom attributes to your transactions so you can filter them when querying. Use these calls when you want to change the metadata of an existing transaction: If you want to... Do this... Get reference to current transaction To return an object representing the current transaction, use current_transaction. This is required by some other Python agent API calls. Change the name of a transaction Use set_transaction_name. Add metadata (such as a customer's subscription level) to transactions Add custom attributes to your transactions using add_custom_parameter, or use other API calls to report custom data. Mark a transaction as a background job To convert a web transaction into a background task so that it appears as a non-web transaction in the UI, use set_background_task. Prevent a transaction from affecting your Apdex score Use suppress_apdex_metric. Report custom events and custom metric data The agent reports data in two primary forms: Metric data measures numeric, time-based values; for example, connections per minute. Event data captures discrete event information. Events have key-value attributes attached to them. You can analyze and query event data. Use these methods to create new event data and new metric data: If you want to... Do this... Send data about an event for use when querying your data. Use record_custom_event. Report time-based metrics on application performance To report a single metric, use record_custom_metric. To report a set of metrics, use record_custom_metrics. Report an exception as an error By default, the Python agent only reports unhandled exceptions. To report a Python exception as an error, use notice_error. Report query string parameters For security reasons, query string parameters associated with web transactions are disabled by default. Use capture_request_params to enable them. Tag events with metadata To add attributes to events for more detailed analysis in Insights or error analytics, use add_custom_parameter. Generate metrics from data sources and data factories To generate metrics with a pull-style API rather than the push-style API implemented by record_custom_metric(), use these API calls: register_data_source data_source_generator data_source_factory Message-related calls These API calls allow you to collect performance data on your message-passing architecture or service; for example, RabbitMQ. To use these calls, make sure you have Python agent version 2.88.0.72 or higher. If you want to... Do this... Report messages as a transaction Use message_transaction. Report message details as transaction trace segments Use message_trace. Implement distributed tracing These APIs require distributed tracing to be enabled. Services and applications monitored by our agents will automatically pass distributed tracing context to each other when using a supported framework. When not using a supported framework, you will need to use the distributed tracing APIs to manually accept this context. Supported web frameworks (for example, Flask, Django, Tornado) will automatically call accept_distributed_trace_payload when creating a transaction. Supported external web services libraries will automatically call create_distributed_trace_payload before making an external HTTP call. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. If you want to... Do this... Create a payload to be sent to a called service. Use create_distributed_trace_payload. Accept a payload sent from the first service; this will link these services together in a trace Use accept_distributed_trace_payload. Agent configuration, initialization, shutdown These calls help you manage Python agent behavior, such as initializing and integrating the agent, and referencing or changing configuration settings: If you want to... Do this... Initialize the agent To initialize the Python agent with a specific configuration file as part of advanced integration process, use initialize. Get a reference to the application object The application object represents an agent-monitored application and is used by some Python agent API calls. Get a reference to configuration settings To control the Python agent's behavior, you can use configuration settings. To get a reference to config file and environment variable settings and make changes to them, use global_settings. To get a reference to all settings, including server-side configuration from our UI, use application_settings. Shut down the agent To forcibly shut down the agent instead of allowing it to make the standard final attempt to upload data, use shutdown_agent. Control the Browser monitoring agent You can install the browser monitoring agent by automatically adding it to your pages or by deploying it on specific pages by copying and pasting the browser agent JavaScript snippet. You can also control the browser agent by using APM agent API calls. For more information, see Browser agent and the Python agent. If you want to... Do this... Monitor specific page views To inject the browser agent header and footer JavaScript snippets into views you want to monitor, use both get_browser_timing_header and get_browser_timing_footer. Disable monitoring of specific page views To disable browser monitoring for specific page views, use disable_browser_autorum.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.59262,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Guide</em> to using the Python <em>agent</em> <em>API</em>",
        "sections": "<em>Guide</em> to using the Python <em>agent</em> <em>API</em>",
        "tags": "<em>API</em> <em>guides</em>",
        "body": ". Control the Browser monitoring <em>agent</em> You can install the browser monitoring <em>agent</em> by automatically adding it to your pages or by deploying it on specific pages by copying and pasting the browser <em>agent</em> <em>Java</em>Script snippet. You can also control the browser <em>agent</em> by using APM <em>agent</em> <em>API</em> calls. For more"
      },
      "id": "60441c8d64441f0ec7378eff"
    },
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 101.91658,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the instrumentation package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]instrumentation.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate configuration to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    }
  ],
  "/docs/agents/java-agent/api-guides/java-agent-api-instrumenting-example-app-external-datastore-calls-cat": [
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 176.06271,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Guide</em> to using the <em>Java</em> <em>agent</em> <em>API</em> ",
        "sections": "<em>Guide</em> to using the <em>Java</em> <em>agent</em> <em>API</em>",
        "tags": "<em>API</em> <em>guides</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> <em>API</em> lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This <em>API</em> consists of: Static methods on the com.newrelic.<em>api.agent</em>.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of <em>API</em> objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    },
    {
      "sections": [
        "Guide to using the Python agent API",
        "Custom instrumentation or API",
        "Monitor transactions and segments",
        "Add and edit transaction metadata",
        "Report custom events and custom metric data",
        "Message-related calls",
        "Implement distributed tracing",
        "Agent configuration, initialization, shutdown",
        "Control the Browser monitoring agent"
      ],
      "title": "Guide to using the Python agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "Python agent",
        "API guides"
      ],
      "external_id": "41f2cf33977b57e872b8c69a30b77fd603b51926",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/python-agent/api-guides/guide-using-python-agent-api/",
      "published_at": "2021-06-02T13:37:41Z",
      "updated_at": "2021-06-02T13:37:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Python agent API allows you to customize and extend your monitoring. Use the Python agent API to: Manually instrument an unsupported framework or third-party system. Add instrumentation to supplement the agent's default monitoring. This document describes some of the available Python API calls. For a description of all our available APIs, see Introduction to APIs. Custom instrumentation or API If your goal is custom instrumentation, consider using the configuration file method, which allows you to add functions and class methods to the config file that will be auto-instrumented by the agent. The benefit of the config-file method is that it does not require you to change your application code. However, the Python agent API is much more powerful and is best for setting up more complex and tailored instrumentation. To ensure you have access to the full API functionality, update to the latest Python agent. Monitor transactions and segments The Python agent is compatible with most of the common WSGI web frameworks. If the agent supports your framework, web requests automatically will be captured as transactions and displayed in the New Relic One UI. A transaction can also have function-level segments that are captured as part of a transaction trace. Use these methods to monitor web transactions, non-web transactions, and transaction segments: If you want to... Do this... Monitor WSGI web transactions The Python agent automatically captures web transactions for supported frameworks. If you do not have a supported framework, you can use the wsgi_application function to monitor your WSGI entry point. Monitor non-web transactions The Python agent classifies non-web transactions as background tasks. To capture non-web transactions, use background_task. Capture more details about a transaction If your transaction traces do not have the level of detail you want: Use function_trace to capture more function-level detail in transactions. Use datastore_trace to capture more detail about datastore calls. Ignore a transaction Use any of these options: To ignore a transaction altogether, use ignore_transaction. To prevent a transaction from producing a transaction trace, use suppress_transaction_trace. To end a transaction before the agent would end it automatically, use end_of_transaction. Add and edit transaction metadata Sometimes the code you target is visible in our UI, but some details of the method are not useful. For example: The default name is not helpful, or it is causing a metric grouping issue. You want to add custom attributes to your transactions so you can filter them when querying. Use these calls when you want to change the metadata of an existing transaction: If you want to... Do this... Get reference to current transaction To return an object representing the current transaction, use current_transaction. This is required by some other Python agent API calls. Change the name of a transaction Use set_transaction_name. Add metadata (such as a customer's subscription level) to transactions Add custom attributes to your transactions using add_custom_parameter, or use other API calls to report custom data. Mark a transaction as a background job To convert a web transaction into a background task so that it appears as a non-web transaction in the UI, use set_background_task. Prevent a transaction from affecting your Apdex score Use suppress_apdex_metric. Report custom events and custom metric data The agent reports data in two primary forms: Metric data measures numeric, time-based values; for example, connections per minute. Event data captures discrete event information. Events have key-value attributes attached to them. You can analyze and query event data. Use these methods to create new event data and new metric data: If you want to... Do this... Send data about an event for use when querying your data. Use record_custom_event. Report time-based metrics on application performance To report a single metric, use record_custom_metric. To report a set of metrics, use record_custom_metrics. Report an exception as an error By default, the Python agent only reports unhandled exceptions. To report a Python exception as an error, use notice_error. Report query string parameters For security reasons, query string parameters associated with web transactions are disabled by default. Use capture_request_params to enable them. Tag events with metadata To add attributes to events for more detailed analysis in Insights or error analytics, use add_custom_parameter. Generate metrics from data sources and data factories To generate metrics with a pull-style API rather than the push-style API implemented by record_custom_metric(), use these API calls: register_data_source data_source_generator data_source_factory Message-related calls These API calls allow you to collect performance data on your message-passing architecture or service; for example, RabbitMQ. To use these calls, make sure you have Python agent version 2.88.0.72 or higher. If you want to... Do this... Report messages as a transaction Use message_transaction. Report message details as transaction trace segments Use message_trace. Implement distributed tracing These APIs require distributed tracing to be enabled. Services and applications monitored by our agents will automatically pass distributed tracing context to each other when using a supported framework. When not using a supported framework, you will need to use the distributed tracing APIs to manually accept this context. Supported web frameworks (for example, Flask, Django, Tornado) will automatically call accept_distributed_trace_payload when creating a transaction. Supported external web services libraries will automatically call create_distributed_trace_payload before making an external HTTP call. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. If you want to... Do this... Create a payload to be sent to a called service. Use create_distributed_trace_payload. Accept a payload sent from the first service; this will link these services together in a trace Use accept_distributed_trace_payload. Agent configuration, initialization, shutdown These calls help you manage Python agent behavior, such as initializing and integrating the agent, and referencing or changing configuration settings: If you want to... Do this... Initialize the agent To initialize the Python agent with a specific configuration file as part of advanced integration process, use initialize. Get a reference to the application object The application object represents an agent-monitored application and is used by some Python agent API calls. Get a reference to configuration settings To control the Python agent's behavior, you can use configuration settings. To get a reference to config file and environment variable settings and make changes to them, use global_settings. To get a reference to all settings, including server-side configuration from our UI, use application_settings. Shut down the agent To forcibly shut down the agent instead of allowing it to make the standard final attempt to upload data, use shutdown_agent. Control the Browser monitoring agent You can install the browser monitoring agent by automatically adding it to your pages or by deploying it on specific pages by copying and pasting the browser agent JavaScript snippet. You can also control the browser agent by using APM agent API calls. For more information, see Browser agent and the Python agent. If you want to... Do this... Monitor specific page views To inject the browser agent header and footer JavaScript snippets into views you want to monitor, use both get_browser_timing_header and get_browser_timing_footer. Disable monitoring of specific page views To disable browser monitoring for specific page views, use disable_browser_autorum.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.592575,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Guide</em> to using the Python <em>agent</em> <em>API</em>",
        "sections": "<em>Guide</em> to using the Python <em>agent</em> <em>API</em>",
        "tags": "<em>API</em> <em>guides</em>",
        "body": ". Control the Browser monitoring <em>agent</em> You can install the browser monitoring <em>agent</em> by automatically adding it to your pages or by deploying it on specific pages by copying and pasting the browser <em>agent</em> <em>Java</em>Script snippet. You can also control the browser <em>agent</em> by using APM <em>agent</em> <em>API</em> calls. For more"
      },
      "id": "60441c8d64441f0ec7378eff"
    },
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 101.91653,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the instrumentation package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]instrumentation.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate configuration to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    }
  ],
  "/docs/agents/java-agent/async-instrumentation/disable-scala-netty-akka-play-2-instrumentation": [
    {
      "sections": [
        "Troubleshoot Java asynchronous instrumentation",
        "Verify your instrumentation",
        "Use logs to troubleshoot",
        "Problem: Transaction times are too long",
        "Problem: No transaction trace data",
        "Problem: Too few async calls",
        "Ensure that each activity you monitor is appropriately linked",
        "Check if you are missing required annotations"
      ],
      "title": "Troubleshoot Java asynchronous instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Async instrumentation"
      ],
      "external_id": "0f21da73ba02edc45ec0cbbbaa7e0fc45678404b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/async-instrumentation/troubleshoot-java-asynchronous-instrumentation/",
      "published_at": "2021-06-02T18:16:53Z",
      "updated_at": "2021-03-16T09:03:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you are having problems using the Java agent API for async tokens and segments, use these techniques to help you find answers and solve problems. Verify your instrumentation The API has a number of built-in safety mechanisms to prevent issues caused by incorrect API usage, but you can use these techniques to verify that your application’s instrumentation is correct: After instrumenting your code, verify that the logs show that an equal number of tokens have been created and expired. For more information on which log messages to look for, see Use logs to troubleshoot. Check the garbage collection statistics under APM's JVMs page to determine whether or not your changes have significantly altered garbage collection patterns. Check if any segments or tokens are timing out by reviewing your transaction traces for a timed_out attribute. If so, you can change the limit with token_timeout and segment_timeout. Use logs to troubleshoot To customize your Java agent logging, see Generating logs. Then, you can examine your logs for these common messages: To view created tokens, check logs at FINEST for: Transaction com.newrelic.agent.Transaction@5a7cc8e: created active token com.newrelic.agent.TokenImpl@7db8d0e8 Copy To view expired tokens and the time that they expired, check logs at FINEST for: Transaction com.newrelic.agent.Transaction@5a7cc8e: expired token com.newrelic.agent.TokenImpl@7db8d0e8 Copy To view created segments, check logs at FINEST for: Transaction com.newrelic.agent.Transaction@486b7f04: startSegment(): com.newrelic.agent.Segment@2b7fdad3 created and started with tracer com.newrelic.agent.tracers.OtherRootTracer@4df4a953 Copy To view ended segments and the time that they ended, check logs at FINEST for: com.newrelic.agent.Transaction@486b7f04--finish segment(): com.newrelic.agent.Segment@2b7fdad3 async finish with tracer com.newrelic.agent.tracers.OtherRootTracer@4df4a953 Copy Problem: Transaction times are too long Make sure to expire tokens and end or ignore segments; otherwise transactions may take longer to report to New Relic. The Java agent has a timeout mechanism for tokens and segments that are not ended correctly. For more information, see token_timeout and segment_timeout. Problem: No transaction trace data Inspect transaction traces to make sure expected asynchronous work is reported. If you do not see any transaction traces, make sure your transaction duration exceeds the transaction trace threshold set in transaction_threshold. Problem: Too few async calls If too few calls are being reported: Ensure that each activity you monitor is appropriately linked In the faulty example below, a parallel stream is being used, which means that the work done inside the lambda in the call to map() can be scheduled on a different thread than the thread handling the request. Without creating a token to link all this work together, you will not see any of the work that gets scheduled on a different thread inside of your transaction. @RequestMapping(\"parallel_stream_bad\") @Trace(dispatcher = true) public ResponseEntity parallelStreamBad(@RequestParam(\"ids\") List<long> ids) { List<item> results = ids .parallelStream() .map(i -> requestItem(i)) .filter(item -> item != null) .collect(Collectors.toList()); return formattedResponse(\"parallel_stream_bad\", results); } Copy Check if you are missing required annotations The example below will report only a subset of the calls to requestItem() because it is impossible to put @Trace(async = true) around blocks of anonymous work inside the call to map(). Instead, you should pass the token into requestItem() and link it, and then add @Trace(async=true) around it. Or use a helper function like requestItemAsync() to do this without changing your existing methods. @RequestMapping(\"parallel_stream_bad2\") @Trace(dispatcher = true) public ResponseEntity parallelStreamBad2(@RequestParam(\"ids\") List<long> ids) { final Token token = NewRelic.getAgent().getTransaction().getToken(); List<item> results = ids .parallelStream() .map(id -> { token.link(); return requestItem(id); }) .filter(item -> item != null) .collect(Collectors.toList()); return formattedResponse(\"parallel_stream_bad2\", results); } Copy Compare this to the correct example below, in which the lambda expression is wrapped by the wrapper class InstrumentedCallable. This class accepts a token and a lambda, then wraps asynchronous work in @Trace(async = true) and uses a token to link the work to the request thread. @RequestMapping(\"parallel_stream_wrap\") @Trace(dispatcher = true) public ResponseEntity parallelStreamWrap(@RequestParam(\"ids\") List<long> ids) { final Token token = NewRelic.getAgent().getTransaction().getToken(); List<item> results = ids .parallelStream() .map(id -> InstrumentedCallable.instrumentCallable(token, () -> requestItem(id))) .map(c -> c.call()) .filter(item -> item != null) .collect(Collectors.toList()); token.expire(); return formattedResponse(\"parallel_stream_wrap\", results); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.5366,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshoot <em>Java</em> <em>asynchronous</em> <em>instrumentation</em>",
        "sections": "Troubleshoot <em>Java</em> <em>asynchronous</em> <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "If you are having problems using the <em>Java</em> <em>agent</em> API for <em>async</em> tokens and segments, use these techniques to help you find answers and solve problems. Verify your <em>instrumentation</em> The API has a number of built-in safety mechanisms to prevent issues caused by incorrect API usage, but you can use"
      },
      "id": "603eb55a196a67260aa83dac"
    },
    {
      "sections": [
        "Java agent API for asynchronous applications",
        "Async tracking tools: Tokens and segments",
        "Tokens: Connect async threads",
        "1. Start a transaction, then create and expire a token",
        "2. Mark a transaction as async and link to request thread",
        "3. View your async trace in the New Relic UI",
        "Tip",
        "Segments: Time arbitrary async activity",
        "1. Create a transaction and call an external service",
        "2. Start a segment, report externals, and end the segment"
      ],
      "title": "Java agent API for asynchronous applications",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Async instrumentation"
      ],
      "external_id": "7b5f035809040487d96279fb318203b479a61b02",
      "image": "https://docs.newrelic.com/static/06c87505ee5c0d97e598d04258587f52/c1b63/Screen-Shot-2017-03-14-at-4.50.31-PM.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/async-instrumentation/java-agent-api-asynchronous-applications/",
      "published_at": "2021-06-02T18:16:52Z",
      "updated_at": "2021-03-16T09:00:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic for Java (agent version 3.37 or higher) includes an API to instrument asynchronous activity. For supported frameworks, the agent usually instruments async work automatically. However, the async API can still be useful to add detail. This document provides examples of using tokens and segments to instrument your app. For more information about how New Relic instruments and displays async work in the APM UI, see Monitoring considerations for asynchronous applications. For details on the actual classes and methods, see the Javadoc. For general information on the Java agent API, see the Java agent API guide. For troubleshooting common problems, see Troubleshooting Java asynchronous applications. Async tracking tools: Tokens and segments The Java agent API provides two ways to trace asynchronous activity: Tokens: Tokens are passed between threads to link asynchronous units of work to a specific transaction. They do not perform any timing directly. Segments: Segments are used to measure an arbitrary piece of asynchronous application code, not necessarily associated with a method or thread. Segments are typically used to track external calls that are completed by a callback mechanism. Tokens: Connect async threads Use tokens to link arbitrary units of work that are on separate threads. This section describes how to use the token-related calls together to instrument async work. For detailed information on classes and methods, see the Javadoc. To use tokens, you first need to create the token, then link another call to the originating transaction. You should link the token as soon as possible within the other call. If you do not link the token immediately, you risk losing any methods that contain an @Trace below the call you are trying to link. You can also expire the token in the original call. The Java agent will then link the work in the New Relic UI. These examples illustrate how to use the token-related calls together: 1. Start a transaction, then create and expire a token Consider the method parallelStream() in the code snippet below. Because some of the calls to requestItemAsync() will occur on a separate thread, a token is created and passed to link that asynchronous work back to the requesting thread. /** * Example showing multi-threaded implementation of requesting data using a parallel {@link Stream}. */ @RequestMapping(\"parallel_stream\") @Trace(dispatcher = true) // starts a transaction public ResponseEntity<String> parallelStream(@RequestParam(\"ids\") List<Long> ids) { final Token token = NewRelic.getAgent().getTransaction(). getToken() ; List<item> results = ids .parallelStream() .map(id -> requestItemAsync\\(id, token)) // note we're calling a different method than parallelStreamBad .filter(item -> item != null) .collect(Collectors.toList()); token.expire() ; return formattedResponse(\"parallel_stream\", results); } Copy The agent API calls in this sample are: @Trace(dispatcher = true): Tells the agent to start a transaction. For more on this method, see the Javadoc. getToken(): Creates the token which will link the work together. For more on this method, see the Javadoc. token.expire(): Expires the token. This allows the transaction to end. For more on this method, see the Javadoc. 2. Mark a transaction as async and link to request thread The following code example shows requestItemAsync, which might execute on a separate thread from the requesting thread. For this reason, the token that was created in the previous code example is linked to the Transaction in requestItemAsync. Note that requestItemAsync() has the @Trace(async=true) annotation, which tells the agent to trace this method if it's linked to an existing transaction. After parallelStream() collects all results, the token is expired. This is important because it makes sure the transaction doesn't stay open after parallelStream() completes. @Trace(async = true) private Item requestItemAsync(long id, Token token) { token.link() ; return requestItem(id); } Copy The agent API calls in this sample are: @Trace(async = true): Starts a transaction. For more on this method, see the Javadoc. token.link(): Links the work being done in requestItemAsync() (which is executing on a different thread) to the requesting thread. For more on this method, see the Javadoc. 3. View your async trace in the New Relic UI Here's an example of a transaction trace in the APM UI for this endpoint: one.newrelic.com > APM > (select an app) > Transactions > Transaction trace > Trace details: All asynchronous method calls linked with a token are indicated with an Async icon. All asynchronous method calls linked with a token are indicated with an Async icon in the Drilldown column. It's not necessary to link methods that are on the same thread, but doing so will have no negative effect. It's often the case that a single token can be shared, like in the parallelStream() example. Tip By default, a transaction can create a maximum of 3000 tokens and each token has a default timeout of 180s. You can change the former limit with the token_limit config option and the latter with the token_timeout config option. Traces for transactions that exceed the token_limit will contain a token_clamp attribute. Increasing either config option may increase agent memory usage. Segments: Time arbitrary async activity Segments are used to measure an arbitrary piece of asynchronous application code, not necessarily associated with a method or thread. This is most commonly used to time connections to external services. Use segments if you want to: Time code that completes via a callback Time an asynchronous call that spans many methods Measure the time between when work is created and when it executed (for example, in a thread pool) 1. Create a transaction and call an external service The method below makes a call to an external service (in this case a database) using the method storeItem(): /** * Example showing single threaded implementation of inserting data into a datasource. */ @RequestMapping(\"insert\") @Trace(dispatcher = true) //starts a transaction public ResponseEntity insert(@RequestParam(\"id\") Long id) { if (id != null) { storeItem(id); return new ResponseEntity<>(\"insert\", HttpStatus.OK); } else { return new ResponseEntity<>(\"insert\", HttpStatus.BAD_REQUEST); } } Copy The goal in this case it to find out how long the Callable in the Lambda statement is waiting in the thread pool before executing, rather than determining how long storeItem() runs. For this reason, a segment is used instead of a token, and @Trace(async = true) is not necessary like it was for a token. The agent API call in this sample is: @Trace(dispatcher = true): Starts a transaction. For more on this method, see the Javadoc. 2. Start a segment, report externals, and end the segment The following code example shows a segment starting in the storeItem method to measure how long the Lambda statement is waiting in the thread pool. To stop timing the segment, you must call either .end() or .ignore(). If you don't want to report the segment as part of its parent transaction, call .ignore(). Otherwise, to report the segment as part of its parent transaction, call .end(). private void storeItem(long id) { Segment segment = NewRelic.getAgent().getTransaction(). startSegment(\"storeItem\") ; segment. reportAsExternal (DatastoreParameters .product(\"H2\") .collection(null) .operation(\"insert\") .instance(\"localhost\", 8080) .databaseName(\"test\") .build()); // fire and forget DB_POOL.submit(() -> { segment.end(); insertData(id); }); } Copy The agent API calls in this sample are: startSegment(...): Begins the segment that will time the code. For more on this method, see the Javadoc. reportAsExternal(DatastoreParameters()): Associates the time with a datastore external call This will show up in APM with datastore data. For more information, see reportAsExternal API. segment.end(): Stops timing this segment. For more on this method, see the Javadoc. 3. View your async trace in the New Relic UI When the method completes, APM displays a transaction trace with one external call: one.newrelic.com > APM > (select an app) > Transactions > Transaction trace > Trace details: A single asynchronous segment is called out in the Drilldown column. Tip By default, the agent can track a maximum of 1000 segments during a given transaction. You can change this limit with the segment_timeout config option. Traces of transactions that exceed this limit will contain a segment_clamp attribute. Increasing this limit may increase agent memory usage.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.53629,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> API for <em>asynchronous</em> applications",
        "sections": "<em>Java</em> <em>agent</em> API for <em>asynchronous</em> applications",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "New Relic for <em>Java</em> (<em>agent</em> version 3.37 or higher) includes an API to <em>instrument</em> asynchronous activity. For supported frameworks, the <em>agent</em> usually instruments <em>async</em> work automatically. However, the <em>async</em> API can still be useful to add detail. This document provides examples of using tokens"
      },
      "id": "603eb4c9196a67dde5a83db7"
    },
    {
      "sections": [
        "Introduction to Java async instrumentation",
        "Asynchronous operations",
        "Async and thread-switching",
        "Async and response time",
        "Custom instrumentation with the async API"
      ],
      "title": "Introduction to Java async instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Async instrumentation"
      ],
      "external_id": "3b0a9e1f2f6b69a8ad101ec59c592ac4a574ae63",
      "image": "https://docs.newrelic.com/static/a38112969f7c8a3001651b65853a803b/39c09/sZ6-I4x5BDSDspRS_G7Hefg.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/async-instrumentation/introduction-java-async-instrumentation/",
      "published_at": "2021-06-02T18:16:06Z",
      "updated_at": "2021-03-16T09:00:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic for Java includes a set of API methods for custom instrumentation of asynchronous activity. This is most useful to instrument asynchronous activity in unsupported frameworks, but you can also use the API to add additional instrumentation to supported frameworks. This document explains how asynchronous activity occurs, and how New Relic monitors async work. Asynchronous operations With a synchronous programming model, programming tasks are usually executed in a specific order. One task must complete before the next task begins, and each task blocks the next task from completing. Asynchronous programming uses a non-blocking model, so that tasks can be run in parallel. Tasks executed asynchronously are completely independent of each other in their execution and initialization. Because asynchronous code doesn't execute in a specific order, the server's full processing power can be used more efficiently, and the app's throughput increases. Async and thread-switching For applications that use asynchronous processing, thread-switching is when a program or task switches from one thread to another. Understanding these asynchronous interleavings can help you decide which methods should be instrumented. Here is an example method with a controller that makes external requests in parallel. These requests execute asynchronously, so each request executes independently of each other and getScoreAsync() returns immediately after being called. This allows the requesting thread to continue making requests while getScoreAsync() makes an external call and sends a reply. @ResponseBody @RequestMapping(\"getScores\", method = RequestMethod.Get produces = “text/plain”) public String getCreditScores(@RequestParam(name = \"uids\") uids) { return Arrays.stream(uids.split(\",\")) .parallel() .map(Integer::valueOf) .map(uid -> getScoreAsync(uid)) .collect(Collectors.toList());} Copy Some of these requests will finish before others. Some might even finish after the requesting thread has moved on to other tasks: With New Relic's asynchronous instrumentation, the APM UI flags the work as Async. For example, if the above method were instrumented by New Relic (either automatically or via custom instrumentation), this is what the APM UI would show on the Trace details page: one.newrelic.com > APM > (select an app) > Transactions > Transaction trace > Trace details: When asynchronous activity in a Java application is detected by APM, it is indicated with the Async flag in the Drilldown column. Async and response time Response time is defined as the duration of a transaction from the perspective of the requester. For asynchronous applications, the response time is often less than the total transaction time. This is because the methods don't have to wait for all preceding methods to complete before returning. Because tasks can be deferred, the application can take advantage of its limited resources and process things more quickly. The chart's response time line gives you more insight into the perceived behavior and speed of your application than does the total web transaction time: one.newrelic.com > APM > (select an app) > Summary: On the APM Summary page, asynchronous activity in a Java app can result in the response time (the blue line) being less than the total transaction time. This is because the methods don't have to wait for all preceding methods to complete before returning. Custom instrumentation with the async API To implement custom instrumentation of async work, see the Java agent async API guide. For general information on how to use the Java agent API, see Java agent API guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.53629,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Java</em> <em>async</em> <em>instrumentation</em>",
        "sections": "Introduction to <em>Java</em> <em>async</em> <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " transaction time. This is because the methods don&#x27;t have to wait for all preceding methods to complete before returning. Custom <em>instrumentation</em> with the <em>async</em> API To implement custom <em>instrumentation</em> of <em>async</em> work, see the <em>Java</em> <em>agent</em> <em>async</em> API guide. For general information on how to use the <em>Java</em> <em>agent</em> API, see <em>Java</em> <em>agent</em> API guide."
      },
      "id": "603eb491e7b9d282bd2a07ca"
    }
  ],
  "/docs/agents/java-agent/async-instrumentation/introduction-java-async-instrumentation": [
    {
      "sections": [
        "Troubleshoot Java asynchronous instrumentation",
        "Verify your instrumentation",
        "Use logs to troubleshoot",
        "Problem: Transaction times are too long",
        "Problem: No transaction trace data",
        "Problem: Too few async calls",
        "Ensure that each activity you monitor is appropriately linked",
        "Check if you are missing required annotations"
      ],
      "title": "Troubleshoot Java asynchronous instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Async instrumentation"
      ],
      "external_id": "0f21da73ba02edc45ec0cbbbaa7e0fc45678404b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/async-instrumentation/troubleshoot-java-asynchronous-instrumentation/",
      "published_at": "2021-06-02T18:16:53Z",
      "updated_at": "2021-03-16T09:03:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you are having problems using the Java agent API for async tokens and segments, use these techniques to help you find answers and solve problems. Verify your instrumentation The API has a number of built-in safety mechanisms to prevent issues caused by incorrect API usage, but you can use these techniques to verify that your application’s instrumentation is correct: After instrumenting your code, verify that the logs show that an equal number of tokens have been created and expired. For more information on which log messages to look for, see Use logs to troubleshoot. Check the garbage collection statistics under APM's JVMs page to determine whether or not your changes have significantly altered garbage collection patterns. Check if any segments or tokens are timing out by reviewing your transaction traces for a timed_out attribute. If so, you can change the limit with token_timeout and segment_timeout. Use logs to troubleshoot To customize your Java agent logging, see Generating logs. Then, you can examine your logs for these common messages: To view created tokens, check logs at FINEST for: Transaction com.newrelic.agent.Transaction@5a7cc8e: created active token com.newrelic.agent.TokenImpl@7db8d0e8 Copy To view expired tokens and the time that they expired, check logs at FINEST for: Transaction com.newrelic.agent.Transaction@5a7cc8e: expired token com.newrelic.agent.TokenImpl@7db8d0e8 Copy To view created segments, check logs at FINEST for: Transaction com.newrelic.agent.Transaction@486b7f04: startSegment(): com.newrelic.agent.Segment@2b7fdad3 created and started with tracer com.newrelic.agent.tracers.OtherRootTracer@4df4a953 Copy To view ended segments and the time that they ended, check logs at FINEST for: com.newrelic.agent.Transaction@486b7f04--finish segment(): com.newrelic.agent.Segment@2b7fdad3 async finish with tracer com.newrelic.agent.tracers.OtherRootTracer@4df4a953 Copy Problem: Transaction times are too long Make sure to expire tokens and end or ignore segments; otherwise transactions may take longer to report to New Relic. The Java agent has a timeout mechanism for tokens and segments that are not ended correctly. For more information, see token_timeout and segment_timeout. Problem: No transaction trace data Inspect transaction traces to make sure expected asynchronous work is reported. If you do not see any transaction traces, make sure your transaction duration exceeds the transaction trace threshold set in transaction_threshold. Problem: Too few async calls If too few calls are being reported: Ensure that each activity you monitor is appropriately linked In the faulty example below, a parallel stream is being used, which means that the work done inside the lambda in the call to map() can be scheduled on a different thread than the thread handling the request. Without creating a token to link all this work together, you will not see any of the work that gets scheduled on a different thread inside of your transaction. @RequestMapping(\"parallel_stream_bad\") @Trace(dispatcher = true) public ResponseEntity parallelStreamBad(@RequestParam(\"ids\") List<long> ids) { List<item> results = ids .parallelStream() .map(i -> requestItem(i)) .filter(item -> item != null) .collect(Collectors.toList()); return formattedResponse(\"parallel_stream_bad\", results); } Copy Check if you are missing required annotations The example below will report only a subset of the calls to requestItem() because it is impossible to put @Trace(async = true) around blocks of anonymous work inside the call to map(). Instead, you should pass the token into requestItem() and link it, and then add @Trace(async=true) around it. Or use a helper function like requestItemAsync() to do this without changing your existing methods. @RequestMapping(\"parallel_stream_bad2\") @Trace(dispatcher = true) public ResponseEntity parallelStreamBad2(@RequestParam(\"ids\") List<long> ids) { final Token token = NewRelic.getAgent().getTransaction().getToken(); List<item> results = ids .parallelStream() .map(id -> { token.link(); return requestItem(id); }) .filter(item -> item != null) .collect(Collectors.toList()); return formattedResponse(\"parallel_stream_bad2\", results); } Copy Compare this to the correct example below, in which the lambda expression is wrapped by the wrapper class InstrumentedCallable. This class accepts a token and a lambda, then wraps asynchronous work in @Trace(async = true) and uses a token to link the work to the request thread. @RequestMapping(\"parallel_stream_wrap\") @Trace(dispatcher = true) public ResponseEntity parallelStreamWrap(@RequestParam(\"ids\") List<long> ids) { final Token token = NewRelic.getAgent().getTransaction().getToken(); List<item> results = ids .parallelStream() .map(id -> InstrumentedCallable.instrumentCallable(token, () -> requestItem(id))) .map(c -> c.call()) .filter(item -> item != null) .collect(Collectors.toList()); token.expire(); return formattedResponse(\"parallel_stream_wrap\", results); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.5366,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshoot <em>Java</em> <em>asynchronous</em> <em>instrumentation</em>",
        "sections": "Troubleshoot <em>Java</em> <em>asynchronous</em> <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "If you are having problems using the <em>Java</em> <em>agent</em> API for <em>async</em> tokens and segments, use these techniques to help you find answers and solve problems. Verify your <em>instrumentation</em> The API has a number of built-in safety mechanisms to prevent issues caused by incorrect API usage, but you can use"
      },
      "id": "603eb55a196a67260aa83dac"
    },
    {
      "sections": [
        "Java agent API for asynchronous applications",
        "Async tracking tools: Tokens and segments",
        "Tokens: Connect async threads",
        "1. Start a transaction, then create and expire a token",
        "2. Mark a transaction as async and link to request thread",
        "3. View your async trace in the New Relic UI",
        "Tip",
        "Segments: Time arbitrary async activity",
        "1. Create a transaction and call an external service",
        "2. Start a segment, report externals, and end the segment"
      ],
      "title": "Java agent API for asynchronous applications",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Async instrumentation"
      ],
      "external_id": "7b5f035809040487d96279fb318203b479a61b02",
      "image": "https://docs.newrelic.com/static/06c87505ee5c0d97e598d04258587f52/c1b63/Screen-Shot-2017-03-14-at-4.50.31-PM.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/async-instrumentation/java-agent-api-asynchronous-applications/",
      "published_at": "2021-06-02T18:16:52Z",
      "updated_at": "2021-03-16T09:00:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic for Java (agent version 3.37 or higher) includes an API to instrument asynchronous activity. For supported frameworks, the agent usually instruments async work automatically. However, the async API can still be useful to add detail. This document provides examples of using tokens and segments to instrument your app. For more information about how New Relic instruments and displays async work in the APM UI, see Monitoring considerations for asynchronous applications. For details on the actual classes and methods, see the Javadoc. For general information on the Java agent API, see the Java agent API guide. For troubleshooting common problems, see Troubleshooting Java asynchronous applications. Async tracking tools: Tokens and segments The Java agent API provides two ways to trace asynchronous activity: Tokens: Tokens are passed between threads to link asynchronous units of work to a specific transaction. They do not perform any timing directly. Segments: Segments are used to measure an arbitrary piece of asynchronous application code, not necessarily associated with a method or thread. Segments are typically used to track external calls that are completed by a callback mechanism. Tokens: Connect async threads Use tokens to link arbitrary units of work that are on separate threads. This section describes how to use the token-related calls together to instrument async work. For detailed information on classes and methods, see the Javadoc. To use tokens, you first need to create the token, then link another call to the originating transaction. You should link the token as soon as possible within the other call. If you do not link the token immediately, you risk losing any methods that contain an @Trace below the call you are trying to link. You can also expire the token in the original call. The Java agent will then link the work in the New Relic UI. These examples illustrate how to use the token-related calls together: 1. Start a transaction, then create and expire a token Consider the method parallelStream() in the code snippet below. Because some of the calls to requestItemAsync() will occur on a separate thread, a token is created and passed to link that asynchronous work back to the requesting thread. /** * Example showing multi-threaded implementation of requesting data using a parallel {@link Stream}. */ @RequestMapping(\"parallel_stream\") @Trace(dispatcher = true) // starts a transaction public ResponseEntity<String> parallelStream(@RequestParam(\"ids\") List<Long> ids) { final Token token = NewRelic.getAgent().getTransaction(). getToken() ; List<item> results = ids .parallelStream() .map(id -> requestItemAsync\\(id, token)) // note we're calling a different method than parallelStreamBad .filter(item -> item != null) .collect(Collectors.toList()); token.expire() ; return formattedResponse(\"parallel_stream\", results); } Copy The agent API calls in this sample are: @Trace(dispatcher = true): Tells the agent to start a transaction. For more on this method, see the Javadoc. getToken(): Creates the token which will link the work together. For more on this method, see the Javadoc. token.expire(): Expires the token. This allows the transaction to end. For more on this method, see the Javadoc. 2. Mark a transaction as async and link to request thread The following code example shows requestItemAsync, which might execute on a separate thread from the requesting thread. For this reason, the token that was created in the previous code example is linked to the Transaction in requestItemAsync. Note that requestItemAsync() has the @Trace(async=true) annotation, which tells the agent to trace this method if it's linked to an existing transaction. After parallelStream() collects all results, the token is expired. This is important because it makes sure the transaction doesn't stay open after parallelStream() completes. @Trace(async = true) private Item requestItemAsync(long id, Token token) { token.link() ; return requestItem(id); } Copy The agent API calls in this sample are: @Trace(async = true): Starts a transaction. For more on this method, see the Javadoc. token.link(): Links the work being done in requestItemAsync() (which is executing on a different thread) to the requesting thread. For more on this method, see the Javadoc. 3. View your async trace in the New Relic UI Here's an example of a transaction trace in the APM UI for this endpoint: one.newrelic.com > APM > (select an app) > Transactions > Transaction trace > Trace details: All asynchronous method calls linked with a token are indicated with an Async icon. All asynchronous method calls linked with a token are indicated with an Async icon in the Drilldown column. It's not necessary to link methods that are on the same thread, but doing so will have no negative effect. It's often the case that a single token can be shared, like in the parallelStream() example. Tip By default, a transaction can create a maximum of 3000 tokens and each token has a default timeout of 180s. You can change the former limit with the token_limit config option and the latter with the token_timeout config option. Traces for transactions that exceed the token_limit will contain a token_clamp attribute. Increasing either config option may increase agent memory usage. Segments: Time arbitrary async activity Segments are used to measure an arbitrary piece of asynchronous application code, not necessarily associated with a method or thread. This is most commonly used to time connections to external services. Use segments if you want to: Time code that completes via a callback Time an asynchronous call that spans many methods Measure the time between when work is created and when it executed (for example, in a thread pool) 1. Create a transaction and call an external service The method below makes a call to an external service (in this case a database) using the method storeItem(): /** * Example showing single threaded implementation of inserting data into a datasource. */ @RequestMapping(\"insert\") @Trace(dispatcher = true) //starts a transaction public ResponseEntity insert(@RequestParam(\"id\") Long id) { if (id != null) { storeItem(id); return new ResponseEntity<>(\"insert\", HttpStatus.OK); } else { return new ResponseEntity<>(\"insert\", HttpStatus.BAD_REQUEST); } } Copy The goal in this case it to find out how long the Callable in the Lambda statement is waiting in the thread pool before executing, rather than determining how long storeItem() runs. For this reason, a segment is used instead of a token, and @Trace(async = true) is not necessary like it was for a token. The agent API call in this sample is: @Trace(dispatcher = true): Starts a transaction. For more on this method, see the Javadoc. 2. Start a segment, report externals, and end the segment The following code example shows a segment starting in the storeItem method to measure how long the Lambda statement is waiting in the thread pool. To stop timing the segment, you must call either .end() or .ignore(). If you don't want to report the segment as part of its parent transaction, call .ignore(). Otherwise, to report the segment as part of its parent transaction, call .end(). private void storeItem(long id) { Segment segment = NewRelic.getAgent().getTransaction(). startSegment(\"storeItem\") ; segment. reportAsExternal (DatastoreParameters .product(\"H2\") .collection(null) .operation(\"insert\") .instance(\"localhost\", 8080) .databaseName(\"test\") .build()); // fire and forget DB_POOL.submit(() -> { segment.end(); insertData(id); }); } Copy The agent API calls in this sample are: startSegment(...): Begins the segment that will time the code. For more on this method, see the Javadoc. reportAsExternal(DatastoreParameters()): Associates the time with a datastore external call This will show up in APM with datastore data. For more information, see reportAsExternal API. segment.end(): Stops timing this segment. For more on this method, see the Javadoc. 3. View your async trace in the New Relic UI When the method completes, APM displays a transaction trace with one external call: one.newrelic.com > APM > (select an app) > Transactions > Transaction trace > Trace details: A single asynchronous segment is called out in the Drilldown column. Tip By default, the agent can track a maximum of 1000 segments during a given transaction. You can change this limit with the segment_timeout config option. Traces of transactions that exceed this limit will contain a segment_clamp attribute. Increasing this limit may increase agent memory usage.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.53629,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> API for <em>asynchronous</em> applications",
        "sections": "<em>Java</em> <em>agent</em> API for <em>asynchronous</em> applications",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "New Relic for <em>Java</em> (<em>agent</em> version 3.37 or higher) includes an API to <em>instrument</em> asynchronous activity. For supported frameworks, the <em>agent</em> usually instruments <em>async</em> work automatically. However, the <em>async</em> API can still be useful to add detail. This document provides examples of using tokens"
      },
      "id": "603eb4c9196a67dde5a83db7"
    },
    {
      "sections": [
        "Disable Scala, Netty, Akka, and Play 2 Instrumentation",
        "Contents",
        "Java agent versions 3.21 or lower",
        "Java agent versions 3.22 or higher",
        "Check for deprecated configuration settings"
      ],
      "title": "Disable Scala, Netty, Akka, and Play 2 Instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Async instrumentation"
      ],
      "external_id": "7a6fa946f9f903c240099279d125807b89665668",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/async-instrumentation/disable-scala-netty-akka-play-2-instrumentation/",
      "published_at": "2021-06-02T18:16:06Z",
      "updated_at": "2021-03-13T02:45:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes how to disable Java agent instrumentation on these popular async frameworks: Scala Netty Akka Play 2 You may choose to disable some or all of this instrumentation if you find that the metrics reported aren't valuable to you, or if the instrumentation incurs more overhead than you would like. If you selectively disable some of the instrumentation, some segments of activity will not be reported and your total time will be understated. Contents Java agent versions 3.21 or lower If you are using Java agent version 3.22 or lower, add the following to the class_transformer section of your newrelic.yml settings: # This section is for settings common to all environments. # Do not add anything above this next line. common: &default_settings class_transformer: akka_instrumentation: enabled: false netty_instrumenation: enabled: false play2_instrumentation: enabled: false scala_instrumentation: enabled: false Copy Java agent versions 3.22 or higher The older Scala, Netty, Akka, and Play 2 Framework instrumentation configuration names have been deprecated as of Java Agent version 3.22. For those using Java Agent 3.22 or higher, add the following to the class_transformer section of your newrelic.yml settings: common: &default_settings class_transformer: # Disable all Akka instrumentations com.newrelic.instrumentation.akka-2.0: enabled: false com.newrelic.instrumentation.akka-2.1: enabled: false # Disabling 2.2 also disables higher versions com.newrelic.instrumentation.akka-2.2: enabled: false # Disable all Netty instrumentations com.newrelic.instrumentation.netty-3.4: enabled: false com.newrelic.instrumentation.netty-3.8: enabled: false com.newrelic.instrumentation.netty-4.0.0: enabled: false com.newrelic.instrumentation.netty-4.0.8: enabled: false # Disable all Play 2 instrumentations com.newrelic.instrumentation.play-2.1: enabled: false com.newrelic.instrumentation.play-2.2: enabled: false com.newrelic.instrumentation.play-2.3: enabled: false # New in Release 3.22, the Play 2.4 instrumentation does not respect # the older play2_instrumentation configuration setting com.newrelic.instrumentation.play-2.4: enabled: false # Disable all Scala-language instrumentations com.newrelic.instrumentation.scala-2.9.3: enabled: false Copy The pre-3.22 instrumentation names will be respected for a time, but they will be removed in future releases. If disabled by either the old or new instrumentation configuration, the instrumentation will be disabled. Check for deprecated configuration settings Any use of the pre-3.22 instrumentation names will be logged with messages similar to: INFO: Using deprecated configuration setting akka_instrumentation for instrumentation com.newrelic.instrumentation.akka-2.2 Copy OR INFO: The configuration setting akka_instrumentation is deprecated, please update the class_transformer config to use com.newrelic.instrumentation.akka-2.2 instead Copy Using the deprecated settings does not indicate the deprecated instrumentation has been loaded or is being used. These messages are hints to the user that it is time to update your configuration settings. Play 2.4 does not respect the older play2_instrumentation configuration settings, as it is a new instrumentation. In all cases, if you are using Java agent version 3.22 or higher, you should use the new instrumentation names for the Scala, Netty, Akka, and Play 2 framework in their newrelic.yml.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.02397,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Disable Scala, Netty, Akka, and Play 2 <em>Instrumentation</em>",
        "sections": "<em>Java</em> <em>agent</em> versions 3.21 or lower",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "This document describes how to disable <em>Java</em> <em>agent</em> <em>instrumentation</em> on these popular <em>async</em> frameworks: Scala Netty Akka Play 2 You may choose to disable some or all of this <em>instrumentation</em> if you find that the metrics reported aren&#x27;t valuable to you, or if the <em>instrumentation</em> incurs more overhead"
      },
      "id": "6043f28428ccbc13812c6062"
    }
  ],
  "/docs/agents/java-agent/async-instrumentation/java-agent-api-asynchronous-applications": [
    {
      "sections": [
        "Troubleshoot Java asynchronous instrumentation",
        "Verify your instrumentation",
        "Use logs to troubleshoot",
        "Problem: Transaction times are too long",
        "Problem: No transaction trace data",
        "Problem: Too few async calls",
        "Ensure that each activity you monitor is appropriately linked",
        "Check if you are missing required annotations"
      ],
      "title": "Troubleshoot Java asynchronous instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Async instrumentation"
      ],
      "external_id": "0f21da73ba02edc45ec0cbbbaa7e0fc45678404b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/async-instrumentation/troubleshoot-java-asynchronous-instrumentation/",
      "published_at": "2021-06-02T18:16:53Z",
      "updated_at": "2021-03-16T09:03:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "If you are having problems using the Java agent API for async tokens and segments, use these techniques to help you find answers and solve problems. Verify your instrumentation The API has a number of built-in safety mechanisms to prevent issues caused by incorrect API usage, but you can use these techniques to verify that your application’s instrumentation is correct: After instrumenting your code, verify that the logs show that an equal number of tokens have been created and expired. For more information on which log messages to look for, see Use logs to troubleshoot. Check the garbage collection statistics under APM's JVMs page to determine whether or not your changes have significantly altered garbage collection patterns. Check if any segments or tokens are timing out by reviewing your transaction traces for a timed_out attribute. If so, you can change the limit with token_timeout and segment_timeout. Use logs to troubleshoot To customize your Java agent logging, see Generating logs. Then, you can examine your logs for these common messages: To view created tokens, check logs at FINEST for: Transaction com.newrelic.agent.Transaction@5a7cc8e: created active token com.newrelic.agent.TokenImpl@7db8d0e8 Copy To view expired tokens and the time that they expired, check logs at FINEST for: Transaction com.newrelic.agent.Transaction@5a7cc8e: expired token com.newrelic.agent.TokenImpl@7db8d0e8 Copy To view created segments, check logs at FINEST for: Transaction com.newrelic.agent.Transaction@486b7f04: startSegment(): com.newrelic.agent.Segment@2b7fdad3 created and started with tracer com.newrelic.agent.tracers.OtherRootTracer@4df4a953 Copy To view ended segments and the time that they ended, check logs at FINEST for: com.newrelic.agent.Transaction@486b7f04--finish segment(): com.newrelic.agent.Segment@2b7fdad3 async finish with tracer com.newrelic.agent.tracers.OtherRootTracer@4df4a953 Copy Problem: Transaction times are too long Make sure to expire tokens and end or ignore segments; otherwise transactions may take longer to report to New Relic. The Java agent has a timeout mechanism for tokens and segments that are not ended correctly. For more information, see token_timeout and segment_timeout. Problem: No transaction trace data Inspect transaction traces to make sure expected asynchronous work is reported. If you do not see any transaction traces, make sure your transaction duration exceeds the transaction trace threshold set in transaction_threshold. Problem: Too few async calls If too few calls are being reported: Ensure that each activity you monitor is appropriately linked In the faulty example below, a parallel stream is being used, which means that the work done inside the lambda in the call to map() can be scheduled on a different thread than the thread handling the request. Without creating a token to link all this work together, you will not see any of the work that gets scheduled on a different thread inside of your transaction. @RequestMapping(\"parallel_stream_bad\") @Trace(dispatcher = true) public ResponseEntity parallelStreamBad(@RequestParam(\"ids\") List<long> ids) { List<item> results = ids .parallelStream() .map(i -> requestItem(i)) .filter(item -> item != null) .collect(Collectors.toList()); return formattedResponse(\"parallel_stream_bad\", results); } Copy Check if you are missing required annotations The example below will report only a subset of the calls to requestItem() because it is impossible to put @Trace(async = true) around blocks of anonymous work inside the call to map(). Instead, you should pass the token into requestItem() and link it, and then add @Trace(async=true) around it. Or use a helper function like requestItemAsync() to do this without changing your existing methods. @RequestMapping(\"parallel_stream_bad2\") @Trace(dispatcher = true) public ResponseEntity parallelStreamBad2(@RequestParam(\"ids\") List<long> ids) { final Token token = NewRelic.getAgent().getTransaction().getToken(); List<item> results = ids .parallelStream() .map(id -> { token.link(); return requestItem(id); }) .filter(item -> item != null) .collect(Collectors.toList()); return formattedResponse(\"parallel_stream_bad2\", results); } Copy Compare this to the correct example below, in which the lambda expression is wrapped by the wrapper class InstrumentedCallable. This class accepts a token and a lambda, then wraps asynchronous work in @Trace(async = true) and uses a token to link the work to the request thread. @RequestMapping(\"parallel_stream_wrap\") @Trace(dispatcher = true) public ResponseEntity parallelStreamWrap(@RequestParam(\"ids\") List<long> ids) { final Token token = NewRelic.getAgent().getTransaction().getToken(); List<item> results = ids .parallelStream() .map(id -> InstrumentedCallable.instrumentCallable(token, () -> requestItem(id))) .map(c -> c.call()) .filter(item -> item != null) .collect(Collectors.toList()); token.expire(); return formattedResponse(\"parallel_stream_wrap\", results); } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.5366,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Troubleshoot <em>Java</em> <em>asynchronous</em> <em>instrumentation</em>",
        "sections": "Troubleshoot <em>Java</em> <em>asynchronous</em> <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "If you are having problems using the <em>Java</em> <em>agent</em> API for <em>async</em> tokens and segments, use these techniques to help you find answers and solve problems. Verify your <em>instrumentation</em> The API has a number of built-in safety mechanisms to prevent issues caused by incorrect API usage, but you can use"
      },
      "id": "603eb55a196a67260aa83dac"
    },
    {
      "sections": [
        "Introduction to Java async instrumentation",
        "Asynchronous operations",
        "Async and thread-switching",
        "Async and response time",
        "Custom instrumentation with the async API"
      ],
      "title": "Introduction to Java async instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Async instrumentation"
      ],
      "external_id": "3b0a9e1f2f6b69a8ad101ec59c592ac4a574ae63",
      "image": "https://docs.newrelic.com/static/a38112969f7c8a3001651b65853a803b/39c09/sZ6-I4x5BDSDspRS_G7Hefg.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/async-instrumentation/introduction-java-async-instrumentation/",
      "published_at": "2021-06-02T18:16:06Z",
      "updated_at": "2021-03-16T09:00:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic for Java includes a set of API methods for custom instrumentation of asynchronous activity. This is most useful to instrument asynchronous activity in unsupported frameworks, but you can also use the API to add additional instrumentation to supported frameworks. This document explains how asynchronous activity occurs, and how New Relic monitors async work. Asynchronous operations With a synchronous programming model, programming tasks are usually executed in a specific order. One task must complete before the next task begins, and each task blocks the next task from completing. Asynchronous programming uses a non-blocking model, so that tasks can be run in parallel. Tasks executed asynchronously are completely independent of each other in their execution and initialization. Because asynchronous code doesn't execute in a specific order, the server's full processing power can be used more efficiently, and the app's throughput increases. Async and thread-switching For applications that use asynchronous processing, thread-switching is when a program or task switches from one thread to another. Understanding these asynchronous interleavings can help you decide which methods should be instrumented. Here is an example method with a controller that makes external requests in parallel. These requests execute asynchronously, so each request executes independently of each other and getScoreAsync() returns immediately after being called. This allows the requesting thread to continue making requests while getScoreAsync() makes an external call and sends a reply. @ResponseBody @RequestMapping(\"getScores\", method = RequestMethod.Get produces = “text/plain”) public String getCreditScores(@RequestParam(name = \"uids\") uids) { return Arrays.stream(uids.split(\",\")) .parallel() .map(Integer::valueOf) .map(uid -> getScoreAsync(uid)) .collect(Collectors.toList());} Copy Some of these requests will finish before others. Some might even finish after the requesting thread has moved on to other tasks: With New Relic's asynchronous instrumentation, the APM UI flags the work as Async. For example, if the above method were instrumented by New Relic (either automatically or via custom instrumentation), this is what the APM UI would show on the Trace details page: one.newrelic.com > APM > (select an app) > Transactions > Transaction trace > Trace details: When asynchronous activity in a Java application is detected by APM, it is indicated with the Async flag in the Drilldown column. Async and response time Response time is defined as the duration of a transaction from the perspective of the requester. For asynchronous applications, the response time is often less than the total transaction time. This is because the methods don't have to wait for all preceding methods to complete before returning. Because tasks can be deferred, the application can take advantage of its limited resources and process things more quickly. The chart's response time line gives you more insight into the perceived behavior and speed of your application than does the total web transaction time: one.newrelic.com > APM > (select an app) > Summary: On the APM Summary page, asynchronous activity in a Java app can result in the response time (the blue line) being less than the total transaction time. This is because the methods don't have to wait for all preceding methods to complete before returning. Custom instrumentation with the async API To implement custom instrumentation of async work, see the Java agent async API guide. For general information on how to use the Java agent API, see Java agent API guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.53629,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Java</em> <em>async</em> <em>instrumentation</em>",
        "sections": "Introduction to <em>Java</em> <em>async</em> <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " transaction time. This is because the methods don&#x27;t have to wait for all preceding methods to complete before returning. Custom <em>instrumentation</em> with the <em>async</em> API To implement custom <em>instrumentation</em> of <em>async</em> work, see the <em>Java</em> <em>agent</em> <em>async</em> API guide. For general information on how to use the <em>Java</em> <em>agent</em> API, see <em>Java</em> <em>agent</em> API guide."
      },
      "id": "603eb491e7b9d282bd2a07ca"
    },
    {
      "sections": [
        "Disable Scala, Netty, Akka, and Play 2 Instrumentation",
        "Contents",
        "Java agent versions 3.21 or lower",
        "Java agent versions 3.22 or higher",
        "Check for deprecated configuration settings"
      ],
      "title": "Disable Scala, Netty, Akka, and Play 2 Instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Async instrumentation"
      ],
      "external_id": "7a6fa946f9f903c240099279d125807b89665668",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/async-instrumentation/disable-scala-netty-akka-play-2-instrumentation/",
      "published_at": "2021-06-02T18:16:06Z",
      "updated_at": "2021-03-13T02:45:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes how to disable Java agent instrumentation on these popular async frameworks: Scala Netty Akka Play 2 You may choose to disable some or all of this instrumentation if you find that the metrics reported aren't valuable to you, or if the instrumentation incurs more overhead than you would like. If you selectively disable some of the instrumentation, some segments of activity will not be reported and your total time will be understated. Contents Java agent versions 3.21 or lower If you are using Java agent version 3.22 or lower, add the following to the class_transformer section of your newrelic.yml settings: # This section is for settings common to all environments. # Do not add anything above this next line. common: &default_settings class_transformer: akka_instrumentation: enabled: false netty_instrumenation: enabled: false play2_instrumentation: enabled: false scala_instrumentation: enabled: false Copy Java agent versions 3.22 or higher The older Scala, Netty, Akka, and Play 2 Framework instrumentation configuration names have been deprecated as of Java Agent version 3.22. For those using Java Agent 3.22 or higher, add the following to the class_transformer section of your newrelic.yml settings: common: &default_settings class_transformer: # Disable all Akka instrumentations com.newrelic.instrumentation.akka-2.0: enabled: false com.newrelic.instrumentation.akka-2.1: enabled: false # Disabling 2.2 also disables higher versions com.newrelic.instrumentation.akka-2.2: enabled: false # Disable all Netty instrumentations com.newrelic.instrumentation.netty-3.4: enabled: false com.newrelic.instrumentation.netty-3.8: enabled: false com.newrelic.instrumentation.netty-4.0.0: enabled: false com.newrelic.instrumentation.netty-4.0.8: enabled: false # Disable all Play 2 instrumentations com.newrelic.instrumentation.play-2.1: enabled: false com.newrelic.instrumentation.play-2.2: enabled: false com.newrelic.instrumentation.play-2.3: enabled: false # New in Release 3.22, the Play 2.4 instrumentation does not respect # the older play2_instrumentation configuration setting com.newrelic.instrumentation.play-2.4: enabled: false # Disable all Scala-language instrumentations com.newrelic.instrumentation.scala-2.9.3: enabled: false Copy The pre-3.22 instrumentation names will be respected for a time, but they will be removed in future releases. If disabled by either the old or new instrumentation configuration, the instrumentation will be disabled. Check for deprecated configuration settings Any use of the pre-3.22 instrumentation names will be logged with messages similar to: INFO: Using deprecated configuration setting akka_instrumentation for instrumentation com.newrelic.instrumentation.akka-2.2 Copy OR INFO: The configuration setting akka_instrumentation is deprecated, please update the class_transformer config to use com.newrelic.instrumentation.akka-2.2 instead Copy Using the deprecated settings does not indicate the deprecated instrumentation has been loaded or is being used. These messages are hints to the user that it is time to update your configuration settings. Play 2.4 does not respect the older play2_instrumentation configuration settings, as it is a new instrumentation. In all cases, if you are using Java agent version 3.22 or higher, you should use the new instrumentation names for the Scala, Netty, Akka, and Play 2 framework in their newrelic.yml.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.02397,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Disable Scala, Netty, Akka, and Play 2 <em>Instrumentation</em>",
        "sections": "<em>Java</em> <em>agent</em> versions 3.21 or lower",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "This document describes how to disable <em>Java</em> <em>agent</em> <em>instrumentation</em> on these popular <em>async</em> frameworks: Scala Netty Akka Play 2 You may choose to disable some or all of this <em>instrumentation</em> if you find that the metrics reported aren&#x27;t valuable to you, or if the <em>instrumentation</em> incurs more overhead"
      },
      "id": "6043f28428ccbc13812c6062"
    }
  ],
  "/docs/agents/java-agent/async-instrumentation/troubleshoot-java-asynchronous-instrumentation": [
    {
      "sections": [
        "Java agent API for asynchronous applications",
        "Async tracking tools: Tokens and segments",
        "Tokens: Connect async threads",
        "1. Start a transaction, then create and expire a token",
        "2. Mark a transaction as async and link to request thread",
        "3. View your async trace in the New Relic UI",
        "Tip",
        "Segments: Time arbitrary async activity",
        "1. Create a transaction and call an external service",
        "2. Start a segment, report externals, and end the segment"
      ],
      "title": "Java agent API for asynchronous applications",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Async instrumentation"
      ],
      "external_id": "7b5f035809040487d96279fb318203b479a61b02",
      "image": "https://docs.newrelic.com/static/06c87505ee5c0d97e598d04258587f52/c1b63/Screen-Shot-2017-03-14-at-4.50.31-PM.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/async-instrumentation/java-agent-api-asynchronous-applications/",
      "published_at": "2021-06-02T18:16:52Z",
      "updated_at": "2021-03-16T09:00:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic for Java (agent version 3.37 or higher) includes an API to instrument asynchronous activity. For supported frameworks, the agent usually instruments async work automatically. However, the async API can still be useful to add detail. This document provides examples of using tokens and segments to instrument your app. For more information about how New Relic instruments and displays async work in the APM UI, see Monitoring considerations for asynchronous applications. For details on the actual classes and methods, see the Javadoc. For general information on the Java agent API, see the Java agent API guide. For troubleshooting common problems, see Troubleshooting Java asynchronous applications. Async tracking tools: Tokens and segments The Java agent API provides two ways to trace asynchronous activity: Tokens: Tokens are passed between threads to link asynchronous units of work to a specific transaction. They do not perform any timing directly. Segments: Segments are used to measure an arbitrary piece of asynchronous application code, not necessarily associated with a method or thread. Segments are typically used to track external calls that are completed by a callback mechanism. Tokens: Connect async threads Use tokens to link arbitrary units of work that are on separate threads. This section describes how to use the token-related calls together to instrument async work. For detailed information on classes and methods, see the Javadoc. To use tokens, you first need to create the token, then link another call to the originating transaction. You should link the token as soon as possible within the other call. If you do not link the token immediately, you risk losing any methods that contain an @Trace below the call you are trying to link. You can also expire the token in the original call. The Java agent will then link the work in the New Relic UI. These examples illustrate how to use the token-related calls together: 1. Start a transaction, then create and expire a token Consider the method parallelStream() in the code snippet below. Because some of the calls to requestItemAsync() will occur on a separate thread, a token is created and passed to link that asynchronous work back to the requesting thread. /** * Example showing multi-threaded implementation of requesting data using a parallel {@link Stream}. */ @RequestMapping(\"parallel_stream\") @Trace(dispatcher = true) // starts a transaction public ResponseEntity<String> parallelStream(@RequestParam(\"ids\") List<Long> ids) { final Token token = NewRelic.getAgent().getTransaction(). getToken() ; List<item> results = ids .parallelStream() .map(id -> requestItemAsync\\(id, token)) // note we're calling a different method than parallelStreamBad .filter(item -> item != null) .collect(Collectors.toList()); token.expire() ; return formattedResponse(\"parallel_stream\", results); } Copy The agent API calls in this sample are: @Trace(dispatcher = true): Tells the agent to start a transaction. For more on this method, see the Javadoc. getToken(): Creates the token which will link the work together. For more on this method, see the Javadoc. token.expire(): Expires the token. This allows the transaction to end. For more on this method, see the Javadoc. 2. Mark a transaction as async and link to request thread The following code example shows requestItemAsync, which might execute on a separate thread from the requesting thread. For this reason, the token that was created in the previous code example is linked to the Transaction in requestItemAsync. Note that requestItemAsync() has the @Trace(async=true) annotation, which tells the agent to trace this method if it's linked to an existing transaction. After parallelStream() collects all results, the token is expired. This is important because it makes sure the transaction doesn't stay open after parallelStream() completes. @Trace(async = true) private Item requestItemAsync(long id, Token token) { token.link() ; return requestItem(id); } Copy The agent API calls in this sample are: @Trace(async = true): Starts a transaction. For more on this method, see the Javadoc. token.link(): Links the work being done in requestItemAsync() (which is executing on a different thread) to the requesting thread. For more on this method, see the Javadoc. 3. View your async trace in the New Relic UI Here's an example of a transaction trace in the APM UI for this endpoint: one.newrelic.com > APM > (select an app) > Transactions > Transaction trace > Trace details: All asynchronous method calls linked with a token are indicated with an Async icon. All asynchronous method calls linked with a token are indicated with an Async icon in the Drilldown column. It's not necessary to link methods that are on the same thread, but doing so will have no negative effect. It's often the case that a single token can be shared, like in the parallelStream() example. Tip By default, a transaction can create a maximum of 3000 tokens and each token has a default timeout of 180s. You can change the former limit with the token_limit config option and the latter with the token_timeout config option. Traces for transactions that exceed the token_limit will contain a token_clamp attribute. Increasing either config option may increase agent memory usage. Segments: Time arbitrary async activity Segments are used to measure an arbitrary piece of asynchronous application code, not necessarily associated with a method or thread. This is most commonly used to time connections to external services. Use segments if you want to: Time code that completes via a callback Time an asynchronous call that spans many methods Measure the time between when work is created and when it executed (for example, in a thread pool) 1. Create a transaction and call an external service The method below makes a call to an external service (in this case a database) using the method storeItem(): /** * Example showing single threaded implementation of inserting data into a datasource. */ @RequestMapping(\"insert\") @Trace(dispatcher = true) //starts a transaction public ResponseEntity insert(@RequestParam(\"id\") Long id) { if (id != null) { storeItem(id); return new ResponseEntity<>(\"insert\", HttpStatus.OK); } else { return new ResponseEntity<>(\"insert\", HttpStatus.BAD_REQUEST); } } Copy The goal in this case it to find out how long the Callable in the Lambda statement is waiting in the thread pool before executing, rather than determining how long storeItem() runs. For this reason, a segment is used instead of a token, and @Trace(async = true) is not necessary like it was for a token. The agent API call in this sample is: @Trace(dispatcher = true): Starts a transaction. For more on this method, see the Javadoc. 2. Start a segment, report externals, and end the segment The following code example shows a segment starting in the storeItem method to measure how long the Lambda statement is waiting in the thread pool. To stop timing the segment, you must call either .end() or .ignore(). If you don't want to report the segment as part of its parent transaction, call .ignore(). Otherwise, to report the segment as part of its parent transaction, call .end(). private void storeItem(long id) { Segment segment = NewRelic.getAgent().getTransaction(). startSegment(\"storeItem\") ; segment. reportAsExternal (DatastoreParameters .product(\"H2\") .collection(null) .operation(\"insert\") .instance(\"localhost\", 8080) .databaseName(\"test\") .build()); // fire and forget DB_POOL.submit(() -> { segment.end(); insertData(id); }); } Copy The agent API calls in this sample are: startSegment(...): Begins the segment that will time the code. For more on this method, see the Javadoc. reportAsExternal(DatastoreParameters()): Associates the time with a datastore external call This will show up in APM with datastore data. For more information, see reportAsExternal API. segment.end(): Stops timing this segment. For more on this method, see the Javadoc. 3. View your async trace in the New Relic UI When the method completes, APM displays a transaction trace with one external call: one.newrelic.com > APM > (select an app) > Transactions > Transaction trace > Trace details: A single asynchronous segment is called out in the Drilldown column. Tip By default, the agent can track a maximum of 1000 segments during a given transaction. You can change this limit with the segment_timeout config option. Traces of transactions that exceed this limit will contain a segment_clamp attribute. Increasing this limit may increase agent memory usage.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.53629,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> API for <em>asynchronous</em> applications",
        "sections": "<em>Java</em> <em>agent</em> API for <em>asynchronous</em> applications",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "New Relic for <em>Java</em> (<em>agent</em> version 3.37 or higher) includes an API to <em>instrument</em> asynchronous activity. For supported frameworks, the <em>agent</em> usually instruments <em>async</em> work automatically. However, the <em>async</em> API can still be useful to add detail. This document provides examples of using tokens"
      },
      "id": "603eb4c9196a67dde5a83db7"
    },
    {
      "sections": [
        "Introduction to Java async instrumentation",
        "Asynchronous operations",
        "Async and thread-switching",
        "Async and response time",
        "Custom instrumentation with the async API"
      ],
      "title": "Introduction to Java async instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Async instrumentation"
      ],
      "external_id": "3b0a9e1f2f6b69a8ad101ec59c592ac4a574ae63",
      "image": "https://docs.newrelic.com/static/a38112969f7c8a3001651b65853a803b/39c09/sZ6-I4x5BDSDspRS_G7Hefg.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/async-instrumentation/introduction-java-async-instrumentation/",
      "published_at": "2021-06-02T18:16:06Z",
      "updated_at": "2021-03-16T09:00:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic for Java includes a set of API methods for custom instrumentation of asynchronous activity. This is most useful to instrument asynchronous activity in unsupported frameworks, but you can also use the API to add additional instrumentation to supported frameworks. This document explains how asynchronous activity occurs, and how New Relic monitors async work. Asynchronous operations With a synchronous programming model, programming tasks are usually executed in a specific order. One task must complete before the next task begins, and each task blocks the next task from completing. Asynchronous programming uses a non-blocking model, so that tasks can be run in parallel. Tasks executed asynchronously are completely independent of each other in their execution and initialization. Because asynchronous code doesn't execute in a specific order, the server's full processing power can be used more efficiently, and the app's throughput increases. Async and thread-switching For applications that use asynchronous processing, thread-switching is when a program or task switches from one thread to another. Understanding these asynchronous interleavings can help you decide which methods should be instrumented. Here is an example method with a controller that makes external requests in parallel. These requests execute asynchronously, so each request executes independently of each other and getScoreAsync() returns immediately after being called. This allows the requesting thread to continue making requests while getScoreAsync() makes an external call and sends a reply. @ResponseBody @RequestMapping(\"getScores\", method = RequestMethod.Get produces = “text/plain”) public String getCreditScores(@RequestParam(name = \"uids\") uids) { return Arrays.stream(uids.split(\",\")) .parallel() .map(Integer::valueOf) .map(uid -> getScoreAsync(uid)) .collect(Collectors.toList());} Copy Some of these requests will finish before others. Some might even finish after the requesting thread has moved on to other tasks: With New Relic's asynchronous instrumentation, the APM UI flags the work as Async. For example, if the above method were instrumented by New Relic (either automatically or via custom instrumentation), this is what the APM UI would show on the Trace details page: one.newrelic.com > APM > (select an app) > Transactions > Transaction trace > Trace details: When asynchronous activity in a Java application is detected by APM, it is indicated with the Async flag in the Drilldown column. Async and response time Response time is defined as the duration of a transaction from the perspective of the requester. For asynchronous applications, the response time is often less than the total transaction time. This is because the methods don't have to wait for all preceding methods to complete before returning. Because tasks can be deferred, the application can take advantage of its limited resources and process things more quickly. The chart's response time line gives you more insight into the perceived behavior and speed of your application than does the total web transaction time: one.newrelic.com > APM > (select an app) > Summary: On the APM Summary page, asynchronous activity in a Java app can result in the response time (the blue line) being less than the total transaction time. This is because the methods don't have to wait for all preceding methods to complete before returning. Custom instrumentation with the async API To implement custom instrumentation of async work, see the Java agent async API guide. For general information on how to use the Java agent API, see Java agent API guide.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.53629,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to <em>Java</em> <em>async</em> <em>instrumentation</em>",
        "sections": "Introduction to <em>Java</em> <em>async</em> <em>instrumentation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " transaction time. This is because the methods don&#x27;t have to wait for all preceding methods to complete before returning. Custom <em>instrumentation</em> with the <em>async</em> API To implement custom <em>instrumentation</em> of <em>async</em> work, see the <em>Java</em> <em>agent</em> <em>async</em> API guide. For general information on how to use the <em>Java</em> <em>agent</em> API, see <em>Java</em> <em>agent</em> API guide."
      },
      "id": "603eb491e7b9d282bd2a07ca"
    },
    {
      "sections": [
        "Disable Scala, Netty, Akka, and Play 2 Instrumentation",
        "Contents",
        "Java agent versions 3.21 or lower",
        "Java agent versions 3.22 or higher",
        "Check for deprecated configuration settings"
      ],
      "title": "Disable Scala, Netty, Akka, and Play 2 Instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Async instrumentation"
      ],
      "external_id": "7a6fa946f9f903c240099279d125807b89665668",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/async-instrumentation/disable-scala-netty-akka-play-2-instrumentation/",
      "published_at": "2021-06-02T18:16:06Z",
      "updated_at": "2021-03-13T02:45:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document describes how to disable Java agent instrumentation on these popular async frameworks: Scala Netty Akka Play 2 You may choose to disable some or all of this instrumentation if you find that the metrics reported aren't valuable to you, or if the instrumentation incurs more overhead than you would like. If you selectively disable some of the instrumentation, some segments of activity will not be reported and your total time will be understated. Contents Java agent versions 3.21 or lower If you are using Java agent version 3.22 or lower, add the following to the class_transformer section of your newrelic.yml settings: # This section is for settings common to all environments. # Do not add anything above this next line. common: &default_settings class_transformer: akka_instrumentation: enabled: false netty_instrumenation: enabled: false play2_instrumentation: enabled: false scala_instrumentation: enabled: false Copy Java agent versions 3.22 or higher The older Scala, Netty, Akka, and Play 2 Framework instrumentation configuration names have been deprecated as of Java Agent version 3.22. For those using Java Agent 3.22 or higher, add the following to the class_transformer section of your newrelic.yml settings: common: &default_settings class_transformer: # Disable all Akka instrumentations com.newrelic.instrumentation.akka-2.0: enabled: false com.newrelic.instrumentation.akka-2.1: enabled: false # Disabling 2.2 also disables higher versions com.newrelic.instrumentation.akka-2.2: enabled: false # Disable all Netty instrumentations com.newrelic.instrumentation.netty-3.4: enabled: false com.newrelic.instrumentation.netty-3.8: enabled: false com.newrelic.instrumentation.netty-4.0.0: enabled: false com.newrelic.instrumentation.netty-4.0.8: enabled: false # Disable all Play 2 instrumentations com.newrelic.instrumentation.play-2.1: enabled: false com.newrelic.instrumentation.play-2.2: enabled: false com.newrelic.instrumentation.play-2.3: enabled: false # New in Release 3.22, the Play 2.4 instrumentation does not respect # the older play2_instrumentation configuration setting com.newrelic.instrumentation.play-2.4: enabled: false # Disable all Scala-language instrumentations com.newrelic.instrumentation.scala-2.9.3: enabled: false Copy The pre-3.22 instrumentation names will be respected for a time, but they will be removed in future releases. If disabled by either the old or new instrumentation configuration, the instrumentation will be disabled. Check for deprecated configuration settings Any use of the pre-3.22 instrumentation names will be logged with messages similar to: INFO: Using deprecated configuration setting akka_instrumentation for instrumentation com.newrelic.instrumentation.akka-2.2 Copy OR INFO: The configuration setting akka_instrumentation is deprecated, please update the class_transformer config to use com.newrelic.instrumentation.akka-2.2 instead Copy Using the deprecated settings does not indicate the deprecated instrumentation has been loaded or is being used. These messages are hints to the user that it is time to update your configuration settings. Play 2.4 does not respect the older play2_instrumentation configuration settings, as it is a new instrumentation. In all cases, if you are using Java agent version 3.22 or higher, you should use the new instrumentation names for the Scala, Netty, Akka, and Play 2 framework in their newrelic.yml.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.02397,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Disable Scala, Netty, Akka, and Play 2 <em>Instrumentation</em>",
        "sections": "<em>Java</em> <em>agent</em> versions 3.21 or lower",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "This document describes how to disable <em>Java</em> <em>agent</em> <em>instrumentation</em> on these popular <em>async</em> frameworks: Scala Netty Akka Play 2 You may choose to disable some or all of this <em>instrumentation</em> if you find that the metrics reported aren&#x27;t valuable to you, or if the <em>instrumentation</em> incurs more overhead"
      },
      "id": "6043f28428ccbc13812c6062"
    }
  ],
  "/docs/agents/java-agent/attributes/java-agent-attributes": [
    {
      "sections": [
        "APM agent security: Java",
        "Default security settings",
        "Caution",
        "High security mode settings",
        "Custom security settings"
      ],
      "title": "APM agent security: Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "fd9f5744c001453dbb9f129480f4e7e5ce42a176",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/apm-agent-security-java/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives, you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see Java agent error configuration. By default, here is how the New Relic Java agent handles the following potentially sensitive data:: Request parameters: The agent does not capture HTTP request parameters. HTTPS: The agent communicates with New Relic using HTTPS. SQL: The agent sets SQL recording to obfuscated, which removes the potentially sensitive numeric and string literal values. High security mode settings When you enable high security mode, the default settings are locked so that users cannot change them. In addition: The agent does not collect message queue parameters. You cannot create custom events. You cannot implement custom instrumentation using the Custom Instrumentation Editor. You cannot collect user attributes. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: Java agent configuration file Custom attributes Java agent API Setting Effects on data security audit_mode boolean Default: false By default, the Java agent does not log all data sent to New Relic in the agent log file. If you set this to true, the agent logs data sent to the New Relic collector in the agent log file. You can then evaluate the information that the agent sends by reviewing the agent log file to see if it includes sensitive information. high_security boolean Default: false To enable high security mode, set this to true and enable high security in New Relic. This restricts the information you can send to New Relic. proxy_host string Default: (none) Some proxies default to using HTTP, which is a less secure protocol. attributes.enabled boolean Default: true Default for the Custom Instrumentation Editor: false By default, you are sending attributes to New Relic, except for methods instrumented using the Custom Instrumentation Editor. If you do not want to send attributes to New Relic, set this to false. attributes.exclude string Default: (none) If there are specific attribute keys that you do not want to send to New Relic in transaction traces, identify them using attributes.exclude. This restricts the information sent to New Relic. Consider if you want to exclude these potentially sensitive attributes using attributes.exclude or if you need the information sent to New Relic: request.headers.*: Removes all request headers. (Note that HTTP headers that contain sensitive data such as cookie and authorization are never collected.) response.headers.*: Removes all response headers. request_uri: Removes the path for the transaction's incoming request. log_sql boolean Default: false By default, you are sending queries to New Relic using record_sql. If you want to log queries in the agent log file as well as send them to New Relic, set this to true. record_sql string Default: obfuscated By default, record_sql is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to off. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. strip_exception_messages boolean Default: false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. If you are not using high security mode but still want to strip messages from all exceptions except those in your allow list, set this to true. custom_insights_events.enabled boolean Default: true By default, the agent records events sent to the Event API via recordCustomEvent(). If you enable high security mode, this is automatically set to false.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.83087,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>agent</em> security: <em>Java</em>",
        "sections": "APM <em>agent</em> security: <em>Java</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " <em>attributes</em>. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: <em>Java</em> <em>agent</em> configuration file Custom <em>attributes</em> <em>Java</em> <em>agent</em> API"
      },
      "id": "6043b8bb28ccbc3db92c60b7"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 129.32054,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> API lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This API consists of: Static methods on the com.newrelic.api.<em>agent</em>.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 114.71704,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " method. The <em>Java</em> <em>agent</em> reports the database name and database server&#x2F;identifier <em>attributes</em> on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install"
      },
      "id": "6043b8f6196a6771a9960f87"
    }
  ],
  "/docs/agents/java-agent/configuration/automatic-application-naming": [
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.26529,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the instrumentation package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]instrumentation.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate <em>configuration</em> to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.7324,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "): Include the <em>Java</em> <em>agent</em>: Install <em>Java</em> <em>agent</em> version 6.1.0 or higher to monitor your application. Configure the <em>Java</em> <em>agent</em> to allow it to communicate with the JMX daemon by adding the following <em>configuration</em> to the newrelic.yml <em>configuration</em> file: jmx: enabled: true linkingMetadataMBean: true Copy Tip"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "APM agent security: Java",
        "Default security settings",
        "Caution",
        "High security mode settings",
        "Custom security settings"
      ],
      "title": "APM agent security: Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "fd9f5744c001453dbb9f129480f4e7e5ce42a176",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/apm-agent-security-java/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives, you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see Java agent error configuration. By default, here is how the New Relic Java agent handles the following potentially sensitive data:: Request parameters: The agent does not capture HTTP request parameters. HTTPS: The agent communicates with New Relic using HTTPS. SQL: The agent sets SQL recording to obfuscated, which removes the potentially sensitive numeric and string literal values. High security mode settings When you enable high security mode, the default settings are locked so that users cannot change them. In addition: The agent does not collect message queue parameters. You cannot create custom events. You cannot implement custom instrumentation using the Custom Instrumentation Editor. You cannot collect user attributes. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: Java agent configuration file Custom attributes Java agent API Setting Effects on data security audit_mode boolean Default: false By default, the Java agent does not log all data sent to New Relic in the agent log file. If you set this to true, the agent logs data sent to the New Relic collector in the agent log file. You can then evaluate the information that the agent sends by reviewing the agent log file to see if it includes sensitive information. high_security boolean Default: false To enable high security mode, set this to true and enable high security in New Relic. This restricts the information you can send to New Relic. proxy_host string Default: (none) Some proxies default to using HTTP, which is a less secure protocol. attributes.enabled boolean Default: true Default for the Custom Instrumentation Editor: false By default, you are sending attributes to New Relic, except for methods instrumented using the Custom Instrumentation Editor. If you do not want to send attributes to New Relic, set this to false. attributes.exclude string Default: (none) If there are specific attribute keys that you do not want to send to New Relic in transaction traces, identify them using attributes.exclude. This restricts the information sent to New Relic. Consider if you want to exclude these potentially sensitive attributes using attributes.exclude or if you need the information sent to New Relic: request.headers.*: Removes all request headers. (Note that HTTP headers that contain sensitive data such as cookie and authorization are never collected.) response.headers.*: Removes all response headers. request_uri: Removes the path for the transaction's incoming request. log_sql boolean Default: false By default, you are sending queries to New Relic using record_sql. If you want to log queries in the agent log file as well as send them to New Relic, set this to true. record_sql string Default: obfuscated By default, record_sql is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to off. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. strip_exception_messages boolean Default: false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. If you are not using high security mode but still want to strip messages from all exceptions except those in your allow list, set this to true. custom_insights_events.enabled boolean Default: true By default, the agent records events sent to the Event API via recordCustomEvent(). If you enable high security mode, this is automatically set to false.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.97745,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>agent</em> security: <em>Java</em>",
        "sections": "APM <em>agent</em> security: <em>Java</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": ". Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see <em>Java</em> <em>agent</em> error <em>configuration</em>. By default, here is how the New Relic <em>Java</em> <em>agent</em> handles the following potentially sensitive"
      },
      "id": "6043b8bb28ccbc3db92c60b7"
    }
  ],
  "/docs/agents/java-agent/configuration/configuring-your-ssl-certificates": [
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.26529,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the instrumentation package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]instrumentation.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate <em>configuration</em> to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.7324,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "): Include the <em>Java</em> <em>agent</em>: Install <em>Java</em> <em>agent</em> version 6.1.0 or higher to monitor your application. Configure the <em>Java</em> <em>agent</em> to allow it to communicate with the JMX daemon by adding the following <em>configuration</em> to the newrelic.yml <em>configuration</em> file: jmx: enabled: true linkingMetadataMBean: true Copy Tip"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "APM agent security: Java",
        "Default security settings",
        "Caution",
        "High security mode settings",
        "Custom security settings"
      ],
      "title": "APM agent security: Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "fd9f5744c001453dbb9f129480f4e7e5ce42a176",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/apm-agent-security-java/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives, you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see Java agent error configuration. By default, here is how the New Relic Java agent handles the following potentially sensitive data:: Request parameters: The agent does not capture HTTP request parameters. HTTPS: The agent communicates with New Relic using HTTPS. SQL: The agent sets SQL recording to obfuscated, which removes the potentially sensitive numeric and string literal values. High security mode settings When you enable high security mode, the default settings are locked so that users cannot change them. In addition: The agent does not collect message queue parameters. You cannot create custom events. You cannot implement custom instrumentation using the Custom Instrumentation Editor. You cannot collect user attributes. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: Java agent configuration file Custom attributes Java agent API Setting Effects on data security audit_mode boolean Default: false By default, the Java agent does not log all data sent to New Relic in the agent log file. If you set this to true, the agent logs data sent to the New Relic collector in the agent log file. You can then evaluate the information that the agent sends by reviewing the agent log file to see if it includes sensitive information. high_security boolean Default: false To enable high security mode, set this to true and enable high security in New Relic. This restricts the information you can send to New Relic. proxy_host string Default: (none) Some proxies default to using HTTP, which is a less secure protocol. attributes.enabled boolean Default: true Default for the Custom Instrumentation Editor: false By default, you are sending attributes to New Relic, except for methods instrumented using the Custom Instrumentation Editor. If you do not want to send attributes to New Relic, set this to false. attributes.exclude string Default: (none) If there are specific attribute keys that you do not want to send to New Relic in transaction traces, identify them using attributes.exclude. This restricts the information sent to New Relic. Consider if you want to exclude these potentially sensitive attributes using attributes.exclude or if you need the information sent to New Relic: request.headers.*: Removes all request headers. (Note that HTTP headers that contain sensitive data such as cookie and authorization are never collected.) response.headers.*: Removes all response headers. request_uri: Removes the path for the transaction's incoming request. log_sql boolean Default: false By default, you are sending queries to New Relic using record_sql. If you want to log queries in the agent log file as well as send them to New Relic, set this to true. record_sql string Default: obfuscated By default, record_sql is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to off. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. strip_exception_messages boolean Default: false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. If you are not using high security mode but still want to strip messages from all exceptions except those in your allow list, set this to true. custom_insights_events.enabled boolean Default: true By default, the agent records events sent to the Event API via recordCustomEvent(). If you enable high security mode, this is automatically set to false.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.97745,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>agent</em> security: <em>Java</em>",
        "sections": "APM <em>agent</em> security: <em>Java</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": ". Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see <em>Java</em> <em>agent</em> error <em>configuration</em>. By default, here is how the New Relic <em>Java</em> <em>agent</em> handles the following potentially sensitive"
      },
      "id": "6043b8bb28ccbc3db92c60b7"
    }
  ],
  "/docs/agents/java-agent/configuration/hostname-logic-java": [
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.26523,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the instrumentation package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]instrumentation.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate <em>configuration</em> to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.73235,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "): Include the <em>Java</em> <em>agent</em>: Install <em>Java</em> <em>agent</em> version 6.1.0 or higher to monitor your application. Configure the <em>Java</em> <em>agent</em> to allow it to communicate with the JMX daemon by adding the following <em>configuration</em> to the newrelic.yml <em>configuration</em> file: jmx: enabled: true linkingMetadataMBean: true Copy Tip"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "APM agent security: Java",
        "Default security settings",
        "Caution",
        "High security mode settings",
        "Custom security settings"
      ],
      "title": "APM agent security: Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "fd9f5744c001453dbb9f129480f4e7e5ce42a176",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/apm-agent-security-java/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives, you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see Java agent error configuration. By default, here is how the New Relic Java agent handles the following potentially sensitive data:: Request parameters: The agent does not capture HTTP request parameters. HTTPS: The agent communicates with New Relic using HTTPS. SQL: The agent sets SQL recording to obfuscated, which removes the potentially sensitive numeric and string literal values. High security mode settings When you enable high security mode, the default settings are locked so that users cannot change them. In addition: The agent does not collect message queue parameters. You cannot create custom events. You cannot implement custom instrumentation using the Custom Instrumentation Editor. You cannot collect user attributes. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: Java agent configuration file Custom attributes Java agent API Setting Effects on data security audit_mode boolean Default: false By default, the Java agent does not log all data sent to New Relic in the agent log file. If you set this to true, the agent logs data sent to the New Relic collector in the agent log file. You can then evaluate the information that the agent sends by reviewing the agent log file to see if it includes sensitive information. high_security boolean Default: false To enable high security mode, set this to true and enable high security in New Relic. This restricts the information you can send to New Relic. proxy_host string Default: (none) Some proxies default to using HTTP, which is a less secure protocol. attributes.enabled boolean Default: true Default for the Custom Instrumentation Editor: false By default, you are sending attributes to New Relic, except for methods instrumented using the Custom Instrumentation Editor. If you do not want to send attributes to New Relic, set this to false. attributes.exclude string Default: (none) If there are specific attribute keys that you do not want to send to New Relic in transaction traces, identify them using attributes.exclude. This restricts the information sent to New Relic. Consider if you want to exclude these potentially sensitive attributes using attributes.exclude or if you need the information sent to New Relic: request.headers.*: Removes all request headers. (Note that HTTP headers that contain sensitive data such as cookie and authorization are never collected.) response.headers.*: Removes all response headers. request_uri: Removes the path for the transaction's incoming request. log_sql boolean Default: false By default, you are sending queries to New Relic using record_sql. If you want to log queries in the agent log file as well as send them to New Relic, set this to true. record_sql string Default: obfuscated By default, record_sql is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to off. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. strip_exception_messages boolean Default: false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. If you are not using high security mode but still want to strip messages from all exceptions except those in your allow list, set this to true. custom_insights_events.enabled boolean Default: true By default, the agent records events sent to the Event API via recordCustomEvent(). If you enable high security mode, this is automatically set to false.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.97739,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>agent</em> security: <em>Java</em>",
        "sections": "APM <em>agent</em> security: <em>Java</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": ". Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see <em>Java</em> <em>agent</em> error <em>configuration</em>. By default, here is how the New Relic <em>Java</em> <em>agent</em> handles the following potentially sensitive"
      },
      "id": "6043b8bb28ccbc3db92c60b7"
    }
  ],
  "/docs/agents/java-agent/configuration/java-agent-config-file-template": [
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.26523,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the instrumentation package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]instrumentation.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate <em>configuration</em> to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.73235,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "): Include the <em>Java</em> <em>agent</em>: Install <em>Java</em> <em>agent</em> version 6.1.0 or higher to monitor your application. Configure the <em>Java</em> <em>agent</em> to allow it to communicate with the JMX daemon by adding the following <em>configuration</em> to the newrelic.yml <em>configuration</em> file: jmx: enabled: true linkingMetadataMBean: true Copy Tip"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "APM agent security: Java",
        "Default security settings",
        "Caution",
        "High security mode settings",
        "Custom security settings"
      ],
      "title": "APM agent security: Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "fd9f5744c001453dbb9f129480f4e7e5ce42a176",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/apm-agent-security-java/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives, you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see Java agent error configuration. By default, here is how the New Relic Java agent handles the following potentially sensitive data:: Request parameters: The agent does not capture HTTP request parameters. HTTPS: The agent communicates with New Relic using HTTPS. SQL: The agent sets SQL recording to obfuscated, which removes the potentially sensitive numeric and string literal values. High security mode settings When you enable high security mode, the default settings are locked so that users cannot change them. In addition: The agent does not collect message queue parameters. You cannot create custom events. You cannot implement custom instrumentation using the Custom Instrumentation Editor. You cannot collect user attributes. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: Java agent configuration file Custom attributes Java agent API Setting Effects on data security audit_mode boolean Default: false By default, the Java agent does not log all data sent to New Relic in the agent log file. If you set this to true, the agent logs data sent to the New Relic collector in the agent log file. You can then evaluate the information that the agent sends by reviewing the agent log file to see if it includes sensitive information. high_security boolean Default: false To enable high security mode, set this to true and enable high security in New Relic. This restricts the information you can send to New Relic. proxy_host string Default: (none) Some proxies default to using HTTP, which is a less secure protocol. attributes.enabled boolean Default: true Default for the Custom Instrumentation Editor: false By default, you are sending attributes to New Relic, except for methods instrumented using the Custom Instrumentation Editor. If you do not want to send attributes to New Relic, set this to false. attributes.exclude string Default: (none) If there are specific attribute keys that you do not want to send to New Relic in transaction traces, identify them using attributes.exclude. This restricts the information sent to New Relic. Consider if you want to exclude these potentially sensitive attributes using attributes.exclude or if you need the information sent to New Relic: request.headers.*: Removes all request headers. (Note that HTTP headers that contain sensitive data such as cookie and authorization are never collected.) response.headers.*: Removes all response headers. request_uri: Removes the path for the transaction's incoming request. log_sql boolean Default: false By default, you are sending queries to New Relic using record_sql. If you want to log queries in the agent log file as well as send them to New Relic, set this to true. record_sql string Default: obfuscated By default, record_sql is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to off. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. strip_exception_messages boolean Default: false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. If you are not using high security mode but still want to strip messages from all exceptions except those in your allow list, set this to true. custom_insights_events.enabled boolean Default: true By default, the agent records events sent to the Event API via recordCustomEvent(). If you enable high security mode, this is automatically set to false.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.97739,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>agent</em> security: <em>Java</em>",
        "sections": "APM <em>agent</em> security: <em>Java</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": ". Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see <em>Java</em> <em>agent</em> error <em>configuration</em>. By default, here is how the New Relic <em>Java</em> <em>agent</em> handles the following potentially sensitive"
      },
      "id": "6043b8bb28ccbc3db92c60b7"
    }
  ],
  "/docs/agents/java-agent/configuration/java-agent-configuration-config-file": [
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.26517,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the instrumentation package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]instrumentation.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate <em>configuration</em> to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.73227,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "): Include the <em>Java</em> <em>agent</em>: Install <em>Java</em> <em>agent</em> version 6.1.0 or higher to monitor your application. Configure the <em>Java</em> <em>agent</em> to allow it to communicate with the JMX daemon by adding the following <em>configuration</em> to the newrelic.yml <em>configuration</em> file: jmx: enabled: true linkingMetadataMBean: true Copy Tip"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "APM agent security: Java",
        "Default security settings",
        "Caution",
        "High security mode settings",
        "Custom security settings"
      ],
      "title": "APM agent security: Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "fd9f5744c001453dbb9f129480f4e7e5ce42a176",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/apm-agent-security-java/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives, you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see Java agent error configuration. By default, here is how the New Relic Java agent handles the following potentially sensitive data:: Request parameters: The agent does not capture HTTP request parameters. HTTPS: The agent communicates with New Relic using HTTPS. SQL: The agent sets SQL recording to obfuscated, which removes the potentially sensitive numeric and string literal values. High security mode settings When you enable high security mode, the default settings are locked so that users cannot change them. In addition: The agent does not collect message queue parameters. You cannot create custom events. You cannot implement custom instrumentation using the Custom Instrumentation Editor. You cannot collect user attributes. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: Java agent configuration file Custom attributes Java agent API Setting Effects on data security audit_mode boolean Default: false By default, the Java agent does not log all data sent to New Relic in the agent log file. If you set this to true, the agent logs data sent to the New Relic collector in the agent log file. You can then evaluate the information that the agent sends by reviewing the agent log file to see if it includes sensitive information. high_security boolean Default: false To enable high security mode, set this to true and enable high security in New Relic. This restricts the information you can send to New Relic. proxy_host string Default: (none) Some proxies default to using HTTP, which is a less secure protocol. attributes.enabled boolean Default: true Default for the Custom Instrumentation Editor: false By default, you are sending attributes to New Relic, except for methods instrumented using the Custom Instrumentation Editor. If you do not want to send attributes to New Relic, set this to false. attributes.exclude string Default: (none) If there are specific attribute keys that you do not want to send to New Relic in transaction traces, identify them using attributes.exclude. This restricts the information sent to New Relic. Consider if you want to exclude these potentially sensitive attributes using attributes.exclude or if you need the information sent to New Relic: request.headers.*: Removes all request headers. (Note that HTTP headers that contain sensitive data such as cookie and authorization are never collected.) response.headers.*: Removes all response headers. request_uri: Removes the path for the transaction's incoming request. log_sql boolean Default: false By default, you are sending queries to New Relic using record_sql. If you want to log queries in the agent log file as well as send them to New Relic, set this to true. record_sql string Default: obfuscated By default, record_sql is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to off. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. strip_exception_messages boolean Default: false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. If you are not using high security mode but still want to strip messages from all exceptions except those in your allow list, set this to true. custom_insights_events.enabled boolean Default: true By default, the agent records events sent to the Event API via recordCustomEvent(). If you enable high security mode, this is automatically set to false.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.977325,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>agent</em> security: <em>Java</em>",
        "sections": "APM <em>agent</em> security: <em>Java</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": ". Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see <em>Java</em> <em>agent</em> error <em>configuration</em>. By default, here is how the New Relic <em>Java</em> <em>agent</em> handles the following potentially sensitive"
      },
      "id": "6043b8bb28ccbc3db92c60b7"
    }
  ],
  "/docs/agents/java-agent/configuration/java-agent-error-configuration": [
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.26517,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the instrumentation package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]instrumentation.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate <em>configuration</em> to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.73227,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "): Include the <em>Java</em> <em>agent</em>: Install <em>Java</em> <em>agent</em> version 6.1.0 or higher to monitor your application. Configure the <em>Java</em> <em>agent</em> to allow it to communicate with the JMX daemon by adding the following <em>configuration</em> to the newrelic.yml <em>configuration</em> file: jmx: enabled: true linkingMetadataMBean: true Copy Tip"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "APM agent security: Java",
        "Default security settings",
        "Caution",
        "High security mode settings",
        "Custom security settings"
      ],
      "title": "APM agent security: Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "fd9f5744c001453dbb9f129480f4e7e5ce42a176",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/apm-agent-security-java/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives, you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see Java agent error configuration. By default, here is how the New Relic Java agent handles the following potentially sensitive data:: Request parameters: The agent does not capture HTTP request parameters. HTTPS: The agent communicates with New Relic using HTTPS. SQL: The agent sets SQL recording to obfuscated, which removes the potentially sensitive numeric and string literal values. High security mode settings When you enable high security mode, the default settings are locked so that users cannot change them. In addition: The agent does not collect message queue parameters. You cannot create custom events. You cannot implement custom instrumentation using the Custom Instrumentation Editor. You cannot collect user attributes. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: Java agent configuration file Custom attributes Java agent API Setting Effects on data security audit_mode boolean Default: false By default, the Java agent does not log all data sent to New Relic in the agent log file. If you set this to true, the agent logs data sent to the New Relic collector in the agent log file. You can then evaluate the information that the agent sends by reviewing the agent log file to see if it includes sensitive information. high_security boolean Default: false To enable high security mode, set this to true and enable high security in New Relic. This restricts the information you can send to New Relic. proxy_host string Default: (none) Some proxies default to using HTTP, which is a less secure protocol. attributes.enabled boolean Default: true Default for the Custom Instrumentation Editor: false By default, you are sending attributes to New Relic, except for methods instrumented using the Custom Instrumentation Editor. If you do not want to send attributes to New Relic, set this to false. attributes.exclude string Default: (none) If there are specific attribute keys that you do not want to send to New Relic in transaction traces, identify them using attributes.exclude. This restricts the information sent to New Relic. Consider if you want to exclude these potentially sensitive attributes using attributes.exclude or if you need the information sent to New Relic: request.headers.*: Removes all request headers. (Note that HTTP headers that contain sensitive data such as cookie and authorization are never collected.) response.headers.*: Removes all response headers. request_uri: Removes the path for the transaction's incoming request. log_sql boolean Default: false By default, you are sending queries to New Relic using record_sql. If you want to log queries in the agent log file as well as send them to New Relic, set this to true. record_sql string Default: obfuscated By default, record_sql is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to off. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. strip_exception_messages boolean Default: false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. If you are not using high security mode but still want to strip messages from all exceptions except those in your allow list, set this to true. custom_insights_events.enabled boolean Default: true By default, the agent records events sent to the Event API via recordCustomEvent(). If you enable high security mode, this is automatically set to false.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.977325,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>agent</em> security: <em>Java</em>",
        "sections": "APM <em>agent</em> security: <em>Java</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": ". Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see <em>Java</em> <em>agent</em> error <em>configuration</em>. By default, here is how the New Relic <em>Java</em> <em>agent</em> handles the following potentially sensitive"
      },
      "id": "6043b8bb28ccbc3db92c60b7"
    }
  ],
  "/docs/agents/java-agent/configuration/name-your-java-application": [
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.2651,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the instrumentation package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]instrumentation.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate <em>configuration</em> to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 132.73221,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "): Include the <em>Java</em> <em>agent</em>: Install <em>Java</em> <em>agent</em> version 6.1.0 or higher to monitor your application. Configure the <em>Java</em> <em>agent</em> to allow it to communicate with the JMX daemon by adding the following <em>configuration</em> to the newrelic.yml <em>configuration</em> file: jmx: enabled: true linkingMetadataMBean: true Copy Tip"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "APM agent security: Java",
        "Default security settings",
        "Caution",
        "High security mode settings",
        "Custom security settings"
      ],
      "title": "APM agent security: Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "fd9f5744c001453dbb9f129480f4e7e5ce42a176",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/apm-agent-security-java/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives, you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see Java agent error configuration. By default, here is how the New Relic Java agent handles the following potentially sensitive data:: Request parameters: The agent does not capture HTTP request parameters. HTTPS: The agent communicates with New Relic using HTTPS. SQL: The agent sets SQL recording to obfuscated, which removes the potentially sensitive numeric and string literal values. High security mode settings When you enable high security mode, the default settings are locked so that users cannot change them. In addition: The agent does not collect message queue parameters. You cannot create custom events. You cannot implement custom instrumentation using the Custom Instrumentation Editor. You cannot collect user attributes. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: Java agent configuration file Custom attributes Java agent API Setting Effects on data security audit_mode boolean Default: false By default, the Java agent does not log all data sent to New Relic in the agent log file. If you set this to true, the agent logs data sent to the New Relic collector in the agent log file. You can then evaluate the information that the agent sends by reviewing the agent log file to see if it includes sensitive information. high_security boolean Default: false To enable high security mode, set this to true and enable high security in New Relic. This restricts the information you can send to New Relic. proxy_host string Default: (none) Some proxies default to using HTTP, which is a less secure protocol. attributes.enabled boolean Default: true Default for the Custom Instrumentation Editor: false By default, you are sending attributes to New Relic, except for methods instrumented using the Custom Instrumentation Editor. If you do not want to send attributes to New Relic, set this to false. attributes.exclude string Default: (none) If there are specific attribute keys that you do not want to send to New Relic in transaction traces, identify them using attributes.exclude. This restricts the information sent to New Relic. Consider if you want to exclude these potentially sensitive attributes using attributes.exclude or if you need the information sent to New Relic: request.headers.*: Removes all request headers. (Note that HTTP headers that contain sensitive data such as cookie and authorization are never collected.) response.headers.*: Removes all response headers. request_uri: Removes the path for the transaction's incoming request. log_sql boolean Default: false By default, you are sending queries to New Relic using record_sql. If you want to log queries in the agent log file as well as send them to New Relic, set this to true. record_sql string Default: obfuscated By default, record_sql is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to off. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. strip_exception_messages boolean Default: false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. If you are not using high security mode but still want to strip messages from all exceptions except those in your allow list, set this to true. custom_insights_events.enabled boolean Default: true By default, the agent records events sent to the Event API via recordCustomEvent(). If you enable high security mode, this is automatically set to false.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 120.977264,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>agent</em> security: <em>Java</em>",
        "sections": "APM <em>agent</em> security: <em>Java</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": ". Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see <em>Java</em> <em>agent</em> error <em>configuration</em>. By default, here is how the New Relic <em>Java</em> <em>agent</em> handles the following potentially sensitive"
      },
      "id": "6043b8bb28ccbc3db92c60b7"
    }
  ],
  "/docs/agents/java-agent/custom-instrumentation/circuit-breaker-java-custom-instrumentation": [
    {
      "sections": [
        "APM agent security: Java",
        "Default security settings",
        "Caution",
        "High security mode settings",
        "Custom security settings"
      ],
      "title": "APM agent security: Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "fd9f5744c001453dbb9f129480f4e7e5ce42a176",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/apm-agent-security-java/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives, you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see Java agent error configuration. By default, here is how the New Relic Java agent handles the following potentially sensitive data:: Request parameters: The agent does not capture HTTP request parameters. HTTPS: The agent communicates with New Relic using HTTPS. SQL: The agent sets SQL recording to obfuscated, which removes the potentially sensitive numeric and string literal values. High security mode settings When you enable high security mode, the default settings are locked so that users cannot change them. In addition: The agent does not collect message queue parameters. You cannot create custom events. You cannot implement custom instrumentation using the Custom Instrumentation Editor. You cannot collect user attributes. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: Java agent configuration file Custom attributes Java agent API Setting Effects on data security audit_mode boolean Default: false By default, the Java agent does not log all data sent to New Relic in the agent log file. If you set this to true, the agent logs data sent to the New Relic collector in the agent log file. You can then evaluate the information that the agent sends by reviewing the agent log file to see if it includes sensitive information. high_security boolean Default: false To enable high security mode, set this to true and enable high security in New Relic. This restricts the information you can send to New Relic. proxy_host string Default: (none) Some proxies default to using HTTP, which is a less secure protocol. attributes.enabled boolean Default: true Default for the Custom Instrumentation Editor: false By default, you are sending attributes to New Relic, except for methods instrumented using the Custom Instrumentation Editor. If you do not want to send attributes to New Relic, set this to false. attributes.exclude string Default: (none) If there are specific attribute keys that you do not want to send to New Relic in transaction traces, identify them using attributes.exclude. This restricts the information sent to New Relic. Consider if you want to exclude these potentially sensitive attributes using attributes.exclude or if you need the information sent to New Relic: request.headers.*: Removes all request headers. (Note that HTTP headers that contain sensitive data such as cookie and authorization are never collected.) response.headers.*: Removes all response headers. request_uri: Removes the path for the transaction's incoming request. log_sql boolean Default: false By default, you are sending queries to New Relic using record_sql. If you want to log queries in the agent log file as well as send them to New Relic, set this to true. record_sql string Default: obfuscated By default, record_sql is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to off. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. strip_exception_messages boolean Default: false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. If you are not using high security mode but still want to strip messages from all exceptions except those in your allow list, set this to true. custom_insights_events.enabled boolean Default: true By default, the agent records events sent to the Event API via recordCustomEvent(). If you enable high security mode, this is automatically set to false.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.18863,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>agent</em> security: <em>Java</em>",
        "sections": "APM <em>agent</em> security: <em>Java</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " enable high security mode, the default settings are locked so that users cannot change them. In addition: The <em>agent</em> does not collect message queue parameters. You cannot create <em>custom</em> events. You cannot implement <em>custom</em> <em>instrumentation</em> using the <em>Custom</em> <em>Instrumentation</em> Editor. You cannot collect user"
      },
      "id": "6043b8bb28ccbc3db92c60b7"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 158.12048,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> API lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This API consists of: Static methods on the com.newrelic.api.<em>agent</em>.NewRelic class A @Trace annotation for implementing <em>custom</em> <em>instrumentation</em> A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.441345,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "New Relic&#x27;s <em>Java</em> <em>agent</em> includes built-in <em>instrumentation</em> of the most popular parts of the <em>Java</em> ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the <em>agent</em> with <em>Java</em> <em>custom</em>"
      },
      "id": "6043b8f6196a6771a9960f87"
    }
  ],
  "/docs/agents/java-agent/custom-instrumentation/custom-instrumentation-editor-instrument-ui": [
    {
      "sections": [
        "APM agent security: Java",
        "Default security settings",
        "Caution",
        "High security mode settings",
        "Custom security settings"
      ],
      "title": "APM agent security: Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "fd9f5744c001453dbb9f129480f4e7e5ce42a176",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/apm-agent-security-java/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives, you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see Java agent error configuration. By default, here is how the New Relic Java agent handles the following potentially sensitive data:: Request parameters: The agent does not capture HTTP request parameters. HTTPS: The agent communicates with New Relic using HTTPS. SQL: The agent sets SQL recording to obfuscated, which removes the potentially sensitive numeric and string literal values. High security mode settings When you enable high security mode, the default settings are locked so that users cannot change them. In addition: The agent does not collect message queue parameters. You cannot create custom events. You cannot implement custom instrumentation using the Custom Instrumentation Editor. You cannot collect user attributes. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: Java agent configuration file Custom attributes Java agent API Setting Effects on data security audit_mode boolean Default: false By default, the Java agent does not log all data sent to New Relic in the agent log file. If you set this to true, the agent logs data sent to the New Relic collector in the agent log file. You can then evaluate the information that the agent sends by reviewing the agent log file to see if it includes sensitive information. high_security boolean Default: false To enable high security mode, set this to true and enable high security in New Relic. This restricts the information you can send to New Relic. proxy_host string Default: (none) Some proxies default to using HTTP, which is a less secure protocol. attributes.enabled boolean Default: true Default for the Custom Instrumentation Editor: false By default, you are sending attributes to New Relic, except for methods instrumented using the Custom Instrumentation Editor. If you do not want to send attributes to New Relic, set this to false. attributes.exclude string Default: (none) If there are specific attribute keys that you do not want to send to New Relic in transaction traces, identify them using attributes.exclude. This restricts the information sent to New Relic. Consider if you want to exclude these potentially sensitive attributes using attributes.exclude or if you need the information sent to New Relic: request.headers.*: Removes all request headers. (Note that HTTP headers that contain sensitive data such as cookie and authorization are never collected.) response.headers.*: Removes all response headers. request_uri: Removes the path for the transaction's incoming request. log_sql boolean Default: false By default, you are sending queries to New Relic using record_sql. If you want to log queries in the agent log file as well as send them to New Relic, set this to true. record_sql string Default: obfuscated By default, record_sql is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to off. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. strip_exception_messages boolean Default: false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. If you are not using high security mode but still want to strip messages from all exceptions except those in your allow list, set this to true. custom_insights_events.enabled boolean Default: true By default, the agent records events sent to the Event API via recordCustomEvent(). If you enable high security mode, this is automatically set to false.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.18863,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>agent</em> security: <em>Java</em>",
        "sections": "APM <em>agent</em> security: <em>Java</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " enable high security mode, the default settings are locked so that users cannot change them. In addition: The <em>agent</em> does not collect message queue parameters. You cannot create <em>custom</em> events. You cannot implement <em>custom</em> <em>instrumentation</em> using the <em>Custom</em> <em>Instrumentation</em> Editor. You cannot collect user"
      },
      "id": "6043b8bb28ccbc3db92c60b7"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 158.12048,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> API lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This API consists of: Static methods on the com.newrelic.api.<em>agent</em>.NewRelic class A @Trace annotation for implementing <em>custom</em> <em>instrumentation</em> A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.441345,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "New Relic&#x27;s <em>Java</em> <em>agent</em> includes built-in <em>instrumentation</em> of the most popular parts of the <em>Java</em> ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the <em>agent</em> with <em>Java</em> <em>custom</em>"
      },
      "id": "6043b8f6196a6771a9960f87"
    }
  ],
  "/docs/agents/java-agent/custom-instrumentation/custom-jmx-yaml-examples": [
    {
      "sections": [
        "APM agent security: Java",
        "Default security settings",
        "Caution",
        "High security mode settings",
        "Custom security settings"
      ],
      "title": "APM agent security: Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "fd9f5744c001453dbb9f129480f4e7e5ce42a176",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/apm-agent-security-java/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives, you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see Java agent error configuration. By default, here is how the New Relic Java agent handles the following potentially sensitive data:: Request parameters: The agent does not capture HTTP request parameters. HTTPS: The agent communicates with New Relic using HTTPS. SQL: The agent sets SQL recording to obfuscated, which removes the potentially sensitive numeric and string literal values. High security mode settings When you enable high security mode, the default settings are locked so that users cannot change them. In addition: The agent does not collect message queue parameters. You cannot create custom events. You cannot implement custom instrumentation using the Custom Instrumentation Editor. You cannot collect user attributes. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: Java agent configuration file Custom attributes Java agent API Setting Effects on data security audit_mode boolean Default: false By default, the Java agent does not log all data sent to New Relic in the agent log file. If you set this to true, the agent logs data sent to the New Relic collector in the agent log file. You can then evaluate the information that the agent sends by reviewing the agent log file to see if it includes sensitive information. high_security boolean Default: false To enable high security mode, set this to true and enable high security in New Relic. This restricts the information you can send to New Relic. proxy_host string Default: (none) Some proxies default to using HTTP, which is a less secure protocol. attributes.enabled boolean Default: true Default for the Custom Instrumentation Editor: false By default, you are sending attributes to New Relic, except for methods instrumented using the Custom Instrumentation Editor. If you do not want to send attributes to New Relic, set this to false. attributes.exclude string Default: (none) If there are specific attribute keys that you do not want to send to New Relic in transaction traces, identify them using attributes.exclude. This restricts the information sent to New Relic. Consider if you want to exclude these potentially sensitive attributes using attributes.exclude or if you need the information sent to New Relic: request.headers.*: Removes all request headers. (Note that HTTP headers that contain sensitive data such as cookie and authorization are never collected.) response.headers.*: Removes all response headers. request_uri: Removes the path for the transaction's incoming request. log_sql boolean Default: false By default, you are sending queries to New Relic using record_sql. If you want to log queries in the agent log file as well as send them to New Relic, set this to true. record_sql string Default: obfuscated By default, record_sql is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to off. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. strip_exception_messages boolean Default: false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. If you are not using high security mode but still want to strip messages from all exceptions except those in your allow list, set this to true. custom_insights_events.enabled boolean Default: true By default, the agent records events sent to the Event API via recordCustomEvent(). If you enable high security mode, this is automatically set to false.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.18855,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>agent</em> security: <em>Java</em>",
        "sections": "APM <em>agent</em> security: <em>Java</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " enable high security mode, the default settings are locked so that users cannot change them. In addition: The <em>agent</em> does not collect message queue parameters. You cannot create <em>custom</em> events. You cannot implement <em>custom</em> <em>instrumentation</em> using the <em>Custom</em> <em>Instrumentation</em> Editor. You cannot collect user"
      },
      "id": "6043b8bb28ccbc3db92c60b7"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 158.12039,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> API lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This API consists of: Static methods on the com.newrelic.api.<em>agent</em>.NewRelic class A @Trace annotation for implementing <em>custom</em> <em>instrumentation</em> A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.441284,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "New Relic&#x27;s <em>Java</em> <em>agent</em> includes built-in <em>instrumentation</em> of the most popular parts of the <em>Java</em> ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the <em>agent</em> with <em>Java</em> <em>custom</em>"
      },
      "id": "6043b8f6196a6771a9960f87"
    }
  ],
  "/docs/agents/java-agent/custom-instrumentation/java-agent-custom-jmx-instrumentation-yaml": [
    {
      "sections": [
        "APM agent security: Java",
        "Default security settings",
        "Caution",
        "High security mode settings",
        "Custom security settings"
      ],
      "title": "APM agent security: Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "fd9f5744c001453dbb9f129480f4e7e5ce42a176",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/apm-agent-security-java/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives, you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see Java agent error configuration. By default, here is how the New Relic Java agent handles the following potentially sensitive data:: Request parameters: The agent does not capture HTTP request parameters. HTTPS: The agent communicates with New Relic using HTTPS. SQL: The agent sets SQL recording to obfuscated, which removes the potentially sensitive numeric and string literal values. High security mode settings When you enable high security mode, the default settings are locked so that users cannot change them. In addition: The agent does not collect message queue parameters. You cannot create custom events. You cannot implement custom instrumentation using the Custom Instrumentation Editor. You cannot collect user attributes. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: Java agent configuration file Custom attributes Java agent API Setting Effects on data security audit_mode boolean Default: false By default, the Java agent does not log all data sent to New Relic in the agent log file. If you set this to true, the agent logs data sent to the New Relic collector in the agent log file. You can then evaluate the information that the agent sends by reviewing the agent log file to see if it includes sensitive information. high_security boolean Default: false To enable high security mode, set this to true and enable high security in New Relic. This restricts the information you can send to New Relic. proxy_host string Default: (none) Some proxies default to using HTTP, which is a less secure protocol. attributes.enabled boolean Default: true Default for the Custom Instrumentation Editor: false By default, you are sending attributes to New Relic, except for methods instrumented using the Custom Instrumentation Editor. If you do not want to send attributes to New Relic, set this to false. attributes.exclude string Default: (none) If there are specific attribute keys that you do not want to send to New Relic in transaction traces, identify them using attributes.exclude. This restricts the information sent to New Relic. Consider if you want to exclude these potentially sensitive attributes using attributes.exclude or if you need the information sent to New Relic: request.headers.*: Removes all request headers. (Note that HTTP headers that contain sensitive data such as cookie and authorization are never collected.) response.headers.*: Removes all response headers. request_uri: Removes the path for the transaction's incoming request. log_sql boolean Default: false By default, you are sending queries to New Relic using record_sql. If you want to log queries in the agent log file as well as send them to New Relic, set this to true. record_sql string Default: obfuscated By default, record_sql is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to off. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. strip_exception_messages boolean Default: false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. If you are not using high security mode but still want to strip messages from all exceptions except those in your allow list, set this to true. custom_insights_events.enabled boolean Default: true By default, the agent records events sent to the Event API via recordCustomEvent(). If you enable high security mode, this is automatically set to false.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.18855,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>agent</em> security: <em>Java</em>",
        "sections": "APM <em>agent</em> security: <em>Java</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " enable high security mode, the default settings are locked so that users cannot change them. In addition: The <em>agent</em> does not collect message queue parameters. You cannot create <em>custom</em> events. You cannot implement <em>custom</em> <em>instrumentation</em> using the <em>Custom</em> <em>Instrumentation</em> Editor. You cannot collect user"
      },
      "id": "6043b8bb28ccbc3db92c60b7"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 158.12039,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> API lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This API consists of: Static methods on the com.newrelic.api.<em>agent</em>.NewRelic class A @Trace annotation for implementing <em>custom</em> <em>instrumentation</em> A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.441284,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "New Relic&#x27;s <em>Java</em> <em>agent</em> includes built-in <em>instrumentation</em> of the most popular parts of the <em>Java</em> ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the <em>agent</em> with <em>Java</em> <em>custom</em>"
      },
      "id": "6043b8f6196a6771a9960f87"
    }
  ],
  "/docs/agents/java-agent/custom-instrumentation/java-custom-instrumentation": [
    {
      "sections": [
        "APM agent security: Java",
        "Default security settings",
        "Caution",
        "High security mode settings",
        "Custom security settings"
      ],
      "title": "APM agent security: Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "fd9f5744c001453dbb9f129480f4e7e5ce42a176",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/apm-agent-security-java/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives, you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see Java agent error configuration. By default, here is how the New Relic Java agent handles the following potentially sensitive data:: Request parameters: The agent does not capture HTTP request parameters. HTTPS: The agent communicates with New Relic using HTTPS. SQL: The agent sets SQL recording to obfuscated, which removes the potentially sensitive numeric and string literal values. High security mode settings When you enable high security mode, the default settings are locked so that users cannot change them. In addition: The agent does not collect message queue parameters. You cannot create custom events. You cannot implement custom instrumentation using the Custom Instrumentation Editor. You cannot collect user attributes. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: Java agent configuration file Custom attributes Java agent API Setting Effects on data security audit_mode boolean Default: false By default, the Java agent does not log all data sent to New Relic in the agent log file. If you set this to true, the agent logs data sent to the New Relic collector in the agent log file. You can then evaluate the information that the agent sends by reviewing the agent log file to see if it includes sensitive information. high_security boolean Default: false To enable high security mode, set this to true and enable high security in New Relic. This restricts the information you can send to New Relic. proxy_host string Default: (none) Some proxies default to using HTTP, which is a less secure protocol. attributes.enabled boolean Default: true Default for the Custom Instrumentation Editor: false By default, you are sending attributes to New Relic, except for methods instrumented using the Custom Instrumentation Editor. If you do not want to send attributes to New Relic, set this to false. attributes.exclude string Default: (none) If there are specific attribute keys that you do not want to send to New Relic in transaction traces, identify them using attributes.exclude. This restricts the information sent to New Relic. Consider if you want to exclude these potentially sensitive attributes using attributes.exclude or if you need the information sent to New Relic: request.headers.*: Removes all request headers. (Note that HTTP headers that contain sensitive data such as cookie and authorization are never collected.) response.headers.*: Removes all response headers. request_uri: Removes the path for the transaction's incoming request. log_sql boolean Default: false By default, you are sending queries to New Relic using record_sql. If you want to log queries in the agent log file as well as send them to New Relic, set this to true. record_sql string Default: obfuscated By default, record_sql is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to off. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. strip_exception_messages boolean Default: false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. If you are not using high security mode but still want to strip messages from all exceptions except those in your allow list, set this to true. custom_insights_events.enabled boolean Default: true By default, the agent records events sent to the Event API via recordCustomEvent(). If you enable high security mode, this is automatically set to false.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.18848,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>agent</em> security: <em>Java</em>",
        "sections": "APM <em>agent</em> security: <em>Java</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " enable high security mode, the default settings are locked so that users cannot change them. In addition: The <em>agent</em> does not collect message queue parameters. You cannot create <em>custom</em> events. You cannot implement <em>custom</em> <em>instrumentation</em> using the <em>Custom</em> <em>Instrumentation</em> Editor. You cannot collect user"
      },
      "id": "6043b8bb28ccbc3db92c60b7"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 158.12033,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> API lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This API consists of: Static methods on the com.newrelic.api.<em>agent</em>.NewRelic class A @Trace annotation for implementing <em>custom</em> <em>instrumentation</em> A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.44122,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "New Relic&#x27;s <em>Java</em> <em>agent</em> includes built-in <em>instrumentation</em> of the most popular parts of the <em>Java</em> ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the <em>agent</em> with <em>Java</em> <em>custom</em>"
      },
      "id": "6043b8f6196a6771a9960f87"
    }
  ],
  "/docs/agents/java-agent/custom-instrumentation/java-instrumentation-xml": [
    {
      "sections": [
        "APM agent security: Java",
        "Default security settings",
        "Caution",
        "High security mode settings",
        "Custom security settings"
      ],
      "title": "APM agent security: Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "fd9f5744c001453dbb9f129480f4e7e5ce42a176",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/apm-agent-security-java/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives, you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see Java agent error configuration. By default, here is how the New Relic Java agent handles the following potentially sensitive data:: Request parameters: The agent does not capture HTTP request parameters. HTTPS: The agent communicates with New Relic using HTTPS. SQL: The agent sets SQL recording to obfuscated, which removes the potentially sensitive numeric and string literal values. High security mode settings When you enable high security mode, the default settings are locked so that users cannot change them. In addition: The agent does not collect message queue parameters. You cannot create custom events. You cannot implement custom instrumentation using the Custom Instrumentation Editor. You cannot collect user attributes. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: Java agent configuration file Custom attributes Java agent API Setting Effects on data security audit_mode boolean Default: false By default, the Java agent does not log all data sent to New Relic in the agent log file. If you set this to true, the agent logs data sent to the New Relic collector in the agent log file. You can then evaluate the information that the agent sends by reviewing the agent log file to see if it includes sensitive information. high_security boolean Default: false To enable high security mode, set this to true and enable high security in New Relic. This restricts the information you can send to New Relic. proxy_host string Default: (none) Some proxies default to using HTTP, which is a less secure protocol. attributes.enabled boolean Default: true Default for the Custom Instrumentation Editor: false By default, you are sending attributes to New Relic, except for methods instrumented using the Custom Instrumentation Editor. If you do not want to send attributes to New Relic, set this to false. attributes.exclude string Default: (none) If there are specific attribute keys that you do not want to send to New Relic in transaction traces, identify them using attributes.exclude. This restricts the information sent to New Relic. Consider if you want to exclude these potentially sensitive attributes using attributes.exclude or if you need the information sent to New Relic: request.headers.*: Removes all request headers. (Note that HTTP headers that contain sensitive data such as cookie and authorization are never collected.) response.headers.*: Removes all response headers. request_uri: Removes the path for the transaction's incoming request. log_sql boolean Default: false By default, you are sending queries to New Relic using record_sql. If you want to log queries in the agent log file as well as send them to New Relic, set this to true. record_sql string Default: obfuscated By default, record_sql is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to off. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. strip_exception_messages boolean Default: false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. If you are not using high security mode but still want to strip messages from all exceptions except those in your allow list, set this to true. custom_insights_events.enabled boolean Default: true By default, the agent records events sent to the Event API via recordCustomEvent(). If you enable high security mode, this is automatically set to false.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.18848,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>agent</em> security: <em>Java</em>",
        "sections": "APM <em>agent</em> security: <em>Java</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " enable high security mode, the default settings are locked so that users cannot change them. In addition: The <em>agent</em> does not collect message queue parameters. You cannot create <em>custom</em> events. You cannot implement <em>custom</em> <em>instrumentation</em> using the <em>Custom</em> <em>Instrumentation</em> Editor. You cannot collect user"
      },
      "id": "6043b8bb28ccbc3db92c60b7"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 158.12033,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> API lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This API consists of: Static methods on the com.newrelic.api.<em>agent</em>.NewRelic class A @Trace annotation for implementing <em>custom</em> <em>instrumentation</em> A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.44122,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "New Relic&#x27;s <em>Java</em> <em>agent</em> includes built-in <em>instrumentation</em> of the most popular parts of the <em>Java</em> ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the <em>agent</em> with <em>Java</em> <em>custom</em>"
      },
      "id": "6043b8f6196a6771a9960f87"
    }
  ],
  "/docs/agents/java-agent/custom-instrumentation/java-xml-instrumentation-examples": [
    {
      "sections": [
        "APM agent security: Java",
        "Default security settings",
        "Caution",
        "High security mode settings",
        "Custom security settings"
      ],
      "title": "APM agent security: Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "fd9f5744c001453dbb9f129480f4e7e5ce42a176",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/apm-agent-security-java/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives, you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see Java agent error configuration. By default, here is how the New Relic Java agent handles the following potentially sensitive data:: Request parameters: The agent does not capture HTTP request parameters. HTTPS: The agent communicates with New Relic using HTTPS. SQL: The agent sets SQL recording to obfuscated, which removes the potentially sensitive numeric and string literal values. High security mode settings When you enable high security mode, the default settings are locked so that users cannot change them. In addition: The agent does not collect message queue parameters. You cannot create custom events. You cannot implement custom instrumentation using the Custom Instrumentation Editor. You cannot collect user attributes. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: Java agent configuration file Custom attributes Java agent API Setting Effects on data security audit_mode boolean Default: false By default, the Java agent does not log all data sent to New Relic in the agent log file. If you set this to true, the agent logs data sent to the New Relic collector in the agent log file. You can then evaluate the information that the agent sends by reviewing the agent log file to see if it includes sensitive information. high_security boolean Default: false To enable high security mode, set this to true and enable high security in New Relic. This restricts the information you can send to New Relic. proxy_host string Default: (none) Some proxies default to using HTTP, which is a less secure protocol. attributes.enabled boolean Default: true Default for the Custom Instrumentation Editor: false By default, you are sending attributes to New Relic, except for methods instrumented using the Custom Instrumentation Editor. If you do not want to send attributes to New Relic, set this to false. attributes.exclude string Default: (none) If there are specific attribute keys that you do not want to send to New Relic in transaction traces, identify them using attributes.exclude. This restricts the information sent to New Relic. Consider if you want to exclude these potentially sensitive attributes using attributes.exclude or if you need the information sent to New Relic: request.headers.*: Removes all request headers. (Note that HTTP headers that contain sensitive data such as cookie and authorization are never collected.) response.headers.*: Removes all response headers. request_uri: Removes the path for the transaction's incoming request. log_sql boolean Default: false By default, you are sending queries to New Relic using record_sql. If you want to log queries in the agent log file as well as send them to New Relic, set this to true. record_sql string Default: obfuscated By default, record_sql is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to off. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. strip_exception_messages boolean Default: false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. If you are not using high security mode but still want to strip messages from all exceptions except those in your allow list, set this to true. custom_insights_events.enabled boolean Default: true By default, the agent records events sent to the Event API via recordCustomEvent(). If you enable high security mode, this is automatically set to false.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.1884,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>agent</em> security: <em>Java</em>",
        "sections": "APM <em>agent</em> security: <em>Java</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " enable high security mode, the default settings are locked so that users cannot change them. In addition: The <em>agent</em> does not collect message queue parameters. You cannot create <em>custom</em> events. You cannot implement <em>custom</em> <em>instrumentation</em> using the <em>Custom</em> <em>Instrumentation</em> Editor. You cannot collect user"
      },
      "id": "6043b8bb28ccbc3db92c60b7"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 158.12025,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> API lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This API consists of: Static methods on the com.newrelic.api.<em>agent</em>.NewRelic class A @Trace annotation for implementing <em>custom</em> <em>instrumentation</em> A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.44116,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "New Relic&#x27;s <em>Java</em> <em>agent</em> includes built-in <em>instrumentation</em> of the most popular parts of the <em>Java</em> ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the <em>agent</em> with <em>Java</em> <em>custom</em>"
      },
      "id": "6043b8f6196a6771a9960f87"
    }
  ],
  "/docs/agents/java-agent/custom-instrumentation/messaging-framework-instrumentation": [
    {
      "sections": [
        "APM agent security: Java",
        "Default security settings",
        "Caution",
        "High security mode settings",
        "Custom security settings"
      ],
      "title": "APM agent security: Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "fd9f5744c001453dbb9f129480f4e7e5ce42a176",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/apm-agent-security-java/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives, you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see Java agent error configuration. By default, here is how the New Relic Java agent handles the following potentially sensitive data:: Request parameters: The agent does not capture HTTP request parameters. HTTPS: The agent communicates with New Relic using HTTPS. SQL: The agent sets SQL recording to obfuscated, which removes the potentially sensitive numeric and string literal values. High security mode settings When you enable high security mode, the default settings are locked so that users cannot change them. In addition: The agent does not collect message queue parameters. You cannot create custom events. You cannot implement custom instrumentation using the Custom Instrumentation Editor. You cannot collect user attributes. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: Java agent configuration file Custom attributes Java agent API Setting Effects on data security audit_mode boolean Default: false By default, the Java agent does not log all data sent to New Relic in the agent log file. If you set this to true, the agent logs data sent to the New Relic collector in the agent log file. You can then evaluate the information that the agent sends by reviewing the agent log file to see if it includes sensitive information. high_security boolean Default: false To enable high security mode, set this to true and enable high security in New Relic. This restricts the information you can send to New Relic. proxy_host string Default: (none) Some proxies default to using HTTP, which is a less secure protocol. attributes.enabled boolean Default: true Default for the Custom Instrumentation Editor: false By default, you are sending attributes to New Relic, except for methods instrumented using the Custom Instrumentation Editor. If you do not want to send attributes to New Relic, set this to false. attributes.exclude string Default: (none) If there are specific attribute keys that you do not want to send to New Relic in transaction traces, identify them using attributes.exclude. This restricts the information sent to New Relic. Consider if you want to exclude these potentially sensitive attributes using attributes.exclude or if you need the information sent to New Relic: request.headers.*: Removes all request headers. (Note that HTTP headers that contain sensitive data such as cookie and authorization are never collected.) response.headers.*: Removes all response headers. request_uri: Removes the path for the transaction's incoming request. log_sql boolean Default: false By default, you are sending queries to New Relic using record_sql. If you want to log queries in the agent log file as well as send them to New Relic, set this to true. record_sql string Default: obfuscated By default, record_sql is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to off. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. strip_exception_messages boolean Default: false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. If you are not using high security mode but still want to strip messages from all exceptions except those in your allow list, set this to true. custom_insights_events.enabled boolean Default: true By default, the agent records events sent to the Event API via recordCustomEvent(). If you enable high security mode, this is automatically set to false.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.1884,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>agent</em> security: <em>Java</em>",
        "sections": "APM <em>agent</em> security: <em>Java</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " enable high security mode, the default settings are locked so that users cannot change them. In addition: The <em>agent</em> does not collect message queue parameters. You cannot create <em>custom</em> events. You cannot implement <em>custom</em> <em>instrumentation</em> using the <em>Custom</em> <em>Instrumentation</em> Editor. You cannot collect user"
      },
      "id": "6043b8bb28ccbc3db92c60b7"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 158.12025,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> API lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This API consists of: Static methods on the com.newrelic.api.<em>agent</em>.NewRelic class A @Trace annotation for implementing <em>custom</em> <em>instrumentation</em> A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.44116,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "New Relic&#x27;s <em>Java</em> <em>agent</em> includes built-in <em>instrumentation</em> of the most popular parts of the <em>Java</em> ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the <em>agent</em> with <em>Java</em> <em>custom</em>"
      },
      "id": "6043b8f6196a6771a9960f87"
    }
  ],
  "/docs/agents/java-agent/custom-instrumentation/troubleshooting-java-custom-instrumentation": [
    {
      "sections": [
        "APM agent security: Java",
        "Default security settings",
        "Caution",
        "High security mode settings",
        "Custom security settings"
      ],
      "title": "APM agent security: Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "fd9f5744c001453dbb9f129480f4e7e5ce42a176",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/apm-agent-security-java/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives, you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see Java agent error configuration. By default, here is how the New Relic Java agent handles the following potentially sensitive data:: Request parameters: The agent does not capture HTTP request parameters. HTTPS: The agent communicates with New Relic using HTTPS. SQL: The agent sets SQL recording to obfuscated, which removes the potentially sensitive numeric and string literal values. High security mode settings When you enable high security mode, the default settings are locked so that users cannot change them. In addition: The agent does not collect message queue parameters. You cannot create custom events. You cannot implement custom instrumentation using the Custom Instrumentation Editor. You cannot collect user attributes. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: Java agent configuration file Custom attributes Java agent API Setting Effects on data security audit_mode boolean Default: false By default, the Java agent does not log all data sent to New Relic in the agent log file. If you set this to true, the agent logs data sent to the New Relic collector in the agent log file. You can then evaluate the information that the agent sends by reviewing the agent log file to see if it includes sensitive information. high_security boolean Default: false To enable high security mode, set this to true and enable high security in New Relic. This restricts the information you can send to New Relic. proxy_host string Default: (none) Some proxies default to using HTTP, which is a less secure protocol. attributes.enabled boolean Default: true Default for the Custom Instrumentation Editor: false By default, you are sending attributes to New Relic, except for methods instrumented using the Custom Instrumentation Editor. If you do not want to send attributes to New Relic, set this to false. attributes.exclude string Default: (none) If there are specific attribute keys that you do not want to send to New Relic in transaction traces, identify them using attributes.exclude. This restricts the information sent to New Relic. Consider if you want to exclude these potentially sensitive attributes using attributes.exclude or if you need the information sent to New Relic: request.headers.*: Removes all request headers. (Note that HTTP headers that contain sensitive data such as cookie and authorization are never collected.) response.headers.*: Removes all response headers. request_uri: Removes the path for the transaction's incoming request. log_sql boolean Default: false By default, you are sending queries to New Relic using record_sql. If you want to log queries in the agent log file as well as send them to New Relic, set this to true. record_sql string Default: obfuscated By default, record_sql is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to off. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. strip_exception_messages boolean Default: false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. If you are not using high security mode but still want to strip messages from all exceptions except those in your allow list, set this to true. custom_insights_events.enabled boolean Default: true By default, the agent records events sent to the Event API via recordCustomEvent(). If you enable high security mode, this is automatically set to false.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.18832,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>agent</em> security: <em>Java</em>",
        "sections": "APM <em>agent</em> security: <em>Java</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " enable high security mode, the default settings are locked so that users cannot change them. In addition: The <em>agent</em> does not collect message queue parameters. You cannot create <em>custom</em> events. You cannot implement <em>custom</em> <em>instrumentation</em> using the <em>Custom</em> <em>Instrumentation</em> Editor. You cannot collect user"
      },
      "id": "6043b8bb28ccbc3db92c60b7"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 158.12018,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> API lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This API consists of: Static methods on the com.newrelic.api.<em>agent</em>.NewRelic class A @Trace annotation for implementing <em>custom</em> <em>instrumentation</em> A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.4411,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "New Relic&#x27;s <em>Java</em> <em>agent</em> includes built-in <em>instrumentation</em> of the most popular parts of the <em>Java</em> ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the <em>agent</em> with <em>Java</em> <em>custom</em>"
      },
      "id": "6043b8f6196a6771a9960f87"
    }
  ],
  "/docs/agents/java-agent/features/jvms-page-java-view-app-server-metrics-jmx": [
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.68108,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " to our flamegraphs feature is available upon request. All other real-time profiling <em>features</em> are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and <em>Java</em> <em>agent</em> and the daemon must be reporting"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.75346,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " instrumentation. Requirements to install the <em>agent</em> Before you install the <em>Java</em> <em>agent</em>, ensure your system meets these requirements: JVM Tip The <em>Java</em> <em>agent</em> is compatible with any JVM-based language, including: <em>Java</em>, Scala, Kotlin, and Clojure. For instrumentation support for language-specific <em>features</em>, see"
      },
      "id": "6043b8f6196a6771a9960f87"
    },
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 101.91603,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the instrumentation package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]instrumentation.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate configuration to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    }
  ],
  "/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics": [
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.75341,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " instrumentation. Requirements to install the <em>agent</em> Before you install the <em>Java</em> <em>agent</em>, ensure your system meets these requirements: JVM Tip The <em>Java</em> <em>agent</em> is compatible with any JVM-based language, including: <em>Java</em>, Scala, Kotlin, and Clojure. For instrumentation support for language-specific <em>features</em>, see"
      },
      "id": "6043b8f6196a6771a9960f87"
    },
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 101.915985,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the instrumentation package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]instrumentation.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate configuration to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    },
    {
      "sections": [
        "JVMs page (Java): View app server metrics from JMX",
        "View JVM metrics",
        "Tabs available by app server",
        "Metrics available by tab",
        "Data source metrics by app server",
        "Enable for Spring Boot 2.2 and higher with Tomcat",
        "Enable WebSphere PMI metrics",
        "Enable all statistic sets (recommended)",
        "Enable custom statistic sets (advanced)",
        "Collected WebSphere PMI metrics",
        "stats.ActiveCount",
        "maximumSize",
        "stats.CommittedCount",
        "stats.RolledbackCount",
        "stats.GlobalTimeoutCount",
        "stats.LiveCount",
        "WebLogic JMX metrics",
        "Tip",
        "ThreadCount",
        "TotalStartedThreadCount",
        "LoadedClassCount",
        "UnloadedClassCount",
        "HoggingThreadCount",
        "ExecuteThreadIdleCount",
        "StandbyThreadCount",
        "TransactionTotalCount",
        "TransactionCommittedTotalCount",
        "TransactionRolledBackTotalCount",
        "TransactionAbandonedTotalCount",
        "NumAvailable",
        "CurrCapacity",
        "ConnectionsTotalCount",
        "ActiveConnectionsCurrentCount",
        "LeakedConnectionCount",
        "PrepStmtCacheCurrentSize",
        "WaitingForConnectionCurrentCount",
        "WaitingForConnectionTotal",
        "WaitingForConnectionSuccessTotal",
        "WaitingForConnectionFailureTotal",
        "AccessTotalCount - MissTotalCount",
        "MissTotalCount",
        "WaiterCurrentCount",
        "DestroyedTotalCount",
        "BeansInUseCurrentCount",
        "PooledBeansCurrentCount",
        "TransactionsCommittedTotalCount +TransactionsRolledBackTotalCount +TransactionsTimedOutTotalCount",
        "TransactionsCommittedTotalCount",
        "TransactionsRolledBackTotalCount",
        "TransactionsTimedOutTotalCount"
      ],
      "title": "JVMs page (Java): View app server metrics from JMX",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "da87ac2a630aa7d23dcfcd29838c92a0ec1b3ec3",
      "image": "https://docs.newrelic.com/static/9fc8aafbabec1473134b718135fdef74/c1b63/apm_jvm.png",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/jvms-page-java-view-app-server-metrics-jmx/",
      "published_at": "2021-06-02T15:21:38Z",
      "updated_at": "2021-03-16T04:31:10Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use New Relic's Java agent to collect and view additional metrics provided by the most common application servers via JMX. The collected metrics vary by app server and include measurements of thread pools, HTTP sessions, and transactions. View JVM metrics Application servers collect and report different metrics, which appear on APM's JVMs page. (For applications using New Relic via Heroku, the JVMs page is named Instances.) At a minimum, each app server collects and reports metric data on memory. For instructions on enabling JMX metrics, refer to your app server's documentation. To view JVM metrics: Go to one.newrelic.com > APM > (select an app) > Monitoring > JVMs > (select a JVM). From the selected JVM's Memory page, use any of New Relic's standard user interface functions to drill down into detailed information. To view other metrics, select any available tab. Optional: To use the thread profiler to look for bottlenecks in data on executing threads, select Profile this JVM. one.newrelic.com > APM > (select an app) > Monitoring > JVMs: Depending on the metrics your app server is reporting, one or more tabs appear on your JVM page. Tabs available by app server This table lists which tabs appear on the JVM page for app servers. If your app server does not report a particular type of metric data, the tab does not appear on your JVM page. App server Memory Thread pools HTTP sessions App server transactions Data sources Glassfish JBoss 5AS JBoss 6AS JBoss 6EAP JBoss 7AS Jetty Resin 3 Resin 4 Tomcat TomEE WebLogic Websphere Liberty Websphere Traditional WildFly Metrics available by tab Here is a summary of the metrics available from the JVM page. If the app server does not support a particular metric, that tab does not appear on your JVM page. JMX Metric charts Memory Heap memory usage: Each chart shows the used and committed heap space in MB for a given heap. Non-heap memory pool usage for the JVM: The used code cache and used CMS Perm Gen in MB. Garbage collection: The garbage collection CPU time. Class count: The loaded and unloaded class count for the JVM. Threads Thread count: The current number of active threads in the JVM. Thread pool: The active and idle thread count for the pool. On supported app servers, a chart shows each thread pool present in the app server, as well as the ratio of active to maximum thread count for each thread pool. HTTP sessions Session: The active, invalidated by timeout, and invalidated HTTP session counts for the application. On supported app servers, a chart shows each application present in the app server. App server transactions Active transaction: The number of active transactions within the app server's transaction manager. Created transaction: The change in the total number of created transactions per app server. Some app servers separate top level transactions and nested transactions. Finished transaction: The change in the total number of finished transactions per app server. Some app servers separate them by aborted and committed completed transactions. Data sources The metrics for the data source tab vary by app server. For more details, see Data source metrics by app server. For details on WebLogic's data source metrics, see WebLogic JMX metrics. Data source metrics by app server For supported app servers, the agent collects JMX data source metrics. You can view these metrics at one.newrelic.com > APM > (select an app) > Monitoring > JVMs > Data sources. To see these metrics, ensure that your data source has been properly configured for JMX monitoring for your app server. App server Metrics Tomcat Max connections: The maximum connections available for a data source. This is generally a configurable parameter. Active connections: The current number of active connections in a data source. Idle connections: The current number of idle connections in a data source. WebSphere Liberty Max connections: The maximum connections available for a data source. This is generally a configurable parameter. Active connections: The current number of active connections in a data source. Idle connections: The current number of idle connections in a data source. Wait time: The average amount of time a connections needs to wait before being handled. Destroyed connections: The number of destroyed connections. Resin Max connections: The maximum connections available for a data source. This is generally a configurable parameter. Active connections: The current number of active connections in a data source. Idle connections: The current number of idle connections in a data source. Created connections: The number of created connections. Enable for Spring Boot 2.2 and higher with Tomcat To enable New Relic to access Tomcat JMX metrics when running with Spring Boot 2.2 and higher, the system property server.tomcat.mbeanregistry.enabled must be set to true. See the Spring Boot 2.2 release notes. Enable WebSphere PMI metrics To enable New Relic to access WebSphere PMI metrics, you will need to configure WebSphere to monitor the necessary statistic sets. Enable all statistic sets (recommended) The simplest approach is to enable the collection of all statistic sets: If you are using Java 2 Security, ensure you have granted New Relic proper permissions. From the WebSphere admin console, select Monitoring and Tuning > Performance Monitoring Infrastructure (PMI) > (your server name). Select the Enable Performance Monitoring Infrastructure (PMI) checkbox. In the Currently monitored statistic set section, select All, then save your changes. Enable custom statistic sets (advanced) You can also collect only the PMI metrics that New Relic monitors by default. To collect only some PMI metrics: If you are using Java 2 Security, ensure you have granted New Relic proper permissions. From the WebSphere admin console, select Monitoring and Tuning > Performance Monitoring Infrastructure (PMI) > (selected app server). Select the Enable Performance Monitoring Infrastructure (PMI) checkbox. Select Custom. From the custom statistic set list, enable the following metrics: In the ThreadPool category, select the ActiveCount and PoolSize checkboxes. In the Servlet Session Manager category, select the ActiveCount and LiveCount checkboxes. In the Transaction Manager category, select the CommittedCount, RolledbackCount, and GlobalTimeoutCount checkboxes. From the Messages panel, select Save directly to the master configuration. Collected WebSphere PMI metrics When enabled, New Relic collects the following WebSphere PMI metrics. If you want other PMI metrics besides these to be collected and displayed in New Relic custom dashboards, use JMX instrumentation. stats.ActiveCount WebSphere PMI metrics Details Attribute stats.ActiveCount Object name pattern WebSphere:type=ThreadPool,name=*,process=*,platform=*,node=*,* Copy New Relic metric JmxBuiltIn/ThreadPool/WebContainer/Active Copy Type Simple maximumSize WebSphere PMI metrics Details Attribute maximumSize Object name pattern WebSphere:type=ThreadPool,name=*,process=*,platform=*,node=*,* Copy New Relic metric JmxBuiltIn/ThreadPool/WebContainer/Max Copy Type Simple stats.CommittedCount WebSphere PMI metrics Details Attribute stats.CommittedCount Object name pattern WebSphere:j2eeType=JTAResource,type=TransactionService,name=*,process=*,platform=*,node=*,* Copy New Relic metric JmxBuiltIn/JTA/TransactionService/Committed Copy Type Simple stats.RolledbackCount WebSphere PMI metrics Details Attribute stats.RolledbackCount Object name pattern WebSphere:j2eeType=JTAResource,type=TransactionService,name=*,process=*,platform=*,node=*,* Copy New Relic metric JmxBuiltIn/JTA/TransactionService/Rolled Back Copy Type Simple stats.GlobalTimeoutCount WebSphere PMI metrics Details Attribute stats.GlobalTimeoutCount Object name pattern WebSphere:j2eeType=JTAResource,type=TransactionService,name=*,process=*,platform=*,node=*,* Copy New Relic metric JmxBuiltIn/JTA/TransactionService/Timed Out Copy Type Simple stats.LiveCount WebSphere PMI metrics Details Attribute stats.GlobalTimeoutCount Object name pattern WebSphere:type=SessionManager,name=*,process=*,platform=*,node=*,* Copy New Relic metric JmxBuiltIn/Session/DefaultApplication#DefaultWebApplication.war/Active Copy Type Simple WebLogic JMX metrics In WebLogic, JMX is enabled by default. New Relic collects the following mbeans metrics. Tip To collect additional JMX metrics, use a custom YAML file. ThreadCount WebLogic JMX metrics Details Attribute ThreadCount Object name pattern java.lang:type=Threading Copy New Relic metric JmxBuiltIn/Threads/Thread Count Copy Type Simple TotalStartedThreadCount WebLogic JMX metrics Details Attribute TotalStartedThreadCount Object name pattern java.lang:type=Threading Copy New Relic metric JmxBuiltIn/Threads/TotalStartedCount Copy Type Simple LoadedClassCount WebLogic JMX metrics Details Attribute LoadedClassCount Object name pattern java.lang:type=ClassLoading Copy New Relic metric JmxBuiltIn/Classes/Loaded Copy Type Simple UnloadedClassCount WebLogic JMX metrics Details Attribute UnloadedClassCount Object name pattern java.lang:type=ClassLoading Copy New Relic metric JmxBuiltIn/Classes/Unloaded Copy Type Simple HoggingThreadCount WebLogic JMX metrics Details Attribute HoggingThreadCount Object name pattern com.bea:ServerRuntime=*,Name=ThreadPoolRuntime,Type=ThreadPoolRuntime Copy New Relic metric JmxBuiltIn/ThreadPool/{Name}/Active Copy Type Simple ExecuteThreadIdleCount WebLogic JMX metrics Details Attribute ExecuteThreadIdleCount Object name pattern com.bea:ServerRuntime=*,Name=ThreadPoolRuntime,Type=ThreadPoolRuntime Copy New Relic metric JmxBuiltIn/ThreadPool/{Name}/Idle Copy Type Simple StandbyThreadCount WebLogic JMX metrics Details Attribute StandbyThreadCount Object name pattern com.bea:ServerRuntime=*,Name=ThreadPoolRuntime,Type=ThreadPoolRuntime Copy New Relic metric JmxBuiltIn/ThreadPool/{Name}/Standby Copy Type Simple TransactionTotalCount WebLogic JMX metrics Details Attribute TransactionTotalCount Object name pattern com.bea:ServerRuntime=*,Name=JTARuntime,Type=JTARuntime Copy New Relic metric JmxBuiltIn/JTA/{Name}/Count Copy Type Monotonic TransactionCommittedTotalCount WebLogic JMX metrics Details Attribute TransactionCommittedTotalCount Object name pattern com.bea:ServerRuntime=*,Name=JTARuntime,Type=JTARuntime Copy New Relic metric JmxBuiltIn/JTA/{Name}/Committed Copy Type Monotonic TransactionRolledBackTotalCount WebLogic JMX metrics Details Attribute TransactionRolledBackTotalCount Object name pattern com.bea:ServerRuntime=*,Name=JTARuntime,Type=JTARuntime Copy New Relic metric JmxBuiltIn/JTA/{Name}/Rolled Back Copy Type Monotonic TransactionAbandonedTotalCount WebLogic JMX metrics Details Attribute TransactionAbandonedTotalCount Object name pattern com.bea:ServerRuntime=*,Name=JTARuntime,Type=JTARuntime Copy New Relic metric JmxBuiltIn/JTA/{Name}/Abandoned Copy Type Monotonic NumAvailable WebLogic JMX metrics Details Attribute NumAvailable Object name pattern com.bea:ServerRuntime=*,Name=*,Type=JDBCDataSourceRuntime Copy New Relic metric JmxBuiltIn/DataSources/{Name}/Connections/Available Copy Type Simple CurrCapacity WebLogic JMX metrics Details Attribute CurrCapacity Object name pattern com.bea:ServerRuntime=*,Name=*,Type=JDBCDataSourceRuntime Copy New Relic metric JmxBuiltIn/DataSources/{Name}/Connections/PoolSize Copy Type Simple ConnectionsTotalCount WebLogic JMX metrics Details Attribute ConnectionsTotalCount Object name pattern com.bea:ServerRuntime=*,Name=*,Type=JDBCDataSourceRuntime Copy New Relic metric JmxBuiltIn/DataSources/{Name}/Connections/Created Copy Type Monotonic ActiveConnectionsCurrentCount WebLogic JMX metrics Details Attribute ActiveConnectionsCurrentCount Object name pattern com.bea:ServerRuntime=*,Name=*,Type=JDBCDataSourceRuntime Copy New Relic metric JmxBuiltIn/DataSources/{Name}/Connections/Active Copy Type Simple LeakedConnectionCount WebLogic JMX metrics Details Attribute LeakedConnectionCount Object name pattern com.bea:ServerRuntime=*,Name=*,Type=JDBCDataSourceRuntime Copy New Relic metric JmxBuiltIn/DataSources/{Name}/Connections/Leaked Copy Type Monotonic PrepStmtCacheCurrentSize WebLogic JMX metrics Details Attribute PrepStmtCacheCurrentSize Object name pattern com.bea:ServerRuntime=*,Name=*,Type=JDBCDataSourceRuntime Copy New Relic metric JmxBuiltIn/DataSources/{Name}/Statement Cache/Size Copy Type Simple WaitingForConnectionCurrentCount WebLogic JMX metrics Details Attribute WaitingForConnectionCurrentCount Object name pattern com.bea:ServerRuntime=*,Name=*,Type=JDBCDataSourceRuntime Copy New Relic metric JmxBuiltIn/DataSources/{Name}/Requests/Currently Waiting Copy Type Simple WaitingForConnectionTotal WebLogic JMX metrics Details Attribute WaitingForConnectionTotal Object name pattern com.bea:ServerRuntime=*,Name=*,Type=JDBCDataSourceRuntime Copy New Relic metric JmxBuiltIn/DataSources/{Name}/Requests/Count Copy Type Monotonic WaitingForConnectionSuccessTotal WebLogic JMX metrics Details Attribute WaitingForConnectionSuccessTotal Object name pattern com.bea:ServerRuntime=*,Name=*,Type=JDBCDataSourceRuntime Copy New Relic metric JmxBuiltIn/DataSources/{Name}/Requests/Successful Copy Type Monotonic WaitingForConnectionFailureTotal WebLogic JMX metrics Details Attribute WaitingForConnectionFailureTotal Object name pattern com.bea:ServerRuntime=*,Name=*,Type=JDBCDataSourceRuntime Copy New Relic metric JmxBuiltIn/DataSources/{Name}/Requests/Failed Copy Type Monotonic AccessTotalCount - MissTotalCount WebLogic JMX metrics Details Attribute AccessTotalCount - MissTotalCount Object name pattern com.bea:ServerRuntime=*,Name=*,ApplicationRuntime=*,Type=EJBPoolRuntime,EJBComponentRuntime=*,* Copy New Relic metric JmxBuiltIn/EJB/Pool/Bean/{ApplicationRuntime}/{EJBComponentRuntime}/{Name}/Attempts/Successful Copy Type Monotonic MissTotalCount WebLogic JMX metrics Details Attribute MissTotalCount Object name pattern com.bea:ServerRuntime=*,Name=*,ApplicationRuntime=*,Type=EJBPoolRuntime,EJBComponentRuntime=*,* Copy New Relic metric JmxBuiltIn/EJB/Pool/Bean/{ApplicationRuntime}/{EJBComponentRuntime}/{Name}/Attempts/Failed Copy Type Monotonic WaiterCurrentCount WebLogic JMX metrics Details Attribute WaiterCurrentCount Object name pattern com.bea:ServerRuntime=*,Name=*,ApplicationRuntime=*,Type=EJBPoolRuntime,EJBComponentRuntime=*,*> Copy New Relic metric JmxBuiltIn/EJB/Pool/Bean/{ApplicationRuntime}/{EJBComponentRuntime}/{Name}/Threads/Waiting Copy Type Simple DestroyedTotalCount WebLogic JMX metrics Details Attribute DestroyedTotalCount Object name pattern com.bea:ServerRuntime=*,Name=*,ApplicationRuntime=*,Type=EJBPoolRuntime,EJBComponentRuntime=*,* Copy New Relic metric JmxBuiltIn/EJB/Pool/Bean/{ApplicationRuntime}/{EJBComponentRuntime}/{Name}/Beans/Destroyed Copy Type Monotonic BeansInUseCurrentCount WebLogic JMX metrics Details Attribute BeansInUseCurrentCount Object name pattern com.bea:ServerRuntime=*,Name=*,ApplicationRuntime=*,Type=EJBPoolRuntime,EJBComponentRuntime=*,* Copy New Relic metric JmxBuiltIn/EJB/Pool/Bean/{ApplicationRuntime}/{EJBComponentRuntime}/{Name}/Beans/Active Copy Type Simple PooledBeansCurrentCount WebLogic JMX metrics Details Attribute PooledBeansCurrentCount Object name pattern com.bea:ServerRuntime=*,Name=*,ApplicationRuntime=*,Type=EJBPoolRuntime,EJBComponentRuntime=*,* Copy New Relic metric JmxBuiltIn/EJB/Pool/Bean/{ApplicationRuntime}/{EJBComponentRuntime}/{Name}/Beans/Available Copy Type Simple TransactionsCommittedTotalCount +TransactionsRolledBackTotalCount +TransactionsTimedOutTotalCount WebLogic JMX metrics Details Attribute TransactionsCommittedTotalCount +TransactionsRolledBackTotalCount +TransactionsTimedOutTotalCount Object name pattern com.bea:ServerRuntime=*,Name=*,ApplicationRuntime=*,Type=EJBTransactionRuntime,EJBComponentRuntime=*,* Copy New Relic metric JmxBuiltIn/EJB/Transactions/Application/{ApplicationRuntime}/Count Copy Type Monotonic TransactionsCommittedTotalCount WebLogic JMX metrics Details Attribute TransactionsCommittedTotalCount Object name pattern com.bea:ServerRuntime=*,Name=*,ApplicationRuntime=*,Type=EJBTransactionRuntime,EJBComponentRuntime=*,* Copy New Relic metric JmxBuiltIn/EJB/Transactions/Application/{ApplicationRuntime}/Committed Copy Type Monotonic TransactionsRolledBackTotalCount WebLogic JMX metrics Details Attribute TransactionsRolledBackTotalCount Object name pattern com.bea:ServerRuntime=*,Name=*,ApplicationRuntime=*,Type=EJBTransactionRuntime,EJBComponentRuntime=*,* Copy New Relic metric JmxBuiltIn/EJB/Transactions/Application/{ApplicationRuntime}/Rolled Back Copy Type Monotonic TransactionsTimedOutTotalCount WebLogic JMX metrics Details Attribute TransactionsTimedOutTotalCount Object name pattern com.bea:ServerRuntime=*,Name=*,ApplicationRuntime=*,Type=EJBTransactionRuntime,EJBComponentRuntime=*,* Copy New Relic metric JmxBuiltIn/EJB/Transactions/Application/{ApplicationRuntime}/Timed Out Copy Type Monotonic",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 96.97777,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "JVMs page (<em>Java</em>): View app server metrics from JMX",
        "sections": "JVMs page (<em>Java</em>): View app server metrics from JMX",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "You can use New Relic&#x27;s <em>Java</em> <em>agent</em> to collect and view additional metrics provided by the most common application servers via JMX. The collected metrics vary by app server and include measurements of thread pools, HTTP sessions, and transactions. View JVM metrics Application servers collect"
      },
      "id": "603eb1c3e7b9d2d4182a07dc"
    }
  ],
  "/docs/agents/java-agent/frameworks/scala-installation-java": [
    {
      "sections": [
        "APM agent security: Java",
        "Default security settings",
        "Caution",
        "High security mode settings",
        "Custom security settings"
      ],
      "title": "APM agent security: Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "fd9f5744c001453dbb9f129480f4e7e5ce42a176",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/apm-agent-security-java/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives, you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see Java agent error configuration. By default, here is how the New Relic Java agent handles the following potentially sensitive data:: Request parameters: The agent does not capture HTTP request parameters. HTTPS: The agent communicates with New Relic using HTTPS. SQL: The agent sets SQL recording to obfuscated, which removes the potentially sensitive numeric and string literal values. High security mode settings When you enable high security mode, the default settings are locked so that users cannot change them. In addition: The agent does not collect message queue parameters. You cannot create custom events. You cannot implement custom instrumentation using the Custom Instrumentation Editor. You cannot collect user attributes. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: Java agent configuration file Custom attributes Java agent API Setting Effects on data security audit_mode boolean Default: false By default, the Java agent does not log all data sent to New Relic in the agent log file. If you set this to true, the agent logs data sent to the New Relic collector in the agent log file. You can then evaluate the information that the agent sends by reviewing the agent log file to see if it includes sensitive information. high_security boolean Default: false To enable high security mode, set this to true and enable high security in New Relic. This restricts the information you can send to New Relic. proxy_host string Default: (none) Some proxies default to using HTTP, which is a less secure protocol. attributes.enabled boolean Default: true Default for the Custom Instrumentation Editor: false By default, you are sending attributes to New Relic, except for methods instrumented using the Custom Instrumentation Editor. If you do not want to send attributes to New Relic, set this to false. attributes.exclude string Default: (none) If there are specific attribute keys that you do not want to send to New Relic in transaction traces, identify them using attributes.exclude. This restricts the information sent to New Relic. Consider if you want to exclude these potentially sensitive attributes using attributes.exclude or if you need the information sent to New Relic: request.headers.*: Removes all request headers. (Note that HTTP headers that contain sensitive data such as cookie and authorization are never collected.) response.headers.*: Removes all response headers. request_uri: Removes the path for the transaction's incoming request. log_sql boolean Default: false By default, you are sending queries to New Relic using record_sql. If you want to log queries in the agent log file as well as send them to New Relic, set this to true. record_sql string Default: obfuscated By default, record_sql is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to off. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. strip_exception_messages boolean Default: false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. If you are not using high security mode but still want to strip messages from all exceptions except those in your allow list, set this to true. custom_insights_events.enabled boolean Default: true By default, the agent records events sent to the Event API via recordCustomEvent(). If you enable high security mode, this is automatically set to false.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 164.18823,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>agent</em> security: <em>Java</em>",
        "sections": "APM <em>agent</em> security: <em>Java</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " enable high security mode, the default settings are locked so that users cannot change them. In addition: The <em>agent</em> does not collect message queue parameters. You cannot create <em>custom</em> events. You cannot implement <em>custom</em> <em>instrumentation</em> using the <em>Custom</em> <em>Instrumentation</em> Editor. You cannot collect user"
      },
      "id": "6043b8bb28ccbc3db92c60b7"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 158.1201,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> API lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This API consists of: Static methods on the com.newrelic.api.<em>agent</em>.NewRelic class A @Trace annotation for implementing <em>custom</em> <em>instrumentation</em> A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 127.44104,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "New Relic&#x27;s <em>Java</em> <em>agent</em> includes built-in <em>instrumentation</em> of the most popular parts of the <em>Java</em> ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the <em>agent</em> with <em>Java</em> <em>custom</em>"
      },
      "id": "6043b8f6196a6771a9960f87"
    }
  ],
  "/docs/agents/java-agent/getting-started/apm-agent-security-java": [
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.15741,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " method. The <em>Java</em> <em>agent</em> reports the database name and database server&#x2F;identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, <em>get</em> support at support.newrelic.com. Hosting services You can install"
      },
      "id": "6043b8f6196a6771a9960f87"
    },
    {
      "sections": [
        "Introduction to New Relic for Java",
        "Tip",
        "Installation",
        "Startup configuration",
        "Configuration options",
        "Additional instrumentation",
        "When to restart your JVM",
        "JSR 163 compliance",
        "Troubleshooting procedures"
      ],
      "title": "Introduction to New Relic for Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "7e45fd7009c9f4669aeab68516b6c22a1f7d780b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/introduction-new-relic-java/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-05-16T11:05:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's Java agent, you can track everything from performance issues to tiny errors within your code. Every minute the agent posts metric timeslice and event data to the New Relic user interface, where the owner of that data can sign in and use the data to see how their website is performing. Tip To use Java or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Installation To use the Java agent: Make sure your system meets the Java agent's compatibility and requirements. Sign up for a New Relic account. Install the Java agent using our launcher, or by following the standard installation procedures. Depending on your tools and frameworks, refer to additional installation procedures to install or configure the Java agent. Read the install docs Add Java data To view your app's performance in the New Relic UI, go to one.newrelic.com > APM > (select an app) > Summary. The APM user interface includes a dedicated JVM metrics page, transaction and error details, a thread profiler tool to sample Java threads and report stack traces, and more. You can also extend your agent instrumentation and explore your data with other New Relic products, including New Relic One's data explorer and dashboards. Startup configuration The Java agent reads the startup configuration from the newrelic.yml file, which must be in the same directory as newrelic.jar. You can also override settings using Java system properties. The agent needs the license_key and app_name settings at startup (bootstrap). You can customize the location of the log file and other settings in your newrelic.yml file. In addition, you can adjust the naming configuration if your app server runs multiple applications in the same JVM. Configuration options You can configure application reporting from the New Relic web interface using server-side configuration. Changes will be applied to all agents reporting for your application when the JVM restarts. However, if you use server-side configuration, you must still maintain required settings (license_key and app_name) in the local config file. Both transaction traces and error snapshots can optionally record HTTP parameters. Sometimes HTTP parameters contain sensitive information, such as a credit card number. The agent has several configuration options to ensure data security, such as collecting HTTP parameters but excluding certain named parameters. Additional instrumentation After installing the Java agent, use any of these methods to extend your instrumentation: Custom instrumentation: Implement Java custom instrumentation via annotation or XML. Enable distributed tracing: See the paths of your requests as they spread across a distributed, multiple-services architecture. Collect custom attributes: Collect custom attributes via API or XML file. Java agent API: Use the API to control, customize, or extend the functionality of the Java agent. Browser instrumentation: Integrate the Java agent with Browser monitoring to gain visibility into end-user activity. Circuit breaker for Java custom instrumentation: Use a circuit breaker to protect applications from over-instrumentation. Custom JMX instrumentation by YAML: View custom JMX metrics with a YAML custom instrumentation file. JVM metrics page: Collect metrics from the most common application servers through JMX. Open source telemetry: We offer a variety of tools, such as Kamon Reporter, OpenTelemetry exporter, Micrometer metrics registry, and Java Telemetry SDK. When to restart your JVM When you make a change to your configuration or to your custom XML, in almost all cases you must restart your JVM. There are only four situations where a restart is not necessary: JVM restart is not required for... Comments Log level or audit mode changes If you are simply changing the log_level or audit_mode in the Java agent configuration file, you do not need to restart the JVM. Custom instrumentation XML file JVM restart depends on your Java agent version: 3.15.0 or higher: If you are updating a custom instrumentation XML file in the extensions folder, the updates will be reloaded automatically within a minute. Java agent versions lower than 3.15.0: If you using an agent version earlier than 3.15.0, you must restart the JVM. Circuit breaker changes If you are changing the circuit breaker for Java custom instrumentation, a JVM restart is not required. Ignored or expected errors If you are ignoring or expecting errors by configuring the newrelic.yml file, a JVM restart is not required. This includes adding status codes or classes to the newrelic.yml file when using the Java agent version 3.40.0 or higher. For example: ignore_status_codes expected_status_codes ignore_classes ignore_messages expected_classes expected_messages All other changes require an agent restart, which means restarting the JVM. JSR 163 compliance The New Relic Java agent monitors web transactions, receiving information about them and communicating that information to the New Relic user interface with strong data security measures in place. The agent is packaged as a JSR 163 compliant javaagent that is activated by the JVM through modifications to the JVM launch. Once activated, the agent inserts itself into the class loading stream and instruments class methods using byte code instrumentation (bci). Designed to have minimal impact on your web application, all of the classes are in the newrelic package namespace so they do not collide with your own classes. The agent uses the ASM bci engine to insert software probes. The agent receives basic information about your host environment, such as operating system, Java version, system properties, and your New Relic configuration file. The agent also polls data from the JVM and from JMX. Troubleshooting procedures If you encounter problems with the Java agent, see the troubleshooting documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 118.25206,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic for <em>Java</em>",
        "sections": "Introduction to New Relic for <em>Java</em>",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": "With New Relic&#x27;s <em>Java</em> <em>agent</em>, you can track everything from performance issues to tiny errors within your code. Every minute the <em>agent</em> posts metric timeslice and event data to the New Relic user interface, where the owner of that data can sign in and use the data to see how their website"
      },
      "id": "6043ba0f64441f5a3b378eec"
    },
    {
      "sections": [
        "APM agent security: Python",
        "Default security settings",
        "High security mode settings",
        "Custom security settings",
        "Caution",
        "Tip"
      ],
      "title": "APM agent security: Python",
      "type": "docs",
      "tags": [
        "Agents",
        "Python agent",
        "Getting started"
      ],
      "external_id": "ad1cc218ab320532980be60513a8ce52b5e209c3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/python-agent/getting-started/apm-agent-security-python/",
      "published_at": "2021-06-03T06:22:46Z",
      "updated_at": "2021-06-03T06:22:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Python agent default security settings automatically provide security for your data to ensure data privacy and to limit the kind of information we ingest. You may have business reasons to change these settings. If you want to restrict the information that we ingest you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. For more information about security measures, see our security and privacy documentation, or visit the New Relic security website. Default security settings By default, here is how the Python agent handles the following potentially sensitive data: Request parameters: The agent does not capture HTTP request parameters. SQL: The agent sets SQL recording to obfuscated, which removes the potentially sensitive numeric and string literal values. High security mode settings When you enable high security mode, the default settings are locked so that users cannot change them. In addition: The agent does not collect message queue parameters. You cannot create custom events. The agent strips exception messages from errors. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: Python agent configuration file Custom attributes Python agent API Tip Some of these settings can be changed using environment variables. See Python agent environment variables for the complete list. Setting Effects on data security audit_log_file string Default: (none) If you use this to set the name of the audit log file, the agent will log details of messages passed back and forth between the monitored process and the data collector. You can then evaluate the information that the agent sends to the collector to see if it includes sensitive information. high_security boolean Default: false To enable high security mode, set this to true and enable high security. This restricts the information you can send. proxy_host string Default: (none) Some proxies default to using HTTP, which is a less secure protocol. attributes.enabled boolean Default: true By default, you are sending attributes. If you do not want to send attributes, set this to false. attributes.exclude string Default: (none) If there are specific attribute keys that you do not want to send in transaction traces, identify them using attributes.exclude. This restricts the information sent. Consider if you want to exclude these potentially sensitive attributes using attributes.exclude or if you need the information sent: request.headers.*: Removes all request headers. (Note that HTTP headers that contain sensitive data such as cookie and authorization are never collected.) response.headers.*: Removes all response headers. custom_insights_events.enabled boolean Default: true By default, the agent records events sent to the Event API via record_custom_event(). If you enable high security mode, this is automatically set to false. transaction_tracer.record_sql string Default: obfuscated By default, transaction_tracer.record_sql is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to off. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. strip_exception_messages.enabled boolean Default: false If you enable high security mode, this is automatically set to true. If you are not using high security mode but want to strip messages from all exceptions except those in your allow list, set this to true.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 101.93765,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>agent</em> security: Python",
        "sections": "APM <em>agent</em> security: Python",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": "The Python <em>agent</em> default security settings automatically provide security for your data to ensure data privacy and to limit the kind of information we ingest. You may have business reasons to change these settings. If you want to restrict the information that we ingest you can enable high security"
      },
      "id": "6044103f64441fbcef378ef7"
    }
  ],
  "/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent": [
    {
      "sections": [
        "APM agent security: Java",
        "Default security settings",
        "Caution",
        "High security mode settings",
        "Custom security settings"
      ],
      "title": "APM agent security: Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "fd9f5744c001453dbb9f129480f4e7e5ce42a176",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/apm-agent-security-java/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives, you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see Java agent error configuration. By default, here is how the New Relic Java agent handles the following potentially sensitive data:: Request parameters: The agent does not capture HTTP request parameters. HTTPS: The agent communicates with New Relic using HTTPS. SQL: The agent sets SQL recording to obfuscated, which removes the potentially sensitive numeric and string literal values. High security mode settings When you enable high security mode, the default settings are locked so that users cannot change them. In addition: The agent does not collect message queue parameters. You cannot create custom events. You cannot implement custom instrumentation using the Custom Instrumentation Editor. You cannot collect user attributes. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: Java agent configuration file Custom attributes Java agent API Setting Effects on data security audit_mode boolean Default: false By default, the Java agent does not log all data sent to New Relic in the agent log file. If you set this to true, the agent logs data sent to the New Relic collector in the agent log file. You can then evaluate the information that the agent sends by reviewing the agent log file to see if it includes sensitive information. high_security boolean Default: false To enable high security mode, set this to true and enable high security in New Relic. This restricts the information you can send to New Relic. proxy_host string Default: (none) Some proxies default to using HTTP, which is a less secure protocol. attributes.enabled boolean Default: true Default for the Custom Instrumentation Editor: false By default, you are sending attributes to New Relic, except for methods instrumented using the Custom Instrumentation Editor. If you do not want to send attributes to New Relic, set this to false. attributes.exclude string Default: (none) If there are specific attribute keys that you do not want to send to New Relic in transaction traces, identify them using attributes.exclude. This restricts the information sent to New Relic. Consider if you want to exclude these potentially sensitive attributes using attributes.exclude or if you need the information sent to New Relic: request.headers.*: Removes all request headers. (Note that HTTP headers that contain sensitive data such as cookie and authorization are never collected.) response.headers.*: Removes all response headers. request_uri: Removes the path for the transaction's incoming request. log_sql boolean Default: false By default, you are sending queries to New Relic using record_sql. If you want to log queries in the agent log file as well as send them to New Relic, set this to true. record_sql string Default: obfuscated By default, record_sql is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to off. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. strip_exception_messages boolean Default: false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. If you are not using high security mode but still want to strip messages from all exceptions except those in your allow list, set this to true. custom_insights_events.enabled boolean Default: true By default, the agent records events sent to the Event API via recordCustomEvent(). If you enable high security mode, this is automatically set to false.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.15733,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>agent</em> security: <em>Java</em>",
        "sections": "APM <em>agent</em> security: <em>Java</em>",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives"
      },
      "id": "6043b8bb28ccbc3db92c60b7"
    },
    {
      "sections": [
        "Introduction to New Relic for Java",
        "Tip",
        "Installation",
        "Startup configuration",
        "Configuration options",
        "Additional instrumentation",
        "When to restart your JVM",
        "JSR 163 compliance",
        "Troubleshooting procedures"
      ],
      "title": "Introduction to New Relic for Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "7e45fd7009c9f4669aeab68516b6c22a1f7d780b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/introduction-new-relic-java/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-05-16T11:05:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's Java agent, you can track everything from performance issues to tiny errors within your code. Every minute the agent posts metric timeslice and event data to the New Relic user interface, where the owner of that data can sign in and use the data to see how their website is performing. Tip To use Java or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Installation To use the Java agent: Make sure your system meets the Java agent's compatibility and requirements. Sign up for a New Relic account. Install the Java agent using our launcher, or by following the standard installation procedures. Depending on your tools and frameworks, refer to additional installation procedures to install or configure the Java agent. Read the install docs Add Java data To view your app's performance in the New Relic UI, go to one.newrelic.com > APM > (select an app) > Summary. The APM user interface includes a dedicated JVM metrics page, transaction and error details, a thread profiler tool to sample Java threads and report stack traces, and more. You can also extend your agent instrumentation and explore your data with other New Relic products, including New Relic One's data explorer and dashboards. Startup configuration The Java agent reads the startup configuration from the newrelic.yml file, which must be in the same directory as newrelic.jar. You can also override settings using Java system properties. The agent needs the license_key and app_name settings at startup (bootstrap). You can customize the location of the log file and other settings in your newrelic.yml file. In addition, you can adjust the naming configuration if your app server runs multiple applications in the same JVM. Configuration options You can configure application reporting from the New Relic web interface using server-side configuration. Changes will be applied to all agents reporting for your application when the JVM restarts. However, if you use server-side configuration, you must still maintain required settings (license_key and app_name) in the local config file. Both transaction traces and error snapshots can optionally record HTTP parameters. Sometimes HTTP parameters contain sensitive information, such as a credit card number. The agent has several configuration options to ensure data security, such as collecting HTTP parameters but excluding certain named parameters. Additional instrumentation After installing the Java agent, use any of these methods to extend your instrumentation: Custom instrumentation: Implement Java custom instrumentation via annotation or XML. Enable distributed tracing: See the paths of your requests as they spread across a distributed, multiple-services architecture. Collect custom attributes: Collect custom attributes via API or XML file. Java agent API: Use the API to control, customize, or extend the functionality of the Java agent. Browser instrumentation: Integrate the Java agent with Browser monitoring to gain visibility into end-user activity. Circuit breaker for Java custom instrumentation: Use a circuit breaker to protect applications from over-instrumentation. Custom JMX instrumentation by YAML: View custom JMX metrics with a YAML custom instrumentation file. JVM metrics page: Collect metrics from the most common application servers through JMX. Open source telemetry: We offer a variety of tools, such as Kamon Reporter, OpenTelemetry exporter, Micrometer metrics registry, and Java Telemetry SDK. When to restart your JVM When you make a change to your configuration or to your custom XML, in almost all cases you must restart your JVM. There are only four situations where a restart is not necessary: JVM restart is not required for... Comments Log level or audit mode changes If you are simply changing the log_level or audit_mode in the Java agent configuration file, you do not need to restart the JVM. Custom instrumentation XML file JVM restart depends on your Java agent version: 3.15.0 or higher: If you are updating a custom instrumentation XML file in the extensions folder, the updates will be reloaded automatically within a minute. Java agent versions lower than 3.15.0: If you using an agent version earlier than 3.15.0, you must restart the JVM. Circuit breaker changes If you are changing the circuit breaker for Java custom instrumentation, a JVM restart is not required. Ignored or expected errors If you are ignoring or expecting errors by configuring the newrelic.yml file, a JVM restart is not required. This includes adding status codes or classes to the newrelic.yml file when using the Java agent version 3.40.0 or higher. For example: ignore_status_codes expected_status_codes ignore_classes ignore_messages expected_classes expected_messages All other changes require an agent restart, which means restarting the JVM. JSR 163 compliance The New Relic Java agent monitors web transactions, receiving information about them and communicating that information to the New Relic user interface with strong data security measures in place. The agent is packaged as a JSR 163 compliant javaagent that is activated by the JVM through modifications to the JVM launch. Once activated, the agent inserts itself into the class loading stream and instruments class methods using byte code instrumentation (bci). Designed to have minimal impact on your web application, all of the classes are in the newrelic package namespace so they do not collide with your own classes. The agent uses the ASM bci engine to insert software probes. The agent receives basic information about your host environment, such as operating system, Java version, system properties, and your New Relic configuration file. The agent also polls data from the JVM and from JMX. Troubleshooting procedures If you encounter problems with the Java agent, see the troubleshooting documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 118.25206,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic for <em>Java</em>",
        "sections": "Introduction to New Relic for <em>Java</em>",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": "With New Relic&#x27;s <em>Java</em> <em>agent</em>, you can track everything from performance issues to tiny errors within your code. Every minute the <em>agent</em> posts metric timeslice and event data to the New Relic user interface, where the owner of that data can sign in and use the data to see how their website"
      },
      "id": "6043ba0f64441f5a3b378eec"
    },
    {
      "sections": [
        "APM agent security: Python",
        "Default security settings",
        "High security mode settings",
        "Custom security settings",
        "Caution",
        "Tip"
      ],
      "title": "APM agent security: Python",
      "type": "docs",
      "tags": [
        "Agents",
        "Python agent",
        "Getting started"
      ],
      "external_id": "ad1cc218ab320532980be60513a8ce52b5e209c3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/python-agent/getting-started/apm-agent-security-python/",
      "published_at": "2021-06-03T06:22:46Z",
      "updated_at": "2021-06-03T06:22:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Python agent default security settings automatically provide security for your data to ensure data privacy and to limit the kind of information we ingest. You may have business reasons to change these settings. If you want to restrict the information that we ingest you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. For more information about security measures, see our security and privacy documentation, or visit the New Relic security website. Default security settings By default, here is how the Python agent handles the following potentially sensitive data: Request parameters: The agent does not capture HTTP request parameters. SQL: The agent sets SQL recording to obfuscated, which removes the potentially sensitive numeric and string literal values. High security mode settings When you enable high security mode, the default settings are locked so that users cannot change them. In addition: The agent does not collect message queue parameters. You cannot create custom events. The agent strips exception messages from errors. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: Python agent configuration file Custom attributes Python agent API Tip Some of these settings can be changed using environment variables. See Python agent environment variables for the complete list. Setting Effects on data security audit_log_file string Default: (none) If you use this to set the name of the audit log file, the agent will log details of messages passed back and forth between the monitored process and the data collector. You can then evaluate the information that the agent sends to the collector to see if it includes sensitive information. high_security boolean Default: false To enable high security mode, set this to true and enable high security. This restricts the information you can send. proxy_host string Default: (none) Some proxies default to using HTTP, which is a less secure protocol. attributes.enabled boolean Default: true By default, you are sending attributes. If you do not want to send attributes, set this to false. attributes.exclude string Default: (none) If there are specific attribute keys that you do not want to send in transaction traces, identify them using attributes.exclude. This restricts the information sent. Consider if you want to exclude these potentially sensitive attributes using attributes.exclude or if you need the information sent: request.headers.*: Removes all request headers. (Note that HTTP headers that contain sensitive data such as cookie and authorization are never collected.) response.headers.*: Removes all response headers. custom_insights_events.enabled boolean Default: true By default, the agent records events sent to the Event API via record_custom_event(). If you enable high security mode, this is automatically set to false. transaction_tracer.record_sql string Default: obfuscated By default, transaction_tracer.record_sql is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to off. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. strip_exception_messages.enabled boolean Default: false If you enable high security mode, this is automatically set to true. If you are not using high security mode but want to strip messages from all exceptions except those in your allow list, set this to true.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 101.93765,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>agent</em> security: Python",
        "sections": "APM <em>agent</em> security: Python",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": "The Python <em>agent</em> default security settings automatically provide security for your data to ensure data privacy and to limit the kind of information we ingest. You may have business reasons to change these settings. If you want to restrict the information that we ingest you can enable high security"
      },
      "id": "6044103f64441fbcef378ef7"
    }
  ],
  "/docs/agents/java-agent/getting-started/introduction-new-relic-java": [
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.15741,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " method. The <em>Java</em> <em>agent</em> reports the database name and database server&#x2F;identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, <em>get</em> support at support.newrelic.com. Hosting services You can install"
      },
      "id": "6043b8f6196a6771a9960f87"
    },
    {
      "sections": [
        "APM agent security: Java",
        "Default security settings",
        "Caution",
        "High security mode settings",
        "Custom security settings"
      ],
      "title": "APM agent security: Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "fd9f5744c001453dbb9f129480f4e7e5ce42a176",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/apm-agent-security-java/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives, you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see Java agent error configuration. By default, here is how the New Relic Java agent handles the following potentially sensitive data:: Request parameters: The agent does not capture HTTP request parameters. HTTPS: The agent communicates with New Relic using HTTPS. SQL: The agent sets SQL recording to obfuscated, which removes the potentially sensitive numeric and string literal values. High security mode settings When you enable high security mode, the default settings are locked so that users cannot change them. In addition: The agent does not collect message queue parameters. You cannot create custom events. You cannot implement custom instrumentation using the Custom Instrumentation Editor. You cannot collect user attributes. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: Java agent configuration file Custom attributes Java agent API Setting Effects on data security audit_mode boolean Default: false By default, the Java agent does not log all data sent to New Relic in the agent log file. If you set this to true, the agent logs data sent to the New Relic collector in the agent log file. You can then evaluate the information that the agent sends by reviewing the agent log file to see if it includes sensitive information. high_security boolean Default: false To enable high security mode, set this to true and enable high security in New Relic. This restricts the information you can send to New Relic. proxy_host string Default: (none) Some proxies default to using HTTP, which is a less secure protocol. attributes.enabled boolean Default: true Default for the Custom Instrumentation Editor: false By default, you are sending attributes to New Relic, except for methods instrumented using the Custom Instrumentation Editor. If you do not want to send attributes to New Relic, set this to false. attributes.exclude string Default: (none) If there are specific attribute keys that you do not want to send to New Relic in transaction traces, identify them using attributes.exclude. This restricts the information sent to New Relic. Consider if you want to exclude these potentially sensitive attributes using attributes.exclude or if you need the information sent to New Relic: request.headers.*: Removes all request headers. (Note that HTTP headers that contain sensitive data such as cookie and authorization are never collected.) response.headers.*: Removes all response headers. request_uri: Removes the path for the transaction's incoming request. log_sql boolean Default: false By default, you are sending queries to New Relic using record_sql. If you want to log queries in the agent log file as well as send them to New Relic, set this to true. record_sql string Default: obfuscated By default, record_sql is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to off. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. strip_exception_messages boolean Default: false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. If you are not using high security mode but still want to strip messages from all exceptions except those in your allow list, set this to true. custom_insights_events.enabled boolean Default: true By default, the agent records events sent to the Event API via recordCustomEvent(). If you enable high security mode, this is automatically set to false.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.15733,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>agent</em> security: <em>Java</em>",
        "sections": "APM <em>agent</em> security: <em>Java</em>",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives"
      },
      "id": "6043b8bb28ccbc3db92c60b7"
    },
    {
      "sections": [
        "APM agent security: Python",
        "Default security settings",
        "High security mode settings",
        "Custom security settings",
        "Caution",
        "Tip"
      ],
      "title": "APM agent security: Python",
      "type": "docs",
      "tags": [
        "Agents",
        "Python agent",
        "Getting started"
      ],
      "external_id": "ad1cc218ab320532980be60513a8ce52b5e209c3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/python-agent/getting-started/apm-agent-security-python/",
      "published_at": "2021-06-03T06:22:46Z",
      "updated_at": "2021-06-03T06:22:45Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Python agent default security settings automatically provide security for your data to ensure data privacy and to limit the kind of information we ingest. You may have business reasons to change these settings. If you want to restrict the information that we ingest you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. For more information about security measures, see our security and privacy documentation, or visit the New Relic security website. Default security settings By default, here is how the Python agent handles the following potentially sensitive data: Request parameters: The agent does not capture HTTP request parameters. SQL: The agent sets SQL recording to obfuscated, which removes the potentially sensitive numeric and string literal values. High security mode settings When you enable high security mode, the default settings are locked so that users cannot change them. In addition: The agent does not collect message queue parameters. You cannot create custom events. The agent strips exception messages from errors. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: Python agent configuration file Custom attributes Python agent API Tip Some of these settings can be changed using environment variables. See Python agent environment variables for the complete list. Setting Effects on data security audit_log_file string Default: (none) If you use this to set the name of the audit log file, the agent will log details of messages passed back and forth between the monitored process and the data collector. You can then evaluate the information that the agent sends to the collector to see if it includes sensitive information. high_security boolean Default: false To enable high security mode, set this to true and enable high security. This restricts the information you can send. proxy_host string Default: (none) Some proxies default to using HTTP, which is a less secure protocol. attributes.enabled boolean Default: true By default, you are sending attributes. If you do not want to send attributes, set this to false. attributes.exclude string Default: (none) If there are specific attribute keys that you do not want to send in transaction traces, identify them using attributes.exclude. This restricts the information sent. Consider if you want to exclude these potentially sensitive attributes using attributes.exclude or if you need the information sent: request.headers.*: Removes all request headers. (Note that HTTP headers that contain sensitive data such as cookie and authorization are never collected.) response.headers.*: Removes all response headers. custom_insights_events.enabled boolean Default: true By default, the agent records events sent to the Event API via record_custom_event(). If you enable high security mode, this is automatically set to false. transaction_tracer.record_sql string Default: obfuscated By default, transaction_tracer.record_sql is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to off. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. strip_exception_messages.enabled boolean Default: false If you enable high security mode, this is automatically set to true. If you are not using high security mode but want to strip messages from all exceptions except those in your allow list, set this to true.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 101.93765,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>agent</em> security: Python",
        "sections": "APM <em>agent</em> security: Python",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": "The Python <em>agent</em> default security settings automatically provide security for your data to ensure data privacy and to limit the kind of information we ingest. You may have business reasons to change these settings. If you want to restrict the information that we ingest you can enable high security"
      },
      "id": "6044103f64441fbcef378ef7"
    }
  ],
  "/docs/agents/java-agent/heroku/java-agent-heroku": [
    {
      "sections": [
        "No data appears with Heroku (Java)",
        "Problem",
        "Solution"
      ],
      "title": "No data appears with Heroku (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "b08d6638b319ee5716e462566e8a8ad54a63fec5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/no-data-appears-heroku-java/",
      "published_at": "2021-06-02T15:12:06Z",
      "updated_at": "2021-03-11T03:21:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem After waiting a few minutes, data is not appearing in your Heroku app's APM Summary page. Solution Check the Heroku logs for errors with this Heroku toolbelt command: heroku logs --tail Copy Check that the files in your Heroku dyno match the file modifications from the Java on Heroku or Java with Scala on Heroku installation procedures. Use this Heroku toolbelt command: heroku run bash Copy Try the steps in No data appears (Java).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.46214,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No data appears with <em>Heroku</em> (<em>Java</em>)",
        "sections": "No data appears with <em>Heroku</em> (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem After waiting a few minutes, data is not appearing in your <em>Heroku</em> app&#x27;s APM Summary page. Solution Check the <em>Heroku</em> logs for errors with this <em>Heroku</em> toolbelt command: <em>heroku</em> logs --tail Copy Check that the files in your <em>Heroku</em> dyno match the file modifications from the <em>Java</em> on <em>Heroku</em> or <em>Java</em> with Scala on <em>Heroku</em> installation procedures. Use this <em>Heroku</em> toolbelt command: <em>heroku</em> run bash Copy Try the steps in No data appears (<em>Java</em>)."
      },
      "id": "6043b7c9e7b9d29b015799da"
    },
    {
      "sections": [
        "Java agent with Scala on Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic add-on",
        "Caution",
        "2. Configure your Heroku environment for New Relic",
        "Custom build.sbt",
        "How to download a custom newrelic.yml",
        "3. Push your changes and open the app",
        "Troubleshooting your installation",
        "For more help"
      ],
      "title": "Java agent with Scala on Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "3e132d7c22df97d5cd8e189047cec608d77f06fd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-scala-heroku/",
      "published_at": "2021-06-02T15:23:16Z",
      "updated_at": "2021-03-11T03:21:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and Browser. Tip For non-Scala installations, see Java agent and Heroku. Compatibility and requirements Java 7 or higher Latest New Relic Java agent version 1. Enable the New Relic add-on After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install New Relic APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Configure your Heroku environment for New Relic After you complete the requirements and enable the New Relic add-on, configure your Scala Heroku environment for New Relic: Edit your Procfile to point to the agent jar in your app's root folder. Replace the contents of the file, substituting X.Y.Z with the latest agent version: web: target/universal/stage/bin/play-getting-started -Dhttp.port=${PORT} -J-javaagent:/app/target/universal/stage/lib/com.newrelic.agent.java.newrelic-agent-X.Y.Z.jar -J-Dnewrelic.config.file=conf/newrelic.yml Copy OR Identify the path to newrelic.jar with the JAVA_OPTS environment variable. Edit your build.sbt. Call the agent, substituting X.Y.Z with the latest Java agent version: Custom build.sbt name := \"\"\"play-getting-started\"\"\" version := \"1.0-SNAPSHOT\" lazy val root = (project in file(\".\")).enablePlugins(PlayScala) scalaVersion := \"2.11.7\" libraryDependencies ++= Seq( jdbc, cache, \"org.postgresql\" % \"postgresql\" % \"9.4-1201-jdbc41\", ws ) libraryDependencies <+= scalaVersion(\"org.scala-lang\" % \"scala-compiler\" % _ ) libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-agent\" % \"X.Y.Z\") libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\") Copy Download a customized newrelic.yml file from your APM account settings: How to download a custom newrelic.yml Log in to dashboard.heroku.com. Select your app. Select Add-ons > New Relic APM. From the New Relic UI's account dropdown, select Account settings. In the Update your New Relic agent section, download the latest agent for your Java SE release. Unzip the downloaded file. Copy newrelic.yml to the scala-getting-started/conf directory: Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 3. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshooting your installation If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find More Add Ons, and add the APM add-on. If no data appears after waiting a few minutes, see No data appears with Heroku (Java). For more help Additional documentation resources include: Java agent and Heroku (for non-Scala installation on Heroku) No data appears with Heroku (troubleshotoing steps after installation) Scala installation for Java (Scala installation if you don't use Heroku)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.46214,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> with Scala on <em>Heroku</em>",
        "sections": "<em>Java</em> <em>agent</em> with Scala on <em>Heroku</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "<em>Heroku</em> is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including Scala. With New Relic, you can extend <em>Heroku</em> with metrics from APM and Browser. Tip For non-Scala installations, see <em>Java</em> <em>agent</em> and <em>Heroku</em>. Compatibility and requirements <em>Java</em> 7"
      },
      "id": "6043b879196a670bb4960f4b"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.19377,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " the <em>Java</em> <em>agent</em> on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment <em>Heroku</em> Asynchronous instrumentation For supported frameworks, the <em>Java</em> <em>agent</em> usually instruments async work"
      },
      "id": "6043b8f6196a6771a9960f87"
    }
  ],
  "/docs/agents/java-agent/heroku/java-agent-scala-heroku": [
    {
      "sections": [
        "No data appears with Heroku (Java)",
        "Problem",
        "Solution"
      ],
      "title": "No data appears with Heroku (Java)",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "b08d6638b319ee5716e462566e8a8ad54a63fec5",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/no-data-appears-heroku-java/",
      "published_at": "2021-06-02T15:12:06Z",
      "updated_at": "2021-03-11T03:21:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem After waiting a few minutes, data is not appearing in your Heroku app's APM Summary page. Solution Check the Heroku logs for errors with this Heroku toolbelt command: heroku logs --tail Copy Check that the files in your Heroku dyno match the file modifications from the Java on Heroku or Java with Scala on Heroku installation procedures. Use this Heroku toolbelt command: heroku run bash Copy Try the steps in No data appears (Java).",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.46214,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No data appears with <em>Heroku</em> (<em>Java</em>)",
        "sections": "No data appears with <em>Heroku</em> (<em>Java</em>)",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "Problem After waiting a few minutes, data is not appearing in your <em>Heroku</em> app&#x27;s APM Summary page. Solution Check the <em>Heroku</em> logs for errors with this <em>Heroku</em> toolbelt command: <em>heroku</em> logs --tail Copy Check that the files in your <em>Heroku</em> dyno match the file modifications from the <em>Java</em> on <em>Heroku</em> or <em>Java</em> with Scala on <em>Heroku</em> installation procedures. Use this <em>Heroku</em> toolbelt command: <em>heroku</em> run bash Copy Try the steps in No data appears (<em>Java</em>)."
      },
      "id": "6043b7c9e7b9d29b015799da"
    },
    {
      "sections": [
        "Java agent and Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic agent add-on in Heroku",
        "Caution",
        "2. Provide the path to the jar file",
        "Deploy to Heroku",
        "Deploy locally",
        "3. Configure your Heroku environment for New Relic",
        "Maven configuration",
        "Manual configuration",
        "4. Push your changes and open the app",
        "Troubleshoot",
        "For more help"
      ],
      "title": "Java agent and Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "24069e33fc3bf337ebce684631a398f68eeb4d3b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-heroku/",
      "published_at": "2021-06-02T15:23:16Z",
      "updated_at": "2021-03-11T02:28:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Java. With New Relic, you can extend Heroku with metrics from APM or Browser. Tip If you use Scala, see Java agent Scala procedures for Heroku. Compatibility and requirements Java 7 or higher Maven 3 or higher (if you are using Maven) Latest New Relic Java agent version 1. Enable the New Relic agent add-on in Heroku After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install New Relic APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Provide the path to the jar file After you enable the New Relic agent add-on, pass the javaagent flag to the java process and provide the path to the jar file by editing your Procfile. Deploy to Heroku If you deploy to Heroku, the location of the jar file for both Maven and manual configuration is in the app's root folder in a directory called newrelic. Example: web: java -javaagent:/app/newrelic/newrelic.jar -jar target/HELLOWORLD.jar Copy Deploy locally If you deploy locally, your jar file might be in a different directory. If it is, replace PATH/TO/NEWRELIC.JAR with the path to the jar file in your local directory. Example: web: java -javaagent:PATH/TO/NEWRELIC.JAR -jar target/HELLOWORLD.jar Copy 3. Configure your Heroku environment for New Relic After you provide the path to the jar file, configure your Heroku environment for New Relic, depending on your platform: Maven configuration Give your app a meaningful name with this Heroku toolbelt command: heroku config:set NEW_RELIC_APP_NAME=\"APP_NAME\" Copy Add your New Relic license key: heroku config:set NEW_RELIC_LICENSE_KEY=\"LICENSE_KEY\" Copy In your pom.xml, add the newrelic-agent dependency, substituting X.Y.Z with the latest Java agent version. Recommended: To ensure proper formatting is applied and contents do not contain sensitive information, format the syntax using http://codebeautify.org/xmlviewer. <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>X.Y.Z</version> <scope>provided</scope> <type>zip</type> </dependency> Copy In the <build> element of pom.xml, customize the build so it downloads the agent: <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.0.2</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.basedir}</outputDirectory> <destFileName>newrelic</destFileName> </configuration> </execution> </executions> </plugin> Copy Manual configuration Log in to dashboard.heroku.com. Select your app. Select Add-ons > New Relic APM. From the New Relic UI's account dropdown, select Account settings. In the Update your New Relic agent section, download the latest agent release for your Java SE release. Unzip the file into your app root. Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 4. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshoot Here are some tips to help you troubleshoot: If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find More Add Ons, and add the APM add-on. If no data appears after waiting a few minutes, follow the troubleshooting procedures for Heroku (Java). For more help Additional documentation resources include: Heroku and New Relic (additional topics for Heroku users) Heroku Dev Center (information on the Heroku site on installing New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.45729,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> and <em>Heroku</em>",
        "sections": "<em>Java</em> <em>agent</em> and <em>Heroku</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "<em>Heroku</em> is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including <em>Java</em>. With New Relic, you can extend <em>Heroku</em> with metrics from APM or Browser. Tip If you use Scala, see <em>Java</em> <em>agent</em> Scala procedures for <em>Heroku</em>. Compatibility and requirements <em>Java</em> 7"
      },
      "id": "6043ba0f64441f731e378ee0"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.19377,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " the <em>Java</em> <em>agent</em> on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment <em>Heroku</em> Asynchronous instrumentation For supported frameworks, the <em>Java</em> <em>agent</em> usually instruments async work"
      },
      "id": "6043b8f6196a6771a9960f87"
    }
  ],
  "/docs/agents/java-agent/heroku/no-data-appears-heroku-java": [
    {
      "sections": [
        "Java agent with Scala on Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic add-on",
        "Caution",
        "2. Configure your Heroku environment for New Relic",
        "Custom build.sbt",
        "How to download a custom newrelic.yml",
        "3. Push your changes and open the app",
        "Troubleshooting your installation",
        "For more help"
      ],
      "title": "Java agent with Scala on Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "3e132d7c22df97d5cd8e189047cec608d77f06fd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-scala-heroku/",
      "published_at": "2021-06-02T15:23:16Z",
      "updated_at": "2021-03-11T03:21:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Scala. With New Relic, you can extend Heroku with metrics from APM and Browser. Tip For non-Scala installations, see Java agent and Heroku. Compatibility and requirements Java 7 or higher Latest New Relic Java agent version 1. Enable the New Relic add-on After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install New Relic APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Configure your Heroku environment for New Relic After you complete the requirements and enable the New Relic add-on, configure your Scala Heroku environment for New Relic: Edit your Procfile to point to the agent jar in your app's root folder. Replace the contents of the file, substituting X.Y.Z with the latest agent version: web: target/universal/stage/bin/play-getting-started -Dhttp.port=${PORT} -J-javaagent:/app/target/universal/stage/lib/com.newrelic.agent.java.newrelic-agent-X.Y.Z.jar -J-Dnewrelic.config.file=conf/newrelic.yml Copy OR Identify the path to newrelic.jar with the JAVA_OPTS environment variable. Edit your build.sbt. Call the agent, substituting X.Y.Z with the latest Java agent version: Custom build.sbt name := \"\"\"play-getting-started\"\"\" version := \"1.0-SNAPSHOT\" lazy val root = (project in file(\".\")).enablePlugins(PlayScala) scalaVersion := \"2.11.7\" libraryDependencies ++= Seq( jdbc, cache, \"org.postgresql\" % \"postgresql\" % \"9.4-1201-jdbc41\", ws ) libraryDependencies <+= scalaVersion(\"org.scala-lang\" % \"scala-compiler\" % _ ) libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-agent\" % \"X.Y.Z\") libraryDependencies ++= Seq(\"com.newrelic.agent.java\" % \"newrelic-api\" % \"X.Y.Z\") Copy Download a customized newrelic.yml file from your APM account settings: How to download a custom newrelic.yml Log in to dashboard.heroku.com. Select your app. Select Add-ons > New Relic APM. From the New Relic UI's account dropdown, select Account settings. In the Update your New Relic agent section, download the latest agent for your Java SE release. Unzip the downloaded file. Copy newrelic.yml to the scala-getting-started/conf directory: Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 3. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshooting your installation If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find More Add Ons, and add the APM add-on. If no data appears after waiting a few minutes, see No data appears with Heroku (Java). For more help Additional documentation resources include: Java agent and Heroku (for non-Scala installation on Heroku) No data appears with Heroku (troubleshotoing steps after installation) Scala installation for Java (Scala installation if you don't use Heroku)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.46214,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> with Scala on <em>Heroku</em>",
        "sections": "<em>Java</em> <em>agent</em> with Scala on <em>Heroku</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "<em>Heroku</em> is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including Scala. With New Relic, you can extend <em>Heroku</em> with metrics from APM and Browser. Tip For non-Scala installations, see <em>Java</em> <em>agent</em> and <em>Heroku</em>. Compatibility and requirements <em>Java</em> 7"
      },
      "id": "6043b879196a670bb4960f4b"
    },
    {
      "sections": [
        "Java agent and Heroku",
        "Tip",
        "Compatibility and requirements",
        "1. Enable the New Relic agent add-on in Heroku",
        "Caution",
        "2. Provide the path to the jar file",
        "Deploy to Heroku",
        "Deploy locally",
        "3. Configure your Heroku environment for New Relic",
        "Maven configuration",
        "Manual configuration",
        "4. Push your changes and open the app",
        "Troubleshoot",
        "For more help"
      ],
      "title": "Java agent and Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Heroku"
      ],
      "external_id": "24069e33fc3bf337ebce684631a398f68eeb4d3b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/heroku/java-agent-heroku/",
      "published_at": "2021-06-02T15:23:16Z",
      "updated_at": "2021-03-11T02:28:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Java. With New Relic, you can extend Heroku with metrics from APM or Browser. Tip If you use Scala, see Java agent Scala procedures for Heroku. Compatibility and requirements Java 7 or higher Maven 3 or higher (if you are using Maven) Latest New Relic Java agent version 1. Enable the New Relic agent add-on in Heroku After you ensure that you meet the requirements, enable the New Relic agent add-on in Heroku. Caution You must deploy your Java app to Heroku, following the Heroku instructions at least through the Deploy the app step, before you can enable the New Relic agent add-on. Log in to your Heroku account. From the APM Add-On Page, select a subscription plan. Select Install New Relic APM, and then select your target app from the dropdown. Installing the add-on automatically creates a New Relic account and configures access for Heroku servers. 2. Provide the path to the jar file After you enable the New Relic agent add-on, pass the javaagent flag to the java process and provide the path to the jar file by editing your Procfile. Deploy to Heroku If you deploy to Heroku, the location of the jar file for both Maven and manual configuration is in the app's root folder in a directory called newrelic. Example: web: java -javaagent:/app/newrelic/newrelic.jar -jar target/HELLOWORLD.jar Copy Deploy locally If you deploy locally, your jar file might be in a different directory. If it is, replace PATH/TO/NEWRELIC.JAR with the path to the jar file in your local directory. Example: web: java -javaagent:PATH/TO/NEWRELIC.JAR -jar target/HELLOWORLD.jar Copy 3. Configure your Heroku environment for New Relic After you provide the path to the jar file, configure your Heroku environment for New Relic, depending on your platform: Maven configuration Give your app a meaningful name with this Heroku toolbelt command: heroku config:set NEW_RELIC_APP_NAME=\"APP_NAME\" Copy Add your New Relic license key: heroku config:set NEW_RELIC_LICENSE_KEY=\"LICENSE_KEY\" Copy In your pom.xml, add the newrelic-agent dependency, substituting X.Y.Z with the latest Java agent version. Recommended: To ensure proper formatting is applied and contents do not contain sensitive information, format the syntax using http://codebeautify.org/xmlviewer. <dependency> <groupId>com.newrelic.agent.java</groupId> <artifactId>newrelic-java</artifactId> <version>X.Y.Z</version> <scope>provided</scope> <type>zip</type> </dependency> Copy In the <build> element of pom.xml, customize the build so it downloads the agent: <plugin> <groupId>org.apache.maven.plugins</groupId> <artifactId>maven-dependency-plugin</artifactId> <version>3.0.2</version> <executions> <execution> <id>unpack-newrelic</id> <phase>package</phase> <goals> <goal>unpack-dependencies</goal> </goals> <configuration> <includeGroupIds>com.newrelic.agent.java</includeGroupIds> <includeArtifactIds>newrelic-java</includeArtifactIds> <overWriteReleases>false</overWriteReleases> <overWriteSnapshots>false</overWriteSnapshots> <overWriteIfNewer>true</overWriteIfNewer> <outputDirectory>${project.basedir}</outputDirectory> <destFileName>newrelic</destFileName> </configuration> </execution> </executions> </plugin> Copy Manual configuration Log in to dashboard.heroku.com. Select your app. Select Add-ons > New Relic APM. From the New Relic UI's account dropdown, select Account settings. In the Update your New Relic agent section, download the latest agent release for your Java SE release. Unzip the file into your app root. Edit newrelic.yml to customize the app_name setting with a descriptive app name. Also in newrelic.yml, add your license key to the license_key setting. 4. Push your changes and open the app After you configure your Heroku environment for New Relic, push your changes and open the app to monitor it with New Relic. Push your changes to the dyno with this Heroku toolbelt command: git add . git commit -m 'YOUR COMMIT MESSAGE' git push heroku master Copy Open your app in your browser with this Heroku toolbelt command: heroku open Copy Generate some traffic to your app and wait a few minutes. Check your app's performance in Heroku by selecting your app and then selecting the New Relic add-on. If no data appears or if you have problems, follow the troubleshooting tips. Troubleshoot Here are some tips to help you troubleshoot: If you don't see the New Relic add-on after you generate traffic, go to Heroku, select Find More Add Ons, and add the APM add-on. If no data appears after waiting a few minutes, follow the troubleshooting procedures for Heroku (Java). For more help Additional documentation resources include: Heroku and New Relic (additional topics for Heroku users) Heroku Dev Center (information on the Heroku site on installing New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.45729,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Java</em> <em>agent</em> and <em>Heroku</em>",
        "sections": "<em>Java</em> <em>agent</em> and <em>Heroku</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "<em>Heroku</em> is a Platform as a Service (PaaS) solution for hosting web applications in various <em>agent</em> languages, including <em>Java</em>. With New Relic, you can extend <em>Heroku</em> with metrics from APM or Browser. Tip If you use Scala, see <em>Java</em> <em>agent</em> Scala procedures for <em>Heroku</em>. Compatibility and requirements <em>Java</em> 7"
      },
      "id": "6043ba0f64441f731e378ee0"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.19371,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " the <em>Java</em> <em>agent</em> on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment <em>Heroku</em> Asynchronous instrumentation For supported frameworks, the <em>Java</em> <em>agent</em> usually instruments async work"
      },
      "id": "6043b8f6196a6771a9960f87"
    }
  ],
  "/docs/agents/java-agent/index": [
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 101.91583,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the instrumentation package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]instrumentation.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate configuration to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    },
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 101.48221,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic <em>Java</em> <em>agent</em>. If the <em>Java</em> <em>agent</em> is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the <em>agent</em> will then report to the same"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.49041,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> API lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This API consists of: Static methods on the com.newrelic.api.<em>agent</em>.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    }
  ],
  "/docs/agents/java-agent/installation/include-java-agent-jvm-argument": [
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.40413,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "<em>Installation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic <em>Java</em> <em>agent</em>. If the <em>Java</em> <em>agent</em> is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the <em>agent</em> will then report to the same"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.924484,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "-in instrumentation After you install the <em>Java</em> <em>agent</em>, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the <em>agent</em> collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of <em>installation</em>. Even if your library"
      },
      "id": "6043b8f6196a6771a9960f87"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.32201,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic <em>Java</em> <em>agent</em>&#x27;s <em>installation</em> zip file. You can call the API when the <em>Java</em> <em>agent</em> is not running. The API methods are just stubs; the implementation is added"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    }
  ],
  "/docs/agents/java-agent/installation/install-java-agent-java-2-security": [
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.68004,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "<em>Installation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic <em>Java</em> <em>agent</em>. If the <em>Java</em> <em>agent</em> is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the <em>agent</em> will then report to the same"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "WildFly installation for Java",
        "Install WildFly versions earlier than 11",
        "Install WildFly version 11 or higher"
      ],
      "title": "WildFly installation for Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "7f9259f3b77efb78cd4861a9d7b519fe44191e3c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/wildfly-installation-java/",
      "published_at": "2021-06-02T15:31:27Z",
      "updated_at": "2021-03-16T14:29:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before you install New Relic's Java agent, make sure your WildFly version is supported. Depending on which WildFly version your application uses, additional configuration steps may be required. Install WildFly versions earlier than 11 If your supported WildFly version is earlier than v11, follow standard Java installation procedures. You do not need to do any additional configuration. Install WildFly version 11 or higher If you use WildFly version 11 or higher, New Relic's Java agent requires additional configuration after you install it. Install the Java agent. If you already have it installed, update to the latest Java agent version. Versions 5.0.0 and higher include fixes for later WildFly versions 11 and higher. Open the standalone configuration file appropriate for your operating system and add the -javaagent property to JAVA_OPTS. For example, if you use Linux, edit the /bin/standalone.conf file or /bin/standalone.conf.bat for Windows. Make sure the agent jar is visible to all JBoss modules by adding com.newrelic to the JBoss modules system packages using either of these options in the standalone script: Recommended: Option 1 (same as adding -javaagent property): JAVA_OPTS=\"$JAVA_OPTS -Djboss.modules.system.pkgs=$JBOSS_MODULES_SYSTEM_PKGS,com.newrelic Copy Option 2: if [ \"x$JBOSS_MODULES_SYSTEM_PKGS\" = \"x\" ]; then JBOSS_MODULES_SYSTEM_PKGS=\"org.jboss.byteman,com.newrelic\" fi Copy Restart your application server.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.519356,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "WildFly <em>installation</em> for <em>Java</em>",
        "sections": "WildFly <em>installation</em> for <em>Java</em>",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": " standard <em>Java</em> <em>installation</em> procedures. You do not need to do any <em>additional</em> configuration. Install WildFly version 11 or higher If you use WildFly version 11 or higher, New Relic&#x27;s <em>Java</em> <em>agent</em> requires <em>additional</em> configuration after you install it. Install the <em>Java</em> <em>agent</em>. If you already have"
      },
      "id": "603e791764441f18724e88ab"
    },
    {
      "sections": [
        "Install New Relic Java agent for Docker",
        "Tip",
        "Get the Java agent",
        "Download using curl",
        "Download using Invoke-WebRequest (PowerShell)",
        "Download from the New Relic UI",
        "Set up the installation directory",
        "Modify startup scripts",
        "Set agent configurations",
        "Application name",
        "License key",
        "Logs",
        "Environment (optional)",
        "Important",
        "Enabled (optional)",
        "Additional Tomcat Dockerfile examples",
        "Tomcat with environment and Java system properties",
        "How to start an application with the Java agent",
        "Next steps"
      ],
      "title": "Install New Relic Java agent for Docker",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Additional installation"
      ],
      "external_id": "4de0ccd173c9851b045cfa036089e2f703b4a0f7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/additional-installation/install-new-relic-java-agent-docker/",
      "published_at": "2021-06-02T18:13:26Z",
      "updated_at": "2021-03-16T14:29:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains a basic installation of the APM agent for Java applications in a Docker container. We discuss required configurations and also explore some optional configurations, including: How to use identical New Relic configuration files for each container, regardless of the environment where the containers are used How to use the Docker layer when every agent in every environment needs slightly different configuration data How to disable the New Relic agent in some environments and enable it in others Although we don't discuss advanced options here, you can install the Java agent in Docker volumes and use your Docker container image in other software such as Swarm, ECS, AKS, EKS, OpenShift, and Kubernetes. Our Docker examples refer to Tomcat, so if you are using another application server, refer to your vendor’s documentation. Tip To use Java or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Get the Java agent Download newrelic-java.zip using curl, Invoke-WebRequest (PowerShell), or the New Relic UI: Download using curl Complete the following: Start a command-line session. Change to a temporary directory where you can download the zip file. Execute this curl command: curl -O https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip Copy Unzip newrelic-java.zip Download using Invoke-WebRequest (PowerShell) Complete the following: Start a PowerShell session. Change to a temporary directory where you can download the zip file. Execute this PowerShell command: Invoke-WebRequest -Uri https://download.newrelic.com/newrelic/java-agent/newrelic-agent/current/newrelic-java.zip -OutFile newrelic-java.zip Copy Unzip newrelic-java.zip: Expand-Archive -Path newrelic-java.zip -DestinationPath DESTINATION_PATH Copy Download from the New Relic UI Complete the following: Log in to New Relic. From the account dropdown in the New Relic UI, select Account settings. In the right sidebar under Most recent, select the Java agent, and save the newrelic-java.zip to a temporary directory. Unzip newrelic-java.zip. Set up the installation directory You can unzip the newrelic-java.zip file wherever it is convenient for you. In the subsequent sections we assume you extracted it in the current working directory, which puts the files we need in ./newrelic. Modify startup scripts The startup script that contains the command to start your application server must include Java’s built-in argument -javaagent. We recommend that you set this argument with the JAVA_OPTS environment variable. The value of that argument must contain the location where you ADD the Java APM agent’s jar file to the image. For example, with Tomcat, use commands like these in the Dockerfile: RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/newrelic.jar ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" Copy Set agent configurations By default, agent behavior is controlled by configuration entries in newrelic.yml, which is typically located in the same directory as the agent. This section explains how to override these newrelic.yml configurations by using environment variables or Java system properties in the Dockerfile. Before we look at some specific configurations, here’s how to load newrelic.yml using the Dockerfile: ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/newrelic.yml Copy For a basic Docker installation, complete these configurations: Application name License key Logs Environment (optional) Enabled (optional) Application name The application name is a configuration you set to identify your application in New Relic. Tip You can reuse an application name for multiple apps serving the same role so that all the data from those apps rolls up into the same logical application in New Relic. For more detail about additional grouping options, see Use multiple names for an app. Replace MY_APP_NAME with your application name in one of these Dockerfile commands: Option Command Environment variable ENV NEW_RELIC_APP_NAME=\"MY_APP_NAME\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='MY_APP_NAME'\" Copy After you boot the container, your application name appears in New Relic. License key This configuration is required for you to report on any data in your New Relic Account. To copy your license key: Go to one.newrelic.com > (account dropdown) > Account settings. Under Account information, copy the license key. In one of these Dockerfile commands, replace MY_LICENSE_KEY with your license key: Option Command Environment variable ENV NEW_RELIC_LICENSE_KEY=\"MY_LICENSE_KEY\" Copy Java system property ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.license_key='MY_LICENSE_KEY'\" Copy Logs By default, logs are written into the logs directory relative to the location of newrelic.jar. Make sure that the user account that starts your application server also has the right to perform tasks such as: Creating the logs directory. Creating and appending to the log files in that directory. Here’s a Dockerfile example where tomcat is the user who starts Tomcat: RUN mkdir -p /usr/local/tomcat/newrelic/logs RUN chown -R tomcat:tomcat /usr/local/tomcat/newrelic/logs Copy You can also send the logs to STDOUT by adding one of the following to the Dockerfile: Option Command Environment Variable ENV NEW_RELIC_LOG_FILE_NAME=STDOUT Copy Java system property ENV JAVA_OPTS=-Dnewrelic.config.log_file_name=STDOUT Copy Environment (optional) You can pass either a Java property or an environment variable to determine which of the environment-specific stanzas the agent uses in newrelic.yml. Use this approach if you prefer to have the newrelic.yml file control environment-specific configurations instead of passing all the configurations via Docker. Here’s a Dockerfile example of passing the newrelic.environment Java system property via Docker to use the custom value dev in the environment stanza of newrelic.yml: Using the shell form of the CMD instruction, include a reference to a new environment variable you choose (for example, ENV): CMD java -Dnewrelic.environment=$ENV -jar myjar.jar Copy In your docker run command line, include an argument to set the environment variable in the container: docker run -it -e \"ENV=dev\" myDockerImage Copy Important If you don’t specify a value for newrelic.environment, the agent assumes it is running in your production environment and uses the values from the main body of the configuration file. Enabled (optional) This configuration controls whether the agent is enabled. Let’s say you want the same Docker image for every installation. However, you don’t want to run the New Relic agent every time an engineer spins up a test app because you don’t want to run up your instance count. This problem can be solved using the newrelic.environment Java system property. In the main body of newrelic.yml, disable the Java agent by setting enabled: false. In specific environment stanzas of newrelic.yml, set enabled: true. Then, you can run specific agents by specifying the environment at runtime. Additional Tomcat Dockerfile examples Tomcat with environment and Java system properties FROM tomcat:9 # Add the newrelic.jar and -javaagent parameters RUN mkdir -p /usr/local/tomcat/newrelic ADD ./newrelic/newrelic.jar /usr/local/tomcat/newrelic/ ENV JAVA_OPTS=\"$JAVA_OPTS -javaagent:/usr/local/tomcat/newrelic/newrelic.jar\" # Add the configuration file ADD ./newrelic/newrelic.yml /usr/local/tomcat/newrelic/ # An example of setting a system property config ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.app_name='My Application'\" # An example of setting an Environment variable config ENV NEW_RELIC_LICENSE_KEY=\"license_key\" # Config to include the agent logs in Docker's stdout logging ENV JAVA_OPTS=\"$JAVA_OPTS -Dnewrelic.config.log_file_name=STDOUT\" EXPOSE 8080 CMD [\"catalina.sh\", \"run\"] Copy How to start an application with the Java agent FROM openjdk:8 ADD my-application.jar /app ADD newrelic.jar /app ADD newrelic.yml /app ENV NEW_RELIC_APP_NAME=\"My Application\" ENV NEW_RELIC_LICENSE_KEY=\"license_key\" ENV NEW_RELIC_LOG_FILE_NAME=\"STDOUT\" ENTRYPOINT [\"java\",\"-javaagent:/app/newrelic.jar\",\"-jar\",\"/app/my-application.jar\"] Copy Next steps Now that you have a basic agent installation in Docker, here are some additional steps to consider: Review other configurations for the agent. Read a detailed Explorers Hub post about Docker and New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.519356,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "sections": "<em>Install</em> New Relic <em>Java</em> <em>agent</em> for Docker",
        "tags": "<em>Additional</em> <em>installation</em>",
        "body": "This document explains a basic <em>installation</em> of the APM <em>agent</em> for <em>Java</em> applications in a Docker container. We discuss required configurations and also explore some optional configurations, including: How to use identical New Relic configuration files for each container, regardless of the environment"
      },
      "id": "603ea3dc28ccbc8889eba765"
    }
  ],
  "/docs/agents/java-agent/installation/install-java-agent": [
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.40407,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "<em>Installation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic <em>Java</em> <em>agent</em>. If the <em>Java</em> <em>agent</em> is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the <em>agent</em> will then report to the same"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.92442,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "-in instrumentation After you install the <em>Java</em> <em>agent</em>, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the <em>agent</em> collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of <em>installation</em>. Even if your library"
      },
      "id": "6043b8f6196a6771a9960f87"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.32195,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic <em>Java</em> <em>agent</em>&#x27;s <em>installation</em> zip file. You can call the API when the <em>Java</em> <em>agent</em> is not running. The API methods are just stubs; the implementation is added"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    }
  ],
  "/docs/agents/java-agent/installation/uninstall-java-agent": [
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.40407,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "<em>Installation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic <em>Java</em> <em>agent</em>. If the <em>Java</em> <em>agent</em> is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the <em>agent</em> will then report to the same"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.92442,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "-in instrumentation After you install the <em>Java</em> <em>agent</em>, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the <em>agent</em> collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of <em>installation</em>. Even if your library"
      },
      "id": "6043b8f6196a6771a9960f87"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.32195,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic <em>Java</em> <em>agent</em>&#x27;s <em>installation</em> zip file. You can call the API when the <em>Java</em> <em>agent</em> is not running. The API methods are just stubs; the implementation is added"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    }
  ],
  "/docs/agents/java-agent/installation/update-java-agent": [
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.40401,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "<em>Installation</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic <em>Java</em> <em>agent</em>. If the <em>Java</em> <em>agent</em> is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the <em>agent</em> will then report to the same"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.92437,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "-in instrumentation After you install the <em>Java</em> <em>agent</em>, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the <em>agent</em> collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of <em>installation</em>. Even if your library"
      },
      "id": "6043b8f6196a6771a9960f87"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.3219,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic <em>Java</em> <em>agent</em>&#x27;s <em>installation</em> zip file. You can call the API when the <em>Java</em> <em>agent</em> is not running. The API methods are just stubs; the implementation is added"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    }
  ],
  "/docs/agents/java-agent/instrumentation/extension-additional-instrumentation-modules": [
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.99341,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the <em>instrumentation</em> package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]<em>instrumentation</em>.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate configuration to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.05023,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> API lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This API consists of: Static methods on the com.newrelic.api.<em>agent</em>.NewRelic class A @Trace annotation for implementing custom <em>instrumentation</em> A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 133.40321,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " the APM and Browser data for a particular app. For configuration options and manual <em>instrumentation</em>, see Browser monitoring and the <em>Java</em> <em>agent</em>. Infrastructure monitoring When you install the Infrastructure and APM <em>agents</em> on the same host, they automatically detect one another. You can then view"
      },
      "id": "6043b8f6196a6771a9960f87"
    }
  ],
  "/docs/agents/java-agent/instrumentation/ignore-transactions-using-api": [
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.99335,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the <em>instrumentation</em> package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]<em>instrumentation</em>.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate configuration to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.05017,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> API lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This API consists of: Static methods on the com.newrelic.api.<em>agent</em>.NewRelic class A @Trace annotation for implementing custom <em>instrumentation</em> A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 133.40314,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " the APM and Browser data for a particular app. For configuration options and manual <em>instrumentation</em>, see Browser monitoring and the <em>Java</em> <em>agent</em>. Infrastructure monitoring When you install the Infrastructure and APM <em>agents</em> on the same host, they automatically detect one another. You can then view"
      },
      "id": "6043b8f6196a6771a9960f87"
    }
  ],
  "/docs/agents/java-agent/instrumentation/instrument-browser-monitoring-java-agent-api": [
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.99335,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the <em>instrumentation</em> package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]<em>instrumentation</em>.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate configuration to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.05017,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> API lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This API consists of: Static methods on the com.newrelic.api.<em>agent</em>.NewRelic class A @Trace annotation for implementing custom <em>instrumentation</em> A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 133.40314,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " the APM and Browser data for a particular app. For configuration options and manual <em>instrumentation</em>, see Browser monitoring and the <em>Java</em> <em>agent</em>. Infrastructure monitoring When you install the Infrastructure and APM <em>agents</em> on the same host, they automatically detect one another. You can then view"
      },
      "id": "6043b8f6196a6771a9960f87"
    }
  ],
  "/docs/agents/java-agent/instrumentation/java-agent-instrument-kafka-message-queues": [
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.99335,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the <em>instrumentation</em> package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]<em>instrumentation</em>.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate configuration to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.05017,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> API lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This API consists of: Static methods on the com.newrelic.api.<em>agent</em>.NewRelic class A @Trace annotation for implementing custom <em>instrumentation</em> A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 133.40314,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " the APM and Browser data for a particular app. For configuration options and manual <em>instrumentation</em>, see Browser monitoring and the <em>Java</em> <em>agent</em>. Infrastructure monitoring When you install the Infrastructure and APM <em>agents</em> on the same host, they automatically detect one another. You can then view"
      },
      "id": "6043b8f6196a6771a9960f87"
    }
  ],
  "/docs/agents/java-agent/instrumentation/monitor-deployments-java-agent": [
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.99326,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the <em>instrumentation</em> package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]<em>instrumentation</em>.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate configuration to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.05011,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> API lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This API consists of: Static methods on the com.newrelic.api.<em>agent</em>.NewRelic class A @Trace annotation for implementing custom <em>instrumentation</em> A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 133.40308,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " the APM and Browser data for a particular app. For configuration options and manual <em>instrumentation</em>, see Browser monitoring and the <em>Java</em> <em>agent</em>. Infrastructure monitoring When you install the Infrastructure and APM <em>agents</em> on the same host, they automatically detect one another. You can then view"
      },
      "id": "6043b8f6196a6771a9960f87"
    }
  ],
  "/docs/agents/java-agent/instrumentation/transaction-naming-protocol": [
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.99326,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the <em>instrumentation</em> package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]<em>instrumentation</em>.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate configuration to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.05011,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> API lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This API consists of: Static methods on the com.newrelic.api.<em>agent</em>.NewRelic class A @Trace annotation for implementing custom <em>instrumentation</em> A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 133.40308,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " the APM and Browser data for a particular app. For configuration options and manual <em>instrumentation</em>, see Browser monitoring and the <em>Java</em> <em>agent</em>. Infrastructure monitoring When you install the Infrastructure and APM <em>agents</em> on the same host, they automatically detect one another. You can then view"
      },
      "id": "6043b8f6196a6771a9960f87"
    }
  ],
  "/docs/agents/java-agent/instrumentation/use-rabbitmq-or-jms-message-queues": [
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 151.9932,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the <em>instrumentation</em> package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]<em>instrumentation</em>.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate configuration to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 134.05005,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> API lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This API consists of: Static methods on the com.newrelic.api.<em>agent</em>.NewRelic class A @Trace annotation for implementing custom <em>instrumentation</em> A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 133.40302,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " the APM and Browser data for a particular app. For configuration options and manual <em>instrumentation</em>, see Browser monitoring and the <em>Java</em> <em>agent</em>. Infrastructure monitoring When you install the Infrastructure and APM <em>agents</em> on the same host, they automatically detect one another. You can then view"
      },
      "id": "6043b8f6196a6771a9960f87"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/all-hosts-appear-localhost": [
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.0876,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where you’re wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.23978,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the instrumentation package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]instrumentation.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate configuration to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.49014,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> API lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This API consists of: Static methods on the com.newrelic.api.<em>agent</em>.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/application-server-jmx-setup": [
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.08752,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where you’re wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.23972,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the instrumentation package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]instrumentation.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate configuration to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.4901,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> API lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This API consists of: Static methods on the com.newrelic.api.<em>agent</em>.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/determine-permissions-requirements-java": [
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.08752,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where you’re wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.23972,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the instrumentation package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]instrumentation.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate configuration to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.4901,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> API lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This API consists of: Static methods on the com.newrelic.api.<em>agent</em>.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/error-bootstrapping-new-relic-java-agent": [
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.08746,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where you’re wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.23965,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the instrumentation package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]instrumentation.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate configuration to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.49005,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> API lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This API consists of: Static methods on the com.newrelic.api.<em>agent</em>.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/errors-starting-java-app-server": [
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.08746,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where you’re wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.23965,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the instrumentation package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]instrumentation.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate configuration to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.49005,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> API lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This API consists of: Static methods on the com.newrelic.api.<em>agent</em>.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/firewall-or-traffic-connectivity-failures": [
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.0874,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where you’re wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.23958,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the instrumentation package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]instrumentation.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate configuration to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.490005,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> API lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This API consists of: Static methods on the com.newrelic.api.<em>agent</em>.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/gather-troubleshooting-information-java": [
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.0874,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where you’re wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.23958,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the instrumentation package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]instrumentation.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate configuration to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.490005,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> API lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This API consists of: Static methods on the com.newrelic.api.<em>agent</em>.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/generate-debug-logs-troubleshooting-java": [
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.08733,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where you’re wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.2395,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the instrumentation package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]instrumentation.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate configuration to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.48996,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> API lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This API consists of: Static methods on the com.newrelic.api.<em>agent</em>.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/host-links-missing-java-apps-apm-summary": [
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.08733,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where you’re wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.2395,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the instrumentation package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]instrumentation.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate configuration to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.48996,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> API lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This API consists of: Static methods on the com.newrelic.api.<em>agent</em>.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/java-solr-data-does-not-appear": [
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.08733,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where you’re wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.2395,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the instrumentation package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]instrumentation.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate configuration to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.48996,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> API lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This API consists of: Static methods on the com.newrelic.api.<em>agent</em>.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities": [
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.08725,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where you’re wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.489914,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> API lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This API consists of: Static methods on the com.newrelic.api.<em>agent</em>.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.46767,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "sections": "Compatibility and requirements for the <em>Java</em> <em>agent</em>",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the <em>Java</em> <em>agent</em>. Infrastructure monitoring When you install the Infrastructure and APM <em>agents</em> on the same host, they automatically detect one another. You can then view"
      },
      "id": "6043b8f6196a6771a9960f87"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/no-browser-data-appears-java": [
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.08725,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where you’re wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.23944,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the instrumentation package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]instrumentation.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate configuration to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.489914,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> API lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This API consists of: Static methods on the com.newrelic.api.<em>agent</em>.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/no-data-appears-java": [
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.08719,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where you’re wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.23936,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the instrumentation package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]instrumentation.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate configuration to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.48987,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> API lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This API consists of: Static methods on the com.newrelic.api.<em>agent</em>.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/no-log-file-java": [
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.08719,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where you’re wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.23936,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the instrumentation package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]instrumentation.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate configuration to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.48987,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> API lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This API consists of: Static methods on the com.newrelic.api.<em>agent</em>.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/no-stack-traces-java": [
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.08713,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where you’re wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.23929,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the instrumentation package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]instrumentation.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate configuration to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.48982,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> API lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This API consists of: Static methods on the com.newrelic.api.<em>agent</em>.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/nullpointerexception-issues-java": [
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.08713,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where you’re wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.23929,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the instrumentation package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]instrumentation.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate configuration to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.48982,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> API lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This API consists of: Static methods on the com.newrelic.api.<em>agent</em>.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/resolve-metric-grouping-issues-java-apps": [
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.08705,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where you’re wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.23923,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the instrumentation package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]instrumentation.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate configuration to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.489784,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> API lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This API consists of: Static methods on the com.newrelic.api.<em>agent</em>.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/ssl-or-connection-errors-java": [
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.08705,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where you’re wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.23923,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the instrumentation package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]instrumentation.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate configuration to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.489784,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> API lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This API consists of: Static methods on the com.newrelic.api.<em>agent</em>.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    }
  ],
  "/docs/agents/java-agent/troubleshooting/update-java-config-legacy-agent-versions": [
    {
      "sections": [
        "Real-time profiling for Java using JFR metrics",
        "Find performance bottlenecks",
        "JFR daemon",
        "Requirements",
        "Important",
        "Installation",
        "Tip",
        "View your data",
        "Understand JVM cluster behavior over time",
        "JVM details",
        "Identify resource intensive code paths using flamegraphs"
      ],
      "title": "Real-time profiling for Java using JFR metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Features"
      ],
      "external_id": "e37ad20639884cbd94e3032b5b51788eb6d79618",
      "image": "https://docs.newrelic.com/static/d995a7d337779024851a421fcc95ad79/e5166/new-relic-one-java-flight-record-ui.jpg",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/features/real-time-profiling-java-using-jfr-metrics/",
      "published_at": "2021-06-02T15:20:49Z",
      "updated_at": "2021-06-02T15:20:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's real-time profiling for Java using Java Flight Recorder (JFR) metrics, you can run continuous, always-on profiling of your Java code in production environments. The accompanying JVM cluster timeline view provides a fast and intuitive way to diagnose cluster-wide performance problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks Troubleshooting performance bottlenecks in your Java application or service can help you better understand the following: Where you’re wasting resources When an incident occurs What happened during an incident What performance issues led up to an incident To make troubleshooting faster and easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. JFR daemon The New Relic JFR daemon runs as its own Java process and monitors a JVM for JFR events over remote JMX. Using the New Relic Java telemetry SDK as the underlying implementation, the JFR daemon converts JFR events into New Relic telemetry types and reports them to New Relic's metric and event ingest APIs. On startup the JFR daemon checks if the application you are monitoring is also being monitored by the New Relic Java agent. If the Java agent is present, then the daemon will obtain the entity GUID associated with the application. Both the JFR data and the data collected by the agent will then report to the same APM entity. If the the Java agent is not detected, then the daemon will report as a unique entity under the app name that you configured for it. Requirements Requirements include: Java 8 (version 8u262+) or higher for both the JFR daemon process, and the application process An Insert API key or an APM license key. JFR daemon jar. Required for flamegraphs, otherwise optional but recommended: Install of New Relic Java agent version 6.1.0 or higher on your JVM. The JFR daemon can run without a Java agent being included, but if the Java agent is present it will combine agent and daemon data into a single APM application. Important Apps running with the JFR daemon should expect the JFR subsystem to use about 150MB of additional memory. Installation The application that you wish to monitor with the JFR daemon must be configured to expose JFR data over remote JMX by adding the following system properties: -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false Copy Tip By default, the JFR daemon will connect via JMX to localhost on port 1099 and send data to New Relic's US production metric and event ingest endpoints. Additionally, if you need the JFR daemon to report through a proxy that will require special configuration settings. To configure the JFR daemon's behavior, please see the fully documented configuration options. To use the JFR daemon: Download the latest version of the JFR daemon jar: jfr-daemon-n.n.n.jar. Register an Insert API key or an APM license key for publishing data to New Relic. Required: Assign your key to the INSIGHTS_INSERT_KEY environment variable. If you are using an APM license key then you will also need to set the USE_LICENSE_KEY=true environment variable. Recommended: Set the name of the application being monitored to the NEW_RELIC_APP_NAME environment variable. If this is not set, then the default app name will be used instead. Start your application and the JFR daemon: java -jar jfr-daemon-n.n.n.jar Copy Optional (but recommended): Include the Java agent: Install Java agent version 6.1.0 or higher to monitor your application. Configure the Java agent to allow it to communicate with the JMX daemon by adding the following configuration to the newrelic.yml configuration file: jmx: enabled: true linkingMetadataMBean: true Copy Tip Enabling linkingMetadataMBean allows the JFR daemon to acquire the entity GUID that was generated by the Java agent for the application. If the entity GUID is successfully acquired, then data collected by the daemon will be reported to the same application as the Java agent. Any name configured for the daemon using NEW_RELIC_APP_NAMEwould be overridden in favor of the name specified by the agent. View your data To view your data, go to one.newrelic.com > Explorer > (select service) > More Views > Realtime Profiling Java. Understand JVM cluster behavior over time The JVM cluster timeline view shows the JVM behavior across your entire cluster. This timeline enables quicker troubleshooting and issue detection; for example, at a glance you can see: How a recent deployment affected the rest of the JVM cluster When a JVM restarted How an individual instance was affected by its noisy neighbor To make troubleshooting easier, you need to see the high fidelity runtime characteristics of your code running on the JVM, and you need that data in real time. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java: The JVM cluster timeline view shows the JVM behavior across the cluster. Each row of the timeline represents a specific JVM over time. Inside each row, a box represents a 5-minute period of that JVM’s life. From least severe to most severe, yellow, orange, and red traffic lights indicate anomalous behavior for a JVM, so you can drill down into that instance and the right time period when investigating errors or other performance issues. Select How is JVM health determined? for a detailed breakdown of how JVM health is calculated. JVM details The details panel for each JVM provides several critical views: How resources are allocated within a process How garbage collection affects performance How to track garbage collection with logs How CPU is used one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM. Identify resource intensive code paths using flamegraphs Requirements: Early access to our flamegraphs feature is available upon request. All other real-time profiling features are available by default. To request this early access, please email flamegraph@newrelic.com. At this time, this requires deployment of both the JFR daemon and Java agent and the daemon must be reporting as the same entity as the agent. Use flamegraphs to identify the Java classes and methods that are most frequently executed in your application code. By using flamegraphs to optimize the hot spots in your code you can reduce resource consumption and increase your application’s overall performance. one.newrelic.com > Explorer > (select service) > Realtime Profiling Java > (select JVM): You can see details for each JVM, including flamegraphs.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 143.08698,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Real-time profiling for <em>Java</em> using JFR metrics",
        "sections": "Real-time profiling for <em>Java</em> using JFR metrics",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " problems. For example, you can quickly see how an application’s deployment affects the overall health of the cluster. Find performance bottlenecks <em>Troubleshooting</em> performance bottlenecks in your <em>Java</em> application or service can help you better understand the following: Where you’re wasting resources When"
      },
      "id": "603e9db2e7b9d2a5432a07f5"
    },
    {
      "sections": [
        "Large number of false positive security vulnerabilities",
        "Problem",
        "Cause",
        "Solution"
      ],
      "title": "Large number of false positive security vulnerabilities ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Troubleshooting"
      ],
      "external_id": "ad821786352c0cb9e32b933e492765d857e2c9f3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/troubleshooting/large-number-false-positive-security-vulnerabilities/",
      "published_at": "2021-06-02T17:47:59Z",
      "updated_at": "2021-06-02T17:47:59Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem When a security scan is performed, it reports back with a high number of false positive security vulnerabilities. Cause The security scan flagged the jar files as vulnerable due to the class and method names we use to identify sources for instrumentation. However, the jar files only contain New Relic instrumentation code. Solution Suppress the false positive warnings coming from the instrumentation package in the newrelic.jar with your scanning tool. For example, false positives discovered by the DependencyCheck project at github.com/jeremylong/DependencyCheck can be suppressed with: <suppress> <notes><![CDATA[newrelic-agent false positives due to the instrumentation package]]></notes> <filePath regex=\"true\">.*newrelic-agent-.*\\.jar[\\\\\\/]instrumentation.*\\.jar</filePath> <cpe regex=\"true\">.* </suppress> Copy Consult your security scan vendor for the appropriate configuration to suppress false positives.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 142.23917,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Java</em> <em>agent</em>",
        "body": " with: &lt;suppress&gt; &lt;notes&gt;&lt;![CDATA[newrelic-<em>agent</em> false positives due to the instrumentation package]]&gt;&lt;&#x2F;notes&gt; &lt;filePath regex=&quot;true&quot;&gt;.*newrelic-<em>agent</em>-.*\\.jar[\\\\\\&#x2F;]instrumentation.*\\.jar&lt;&#x2F;filePath&gt; &lt;cpe regex=&quot;true&quot;&gt;.* &lt;&#x2F;suppress&gt; Copy Consult your security scan vendor for the appropriate configuration to suppress false positives."
      },
      "id": "603ea8cb28ccbc0319eba74f"
    },
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 93.48974,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Guide to using the <em>Java</em> <em>agent</em> API ",
        "sections": "Guide to using the <em>Java</em> <em>agent</em> API",
        "tags": "<em>Java</em> <em>agent</em>",
        "body": "The New Relic <em>Java</em> <em>agent</em> API lets you control, customize, and extend the functionality of the APM <em>Java</em> <em>agent</em>. This API consists of: Static methods on the com.newrelic.api.<em>agent</em>.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    }
  ],
  "/docs/agents/manage-apm-agents/agent-data/agent-attributes": [
    {
      "sections": [
        "Real time streaming",
        "Why it matters",
        "Agent version to automatically enable",
        "Caution",
        "Query real time streaming data",
        "Create real time streaming charts"
      ],
      "title": "Real time streaming",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "ead7b5f2e74d1096a9ba796f3001be0b663941e0",
      "image": "https://docs.newrelic.com/static/5edbc3948f29fe9b1202aa05c9645b6a/c1b63/RTS.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/real-time-streaming/",
      "published_at": "2021-06-02T17:39:31Z",
      "updated_at": "2021-06-02T17:39:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With real time streaming, your APM event data is sent to New Relic every five seconds. You can query and visualize your data for transactions, errors, and custom events in near real time. The smaller payloads result in faster chart refreshes and faster queries of data that is the most important to you. No configuration is needed to take advantage of real time streaming. All you need to do is ensure your APM agent version is up to date. Why it matters Real time streaming doesn't result in more events being sent. The combination of more frequent posts, with a smaller number of events per post, results in approximately the same number of events per minute as there would be without real time streaming. The following image shows a comparison between data sent to New Relic with and without real time streaming. Note that 10,000 is an example number of events; some agents have lower default limits. The overall limits on how many events can be sent per minute haven't changed. Also, non-event data (spans, traces, and metrics) are unaffected; they're still sent every minute. Use real time streaming to quickly understand the impact when something has changed, such as deploying a new app version. Examine key performance indicators (throughput, error rates, charting, etc.) in near real time. Respond quickly to failure conditions and anomalies. Get the most out of New Relic One dashboards. Reduce mean time to detection with APM events reporting every five seconds. Agent version to automatically enable To enable real time streaming, update to the latest New Relic APM agent. You don't need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all APM agents. Here are the minimum agent versions: C SDK: v1.3.0 or higher Go: v2.8.0 or higher Java: v5.5.0 or higher .NET: v8.23.107.0 or higher Node.js: v5.13.0 or higher PHP: v9.5.0.252 or higher Python: v5.2.0.127 or higher Ruby: v6.7.0.359 or higher Caution If Transaction event reporting is disabled, this can affect some UI elements throughout New Relic. You may see some empty charts on some UI pages that rely on this data. Query real time streaming data When building charts, include the following in your NRQL query: NRQL clause Comments SINCE 5 minutes ago Be sure to add a SINCE 5 minutes ago clause to your NRQL query in order to take advantage of the 5 second chart refresh interval. This is because the chart's refresh interval is based on the time window. TIMESERIES bucket To set the refresh interval for time series charts, you can also specify the bucket size as an optional argument to the TIMESERIES clause. For example, SINCE 30 minutes ago TIMESERIES 5 seconds will display a 30 minute window at a 5 second resolution. You can have a maximum of 366 buckets. Create real time streaming charts You can visualize the results of your NRQL query in New Relic One: Go to one.newrelic.com, and at the top of the page, select Query your data. Use the query builder to start building a chart. Select the advanced (NRQL) mode. (If you start with basic mode, switch to advanced mode to complete the next step.) In your NRQL query, adjust the SINCE and TIMESERIES clauses to take advantage of the 5 second refresh intervals.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 254.35199,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Agent</em> version to automatically enable",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to automatically enable To enable real time streaming, update to the latest New Relic <em>APM</em> <em>agent</em>. You don&#x27;t need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all <em>APM</em> <em>agents</em>. Here are the minimum <em>agent</em> versions: C SDK: v1.3.0"
      },
      "id": "603e9d27196a678e41a83db1"
    },
    {
      "sections": [
        "Manage errors in APM: Collect, ignore, or mark as expected",
        "Collect errors not instrumented by default",
        "Ignore errors",
        "Tip",
        "Ignore errors using server-side configuration in the UI",
        "Ignore errors using agent configuration",
        "Expected errors (Java, Node.js, Python, Ruby, and .NET only)",
        "View errors in the UI"
      ],
      "title": "Manage errors in APM: Collect, ignore, or mark as expected",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "ebd20f78d5084c48b1669ae33569da3f829fec6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/manage-errors-apm-collect-ignore-or-mark-expected/",
      "published_at": "2021-06-02T15:36:26Z",
      "updated_at": "2021-05-27T19:09:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM agents automatically report error data for supported frameworks. To optimize error reporting and alerting, you can further manage errors in order to: Catch errors that we don't instrument by default. Ignore errors that you don't want reported at all. Filter out noise from expected errors so you can focus on the errors that are affecting performance. (Java, Ruby, Node, Python, and .NET agents only) Collect errors not instrumented by default APM agents include API calls to report (or \"notice\") errors. These are useful when APM doesn't instrument your framework automatically or when there are particular errors that aren't caught for your supported framework. To learn how to get an APM agent to report an error, see the agent-specific API documentation: C SDK: newrelic_notice_error() Go: NoticeError() Java: NoticeError() .NET: NoticeError() Node.js: noticeError() PHP: newrelic_notice_error() Python: notice_error() Ruby: notice_error() Ignore errors Sometimes the APM agent instruments an error that you don't want reported, such as errors that contain sensitive information like user login errors. If you don't want an error to report to the our collector, you can ignore the error, and the APM agent discards the error entirely. Tip For Java, Ruby, Node.js, and Python: If you want to report errors to APM but don't want those errors to affect your Apdex or error rate, mark them as expected instead. There are two ways to ignore errors: through the agent configuration or through server-side configuration in the UI: Ignore errors using server-side configuration in the UI This option depends on whether the agent supports server-side configuration. If it is not already enabled, enable server-side configuration. Go to the Server-side configuration menu for the application that has errors that you want to ignore. Under Error collection, look for Ignore from error collection. Add the HTTP code or the Error class for the errors that you want to ignore. Select Save server-side configuration. Ignore errors using agent configuration To ignore an error using the agent configuration, see the configuration documentation for your agent: C SDK: Not available. For more information, see the C SDK errors example on GitHub. Go: ErrorCollector.IgnoreStatusCodes. Java: error_collector.ignore_classes, error_collector.ignore_classes.message, or error_collector.ignore_status_codes. For additional information, see Java agent error configuration. .NET: ignoreErrors or ignoreStatusCodes. Node.js: ignore_status_codes, ignore_classes, or ignore_messages. PHP: error_collector.ignore_exceptions or error_collector.ignore_errors. Python: error_collector.ignore_classes or error_collector.ignore_status_codes. Ruby: error_collector.ignore_errors. Expected errors (Java, Node.js, Python, Ruby, and .NET only) For the Ruby and Java agents, you can mark errors as expected. These errors will be reported to APM and available for viewing, but they won't affect the Apdex or error rate (or alert conditions based on error rate). To configure errors as expected, see the agent-specific documentation: Java Ruby Node.js .NET Python If expected errors are enabled, APM's Error analytics page will, by default, have a filter applied with the error.expected attribute set to false, meaning expected errors will not be displayed. To view expected errors, turn off the error.expected filter. To view expected errors, query your data: To view charts of expected errors, create a query for the error.expected attribute. To create alert conditions for NRQL queries, use the error.expected attribute. View errors in the UI Among other places, error data appears in these parts of the UI: Error analytics page: shows in-depth charts and visual analysis of errors. APM Overview page: shows a high-level view of your application, which includes errors. Alert conditions: can be based on error rate. The transactionError event: contains underlying error data, which can be used in NRQL queries.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 212.44228,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Manage</em> errors in <em>APM</em>: Collect, ignore, or mark as expected",
        "sections": "<em>Manage</em> errors in <em>APM</em>: Collect, ignore, or mark as expected",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": "<em>APM</em> <em>agents</em> automatically report error <em>data</em> for supported frameworks. To optimize error reporting and alerting, you can further <em>manage</em> errors in order to: Catch errors that we don&#x27;t instrument by default. Ignore errors that you don&#x27;t want reported at all. Filter out noise from expected errors so you"
      },
      "id": "6043f7d6196a67c1d4960f72"
    },
    {
      "sections": [
        "Use multiple names for an app",
        "Important",
        "Roll up app data",
        "Prevent duplicate transaction events",
        "Roll up browser data",
        "Define app names from most to least specific",
        "Name app instances via agent config file",
        "Examples",
        "One app, three clusters",
        "Two instances of one app",
        "Other options to organize your apps"
      ],
      "title": "Use multiple names for an app",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "App naming"
      ],
      "external_id": "af78a44c170729aac326233d6468b0b61b6cdff2",
      "image": "https://docs.newrelic.com/static/67c256b1f08164be39b8eeb2ca8ff4e6/8c557/Insights-ToggleOnOff.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/app-naming/use-multiple-names-app/",
      "published_at": "2021-06-02T17:23:07Z",
      "updated_at": "2021-06-02T17:23:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When working with your data in New Relic, you may want to view aggregated data for an application across clusters, environments, or data centers, while at the same time be able to view each of your application instance's data individually. Important If you use multiple names for an app, the last name assigned is the least specific name New Relic uses to roll up the data. For best results to view both instance-level and aggregated data, set the order of your app's rollup names from most specific to least specific in your configuration file. Roll up app data Normally, when two instances report with the same app name, agent language, and license key, New Relic aggregates their data into a single app within the New Relic user interface. You can also view data for the individual hosts and instances from the app's New Relic APM Overview page. To segment your app in a different way, or to work with each instance as an individual app while maintaining the overall view of the data, use your New Relic agent's config file to give an app up to three different rollup names. New Relic will then report the app's data separately to each app listed in the config file. For example, you might want to separate the data collected for your app running in development, staging, and production environments, but also have a common view of the app in every environment. Or, if you have two data centers running the same code, you could name one app EastCoastApp;AggregateApp and the second app WestCoastApp;AggregateApp. Prevent duplicate transaction events By default, an app with multiple names will generate multiple events for transactions (a duplicate transaction for each name). For example, if you give your app three names, that's three times the number of events for transactions. To avoid duplicate events, disable collection for each of the duplicate app names: Go to one.newrelic.com or one.eu.newrelic.com > More > Manage Insights Data. Toggle data collection on/off for duplicate app names, then save. Roll up browser data When you use multiple names to report application data, any Browser monitoring data from that application will also be grouped into multiple applications using the same configuration. Important Session trace data will only report to the first application listed. Other Browser data will populate into each of the up to three applications, but session trace data will be limited to the most specific application. Define app names from most to least specific You can give each app up to three names, which New Relic uses to aggregate data from most to least specific. You can then use the New Relic UI to view data for each app name individually, as well as in aggregate for overall application performance. When doing so, the order in which you specify the app names is important. Using multiple names Comments Most specific A unique rollup name. Less specific A shared rollup name to aggregate data in the New Relic UI. This provides more general organization. Optional, least specific An additional, shared rollup name. If used, this is the most general name New Relic uses to aggregate data into a single app. Name app instances via agent config file The naming convention you use in your configuration file depends on your New Relic agent. Set the order of your app's names so that the first rollup name is the most unique. The second and third names can be unique, or they can be the same. The second name is more general for aggregate data, and the third name (if used) is the most general. Agent Configuration file value C Identify a maximum of three names separated by a semicolon ; in your newrelic_app_config_t * config;. Go Set AppName to a maximum of three names separated by a semicolon. Java Set app_name to a maximum of three names separated by a semicolon. .NET Use any of the available options to name your .NET app. Node.js Set app_name to a maximum of three names separated by a comma. Enclose the string of names with single or double quotes. (Or, change the environment variable NEW_RELIC_APP_NAME.) PHP Use any of the available options to name your PHP application. Use three names separated by a semicolon. Python Set app_name to a maximum of three names separated by a semicolon. Do not add a space after the semicolon, or the next name will be interpreted as a comment. Ruby Set app_name to a maximum of three names separated by a semicolon. For more information, refer to the configuration file documentation for your agent. Examples Here are examples of how you could use multiple rollup names for a single app. One app, three clusters A Java app collecting survey data runs on three clusters. Change the value for the app name in your agent config file by giving it three different names, one for each cluster. Cluster 1: app_name: SurveyCluster1;Survey Data Copy Cluster 2: app_name: SurveyCluster2;Survey Data Copy Cluster 3: app_name: SurveyCluster3;Survey Data Copy This will report four applications in New Relic APM: The app name for aggregate data from all three clusters is Survey Data. Three individual applications named SurveyCluster1, SurveyCluster2, and SurveyCluster3. Two instances of one app A PHP agent is monitoring an e-commerce application running on two clusters in each of two data centers, and you want to view data for each subgroup as well as the overall aggregated data. Cluster A: newrelic.appname=\"EcomClusterA;EcomEast;EcomAll\" Copy Cluster B: newrelic.appname=\"EcomClusterB;EcomEast;EcomAll\" Copy Cluster C: newrelic.appname=\"EcomClusterC;EcomWest;EcomAll\" Copy Cluster D: newrelic.appname=\"EcomClusterD;EcomWest;EcomAll\" Copy This example configuration will report seven applications in the New Relic APM UI: Four apps: One for each of the four clusters (A B C D) Two apps: One for each datacenter (East and West) One app for the overall data across clusters and data centers (EcomAll) Other options to organize your apps If you do not want to apply multiple names to your apps, you can organize them with labels and categories. This allows you to easily sort, filter, and page through them from their product index pages in the New Relic UI. You can also set distinct performance thresholds for each environment with alert conditions and key transactions. These thresholds will apply to the individual apps, while the overall app will not have its own thresholds. The overall app will treat incoming data according to the threshold for the relevant enviroment.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.77597,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Roll up app <em>data</em>",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " with the same app name, <em>agent</em> language, and license key, New Relic aggregates their <em>data</em> into a single app within the New Relic user interface. You can also view <em>data</em> for the individual hosts and instances from the app&#x27;s New Relic <em>APM</em> Overview page. To segment your app in a different way, or to work"
      },
      "id": "603ebde1196a677dbaa83dec"
    }
  ],
  "/docs/agents/manage-apm-agents/agent-data/collect-custom-metrics": [
    {
      "sections": [
        "Glossary",
        "account dropdown",
        "administrator",
        "agent",
        "agent API",
        "aggregated metrics",
        "aggregation function",
        "aggregation window",
        "alert",
        "alert condition",
        "alert evaluation",
        "alert policy",
        "apdex",
        "apdex_f",
        "apdex_t",
        "API (application programming interface)",
        "APM",
        "application",
        "application ID",
        "application name",
        "Applied Intelligence (AI)",
        "attribute",
        "availability monitoring",
        "browser",
        "Browser monitoring",
        "background external",
        "cloud-based integration",
        "collector",
        "Command line interface (CLI)",
        "compute unit (CU)",
        "condition_id",
        "CPM (calls per minute)",
        "CPU burn",
        "custom attribute",
        "custom dashboard",
        "custom event",
        "custom instrumentation",
        "custom metric",
        "data collector",
        "data explorer",
        "degradation period",
        "dimensional metric",
        "Docker",
        "downtime",
        "entity",
        "event",
        "expected error",
        "exporter",
        "Flex",
        "framework",
        "Full-Stack Observability",
        "harvest cycle",
        "health status indicator",
        "host",
        "host ID",
        "ignored error",
        "incident",
        "Infrastructure Monitoring",
        "Insights",
        "instance ID",
        "instrumentation",
        "integration",
        "interaction",
        "interaction trace",
        "inventory data",
        "key transaction",
        "launcher",
        "log",
        "Log monitoring",
        "Logs",
        "Logs in context",
        "master account",
        "metric",
        "metric timeslice",
        "metric grouping issue",
        "minion",
        "Mobile Monitoring",
        "monitor",
        "NerdGraph",
        "Nerdlet",
        "Nerdpack",
        "New Relic Edge with Infinite Tracing",
        "New Relic One",
        "New Relic One catalog",
        "NRQL (New Relic query language)",
        "non-web transaction",
        "notification",
        "notification channel",
        "on-host integration",
        "owner",
        "page load timing",
        "parameter",
        "permalink",
        "pinger",
        "Plugins",
        "polling interval (AWS)",
        "PPM (pages per minute)",
        "private location",
        "recovery period",
        "response time",
        "restricted user",
        "rollup",
        "root span",
        "RPM",
        "RUM (real user monitoring)",
        "runbook",
        "SAML (Security Assertion Markup Language)",
        "Selenium",
        "service",
        "signal",
        "signal filter",
        "span",
        "SSL certificate",
        "SSO (single sign on)",
        "streaming algorithm",
        "sub-accounts",
        "Synthetic monitoring",
        "target",
        "tag",
        "Telemetry Data Platform",
        "thresholds",
        "throughput",
        "tier",
        "time picker",
        "time range",
        "timeslice data",
        "trace",
        "traffic light",
        "transaction",
        "transaction trace",
        "UI",
        "user",
        "UTC",
        "value function (metrics)",
        "violation",
        "web external",
        "web transaction",
        "WebDriverJS",
        "workload"
      ],
      "title": "Glossary",
      "type": "docs",
      "tags": [
        "Using New Relic",
        "Welcome to New Relic",
        "Get started"
      ],
      "external_id": "756954560251823f905fe44d0ebea119cf983160",
      "image": "https://docs.newrelic.com/static/035f6a352a6ed56d7d44284f3eee9343/d6a46/account-dropdowns.png",
      "url": "https://docs.newrelic.com/docs/using-new-relic/welcome-new-relic/get-started/glossary/",
      "published_at": "2021-06-03T17:25:03Z",
      "updated_at": "2021-06-03T17:25:02Z",
      "document_type": "page",
      "popularity": 1,
      "body": "A glossary of common terminology you may encounter. account dropdown The account dropdown on the left lets you switch accounts. The account dropdown on the right gets you to your account settings. To access your account settings, in the top right, click your profile icon for all your account-related abilities. In the top left, use the All accounts dropdown menu to switch accounts. administrator A type of user role on a New Relic account. For more information, see Users. agent At New Relic, an agent is a piece of monitoring software that provides integrations with various technologies (for example, web frameworks, host operating systems, or database types). The agents send that data to New Relic, usually on a specific cadence. For more information, see: New Relic integrations Install agents agent API Some New Relic agents have agent APIs that allow you to extend the functionality of an agent. You can use the API to control, customize and extend the functionality of the agent. Here are some agent API docs: APM agents: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Ruby agent API Python agent API Browser agent: Browser agent API Mobile agents: iOS SDK API Android SDK API aggregated metrics Aggregated metric data summarizes calls to specific methods in your application, including how many times each one was called and response times. In the New Relic UI, you see the class and method names along with their aggregate numbers. Metric data aggregation depends on the New Relic tool and your subscription level. For more information, see the documentation about data retention. aggregation function You can use NRQL query function, such as sum(), average(), or latest() to choose how the data points in an aggregation window should be processed into a single data point. The single aggregated data point is what's passed through the alert evaluation process. aggregation window Streaming alerts gathers data together into specific amounts of time. These windows of time are customizable. Data points are collected together based their timestamps and reported as a batch. The customizable aggregation window provides greater flexibility and fewer false violations when alerting on irregular or less frequent data points. alert An alert communicates an event or incident that designated personnel can track through Alerts. For an explanation of how basic alerts concepts are related, see Concepts and workflow. alert condition An alert condition (or condition), identified by its unique numeric condition_id, contains the criteria for creating a violation. The condition includes the threshold that is set for a metric timeslice or a custom metric over time on a chosen target. For an explanation of how a condition relates to other basic alerts concepts, see Concepts and workflow. alert evaluation Streaming data is assessed on a set of aggregation windows to determine if an alert condition is violating or recovering. The aggregation window time is how long we'll collect data before running the NRQL query condition. The offset evaluation time is how long you want us to wait for late data before assessing it. If a window doesn't have any data points, it's treated as a gap for loss of signal. alert policy A collection of one or more conditions, one or more notification channels, and an Incident preference setting. If a condition contained within the policy opens a violation, an incident may be opened depending on the Incident preference setting. Notifications will then be sent to all channels attached to the policy. For an explanation of how a policy relates to other basic alerts concepts, see Concepts and workflow. apdex Apdex is an industry-standard way to measure users' satisfaction with the response time of an application or service. New Relic rates each response as Satisfied, Tolerated, or Frustrated, and uses these ratings to calculate an overall user satisfaction score. For more information, see Apdex: Measure user satisfaction. apdex_f The response time above which a transaction are rated frustrating. Defaults to four times apdex_t. Requests that complete in less than apdex_t are rated satisfied. Requests that take longer than apdex_t, but less than four times apdex_t (apdex_f), are tolerated. Any requests that take longer than apdex_f are rated frustrating. For more information, see Apdex: Measure user satisfaction. apdex_t The response time above which a transaction is considered tolerable. The default value is 0.5 seconds, but you can change this in your Apdex settings. Requests that complete in less than apdex_t are rated satisfied. Requests that take more than apdex_t, but less than apdex_f, are tolerated. Any requests that take longer than apdex_f are rated frustrating. For more information, see Apdex: Measure user satisfaction. API (application programming interface) New Relic offers a variety of APIs and SDKs. For more information, see the introduction to New Relic's APIs. APM New Relic's APM (application performance monitoring) provides monitoring of your web or non-web application's performance. APM supports apps using several programming languages. application For New Relic purposes, any program instrumented by New Relic. application ID Some New Relic solutions assign a monitored application a unique application ID, often shortened to app ID. When present, this ID is available in the UI. It is also reported as an attribute and can be queried. For how to determine this, see Find app ID. application name The name that New Relic combines with your license key to uniquely identify a particular app. For more information, see Name your application. Applied Intelligence (AI) Applied Intelligence (AI) helps you find, troubleshoot, and resolve problems more quickly. Specifically, it’s a hybrid machine learning engine that reduces alert noise, correlates incidents, and automatically detects anomalies. Applied Intelligence includes Alerts, Incident Intelligence, and Proactive Detection. attribute Attributes are key-value pairs attached to data objects reported to New Relic. Attributes add detail, and they're similar to tags or labels in other SaaS software. You can explore this data by querying or searching via the UI or by using the data dictionary. Examples: APM reports a Transaction event. This includes timing data for the transaction in a duration attribute, which might have a value of .002. Our Infrastructure Monitoring reports a ProcessSample event. This includes a variety of CPU usage attributes, including a cpuSystemPercent attribute, which might have a value of .01. Our Telemetry SDK reports a Metric data type for storing metrics, with attached attributes like metricName and newrelic.source. Some New Relic tools allow you to report custom attributes to enhance your monitoring. For more information about attributes in APM, see Agent attributes. availability monitoring See Types of Synthetics monitors. browser The New Relic UI supports most browsers. For more information, see Supported browsers. For our end-user browser monitoring tool, see Browser Monitoring. Browser monitoring A Real User Monitoring (RUM) solution that measures the speed and performance of your end users as they navigate to your site from different web browsers, devices, operating systems, and networks. background external See web external. cloud-based integration New Relic offers cloud-based integrations with providers such as Amazon Web Services (AWS), Microsoft Azure, and Google Cloud Platform. collector The component that collects data from New Relic agents running on an app server, mobile device, or end-user browser. While the agent is installed on a user's app server, the collectors are centrally located in New Relic's data center. In order to contact the collector, the agent must be able to reach New Relic's domains and IP addresses. (The exact domain or IP depends on the New Relic monitoring tool.) The collector receives and interprets this data, and stores it in a database. The data is then retrieved and presented in the New Relic UI and by our various REST APIs. Command line interface (CLI) Our command line interface (CLI) is a tool you can use to build a New Relic application. This is the same tool our own engineers use. Go here for quick start instructions. Go to our Developer site for sample apps and guides. compute unit (CU) A unit of measurement that determines your pricing for some New Relic products governed by our original product-based pricing plan. For more information, see Compute unit pricing. condition_id See alert condition. CPM (calls per minute) The number of calls your application receives each minute. This usually corresponds to the number of page views or external connections, and is usually the same as RPM (requests per minute). CPU burn The time consumed by code minus the wait time for a transaction. This is the time actually spent processing the transaction. It appears in the New Relic UI at the top of the transaction view for the agents that provide it (Ruby and PHP only). custom attribute A key-value pair added to a transaction or event in order to gain additional information about it. For more information, see custom attributes. custom dashboard A customizable dashboard with charts and tables that includes data from multiple New Relic data sources. For more information, see dashboards. custom event An event, in New Relic terms, is a data object with attached attributes. New Relic reports default event types, like Transaction and TransactionError. You can also create your own events. Events can be queried, and are used in some other features. You can generate custom events with APM agents, with the Browser agent, with the Mobile agent, and via the Event API. Alternatively, you can add custom attributes to some existing default New Relic events. custom instrumentation Custom instrumentation allows you to extend New Relic's monitoring to instrument code elements New Relic doesn't automatically instrument. Custom instrumentation is useful when your framework is not supported by New Relic, or when New Relic fails to pick up some element of your program. You can also use custom instrumentation to block a transaction from being reported entirely. For more information, see Custom instrumentation. custom metric Metric timeslice data that is manually recorded via an API call. Custom metrics allow you to record arbitrary metrics; for example, timing or computer resource data. All custom metric names must be prefixed with Custom/. For more information, see Custom metrics. Not to be confused with custom instrumentation data. data collector See collector. data explorer Use the data explorer to access, query and customize your data, create visualizations, and make connections between your services in a consistent and curated experience. For more on using the data explorer, see Introduction to the data explorer. degradation period When a data source enters a violating state, a degradation period of time begins. The degradation period is set in the condition's threshold. A violation will open if the source stays in a violating state for the entire degradation period. In addition: If the data source enters a non-violating state before the entire time has elapsed, the degradation period countdown is reset, and a violation does not open. If your alert condition threshold is configured as at least once in, the degradation period always lasts a single minute. dimensional metric A dimensional metric is a metric that has multiple attributes, also known as dimensions. At New Relic, we report dimensional metrics using the Metric data type. For more on other metric data types, see Metric data. Docker An open platform for distributed applications, which allows you to assemble multi-container portable apps. Infrastructure Monitoring includes integrated Docker monitoring. For more information about Docker, see the Docker website. downtime The period of time when customers cannot access your site and your app is not reporting to New Relic. For more information, see Synthetic Monitoring and Types of synthetic monitors. entity In New Relic, an entity is anything we can identify that has data you can monitor. An entity can be something you monitor directly, like applications and microservices, or indirectly, like data centers. You can identify one or more entities to be targets for alert conditions. In the Alerts API, the entity being monitored is identified with an entity_id. For more on this, see What are entities? event The word event is a general term that can have many meanings. At New Relic, event can have several meanings: At New Relic, event data is one of our core data types. Event data represents a record of a single event at a particular moment in time. Events can vary by type (for example, Transaction or Mobile, and will have associated attributes (for example, timestamp or transactionName). For more details, see Event data. For our infrastructure monitoring, the word event can be used to refer to important system and host activity. For example, a configuration change for a monitored host would be registered on Infrastructure's Events UI page. For alerts, the Events UI page displays a list of alerts-related incidents for your monitored entities. Events are reported for a violation opening and for closing. In some contexts, event can refer to any NRQL-queryable data type. For example, when you run a NRQL query, you will see a count of inspected events: this refers to a count of all data types queried. expected error An expected error is a common error that you don't want to affect your Apdex score or error rate. For more information, see Manage errors in APM. exporter At New Relic, an exporter is a type of integration that reports telemetry data to New Relic from a third-party (non-New Relic) telemetry tool. For examples, see Exporters, or search our integrations. Flex New Relic Flex is an application-agnostic, all-in-one integration. With it, you can build your own integration that collects metric data from a wide variety of services, and that can instrument any app that exposes metrics over a standard protocol (HTTP, file, shell) in a standard format (for example, JSON or plain text) to the terminal. It's a recommended way to create a custom integration, because it doesn't require coding skills. framework A framework is a structured collection of pre-defined functions, into which an application builder inserts their own code to build their application. A framework is not the same as a library. While a library is a collection of functions you can call as needed, a framework is a skeleton for your application. The functions in that framework then call your functions. For more about the distinction between a framework and a library, see What is the difference between a framework and a library?. New Relic automatically instruments many common frameworks. For more about the frameworks New Relic supports, see the agent-specific documentation: C SDK supported frameworks Go supported frameworks Java supported frameworks .NET supported frameworks Node.js supported frameworks PHP supported frameworks Python supported frameworks Ruby supported frameworks Full-Stack Observability The collection of features and tools you can use to easily analyze and troubleshoot problems across your entire software stack. For more information, read our Introduction to Full-Stack Observability. harvest cycle The period of time between each connection from a New Relic agent to the collector. Between harvest cycles, an agent collects and caches data. At the end of the cycle an agent reports those data to the collector, then begins a new harvest cycle. health status indicator Some New Relic UI pages have a health status indicator appearing next to an index of monitored entities. This is a colored bar (generally green, yellow, red, or gray) indicating the status of your app or other entity monitored by New Relic. It also indicates whether the entity has any alert policies assigned to it and whether there are any policy violations. In general, the colored bar will be green, yellow, red, or gray to indicate the health status. Exceptions: Our REST API (v2) uses orange instead of yellow for the application's health and reporting status. Service maps use different criteria for reporting the health of a connection between an app and an external service not monitored by New Relic (for example, a third party API). host At New Relic, a host means one of the following: A physical machine is a hardware-based device with dedicated physical resources, including memory, processing, and storage. Each machine has its own OS which applications run on. A virtual machine (VM) is the software implementation of a physical machine that executes programs like a physical machine. One or more virtual machines can run on a physical machine. Each virtual machine has its own OS and allocated virtual machine resources such as RAM and CPU. A cloud instance is a type of virtual machine that is run in the public cloud. In this context, virtual machines and cloud instances are different from Java Virtual Machines (JVMs) and containers. host ID Each host identified by APM is assigned a host ID. This ID is used to uniquely identify it, and to retrieve data about that host via the REST API. For more information, see List host ID. ignored error An error that you have told the APM agent not to report to the collector. For more information, see Manage errors in APM. incident An incident is a collection of one or more violations of the conditions defined in an alert policy. An incident record includes all of the open and close time stamps for each violation, as well as chart snapshots of the data being evaluated around the time of each violation. You can view detailed information from the Incidents pages in the user interface. You can also select your preference for how we roll up violations into the incident. For an explanation of how an incident relates to other basic alerts concepts, see Concepts and workflow. Infrastructure Monitoring By connecting changes in host performance to changes in your configuration, Infrastructure Monitoring provides real-time metrics and powerful analytics that reduce your mean-time-to-resolution (MTTR). Infrastructure is specifically designed for complex environments that need flexible, dynamic server monitoring, from a physical datacenter to thousands of Amazon Elastic Compute Cloud (Amazon EC2) instances and other types of integrations. Insights Insights was the name for the New Relic product that previously governed the reporting of custom events, and the ability to query and chart your New Relic data. These features are now separate and no longer related to Insights. To learn more about these features: Event API for reporting custom events Query and chart data For historical reasons, the word \"Insights\" is still used in some contexts. Some examples of this: The API key used for the Event API is still called the Insights insert key. Some APM agents use Insights language in their codebase. For example, the Java agent custom_insights_events configuration. For customers on our original pricing plan, Insights Pro is still the product name governing custom event data ingest and retention. instance ID Each instance identified by New Relic is assigned a unique instance ID. Instance IDs are most commonly found for JVMs (Java Virtual Machines), but can exist for each agent. This ID is used to uniquely identify it, and to retrieve data about that instance via the REST API. For more information, see List instance IDs. instrumentation The collection of data from an application or host. When New Relic instruments a framework, it detects the methods and calls used by that framework, and intelligently groups them together. integration At New Relic, an integration refers to a solution that integrates with a specific technology (like a web framework or a type of database). See Integrations. interaction In our Mobile Monitoring, an interaction is a specific code path initiated by a user interaction (usually a button press). An interaction is the mobile equivalent of a transaction, and like a transaction an interaction can be traced and monitored. interaction trace An interaction trace is a complete picture of a single interaction. With interaction traces, New Relic gives you much deeper visibility into a single slow interaction, which can help you understand a broader problem. Interaction traces are the mobile equivalent of a transaction trace. For more information, see Creating interactions (iOS) and Creating interactions (Android). inventory data Inventory data is information about the status or configuration of a service or host. Examples of inventory data include: Configuration settings Name of the host the service is on Amazon AWS region Port being used For more information, see Understand and use data. key transaction A web transaction that the user has marked as particularly important; for example, key business events (such as signups or purchase confirmations), or transactions with a high performance impact (such as searches). Key transactions have their own pages in the UI and other customized values. For more information, see Key transactions. launcher A launcher is a specific piece of code you can include when you create a New Relic One app. It creates the tile on the homepage that you click to launch the app. For more information, see the documentation about core UI components. log A log is a message about a system used to understand the activity of the system and to diagnose problems. For more information on how we use log data, see Log management. Log monitoring Our log management and monitoring features give you the tools to collect, process, explore, visualize, and alert on your log data using your existing log forwarder. With all of your log data in one place, you'll be able to make better decisions, detect and resolve problems more quickly, and see your logs in context to troubleshoot faster. Logs Our Logs feature is a scalable log management platform that allows you to connect your log data with the rest of your telemetry data. Pre-built plugins with some of the most common open-source logging tools make it simple to send your data from anywhere to New Relic. Logs in context Logs in context makes it easy to link to your log data with related data across the rest of our platform. Bringing all of this data together in a single tool allows you to quickly get to the root cause of an issue and find the log lines that you need to identify and resolve a problem. master account A master account is a New Relic account that has one or more subordinate accounts (sub-accounts). For details, see Account structure. metric A metric is a numeric measurement. Metric data is a broad category because there are several ways to make and report measurements. For more about how metrics are reported at New Relic, see New Relic data types. metric timeslice New Relic reports metrics in several ways. One variety of metric data is called metric timeslice data; this is the type of data used to generate many of the charts in APM, Mobile Monitoring, and Browser Monitoring (for more details, see metric timeslice data). Over time, metric timeslice data is aggregated into longer timeslice data records for more efficient storage. For more about how we aggregate this type of data, see Data aggregation. For how to query this type of data, see Query metric timeslice data. metric grouping issue A metric grouping issue occurs when an account sends too many differently named metric timeslice data points to New Relic, and those individual web transactions are not properly aggregated. For example, rather than a single /user/controlpanel/ metric name, you might see /user/controlpanel/alice, /user/controlpanel/bob, and /user/controlpanel/carol. For more information, see Metric grouping issues. minion The software that accepts monitor jobs from a private location. A minion is a packaged virtual appliance that runs in your hypervisor. For more information, see Private locations overview and install and configure private minions. Mobile Monitoring Mobile Monitoring allows you to monitor and manage the performance of your mobile apps on Android, iOS, tvOS, and other systems. Mobile Monitoring provides end-to-end details, including crashes, throughput, HTTP requests, error traces, and more. Not to be confused with New Relic's own mobile apps for Android, iPhone, and iPad. monitor For our Synthetic Monitoring, a monitor ensures your website or API endpoint is available. For more information, see Adding and editing monitors. NerdGraph NerdGraph is our GraphQL API, an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph calls get all the data you need in a single request. NerdGraph also makes it easier to evolve APIs over time and enables powerful developer tools. You can use our NerdGraph GraphiQL explorer to explore the schema and find definitions. With valid New Relic API key, you can try it out yourself at api.newrelic.com/graphiql. Nerdlet A Nerdlet is a component of a New Relic One application. It's a specific UI view, represented by a React JavaScript package. For more information, see Nerdpack file structure. Nerdpack A Nerdpack is a component of a New Relic One application. It's the package containing all the files needed by that application. For more information, see Nerdpack file structure. New Relic Edge with Infinite Tracing New Relic Edge with Infinite Tracing is a fully managed, distributed tracing service that observes 100% of your application traces, then provides actionable data so you can solve issues faster. For more information, see /docs/understand-dependencies/distributed-tracing/get-started/how-new-relic-distributed-tracing-works. New Relic One For more information, see Introduction to New Relic One. New Relic One catalog Our catalog is a collection of applications built on the New Relic One platform. The catalog includes custom apps we've built, public open source apps, and any apps that you buid. You can browse the catalog on New Relic One. NRQL (New Relic query language) NRQL is a query language, similar in form to SQL, that allows you to query the data stored in your New Relic account. non-web transaction APM identifies transactions as either web or non-web. When New Relic does not detect a transaction was initiated by a web request, this is called a non-web transaction. For more information, see Background processes and other non-web transactions. notification The message sent when an incident opens, is acknowledged, or closes. The type of notification is defined by the alert policy's notification channel. For an explanation of how notifications relate to other basic alerts concepts, see Concepts and workflow. notification channel Where we send a notification when an incident opens, is acknowledged, or closes. Available channels include email, mobile push notifications, webhooks, and more. on-host integration On-host integrations refer to integrations that reside on your own servers or hosts and that communicate with our infrastructure agent. For more information, see Introduction to on-host integrations. owner For accounts on our original pricing plan, this is a type of user role: the user who initially created the account. For more information, see Users. page load timing With page load timing, New Relic monitors the full load time for end-user browsers. New Relic's application agents dynamically inject JavaScript into the page, then capture the following key load points: Navigation start: The user initiates the transaction. First byte: The browser receives the requested page. DOM ready: The browser has finished parsing DOM. Page ready: Page loading is complete. Page load timing is sometimes referred to as RUM, or real user monitoring. Unlike standard RUM, page load timing also captures JavaScript errors and AJAX requests. For more information, see Page load timing process. parameter Deprecated term; see attribute. permalink A unique URL that links to a view of your application at a specific point in time. Permalinks are useful for troubleshooting and for sharing interesting time windows with colleagues. pinger The component of New Relic that connects to your website to verify your website is accessible. New Relic has pingers in Europe, Asia, and the United States. Each pinger attempts to contact your website at least once every two minutes. If enough pingers are unable to reach your website, your application will be considered down. For in-depth scriptable testing, including real browser tests and tests of API endpoints, see Synthetic Monitoring. Synthetic Monitoring includes free ping monitoring, which allows you to monitor your website from locations around the world. For more information, see Types of Synthetic monitors. Plugins Plugins provides an open platform to monitor critical information about your entire stack. New Relic partners, PaAS and SaAS providers, third-party vendors, and plugin users can: Quickly install and use publicly available plugins in Plugin Central. Develop your own plugin agents to collect the metric data that matters most to your business. Publish your plugins for public or private access. polling interval (AWS) Our Amazon integrations query your AWS services according to a polling interval, which varies depending on the integration. Each polling interval occurs for every AWS entity. For example, if you have thirteen Elastic Load Balancers (ELB), each one will be polled every five minutes. Depending on the AWS integration, there may be delays in the timing between the API request and the metric data returned. If you notice unusual delays, follow the integration troubleshooting procedures. PPM (pages per minute) The number of pages per minute your application serves. private location A Synthetic monitor feature that allows you to run Synthetic monitors from within your own systems by creating private minions. Private locations allow you to extend your Synthetic coverage to new geographical locations, and to monitor websites behind your firewall such as an intranet site. For more information, see Private locations overview. recovery period A recovery period of time begins when a data source enters a non-violating state after being in a violating state. The recovery period is set in the condition's threshold. A violation will close when a source remains in a non-violating state and the recovery period time has elapsed. If the data source enters a violating state before the time has elapsed, the recovery period clock will reset and the violation won't close. response time The duration of time between a request for service and a response. For more information, see Response time. restricted user A type of user role on a New Relic account. For more information, see Users. rollup Using the same application name for multiple applications. This allows you to combine data in APM, either from multiple applications, or from multiple instances of an application. For more information, see Rolling up app data. root span For distributed tracing, the root span is the first span in a trace. In many cases, the root span duration will represent the duration of the entire trace, or be very close to it. However, for more complex, modern systems that use a lot of asynchronous, non-blocking processes, this will not be true. For those systems, the root span’s duration may be significantly less than the duration of the trace. RPM The term RPM usually refers to the number of requests per minute your application receives from users. This is usually the same as CPM (calls per minute). Historically, some New Relic monitoring solutions, like APM and Browser Monitoring, used to contain RPM in the URL; for example, https://rpm.newrelic.com. This language use originally referred to Rails performance management because the first iteration of our product monitored Ruby on Rails applications. We monitor many more languages and systems than Ruby now. RUM (real user monitoring) See page load timing. runbook A runbook contains standard procedures and operations typically used by system administrators, network operations staff, and other personnel to handle outages, alert incidents, and other situations. If your organization stores runbook instructions as URLs, you can link this information to an alerts policy so your personnel has easy access to this information when an incident violates the defined policy thresholds. SAML (Security Assertion Markup Language) SAML is an XML-based data format for sharing authentication data between two parties. New Relic accounts must obtain a SAML certificate in order to enable Single Sign On for their users. For more information, see SAML service providers. Selenium Selenium is an open-source browser testing suite. Synthetics uses Selenium to test monitored websites with real browsers. For more information, see monitor types. service A service is a cluster of runtime server processes that accomplish a particular task, usually service requests. Unlike an application, a service is not usually invoked by a human. New Relic offers a variety of integrations that allow you to report data from your services. signal The stream of telemetry data that's watched and alerted on. You use NRQL queries to define a signal. signal filter When we receive data and it's routed to the streaming alerts platform, your NRQL WHERE clause will filter the data coming in. The filtered streaming data is what's evaluated for loss of signal violations, for example. span In a distributed trace, a span is a \"named, timed operation representing a contiguous segment of work in that trace\" (from OpenTracing.io definition). For distributed tracing, spans are displayed in the distributed tracing UI, and the data type Span is available to be queried. See also root span. SSL certificate SSL certificates encrypt data that is being transmitted. While New Relic refers to security certificates as SSL because it is a more commonly used term, all certificates adhere to industry standards for secure encryption in transit. SSO (single sign on) SSO (single sign on) allows you to manage user authentication in New Relic using an external SSO provider. For more information, see Setting up SSO. streaming algorithm This is what determines when the data in an aggregation window is processed. The streaming algorithm uses your server's clock time and the aggregation window size to trigger the alert evaluation process. sub-accounts See master account. Synthetic monitoring Synthetic monitoring allows you to monitor your website or API endpoint via automated, scriptable tools. Use free ping monitor to ensure your website is accessible, or expand your monitoring with browser monitors, which test your website with real browsers. Go further with scripting, to script browsers or API monitors for sophisticated testing. target A target is a resource or component monitored by a New Relic monitoring tool that has been identified in an alert condition. When the data source for that target crosses the defined critical threshold, we will open a violation. Depending on your policy's Incident preference setting, Alerts may create an incident record and send notifications through the defined channels. See also entity. tag Tags are key:value metadata added to monitored apps, hosts, dashboards, and other entities to help you organize your data at a high level. For details, see Tags. Telemetry Data Platform The collection of features and tools you can use to ingest, visualize, and alert on all your telemetry data in one place. For more information, read the Introduction to the Telemetry Data Platform. thresholds Thresholds are alert condition settings that define a violation. Threshold values include the value a data source must pass to trigger a violation and the time-related settings that define a violation; for example: Passing a certain value for at least x minutes Passing a certain value only once in x minutes While the data source passes a certain value, a degradation period starts. Likewise, when that data source stops passing a certain value, a recovery period starts. The durations of these two time periods are defined in the alert condition threshold settings. Thresholds have a required critical (red) threshold and an optional warning (yellow) threshold. In the UI, the entity's health status indicator will change to yellow or red when a threshold has been crossed and a violation will open. For more information, see Define thresholds. For an explanation of how thresholds relate to other basic Alerts concepts, see Concepts and workflow. throughput Throughput is a measurement of user activity for a monitored application. APM throughput and Browser Monitoring throughput are measured in different ways: APM: requests per minute (RPM) Browser: page views per minute (PPM) tier A tier can refer to how New Relic categorizes or visualizes the various agent language ecosystems that we support. For example: In APM, the color-coded categories that appear on your app's main Overview chart show response time spent in various functions, processes, or agents as tiers; for example, request queuing, garbage collection, Middleware, JVMs, etc. In New Relic labels, TIER can be used to define or classify the client-server architecture; for example, front-end and back-end tiers. \"Tier\" may sometimes be used to refer to our Full Stack Observability pricing editions. time picker By default the New Relic UI shows data for the past 30 minutes, ending now. To change the time window, use the time picker. time range A time range can refer to a length of time selected in the New Relic UI. New Relic displays a time range depending on the range you select using the time picker. timeslice data See metric timeslice data. trace A trace is a description of how a request travels through a system. Trace data helps you understand the performance of your system and diagnose problems. For more information on how we use trace data, see New Relic data types. traffic light See health status. transaction A transaction is defined as one logical unit of work in an application. This term primarily refers to server-side transactions monitored by APM. For more information, see documentation about web transactions and non-web transactions. The term transaction is also sometimes used in Browser Monitoring. In that case, it primarily refers to activity beginning with a browser-side web request and ending with a complete page load. transaction trace A transaction trace is a complete picture of a single transaction, down to the database queries and exact invocation patterns. With transaction traces, New Relic gives you much deeper visibility into a single slow transaction, which can help you understand a broader problem. For more information, see Transaction traces. UI The New Relic user interface. For more information, see Standard page functions. user A user can refer to a specific user role in a New Relic account. For more information, see Users. UTC Universal Time Coordinated (UTC), or Coordinated Universal Time, is a standard timestamp for synchronizing time around the world. value function (metrics) The numeric value obtained from metric timeslice data; for example, an average, minimum, maximum, total, sample size, etc. violation A violation occurs when the entity monitored by an alert condition reports a value that crosses the thresholds defined in that condition. For an explanation of how violations relate to other basic alerts concepts, see Concepts and workflow. You can view a summary of the violations for a selected incident's page. You can also view the violations for a specific entity from the product's UI. web external Web external is the term applied to the portion of time spent in transactions to external applications from within the code of the application you are monitoring. That time can be a call to a third party company (a payment provider, for example) or it could be a call to another microservice within your own company. Web external demonstrates how performance is impacted by your code executing outside the application you are measuring. web transaction A transaction is defined as one logical unit of work in an application. This term primarily refers to server-side transactions monitored by APM. Web transactions are initiated with an HTTP request. For most organizations, these represent customer-centric interactions and thus are the most important transactions to monitor. For more information, see Web transactions and Non-web transactions. WebDriverJS WebDriver is a Selenium component, used to control Synthetics scripted browsers. Specifically, Synthetics uses WebDriverJS, a Node.js-based flavor of Selenium. For more information, see Writing scripted browsers and Scripted browser examples. workload A workload represents a group of entities that work together to provide a digital service. For more information, see Workloads.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.40973,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>custom</em> <em>metric</em>",
        "body": " of .01. Our Telemetry SDK reports a <em>Metric</em> data type for storing <em>metrics</em>, with attached attributes like <em>metric</em>Name and newrelic.source. Some New Relic tools allow you to report <em>custom</em> attributes to enhance your monitoring. For more information about attributes in <em>APM</em>, see Agent attributes"
      },
      "id": "603eb6f5e7b9d288392a07fc"
    },
    {
      "sections": [
        "Introduction to New Relic APIs",
        "Tip",
        "NerdGraph (GraphQL)",
        "REST APIs by capability",
        "Alerts",
        "APM",
        "Browser monitoring",
        "Infrastructure monitoring",
        "Mobile monitoring",
        "Synthetic monitoring",
        "Telemetry APIs for core data types",
        "Account management, admin, and usage APIs",
        "Other APIs",
        "Insights",
        "Plugins",
        "See APIs in action"
      ],
      "title": "Introduction to New Relic APIs",
      "type": "docs",
      "tags": [
        "APIs",
        "Get started",
        "Intro to APIs"
      ],
      "external_id": "01e9799a214baad5de04de6146483f6dbbc198aa",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/intro-apis/introduction-new-relic-apis/",
      "published_at": "2021-06-02T16:33:26Z",
      "updated_at": "2021-06-02T16:33:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers a variety of APIs and SDKs you can use to: Retrieve data from New Relic. Send data to New Relic. Adjust settings. This document provides examples and reference information for our API endpoints. For developer-focused content on how to use and customize New Relic, see developer.newrelic.com. Tip To use APIs and SDKs, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. NerdGraph (GraphQL) NerdGraph is New Relic's GraphQL-format API, an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph is the preferred API for querying New Relic data and making a range of feature configurations. To get started, see Introduction to NerdGraph. REST APIs by capability New Relic capabilities, like APM, infrastructure monitoring, or alerts, are often used together, and sometimes they overlap in functionality. This is why multiple APIs may be relevant to each area. Some API functionality will depend on your access to features and data. Tip To learn more about different API key types, see Understand New Relic API keys. Alerts Use the REST API for alerts and the API Explorer to: Create and manage policies, conditions, and notification channels. Create alert conditions based on NRQL queries. Create alert conditions based on data from other New Relic capabilities. APM API resources for application monitoring include: Resource Details REST API REST API features include: Retrieve APM data, including metrics, Apdex, error rates, and host data. Report deployments. Change the app name in the UI. Agent APIs Every APM language agent has an API that lets you customize the agent's default behavior, including reporting custom data. APM agent APIs include: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Python agent API Ruby agent API Query API To query APM data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Browser monitoring The Browser API resources include: Resource Details Browser agent API Use the Browser agent API for tasks such as: Report custom end user data to browser monitoring. Monitor asynchronous browser activity using SPA API calls. Insert custom data into New Relic dashboards . Manage source maps. REST API With the REST API you can: Retrieve page load timing data and throughput. Add or list apps monitored by browser monitoring. Manage alerts conditions for your browser data. Query API To retrieve browser monitoring data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Infrastructure monitoring The Infrastructure API resources include: Resource Details Query API To retrieve infrastructure data, use the Query API. This API can also be used to retrieve subscription usage data. Infrastructure alert API To manage your infrastructure alerts, use the Infrastructure alert API. Integrations SDK To make your own custom integrations for reporting data to infrastructure monitoring, use the Integrations SDK. NerdGraph You can use NerdGraph (our GraphQL API) to query your cloud integration data and make changes to cloud integration settings. Mobile monitoring Mobile API resources include: Resource Details Mobile agent APIs Mobile APIs let you custom instrument your own code and send events to New Relic. See the platform-specific documentation: iOS Android Unity REST API Use the REST API for such tasks as: Retrieve a list of monitored apps. Get subscription usage data. Get metric names and data. Get crash count and crash rate data. Manage New Relic alerts conditions for your mobile apps. Query API To retrieve Mobile data from New Relic, use the Query API. Account management APIs For account-related APIs, see Account APIs. Synthetic monitoring Synthetics API resources include: Resource Details Synthetics REST API The Synthetics REST API functionality includes: Create and manage synthetics monitors. Manage synthetics alert notifications. Add labels to monitors, and retrieve monitors with specific labels. Query API To retrieve synthetics event data, use the Query API. Alerts API To create and manage alert conditions that target synthetics monitors, use the Alerts API. Telemetry APIs for core data types We offer several APIs that allow you to get our core data types (metrics, logs, traces, and events) into New Relic without the use of an installed agent. Data type Description Trace API Send distributed tracing data to New Relic. Event API Send event data to New Relic. Metric API Send metrics to New Relic from any source (including other telemetry monitoring services). Log API Send your log data to New Relic. Account management, admin, and usage APIs Like any other New Relic product or service, you want to be confident that your APIs protect you and your customers' data privacy. The following are API resources related to New Relic account administration and usage. For more information about API capabilities, see the specific New Relic API. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Resource Details REST API REST API features include: Find your API keys, account ID, and information needed to use the REST API. Return a list of account users (original user model only). Get SLA report data for browser and application monitoring. Subscription usage You can use the Query API to retrieve subscription usage data. This can be helpful to see how usage compares to your current subscription level, or for doing departmental chargebacks. Partner API To retrieve information about your New Relic partner account, sub-accounts, and users, use the Partner API. Other APIs Insights New Relic Insights was the name of our original product that governed custom event reporting and querying. The features associated with Insights have been rolled into our New Relic One platform (learn more), but there are still some APIs and original pricing plans that use the term \"Insights\" for these historical reasons. Insights-related APIs include: Resource Details Event API To report custom events, use the Event API. Query API To query your data using NRQL-format queries, you can use the Query API. Note that this API is deprecated and NerdGraph is preferred for querying your data. Dashboard API See the Insights Dashboard API. Plugins Use the REST API for New Relic plugins and the API Explorer to: Get a list of plugins, including their names, IDs, and GUIDs. List one or more plugin components, their output, and their metric timeslice data. Developers and New Relic partners can also use New Relic's Plugin API to write an agent in any language that can work directly with the API for plugins. This allows you to send your own metric data to our plugins and view data received from the API in New Relic. See APIs in action For more on how you as a developer can optimize your ability to solve problems using New Relic, go to developer.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 165.9383,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Mobile</em> monitoring",
        "body": " capabilities. <em>APM</em> API resources for application monitoring include: Resource Details REST API REST API features include: Retrieve <em>APM</em> data, including <em>metrics</em>, Apdex, error rates, and host data. Report deployments. Change the app name in the UI. Agent APIs Every <em>APM</em> language agent has an API that lets you"
      },
      "id": "609fa5cf196a67066022b194"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 145.77295,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "Manage <em>APM</em> agents",
        "body": " transaction traces, <em>browser</em> traces, and errors in New Relic <em>APM</em> and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. <em>Custom</em> attributes can be queried via NRQL exactly like any other attribute. <em>APM</em> &gt; (select an app) &gt; Monitoring"
      },
      "id": "603eb9db28ccbc127aeba79e"
    }
  ],
  "/docs/agents/manage-apm-agents/agent-data/custom-instrumentation": [
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 254.43654,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to each of these destinations. You can also collect custom attributes to send additional <em>data</em> to New Relic. Attribute destination flow This diagram illustrates how an <em>agent</em> decides to send attributes to each destination. <em>Agent</em> attribute collection: An <em>agent</em> makes three different decisions when sending"
      },
      "id": "603eb9db28ccbc127aeba79e"
    },
    {
      "sections": [
        "Real time streaming",
        "Why it matters",
        "Agent version to automatically enable",
        "Caution",
        "Query real time streaming data",
        "Create real time streaming charts"
      ],
      "title": "Real time streaming",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "ead7b5f2e74d1096a9ba796f3001be0b663941e0",
      "image": "https://docs.newrelic.com/static/5edbc3948f29fe9b1202aa05c9645b6a/c1b63/RTS.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/real-time-streaming/",
      "published_at": "2021-06-02T17:39:31Z",
      "updated_at": "2021-06-02T17:39:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With real time streaming, your APM event data is sent to New Relic every five seconds. You can query and visualize your data for transactions, errors, and custom events in near real time. The smaller payloads result in faster chart refreshes and faster queries of data that is the most important to you. No configuration is needed to take advantage of real time streaming. All you need to do is ensure your APM agent version is up to date. Why it matters Real time streaming doesn't result in more events being sent. The combination of more frequent posts, with a smaller number of events per post, results in approximately the same number of events per minute as there would be without real time streaming. The following image shows a comparison between data sent to New Relic with and without real time streaming. Note that 10,000 is an example number of events; some agents have lower default limits. The overall limits on how many events can be sent per minute haven't changed. Also, non-event data (spans, traces, and metrics) are unaffected; they're still sent every minute. Use real time streaming to quickly understand the impact when something has changed, such as deploying a new app version. Examine key performance indicators (throughput, error rates, charting, etc.) in near real time. Respond quickly to failure conditions and anomalies. Get the most out of New Relic One dashboards. Reduce mean time to detection with APM events reporting every five seconds. Agent version to automatically enable To enable real time streaming, update to the latest New Relic APM agent. You don't need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all APM agents. Here are the minimum agent versions: C SDK: v1.3.0 or higher Go: v2.8.0 or higher Java: v5.5.0 or higher .NET: v8.23.107.0 or higher Node.js: v5.13.0 or higher PHP: v9.5.0.252 or higher Python: v5.2.0.127 or higher Ruby: v6.7.0.359 or higher Caution If Transaction event reporting is disabled, this can affect some UI elements throughout New Relic. You may see some empty charts on some UI pages that rely on this data. Query real time streaming data When building charts, include the following in your NRQL query: NRQL clause Comments SINCE 5 minutes ago Be sure to add a SINCE 5 minutes ago clause to your NRQL query in order to take advantage of the 5 second chart refresh interval. This is because the chart's refresh interval is based on the time window. TIMESERIES bucket To set the refresh interval for time series charts, you can also specify the bucket size as an optional argument to the TIMESERIES clause. For example, SINCE 30 minutes ago TIMESERIES 5 seconds will display a 30 minute window at a 5 second resolution. You can have a maximum of 366 buckets. Create real time streaming charts You can visualize the results of your NRQL query in New Relic One: Go to one.newrelic.com, and at the top of the page, select Query your data. Use the query builder to start building a chart. Select the advanced (NRQL) mode. (If you start with basic mode, switch to advanced mode to complete the next step.) In your NRQL query, adjust the SINCE and TIMESERIES clauses to take advantage of the 5 second refresh intervals.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 254.35187,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Agent</em> version to automatically enable",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to automatically enable To enable real time streaming, update to the latest New Relic <em>APM</em> <em>agent</em>. You don&#x27;t need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all <em>APM</em> <em>agents</em>. Here are the minimum <em>agent</em> versions: C SDK: v1.3.0"
      },
      "id": "603e9d27196a678e41a83db1"
    },
    {
      "sections": [
        "Manage errors in APM: Collect, ignore, or mark as expected",
        "Collect errors not instrumented by default",
        "Ignore errors",
        "Tip",
        "Ignore errors using server-side configuration in the UI",
        "Ignore errors using agent configuration",
        "Expected errors (Java, Node.js, Python, Ruby, and .NET only)",
        "View errors in the UI"
      ],
      "title": "Manage errors in APM: Collect, ignore, or mark as expected",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "ebd20f78d5084c48b1669ae33569da3f829fec6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/manage-errors-apm-collect-ignore-or-mark-expected/",
      "published_at": "2021-06-02T15:36:26Z",
      "updated_at": "2021-05-27T19:09:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM agents automatically report error data for supported frameworks. To optimize error reporting and alerting, you can further manage errors in order to: Catch errors that we don't instrument by default. Ignore errors that you don't want reported at all. Filter out noise from expected errors so you can focus on the errors that are affecting performance. (Java, Ruby, Node, Python, and .NET agents only) Collect errors not instrumented by default APM agents include API calls to report (or \"notice\") errors. These are useful when APM doesn't instrument your framework automatically or when there are particular errors that aren't caught for your supported framework. To learn how to get an APM agent to report an error, see the agent-specific API documentation: C SDK: newrelic_notice_error() Go: NoticeError() Java: NoticeError() .NET: NoticeError() Node.js: noticeError() PHP: newrelic_notice_error() Python: notice_error() Ruby: notice_error() Ignore errors Sometimes the APM agent instruments an error that you don't want reported, such as errors that contain sensitive information like user login errors. If you don't want an error to report to the our collector, you can ignore the error, and the APM agent discards the error entirely. Tip For Java, Ruby, Node.js, and Python: If you want to report errors to APM but don't want those errors to affect your Apdex or error rate, mark them as expected instead. There are two ways to ignore errors: through the agent configuration or through server-side configuration in the UI: Ignore errors using server-side configuration in the UI This option depends on whether the agent supports server-side configuration. If it is not already enabled, enable server-side configuration. Go to the Server-side configuration menu for the application that has errors that you want to ignore. Under Error collection, look for Ignore from error collection. Add the HTTP code or the Error class for the errors that you want to ignore. Select Save server-side configuration. Ignore errors using agent configuration To ignore an error using the agent configuration, see the configuration documentation for your agent: C SDK: Not available. For more information, see the C SDK errors example on GitHub. Go: ErrorCollector.IgnoreStatusCodes. Java: error_collector.ignore_classes, error_collector.ignore_classes.message, or error_collector.ignore_status_codes. For additional information, see Java agent error configuration. .NET: ignoreErrors or ignoreStatusCodes. Node.js: ignore_status_codes, ignore_classes, or ignore_messages. PHP: error_collector.ignore_exceptions or error_collector.ignore_errors. Python: error_collector.ignore_classes or error_collector.ignore_status_codes. Ruby: error_collector.ignore_errors. Expected errors (Java, Node.js, Python, Ruby, and .NET only) For the Ruby and Java agents, you can mark errors as expected. These errors will be reported to APM and available for viewing, but they won't affect the Apdex or error rate (or alert conditions based on error rate). To configure errors as expected, see the agent-specific documentation: Java Ruby Node.js .NET Python If expected errors are enabled, APM's Error analytics page will, by default, have a filter applied with the error.expected attribute set to false, meaning expected errors will not be displayed. To view expected errors, turn off the error.expected filter. To view expected errors, query your data: To view charts of expected errors, create a query for the error.expected attribute. To create alert conditions for NRQL queries, use the error.expected attribute. View errors in the UI Among other places, error data appears in these parts of the UI: Error analytics page: shows in-depth charts and visual analysis of errors. APM Overview page: shows a high-level view of your application, which includes errors. Alert conditions: can be based on error rate. The transactionError event: contains underlying error data, which can be used in NRQL queries.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 212.44223,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Manage</em> errors in <em>APM</em>: Collect, ignore, or mark as expected",
        "sections": "<em>Manage</em> errors in <em>APM</em>: Collect, ignore, or mark as expected",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": "<em>APM</em> <em>agents</em> automatically report error <em>data</em> for supported frameworks. To optimize error reporting and alerting, you can further <em>manage</em> errors in order to: Catch errors that we don&#x27;t instrument by default. Ignore errors that you don&#x27;t want reported at all. Filter out noise from expected errors so you"
      },
      "id": "6043f7d6196a67c1d4960f72"
    }
  ],
  "/docs/agents/manage-apm-agents/agent-data/link-your-applications-kubernetes": [
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 254.4364,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to each of these destinations. You can also collect custom attributes to send additional <em>data</em> to New Relic. Attribute destination flow This diagram illustrates how an <em>agent</em> decides to send attributes to each destination. <em>Agent</em> attribute collection: An <em>agent</em> makes three different decisions when sending"
      },
      "id": "603eb9db28ccbc127aeba79e"
    },
    {
      "sections": [
        "Real time streaming",
        "Why it matters",
        "Agent version to automatically enable",
        "Caution",
        "Query real time streaming data",
        "Create real time streaming charts"
      ],
      "title": "Real time streaming",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "ead7b5f2e74d1096a9ba796f3001be0b663941e0",
      "image": "https://docs.newrelic.com/static/5edbc3948f29fe9b1202aa05c9645b6a/c1b63/RTS.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/real-time-streaming/",
      "published_at": "2021-06-02T17:39:31Z",
      "updated_at": "2021-06-02T17:39:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With real time streaming, your APM event data is sent to New Relic every five seconds. You can query and visualize your data for transactions, errors, and custom events in near real time. The smaller payloads result in faster chart refreshes and faster queries of data that is the most important to you. No configuration is needed to take advantage of real time streaming. All you need to do is ensure your APM agent version is up to date. Why it matters Real time streaming doesn't result in more events being sent. The combination of more frequent posts, with a smaller number of events per post, results in approximately the same number of events per minute as there would be without real time streaming. The following image shows a comparison between data sent to New Relic with and without real time streaming. Note that 10,000 is an example number of events; some agents have lower default limits. The overall limits on how many events can be sent per minute haven't changed. Also, non-event data (spans, traces, and metrics) are unaffected; they're still sent every minute. Use real time streaming to quickly understand the impact when something has changed, such as deploying a new app version. Examine key performance indicators (throughput, error rates, charting, etc.) in near real time. Respond quickly to failure conditions and anomalies. Get the most out of New Relic One dashboards. Reduce mean time to detection with APM events reporting every five seconds. Agent version to automatically enable To enable real time streaming, update to the latest New Relic APM agent. You don't need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all APM agents. Here are the minimum agent versions: C SDK: v1.3.0 or higher Go: v2.8.0 or higher Java: v5.5.0 or higher .NET: v8.23.107.0 or higher Node.js: v5.13.0 or higher PHP: v9.5.0.252 or higher Python: v5.2.0.127 or higher Ruby: v6.7.0.359 or higher Caution If Transaction event reporting is disabled, this can affect some UI elements throughout New Relic. You may see some empty charts on some UI pages that rely on this data. Query real time streaming data When building charts, include the following in your NRQL query: NRQL clause Comments SINCE 5 minutes ago Be sure to add a SINCE 5 minutes ago clause to your NRQL query in order to take advantage of the 5 second chart refresh interval. This is because the chart's refresh interval is based on the time window. TIMESERIES bucket To set the refresh interval for time series charts, you can also specify the bucket size as an optional argument to the TIMESERIES clause. For example, SINCE 30 minutes ago TIMESERIES 5 seconds will display a 30 minute window at a 5 second resolution. You can have a maximum of 366 buckets. Create real time streaming charts You can visualize the results of your NRQL query in New Relic One: Go to one.newrelic.com, and at the top of the page, select Query your data. Use the query builder to start building a chart. Select the advanced (NRQL) mode. (If you start with basic mode, switch to advanced mode to complete the next step.) In your NRQL query, adjust the SINCE and TIMESERIES clauses to take advantage of the 5 second refresh intervals.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 254.35175,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Agent</em> version to automatically enable",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to automatically enable To enable real time streaming, update to the latest New Relic <em>APM</em> <em>agent</em>. You don&#x27;t need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all <em>APM</em> <em>agents</em>. Here are the minimum <em>agent</em> versions: C SDK: v1.3.0"
      },
      "id": "603e9d27196a678e41a83db1"
    },
    {
      "sections": [
        "Manage errors in APM: Collect, ignore, or mark as expected",
        "Collect errors not instrumented by default",
        "Ignore errors",
        "Tip",
        "Ignore errors using server-side configuration in the UI",
        "Ignore errors using agent configuration",
        "Expected errors (Java, Node.js, Python, Ruby, and .NET only)",
        "View errors in the UI"
      ],
      "title": "Manage errors in APM: Collect, ignore, or mark as expected",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "ebd20f78d5084c48b1669ae33569da3f829fec6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/manage-errors-apm-collect-ignore-or-mark-expected/",
      "published_at": "2021-06-02T15:36:26Z",
      "updated_at": "2021-05-27T19:09:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM agents automatically report error data for supported frameworks. To optimize error reporting and alerting, you can further manage errors in order to: Catch errors that we don't instrument by default. Ignore errors that you don't want reported at all. Filter out noise from expected errors so you can focus on the errors that are affecting performance. (Java, Ruby, Node, Python, and .NET agents only) Collect errors not instrumented by default APM agents include API calls to report (or \"notice\") errors. These are useful when APM doesn't instrument your framework automatically or when there are particular errors that aren't caught for your supported framework. To learn how to get an APM agent to report an error, see the agent-specific API documentation: C SDK: newrelic_notice_error() Go: NoticeError() Java: NoticeError() .NET: NoticeError() Node.js: noticeError() PHP: newrelic_notice_error() Python: notice_error() Ruby: notice_error() Ignore errors Sometimes the APM agent instruments an error that you don't want reported, such as errors that contain sensitive information like user login errors. If you don't want an error to report to the our collector, you can ignore the error, and the APM agent discards the error entirely. Tip For Java, Ruby, Node.js, and Python: If you want to report errors to APM but don't want those errors to affect your Apdex or error rate, mark them as expected instead. There are two ways to ignore errors: through the agent configuration or through server-side configuration in the UI: Ignore errors using server-side configuration in the UI This option depends on whether the agent supports server-side configuration. If it is not already enabled, enable server-side configuration. Go to the Server-side configuration menu for the application that has errors that you want to ignore. Under Error collection, look for Ignore from error collection. Add the HTTP code or the Error class for the errors that you want to ignore. Select Save server-side configuration. Ignore errors using agent configuration To ignore an error using the agent configuration, see the configuration documentation for your agent: C SDK: Not available. For more information, see the C SDK errors example on GitHub. Go: ErrorCollector.IgnoreStatusCodes. Java: error_collector.ignore_classes, error_collector.ignore_classes.message, or error_collector.ignore_status_codes. For additional information, see Java agent error configuration. .NET: ignoreErrors or ignoreStatusCodes. Node.js: ignore_status_codes, ignore_classes, or ignore_messages. PHP: error_collector.ignore_exceptions or error_collector.ignore_errors. Python: error_collector.ignore_classes or error_collector.ignore_status_codes. Ruby: error_collector.ignore_errors. Expected errors (Java, Node.js, Python, Ruby, and .NET only) For the Ruby and Java agents, you can mark errors as expected. These errors will be reported to APM and available for viewing, but they won't affect the Apdex or error rate (or alert conditions based on error rate). To configure errors as expected, see the agent-specific documentation: Java Ruby Node.js .NET Python If expected errors are enabled, APM's Error analytics page will, by default, have a filter applied with the error.expected attribute set to false, meaning expected errors will not be displayed. To view expected errors, turn off the error.expected filter. To view expected errors, query your data: To view charts of expected errors, create a query for the error.expected attribute. To create alert conditions for NRQL queries, use the error.expected attribute. View errors in the UI Among other places, error data appears in these parts of the UI: Error analytics page: shows in-depth charts and visual analysis of errors. APM Overview page: shows a high-level view of your application, which includes errors. Alert conditions: can be based on error rate. The transactionError event: contains underlying error data, which can be used in NRQL queries.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 212.44217,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Manage</em> errors in <em>APM</em>: Collect, ignore, or mark as expected",
        "sections": "<em>Manage</em> errors in <em>APM</em>: Collect, ignore, or mark as expected",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": "<em>APM</em> <em>agents</em> automatically report error <em>data</em> for supported frameworks. To optimize error reporting and alerting, you can further <em>manage</em> errors in order to: Catch errors that we don&#x27;t instrument by default. Ignore errors that you don&#x27;t want reported at all. Filter out noise from expected errors so you"
      },
      "id": "6043f7d6196a67c1d4960f72"
    }
  ],
  "/docs/agents/manage-apm-agents/agent-data/manage-errors-apm-collect-ignore-or-mark-expected": [
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 254.4364,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to each of these destinations. You can also collect custom attributes to send additional <em>data</em> to New Relic. Attribute destination flow This diagram illustrates how an <em>agent</em> decides to send attributes to each destination. <em>Agent</em> attribute collection: An <em>agent</em> makes three different decisions when sending"
      },
      "id": "603eb9db28ccbc127aeba79e"
    },
    {
      "sections": [
        "Real time streaming",
        "Why it matters",
        "Agent version to automatically enable",
        "Caution",
        "Query real time streaming data",
        "Create real time streaming charts"
      ],
      "title": "Real time streaming",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "ead7b5f2e74d1096a9ba796f3001be0b663941e0",
      "image": "https://docs.newrelic.com/static/5edbc3948f29fe9b1202aa05c9645b6a/c1b63/RTS.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/real-time-streaming/",
      "published_at": "2021-06-02T17:39:31Z",
      "updated_at": "2021-06-02T17:39:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With real time streaming, your APM event data is sent to New Relic every five seconds. You can query and visualize your data for transactions, errors, and custom events in near real time. The smaller payloads result in faster chart refreshes and faster queries of data that is the most important to you. No configuration is needed to take advantage of real time streaming. All you need to do is ensure your APM agent version is up to date. Why it matters Real time streaming doesn't result in more events being sent. The combination of more frequent posts, with a smaller number of events per post, results in approximately the same number of events per minute as there would be without real time streaming. The following image shows a comparison between data sent to New Relic with and without real time streaming. Note that 10,000 is an example number of events; some agents have lower default limits. The overall limits on how many events can be sent per minute haven't changed. Also, non-event data (spans, traces, and metrics) are unaffected; they're still sent every minute. Use real time streaming to quickly understand the impact when something has changed, such as deploying a new app version. Examine key performance indicators (throughput, error rates, charting, etc.) in near real time. Respond quickly to failure conditions and anomalies. Get the most out of New Relic One dashboards. Reduce mean time to detection with APM events reporting every five seconds. Agent version to automatically enable To enable real time streaming, update to the latest New Relic APM agent. You don't need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all APM agents. Here are the minimum agent versions: C SDK: v1.3.0 or higher Go: v2.8.0 or higher Java: v5.5.0 or higher .NET: v8.23.107.0 or higher Node.js: v5.13.0 or higher PHP: v9.5.0.252 or higher Python: v5.2.0.127 or higher Ruby: v6.7.0.359 or higher Caution If Transaction event reporting is disabled, this can affect some UI elements throughout New Relic. You may see some empty charts on some UI pages that rely on this data. Query real time streaming data When building charts, include the following in your NRQL query: NRQL clause Comments SINCE 5 minutes ago Be sure to add a SINCE 5 minutes ago clause to your NRQL query in order to take advantage of the 5 second chart refresh interval. This is because the chart's refresh interval is based on the time window. TIMESERIES bucket To set the refresh interval for time series charts, you can also specify the bucket size as an optional argument to the TIMESERIES clause. For example, SINCE 30 minutes ago TIMESERIES 5 seconds will display a 30 minute window at a 5 second resolution. You can have a maximum of 366 buckets. Create real time streaming charts You can visualize the results of your NRQL query in New Relic One: Go to one.newrelic.com, and at the top of the page, select Query your data. Use the query builder to start building a chart. Select the advanced (NRQL) mode. (If you start with basic mode, switch to advanced mode to complete the next step.) In your NRQL query, adjust the SINCE and TIMESERIES clauses to take advantage of the 5 second refresh intervals.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 254.35175,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Agent</em> version to automatically enable",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to automatically enable To enable real time streaming, update to the latest New Relic <em>APM</em> <em>agent</em>. You don&#x27;t need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all <em>APM</em> <em>agents</em>. Here are the minimum <em>agent</em> versions: C SDK: v1.3.0"
      },
      "id": "603e9d27196a678e41a83db1"
    },
    {
      "sections": [
        "Use multiple names for an app",
        "Important",
        "Roll up app data",
        "Prevent duplicate transaction events",
        "Roll up browser data",
        "Define app names from most to least specific",
        "Name app instances via agent config file",
        "Examples",
        "One app, three clusters",
        "Two instances of one app",
        "Other options to organize your apps"
      ],
      "title": "Use multiple names for an app",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "App naming"
      ],
      "external_id": "af78a44c170729aac326233d6468b0b61b6cdff2",
      "image": "https://docs.newrelic.com/static/67c256b1f08164be39b8eeb2ca8ff4e6/8c557/Insights-ToggleOnOff.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/app-naming/use-multiple-names-app/",
      "published_at": "2021-06-02T17:23:07Z",
      "updated_at": "2021-06-02T17:23:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When working with your data in New Relic, you may want to view aggregated data for an application across clusters, environments, or data centers, while at the same time be able to view each of your application instance's data individually. Important If you use multiple names for an app, the last name assigned is the least specific name New Relic uses to roll up the data. For best results to view both instance-level and aggregated data, set the order of your app's rollup names from most specific to least specific in your configuration file. Roll up app data Normally, when two instances report with the same app name, agent language, and license key, New Relic aggregates their data into a single app within the New Relic user interface. You can also view data for the individual hosts and instances from the app's New Relic APM Overview page. To segment your app in a different way, or to work with each instance as an individual app while maintaining the overall view of the data, use your New Relic agent's config file to give an app up to three different rollup names. New Relic will then report the app's data separately to each app listed in the config file. For example, you might want to separate the data collected for your app running in development, staging, and production environments, but also have a common view of the app in every environment. Or, if you have two data centers running the same code, you could name one app EastCoastApp;AggregateApp and the second app WestCoastApp;AggregateApp. Prevent duplicate transaction events By default, an app with multiple names will generate multiple events for transactions (a duplicate transaction for each name). For example, if you give your app three names, that's three times the number of events for transactions. To avoid duplicate events, disable collection for each of the duplicate app names: Go to one.newrelic.com or one.eu.newrelic.com > More > Manage Insights Data. Toggle data collection on/off for duplicate app names, then save. Roll up browser data When you use multiple names to report application data, any Browser monitoring data from that application will also be grouped into multiple applications using the same configuration. Important Session trace data will only report to the first application listed. Other Browser data will populate into each of the up to three applications, but session trace data will be limited to the most specific application. Define app names from most to least specific You can give each app up to three names, which New Relic uses to aggregate data from most to least specific. You can then use the New Relic UI to view data for each app name individually, as well as in aggregate for overall application performance. When doing so, the order in which you specify the app names is important. Using multiple names Comments Most specific A unique rollup name. Less specific A shared rollup name to aggregate data in the New Relic UI. This provides more general organization. Optional, least specific An additional, shared rollup name. If used, this is the most general name New Relic uses to aggregate data into a single app. Name app instances via agent config file The naming convention you use in your configuration file depends on your New Relic agent. Set the order of your app's names so that the first rollup name is the most unique. The second and third names can be unique, or they can be the same. The second name is more general for aggregate data, and the third name (if used) is the most general. Agent Configuration file value C Identify a maximum of three names separated by a semicolon ; in your newrelic_app_config_t * config;. Go Set AppName to a maximum of three names separated by a semicolon. Java Set app_name to a maximum of three names separated by a semicolon. .NET Use any of the available options to name your .NET app. Node.js Set app_name to a maximum of three names separated by a comma. Enclose the string of names with single or double quotes. (Or, change the environment variable NEW_RELIC_APP_NAME.) PHP Use any of the available options to name your PHP application. Use three names separated by a semicolon. Python Set app_name to a maximum of three names separated by a semicolon. Do not add a space after the semicolon, or the next name will be interpreted as a comment. Ruby Set app_name to a maximum of three names separated by a semicolon. For more information, refer to the configuration file documentation for your agent. Examples Here are examples of how you could use multiple rollup names for a single app. One app, three clusters A Java app collecting survey data runs on three clusters. Change the value for the app name in your agent config file by giving it three different names, one for each cluster. Cluster 1: app_name: SurveyCluster1;Survey Data Copy Cluster 2: app_name: SurveyCluster2;Survey Data Copy Cluster 3: app_name: SurveyCluster3;Survey Data Copy This will report four applications in New Relic APM: The app name for aggregate data from all three clusters is Survey Data. Three individual applications named SurveyCluster1, SurveyCluster2, and SurveyCluster3. Two instances of one app A PHP agent is monitoring an e-commerce application running on two clusters in each of two data centers, and you want to view data for each subgroup as well as the overall aggregated data. Cluster A: newrelic.appname=\"EcomClusterA;EcomEast;EcomAll\" Copy Cluster B: newrelic.appname=\"EcomClusterB;EcomEast;EcomAll\" Copy Cluster C: newrelic.appname=\"EcomClusterC;EcomWest;EcomAll\" Copy Cluster D: newrelic.appname=\"EcomClusterD;EcomWest;EcomAll\" Copy This example configuration will report seven applications in the New Relic APM UI: Four apps: One for each of the four clusters (A B C D) Two apps: One for each datacenter (East and West) One app for the overall data across clusters and data centers (EcomAll) Other options to organize your apps If you do not want to apply multiple names to your apps, you can organize them with labels and categories. This allows you to easily sort, filter, and page through them from their product index pages in the New Relic UI. You can also set distinct performance thresholds for each environment with alert conditions and key transactions. These thresholds will apply to the individual apps, while the overall app will not have its own thresholds. The overall app will treat incoming data according to the threshold for the relevant enviroment.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.77582,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Roll up app <em>data</em>",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " with the same app name, <em>agent</em> language, and license key, New Relic aggregates their <em>data</em> into a single app within the New Relic user interface. You can also view <em>data</em> for the individual hosts and instances from the app&#x27;s New Relic <em>APM</em> Overview page. To segment your app in a different way, or to work"
      },
      "id": "603ebde1196a677dbaa83dec"
    }
  ],
  "/docs/agents/manage-apm-agents/agent-data/real-time-streaming": [
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 254.43628,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to each of these destinations. You can also collect custom attributes to send additional <em>data</em> to New Relic. Attribute destination flow This diagram illustrates how an <em>agent</em> decides to send attributes to each destination. <em>Agent</em> attribute collection: An <em>agent</em> makes three different decisions when sending"
      },
      "id": "603eb9db28ccbc127aeba79e"
    },
    {
      "sections": [
        "Manage errors in APM: Collect, ignore, or mark as expected",
        "Collect errors not instrumented by default",
        "Ignore errors",
        "Tip",
        "Ignore errors using server-side configuration in the UI",
        "Ignore errors using agent configuration",
        "Expected errors (Java, Node.js, Python, Ruby, and .NET only)",
        "View errors in the UI"
      ],
      "title": "Manage errors in APM: Collect, ignore, or mark as expected",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "ebd20f78d5084c48b1669ae33569da3f829fec6b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/manage-errors-apm-collect-ignore-or-mark-expected/",
      "published_at": "2021-06-02T15:36:26Z",
      "updated_at": "2021-05-27T19:09:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "APM agents automatically report error data for supported frameworks. To optimize error reporting and alerting, you can further manage errors in order to: Catch errors that we don't instrument by default. Ignore errors that you don't want reported at all. Filter out noise from expected errors so you can focus on the errors that are affecting performance. (Java, Ruby, Node, Python, and .NET agents only) Collect errors not instrumented by default APM agents include API calls to report (or \"notice\") errors. These are useful when APM doesn't instrument your framework automatically or when there are particular errors that aren't caught for your supported framework. To learn how to get an APM agent to report an error, see the agent-specific API documentation: C SDK: newrelic_notice_error() Go: NoticeError() Java: NoticeError() .NET: NoticeError() Node.js: noticeError() PHP: newrelic_notice_error() Python: notice_error() Ruby: notice_error() Ignore errors Sometimes the APM agent instruments an error that you don't want reported, such as errors that contain sensitive information like user login errors. If you don't want an error to report to the our collector, you can ignore the error, and the APM agent discards the error entirely. Tip For Java, Ruby, Node.js, and Python: If you want to report errors to APM but don't want those errors to affect your Apdex or error rate, mark them as expected instead. There are two ways to ignore errors: through the agent configuration or through server-side configuration in the UI: Ignore errors using server-side configuration in the UI This option depends on whether the agent supports server-side configuration. If it is not already enabled, enable server-side configuration. Go to the Server-side configuration menu for the application that has errors that you want to ignore. Under Error collection, look for Ignore from error collection. Add the HTTP code or the Error class for the errors that you want to ignore. Select Save server-side configuration. Ignore errors using agent configuration To ignore an error using the agent configuration, see the configuration documentation for your agent: C SDK: Not available. For more information, see the C SDK errors example on GitHub. Go: ErrorCollector.IgnoreStatusCodes. Java: error_collector.ignore_classes, error_collector.ignore_classes.message, or error_collector.ignore_status_codes. For additional information, see Java agent error configuration. .NET: ignoreErrors or ignoreStatusCodes. Node.js: ignore_status_codes, ignore_classes, or ignore_messages. PHP: error_collector.ignore_exceptions or error_collector.ignore_errors. Python: error_collector.ignore_classes or error_collector.ignore_status_codes. Ruby: error_collector.ignore_errors. Expected errors (Java, Node.js, Python, Ruby, and .NET only) For the Ruby and Java agents, you can mark errors as expected. These errors will be reported to APM and available for viewing, but they won't affect the Apdex or error rate (or alert conditions based on error rate). To configure errors as expected, see the agent-specific documentation: Java Ruby Node.js .NET Python If expected errors are enabled, APM's Error analytics page will, by default, have a filter applied with the error.expected attribute set to false, meaning expected errors will not be displayed. To view expected errors, turn off the error.expected filter. To view expected errors, query your data: To view charts of expected errors, create a query for the error.expected attribute. To create alert conditions for NRQL queries, use the error.expected attribute. View errors in the UI Among other places, error data appears in these parts of the UI: Error analytics page: shows in-depth charts and visual analysis of errors. APM Overview page: shows a high-level view of your application, which includes errors. Alert conditions: can be based on error rate. The transactionError event: contains underlying error data, which can be used in NRQL queries.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 212.44211,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Manage</em> errors in <em>APM</em>: Collect, ignore, or mark as expected",
        "sections": "<em>Manage</em> errors in <em>APM</em>: Collect, ignore, or mark as expected",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": "<em>APM</em> <em>agents</em> automatically report error <em>data</em> for supported frameworks. To optimize error reporting and alerting, you can further <em>manage</em> errors in order to: Catch errors that we don&#x27;t instrument by default. Ignore errors that you don&#x27;t want reported at all. Filter out noise from expected errors so you"
      },
      "id": "6043f7d6196a67c1d4960f72"
    },
    {
      "sections": [
        "Use multiple names for an app",
        "Important",
        "Roll up app data",
        "Prevent duplicate transaction events",
        "Roll up browser data",
        "Define app names from most to least specific",
        "Name app instances via agent config file",
        "Examples",
        "One app, three clusters",
        "Two instances of one app",
        "Other options to organize your apps"
      ],
      "title": "Use multiple names for an app",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "App naming"
      ],
      "external_id": "af78a44c170729aac326233d6468b0b61b6cdff2",
      "image": "https://docs.newrelic.com/static/67c256b1f08164be39b8eeb2ca8ff4e6/8c557/Insights-ToggleOnOff.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/app-naming/use-multiple-names-app/",
      "published_at": "2021-06-02T17:23:07Z",
      "updated_at": "2021-06-02T17:23:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When working with your data in New Relic, you may want to view aggregated data for an application across clusters, environments, or data centers, while at the same time be able to view each of your application instance's data individually. Important If you use multiple names for an app, the last name assigned is the least specific name New Relic uses to roll up the data. For best results to view both instance-level and aggregated data, set the order of your app's rollup names from most specific to least specific in your configuration file. Roll up app data Normally, when two instances report with the same app name, agent language, and license key, New Relic aggregates their data into a single app within the New Relic user interface. You can also view data for the individual hosts and instances from the app's New Relic APM Overview page. To segment your app in a different way, or to work with each instance as an individual app while maintaining the overall view of the data, use your New Relic agent's config file to give an app up to three different rollup names. New Relic will then report the app's data separately to each app listed in the config file. For example, you might want to separate the data collected for your app running in development, staging, and production environments, but also have a common view of the app in every environment. Or, if you have two data centers running the same code, you could name one app EastCoastApp;AggregateApp and the second app WestCoastApp;AggregateApp. Prevent duplicate transaction events By default, an app with multiple names will generate multiple events for transactions (a duplicate transaction for each name). For example, if you give your app three names, that's three times the number of events for transactions. To avoid duplicate events, disable collection for each of the duplicate app names: Go to one.newrelic.com or one.eu.newrelic.com > More > Manage Insights Data. Toggle data collection on/off for duplicate app names, then save. Roll up browser data When you use multiple names to report application data, any Browser monitoring data from that application will also be grouped into multiple applications using the same configuration. Important Session trace data will only report to the first application listed. Other Browser data will populate into each of the up to three applications, but session trace data will be limited to the most specific application. Define app names from most to least specific You can give each app up to three names, which New Relic uses to aggregate data from most to least specific. You can then use the New Relic UI to view data for each app name individually, as well as in aggregate for overall application performance. When doing so, the order in which you specify the app names is important. Using multiple names Comments Most specific A unique rollup name. Less specific A shared rollup name to aggregate data in the New Relic UI. This provides more general organization. Optional, least specific An additional, shared rollup name. If used, this is the most general name New Relic uses to aggregate data into a single app. Name app instances via agent config file The naming convention you use in your configuration file depends on your New Relic agent. Set the order of your app's names so that the first rollup name is the most unique. The second and third names can be unique, or they can be the same. The second name is more general for aggregate data, and the third name (if used) is the most general. Agent Configuration file value C Identify a maximum of three names separated by a semicolon ; in your newrelic_app_config_t * config;. Go Set AppName to a maximum of three names separated by a semicolon. Java Set app_name to a maximum of three names separated by a semicolon. .NET Use any of the available options to name your .NET app. Node.js Set app_name to a maximum of three names separated by a comma. Enclose the string of names with single or double quotes. (Or, change the environment variable NEW_RELIC_APP_NAME.) PHP Use any of the available options to name your PHP application. Use three names separated by a semicolon. Python Set app_name to a maximum of three names separated by a semicolon. Do not add a space after the semicolon, or the next name will be interpreted as a comment. Ruby Set app_name to a maximum of three names separated by a semicolon. For more information, refer to the configuration file documentation for your agent. Examples Here are examples of how you could use multiple rollup names for a single app. One app, three clusters A Java app collecting survey data runs on three clusters. Change the value for the app name in your agent config file by giving it three different names, one for each cluster. Cluster 1: app_name: SurveyCluster1;Survey Data Copy Cluster 2: app_name: SurveyCluster2;Survey Data Copy Cluster 3: app_name: SurveyCluster3;Survey Data Copy This will report four applications in New Relic APM: The app name for aggregate data from all three clusters is Survey Data. Three individual applications named SurveyCluster1, SurveyCluster2, and SurveyCluster3. Two instances of one app A PHP agent is monitoring an e-commerce application running on two clusters in each of two data centers, and you want to view data for each subgroup as well as the overall aggregated data. Cluster A: newrelic.appname=\"EcomClusterA;EcomEast;EcomAll\" Copy Cluster B: newrelic.appname=\"EcomClusterB;EcomEast;EcomAll\" Copy Cluster C: newrelic.appname=\"EcomClusterC;EcomWest;EcomAll\" Copy Cluster D: newrelic.appname=\"EcomClusterD;EcomWest;EcomAll\" Copy This example configuration will report seven applications in the New Relic APM UI: Four apps: One for each of the four clusters (A B C D) Two apps: One for each datacenter (East and West) One app for the overall data across clusters and data centers (EcomAll) Other options to organize your apps If you do not want to apply multiple names to your apps, you can organize them with labels and categories. This allows you to easily sort, filter, and page through them from their product index pages in the New Relic UI. You can also set distinct performance thresholds for each environment with alert conditions and key transactions. These thresholds will apply to the individual apps, while the overall app will not have its own thresholds. The overall app will treat incoming data according to the threshold for the relevant enviroment.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.77573,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Roll up app <em>data</em>",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " with the same app name, <em>agent</em> language, and license key, New Relic aggregates their <em>data</em> into a single app within the New Relic user interface. You can also view <em>data</em> for the individual hosts and instances from the app&#x27;s New Relic <em>APM</em> Overview page. To segment your app in a different way, or to work"
      },
      "id": "603ebde1196a677dbaa83dec"
    }
  ],
  "/docs/agents/manage-apm-agents/app-naming/name-your-application": [
    {
      "sections": [
        "Use multiple names for an app",
        "Important",
        "Roll up app data",
        "Prevent duplicate transaction events",
        "Roll up browser data",
        "Define app names from most to least specific",
        "Name app instances via agent config file",
        "Examples",
        "One app, three clusters",
        "Two instances of one app",
        "Other options to organize your apps"
      ],
      "title": "Use multiple names for an app",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "App naming"
      ],
      "external_id": "af78a44c170729aac326233d6468b0b61b6cdff2",
      "image": "https://docs.newrelic.com/static/67c256b1f08164be39b8eeb2ca8ff4e6/8c557/Insights-ToggleOnOff.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/app-naming/use-multiple-names-app/",
      "published_at": "2021-06-02T17:23:07Z",
      "updated_at": "2021-06-02T17:23:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When working with your data in New Relic, you may want to view aggregated data for an application across clusters, environments, or data centers, while at the same time be able to view each of your application instance's data individually. Important If you use multiple names for an app, the last name assigned is the least specific name New Relic uses to roll up the data. For best results to view both instance-level and aggregated data, set the order of your app's rollup names from most specific to least specific in your configuration file. Roll up app data Normally, when two instances report with the same app name, agent language, and license key, New Relic aggregates their data into a single app within the New Relic user interface. You can also view data for the individual hosts and instances from the app's New Relic APM Overview page. To segment your app in a different way, or to work with each instance as an individual app while maintaining the overall view of the data, use your New Relic agent's config file to give an app up to three different rollup names. New Relic will then report the app's data separately to each app listed in the config file. For example, you might want to separate the data collected for your app running in development, staging, and production environments, but also have a common view of the app in every environment. Or, if you have two data centers running the same code, you could name one app EastCoastApp;AggregateApp and the second app WestCoastApp;AggregateApp. Prevent duplicate transaction events By default, an app with multiple names will generate multiple events for transactions (a duplicate transaction for each name). For example, if you give your app three names, that's three times the number of events for transactions. To avoid duplicate events, disable collection for each of the duplicate app names: Go to one.newrelic.com or one.eu.newrelic.com > More > Manage Insights Data. Toggle data collection on/off for duplicate app names, then save. Roll up browser data When you use multiple names to report application data, any Browser monitoring data from that application will also be grouped into multiple applications using the same configuration. Important Session trace data will only report to the first application listed. Other Browser data will populate into each of the up to three applications, but session trace data will be limited to the most specific application. Define app names from most to least specific You can give each app up to three names, which New Relic uses to aggregate data from most to least specific. You can then use the New Relic UI to view data for each app name individually, as well as in aggregate for overall application performance. When doing so, the order in which you specify the app names is important. Using multiple names Comments Most specific A unique rollup name. Less specific A shared rollup name to aggregate data in the New Relic UI. This provides more general organization. Optional, least specific An additional, shared rollup name. If used, this is the most general name New Relic uses to aggregate data into a single app. Name app instances via agent config file The naming convention you use in your configuration file depends on your New Relic agent. Set the order of your app's names so that the first rollup name is the most unique. The second and third names can be unique, or they can be the same. The second name is more general for aggregate data, and the third name (if used) is the most general. Agent Configuration file value C Identify a maximum of three names separated by a semicolon ; in your newrelic_app_config_t * config;. Go Set AppName to a maximum of three names separated by a semicolon. Java Set app_name to a maximum of three names separated by a semicolon. .NET Use any of the available options to name your .NET app. Node.js Set app_name to a maximum of three names separated by a comma. Enclose the string of names with single or double quotes. (Or, change the environment variable NEW_RELIC_APP_NAME.) PHP Use any of the available options to name your PHP application. Use three names separated by a semicolon. Python Set app_name to a maximum of three names separated by a semicolon. Do not add a space after the semicolon, or the next name will be interpreted as a comment. Ruby Set app_name to a maximum of three names separated by a semicolon. For more information, refer to the configuration file documentation for your agent. Examples Here are examples of how you could use multiple rollup names for a single app. One app, three clusters A Java app collecting survey data runs on three clusters. Change the value for the app name in your agent config file by giving it three different names, one for each cluster. Cluster 1: app_name: SurveyCluster1;Survey Data Copy Cluster 2: app_name: SurveyCluster2;Survey Data Copy Cluster 3: app_name: SurveyCluster3;Survey Data Copy This will report four applications in New Relic APM: The app name for aggregate data from all three clusters is Survey Data. Three individual applications named SurveyCluster1, SurveyCluster2, and SurveyCluster3. Two instances of one app A PHP agent is monitoring an e-commerce application running on two clusters in each of two data centers, and you want to view data for each subgroup as well as the overall aggregated data. Cluster A: newrelic.appname=\"EcomClusterA;EcomEast;EcomAll\" Copy Cluster B: newrelic.appname=\"EcomClusterB;EcomEast;EcomAll\" Copy Cluster C: newrelic.appname=\"EcomClusterC;EcomWest;EcomAll\" Copy Cluster D: newrelic.appname=\"EcomClusterD;EcomWest;EcomAll\" Copy This example configuration will report seven applications in the New Relic APM UI: Four apps: One for each of the four clusters (A B C D) Two apps: One for each datacenter (East and West) One app for the overall data across clusters and data centers (EcomAll) Other options to organize your apps If you do not want to apply multiple names to your apps, you can organize them with labels and categories. This allows you to easily sort, filter, and page through them from their product index pages in the New Relic UI. You can also set distinct performance thresholds for each environment with alert conditions and key transactions. These thresholds will apply to the individual apps, while the overall app will not have its own thresholds. The overall app will treat incoming data according to the threshold for the relevant enviroment.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 302.75934,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use multiple <em>names</em> for an <em>app</em>",
        "sections": "<em>Name</em> <em>app</em> instances via <em>agent</em> config file",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " with the same <em>app</em> <em>name</em>, <em>agent</em> language, and license key, New Relic aggregates their data into a single <em>app</em> within the New Relic user interface. You can also view data for the individual hosts and instances from the <em>app</em>&#x27;s New Relic <em>APM</em> Overview page. To segment your <em>app</em> in a different way, or to work"
      },
      "id": "603ebde1196a677dbaa83dec"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/update-left-navigation-pane/",
      "sections": [
        "Update left-navigation pane",
        "The configuration file",
        "Tip",
        "Configuration file options",
        "Use nav YAML to generate auto index content",
        "Nav requirements for auto index pages",
        "Example"
      ],
      "published_at": "2021-06-02T17:35:05Z",
      "title": "Update left-navigation pane",
      "updated_at": "2021-05-21T16:38:01Z",
      "type": "docs",
      "external_id": "a05e38602a1eb152749923691d251ef2c99f05a9",
      "document_type": "page",
      "popularity": 1,
      "body": "Navigation for docs.newrelic.com is stored in YAML files located in the /src/nav/ directory. Each top-level navigation should have its own configuration file. You'll most likely edit a version of this file in your branch and merge it into the develop branch. The configuration file As an example, here's a snippet of the agents.yml navigation configuration. Note that the file has indentation that corresponds to the level of the navigation hierarchy. Be sure to imitate the same spacing when you make changes: title: Agents path: /docs/agents pages: - title: Manage APM agents path: /docs/agents/manage-apm-agents pages: - title: Agent data path: /docs/agents/manage-apm-agents/agent-data pages: - title: Real time streaming path: /docs/agents/manage-apm-agents/agent-data/real-time-streaming - title: Custom instrumentation path: /docs/agents/manage-apm-agents/agent-data/custom-instrumentation - title: Agent attributes path: /docs/agents/manage-apm-agents/agent-data/agent-attributes - title: Custom events path: /docs/agents/manage-apm-agents/agent-data/collect-custom-events - title: Custom metrics path: /docs/agents/manage-apm-agents/agent-data/collect-custom-metrics - title: Manage errors path: /docs/agents/manage-apm-agents/agent-data/manage-errors-apm-collect-ignore-or-mark-expected - title: Link Kubernetes path: /docs/agents/manage-apm-agents/agent-data/link-your-applications-kubernetes - title: App naming pages: - title: Name your application path: /docs/agents/manage-apm-agents/app-naming/name-your-application - title: Use multiple names for an app path: /docs/agents/manage-apm-agents/app-naming/use-multiple-names-app Copy Tip Navigation nesting is currently limited to a maximum of six levels deep. Please reach out to the engineering team if that is not enough. Configuration file options When you're changing the navigation, keep in mind that each node in the .yml configuration file can have the following properties: Key Required? Description title yes The text that is shown in the navigation. path * no The URL path to the page. Do not use trailing slashes. * Adding a path is required to generate auto index page content. See path requirements below. children no Any sub-navigation nodes. When the user goes to a page, we determine which section of the site they are on and load the appropriate .yml file to populate the sidebar navigation. The navigation for the homepage is an aggregate of all the top-level pages. Tip Each category has its own index.md page (list of pages for that category). When updating the navigation, you may also want to update these pages to reflect the new information architecture more correctly. Use nav YAML to generate auto index content On build we automatically generate an index page for each sub-directory in src/content that does not already have an index.mdx file and that has at least one .mdx or .md file in it. When creating the page we look through each nav YAML file for a reference to the path to know which nav data to use for the left nav and the auto index page content. If an index page path is in more than one nav YAML file, we use the nav that matches its top level path with the beginning of index page path. Nav requirements for auto index pages In order to populate the auto index page with nav YAML data, you must add the index page path somewhere in the most relevant nav YAML file. This helps the auto index page plugin determine which nav to attach to the index page, but also helps the <IndexContents /> component know which section to display on the index page itself. Each nav item must reference a directory path in src/content that contains at least one .md or .mdx file (otherwise the auto index plugin does not create a page for it). Example If this auto index page is used in full-stack-observability.yml and integrations.yml, we will attach the integrations.yml nav to it because: the top level path in the integrations.yml matches the beginning of the auto index page path: title: Integrations path: /docs/integrations Copy matches this auto index page path: /docs/integrations /amazon-integrations/aws-integrations-list Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 180.8005,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " path: &#x2F;docs&#x2F;<em>agents</em>&#x2F;<em>manage</em>-<em>apm</em>-<em>agents</em>&#x2F;<em>agent</em>-data&#x2F;<em>manage</em>-errors-<em>apm</em>-collect-ignore-or-mark-expected - title: Link Kubernetes path: &#x2F;docs&#x2F;<em>agents</em>&#x2F;<em>manage</em>-<em>apm</em>-<em>agents</em>&#x2F;<em>agent</em>-data&#x2F;link-your-applications-kubernetes - title: <em>App</em> <em>naming</em> pages: - title: <em>Name</em> your application path: &#x2F;docs&#x2F;<em>agents</em>&#x2F;<em>manage</em>-<em>apm</em>-<em>agents</em>"
      },
      "id": "60422077196a67ad56a83dc8"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.86313,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by <em>agent</em>. (The properties in this diagram are specific to the PHP <em>agent</em>, but the general flow is the same for all <em>agents</em>. Property names and syntax vary by <em>agent</em>.) Types of attributes"
      },
      "id": "603eb9db28ccbc127aeba79e"
    }
  ],
  "/docs/agents/manage-apm-agents/app-naming/use-multiple-names-app": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/update-left-navigation-pane/",
      "sections": [
        "Update left-navigation pane",
        "The configuration file",
        "Tip",
        "Configuration file options",
        "Use nav YAML to generate auto index content",
        "Nav requirements for auto index pages",
        "Example"
      ],
      "published_at": "2021-06-02T17:35:05Z",
      "title": "Update left-navigation pane",
      "updated_at": "2021-05-21T16:38:01Z",
      "type": "docs",
      "external_id": "a05e38602a1eb152749923691d251ef2c99f05a9",
      "document_type": "page",
      "popularity": 1,
      "body": "Navigation for docs.newrelic.com is stored in YAML files located in the /src/nav/ directory. Each top-level navigation should have its own configuration file. You'll most likely edit a version of this file in your branch and merge it into the develop branch. The configuration file As an example, here's a snippet of the agents.yml navigation configuration. Note that the file has indentation that corresponds to the level of the navigation hierarchy. Be sure to imitate the same spacing when you make changes: title: Agents path: /docs/agents pages: - title: Manage APM agents path: /docs/agents/manage-apm-agents pages: - title: Agent data path: /docs/agents/manage-apm-agents/agent-data pages: - title: Real time streaming path: /docs/agents/manage-apm-agents/agent-data/real-time-streaming - title: Custom instrumentation path: /docs/agents/manage-apm-agents/agent-data/custom-instrumentation - title: Agent attributes path: /docs/agents/manage-apm-agents/agent-data/agent-attributes - title: Custom events path: /docs/agents/manage-apm-agents/agent-data/collect-custom-events - title: Custom metrics path: /docs/agents/manage-apm-agents/agent-data/collect-custom-metrics - title: Manage errors path: /docs/agents/manage-apm-agents/agent-data/manage-errors-apm-collect-ignore-or-mark-expected - title: Link Kubernetes path: /docs/agents/manage-apm-agents/agent-data/link-your-applications-kubernetes - title: App naming pages: - title: Name your application path: /docs/agents/manage-apm-agents/app-naming/name-your-application - title: Use multiple names for an app path: /docs/agents/manage-apm-agents/app-naming/use-multiple-names-app Copy Tip Navigation nesting is currently limited to a maximum of six levels deep. Please reach out to the engineering team if that is not enough. Configuration file options When you're changing the navigation, keep in mind that each node in the .yml configuration file can have the following properties: Key Required? Description title yes The text that is shown in the navigation. path * no The URL path to the page. Do not use trailing slashes. * Adding a path is required to generate auto index page content. See path requirements below. children no Any sub-navigation nodes. When the user goes to a page, we determine which section of the site they are on and load the appropriate .yml file to populate the sidebar navigation. The navigation for the homepage is an aggregate of all the top-level pages. Tip Each category has its own index.md page (list of pages for that category). When updating the navigation, you may also want to update these pages to reflect the new information architecture more correctly. Use nav YAML to generate auto index content On build we automatically generate an index page for each sub-directory in src/content that does not already have an index.mdx file and that has at least one .mdx or .md file in it. When creating the page we look through each nav YAML file for a reference to the path to know which nav data to use for the left nav and the auto index page content. If an index page path is in more than one nav YAML file, we use the nav that matches its top level path with the beginning of index page path. Nav requirements for auto index pages In order to populate the auto index page with nav YAML data, you must add the index page path somewhere in the most relevant nav YAML file. This helps the auto index page plugin determine which nav to attach to the index page, but also helps the <IndexContents /> component know which section to display on the index page itself. Each nav item must reference a directory path in src/content that contains at least one .md or .mdx file (otherwise the auto index plugin does not create a page for it). Example If this auto index page is used in full-stack-observability.yml and integrations.yml, we will attach the integrations.yml nav to it because: the top level path in the integrations.yml matches the beginning of the auto index page path: title: Integrations path: /docs/integrations Copy matches this auto index page path: /docs/integrations /amazon-integrations/aws-integrations-list Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 180.80048,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " path: &#x2F;docs&#x2F;<em>agents</em>&#x2F;<em>manage</em>-<em>apm</em>-<em>agents</em>&#x2F;<em>agent</em>-data&#x2F;<em>manage</em>-errors-<em>apm</em>-collect-ignore-or-mark-expected - title: Link Kubernetes path: &#x2F;docs&#x2F;<em>agents</em>&#x2F;<em>manage</em>-<em>apm</em>-<em>agents</em>&#x2F;<em>agent</em>-data&#x2F;link-your-applications-kubernetes - title: <em>App</em> <em>naming</em> pages: - title: <em>Name</em> your application path: &#x2F;docs&#x2F;<em>agents</em>&#x2F;<em>manage</em>-<em>apm</em>-<em>agents</em>"
      },
      "id": "60422077196a67ad56a83dc8"
    },
    {
      "sections": [
        "Name or change the name of your application",
        "Important",
        "Changing the name vs. the alias",
        "Give each app a descriptive name",
        "Assign the name in your config file",
        "Change the application's alias",
        "Tip",
        "Using multiple names for an app"
      ],
      "title": "Name or change the name of your application",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "App naming"
      ],
      "external_id": "bfd84f5a7908a84cbe4fa4e8ccb44be94997c85b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/app-naming/name-your-application/",
      "published_at": "2021-06-02T17:22:03Z",
      "updated_at": "2021-03-16T14:51:36Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic connects metrics to individual applications using your license key and the primary application name. You can change the app's name in your config file, or assign an alias to the app to change how it appears in the New Relic UI. Important If you do not specify the app name in your New Relic configuration file, most New Relic agents provide a generic application name by default. To ensure all aggregated data for the same app is reported accurately, make sure you give each app a descriptive name. Changing the name vs. the alias You can assign a new app name or change the app alias. These have two different effects: Term How to change it Effect Name Assign the name in your config file Changing the app name in the agent's configuration file will cause the application to report to a new heading in the New Relic user interface, with a total discontinuity of data. This is useful, for example, if you want to start over and report new data. If no other agents are reporting to the old app name, the old app name will appear gray and can be deleted. Alias Change the alias in the APM Settings UI Creating an alias for the app name only changes how the app name appears in the New Relic UI. Changing the alias does not affect how data is reported. It simply helps you keep track of your data with a useful alias. Give each app a descriptive name By default, most New Relic agents provide a default application name, such as My Application or PHP Application, for each app that is linked to your account. Important We recommend changing the default name of an app to a more descriptive name before deployment, and it can be up to 128 characters long. Each unique app name creates a new application record in your New Relic UI, which allows you to: Run an application on more than one host, and have all the data aggregated (collected) under the same name. Run multiple applications on a single host, and have all the data aggregated (collected) under different names. Assign the name in your config file To change the app name, set the app name value in the agent's configuration file. If you have deployed an app via one APM agent, and then deploy another app with the same name via a different APM agent, New Relic will automatically append the agent language name to the end of the second app's name. For example, if you deploy a Node.js app named New-App, and then deploy a .NET app named New-App, New Relic will automatically append the second app name as New-App (DOTNET). Agent Configuration file value C Identify a maximum of three names separated by a semicolon ;in your newrelic_app_config_t* config;. Go Set AppName to a maximum of three names separated by a semicolon. Java See the options for naming your Java application. .NET Use any of the available options to name your .NET app. Node.js Set app_name to a maximum of three names separated by a comma. Enclose the names with single or double quotes. (Or, change the environment variable NEW_RELIC_APP_NAME.) PHP See the options for naming your PHP application. Python Set app_name to a maximum of three names separated by a semicolon. Do not add a space after the semicolon, or the next name will be interpreted as a comment. Ruby Set app_name to a maximum of three names separated by a semicolon. Change the application's alias The application name you set in the New Relic user interface is a human-readable alias. If you rename your app, the visible name is updated everywhere in the New Relic site, including New Relic Browser. Initially, this alias is the same as the app's identifier name in the New Relic agent configuration file. However, changing the UI alias does not affect the underlying app name used for data rollup, which is set in the agent config file. The application must be actively reporting data to change the alias. Changing the UI alias will cause all agents that report under the app identifier to restart themselves. To change the alias for your application's name in the New Relic user interface: Go to one.newrelic.com > APM > (select an app) > Settings > Application. In the Application alias field, type a new name (alias) for the selected app. Select Save application settings. Tip You can also change the app's alias with the New Relic REST API. Using multiple names for an app By giving your app multiple names, you can aggregate metrics for multiple agents across an entire app or service. Important If you use multiple names for an app, the last name assigned is the least specific name New Relic uses to roll up the data. For best results to view both instance-level and aggregated data, set the order of your app's rollup names from most specific to least specific in your configuration file.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 176.07408,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Name</em> or change the <em>name</em> of your <em>application</em>",
        "sections": "<em>Name</em> or change the <em>name</em> of your <em>application</em>",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": ", for example, if you want to start over and report new data. If no other <em>agents</em> are reporting to the old <em>app</em> <em>name</em>, the old <em>app</em> <em>name</em> will appear gray and can be deleted. Alias Change the alias in the <em>APM</em> Settings UI Creating an alias for the <em>app</em> <em>name</em> only changes how the <em>app</em> <em>name</em> appears in the New Relic"
      },
      "id": "603eb81264441fa6a74e889a"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.86304,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by <em>agent</em>. (The properties in this diagram are specific to the PHP <em>agent</em>, but the general flow is the same for all <em>agents</em>. Property names and syntax vary by <em>agent</em>.) Types of attributes"
      },
      "id": "603eb9db28ccbc127aeba79e"
    }
  ],
  "/docs/agents/manage-apm-agents/configuration/add-rename-remove-hosts": [
    {
      "sections": [
        "Use multiple names for an app",
        "Important",
        "Roll up app data",
        "Prevent duplicate transaction events",
        "Roll up browser data",
        "Define app names from most to least specific",
        "Name app instances via agent config file",
        "Examples",
        "One app, three clusters",
        "Two instances of one app",
        "Other options to organize your apps"
      ],
      "title": "Use multiple names for an app",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "App naming"
      ],
      "external_id": "af78a44c170729aac326233d6468b0b61b6cdff2",
      "image": "https://docs.newrelic.com/static/67c256b1f08164be39b8eeb2ca8ff4e6/8c557/Insights-ToggleOnOff.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/app-naming/use-multiple-names-app/",
      "published_at": "2021-06-02T17:23:07Z",
      "updated_at": "2021-06-02T17:23:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When working with your data in New Relic, you may want to view aggregated data for an application across clusters, environments, or data centers, while at the same time be able to view each of your application instance's data individually. Important If you use multiple names for an app, the last name assigned is the least specific name New Relic uses to roll up the data. For best results to view both instance-level and aggregated data, set the order of your app's rollup names from most specific to least specific in your configuration file. Roll up app data Normally, when two instances report with the same app name, agent language, and license key, New Relic aggregates their data into a single app within the New Relic user interface. You can also view data for the individual hosts and instances from the app's New Relic APM Overview page. To segment your app in a different way, or to work with each instance as an individual app while maintaining the overall view of the data, use your New Relic agent's config file to give an app up to three different rollup names. New Relic will then report the app's data separately to each app listed in the config file. For example, you might want to separate the data collected for your app running in development, staging, and production environments, but also have a common view of the app in every environment. Or, if you have two data centers running the same code, you could name one app EastCoastApp;AggregateApp and the second app WestCoastApp;AggregateApp. Prevent duplicate transaction events By default, an app with multiple names will generate multiple events for transactions (a duplicate transaction for each name). For example, if you give your app three names, that's three times the number of events for transactions. To avoid duplicate events, disable collection for each of the duplicate app names: Go to one.newrelic.com or one.eu.newrelic.com > More > Manage Insights Data. Toggle data collection on/off for duplicate app names, then save. Roll up browser data When you use multiple names to report application data, any Browser monitoring data from that application will also be grouped into multiple applications using the same configuration. Important Session trace data will only report to the first application listed. Other Browser data will populate into each of the up to three applications, but session trace data will be limited to the most specific application. Define app names from most to least specific You can give each app up to three names, which New Relic uses to aggregate data from most to least specific. You can then use the New Relic UI to view data for each app name individually, as well as in aggregate for overall application performance. When doing so, the order in which you specify the app names is important. Using multiple names Comments Most specific A unique rollup name. Less specific A shared rollup name to aggregate data in the New Relic UI. This provides more general organization. Optional, least specific An additional, shared rollup name. If used, this is the most general name New Relic uses to aggregate data into a single app. Name app instances via agent config file The naming convention you use in your configuration file depends on your New Relic agent. Set the order of your app's names so that the first rollup name is the most unique. The second and third names can be unique, or they can be the same. The second name is more general for aggregate data, and the third name (if used) is the most general. Agent Configuration file value C Identify a maximum of three names separated by a semicolon ; in your newrelic_app_config_t * config;. Go Set AppName to a maximum of three names separated by a semicolon. Java Set app_name to a maximum of three names separated by a semicolon. .NET Use any of the available options to name your .NET app. Node.js Set app_name to a maximum of three names separated by a comma. Enclose the string of names with single or double quotes. (Or, change the environment variable NEW_RELIC_APP_NAME.) PHP Use any of the available options to name your PHP application. Use three names separated by a semicolon. Python Set app_name to a maximum of three names separated by a semicolon. Do not add a space after the semicolon, or the next name will be interpreted as a comment. Ruby Set app_name to a maximum of three names separated by a semicolon. For more information, refer to the configuration file documentation for your agent. Examples Here are examples of how you could use multiple rollup names for a single app. One app, three clusters A Java app collecting survey data runs on three clusters. Change the value for the app name in your agent config file by giving it three different names, one for each cluster. Cluster 1: app_name: SurveyCluster1;Survey Data Copy Cluster 2: app_name: SurveyCluster2;Survey Data Copy Cluster 3: app_name: SurveyCluster3;Survey Data Copy This will report four applications in New Relic APM: The app name for aggregate data from all three clusters is Survey Data. Three individual applications named SurveyCluster1, SurveyCluster2, and SurveyCluster3. Two instances of one app A PHP agent is monitoring an e-commerce application running on two clusters in each of two data centers, and you want to view data for each subgroup as well as the overall aggregated data. Cluster A: newrelic.appname=\"EcomClusterA;EcomEast;EcomAll\" Copy Cluster B: newrelic.appname=\"EcomClusterB;EcomEast;EcomAll\" Copy Cluster C: newrelic.appname=\"EcomClusterC;EcomWest;EcomAll\" Copy Cluster D: newrelic.appname=\"EcomClusterD;EcomWest;EcomAll\" Copy This example configuration will report seven applications in the New Relic APM UI: Four apps: One for each of the four clusters (A B C D) Two apps: One for each datacenter (East and West) One app for the overall data across clusters and data centers (EcomAll) Other options to organize your apps If you do not want to apply multiple names to your apps, you can organize them with labels and categories. This allows you to easily sort, filter, and page through them from their product index pages in the New Relic UI. You can also set distinct performance thresholds for each environment with alert conditions and key transactions. These thresholds will apply to the individual apps, while the overall app will not have its own thresholds. The overall app will treat incoming data according to the threshold for the relevant enviroment.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.56825,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Name app instances via <em>agent</em> config file",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " with the same app name, <em>agent</em> language, and license key, New Relic aggregates their data into a single app within the New Relic user interface. You can also view data for the individual hosts and instances from the app&#x27;s New Relic <em>APM</em> Overview page. To segment your app in a different way, or to work"
      },
      "id": "603ebde1196a677dbaa83dec"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 193.4691,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by <em>agent</em>. (The properties in this diagram are specific to the PHP <em>agent</em>, but the general flow is the same for all <em>agents</em>. Property names and syntax vary by <em>agent</em>.) Types of attributes"
      },
      "id": "603eb9db28ccbc127aeba79e"
    },
    {
      "sections": [
        "Real time streaming",
        "Why it matters",
        "Agent version to automatically enable",
        "Caution",
        "Query real time streaming data",
        "Create real time streaming charts"
      ],
      "title": "Real time streaming",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "ead7b5f2e74d1096a9ba796f3001be0b663941e0",
      "image": "https://docs.newrelic.com/static/5edbc3948f29fe9b1202aa05c9645b6a/c1b63/RTS.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/real-time-streaming/",
      "published_at": "2021-06-02T17:39:31Z",
      "updated_at": "2021-06-02T17:39:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With real time streaming, your APM event data is sent to New Relic every five seconds. You can query and visualize your data for transactions, errors, and custom events in near real time. The smaller payloads result in faster chart refreshes and faster queries of data that is the most important to you. No configuration is needed to take advantage of real time streaming. All you need to do is ensure your APM agent version is up to date. Why it matters Real time streaming doesn't result in more events being sent. The combination of more frequent posts, with a smaller number of events per post, results in approximately the same number of events per minute as there would be without real time streaming. The following image shows a comparison between data sent to New Relic with and without real time streaming. Note that 10,000 is an example number of events; some agents have lower default limits. The overall limits on how many events can be sent per minute haven't changed. Also, non-event data (spans, traces, and metrics) are unaffected; they're still sent every minute. Use real time streaming to quickly understand the impact when something has changed, such as deploying a new app version. Examine key performance indicators (throughput, error rates, charting, etc.) in near real time. Respond quickly to failure conditions and anomalies. Get the most out of New Relic One dashboards. Reduce mean time to detection with APM events reporting every five seconds. Agent version to automatically enable To enable real time streaming, update to the latest New Relic APM agent. You don't need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all APM agents. Here are the minimum agent versions: C SDK: v1.3.0 or higher Go: v2.8.0 or higher Java: v5.5.0 or higher .NET: v8.23.107.0 or higher Node.js: v5.13.0 or higher PHP: v9.5.0.252 or higher Python: v5.2.0.127 or higher Ruby: v6.7.0.359 or higher Caution If Transaction event reporting is disabled, this can affect some UI elements throughout New Relic. You may see some empty charts on some UI pages that rely on this data. Query real time streaming data When building charts, include the following in your NRQL query: NRQL clause Comments SINCE 5 minutes ago Be sure to add a SINCE 5 minutes ago clause to your NRQL query in order to take advantage of the 5 second chart refresh interval. This is because the chart's refresh interval is based on the time window. TIMESERIES bucket To set the refresh interval for time series charts, you can also specify the bucket size as an optional argument to the TIMESERIES clause. For example, SINCE 30 minutes ago TIMESERIES 5 seconds will display a 30 minute window at a 5 second resolution. You can have a maximum of 366 buckets. Create real time streaming charts You can visualize the results of your NRQL query in New Relic One: Go to one.newrelic.com, and at the top of the page, select Query your data. Use the query builder to start building a chart. Select the advanced (NRQL) mode. (If you start with basic mode, switch to advanced mode to complete the next step.) In your NRQL query, adjust the SINCE and TIMESERIES clauses to take advantage of the 5 second refresh intervals.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 193.40472,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Agent</em> version to automatically enable",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to you. No <em>configuration</em> is needed to take advantage of real time streaming. All you need to do is ensure your <em>APM</em> <em>agent</em> version is up to date. Why it matters Real time streaming doesn&#x27;t result in more events being sent. The combination of more frequent posts, with a smaller number of events per post"
      },
      "id": "603e9d27196a678e41a83db1"
    }
  ],
  "/docs/agents/manage-apm-agents/configuration/enable-configurable-security-policies": [
    {
      "sections": [
        "Use multiple names for an app",
        "Important",
        "Roll up app data",
        "Prevent duplicate transaction events",
        "Roll up browser data",
        "Define app names from most to least specific",
        "Name app instances via agent config file",
        "Examples",
        "One app, three clusters",
        "Two instances of one app",
        "Other options to organize your apps"
      ],
      "title": "Use multiple names for an app",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "App naming"
      ],
      "external_id": "af78a44c170729aac326233d6468b0b61b6cdff2",
      "image": "https://docs.newrelic.com/static/67c256b1f08164be39b8eeb2ca8ff4e6/8c557/Insights-ToggleOnOff.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/app-naming/use-multiple-names-app/",
      "published_at": "2021-06-02T17:23:07Z",
      "updated_at": "2021-06-02T17:23:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When working with your data in New Relic, you may want to view aggregated data for an application across clusters, environments, or data centers, while at the same time be able to view each of your application instance's data individually. Important If you use multiple names for an app, the last name assigned is the least specific name New Relic uses to roll up the data. For best results to view both instance-level and aggregated data, set the order of your app's rollup names from most specific to least specific in your configuration file. Roll up app data Normally, when two instances report with the same app name, agent language, and license key, New Relic aggregates their data into a single app within the New Relic user interface. You can also view data for the individual hosts and instances from the app's New Relic APM Overview page. To segment your app in a different way, or to work with each instance as an individual app while maintaining the overall view of the data, use your New Relic agent's config file to give an app up to three different rollup names. New Relic will then report the app's data separately to each app listed in the config file. For example, you might want to separate the data collected for your app running in development, staging, and production environments, but also have a common view of the app in every environment. Or, if you have two data centers running the same code, you could name one app EastCoastApp;AggregateApp and the second app WestCoastApp;AggregateApp. Prevent duplicate transaction events By default, an app with multiple names will generate multiple events for transactions (a duplicate transaction for each name). For example, if you give your app three names, that's three times the number of events for transactions. To avoid duplicate events, disable collection for each of the duplicate app names: Go to one.newrelic.com or one.eu.newrelic.com > More > Manage Insights Data. Toggle data collection on/off for duplicate app names, then save. Roll up browser data When you use multiple names to report application data, any Browser monitoring data from that application will also be grouped into multiple applications using the same configuration. Important Session trace data will only report to the first application listed. Other Browser data will populate into each of the up to three applications, but session trace data will be limited to the most specific application. Define app names from most to least specific You can give each app up to three names, which New Relic uses to aggregate data from most to least specific. You can then use the New Relic UI to view data for each app name individually, as well as in aggregate for overall application performance. When doing so, the order in which you specify the app names is important. Using multiple names Comments Most specific A unique rollup name. Less specific A shared rollup name to aggregate data in the New Relic UI. This provides more general organization. Optional, least specific An additional, shared rollup name. If used, this is the most general name New Relic uses to aggregate data into a single app. Name app instances via agent config file The naming convention you use in your configuration file depends on your New Relic agent. Set the order of your app's names so that the first rollup name is the most unique. The second and third names can be unique, or they can be the same. The second name is more general for aggregate data, and the third name (if used) is the most general. Agent Configuration file value C Identify a maximum of three names separated by a semicolon ; in your newrelic_app_config_t * config;. Go Set AppName to a maximum of three names separated by a semicolon. Java Set app_name to a maximum of three names separated by a semicolon. .NET Use any of the available options to name your .NET app. Node.js Set app_name to a maximum of three names separated by a comma. Enclose the string of names with single or double quotes. (Or, change the environment variable NEW_RELIC_APP_NAME.) PHP Use any of the available options to name your PHP application. Use three names separated by a semicolon. Python Set app_name to a maximum of three names separated by a semicolon. Do not add a space after the semicolon, or the next name will be interpreted as a comment. Ruby Set app_name to a maximum of three names separated by a semicolon. For more information, refer to the configuration file documentation for your agent. Examples Here are examples of how you could use multiple rollup names for a single app. One app, three clusters A Java app collecting survey data runs on three clusters. Change the value for the app name in your agent config file by giving it three different names, one for each cluster. Cluster 1: app_name: SurveyCluster1;Survey Data Copy Cluster 2: app_name: SurveyCluster2;Survey Data Copy Cluster 3: app_name: SurveyCluster3;Survey Data Copy This will report four applications in New Relic APM: The app name for aggregate data from all three clusters is Survey Data. Three individual applications named SurveyCluster1, SurveyCluster2, and SurveyCluster3. Two instances of one app A PHP agent is monitoring an e-commerce application running on two clusters in each of two data centers, and you want to view data for each subgroup as well as the overall aggregated data. Cluster A: newrelic.appname=\"EcomClusterA;EcomEast;EcomAll\" Copy Cluster B: newrelic.appname=\"EcomClusterB;EcomEast;EcomAll\" Copy Cluster C: newrelic.appname=\"EcomClusterC;EcomWest;EcomAll\" Copy Cluster D: newrelic.appname=\"EcomClusterD;EcomWest;EcomAll\" Copy This example configuration will report seven applications in the New Relic APM UI: Four apps: One for each of the four clusters (A B C D) Two apps: One for each datacenter (East and West) One app for the overall data across clusters and data centers (EcomAll) Other options to organize your apps If you do not want to apply multiple names to your apps, you can organize them with labels and categories. This allows you to easily sort, filter, and page through them from their product index pages in the New Relic UI. You can also set distinct performance thresholds for each environment with alert conditions and key transactions. These thresholds will apply to the individual apps, while the overall app will not have its own thresholds. The overall app will treat incoming data according to the threshold for the relevant enviroment.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.56815,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Name app instances via <em>agent</em> config file",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " with the same app name, <em>agent</em> language, and license key, New Relic aggregates their data into a single app within the New Relic user interface. You can also view data for the individual hosts and instances from the app&#x27;s New Relic <em>APM</em> Overview page. To segment your app in a different way, or to work"
      },
      "id": "603ebde1196a677dbaa83dec"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 193.46901,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by <em>agent</em>. (The properties in this diagram are specific to the PHP <em>agent</em>, but the general flow is the same for all <em>agents</em>. Property names and syntax vary by <em>agent</em>.) Types of attributes"
      },
      "id": "603eb9db28ccbc127aeba79e"
    },
    {
      "sections": [
        "Real time streaming",
        "Why it matters",
        "Agent version to automatically enable",
        "Caution",
        "Query real time streaming data",
        "Create real time streaming charts"
      ],
      "title": "Real time streaming",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "ead7b5f2e74d1096a9ba796f3001be0b663941e0",
      "image": "https://docs.newrelic.com/static/5edbc3948f29fe9b1202aa05c9645b6a/c1b63/RTS.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/real-time-streaming/",
      "published_at": "2021-06-02T17:39:31Z",
      "updated_at": "2021-06-02T17:39:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With real time streaming, your APM event data is sent to New Relic every five seconds. You can query and visualize your data for transactions, errors, and custom events in near real time. The smaller payloads result in faster chart refreshes and faster queries of data that is the most important to you. No configuration is needed to take advantage of real time streaming. All you need to do is ensure your APM agent version is up to date. Why it matters Real time streaming doesn't result in more events being sent. The combination of more frequent posts, with a smaller number of events per post, results in approximately the same number of events per minute as there would be without real time streaming. The following image shows a comparison between data sent to New Relic with and without real time streaming. Note that 10,000 is an example number of events; some agents have lower default limits. The overall limits on how many events can be sent per minute haven't changed. Also, non-event data (spans, traces, and metrics) are unaffected; they're still sent every minute. Use real time streaming to quickly understand the impact when something has changed, such as deploying a new app version. Examine key performance indicators (throughput, error rates, charting, etc.) in near real time. Respond quickly to failure conditions and anomalies. Get the most out of New Relic One dashboards. Reduce mean time to detection with APM events reporting every five seconds. Agent version to automatically enable To enable real time streaming, update to the latest New Relic APM agent. You don't need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all APM agents. Here are the minimum agent versions: C SDK: v1.3.0 or higher Go: v2.8.0 or higher Java: v5.5.0 or higher .NET: v8.23.107.0 or higher Node.js: v5.13.0 or higher PHP: v9.5.0.252 or higher Python: v5.2.0.127 or higher Ruby: v6.7.0.359 or higher Caution If Transaction event reporting is disabled, this can affect some UI elements throughout New Relic. You may see some empty charts on some UI pages that rely on this data. Query real time streaming data When building charts, include the following in your NRQL query: NRQL clause Comments SINCE 5 minutes ago Be sure to add a SINCE 5 minutes ago clause to your NRQL query in order to take advantage of the 5 second chart refresh interval. This is because the chart's refresh interval is based on the time window. TIMESERIES bucket To set the refresh interval for time series charts, you can also specify the bucket size as an optional argument to the TIMESERIES clause. For example, SINCE 30 minutes ago TIMESERIES 5 seconds will display a 30 minute window at a 5 second resolution. You can have a maximum of 366 buckets. Create real time streaming charts You can visualize the results of your NRQL query in New Relic One: Go to one.newrelic.com, and at the top of the page, select Query your data. Use the query builder to start building a chart. Select the advanced (NRQL) mode. (If you start with basic mode, switch to advanced mode to complete the next step.) In your NRQL query, adjust the SINCE and TIMESERIES clauses to take advantage of the 5 second refresh intervals.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 193.40462,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Agent</em> version to automatically enable",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to you. No <em>configuration</em> is needed to take advantage of real time streaming. All you need to do is ensure your <em>APM</em> <em>agent</em> version is up to date. Why it matters Real time streaming doesn&#x27;t result in more events being sent. The combination of more frequent posts, with a smaller number of events per post"
      },
      "id": "603e9d27196a678e41a83db1"
    }
  ],
  "/docs/agents/manage-apm-agents/configuration/high-security-mode": [
    {
      "sections": [
        "Use multiple names for an app",
        "Important",
        "Roll up app data",
        "Prevent duplicate transaction events",
        "Roll up browser data",
        "Define app names from most to least specific",
        "Name app instances via agent config file",
        "Examples",
        "One app, three clusters",
        "Two instances of one app",
        "Other options to organize your apps"
      ],
      "title": "Use multiple names for an app",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "App naming"
      ],
      "external_id": "af78a44c170729aac326233d6468b0b61b6cdff2",
      "image": "https://docs.newrelic.com/static/67c256b1f08164be39b8eeb2ca8ff4e6/8c557/Insights-ToggleOnOff.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/app-naming/use-multiple-names-app/",
      "published_at": "2021-06-02T17:23:07Z",
      "updated_at": "2021-06-02T17:23:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When working with your data in New Relic, you may want to view aggregated data for an application across clusters, environments, or data centers, while at the same time be able to view each of your application instance's data individually. Important If you use multiple names for an app, the last name assigned is the least specific name New Relic uses to roll up the data. For best results to view both instance-level and aggregated data, set the order of your app's rollup names from most specific to least specific in your configuration file. Roll up app data Normally, when two instances report with the same app name, agent language, and license key, New Relic aggregates their data into a single app within the New Relic user interface. You can also view data for the individual hosts and instances from the app's New Relic APM Overview page. To segment your app in a different way, or to work with each instance as an individual app while maintaining the overall view of the data, use your New Relic agent's config file to give an app up to three different rollup names. New Relic will then report the app's data separately to each app listed in the config file. For example, you might want to separate the data collected for your app running in development, staging, and production environments, but also have a common view of the app in every environment. Or, if you have two data centers running the same code, you could name one app EastCoastApp;AggregateApp and the second app WestCoastApp;AggregateApp. Prevent duplicate transaction events By default, an app with multiple names will generate multiple events for transactions (a duplicate transaction for each name). For example, if you give your app three names, that's three times the number of events for transactions. To avoid duplicate events, disable collection for each of the duplicate app names: Go to one.newrelic.com or one.eu.newrelic.com > More > Manage Insights Data. Toggle data collection on/off for duplicate app names, then save. Roll up browser data When you use multiple names to report application data, any Browser monitoring data from that application will also be grouped into multiple applications using the same configuration. Important Session trace data will only report to the first application listed. Other Browser data will populate into each of the up to three applications, but session trace data will be limited to the most specific application. Define app names from most to least specific You can give each app up to three names, which New Relic uses to aggregate data from most to least specific. You can then use the New Relic UI to view data for each app name individually, as well as in aggregate for overall application performance. When doing so, the order in which you specify the app names is important. Using multiple names Comments Most specific A unique rollup name. Less specific A shared rollup name to aggregate data in the New Relic UI. This provides more general organization. Optional, least specific An additional, shared rollup name. If used, this is the most general name New Relic uses to aggregate data into a single app. Name app instances via agent config file The naming convention you use in your configuration file depends on your New Relic agent. Set the order of your app's names so that the first rollup name is the most unique. The second and third names can be unique, or they can be the same. The second name is more general for aggregate data, and the third name (if used) is the most general. Agent Configuration file value C Identify a maximum of three names separated by a semicolon ; in your newrelic_app_config_t * config;. Go Set AppName to a maximum of three names separated by a semicolon. Java Set app_name to a maximum of three names separated by a semicolon. .NET Use any of the available options to name your .NET app. Node.js Set app_name to a maximum of three names separated by a comma. Enclose the string of names with single or double quotes. (Or, change the environment variable NEW_RELIC_APP_NAME.) PHP Use any of the available options to name your PHP application. Use three names separated by a semicolon. Python Set app_name to a maximum of three names separated by a semicolon. Do not add a space after the semicolon, or the next name will be interpreted as a comment. Ruby Set app_name to a maximum of three names separated by a semicolon. For more information, refer to the configuration file documentation for your agent. Examples Here are examples of how you could use multiple rollup names for a single app. One app, three clusters A Java app collecting survey data runs on three clusters. Change the value for the app name in your agent config file by giving it three different names, one for each cluster. Cluster 1: app_name: SurveyCluster1;Survey Data Copy Cluster 2: app_name: SurveyCluster2;Survey Data Copy Cluster 3: app_name: SurveyCluster3;Survey Data Copy This will report four applications in New Relic APM: The app name for aggregate data from all three clusters is Survey Data. Three individual applications named SurveyCluster1, SurveyCluster2, and SurveyCluster3. Two instances of one app A PHP agent is monitoring an e-commerce application running on two clusters in each of two data centers, and you want to view data for each subgroup as well as the overall aggregated data. Cluster A: newrelic.appname=\"EcomClusterA;EcomEast;EcomAll\" Copy Cluster B: newrelic.appname=\"EcomClusterB;EcomEast;EcomAll\" Copy Cluster C: newrelic.appname=\"EcomClusterC;EcomWest;EcomAll\" Copy Cluster D: newrelic.appname=\"EcomClusterD;EcomWest;EcomAll\" Copy This example configuration will report seven applications in the New Relic APM UI: Four apps: One for each of the four clusters (A B C D) Two apps: One for each datacenter (East and West) One app for the overall data across clusters and data centers (EcomAll) Other options to organize your apps If you do not want to apply multiple names to your apps, you can organize them with labels and categories. This allows you to easily sort, filter, and page through them from their product index pages in the New Relic UI. You can also set distinct performance thresholds for each environment with alert conditions and key transactions. These thresholds will apply to the individual apps, while the overall app will not have its own thresholds. The overall app will treat incoming data according to the threshold for the relevant enviroment.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.56815,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Name app instances via <em>agent</em> config file",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " with the same app name, <em>agent</em> language, and license key, New Relic aggregates their data into a single app within the New Relic user interface. You can also view data for the individual hosts and instances from the app&#x27;s New Relic <em>APM</em> Overview page. To segment your app in a different way, or to work"
      },
      "id": "603ebde1196a677dbaa83dec"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 193.46901,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by <em>agent</em>. (The properties in this diagram are specific to the PHP <em>agent</em>, but the general flow is the same for all <em>agents</em>. Property names and syntax vary by <em>agent</em>.) Types of attributes"
      },
      "id": "603eb9db28ccbc127aeba79e"
    },
    {
      "sections": [
        "Real time streaming",
        "Why it matters",
        "Agent version to automatically enable",
        "Caution",
        "Query real time streaming data",
        "Create real time streaming charts"
      ],
      "title": "Real time streaming",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "ead7b5f2e74d1096a9ba796f3001be0b663941e0",
      "image": "https://docs.newrelic.com/static/5edbc3948f29fe9b1202aa05c9645b6a/c1b63/RTS.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/real-time-streaming/",
      "published_at": "2021-06-02T17:39:31Z",
      "updated_at": "2021-06-02T17:39:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With real time streaming, your APM event data is sent to New Relic every five seconds. You can query and visualize your data for transactions, errors, and custom events in near real time. The smaller payloads result in faster chart refreshes and faster queries of data that is the most important to you. No configuration is needed to take advantage of real time streaming. All you need to do is ensure your APM agent version is up to date. Why it matters Real time streaming doesn't result in more events being sent. The combination of more frequent posts, with a smaller number of events per post, results in approximately the same number of events per minute as there would be without real time streaming. The following image shows a comparison between data sent to New Relic with and without real time streaming. Note that 10,000 is an example number of events; some agents have lower default limits. The overall limits on how many events can be sent per minute haven't changed. Also, non-event data (spans, traces, and metrics) are unaffected; they're still sent every minute. Use real time streaming to quickly understand the impact when something has changed, such as deploying a new app version. Examine key performance indicators (throughput, error rates, charting, etc.) in near real time. Respond quickly to failure conditions and anomalies. Get the most out of New Relic One dashboards. Reduce mean time to detection with APM events reporting every five seconds. Agent version to automatically enable To enable real time streaming, update to the latest New Relic APM agent. You don't need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all APM agents. Here are the minimum agent versions: C SDK: v1.3.0 or higher Go: v2.8.0 or higher Java: v5.5.0 or higher .NET: v8.23.107.0 or higher Node.js: v5.13.0 or higher PHP: v9.5.0.252 or higher Python: v5.2.0.127 or higher Ruby: v6.7.0.359 or higher Caution If Transaction event reporting is disabled, this can affect some UI elements throughout New Relic. You may see some empty charts on some UI pages that rely on this data. Query real time streaming data When building charts, include the following in your NRQL query: NRQL clause Comments SINCE 5 minutes ago Be sure to add a SINCE 5 minutes ago clause to your NRQL query in order to take advantage of the 5 second chart refresh interval. This is because the chart's refresh interval is based on the time window. TIMESERIES bucket To set the refresh interval for time series charts, you can also specify the bucket size as an optional argument to the TIMESERIES clause. For example, SINCE 30 minutes ago TIMESERIES 5 seconds will display a 30 minute window at a 5 second resolution. You can have a maximum of 366 buckets. Create real time streaming charts You can visualize the results of your NRQL query in New Relic One: Go to one.newrelic.com, and at the top of the page, select Query your data. Use the query builder to start building a chart. Select the advanced (NRQL) mode. (If you start with basic mode, switch to advanced mode to complete the next step.) In your NRQL query, adjust the SINCE and TIMESERIES clauses to take advantage of the 5 second refresh intervals.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 193.40462,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Agent</em> version to automatically enable",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to you. No <em>configuration</em> is needed to take advantage of real time streaming. All you need to do is ensure your <em>APM</em> <em>agent</em> version is up to date. Why it matters Real time streaming doesn&#x27;t result in more events being sent. The combination of more frequent posts, with a smaller number of events per post"
      },
      "id": "603e9d27196a678e41a83db1"
    }
  ],
  "/docs/agents/manage-apm-agents/configuration/server-side-agent-configuration": [
    {
      "sections": [
        "Use multiple names for an app",
        "Important",
        "Roll up app data",
        "Prevent duplicate transaction events",
        "Roll up browser data",
        "Define app names from most to least specific",
        "Name app instances via agent config file",
        "Examples",
        "One app, three clusters",
        "Two instances of one app",
        "Other options to organize your apps"
      ],
      "title": "Use multiple names for an app",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "App naming"
      ],
      "external_id": "af78a44c170729aac326233d6468b0b61b6cdff2",
      "image": "https://docs.newrelic.com/static/67c256b1f08164be39b8eeb2ca8ff4e6/8c557/Insights-ToggleOnOff.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/app-naming/use-multiple-names-app/",
      "published_at": "2021-06-02T17:23:07Z",
      "updated_at": "2021-06-02T17:23:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When working with your data in New Relic, you may want to view aggregated data for an application across clusters, environments, or data centers, while at the same time be able to view each of your application instance's data individually. Important If you use multiple names for an app, the last name assigned is the least specific name New Relic uses to roll up the data. For best results to view both instance-level and aggregated data, set the order of your app's rollup names from most specific to least specific in your configuration file. Roll up app data Normally, when two instances report with the same app name, agent language, and license key, New Relic aggregates their data into a single app within the New Relic user interface. You can also view data for the individual hosts and instances from the app's New Relic APM Overview page. To segment your app in a different way, or to work with each instance as an individual app while maintaining the overall view of the data, use your New Relic agent's config file to give an app up to three different rollup names. New Relic will then report the app's data separately to each app listed in the config file. For example, you might want to separate the data collected for your app running in development, staging, and production environments, but also have a common view of the app in every environment. Or, if you have two data centers running the same code, you could name one app EastCoastApp;AggregateApp and the second app WestCoastApp;AggregateApp. Prevent duplicate transaction events By default, an app with multiple names will generate multiple events for transactions (a duplicate transaction for each name). For example, if you give your app three names, that's three times the number of events for transactions. To avoid duplicate events, disable collection for each of the duplicate app names: Go to one.newrelic.com or one.eu.newrelic.com > More > Manage Insights Data. Toggle data collection on/off for duplicate app names, then save. Roll up browser data When you use multiple names to report application data, any Browser monitoring data from that application will also be grouped into multiple applications using the same configuration. Important Session trace data will only report to the first application listed. Other Browser data will populate into each of the up to three applications, but session trace data will be limited to the most specific application. Define app names from most to least specific You can give each app up to three names, which New Relic uses to aggregate data from most to least specific. You can then use the New Relic UI to view data for each app name individually, as well as in aggregate for overall application performance. When doing so, the order in which you specify the app names is important. Using multiple names Comments Most specific A unique rollup name. Less specific A shared rollup name to aggregate data in the New Relic UI. This provides more general organization. Optional, least specific An additional, shared rollup name. If used, this is the most general name New Relic uses to aggregate data into a single app. Name app instances via agent config file The naming convention you use in your configuration file depends on your New Relic agent. Set the order of your app's names so that the first rollup name is the most unique. The second and third names can be unique, or they can be the same. The second name is more general for aggregate data, and the third name (if used) is the most general. Agent Configuration file value C Identify a maximum of three names separated by a semicolon ; in your newrelic_app_config_t * config;. Go Set AppName to a maximum of three names separated by a semicolon. Java Set app_name to a maximum of three names separated by a semicolon. .NET Use any of the available options to name your .NET app. Node.js Set app_name to a maximum of three names separated by a comma. Enclose the string of names with single or double quotes. (Or, change the environment variable NEW_RELIC_APP_NAME.) PHP Use any of the available options to name your PHP application. Use three names separated by a semicolon. Python Set app_name to a maximum of three names separated by a semicolon. Do not add a space after the semicolon, or the next name will be interpreted as a comment. Ruby Set app_name to a maximum of three names separated by a semicolon. For more information, refer to the configuration file documentation for your agent. Examples Here are examples of how you could use multiple rollup names for a single app. One app, three clusters A Java app collecting survey data runs on three clusters. Change the value for the app name in your agent config file by giving it three different names, one for each cluster. Cluster 1: app_name: SurveyCluster1;Survey Data Copy Cluster 2: app_name: SurveyCluster2;Survey Data Copy Cluster 3: app_name: SurveyCluster3;Survey Data Copy This will report four applications in New Relic APM: The app name for aggregate data from all three clusters is Survey Data. Three individual applications named SurveyCluster1, SurveyCluster2, and SurveyCluster3. Two instances of one app A PHP agent is monitoring an e-commerce application running on two clusters in each of two data centers, and you want to view data for each subgroup as well as the overall aggregated data. Cluster A: newrelic.appname=\"EcomClusterA;EcomEast;EcomAll\" Copy Cluster B: newrelic.appname=\"EcomClusterB;EcomEast;EcomAll\" Copy Cluster C: newrelic.appname=\"EcomClusterC;EcomWest;EcomAll\" Copy Cluster D: newrelic.appname=\"EcomClusterD;EcomWest;EcomAll\" Copy This example configuration will report seven applications in the New Relic APM UI: Four apps: One for each of the four clusters (A B C D) Two apps: One for each datacenter (East and West) One app for the overall data across clusters and data centers (EcomAll) Other options to organize your apps If you do not want to apply multiple names to your apps, you can organize them with labels and categories. This allows you to easily sort, filter, and page through them from their product index pages in the New Relic UI. You can also set distinct performance thresholds for each environment with alert conditions and key transactions. These thresholds will apply to the individual apps, while the overall app will not have its own thresholds. The overall app will treat incoming data according to the threshold for the relevant enviroment.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.56805,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Name app instances via <em>agent</em> config file",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " with the same app name, <em>agent</em> language, and license key, New Relic aggregates their data into a single app within the New Relic user interface. You can also view data for the individual hosts and instances from the app&#x27;s New Relic <em>APM</em> Overview page. To segment your app in a different way, or to work"
      },
      "id": "603ebde1196a677dbaa83dec"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 193.4689,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by <em>agent</em>. (The properties in this diagram are specific to the PHP <em>agent</em>, but the general flow is the same for all <em>agents</em>. Property names and syntax vary by <em>agent</em>.) Types of attributes"
      },
      "id": "603eb9db28ccbc127aeba79e"
    },
    {
      "sections": [
        "Real time streaming",
        "Why it matters",
        "Agent version to automatically enable",
        "Caution",
        "Query real time streaming data",
        "Create real time streaming charts"
      ],
      "title": "Real time streaming",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "ead7b5f2e74d1096a9ba796f3001be0b663941e0",
      "image": "https://docs.newrelic.com/static/5edbc3948f29fe9b1202aa05c9645b6a/c1b63/RTS.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/real-time-streaming/",
      "published_at": "2021-06-02T17:39:31Z",
      "updated_at": "2021-06-02T17:39:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With real time streaming, your APM event data is sent to New Relic every five seconds. You can query and visualize your data for transactions, errors, and custom events in near real time. The smaller payloads result in faster chart refreshes and faster queries of data that is the most important to you. No configuration is needed to take advantage of real time streaming. All you need to do is ensure your APM agent version is up to date. Why it matters Real time streaming doesn't result in more events being sent. The combination of more frequent posts, with a smaller number of events per post, results in approximately the same number of events per minute as there would be without real time streaming. The following image shows a comparison between data sent to New Relic with and without real time streaming. Note that 10,000 is an example number of events; some agents have lower default limits. The overall limits on how many events can be sent per minute haven't changed. Also, non-event data (spans, traces, and metrics) are unaffected; they're still sent every minute. Use real time streaming to quickly understand the impact when something has changed, such as deploying a new app version. Examine key performance indicators (throughput, error rates, charting, etc.) in near real time. Respond quickly to failure conditions and anomalies. Get the most out of New Relic One dashboards. Reduce mean time to detection with APM events reporting every five seconds. Agent version to automatically enable To enable real time streaming, update to the latest New Relic APM agent. You don't need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all APM agents. Here are the minimum agent versions: C SDK: v1.3.0 or higher Go: v2.8.0 or higher Java: v5.5.0 or higher .NET: v8.23.107.0 or higher Node.js: v5.13.0 or higher PHP: v9.5.0.252 or higher Python: v5.2.0.127 or higher Ruby: v6.7.0.359 or higher Caution If Transaction event reporting is disabled, this can affect some UI elements throughout New Relic. You may see some empty charts on some UI pages that rely on this data. Query real time streaming data When building charts, include the following in your NRQL query: NRQL clause Comments SINCE 5 minutes ago Be sure to add a SINCE 5 minutes ago clause to your NRQL query in order to take advantage of the 5 second chart refresh interval. This is because the chart's refresh interval is based on the time window. TIMESERIES bucket To set the refresh interval for time series charts, you can also specify the bucket size as an optional argument to the TIMESERIES clause. For example, SINCE 30 minutes ago TIMESERIES 5 seconds will display a 30 minute window at a 5 second resolution. You can have a maximum of 366 buckets. Create real time streaming charts You can visualize the results of your NRQL query in New Relic One: Go to one.newrelic.com, and at the top of the page, select Query your data. Use the query builder to start building a chart. Select the advanced (NRQL) mode. (If you start with basic mode, switch to advanced mode to complete the next step.) In your NRQL query, adjust the SINCE and TIMESERIES clauses to take advantage of the 5 second refresh intervals.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 193.40453,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Agent</em> version to automatically enable",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to you. No <em>configuration</em> is needed to take advantage of real time streaming. All you need to do is ensure your <em>APM</em> <em>agent</em> version is up to date. Why it matters Real time streaming doesn&#x27;t result in more events being sent. The combination of more frequent posts, with a smaller number of events per post"
      },
      "id": "603e9d27196a678e41a83db1"
    }
  ],
  "/docs/agents/manage-apm-agents/configuration/view-config-values-your-app": [
    {
      "sections": [
        "Use multiple names for an app",
        "Important",
        "Roll up app data",
        "Prevent duplicate transaction events",
        "Roll up browser data",
        "Define app names from most to least specific",
        "Name app instances via agent config file",
        "Examples",
        "One app, three clusters",
        "Two instances of one app",
        "Other options to organize your apps"
      ],
      "title": "Use multiple names for an app",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "App naming"
      ],
      "external_id": "af78a44c170729aac326233d6468b0b61b6cdff2",
      "image": "https://docs.newrelic.com/static/67c256b1f08164be39b8eeb2ca8ff4e6/8c557/Insights-ToggleOnOff.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/app-naming/use-multiple-names-app/",
      "published_at": "2021-06-02T17:23:07Z",
      "updated_at": "2021-06-02T17:23:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When working with your data in New Relic, you may want to view aggregated data for an application across clusters, environments, or data centers, while at the same time be able to view each of your application instance's data individually. Important If you use multiple names for an app, the last name assigned is the least specific name New Relic uses to roll up the data. For best results to view both instance-level and aggregated data, set the order of your app's rollup names from most specific to least specific in your configuration file. Roll up app data Normally, when two instances report with the same app name, agent language, and license key, New Relic aggregates their data into a single app within the New Relic user interface. You can also view data for the individual hosts and instances from the app's New Relic APM Overview page. To segment your app in a different way, or to work with each instance as an individual app while maintaining the overall view of the data, use your New Relic agent's config file to give an app up to three different rollup names. New Relic will then report the app's data separately to each app listed in the config file. For example, you might want to separate the data collected for your app running in development, staging, and production environments, but also have a common view of the app in every environment. Or, if you have two data centers running the same code, you could name one app EastCoastApp;AggregateApp and the second app WestCoastApp;AggregateApp. Prevent duplicate transaction events By default, an app with multiple names will generate multiple events for transactions (a duplicate transaction for each name). For example, if you give your app three names, that's three times the number of events for transactions. To avoid duplicate events, disable collection for each of the duplicate app names: Go to one.newrelic.com or one.eu.newrelic.com > More > Manage Insights Data. Toggle data collection on/off for duplicate app names, then save. Roll up browser data When you use multiple names to report application data, any Browser monitoring data from that application will also be grouped into multiple applications using the same configuration. Important Session trace data will only report to the first application listed. Other Browser data will populate into each of the up to three applications, but session trace data will be limited to the most specific application. Define app names from most to least specific You can give each app up to three names, which New Relic uses to aggregate data from most to least specific. You can then use the New Relic UI to view data for each app name individually, as well as in aggregate for overall application performance. When doing so, the order in which you specify the app names is important. Using multiple names Comments Most specific A unique rollup name. Less specific A shared rollup name to aggregate data in the New Relic UI. This provides more general organization. Optional, least specific An additional, shared rollup name. If used, this is the most general name New Relic uses to aggregate data into a single app. Name app instances via agent config file The naming convention you use in your configuration file depends on your New Relic agent. Set the order of your app's names so that the first rollup name is the most unique. The second and third names can be unique, or they can be the same. The second name is more general for aggregate data, and the third name (if used) is the most general. Agent Configuration file value C Identify a maximum of three names separated by a semicolon ; in your newrelic_app_config_t * config;. Go Set AppName to a maximum of three names separated by a semicolon. Java Set app_name to a maximum of three names separated by a semicolon. .NET Use any of the available options to name your .NET app. Node.js Set app_name to a maximum of three names separated by a comma. Enclose the string of names with single or double quotes. (Or, change the environment variable NEW_RELIC_APP_NAME.) PHP Use any of the available options to name your PHP application. Use three names separated by a semicolon. Python Set app_name to a maximum of three names separated by a semicolon. Do not add a space after the semicolon, or the next name will be interpreted as a comment. Ruby Set app_name to a maximum of three names separated by a semicolon. For more information, refer to the configuration file documentation for your agent. Examples Here are examples of how you could use multiple rollup names for a single app. One app, three clusters A Java app collecting survey data runs on three clusters. Change the value for the app name in your agent config file by giving it three different names, one for each cluster. Cluster 1: app_name: SurveyCluster1;Survey Data Copy Cluster 2: app_name: SurveyCluster2;Survey Data Copy Cluster 3: app_name: SurveyCluster3;Survey Data Copy This will report four applications in New Relic APM: The app name for aggregate data from all three clusters is Survey Data. Three individual applications named SurveyCluster1, SurveyCluster2, and SurveyCluster3. Two instances of one app A PHP agent is monitoring an e-commerce application running on two clusters in each of two data centers, and you want to view data for each subgroup as well as the overall aggregated data. Cluster A: newrelic.appname=\"EcomClusterA;EcomEast;EcomAll\" Copy Cluster B: newrelic.appname=\"EcomClusterB;EcomEast;EcomAll\" Copy Cluster C: newrelic.appname=\"EcomClusterC;EcomWest;EcomAll\" Copy Cluster D: newrelic.appname=\"EcomClusterD;EcomWest;EcomAll\" Copy This example configuration will report seven applications in the New Relic APM UI: Four apps: One for each of the four clusters (A B C D) Two apps: One for each datacenter (East and West) One app for the overall data across clusters and data centers (EcomAll) Other options to organize your apps If you do not want to apply multiple names to your apps, you can organize them with labels and categories. This allows you to easily sort, filter, and page through them from their product index pages in the New Relic UI. You can also set distinct performance thresholds for each environment with alert conditions and key transactions. These thresholds will apply to the individual apps, while the overall app will not have its own thresholds. The overall app will treat incoming data according to the threshold for the relevant enviroment.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 202.56805,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Name app instances via <em>agent</em> config file",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " with the same app name, <em>agent</em> language, and license key, New Relic aggregates their data into a single app within the New Relic user interface. You can also view data for the individual hosts and instances from the app&#x27;s New Relic <em>APM</em> Overview page. To segment your app in a different way, or to work"
      },
      "id": "603ebde1196a677dbaa83dec"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 193.4689,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by <em>agent</em>. (The properties in this diagram are specific to the PHP <em>agent</em>, but the general flow is the same for all <em>agents</em>. Property names and syntax vary by <em>agent</em>.) Types of attributes"
      },
      "id": "603eb9db28ccbc127aeba79e"
    },
    {
      "sections": [
        "Real time streaming",
        "Why it matters",
        "Agent version to automatically enable",
        "Caution",
        "Query real time streaming data",
        "Create real time streaming charts"
      ],
      "title": "Real time streaming",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "ead7b5f2e74d1096a9ba796f3001be0b663941e0",
      "image": "https://docs.newrelic.com/static/5edbc3948f29fe9b1202aa05c9645b6a/c1b63/RTS.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/real-time-streaming/",
      "published_at": "2021-06-02T17:39:31Z",
      "updated_at": "2021-06-02T17:39:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With real time streaming, your APM event data is sent to New Relic every five seconds. You can query and visualize your data for transactions, errors, and custom events in near real time. The smaller payloads result in faster chart refreshes and faster queries of data that is the most important to you. No configuration is needed to take advantage of real time streaming. All you need to do is ensure your APM agent version is up to date. Why it matters Real time streaming doesn't result in more events being sent. The combination of more frequent posts, with a smaller number of events per post, results in approximately the same number of events per minute as there would be without real time streaming. The following image shows a comparison between data sent to New Relic with and without real time streaming. Note that 10,000 is an example number of events; some agents have lower default limits. The overall limits on how many events can be sent per minute haven't changed. Also, non-event data (spans, traces, and metrics) are unaffected; they're still sent every minute. Use real time streaming to quickly understand the impact when something has changed, such as deploying a new app version. Examine key performance indicators (throughput, error rates, charting, etc.) in near real time. Respond quickly to failure conditions and anomalies. Get the most out of New Relic One dashboards. Reduce mean time to detection with APM events reporting every five seconds. Agent version to automatically enable To enable real time streaming, update to the latest New Relic APM agent. You don't need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all APM agents. Here are the minimum agent versions: C SDK: v1.3.0 or higher Go: v2.8.0 or higher Java: v5.5.0 or higher .NET: v8.23.107.0 or higher Node.js: v5.13.0 or higher PHP: v9.5.0.252 or higher Python: v5.2.0.127 or higher Ruby: v6.7.0.359 or higher Caution If Transaction event reporting is disabled, this can affect some UI elements throughout New Relic. You may see some empty charts on some UI pages that rely on this data. Query real time streaming data When building charts, include the following in your NRQL query: NRQL clause Comments SINCE 5 minutes ago Be sure to add a SINCE 5 minutes ago clause to your NRQL query in order to take advantage of the 5 second chart refresh interval. This is because the chart's refresh interval is based on the time window. TIMESERIES bucket To set the refresh interval for time series charts, you can also specify the bucket size as an optional argument to the TIMESERIES clause. For example, SINCE 30 minutes ago TIMESERIES 5 seconds will display a 30 minute window at a 5 second resolution. You can have a maximum of 366 buckets. Create real time streaming charts You can visualize the results of your NRQL query in New Relic One: Go to one.newrelic.com, and at the top of the page, select Query your data. Use the query builder to start building a chart. Select the advanced (NRQL) mode. (If you start with basic mode, switch to advanced mode to complete the next step.) In your NRQL query, adjust the SINCE and TIMESERIES clauses to take advantage of the 5 second refresh intervals.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 193.40453,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Agent</em> version to automatically enable",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to you. No <em>configuration</em> is needed to take advantage of real time streaming. All you need to do is ensure your <em>APM</em> <em>agent</em> version is up to date. Why it matters Real time streaming doesn&#x27;t result in more events being sent. The combination of more frequent posts, with a smaller number of events per post"
      },
      "id": "603e9d27196a678e41a83db1"
    }
  ],
  "/docs/agents/manage-apm-agents/troubleshooting/agent-nrintegrationerrors-appear-insights": [
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.69238,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by <em>agent</em>. (The properties in this diagram are specific to the PHP <em>agent</em>, but the general flow is the same for all <em>agents</em>. Property names and syntax vary by <em>agent</em>.) Types of attributes"
      },
      "id": "603eb9db28ccbc127aeba79e"
    },
    {
      "sections": [
        "Real time streaming",
        "Why it matters",
        "Agent version to automatically enable",
        "Caution",
        "Query real time streaming data",
        "Create real time streaming charts"
      ],
      "title": "Real time streaming",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "ead7b5f2e74d1096a9ba796f3001be0b663941e0",
      "image": "https://docs.newrelic.com/static/5edbc3948f29fe9b1202aa05c9645b6a/c1b63/RTS.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/real-time-streaming/",
      "published_at": "2021-06-02T17:39:31Z",
      "updated_at": "2021-06-02T17:39:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With real time streaming, your APM event data is sent to New Relic every five seconds. You can query and visualize your data for transactions, errors, and custom events in near real time. The smaller payloads result in faster chart refreshes and faster queries of data that is the most important to you. No configuration is needed to take advantage of real time streaming. All you need to do is ensure your APM agent version is up to date. Why it matters Real time streaming doesn't result in more events being sent. The combination of more frequent posts, with a smaller number of events per post, results in approximately the same number of events per minute as there would be without real time streaming. The following image shows a comparison between data sent to New Relic with and without real time streaming. Note that 10,000 is an example number of events; some agents have lower default limits. The overall limits on how many events can be sent per minute haven't changed. Also, non-event data (spans, traces, and metrics) are unaffected; they're still sent every minute. Use real time streaming to quickly understand the impact when something has changed, such as deploying a new app version. Examine key performance indicators (throughput, error rates, charting, etc.) in near real time. Respond quickly to failure conditions and anomalies. Get the most out of New Relic One dashboards. Reduce mean time to detection with APM events reporting every five seconds. Agent version to automatically enable To enable real time streaming, update to the latest New Relic APM agent. You don't need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all APM agents. Here are the minimum agent versions: C SDK: v1.3.0 or higher Go: v2.8.0 or higher Java: v5.5.0 or higher .NET: v8.23.107.0 or higher Node.js: v5.13.0 or higher PHP: v9.5.0.252 or higher Python: v5.2.0.127 or higher Ruby: v6.7.0.359 or higher Caution If Transaction event reporting is disabled, this can affect some UI elements throughout New Relic. You may see some empty charts on some UI pages that rely on this data. Query real time streaming data When building charts, include the following in your NRQL query: NRQL clause Comments SINCE 5 minutes ago Be sure to add a SINCE 5 minutes ago clause to your NRQL query in order to take advantage of the 5 second chart refresh interval. This is because the chart's refresh interval is based on the time window. TIMESERIES bucket To set the refresh interval for time series charts, you can also specify the bucket size as an optional argument to the TIMESERIES clause. For example, SINCE 30 minutes ago TIMESERIES 5 seconds will display a 30 minute window at a 5 second resolution. You can have a maximum of 366 buckets. Create real time streaming charts You can visualize the results of your NRQL query in New Relic One: Go to one.newrelic.com, and at the top of the page, select Query your data. Use the query builder to start building a chart. Select the advanced (NRQL) mode. (If you start with basic mode, switch to advanced mode to complete the next step.) In your NRQL query, adjust the SINCE and TIMESERIES clauses to take advantage of the 5 second refresh intervals.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.63559,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Agent</em> version to automatically enable",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to automatically enable To enable real time streaming, update to the latest New Relic <em>APM</em> <em>agent</em>. You don&#x27;t need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all <em>APM</em> <em>agents</em>. Here are the minimum <em>agent</em> versions: C SDK: v1.3.0"
      },
      "id": "603e9d27196a678e41a83db1"
    },
    {
      "sections": [
        "Use multiple names for an app",
        "Important",
        "Roll up app data",
        "Prevent duplicate transaction events",
        "Roll up browser data",
        "Define app names from most to least specific",
        "Name app instances via agent config file",
        "Examples",
        "One app, three clusters",
        "Two instances of one app",
        "Other options to organize your apps"
      ],
      "title": "Use multiple names for an app",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "App naming"
      ],
      "external_id": "af78a44c170729aac326233d6468b0b61b6cdff2",
      "image": "https://docs.newrelic.com/static/67c256b1f08164be39b8eeb2ca8ff4e6/8c557/Insights-ToggleOnOff.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/app-naming/use-multiple-names-app/",
      "published_at": "2021-06-02T17:23:07Z",
      "updated_at": "2021-06-02T17:23:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When working with your data in New Relic, you may want to view aggregated data for an application across clusters, environments, or data centers, while at the same time be able to view each of your application instance's data individually. Important If you use multiple names for an app, the last name assigned is the least specific name New Relic uses to roll up the data. For best results to view both instance-level and aggregated data, set the order of your app's rollup names from most specific to least specific in your configuration file. Roll up app data Normally, when two instances report with the same app name, agent language, and license key, New Relic aggregates their data into a single app within the New Relic user interface. You can also view data for the individual hosts and instances from the app's New Relic APM Overview page. To segment your app in a different way, or to work with each instance as an individual app while maintaining the overall view of the data, use your New Relic agent's config file to give an app up to three different rollup names. New Relic will then report the app's data separately to each app listed in the config file. For example, you might want to separate the data collected for your app running in development, staging, and production environments, but also have a common view of the app in every environment. Or, if you have two data centers running the same code, you could name one app EastCoastApp;AggregateApp and the second app WestCoastApp;AggregateApp. Prevent duplicate transaction events By default, an app with multiple names will generate multiple events for transactions (a duplicate transaction for each name). For example, if you give your app three names, that's three times the number of events for transactions. To avoid duplicate events, disable collection for each of the duplicate app names: Go to one.newrelic.com or one.eu.newrelic.com > More > Manage Insights Data. Toggle data collection on/off for duplicate app names, then save. Roll up browser data When you use multiple names to report application data, any Browser monitoring data from that application will also be grouped into multiple applications using the same configuration. Important Session trace data will only report to the first application listed. Other Browser data will populate into each of the up to three applications, but session trace data will be limited to the most specific application. Define app names from most to least specific You can give each app up to three names, which New Relic uses to aggregate data from most to least specific. You can then use the New Relic UI to view data for each app name individually, as well as in aggregate for overall application performance. When doing so, the order in which you specify the app names is important. Using multiple names Comments Most specific A unique rollup name. Less specific A shared rollup name to aggregate data in the New Relic UI. This provides more general organization. Optional, least specific An additional, shared rollup name. If used, this is the most general name New Relic uses to aggregate data into a single app. Name app instances via agent config file The naming convention you use in your configuration file depends on your New Relic agent. Set the order of your app's names so that the first rollup name is the most unique. The second and third names can be unique, or they can be the same. The second name is more general for aggregate data, and the third name (if used) is the most general. Agent Configuration file value C Identify a maximum of three names separated by a semicolon ; in your newrelic_app_config_t * config;. Go Set AppName to a maximum of three names separated by a semicolon. Java Set app_name to a maximum of three names separated by a semicolon. .NET Use any of the available options to name your .NET app. Node.js Set app_name to a maximum of three names separated by a comma. Enclose the string of names with single or double quotes. (Or, change the environment variable NEW_RELIC_APP_NAME.) PHP Use any of the available options to name your PHP application. Use three names separated by a semicolon. Python Set app_name to a maximum of three names separated by a semicolon. Do not add a space after the semicolon, or the next name will be interpreted as a comment. Ruby Set app_name to a maximum of three names separated by a semicolon. For more information, refer to the configuration file documentation for your agent. Examples Here are examples of how you could use multiple rollup names for a single app. One app, three clusters A Java app collecting survey data runs on three clusters. Change the value for the app name in your agent config file by giving it three different names, one for each cluster. Cluster 1: app_name: SurveyCluster1;Survey Data Copy Cluster 2: app_name: SurveyCluster2;Survey Data Copy Cluster 3: app_name: SurveyCluster3;Survey Data Copy This will report four applications in New Relic APM: The app name for aggregate data from all three clusters is Survey Data. Three individual applications named SurveyCluster1, SurveyCluster2, and SurveyCluster3. Two instances of one app A PHP agent is monitoring an e-commerce application running on two clusters in each of two data centers, and you want to view data for each subgroup as well as the overall aggregated data. Cluster A: newrelic.appname=\"EcomClusterA;EcomEast;EcomAll\" Copy Cluster B: newrelic.appname=\"EcomClusterB;EcomEast;EcomAll\" Copy Cluster C: newrelic.appname=\"EcomClusterC;EcomWest;EcomAll\" Copy Cluster D: newrelic.appname=\"EcomClusterD;EcomWest;EcomAll\" Copy This example configuration will report seven applications in the New Relic APM UI: Four apps: One for each of the four clusters (A B C D) Two apps: One for each datacenter (East and West) One app for the overall data across clusters and data centers (EcomAll) Other options to organize your apps If you do not want to apply multiple names to your apps, you can organize them with labels and categories. This allows you to easily sort, filter, and page through them from their product index pages in the New Relic UI. You can also set distinct performance thresholds for each environment with alert conditions and key transactions. These thresholds will apply to the individual apps, while the overall app will not have its own thresholds. The overall app will treat incoming data according to the threshold for the relevant enviroment.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.77548,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Name app instances via <em>agent</em> config file",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " with the same app name, <em>agent</em> language, and license key, New Relic aggregates their data into a single app within the New Relic user interface. You can also view data for the individual hosts and instances from the app&#x27;s New Relic <em>APM</em> Overview page. To segment your app in a different way, or to work"
      },
      "id": "603ebde1196a677dbaa83dec"
    }
  ],
  "/docs/agents/manage-apm-agents/troubleshooting/get-environment-data-about-your-apm-app": [
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.6923,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by <em>agent</em>. (The properties in this diagram are specific to the PHP <em>agent</em>, but the general flow is the same for all <em>agents</em>. Property names and syntax vary by <em>agent</em>.) Types of attributes"
      },
      "id": "603eb9db28ccbc127aeba79e"
    },
    {
      "sections": [
        "Real time streaming",
        "Why it matters",
        "Agent version to automatically enable",
        "Caution",
        "Query real time streaming data",
        "Create real time streaming charts"
      ],
      "title": "Real time streaming",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "ead7b5f2e74d1096a9ba796f3001be0b663941e0",
      "image": "https://docs.newrelic.com/static/5edbc3948f29fe9b1202aa05c9645b6a/c1b63/RTS.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/real-time-streaming/",
      "published_at": "2021-06-02T17:39:31Z",
      "updated_at": "2021-06-02T17:39:31Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With real time streaming, your APM event data is sent to New Relic every five seconds. You can query and visualize your data for transactions, errors, and custom events in near real time. The smaller payloads result in faster chart refreshes and faster queries of data that is the most important to you. No configuration is needed to take advantage of real time streaming. All you need to do is ensure your APM agent version is up to date. Why it matters Real time streaming doesn't result in more events being sent. The combination of more frequent posts, with a smaller number of events per post, results in approximately the same number of events per minute as there would be without real time streaming. The following image shows a comparison between data sent to New Relic with and without real time streaming. Note that 10,000 is an example number of events; some agents have lower default limits. The overall limits on how many events can be sent per minute haven't changed. Also, non-event data (spans, traces, and metrics) are unaffected; they're still sent every minute. Use real time streaming to quickly understand the impact when something has changed, such as deploying a new app version. Examine key performance indicators (throughput, error rates, charting, etc.) in near real time. Respond quickly to failure conditions and anomalies. Get the most out of New Relic One dashboards. Reduce mean time to detection with APM events reporting every five seconds. Agent version to automatically enable To enable real time streaming, update to the latest New Relic APM agent. You don't need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all APM agents. Here are the minimum agent versions: C SDK: v1.3.0 or higher Go: v2.8.0 or higher Java: v5.5.0 or higher .NET: v8.23.107.0 or higher Node.js: v5.13.0 or higher PHP: v9.5.0.252 or higher Python: v5.2.0.127 or higher Ruby: v6.7.0.359 or higher Caution If Transaction event reporting is disabled, this can affect some UI elements throughout New Relic. You may see some empty charts on some UI pages that rely on this data. Query real time streaming data When building charts, include the following in your NRQL query: NRQL clause Comments SINCE 5 minutes ago Be sure to add a SINCE 5 minutes ago clause to your NRQL query in order to take advantage of the 5 second chart refresh interval. This is because the chart's refresh interval is based on the time window. TIMESERIES bucket To set the refresh interval for time series charts, you can also specify the bucket size as an optional argument to the TIMESERIES clause. For example, SINCE 30 minutes ago TIMESERIES 5 seconds will display a 30 minute window at a 5 second resolution. You can have a maximum of 366 buckets. Create real time streaming charts You can visualize the results of your NRQL query in New Relic One: Go to one.newrelic.com, and at the top of the page, select Query your data. Use the query builder to start building a chart. Select the advanced (NRQL) mode. (If you start with basic mode, switch to advanced mode to complete the next step.) In your NRQL query, adjust the SINCE and TIMESERIES clauses to take advantage of the 5 second refresh intervals.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 170.6355,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Agent</em> version to automatically enable",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " to automatically enable To enable real time streaming, update to the latest New Relic <em>APM</em> <em>agent</em>. You don&#x27;t need to configure anything to enable real time streaming; it will automatically report faster! Real time streaming is supported by all <em>APM</em> <em>agents</em>. Here are the minimum <em>agent</em> versions: C SDK: v1.3.0"
      },
      "id": "603e9d27196a678e41a83db1"
    },
    {
      "sections": [
        "Use multiple names for an app",
        "Important",
        "Roll up app data",
        "Prevent duplicate transaction events",
        "Roll up browser data",
        "Define app names from most to least specific",
        "Name app instances via agent config file",
        "Examples",
        "One app, three clusters",
        "Two instances of one app",
        "Other options to organize your apps"
      ],
      "title": "Use multiple names for an app",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "App naming"
      ],
      "external_id": "af78a44c170729aac326233d6468b0b61b6cdff2",
      "image": "https://docs.newrelic.com/static/67c256b1f08164be39b8eeb2ca8ff4e6/8c557/Insights-ToggleOnOff.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/app-naming/use-multiple-names-app/",
      "published_at": "2021-06-02T17:23:07Z",
      "updated_at": "2021-06-02T17:23:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "When working with your data in New Relic, you may want to view aggregated data for an application across clusters, environments, or data centers, while at the same time be able to view each of your application instance's data individually. Important If you use multiple names for an app, the last name assigned is the least specific name New Relic uses to roll up the data. For best results to view both instance-level and aggregated data, set the order of your app's rollup names from most specific to least specific in your configuration file. Roll up app data Normally, when two instances report with the same app name, agent language, and license key, New Relic aggregates their data into a single app within the New Relic user interface. You can also view data for the individual hosts and instances from the app's New Relic APM Overview page. To segment your app in a different way, or to work with each instance as an individual app while maintaining the overall view of the data, use your New Relic agent's config file to give an app up to three different rollup names. New Relic will then report the app's data separately to each app listed in the config file. For example, you might want to separate the data collected for your app running in development, staging, and production environments, but also have a common view of the app in every environment. Or, if you have two data centers running the same code, you could name one app EastCoastApp;AggregateApp and the second app WestCoastApp;AggregateApp. Prevent duplicate transaction events By default, an app with multiple names will generate multiple events for transactions (a duplicate transaction for each name). For example, if you give your app three names, that's three times the number of events for transactions. To avoid duplicate events, disable collection for each of the duplicate app names: Go to one.newrelic.com or one.eu.newrelic.com > More > Manage Insights Data. Toggle data collection on/off for duplicate app names, then save. Roll up browser data When you use multiple names to report application data, any Browser monitoring data from that application will also be grouped into multiple applications using the same configuration. Important Session trace data will only report to the first application listed. Other Browser data will populate into each of the up to three applications, but session trace data will be limited to the most specific application. Define app names from most to least specific You can give each app up to three names, which New Relic uses to aggregate data from most to least specific. You can then use the New Relic UI to view data for each app name individually, as well as in aggregate for overall application performance. When doing so, the order in which you specify the app names is important. Using multiple names Comments Most specific A unique rollup name. Less specific A shared rollup name to aggregate data in the New Relic UI. This provides more general organization. Optional, least specific An additional, shared rollup name. If used, this is the most general name New Relic uses to aggregate data into a single app. Name app instances via agent config file The naming convention you use in your configuration file depends on your New Relic agent. Set the order of your app's names so that the first rollup name is the most unique. The second and third names can be unique, or they can be the same. The second name is more general for aggregate data, and the third name (if used) is the most general. Agent Configuration file value C Identify a maximum of three names separated by a semicolon ; in your newrelic_app_config_t * config;. Go Set AppName to a maximum of three names separated by a semicolon. Java Set app_name to a maximum of three names separated by a semicolon. .NET Use any of the available options to name your .NET app. Node.js Set app_name to a maximum of three names separated by a comma. Enclose the string of names with single or double quotes. (Or, change the environment variable NEW_RELIC_APP_NAME.) PHP Use any of the available options to name your PHP application. Use three names separated by a semicolon. Python Set app_name to a maximum of three names separated by a semicolon. Do not add a space after the semicolon, or the next name will be interpreted as a comment. Ruby Set app_name to a maximum of three names separated by a semicolon. For more information, refer to the configuration file documentation for your agent. Examples Here are examples of how you could use multiple rollup names for a single app. One app, three clusters A Java app collecting survey data runs on three clusters. Change the value for the app name in your agent config file by giving it three different names, one for each cluster. Cluster 1: app_name: SurveyCluster1;Survey Data Copy Cluster 2: app_name: SurveyCluster2;Survey Data Copy Cluster 3: app_name: SurveyCluster3;Survey Data Copy This will report four applications in New Relic APM: The app name for aggregate data from all three clusters is Survey Data. Three individual applications named SurveyCluster1, SurveyCluster2, and SurveyCluster3. Two instances of one app A PHP agent is monitoring an e-commerce application running on two clusters in each of two data centers, and you want to view data for each subgroup as well as the overall aggregated data. Cluster A: newrelic.appname=\"EcomClusterA;EcomEast;EcomAll\" Copy Cluster B: newrelic.appname=\"EcomClusterB;EcomEast;EcomAll\" Copy Cluster C: newrelic.appname=\"EcomClusterC;EcomWest;EcomAll\" Copy Cluster D: newrelic.appname=\"EcomClusterD;EcomWest;EcomAll\" Copy This example configuration will report seven applications in the New Relic APM UI: Four apps: One for each of the four clusters (A B C D) Two apps: One for each datacenter (East and West) One app for the overall data across clusters and data centers (EcomAll) Other options to organize your apps If you do not want to apply multiple names to your apps, you can organize them with labels and categories. This allows you to easily sort, filter, and page through them from their product index pages in the New Relic UI. You can also set distinct performance thresholds for each environment with alert conditions and key transactions. These thresholds will apply to the individual apps, while the overall app will not have its own thresholds. The overall app will treat incoming data according to the threshold for the relevant enviroment.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 166.77542,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Name app instances via <em>agent</em> config file",
        "tags": "<em>Manage</em> <em>APM</em> <em>agents</em>",
        "body": " with the same app name, <em>agent</em> language, and license key, New Relic aggregates their data into a single app within the New Relic user interface. You can also view data for the individual hosts and instances from the app&#x27;s New Relic <em>APM</em> Overview page. To segment your app in a different way, or to work"
      },
      "id": "603ebde1196a677dbaa83dec"
    }
  ],
  "/docs/agents/net-agent/api-guides/guide-using-net-agent-api": [
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.07985,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Guide</em> to using the Java <em>agent</em> <em>API</em> ",
        "sections": "<em>Guide</em> to using the Java <em>agent</em> <em>API</em>",
        "tags": "<em>API</em> <em>guides</em>",
        "body": "The New Relic Java <em>agent</em> <em>API</em> lets you control, customize, and extend the functionality of the APM Java <em>agent</em>. This <em>API</em> consists of: Static methods on the com.newrelic.<em>api.agent</em>.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of <em>API</em> objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    },
    {
      "sections": [
        "Guide to using the Python agent API",
        "Custom instrumentation or API",
        "Monitor transactions and segments",
        "Add and edit transaction metadata",
        "Report custom events and custom metric data",
        "Message-related calls",
        "Implement distributed tracing",
        "Agent configuration, initialization, shutdown",
        "Control the Browser monitoring agent"
      ],
      "title": "Guide to using the Python agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "Python agent",
        "API guides"
      ],
      "external_id": "41f2cf33977b57e872b8c69a30b77fd603b51926",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/python-agent/api-guides/guide-using-python-agent-api/",
      "published_at": "2021-06-02T13:37:41Z",
      "updated_at": "2021-06-02T13:37:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Python agent API allows you to customize and extend your monitoring. Use the Python agent API to: Manually instrument an unsupported framework or third-party system. Add instrumentation to supplement the agent's default monitoring. This document describes some of the available Python API calls. For a description of all our available APIs, see Introduction to APIs. Custom instrumentation or API If your goal is custom instrumentation, consider using the configuration file method, which allows you to add functions and class methods to the config file that will be auto-instrumented by the agent. The benefit of the config-file method is that it does not require you to change your application code. However, the Python agent API is much more powerful and is best for setting up more complex and tailored instrumentation. To ensure you have access to the full API functionality, update to the latest Python agent. Monitor transactions and segments The Python agent is compatible with most of the common WSGI web frameworks. If the agent supports your framework, web requests automatically will be captured as transactions and displayed in the New Relic One UI. A transaction can also have function-level segments that are captured as part of a transaction trace. Use these methods to monitor web transactions, non-web transactions, and transaction segments: If you want to... Do this... Monitor WSGI web transactions The Python agent automatically captures web transactions for supported frameworks. If you do not have a supported framework, you can use the wsgi_application function to monitor your WSGI entry point. Monitor non-web transactions The Python agent classifies non-web transactions as background tasks. To capture non-web transactions, use background_task. Capture more details about a transaction If your transaction traces do not have the level of detail you want: Use function_trace to capture more function-level detail in transactions. Use datastore_trace to capture more detail about datastore calls. Ignore a transaction Use any of these options: To ignore a transaction altogether, use ignore_transaction. To prevent a transaction from producing a transaction trace, use suppress_transaction_trace. To end a transaction before the agent would end it automatically, use end_of_transaction. Add and edit transaction metadata Sometimes the code you target is visible in our UI, but some details of the method are not useful. For example: The default name is not helpful, or it is causing a metric grouping issue. You want to add custom attributes to your transactions so you can filter them when querying. Use these calls when you want to change the metadata of an existing transaction: If you want to... Do this... Get reference to current transaction To return an object representing the current transaction, use current_transaction. This is required by some other Python agent API calls. Change the name of a transaction Use set_transaction_name. Add metadata (such as a customer's subscription level) to transactions Add custom attributes to your transactions using add_custom_parameter, or use other API calls to report custom data. Mark a transaction as a background job To convert a web transaction into a background task so that it appears as a non-web transaction in the UI, use set_background_task. Prevent a transaction from affecting your Apdex score Use suppress_apdex_metric. Report custom events and custom metric data The agent reports data in two primary forms: Metric data measures numeric, time-based values; for example, connections per minute. Event data captures discrete event information. Events have key-value attributes attached to them. You can analyze and query event data. Use these methods to create new event data and new metric data: If you want to... Do this... Send data about an event for use when querying your data. Use record_custom_event. Report time-based metrics on application performance To report a single metric, use record_custom_metric. To report a set of metrics, use record_custom_metrics. Report an exception as an error By default, the Python agent only reports unhandled exceptions. To report a Python exception as an error, use notice_error. Report query string parameters For security reasons, query string parameters associated with web transactions are disabled by default. Use capture_request_params to enable them. Tag events with metadata To add attributes to events for more detailed analysis in Insights or error analytics, use add_custom_parameter. Generate metrics from data sources and data factories To generate metrics with a pull-style API rather than the push-style API implemented by record_custom_metric(), use these API calls: register_data_source data_source_generator data_source_factory Message-related calls These API calls allow you to collect performance data on your message-passing architecture or service; for example, RabbitMQ. To use these calls, make sure you have Python agent version 2.88.0.72 or higher. If you want to... Do this... Report messages as a transaction Use message_transaction. Report message details as transaction trace segments Use message_trace. Implement distributed tracing These APIs require distributed tracing to be enabled. Services and applications monitored by our agents will automatically pass distributed tracing context to each other when using a supported framework. When not using a supported framework, you will need to use the distributed tracing APIs to manually accept this context. Supported web frameworks (for example, Flask, Django, Tornado) will automatically call accept_distributed_trace_payload when creating a transaction. Supported external web services libraries will automatically call create_distributed_trace_payload before making an external HTTP call. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. If you want to... Do this... Create a payload to be sent to a called service. Use create_distributed_trace_payload. Accept a payload sent from the first service; this will link these services together in a trace Use accept_distributed_trace_payload. Agent configuration, initialization, shutdown These calls help you manage Python agent behavior, such as initializing and integrating the agent, and referencing or changing configuration settings: If you want to... Do this... Initialize the agent To initialize the Python agent with a specific configuration file as part of advanced integration process, use initialize. Get a reference to the application object The application object represents an agent-monitored application and is used by some Python agent API calls. Get a reference to configuration settings To control the Python agent's behavior, you can use configuration settings. To get a reference to config file and environment variable settings and make changes to them, use global_settings. To get a reference to all settings, including server-side configuration from our UI, use application_settings. Shut down the agent To forcibly shut down the agent instead of allowing it to make the standard final attempt to upload data, use shutdown_agent. Control the Browser monitoring agent You can install the browser monitoring agent by automatically adding it to your pages or by deploying it on specific pages by copying and pasting the browser agent JavaScript snippet. You can also control the browser agent by using APM agent API calls. For more information, see Browser agent and the Python agent. If you want to... Do this... Monitor specific page views To inject the browser agent header and footer JavaScript snippets into views you want to monitor, use both get_browser_timing_header and get_browser_timing_footer. Disable monitoring of specific page views To disable browser monitoring for specific page views, use disable_browser_autorum.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 108.72714,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Guide</em> to using the Python <em>agent</em> <em>API</em>",
        "sections": "<em>Guide</em> to using the Python <em>agent</em> <em>API</em>",
        "tags": "<em>API</em> <em>guides</em>",
        "body": "The Python <em>agent</em> <em>API</em> allows you to customize and extend your monitoring. Use the Python <em>agent</em> <em>API</em> to: Manually instrument an unsupported framework or third-party system. Add instrumentation to supplement the <em>agent</em>&#x27;s default monitoring. This document describes some of the available Python <em>API</em> calls"
      },
      "id": "60441c8d64441f0ec7378eff"
    },
    {
      "sections": [
        ".NET agent configuration",
        "Configuration overview",
        "Important",
        "Configuration methods and precedence levels",
        "Required environment variables",
        "Caution",
        ".NET Framework environment variables",
        ".NET Core environment variables",
        "Profiler conflict explanation",
        "Optional environment variables",
        "Setup options, newrelic.config",
        "Configuration element",
        "agentEnabled",
        "maxStackTraceLines",
        "timingPrecision",
        "Service element",
        "licenseKey (required)",
        "sendEnvironmentInfo",
        "syncStartup",
        "sendDataOnExit",
        "sendDataOnExitThreshold",
        "completeTransactionsOnThread",
        "requestTimeout",
        "autoStart",
        "ssl (DEPRECATED)",
        "Obscuring key element",
        "Proxy element",
        "host",
        "port",
        "uriPath",
        "domain",
        "user",
        "password",
        "passwordObfuscated",
        "Log element",
        "level",
        "auditLog",
        "console",
        "directory",
        "fileName",
        "Application element (required)",
        "name",
        "disableSamplers",
        "Data transmission element",
        "putForDataSend",
        "Host name",
        "Set using config file",
        "Set using environment variable",
        "Cloud platform utilization",
        "detectAws",
        "detectAzure",
        "detectGcp",
        "detectPcf",
        "detectDocker",
        "detectKubernetes",
        "Instrumentation options",
        "Instrumentation element",
        "Applications element (instrumentation)",
        "Attributes element",
        "enabled",
        "include",
        "exclude",
        "Feature options",
        "App pools",
        "defaultBehavior",
        "applicationPool",
        "Cross application traces",
        "Error collection",
        "Tip",
        "captureEvents",
        "maxEventSamplesStored",
        "ignoreClasses",
        "ignoreMessages",
        "ignoreErrors (DEPRECATED)",
        "ignoreStatusCodes",
        "expectedClasses",
        "expectedMessages",
        "expectedStatusCodes",
        "attributes",
        "High security mode",
        "Strip exception messages",
        "Transaction events",
        "maximumSamplesStored",
        "Custom events",
        "Custom parameters",
        "Labels (tags)",
        "Browser instrumentation",
        "autoInstrument",
        "requestPathsExcluded",
        "Slow queries",
        "Transaction traces",
        "transactionThreshold",
        "recordSql",
        "explainEnabled",
        "explainThreshold",
        "maxSegments",
        "maxExplainPlans",
        "Datastore tracer",
        "instanceReporting",
        "databaseNameReporting",
        "queryParameters",
        "Distributed tracing",
        "excludeNewrelicHeader",
        "Disable span events via config file",
        "Disable span events via environment variable",
        "Infinite Tracing",
        "trace_observer",
        "Span events",
        "Settings in app.config or web.config",
        "Enable and disable the agent",
        "Application name",
        "License key",
        "Change newrelic.config location",
        "Settings in appsettings.json"
      ],
      "title": ".NET agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Configuration"
      ],
      "external_id": "b89fa7fc399f2729bfee8f5106e777798a73177a",
      "image": "https://docs.newrelic.com/static/cffd7eb2d22c8e338531c38f35208c7c/c1b63/net-agent-config-settings-precedence_0.png",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/configuration/net-agent-configuration/",
      "published_at": "2021-06-03T17:23:12Z",
      "updated_at": "2021-05-15T16:33:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains the configuration options for the APM .NET agent. Configuration overview APM agent configuration options allow you to control some aspects of how the agent behaves. Some of these config options are part of the basic install process (like setting your license key and app name), but most are more advanced settings, such as: setting a log level, setting up proxy host access, excluding certain attributes, and enabling distributed tracing. The .NET agent gets its configuration from the newrelic.config file, which is generated as part of the install process. By default, only a global newrelic.config file is created, but you can also create app-local newrelic.config files for finer control over a multi-app system. Other ways to set config options include: using environment variables, or setting server-side configuration from the UI. For more on the various config options and what overrides what, see Config settings precedence. Support for both .NET Framework and .NET Core use the same configuration options and have the same APM features, unless otherwise stated. If you make changes to the config file and want to validate that it's in the right format, you can check it against the XSD file (for example, at C:\\ProgramData\\New Relic\\.NET Agent\\newrelic.xsd for Windows) with any XSD validator. Important For IIS: after you change your newrelic.config or app.config file, perform an IISRESET from an administrative command prompt. Log level adjustments do not require a reset. Configuration methods and precedence levels Upon installation, the .NET agent's configuration file (newrelic.config) applies to all monitored applications, but you can configure the agent in other ways. Here's a diagram showing how different configuration options take precedence over one another: This diagram explains the order of precedence for different ways you might configure the .NET agent. Here are details about the configuration methods shown in the diagram, and their precedence levels: .NET configuration Details and precedence web.config or app.config or appsettings.json Configuration settings set in these files take highest precedence. However, if the agent is disabled in the local or global newrelic.config, the NewRelic.AgentEnabled settings in these files will be ignored. Environment variables Second-highest precedence. For more about these, see .NET environment variables. Server-side configuration Third-highest precedence. A limited number of server-side configuration settings are available; the other settings will come from other configuration sources. App-local newrelic.config Fourth-highest precedence. You can create app-local newrelic.config files to configure individual apps on a multi-app system. These local configuration files override settings in the global newrelic.config file. The agent looks for app-local config files in the following directories, in this order: A directory specified in your web.config or app.config file with the NewRelic.ConfigFile property The web app's root directory (with the app.config or web.config) The directory containing your app's executable file Note that the app-local config file must be complete and validate against the XSD file (for example, at C:\\ProgramData\\New Relic\\.NET Agent\\newrelic.xsd for Windows). Default (global) newrelic.config Default source and the lowest precedence. Will configure all applications on a host in the absence of other config files. The global config file is located in the New Relic agent home directory: %PROGRAMDATA%\\New Relic\\.NET Agent Required environment variables New Relic's .NET agent relies on environment variables to tell the .NET Common Language Runtime (CLR) to attach New Relic to your processes. Some .NET agent install procedures (like the MSI installer) will automatically set these variables for you; some procedures will require you to manually set them. Caution Security recommendation: You should consider what users can set system environment variables. You should also secure the accounts under which your applications execute to prevent user environment variables overriding system environment variables .NET Framework environment variables For .NET Framework, the following variables are required: COR_ENABLE_PROFILING=1 COR_PROFILER={71DA0A04-7777-4EC6-9643-7D28B46A8A41} NEWRELIC_INSTALL_PATH=path\\to\\agent\\directory Copy The .NET agent installer will add these to IIS or as system-wide environment variables. .NET Core environment variables For .NET Core, the following variables are required: Linux: CORECLR_ENABLE_PROFILING=1 CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_NEWRELIC_HOME=path/to/agent/directory CORECLR_PROFILER_PATH=\"${CORECLR_NEWRELIC_HOME}/libNewRelicProfiler.so\" Copy Windows: CORECLR_ENABLE_PROFILING=1 CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} NEWRELIC_INSTALL_PATH=path\\to\\agent\\directory CORECLR_NEWRELIC_HOME=path\\to\\agent\\directory Copy The .NET agent installer will add these to IIS or as system-wide environment variables. If your system has previously used monitoring services (non-New Relic), you may have a \"profiler conflict\" when trying to install and use the New Relic agent. More details: Profiler conflict explanation New Relic’s .NET agents rely on environment variables to tell the .NET Common Language Runtime (CLR) to load New Relic into your processes. The install-related environment variables are Microsoft variables, not New Relic variables. They can be used by other .NET profilers, and only one profiler can be attached to a process at a time. For this reason, if you have used previous application monitoring products, you may have profiler conflicts. For specific install instructions, see the .NET agent install documentation. Optional environment variables Some configuration options in New Relic's .NET agent can be set via environment variables as an alternative to setting them in a config file. Below is a list of environment variables recognized by the .NET agent with example values. NEW_RELIC_LICENSE_KEY=XXXXXXXX NEW_RELIC_LOG=MyApp.log NEW_RELIC_APP_NAME=Descriptive Name MAX_TRANSACTION_SAMPLES_STORED=500 MAX_EVENT_SAMPLES_STORED=500 NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true NEW_RELIC_SPAN_EVENTS_ENABLED=false NEW_RELIC_LABELS=foo:bar;zip:zap NEW_RELIC_CONFIG_OBSCURING_KEY=XXXXXXXX NEW_RELIC_DISABLE_SAMPLERS=true NEWRELIC_PROFILER_LOG_DIRECTORY=path\\to\\agent\\directory (not configurable via config file) Copy Setup options, newrelic.config Use these options to setup and configure your agent via the newrelic.config file. The New Relic .NET agent supports the following categories of setup options: Configuration element Service element Obscuring key element Proxy element Log element Application element (configuration) Data transmission element Host name Configuration element The root element of the configuration document is a configuration element. <configuration xmlns=\"urn:newrelic-config\" agentEnabled=\"true\" maxStackTraceLines=\"50\" timingPrecision=\"low\"> Copy The configuration element supports the following attributes: agentEnabled Type Boolean Default true Enable or disable the New Relic agent. maxStackTraceLines Type Integer Default 80 The maximum number of stack frames to trace in any stack dump. timingPrecision Type String Default low Controls the precision of the timers. High precision will provide better data, but at a lower execution speed. Possible values are high and low. Service element The first child of the configuration element is a service element. The service element configures the agent's connection to the New Relic service. <service licenseKey=\"YOUR_LICENSE_KEY\" sendEnvironmentInfo=\"true\" syncStartup=\"false\" sendDataOnExit=\"false\" sendDataOnExitThreshold=\"60000\" autoStart=\"true\"/> Copy The service element supports the following attributes: licenseKey (required) Type String Default (none) Your New Relic license key. New Relic uses the license key to match your app's data to the correct account in the UI. Set the license key via environment variable. Alternatively, set the NEW_RELIC_LICENSE_KEY environment variable in the application's environment. NEW_RELIC_LICENSE_KEY=XXXXXXXX Copy sendEnvironmentInfo Type Boolean Default true Instructs the agent to record execution environment information. Environment information includes operating system, agent version, and which assemblies are available. syncStartup Type Boolean Default false Block application startup until the agent connects to New Relic. If set to true, the first transaction may take substantially longer to complete, because it is blocked until the connection to New Relic is finished. sendDataOnExit Type Boolean Default false Block application shutdown until the agent sends all data from the latest harvest cycle. sendDataOnExitThreshold Type Integer Default 60000 Unit Milliseconds The minimum amount of time the process must run before the agent blocks it from shutting down. This setting only applies when sendDataOnExit is true. completeTransactionsOnThread Type Boolean Default false If false, the agent uses a pool thread to complete the transaction processing. If true, the agent will complete transaction processing on the request thread. requestTimeout Type Integer Default 2000 (sendDataOnExit enabled) 120000 (sendDataOnExit disabled) Unit Milliseconds The agent's request timeout when communicating with New Relic. autoStart Type Boolean Default True Automatically start the .NET agent when the first instrumented method is hit. ssl (DEPRECATED) Type Boolean Default true The option to disable SSL is valid only for .NET agent versions 7.x and earlier. .NET agent version 8.x and higher communicate only via SSL. The agent communicates with New Relic via HTTPS by default, and New Relic requires HTTPS for all traffic to APM and the New Relic REST API. Obscuring key element The obscuringKey element is an optional child of the service element. The .NET Agent uses this value to deobfuscate supported configuration values. For example, when an obfuscated proxy password is supplied, it will be deobfuscated using this key. <service licenseKey=\"YOUR_LICENSE_KEY\"> <obscuringKey>OBSCURING_KEY</obscuringKey> </service> Copy The obscuring key may also be configured by setting the NEW_RELIC_CONFIG_OBSCURING_KEY environment variable. Caution Security recommendation: The placement of the obscuring Key in the same configuration file as an obfuscated value may pose a security risk. Consider placing the obscuring key in an environment variable and limiting access to environment variables within your environment. Proxy element The proxy element is an optional child of the service element. The proxy element is used when the agent communicates to the New Relic back-end service via a proxy. <service licenseKey=\"YOUR_LICENSE_KEY\"> <proxy host=\"hostname\" port=\"PROXY_PORT\" uriPath=\"path/to/something.aspx\" domain=\"mydomain.com\" user=\"PROXY_USERNAME\" password=\"PROXY_PASSWORD\" passwordObfuscated=\"OBFUSCATED_PROXY_PASSWORD\"/> </service> Copy The proxy element supports the following attributes: host Type String Default (none) Defines the proxy host. port Type Integer Default 8080 Defines the proxy port. uriPath Type String Default (none) Optionally define a proxy URI path. domain Type String Default (none) Optionally define a domain to use when authenticating with the proxy server. user Type String Default (none) Optionally define a user name for authentication. password Type String Default (none) Optionally define a password for authentication. passwordObfuscated Type String Default (none) For additional security, the .NET Agent supports the use of an obfuscated proxy password with the passwordObfuscated attribute. The obfuscated proxy password is generated using the following New Relic CLI command: newrelic agent config obfuscate --key OBSCURING_KEY --value \"CLEAR_TEXT_PROXY_PASSWORD\" Copy Important When using an obfuscated proxy password, the obscuring key must also be configured. Log element The log element is a child of the configuration element. The log element configures New Relic's logging . The agent generates its own log file to keep its logging information separate from your application's logs. <log level=\"info\" auditLog=\"false\" console=\"false\" directory=\"PATH\\TO\\LOG\\DIRECTORY\" fileName=\"FILENAME.log\" /> Copy The log element supports the following attributes: level Type String Default info Defines the level of detail recorded in the log file. Possible values, in increasing order of detail, are: off error warn info debug finest all Important Increasing the log level will increase New Relic's performance impact. auditLog Type Boolean Default false Records all data sent to and received from New Relic in both an auditlog log file and the standard log file. console Type Boolean Default false Send log messages to the console, in addition to the log file. directory Type String Default C:\\ProgramData\\New Relic\\.NET Agent\\Logs The directory to hold log files generated by the agent. If this is omitted, then a directory named logs in the New Relic agent install area will be used by default. fileName Type String Default (none) Defines a name for the log file. If you do not define a fileName, the name is derived from the name of the monitored process. Alternatively, set the NEW_RELIC_LOG environment variable in the application's environment. NEW_RELIC_LOG=MyApp.log Copy Application element (required) The application element is a child of the configuration element. This required element defines your application name, and disables or enables sampling. name Type String Default My Application The name of your .NET application is a child of the application element. New Relic will aggregate your data according to this name. For example, if you have two running applications named AppA and AppB, you will see two applications in the New Relic interface: AppA and AppB. You can also assign up to three names to your app. The first name is the primary name. For example: <application> <name>MY APPLICATION PRIMARY</name> <name>SECOND APP NAME</name> <name>THIRD APP NAME</name> </application> Copy Alternatively, set the NEW_RELIC_APP_NAME environment variable in the application's environment. NEW_RELIC_APP_NAME=Descriptive Name Copy disableSamplers Type Boolean Default false Samplers collect information about memory and CPU consumption. Set this to true to disable sampling. Alternatively, set the NEW_RELIC_DISABLE_SAMPLERS environment variable in the application's environment. NEW_RELIC_DISABLE_SAMPLERS=true Copy Data transmission element The dataTransmission element is a child of the configuration element. This element affects how data is sent to New Relic and can be used if you have specific data transmission requirements. <dataTransmission putForDataSend=\"false\" compressedContentEncoding=\"deflate\"/> Copy The dataTransmission element supports the following attributes: putForDataSend Type Boolean Default false Defines the HTTP method used when sending data to New Relic. Set this to true to enable using the PUT method when sending data. The POST method is used by default. Host name If the default host name label in the APM UI is not useful, you can decorate that name in the New Relic UI with a display name. After the application process is restarted and the .NET agent is reporting again, the display name will appear in the Servers drop-down list. This host name setting does not affect the list of hosts on your application's Summary page. To set a display name, choose one of the following options. The environment variable takes precedence over the config file value. Then restart your application to see your changes in the New Relic UI. Set using config file Set the displayName attribute in the processHost element in newrelic.config. The processHost element is a child of the configuration element. <configuration . . . > <processHost displayName=\"CUSTOM_NAME\" /> </configuration> Copy Set using environment variable Set the NEW_RELIC_PROCESS_HOST_DISPLAY_NAME environment variable: NEW_RELIC_PROCESS_HOST_DISPLAY_NAME = \"CUSTOM_NAME\" Copy Cloud platform utilization Configures the utilization configuration element to control how the agent collects utilization information and sends it to the New Relic service to determine pricing. The agent can collect information from Amazon Web Services (AWS) EC2 instances, Docker containers, Azure, Google Cloud Platform, Pivotal Cloud Foundry, and Kubernetes. detectAws Type Boolean Default true Determines whether the agent polls AWS metadata API. detectAzure Type Boolean Default true Determines whether the agent polls Azure metadata API. detectGcp Type Boolean Default true Determines whether the agent polls GCP metadata API. detectPcf Type Boolean Default true Determines whether the agent polls PCF information from environment variables. detectDocker Type Boolean Default true Determines whether the agent reads Docker information from the file system. detectKubernetes Type Boolean Default true Determines whether the agent polls Kubernetes information from environment variables. Instrumentation options Use these options to configure which elements of your application and environment to instrument. New Relic for .NET supports the following categories of instrumentation options: Instrumentation element Applications element (instrumentation) Attributes element Instrumentation element The instrumentation element is a child of the configuration element. By default, the .NET agent instruments IIS asp worker processes and Azure web and worker roles. To instrument other processes, see Instrumenting custom applications. Applications element (instrumentation) The applications element is a child of the instrumentation element. The applications element specifies which non-web apps to instrument. It contains a name attribute. Important This is not the same as the application (configuration) element, which is a child of the configuration element. <instrumentation> <applications> <application name=\"MyService1.exe\" /> <application name=\"MyService2.exe\" /> <application name=\"MyService3.exe\" /> </applications> </instrumentation> Copy Attributes element An attribute is a key/value pair that determines the properties of an event or transaction. Each attribute is sent to APM transaction traces, APM error traces, Transaction events, TransactionError events, or PageView events. The primary attributes element enables or disables attribute collection for the .NET agent, and defines specific attributes to collect or exclude. You can also configure attribute settings based on their destination: Error collection, transaction traces, Browser instrumentation, and transaction events. In this example, the agent excludes all attributes whose key begins with myApiKey (myApiKey.bar, myApiKey.value), but collects the custom attribute myApiKey.foo. <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> Copy You can view the .NET APM attributes on the .NET agent attributes page. You can also define custom attributes with the agent API call AddCustomParameter. enabled Type Boolean Default true Enable or disable attribute collection. When set to false in the primary attribute element, this setting overrides all attribute settings for individual destinations. include Type String Default (none) If attributes are enabled, the agent will collect all attribute keys specified in this list. To specify multiple attribute keys, specify each individually. You can also use a * wildcard character at the end of a key to match multiple attributes (for example, myApiKey.*). For more information, see Attribute rules. exclude Type String Default (none) If attributes are enabled, the agent will not collect attribute keys specified in this list. To specify multiple attribute keys, specify each individually. You can also use a * wildcard character at the end of a key to match multiple attributes (for example, myApiKey.*). For more information, see Attribute rules. Feature options Use these options to enable, disable, and configure New Relic features. New Relic for .NET allows you to configure the following features: App pools Cross application traces Error collection High security mode Strip exception messages Transaction events Custom events Custom parameters Tags/labels Browser instrumentation Slow Queries Transaction traces Datastore tracer Distributed tracing Span events App pools Important This is only applicable to a system's global config file. The applicationPools element is a child of the configuration element. The applicationPools element specifies for the profiler exactly which application pools to instrument and uses the same name as the IIS application pool name. This configuration element is useful when you may need to instrument only a small subset of your app pools. For example, a given server might have several hundred application pools, but only a few of those pools need to be instrumented by the .NET agent. Here is an example of disabling instrumentation for specific application pools: <applicationPools> <applicationPool name=\"Foo\" instrument=\"false\"/> <applicationPool name=\"Bar\" instrument=\"false\"/> </applicationPools> Copy Here is an example of disabling instrumentation for all application pools currently executing on the server and enabling instrumentation for specific application pools: <applicationPools> <defaultBehavior instrument=\"false\"/> <applicationPool name=\"Foo\" instrument=\"true\"/> <applicationPool name=\"Bar\" instrument=\"true\"/> </applicationPools> Copy The applicationPools element supports the following elements: defaultBehavior Type Boolean Default false Defines how the .NET agent will behave on a \"global\" level for application pools served via IIS. The .NET agent instruments all application pools by default. When true, application pools listed under applicationPool with an instrument attribute set to false will not be instrumented. Essentially, when set to false, the application pool list acts as an allow list. When set to true, the application pool list acts as a deny list. applicationPool Defines instrumentation behavior for a specific application pool. The name attribute is the name of an application pool. Enable or disable profiling in the instrument attribute. Define this application in the name attribute. Cross application traces The crossApplicationTracer element is a child of the configuration element. crossApplicationTracer links transaction traces across applications. When linked in a service-oriented architecture, all instrumented applications that communicate with each other via HTTP will now \"link\" transaction traces with the applications that they call and the applications they are called by. Cross application tracing makes it easier to understand the performance relationship between services and applications. <crossApplicationTracer enabled=\"true\"/> Copy The crossApplicationTracer element supports the following attribute: enabled Type Boolean Default true Enable or disable cross application tracing Error collection The errorCollector element is a child of the configuration element. errorCollector configures error collection, which captures information about uncaught exceptions and sends them to New Relic. <errorCollector enabled=\"true\" captureEvents=\"true\" maxEventSamplesStored=\"100\"> <ignoreClasses> <errorClass>System.IO.FileNotFoundException</errorClass> <errorClass>System.Threading.ThreadAbortException</errorClass> </ignoreClasses> <ignoreMessages> <errorClass name=\"System.Exception\"> <message>Ignore message</message> <message>Ignore too</message> </errorClass> </ignoreMessages> <ignoreStatusCodes> <code>401</code> <code>404</code> </ignoreStatusCodes> <expectedClasses> <errorClass>System.ArgumentNullException</errorClass> <errorClass>System.ArgumentOutOfRangeException</errorClass> </expectedClasses> <expectedMessages> <errorClass name=\"System.Exception\"> <message>Expected message</message> <message>Expected too</message> </errorClass> </expectedMessages> <expectedStatusCodes>403,500-505</expectedStatusCodes> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </errorCollector> Copy Tip For an overview of error configuration in APM, see Manage errors in APM. The errorCollector element supports the following elements and attributes: enabled Type Boolean Default true Enable or disable the error collector. captureEvents Type Boolean Default true Enable or disable the capturing of error events. maxEventSamplesStored Type Integer Default 100 Reservoir limit for error events. ignoreClasses A list of fully qualified class names to be ignored. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used ignoreMessages An optional map of fully qualified class names to list of strings matching a substring of the message of an error. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used ignoreErrors (DEPRECATED) Type String Default (none) Lists specific exceptions to not report to New Relic. The full name of the exception should be used, such as System.IO.FileNotFoundException. ignoreStatusCodes Type String Default (none) Lists specific HTTP error codes to not report to New Relic. You can use standard integral HTTP error codes, such as just 401, or you may use Microsoft full status codes with decimal points, such as 401.4 or 403.18. The status codes should be equal to or greater than 400. expectedClasses A list of fully qualified class names to be marked as expected. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used expectedMessages An optional map of fully qualified class names to list of strings matching a substring of the message of an error. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used expectedStatusCodes A comma separated list of status codes. The list may include integer ranges, using a single dash (-) and will be inclusive of both the starting and ending integer in the range. attributes Use this sub-element to customize your agent attribute settings for error traces. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. High security mode The highSecurity element is a child of the configuration element. To enable high security mode, set this property to true and enable high security property in the New Relic user interface. Enabling high security means SSL is turned on, request parameters and custom parameters are not collected, strip exception messages is enabled, and queries cannot be sent to New Relic in their raw form. enabled Type Boolean Default false Enable or disable high security mode. Example: <highSecurity enabled=\"true\"/> Copy Strip exception messages The stripExceptionMessages element is a child of the configuration element. To enable strip exception messages, set this property to true. By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. enabled Type Boolean Default false Enable or disable strip exception messages. Example: <stripExceptionMessages enabled=\"true\"/> Copy Transaction events The transactionEvents element is a child of the configuration element. Use transactionEvents to configure transaction events. <transactionEvents enabled=\"true\" maximumSamplesStored=\"10000\"> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </transactionEvents> Copy The transactionEvents element supports the following attributes: enabled Type Boolean Default true Enable or disable the event recorder. maximumSamplesStored Type Integer Default 10000 The maximum number of samples to store in memory at once. Alternatively, set the MAX_TRANSACTION_SAMPLES_STORED environment variable in the application's environment. MAX_TRANSACTION_SAMPLES_STORED=500 Copy attributes Use this sub-element to customize your agent attribute settings for transaction events. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. Tip These attribute settings are specific to transaction events. Attribute settings can be applied globally to all event types to with this configuration setting. Caution When distributed tracing and/or Infinite Tracing are enabled, information from transaction events is applied to the root Span Event of the transaction. Consider applying any attribute settings for transaction events to span events and/or apply them as Global Attribute settings. Custom events The customEvents element is a child of the configuration element. Use customEvents to configure custom events. <customEvents enabled=\"true\" maximumSamplesStored=\"10000\"/> Copy The CustomEvents element supports the following attributes: enabled Type Boolean Default true Enable or disable the event recorder. maximumSamplesStored Type Integer Default 10000 The maximum number of samples to store in memory at once. Alternatively, set the MAX_EVENT_SAMPLES_STORED environment variable in the application's environment. MAX_EVENT_SAMPLES_STORED=500 Copy Custom parameters The customParameters element is a child of the configuration element. Use customParameters to configure custom parameters. <customParameters enabled=\"true\" /> Copy The CustomParameters element supports the following attributes: enabled Type Boolean Default true Enable or disable the capture of custom parameters. Labels (tags) The labels element is a child of the configuration element. This sets tag names and values. The list is a semicolon delimited list of colon-separated name and value pairs. You can also use with the NEW_RELIC_LABELS environment variable. Example: <labels>foo:bar;zip:zap</labels> Copy Browser instrumentation The browserMonitoring element is a child of the configuration element. browserMonitoring configures Browser monitoring in your .NET application. Browser gives you insight your end users' performance experience. This is accomplished by measuring the time it takes for your users' browsers to download and render your webpages by injecting a small amount of JavaScript code into the header and footer of each page. // If you use both the Exclude and Attribute elements // the Exclude element must be listed first. <browserMonitoring autoInstrument=\"true\"> <requestPathsExcluded> <path regex=\"url-regex-1\"/> <path regex=\"url-regex-2\"/> ... <path regex=\"url-regex-n\"/> </requestPathsExcluded> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </browserMonitoring> Copy The browserMonitoring element supports the following attributes: autoInstrument Type Boolean Default true By default the agent automatically injects the Browser agent JavaScript. To turn off automatic injection, set this attribute to false. attributes Use this sub-element to customize your agent attribute settings for Browser. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. requestPathsExcluded Use this sub-element to prevent the Browser agent from being injected in specific pages. The element is used as follows: <requestPathsExcluded> <path regex=\"url-regex-1\"/> <path regex=\"url-regex-2\"/> ... <path regex=\"url-regex-n\"/> </requestPathsExcluded> Copy The agent will not inject the Browser agent into pages whose URL matches one of the specified regular expressions. The regular expression should follow Microsoft guidelines for the Regex class. It is a reference to the virtual directory of the path in your application and not the full URL of the path you wish to exclude. For example, to exclude the pages in https://www.mywebsite.com/mywebpages/ you would simply insert /mywebpages/ as the path regex value. The requestPathsExcluded element should be used in cases where it is impossible or undesirable to use the DisableBrowserMonitoring() call. To minimize a possible performance impact try to use as few regular expressions as possible and keep them as simple as possible. Slow queries The slowSql element is a child of the configuration element. slowSql configures capturing information about slow query executions, and captures and obfuscates explain plans for these queries. <slowSql enabled=\"true\"/> Copy The slowSql element supports the following attribute: enabled Type Boolean Default true Enable or disable slow query tracing. Transaction traces The transactionTracer element is a child of the configuration element. transactionTracer configures transaction traces. Included in the trace is the exact call sequence of the transactions, including any query statements issued. <transactionTracer enabled=\"true\" transactionThreshold=\"apdex_f\" recordSql=\"obfuscated\" explainEnabled=\"true\" explainThreshold=\"500\" maxSegments=\"3000\" maxExplainPlans=\"20\"> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </transactionTracer> Copy The transactionTracer element supports the following attributes: enabled Type Boolean Default true Enable or disable transaction traces. transactionThreshold Type String Default apdex_f Defines the threshold for transaction traces. If a transaction takes longer than the threshold, it is eligible for being traced. See transaction trace basics for more about the rules governing traces. The default value is apdex_f, which sets the threshold to four times the application's apdex_t value. For more information about apdex_t, see Apdex. You can also set the threshold to be a specific time value in milliseconds. recordSql Type String Default obfuscated Select a query tracing policy. Options are off, which records nothing; obfuscated, which records an obfuscated version of the query; or raw, which records the query exactly as it is issued to the database. Caution Recording raw queries may capture sensitive information. explainEnabled Type Boolean Default false When true, the agent captures EXPLAIN statements for slow queries. explainThreshold Type Integer Default 500 Unit Milliseconds The agent collects slow query data for queries that exceed this threshold, along with any available explain plans, as part of transaction traces. maxSegments Type Integer Default 3000 The maximum number of segments to collect in a transaction trace. maxExplainPlans Type Integer Default 20 The maximum number of explain plans to collect during a harvest cycle. attributes Use this sub-element to customize your agent attribute settings for transaction traces. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. Datastore tracer The datastoreTracer element is a child of the configuration element. <datastoreTracer> <instanceReporting enabled=\"true\" /> <databaseNameReporting enabled=\"true\" /> <queryParameters enabled=\"false\" /> </datastoreTracer> Copy The datastoreTracer element supports the following sub-elements: instanceReporting Use this sub-element to enable collection of datastore instance metrics (such as the host and port) for some database drivers. These are reported on slow query traces and transaction traces. The default value of attribute enabled is true. databaseNameReporting Use this sub-element to enable collection of the database name on slow query traces and transaction traces for some database drivers. The default value of attribute enabled is true. queryParameters Use this sub-element to enable collection of the SQL query parameters on slow query traces. The default value of attribute enabled is false. Caution Recording query parameters may capture sensitive information. The transactionTracer.recordSql configuration option must be set to raw or this option is ignored. Distributed tracing The distributedTracing element is a child of the configuration element. <distributedTracing enabled=\"false\" excludeNewrelicHeader=\"false\"/> Copy Distributed tracing lets you see the path that a request takes as it travels through a distributed system. Enabling distributed tracing disables cross application tracing, and has other effects on APM features. Before enabling, read the planning guide. Important Requires .NET agent version 8.6.45.0 or higher. The distributedTracing element supports the following attributes: To enable or disable, see Enable distributed tracing. enabled Type Boolean Default false Alternatively, enable distributed tracing via the NEW_RELIC_DISTRIBUTED_TRACING_ENABLED environment variable in the application's environment. NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true Copy excludeNewrelicHeader Type Boolean Default false By default, supported versions of the agent utilize both the newrelic header and W3C Trace Context headers for distributed tracing. The newrelic distributed tracing header allows interoperability with older agents that don't support W3C Trace Context headers. Agent versions that support W3C Trace Context headers will prioritize them over newrelic headers for distributed tracing. If you do not want to utilize the newrelic header, setting this to true will result in the agent excluding the newrelic header and only using W3C Trace Context headers for distributed tracing. Distributed tracing reports span events. Span event reporting is enabled by default, but distributed tracing must be enabled for spans to be reported. To disable span events, choose one of the following options: Disable span events via config file Set the <spanEvents> element to false to disable via the newrelic.config file. This element is a child of the <configuration> element. <configuration . . . > <spanEvents enabled=\"false\" /> </configuration> Copy Disable span events via environment variable Set the NEW_RELIC_SPAN_EVENTS_ENABLED environment variable in the application's environment. NEW_RELIC_SPAN_EVENTS_ENABLED=false Copy Infinite Tracing Infinite Tracing extends the distributed tracing service by employing a trace observer that is external to the agent. It observes 100% of your application traces across various services and provides actionable data so you can solve issues faster. Important Infinite Tracing requires .NET Agent version 8.30 or higher. To turn on Infinite Tracing, enable distributed tracing and add the additional settings below <configuration . . . > <distributedTracing enabled=\"true\" /> <infiniteTracing> <trace_observer host=\"YOUR_TRACE_OBSERVER_HOST\" /> </infiniteTracing> </configuration> Copy The infiniteTracing element supports the following elements: trace_observer The trace_observer element identifies an observer host that is independent from the agent. For help getting a valid Infinite Tracing trace observer host entry, see Find or create a trace observer endpoint. The trace observer may be configured using the NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST environment variable as well. Important When configuring the trace observer, you should not supply the protocol as part of the host. For example, use myhost.infinitetracing.com instead of https://myhost.infinitetracing.com. Span events The spanEvents element is a child of the configuration element. Use spanEvents to configure span events. <spanEvents enabled=\"true\"> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </spanEvents> Copy The spanEvents element supports the following attributes: enabled Type Boolean Default true Enable or disable the event recorder. attributes Use this sub-element to customize your agent attribute settings for span events. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. Tip These attribute settings are specific to span events. Attribute settings may be applied globally to all event types to with this configuration setting. Settings in app.config or web.config For ASP.NET and .NET Framework console apps you can also configure the following settings in your app's app.config or web.config, within the outermost element, <configuration>: Enable and disable the agent <appSettings> <add key = \"NewRelic.AgentEnabled\" value=\"false\" /> </appSettings> Copy Important If the agent is disabled in the local or global newrelic.config, the NewRelic.AgentEnabled settings in these files will be ignored. Application name For more information, see Name your .NET application. <appSettings> <add key = \"NewRelic.AppName\" value =\"Descriptive Name\" /> </appSettings> Copy License key <appSettings> <add key = \"NewRelic.LicenseKey\" value =\"XXXXXXXX\" /> </appSettings> Copy Change newrelic.config location Designates an alternative location for the config file outside of the local root of the app or global config location. The location entered must be an absolute path. <appSettings> <add key = \"NewRelic.ConfigFile\" value=\"C:\\Path-to-alternate-config-dir\\newrelic.config\" /> </appSettings> Copy Settings in appsettings.json For .NET Core apps, you can configure the following settings in appsettings.json if the following is true: The appsettings.json file must be located in the current working directory of the application. The application must have the following dependencies: Microsoft.Extensions.Configuration Microsoft.Extensions.Configuration.Json Microsoft.Extensions.Configuration.EnvironmentVariables Enable and disable the agent { \"NewRelic.AgentEnabled\":\"false\" } Copy Important If the agent is disabled in the local or global newrelic.config, the NewRelic.AgentEnabled setting in this file will be ignored. Application name For more information, see Name your .NET application. { \"NewRelic.AppName\": \"Descriptive Name\" } Copy License key { \"NewRelic.LicenseKey\": \"XXXXXXXX\" } Copy Change newrelic.config location Designates an alternative location for the config file outside of the local root of the app or global config location. The location entered must be an absolute path. { \"NewRelic.ConfigFile\": \"C:\\\\Path-to-alternate-config-dir\\\\newrelic.config\" } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 71.82114,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> configuration",
        "sections": ".<em>NET</em> <em>agent</em> configuration",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " Relic), you may have a &quot;profiler conflict&quot; when trying to install and use the New Relic <em>agent</em>. More details: Profiler conflict explanation New Relic’s .<em>NET</em> <em>agents</em> rely on environment variables to tell the .<em>NET</em> Common Language Runtime (CLR) to load New Relic into your processes. The install-related"
      },
      "id": "60446c3b196a679d6a960f7a"
    }
  ],
  "/docs/agents/net-agent/attributes/custom-attributes-net": [
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.99244,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> <em>attributes</em>",
        "sections": "<em>Agent</em> <em>attributes</em>",
        "tags": "<em>Agents</em>",
        "body": " called browser monitoring. Span events Span events collected for distributed tracing will contain <em>attributes</em> collected during the span. The following <em>agents</em> support the addition of custom user <em>attributes</em> to span events: Java <em>agent</em> 5.13.0 and above Go <em>agent</em> 3.6.0 and above .<em>NET</em> <em>agent</em> 8.25 and above Node"
      },
      "id": "603eb9db28ccbc127aeba79e"
    },
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.98917,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Ruby <em>agent</em> <em>attributes</em>",
        "sections": "Ruby <em>agent</em> <em>attributes</em>",
        "tags": "<em>Agents</em>",
        "body": " <em>attributes</em> (types, destinations, and limits for <em>attributes</em> used by New Relic <em>agents</em>) Enabling and disabling <em>attributes</em> (properties, rules, and backwards compatibility information for Ruby <em>agent</em> <em>attributes</em>) Attribute examples (scenarios and results of enabling and disabling different Ruby <em>agent</em> <em>attributes</em>)"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "sections": [
        "Enable or disable attributes",
        "Properties",
        "newrelic.attributes.enabled",
        "newrelic.browser_monitoring.attributes.enabled",
        "newrelic.error_collector.attributes.enabled",
        "newrelic.transaction_events.attributes.enabled",
        "newrelic.transaction_tracer.attributes.enabled",
        "newrelic.span_events.attributes.enabled",
        "newrelic.attributes.include",
        "newrelic.attributes.exclude",
        "newrelic.browser_monitoring.attributes.include",
        "newrelic.browser_monitoring.attributes.exclude",
        "newrelic.error_collector.attributes.include",
        "newrelic.error_collector.attributes.exclude",
        "newrelic.transaction_events.attributes.include",
        "newrelic.transaction_events.attributes.exclude",
        "newrelic.transaction_tracer.attributes.include",
        "newrelic.transaction_tracer.attributes.exclude",
        "newrelic.span_events.attributes.include",
        "newrelic.span_events.attributes.exclude",
        "Attribute rules",
        "Root level takes precedence for enabled.",
        "Destination enabled takes precedence over include and exclude.",
        "Attribute is included if the destination is enabled.",
        "Exclude always supersedes include.",
        "Keys are case sensitive.",
        "Use a star (\\*) for wildcards.",
        "Most specific setting for a key takes priority.",
        "Include or exclude affects the specific destination.",
        "Deprecated properties",
        "For more help"
      ],
      "title": "Enable or disable attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "Attributes"
      ],
      "external_id": "6e9bf6c2e32a6add76412e6381a7bd4c99a0bc1c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/attributes/enable-or-disable-attributes/",
      "published_at": "2021-06-02T20:32:04Z",
      "updated_at": "2021-06-02T20:32:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Learn about properties to enable or disable attributes, and the rules that New Relic uses when determining which attributes to include or exclude for a destination. This also includes a summary of the PHP agent properties that have been deprecated with the release of New Relic agent attributes. Properties Use the following destination properties to open or close the destination to any attribute collection: newrelic.attributes.enabled Type Boolean Default True Turns on or turns off all attributes in all destinations. newrelic.browser_monitoring.attributes.enabled Type: Boolean Default: False Turns on or turns off all attributes for browser monitoring. This is the data that gets attached to page view events. If newrelic.attributes.enabled is false, no attributes will be sent to browser monitoring regardless of how this property is set. newrelic.error_collector.attributes.enabled Type: Boolean Default: True Turns on or turns off all attributes for traced errors. If newrelic.attributes.enabled is false, no attributes will be sent to traced errors regardless of how this property is set. newrelic.transaction_events.attributes.enabled Type: Boolean Default: True Turns on or turns off all attributes for transaction events. If newrelic.attributes.enabled is false, no attributes will be sent to transaction events regardless of how this property is set. newrelic.transaction_tracer.attributes.enabled Type Boolean Default True Turns on or off all attributes for transaction traces. If newrelic.attributes.enabled is false, no attributes will be sent to transaction traces regardless of how this property is set. newrelic.span_events.attributes.enabled Type Boolean Default True Turns on or off all attributes for Span data. If newrelic.attributes.enabled is false, no attributes will be sent to spans regardless of how this property is set. Use the following attribute/destination specific .include or .exclude properties to add or remove specific attributes in specific destinations: newrelic.attributes.include Type: Comma-delimited list of strings Default: Empty If attributes are enabled, all attribute keys in this list will be sent to New Relic. newrelic.attributes.exclude Type: Comma-delimited list of strings Default: Empty All attribute keys in this list will not be sent to New Relic. newrelic.browser_monitoring.attributes.include Type: Comma-delimited list of strings Default: Empty If attributes are enabled for browser_monitoring, all attribute keys in this list will be sent to New Relic Browser in page views. newrelic.browser_monitoring.attributes.exclude Type: Comma-delimited list of strings Default: Empty All attribute keys found in this list will not be sent to New Relic in page views. newrelic.error_collector.attributes.include Type: Comma-delimited list of strings Default: Empty If attributes are enabled for traced errors, all attribute keys in this list will be sent to New Relic in traced errors. newrelic.error_collector.attributes.exclude Type: Comma-delimited list of strings Default: Empty All attribute keys in this list will not be sent to New Relic in traced errors. newrelic.transaction_events.attributes.include Type: Comma-delimited list of strings Default: Empty If attributes are enabled for transaction events, all attribute keys in this list will be sent to New Relic in transaction events. newrelic.transaction_events.attributes.exclude Type: Comma-delimited list of strings Default: Empty All attribute keys in this list will not be sent to New Relic in transaction events. newrelic.transaction_tracer.attributes.include Type: Comma-delimited list of strings Default: Empty If attributes are enabled for transaction traces, all attribute keys in this list will be sent to New Relic in transaction traces. newrelic.transaction_tracer.attributes.exclude Type: Comma-delimited list of strings Default: Empty All attribute keys in this list will not be sent to New Relic in transaction traces. newrelic.span_events.attributes.include Type: Comma-delimited list of strings Default: Empty If attributes are enabled for span events, all attribute keys in this list will be sent to New Relic in span events. newrelic.span_events.attributes.exclude Type: Comma-delimited list of strings Default: Empty All attribute keys in this list will not be sent to New Relic in span events. Attribute rules New Relic follows these rules when determining which attributes to include or exclude for a destination. Root level takes precedence for enabled. The newrelic.attributes.enabled field trumps all other settings. When false, no attributes will be reported to New Relic. Example configuration: newrelic.attributes.enabled = false newrelic.attributes.include = foo,bar newrelic.transaction_tracer.attributes.enabled = true Copy Example output: Keys passed in: password, foo, bar, bat Keys included for all destinations: Keys excluded for all destinations: password, foo, bar, bat Copy Destination enabled takes precedence over include and exclude. newrelic.{destination}.attributes.enabled flags take precedence over include and exclude keys. Example configuration: newrelic.transaction_tracer.attributes.enabled = false newrelic.attributes.include = one,two newrelic.transaction_tracer.attributes.include = three,four Copy Example output: Keys passed in: one, two, three, four Keys included for transaction traces: Keys excluded for transaction traces: one, two, three, four Copy Attribute is included if the destination is enabled. If a destination is enabled, all user attributes are sent to that destination by default. All user attributes default to true. However, by default, request attributes and message parameters are disabled for all destinations. Example configuration: newrelic.attributes.enabled = true newrelic.attributes.exclude = myAttKey Copy Example output: Keys passed in: foo, bar, myAttKey Keys included: foo, bar Keys excluded: myAttKey Copy Exclude always supersedes include. If the same key is listed in the include and exclude lists, then attributes with the specified key will be excluded. Example configuration: newrelic.attributes.enabled = true newrelic.attributes.include = foo,myCustomAtt newrelic.attributes.exclude = password,myCustomAtt Copy Example output: Keys passed in: foo, myCustomAtt, password Keys included: foo Keys excluded: password, myCustomAtt Copy Keys are case sensitive. Keys are case sensitive. Example configuration: newrelic.attributes.enabled = true newrelic.attributes.exclude = password,PaSsWoRd Copy Example output: Keys passed in: password, Password, PASSWORD, PaSsWoRd, PassWORD Keys included: Password, PASSWORD, PassWORD Keys excluded: password, PaSsWoRd Copy Use a star (\\*) for wildcards. You can use an asterisk or star (*) at the end of a key as a wildcard. This will match a set of attributes with the same prefix. Example configuration: newrelic.attributes.enabled = true newrelic.attributes.include = custom* newrelic.attributes.exclude = request.parameters.* Copy Example output: Keys passed in: custom, custom.key1, custom.key2, request.parameters., request.parameters.foo, request.parameters.bar Keys included: custom, custom.key1, custom.key2 Keys excluded: request.parameters., request.parameters.foo, request.parameters.bar Copy Most specific setting for a key takes priority. If multiple include or exclude attributes affect the same key, the most specific setting will have priority. Example configuration: newrelic.attributes.enabled = true newrelic.attributes.include = request.parameters.foo newrelic.attributes.exclude = request.parameters.* Copy Example output: Keys passed in: request.parameters., request.parameters.foo, request.parameters.bar Keys included: request.parameters.foo Keys excluded: request.parameters., request.parameters.bar Copy Include or exclude affects the specific destination. If the attribute include or exclude is specified on a destination, then it only impacts that destination. Example configuration: newrelic.attributes.include = foo newrelic.transaction_events.attributes.exclude = foo Copy Example output: Keys passed in: foo Keys included for transaction events: Keys included for other destinations: foo Keys excluded for transaction events: foo Copy Deprecated properties The following properties have been deprecated. Switch to the new attributes configuration for these properties when upgrading your PHP agent. Deprecated property New property newrelic.capture_params newrelic.attributes.include = request.parameters.* By default, request parameters are not sent to New Relic. Add request.parameters.* to the newrelic.attributes.include list to turn on all request parameters. The newrelic.capture_params property has been deprecated. newrelic.ignored_params newrelic.attributes.exclude = request.parameters.{name} Add each request parameter key to the newrelic.attributes.exclude list, delimited by commas. Be sure to prepend the key with request.parameters. The newrelic.ignored_params property has been deprecated. newrelic.{destination}.capture_attributes newrelic.{destination}.attributes.enabled The old newrelic.{destination}.capture_attributes flag would turn off user attribute collection. This has been deprecated. Use newrelic.{destination}.attributes.enabled instead. For more help If you need more help, check out these support and learning resources: Suggest a change and learn how to contribute to our PHP agent open source repository. Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.64661,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Enable or disable <em>attributes</em>",
        "sections": "Enable or disable <em>attributes</em>",
        "tags": "<em>Agents</em>",
        "body": "Learn about properties to enable or disable <em>attributes</em>, and the rules that New Relic uses when determining which <em>attributes</em> to include or exclude for a destination. This also includes a summary of the PHP <em>agent</em> properties that have been deprecated with the release of New Relic <em>agent</em> <em>attributes</em>"
      },
      "id": "603e9d6de7b9d22a5f2f3445"
    }
  ],
  "/docs/agents/net-agent/attributes/enable-disable-attributes-net": [
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.99244,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> <em>attributes</em>",
        "sections": "<em>Agent</em> <em>attributes</em>",
        "tags": "<em>Agents</em>",
        "body": " called browser monitoring. Span events Span events collected for distributed tracing will contain <em>attributes</em> collected during the span. The following <em>agents</em> support the addition of custom user <em>attributes</em> to span events: Java <em>agent</em> 5.13.0 and above Go <em>agent</em> 3.6.0 and above .<em>NET</em> <em>agent</em> 8.25 and above Node"
      },
      "id": "603eb9db28ccbc127aeba79e"
    },
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.98917,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Ruby <em>agent</em> <em>attributes</em>",
        "sections": "Ruby <em>agent</em> <em>attributes</em>",
        "tags": "<em>Agents</em>",
        "body": " <em>attributes</em> (types, destinations, and limits for <em>attributes</em> used by New Relic <em>agents</em>) Enabling and disabling <em>attributes</em> (properties, rules, and backwards compatibility information for Ruby <em>agent</em> <em>attributes</em>) Attribute examples (scenarios and results of enabling and disabling different Ruby <em>agent</em> <em>attributes</em>)"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "sections": [
        "Enable or disable attributes",
        "Properties",
        "newrelic.attributes.enabled",
        "newrelic.browser_monitoring.attributes.enabled",
        "newrelic.error_collector.attributes.enabled",
        "newrelic.transaction_events.attributes.enabled",
        "newrelic.transaction_tracer.attributes.enabled",
        "newrelic.span_events.attributes.enabled",
        "newrelic.attributes.include",
        "newrelic.attributes.exclude",
        "newrelic.browser_monitoring.attributes.include",
        "newrelic.browser_monitoring.attributes.exclude",
        "newrelic.error_collector.attributes.include",
        "newrelic.error_collector.attributes.exclude",
        "newrelic.transaction_events.attributes.include",
        "newrelic.transaction_events.attributes.exclude",
        "newrelic.transaction_tracer.attributes.include",
        "newrelic.transaction_tracer.attributes.exclude",
        "newrelic.span_events.attributes.include",
        "newrelic.span_events.attributes.exclude",
        "Attribute rules",
        "Root level takes precedence for enabled.",
        "Destination enabled takes precedence over include and exclude.",
        "Attribute is included if the destination is enabled.",
        "Exclude always supersedes include.",
        "Keys are case sensitive.",
        "Use a star (\\*) for wildcards.",
        "Most specific setting for a key takes priority.",
        "Include or exclude affects the specific destination.",
        "Deprecated properties",
        "For more help"
      ],
      "title": "Enable or disable attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "Attributes"
      ],
      "external_id": "6e9bf6c2e32a6add76412e6381a7bd4c99a0bc1c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/attributes/enable-or-disable-attributes/",
      "published_at": "2021-06-02T20:32:04Z",
      "updated_at": "2021-06-02T20:32:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Learn about properties to enable or disable attributes, and the rules that New Relic uses when determining which attributes to include or exclude for a destination. This also includes a summary of the PHP agent properties that have been deprecated with the release of New Relic agent attributes. Properties Use the following destination properties to open or close the destination to any attribute collection: newrelic.attributes.enabled Type Boolean Default True Turns on or turns off all attributes in all destinations. newrelic.browser_monitoring.attributes.enabled Type: Boolean Default: False Turns on or turns off all attributes for browser monitoring. This is the data that gets attached to page view events. If newrelic.attributes.enabled is false, no attributes will be sent to browser monitoring regardless of how this property is set. newrelic.error_collector.attributes.enabled Type: Boolean Default: True Turns on or turns off all attributes for traced errors. If newrelic.attributes.enabled is false, no attributes will be sent to traced errors regardless of how this property is set. newrelic.transaction_events.attributes.enabled Type: Boolean Default: True Turns on or turns off all attributes for transaction events. If newrelic.attributes.enabled is false, no attributes will be sent to transaction events regardless of how this property is set. newrelic.transaction_tracer.attributes.enabled Type Boolean Default True Turns on or off all attributes for transaction traces. If newrelic.attributes.enabled is false, no attributes will be sent to transaction traces regardless of how this property is set. newrelic.span_events.attributes.enabled Type Boolean Default True Turns on or off all attributes for Span data. If newrelic.attributes.enabled is false, no attributes will be sent to spans regardless of how this property is set. Use the following attribute/destination specific .include or .exclude properties to add or remove specific attributes in specific destinations: newrelic.attributes.include Type: Comma-delimited list of strings Default: Empty If attributes are enabled, all attribute keys in this list will be sent to New Relic. newrelic.attributes.exclude Type: Comma-delimited list of strings Default: Empty All attribute keys in this list will not be sent to New Relic. newrelic.browser_monitoring.attributes.include Type: Comma-delimited list of strings Default: Empty If attributes are enabled for browser_monitoring, all attribute keys in this list will be sent to New Relic Browser in page views. newrelic.browser_monitoring.attributes.exclude Type: Comma-delimited list of strings Default: Empty All attribute keys found in this list will not be sent to New Relic in page views. newrelic.error_collector.attributes.include Type: Comma-delimited list of strings Default: Empty If attributes are enabled for traced errors, all attribute keys in this list will be sent to New Relic in traced errors. newrelic.error_collector.attributes.exclude Type: Comma-delimited list of strings Default: Empty All attribute keys in this list will not be sent to New Relic in traced errors. newrelic.transaction_events.attributes.include Type: Comma-delimited list of strings Default: Empty If attributes are enabled for transaction events, all attribute keys in this list will be sent to New Relic in transaction events. newrelic.transaction_events.attributes.exclude Type: Comma-delimited list of strings Default: Empty All attribute keys in this list will not be sent to New Relic in transaction events. newrelic.transaction_tracer.attributes.include Type: Comma-delimited list of strings Default: Empty If attributes are enabled for transaction traces, all attribute keys in this list will be sent to New Relic in transaction traces. newrelic.transaction_tracer.attributes.exclude Type: Comma-delimited list of strings Default: Empty All attribute keys in this list will not be sent to New Relic in transaction traces. newrelic.span_events.attributes.include Type: Comma-delimited list of strings Default: Empty If attributes are enabled for span events, all attribute keys in this list will be sent to New Relic in span events. newrelic.span_events.attributes.exclude Type: Comma-delimited list of strings Default: Empty All attribute keys in this list will not be sent to New Relic in span events. Attribute rules New Relic follows these rules when determining which attributes to include or exclude for a destination. Root level takes precedence for enabled. The newrelic.attributes.enabled field trumps all other settings. When false, no attributes will be reported to New Relic. Example configuration: newrelic.attributes.enabled = false newrelic.attributes.include = foo,bar newrelic.transaction_tracer.attributes.enabled = true Copy Example output: Keys passed in: password, foo, bar, bat Keys included for all destinations: Keys excluded for all destinations: password, foo, bar, bat Copy Destination enabled takes precedence over include and exclude. newrelic.{destination}.attributes.enabled flags take precedence over include and exclude keys. Example configuration: newrelic.transaction_tracer.attributes.enabled = false newrelic.attributes.include = one,two newrelic.transaction_tracer.attributes.include = three,four Copy Example output: Keys passed in: one, two, three, four Keys included for transaction traces: Keys excluded for transaction traces: one, two, three, four Copy Attribute is included if the destination is enabled. If a destination is enabled, all user attributes are sent to that destination by default. All user attributes default to true. However, by default, request attributes and message parameters are disabled for all destinations. Example configuration: newrelic.attributes.enabled = true newrelic.attributes.exclude = myAttKey Copy Example output: Keys passed in: foo, bar, myAttKey Keys included: foo, bar Keys excluded: myAttKey Copy Exclude always supersedes include. If the same key is listed in the include and exclude lists, then attributes with the specified key will be excluded. Example configuration: newrelic.attributes.enabled = true newrelic.attributes.include = foo,myCustomAtt newrelic.attributes.exclude = password,myCustomAtt Copy Example output: Keys passed in: foo, myCustomAtt, password Keys included: foo Keys excluded: password, myCustomAtt Copy Keys are case sensitive. Keys are case sensitive. Example configuration: newrelic.attributes.enabled = true newrelic.attributes.exclude = password,PaSsWoRd Copy Example output: Keys passed in: password, Password, PASSWORD, PaSsWoRd, PassWORD Keys included: Password, PASSWORD, PassWORD Keys excluded: password, PaSsWoRd Copy Use a star (\\*) for wildcards. You can use an asterisk or star (*) at the end of a key as a wildcard. This will match a set of attributes with the same prefix. Example configuration: newrelic.attributes.enabled = true newrelic.attributes.include = custom* newrelic.attributes.exclude = request.parameters.* Copy Example output: Keys passed in: custom, custom.key1, custom.key2, request.parameters., request.parameters.foo, request.parameters.bar Keys included: custom, custom.key1, custom.key2 Keys excluded: request.parameters., request.parameters.foo, request.parameters.bar Copy Most specific setting for a key takes priority. If multiple include or exclude attributes affect the same key, the most specific setting will have priority. Example configuration: newrelic.attributes.enabled = true newrelic.attributes.include = request.parameters.foo newrelic.attributes.exclude = request.parameters.* Copy Example output: Keys passed in: request.parameters., request.parameters.foo, request.parameters.bar Keys included: request.parameters.foo Keys excluded: request.parameters., request.parameters.bar Copy Include or exclude affects the specific destination. If the attribute include or exclude is specified on a destination, then it only impacts that destination. Example configuration: newrelic.attributes.include = foo newrelic.transaction_events.attributes.exclude = foo Copy Example output: Keys passed in: foo Keys included for transaction events: Keys included for other destinations: foo Keys excluded for transaction events: foo Copy Deprecated properties The following properties have been deprecated. Switch to the new attributes configuration for these properties when upgrading your PHP agent. Deprecated property New property newrelic.capture_params newrelic.attributes.include = request.parameters.* By default, request parameters are not sent to New Relic. Add request.parameters.* to the newrelic.attributes.include list to turn on all request parameters. The newrelic.capture_params property has been deprecated. newrelic.ignored_params newrelic.attributes.exclude = request.parameters.{name} Add each request parameter key to the newrelic.attributes.exclude list, delimited by commas. Be sure to prepend the key with request.parameters. The newrelic.ignored_params property has been deprecated. newrelic.{destination}.capture_attributes newrelic.{destination}.attributes.enabled The old newrelic.{destination}.capture_attributes flag would turn off user attribute collection. This has been deprecated. Use newrelic.{destination}.attributes.enabled instead. For more help If you need more help, check out these support and learning resources: Suggest a change and learn how to contribute to our PHP agent open source repository. Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.64661,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Enable or disable <em>attributes</em>",
        "sections": "Enable or disable <em>attributes</em>",
        "tags": "<em>Agents</em>",
        "body": "Learn about properties to enable or disable <em>attributes</em>, and the rules that New Relic uses when determining which <em>attributes</em> to include or exclude for a destination. This also includes a summary of the PHP <em>agent</em> properties that have been deprecated with the release of New Relic <em>agent</em> <em>attributes</em>"
      },
      "id": "603e9d6de7b9d22a5f2f3445"
    }
  ],
  "/docs/agents/net-agent/attributes/net-agent-attributes": [
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.99238,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> <em>attributes</em>",
        "sections": "<em>Agent</em> <em>attributes</em>",
        "tags": "<em>Agents</em>",
        "body": " called browser monitoring. Span events Span events collected for distributed tracing will contain <em>attributes</em> collected during the span. The following <em>agents</em> support the addition of custom user <em>attributes</em> to span events: Java <em>agent</em> 5.13.0 and above Go <em>agent</em> 3.6.0 and above .<em>NET</em> <em>agent</em> 8.25 and above Node"
      },
      "id": "603eb9db28ccbc127aeba79e"
    },
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.98911,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Ruby <em>agent</em> <em>attributes</em>",
        "sections": "Ruby <em>agent</em> <em>attributes</em>",
        "tags": "<em>Agents</em>",
        "body": " <em>attributes</em> (types, destinations, and limits for <em>attributes</em> used by New Relic <em>agents</em>) Enabling and disabling <em>attributes</em> (properties, rules, and backwards compatibility information for Ruby <em>agent</em> <em>attributes</em>) Attribute examples (scenarios and results of enabling and disabling different Ruby <em>agent</em> <em>attributes</em>)"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "sections": [
        "Enable or disable attributes",
        "Properties",
        "newrelic.attributes.enabled",
        "newrelic.browser_monitoring.attributes.enabled",
        "newrelic.error_collector.attributes.enabled",
        "newrelic.transaction_events.attributes.enabled",
        "newrelic.transaction_tracer.attributes.enabled",
        "newrelic.span_events.attributes.enabled",
        "newrelic.attributes.include",
        "newrelic.attributes.exclude",
        "newrelic.browser_monitoring.attributes.include",
        "newrelic.browser_monitoring.attributes.exclude",
        "newrelic.error_collector.attributes.include",
        "newrelic.error_collector.attributes.exclude",
        "newrelic.transaction_events.attributes.include",
        "newrelic.transaction_events.attributes.exclude",
        "newrelic.transaction_tracer.attributes.include",
        "newrelic.transaction_tracer.attributes.exclude",
        "newrelic.span_events.attributes.include",
        "newrelic.span_events.attributes.exclude",
        "Attribute rules",
        "Root level takes precedence for enabled.",
        "Destination enabled takes precedence over include and exclude.",
        "Attribute is included if the destination is enabled.",
        "Exclude always supersedes include.",
        "Keys are case sensitive.",
        "Use a star (\\*) for wildcards.",
        "Most specific setting for a key takes priority.",
        "Include or exclude affects the specific destination.",
        "Deprecated properties",
        "For more help"
      ],
      "title": "Enable or disable attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "Attributes"
      ],
      "external_id": "6e9bf6c2e32a6add76412e6381a7bd4c99a0bc1c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/attributes/enable-or-disable-attributes/",
      "published_at": "2021-06-02T20:32:04Z",
      "updated_at": "2021-06-02T20:32:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Learn about properties to enable or disable attributes, and the rules that New Relic uses when determining which attributes to include or exclude for a destination. This also includes a summary of the PHP agent properties that have been deprecated with the release of New Relic agent attributes. Properties Use the following destination properties to open or close the destination to any attribute collection: newrelic.attributes.enabled Type Boolean Default True Turns on or turns off all attributes in all destinations. newrelic.browser_monitoring.attributes.enabled Type: Boolean Default: False Turns on or turns off all attributes for browser monitoring. This is the data that gets attached to page view events. If newrelic.attributes.enabled is false, no attributes will be sent to browser monitoring regardless of how this property is set. newrelic.error_collector.attributes.enabled Type: Boolean Default: True Turns on or turns off all attributes for traced errors. If newrelic.attributes.enabled is false, no attributes will be sent to traced errors regardless of how this property is set. newrelic.transaction_events.attributes.enabled Type: Boolean Default: True Turns on or turns off all attributes for transaction events. If newrelic.attributes.enabled is false, no attributes will be sent to transaction events regardless of how this property is set. newrelic.transaction_tracer.attributes.enabled Type Boolean Default True Turns on or off all attributes for transaction traces. If newrelic.attributes.enabled is false, no attributes will be sent to transaction traces regardless of how this property is set. newrelic.span_events.attributes.enabled Type Boolean Default True Turns on or off all attributes for Span data. If newrelic.attributes.enabled is false, no attributes will be sent to spans regardless of how this property is set. Use the following attribute/destination specific .include or .exclude properties to add or remove specific attributes in specific destinations: newrelic.attributes.include Type: Comma-delimited list of strings Default: Empty If attributes are enabled, all attribute keys in this list will be sent to New Relic. newrelic.attributes.exclude Type: Comma-delimited list of strings Default: Empty All attribute keys in this list will not be sent to New Relic. newrelic.browser_monitoring.attributes.include Type: Comma-delimited list of strings Default: Empty If attributes are enabled for browser_monitoring, all attribute keys in this list will be sent to New Relic Browser in page views. newrelic.browser_monitoring.attributes.exclude Type: Comma-delimited list of strings Default: Empty All attribute keys found in this list will not be sent to New Relic in page views. newrelic.error_collector.attributes.include Type: Comma-delimited list of strings Default: Empty If attributes are enabled for traced errors, all attribute keys in this list will be sent to New Relic in traced errors. newrelic.error_collector.attributes.exclude Type: Comma-delimited list of strings Default: Empty All attribute keys in this list will not be sent to New Relic in traced errors. newrelic.transaction_events.attributes.include Type: Comma-delimited list of strings Default: Empty If attributes are enabled for transaction events, all attribute keys in this list will be sent to New Relic in transaction events. newrelic.transaction_events.attributes.exclude Type: Comma-delimited list of strings Default: Empty All attribute keys in this list will not be sent to New Relic in transaction events. newrelic.transaction_tracer.attributes.include Type: Comma-delimited list of strings Default: Empty If attributes are enabled for transaction traces, all attribute keys in this list will be sent to New Relic in transaction traces. newrelic.transaction_tracer.attributes.exclude Type: Comma-delimited list of strings Default: Empty All attribute keys in this list will not be sent to New Relic in transaction traces. newrelic.span_events.attributes.include Type: Comma-delimited list of strings Default: Empty If attributes are enabled for span events, all attribute keys in this list will be sent to New Relic in span events. newrelic.span_events.attributes.exclude Type: Comma-delimited list of strings Default: Empty All attribute keys in this list will not be sent to New Relic in span events. Attribute rules New Relic follows these rules when determining which attributes to include or exclude for a destination. Root level takes precedence for enabled. The newrelic.attributes.enabled field trumps all other settings. When false, no attributes will be reported to New Relic. Example configuration: newrelic.attributes.enabled = false newrelic.attributes.include = foo,bar newrelic.transaction_tracer.attributes.enabled = true Copy Example output: Keys passed in: password, foo, bar, bat Keys included for all destinations: Keys excluded for all destinations: password, foo, bar, bat Copy Destination enabled takes precedence over include and exclude. newrelic.{destination}.attributes.enabled flags take precedence over include and exclude keys. Example configuration: newrelic.transaction_tracer.attributes.enabled = false newrelic.attributes.include = one,two newrelic.transaction_tracer.attributes.include = three,four Copy Example output: Keys passed in: one, two, three, four Keys included for transaction traces: Keys excluded for transaction traces: one, two, three, four Copy Attribute is included if the destination is enabled. If a destination is enabled, all user attributes are sent to that destination by default. All user attributes default to true. However, by default, request attributes and message parameters are disabled for all destinations. Example configuration: newrelic.attributes.enabled = true newrelic.attributes.exclude = myAttKey Copy Example output: Keys passed in: foo, bar, myAttKey Keys included: foo, bar Keys excluded: myAttKey Copy Exclude always supersedes include. If the same key is listed in the include and exclude lists, then attributes with the specified key will be excluded. Example configuration: newrelic.attributes.enabled = true newrelic.attributes.include = foo,myCustomAtt newrelic.attributes.exclude = password,myCustomAtt Copy Example output: Keys passed in: foo, myCustomAtt, password Keys included: foo Keys excluded: password, myCustomAtt Copy Keys are case sensitive. Keys are case sensitive. Example configuration: newrelic.attributes.enabled = true newrelic.attributes.exclude = password,PaSsWoRd Copy Example output: Keys passed in: password, Password, PASSWORD, PaSsWoRd, PassWORD Keys included: Password, PASSWORD, PassWORD Keys excluded: password, PaSsWoRd Copy Use a star (\\*) for wildcards. You can use an asterisk or star (*) at the end of a key as a wildcard. This will match a set of attributes with the same prefix. Example configuration: newrelic.attributes.enabled = true newrelic.attributes.include = custom* newrelic.attributes.exclude = request.parameters.* Copy Example output: Keys passed in: custom, custom.key1, custom.key2, request.parameters., request.parameters.foo, request.parameters.bar Keys included: custom, custom.key1, custom.key2 Keys excluded: request.parameters., request.parameters.foo, request.parameters.bar Copy Most specific setting for a key takes priority. If multiple include or exclude attributes affect the same key, the most specific setting will have priority. Example configuration: newrelic.attributes.enabled = true newrelic.attributes.include = request.parameters.foo newrelic.attributes.exclude = request.parameters.* Copy Example output: Keys passed in: request.parameters., request.parameters.foo, request.parameters.bar Keys included: request.parameters.foo Keys excluded: request.parameters., request.parameters.bar Copy Include or exclude affects the specific destination. If the attribute include or exclude is specified on a destination, then it only impacts that destination. Example configuration: newrelic.attributes.include = foo newrelic.transaction_events.attributes.exclude = foo Copy Example output: Keys passed in: foo Keys included for transaction events: Keys included for other destinations: foo Keys excluded for transaction events: foo Copy Deprecated properties The following properties have been deprecated. Switch to the new attributes configuration for these properties when upgrading your PHP agent. Deprecated property New property newrelic.capture_params newrelic.attributes.include = request.parameters.* By default, request parameters are not sent to New Relic. Add request.parameters.* to the newrelic.attributes.include list to turn on all request parameters. The newrelic.capture_params property has been deprecated. newrelic.ignored_params newrelic.attributes.exclude = request.parameters.{name} Add each request parameter key to the newrelic.attributes.exclude list, delimited by commas. Be sure to prepend the key with request.parameters. The newrelic.ignored_params property has been deprecated. newrelic.{destination}.capture_attributes newrelic.{destination}.attributes.enabled The old newrelic.{destination}.capture_attributes flag would turn off user attribute collection. This has been deprecated. Use newrelic.{destination}.attributes.enabled instead. For more help If you need more help, check out these support and learning resources: Suggest a change and learn how to contribute to our PHP agent open source repository. Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.64656,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Enable or disable <em>attributes</em>",
        "sections": "Enable or disable <em>attributes</em>",
        "tags": "<em>Agents</em>",
        "body": "Learn about properties to enable or disable <em>attributes</em>, and the rules that New Relic uses when determining which <em>attributes</em> to include or exclude for a destination. This also includes a summary of the PHP <em>agent</em> properties that have been deprecated with the release of New Relic <em>agent</em> <em>attributes</em>"
      },
      "id": "603e9d6de7b9d22a5f2f3445"
    }
  ],
  "/docs/agents/net-agent/attributes/net-attribute-examples": [
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.99238,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> <em>attributes</em>",
        "sections": "<em>Agent</em> <em>attributes</em>",
        "tags": "<em>Agents</em>",
        "body": " called browser monitoring. Span events Span events collected for distributed tracing will contain <em>attributes</em> collected during the span. The following <em>agents</em> support the addition of custom user <em>attributes</em> to span events: Java <em>agent</em> 5.13.0 and above Go <em>agent</em> 3.6.0 and above .<em>NET</em> <em>agent</em> 8.25 and above Node"
      },
      "id": "603eb9db28ccbc127aeba79e"
    },
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.98911,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Ruby <em>agent</em> <em>attributes</em>",
        "sections": "Ruby <em>agent</em> <em>attributes</em>",
        "tags": "<em>Agents</em>",
        "body": " <em>attributes</em> (types, destinations, and limits for <em>attributes</em> used by New Relic <em>agents</em>) Enabling and disabling <em>attributes</em> (properties, rules, and backwards compatibility information for Ruby <em>agent</em> <em>attributes</em>) Attribute examples (scenarios and results of enabling and disabling different Ruby <em>agent</em> <em>attributes</em>)"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "sections": [
        "Enable or disable attributes",
        "Properties",
        "newrelic.attributes.enabled",
        "newrelic.browser_monitoring.attributes.enabled",
        "newrelic.error_collector.attributes.enabled",
        "newrelic.transaction_events.attributes.enabled",
        "newrelic.transaction_tracer.attributes.enabled",
        "newrelic.span_events.attributes.enabled",
        "newrelic.attributes.include",
        "newrelic.attributes.exclude",
        "newrelic.browser_monitoring.attributes.include",
        "newrelic.browser_monitoring.attributes.exclude",
        "newrelic.error_collector.attributes.include",
        "newrelic.error_collector.attributes.exclude",
        "newrelic.transaction_events.attributes.include",
        "newrelic.transaction_events.attributes.exclude",
        "newrelic.transaction_tracer.attributes.include",
        "newrelic.transaction_tracer.attributes.exclude",
        "newrelic.span_events.attributes.include",
        "newrelic.span_events.attributes.exclude",
        "Attribute rules",
        "Root level takes precedence for enabled.",
        "Destination enabled takes precedence over include and exclude.",
        "Attribute is included if the destination is enabled.",
        "Exclude always supersedes include.",
        "Keys are case sensitive.",
        "Use a star (\\*) for wildcards.",
        "Most specific setting for a key takes priority.",
        "Include or exclude affects the specific destination.",
        "Deprecated properties",
        "For more help"
      ],
      "title": "Enable or disable attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "Attributes"
      ],
      "external_id": "6e9bf6c2e32a6add76412e6381a7bd4c99a0bc1c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/attributes/enable-or-disable-attributes/",
      "published_at": "2021-06-02T20:32:04Z",
      "updated_at": "2021-06-02T20:32:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Learn about properties to enable or disable attributes, and the rules that New Relic uses when determining which attributes to include or exclude for a destination. This also includes a summary of the PHP agent properties that have been deprecated with the release of New Relic agent attributes. Properties Use the following destination properties to open or close the destination to any attribute collection: newrelic.attributes.enabled Type Boolean Default True Turns on or turns off all attributes in all destinations. newrelic.browser_monitoring.attributes.enabled Type: Boolean Default: False Turns on or turns off all attributes for browser monitoring. This is the data that gets attached to page view events. If newrelic.attributes.enabled is false, no attributes will be sent to browser monitoring regardless of how this property is set. newrelic.error_collector.attributes.enabled Type: Boolean Default: True Turns on or turns off all attributes for traced errors. If newrelic.attributes.enabled is false, no attributes will be sent to traced errors regardless of how this property is set. newrelic.transaction_events.attributes.enabled Type: Boolean Default: True Turns on or turns off all attributes for transaction events. If newrelic.attributes.enabled is false, no attributes will be sent to transaction events regardless of how this property is set. newrelic.transaction_tracer.attributes.enabled Type Boolean Default True Turns on or off all attributes for transaction traces. If newrelic.attributes.enabled is false, no attributes will be sent to transaction traces regardless of how this property is set. newrelic.span_events.attributes.enabled Type Boolean Default True Turns on or off all attributes for Span data. If newrelic.attributes.enabled is false, no attributes will be sent to spans regardless of how this property is set. Use the following attribute/destination specific .include or .exclude properties to add or remove specific attributes in specific destinations: newrelic.attributes.include Type: Comma-delimited list of strings Default: Empty If attributes are enabled, all attribute keys in this list will be sent to New Relic. newrelic.attributes.exclude Type: Comma-delimited list of strings Default: Empty All attribute keys in this list will not be sent to New Relic. newrelic.browser_monitoring.attributes.include Type: Comma-delimited list of strings Default: Empty If attributes are enabled for browser_monitoring, all attribute keys in this list will be sent to New Relic Browser in page views. newrelic.browser_monitoring.attributes.exclude Type: Comma-delimited list of strings Default: Empty All attribute keys found in this list will not be sent to New Relic in page views. newrelic.error_collector.attributes.include Type: Comma-delimited list of strings Default: Empty If attributes are enabled for traced errors, all attribute keys in this list will be sent to New Relic in traced errors. newrelic.error_collector.attributes.exclude Type: Comma-delimited list of strings Default: Empty All attribute keys in this list will not be sent to New Relic in traced errors. newrelic.transaction_events.attributes.include Type: Comma-delimited list of strings Default: Empty If attributes are enabled for transaction events, all attribute keys in this list will be sent to New Relic in transaction events. newrelic.transaction_events.attributes.exclude Type: Comma-delimited list of strings Default: Empty All attribute keys in this list will not be sent to New Relic in transaction events. newrelic.transaction_tracer.attributes.include Type: Comma-delimited list of strings Default: Empty If attributes are enabled for transaction traces, all attribute keys in this list will be sent to New Relic in transaction traces. newrelic.transaction_tracer.attributes.exclude Type: Comma-delimited list of strings Default: Empty All attribute keys in this list will not be sent to New Relic in transaction traces. newrelic.span_events.attributes.include Type: Comma-delimited list of strings Default: Empty If attributes are enabled for span events, all attribute keys in this list will be sent to New Relic in span events. newrelic.span_events.attributes.exclude Type: Comma-delimited list of strings Default: Empty All attribute keys in this list will not be sent to New Relic in span events. Attribute rules New Relic follows these rules when determining which attributes to include or exclude for a destination. Root level takes precedence for enabled. The newrelic.attributes.enabled field trumps all other settings. When false, no attributes will be reported to New Relic. Example configuration: newrelic.attributes.enabled = false newrelic.attributes.include = foo,bar newrelic.transaction_tracer.attributes.enabled = true Copy Example output: Keys passed in: password, foo, bar, bat Keys included for all destinations: Keys excluded for all destinations: password, foo, bar, bat Copy Destination enabled takes precedence over include and exclude. newrelic.{destination}.attributes.enabled flags take precedence over include and exclude keys. Example configuration: newrelic.transaction_tracer.attributes.enabled = false newrelic.attributes.include = one,two newrelic.transaction_tracer.attributes.include = three,four Copy Example output: Keys passed in: one, two, three, four Keys included for transaction traces: Keys excluded for transaction traces: one, two, three, four Copy Attribute is included if the destination is enabled. If a destination is enabled, all user attributes are sent to that destination by default. All user attributes default to true. However, by default, request attributes and message parameters are disabled for all destinations. Example configuration: newrelic.attributes.enabled = true newrelic.attributes.exclude = myAttKey Copy Example output: Keys passed in: foo, bar, myAttKey Keys included: foo, bar Keys excluded: myAttKey Copy Exclude always supersedes include. If the same key is listed in the include and exclude lists, then attributes with the specified key will be excluded. Example configuration: newrelic.attributes.enabled = true newrelic.attributes.include = foo,myCustomAtt newrelic.attributes.exclude = password,myCustomAtt Copy Example output: Keys passed in: foo, myCustomAtt, password Keys included: foo Keys excluded: password, myCustomAtt Copy Keys are case sensitive. Keys are case sensitive. Example configuration: newrelic.attributes.enabled = true newrelic.attributes.exclude = password,PaSsWoRd Copy Example output: Keys passed in: password, Password, PASSWORD, PaSsWoRd, PassWORD Keys included: Password, PASSWORD, PassWORD Keys excluded: password, PaSsWoRd Copy Use a star (\\*) for wildcards. You can use an asterisk or star (*) at the end of a key as a wildcard. This will match a set of attributes with the same prefix. Example configuration: newrelic.attributes.enabled = true newrelic.attributes.include = custom* newrelic.attributes.exclude = request.parameters.* Copy Example output: Keys passed in: custom, custom.key1, custom.key2, request.parameters., request.parameters.foo, request.parameters.bar Keys included: custom, custom.key1, custom.key2 Keys excluded: request.parameters., request.parameters.foo, request.parameters.bar Copy Most specific setting for a key takes priority. If multiple include or exclude attributes affect the same key, the most specific setting will have priority. Example configuration: newrelic.attributes.enabled = true newrelic.attributes.include = request.parameters.foo newrelic.attributes.exclude = request.parameters.* Copy Example output: Keys passed in: request.parameters., request.parameters.foo, request.parameters.bar Keys included: request.parameters.foo Keys excluded: request.parameters., request.parameters.bar Copy Include or exclude affects the specific destination. If the attribute include or exclude is specified on a destination, then it only impacts that destination. Example configuration: newrelic.attributes.include = foo newrelic.transaction_events.attributes.exclude = foo Copy Example output: Keys passed in: foo Keys included for transaction events: Keys included for other destinations: foo Keys excluded for transaction events: foo Copy Deprecated properties The following properties have been deprecated. Switch to the new attributes configuration for these properties when upgrading your PHP agent. Deprecated property New property newrelic.capture_params newrelic.attributes.include = request.parameters.* By default, request parameters are not sent to New Relic. Add request.parameters.* to the newrelic.attributes.include list to turn on all request parameters. The newrelic.capture_params property has been deprecated. newrelic.ignored_params newrelic.attributes.exclude = request.parameters.{name} Add each request parameter key to the newrelic.attributes.exclude list, delimited by commas. Be sure to prepend the key with request.parameters. The newrelic.ignored_params property has been deprecated. newrelic.{destination}.capture_attributes newrelic.{destination}.attributes.enabled The old newrelic.{destination}.capture_attributes flag would turn off user attribute collection. This has been deprecated. Use newrelic.{destination}.attributes.enabled instead. For more help If you need more help, check out these support and learning resources: Suggest a change and learn how to contribute to our PHP agent open source repository. Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.64656,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Enable or disable <em>attributes</em>",
        "sections": "Enable or disable <em>attributes</em>",
        "tags": "<em>Agents</em>",
        "body": "Learn about properties to enable or disable <em>attributes</em>, and the rules that New Relic uses when determining which <em>attributes</em> to include or exclude for a destination. This also includes a summary of the PHP <em>agent</em> properties that have been deprecated with the release of New Relic <em>agent</em> <em>attributes</em>"
      },
      "id": "603e9d6de7b9d22a5f2f3445"
    }
  ],
  "/docs/agents/net-agent/azure-installation/install-azure-marketplace-app-new-relic": [
    {
      "sections": [
        "Install the .NET agent on Azure Cloud Services",
        "Important",
        "Check Web or Worker role's location",
        "Install the NuGet package for Cloud Services",
        "Instrument Worker role",
        "Custom instrumentation example for Worker role",
        "Custom instrumentation file deployment",
        "Optional: Create custom config file",
        "View your app's performance"
      ],
      "title": "Install the .NET agent on Azure Cloud Services",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "afe3e181b9ec18fa0b2be3e76f7c9b20d247d21e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-installation/install-net-agent-azure-cloud-services/",
      "published_at": "2021-06-02T20:23:51Z",
      "updated_at": "2021-03-16T14:55:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install APM's .NET agent on Microsoft's Azure Cloud Services platform. This is not the same as installing the Infrastructure integrations for Microsoft Azure. To make sure you are using the most relevant instructions, first see the .NET agent install overview. Important Before installing the NuGet package into a multi-project Visual Studio solution, make sure you have selected the correct project for your New Relic .NET application (for example, a specific website project). Check Web or Worker role's location If Service files are nested within a Solution folder, the NuGet installer cannot locate or update the necessary files. This will cause issues with the .NET agent setup, which will in turn prevent the agent from reporting metrics on your Cloud Service. Recommendation: Place the Web or Worker role at the root of the solution before installing the NuGet package. Once the New Relic .NET agent is installed, you can move the Cloud role back into the Solution folder. Install the NuGet package for Cloud Services Important The NuGet packages in this procedure support only the old packages.config. They do not support the new PackageReference format. For more information see Microsoft's package reference documentation For multi-project solutions, make sure you have selected the correct project (for example, a specific website project) before installing the NuGet package. Open your Visual Studio solution, or create a new one by selecting File > New > Project. For multi-project solutions, make sure you have selected the correct project (for example, a specific website project). If you do not already have an Azure Cloud Service project in your solution, add one by right-clicking your app in the Solution Explorer and selecting Add Windows Azure Cloud Service Project. Open the Package Manager console by selecting Tools > Library Package Manager > Package Manager Console. Set your project as the default project. From the Package Manager command prompt, type Install-Package NewRelicWindowsAzure and press Enter. Follow the prompts to enter your New Relic license key and your application name as you want it to appear in the New Relic UI. Or, use your solution name as the default app name. From the Solution Explorer, right-click your Azure Cloud Service project, and select Publish. If this is your first time deploying this app to Azure, enter your Azure credentials. If applicable, instrument methods for Worker roles. Instrument Worker role A Worker role is a non-web process run as an Azure Cloud Service. To instrument a Worker role, you must create custom transactions. The .NET agent automatically instruments external calls and database calls, but it does not instrument default methods for transactions. Creating custom transactions solves this. After the Worker role starts up and the method executes, transaction data will appear in the APM Summary and Transactions pages under the Non-web category. The NuGet installer automatically adds the NewRelic.AppName parameter to the application config. This appears as <YOUR_WORKER_ROLE_NAME>.dll.config in E:\\approot. The .NET agent also automatically instruments WaWorkerHost.exe. This is the name of the actual Worker role process. Custom instrumentation example for Worker role This is a custom instrumentation example for a Worker role. It creates a custom transaction named ProcessMessage. The transaction begins when the ProcessMessage method is entered, and it ends when the method returns. The following example uses MyWorkerRole as the namespace. If you do not specify a name, it will default to the Solution name. namespace MyWorkerRole { public class NotificationQueue { public bool ProcessMessage(Message message) { // code to process message } } } Copy Here is the custom instrumentation file for the code: <?xml version=\"1.0\" encoding=\"utf-8\"?> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerfactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Custom/ProcessMessage\"> <match assemblyname=\"MyWorkerRole\" classname=\"MyWorkerRole.NotificationQueue\"> <exactmethodmatcher methodName=\"ProcessMessage\" /> </match> </tracerfactory> </instrumentation> </extension> Copy On a local installation, place this instrumentation file in C:\\ProgramData\\New Relic\\.NET Agent\\Extensions. Custom instrumentation file deployment Optional: To send the custom instrumentation file up with an Azure Cloud Service deployment: In your Azure Cloud project, add the instrumentation file to your Worker role inside the Roles folder. After installing the New Relic .NET agent NuGet package, locate newrelic.cmd in your Worker Role project. Find the statement IF %ERRORLEVEL% EQU 0 within the :INSTALL_NEWRELIC_AGENT block, and add the following statement to the conditional: IF %ERRORLEVEL% EQU 0 ( copy /Y \"%RoleRoot%\\approot\\MyInstrumentation.xml\" \"%NR_HOME%\\extensions\" >> %RoleRoot%\\nr.log ) ELSE ( Copy In this example, the newrelic.cmd batch file copies the custom instrumentation file to the Extensions folder in D:\\ProgramData\\New Relic\\.NET Agent\\, or %NR_HOME%. This example uses MyInstrumentation.xml, but any name will work as long as the file name and copy command match, and the file is valid XML. Optional: Create custom config file You can create a custom configuration file in Visual Studio. This allows you to make changes to newrelic.config inside Visual Studio, without having to remote into your Azure Role instance every time you make a change. Whenever you publish your app, the config file in Visual Studio is automatically uploaded to the remote host. The choices you make with the installation wizard do not matter. Installing locally does not affect your Azure development environment. In Visual Studio, select the Solution Explorer, then open NewRelicAgent_x64_XYZ.msi. Follow the steps to install the agent locally. Import newrelic.config into your project: In Solution Explorer > Cloud Project, right-click the Web Role, then select Add > Existing Item. Navigate to C: \\ ProgramData \\ New Relic \\ .NET Agent and select newrelic.config. From C: \\ ProgramData \\ New Relic \\ .NET Agent, edit newrelic.cmd. In the :INSTALL_NEWRELIC_AGENT section, find this statement: IF $ERRORLEVEL% EQU 0 ( Copy Add the following code as another statement inside the IF block, then save the file: copy /Y \"%RoleRoot%\\approot\\newrelic.config\" \"%NR_HOME%\" >> %RoleRoot%\\nr.log Copy You can now edit the newrelic.config hosted in Visual Studio. Whenever you publish your app, the copy command will upload the config file to the remote host. View your app's performance Your application must receive traffic in order for you to view its performance in New Relic. You may need to wait a few minutes for data to start appearing. If no data appears, see the troubleshooting procedures for Azure Cloud Services. To view your app's performance in APM: Go to one.newrelic.com > APM > (select an app). The APM Summary page automatically appears. You can also view detailed information about errors, database and instance performance issues, and more. If you created your New Relic app prior to October 2017, you can use the Azure Portal to select the New Relic account blade. You will be automatically logged in with SAML Single Sign-on (SSO) to APM. You can also view your application's error rate and throughput data in the Azure Portal by going to New Relic Accounts > choose your application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.49438,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Cloud Services",
        "sections": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Cloud Services",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": "&gt; &lt;&#x2F;tracerfactory&gt; &lt;&#x2F;instrumentation&gt; &lt;&#x2F;extension&gt; Copy On a local <em>installation</em>, place this instrumentation file in C:\\ProgramData\\New Relic\\.<em>NET</em> <em>Agent</em>\\Extensions. Custom instrumentation file deployment Optional: To send the custom instrumentation file up with an <em>Azure</em> Cloud Service deployment: In your"
      },
      "id": "603e8e7ee7b9d2b4d42a07e3"
    },
    {
      "sections": [
        "Install the .NET agent on Azure Web Apps",
        "Installation options",
        "Tip",
        "Disable Application Insights",
        "Install using the New Relic Azure Site Extension",
        "Install using NuGet (.NET Framework)",
        "Install using NuGet (.NET Core)",
        "Log file configuration for Windows",
        "Log file configuration for Linux",
        "Environment variables for Windows",
        "Environment variables for Linux",
        "Add New Relic app settings to Azure App Services",
        "View your app's performance",
        "Troubleshooting"
      ],
      "title": "Install the .NET agent on Azure Web Apps",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "5cb6afb3ad05fdc243d2cf110f4df1e7e027740d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-installation/install-net-agent-azure-web-apps/",
      "published_at": "2021-06-02T14:45:45Z",
      "updated_at": "2021-03-16T14:55:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install New Relic's .NET agent for application performance monitoring on your Azure Web App. (This is not the same as installing the infrastructure monitoring integrations for Microsoft Azure.) Recommendation: Before following these instructions, read the .NET agent installation overview. Installation options Tip To use .NET or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Use any of the following methods to add the New Relic .NET agent to your Azure-deployed web app. The best option depends on your role, environment, deployments, etc. For example: For operations teams that need to monitor the app, best practice may be to: Install using the Azure Site Extension For developer teams, best practice may be to use NuGet: Install using NuGet (.NET Framework) Install using NuGet (.NET Core) In order to monitor non-web apps (including WebJobs), or ASP.NET Core apps targeting .NET Framework, you must explicitly enable the agent for that application's .exe process via one of these two methods: Enable via placement of local newrelic.config file. Enable via application config file In addition, WebJobs may need custom instrumentation for transactions to appear in APM, and additional configuration if they run for less than one minute. Disable Application Insights Both New Relic's .NET agent and Microsoft Application Insights rely on the CLR Profiler, but only one may be active at a time. You must disable Application Insights in order for the .NET agent to function properly. For more information, see our Application Insights troubleshooting procedures. Install using the New Relic Azure Site Extension To install the .NET agent for an Azure Web App using the New Relic Azure Site Extension: Shut down your web application before installing the New Relic Azure Site Extension. Add the site extension: Navigate to http://[yoursitename].scm.azurewebsites.net, then select Site extensions > Gallery. Select the plus icon next to the New Relic site extension. In the Azure portal, add New Relic app settings to your Azure App Service. Restart your web app to use the new version of the agent. Install using NuGet (.NET Framework) The NuGet packages in this procedure support only the old packages.config. They do not support the current PackageReference format. For more information, see Microsoft's package reference documentation. For multi-project solutions, make sure you have selected the correct project (for example, a specific web app project) before installing the NuGet package. If you are upgrading the .NET Framework agent using NuGet, any changes you made in the newrelic.config will be overwritten. To preserve any changes, save your newrelic.config outside of your project, then restore it after upgrading. To install the .NET agent on an Azure Web App using NuGet: In the Azure portal, verify your Azure Platform (32-bit or 64-bit): From the Azure sidebar menu, select App Services > Your Application > Settings > Configuration > General settings. Open your application in Visual Studio, and install the New Relic NuGet package by running the appropriate command from the Package manager console: 32-bit: Install-Package NewRelic.Azure.WebSites 64-bit: Install-Package NewRelic.Azure.WebSites.x64 Publish your application. In the Azure portal, open the web app you want to monitor, then select Settings > Configuration. From Configuration, select + New application setting and add these key/value pairs: Key Value COR_ENABLE_PROFILING 1 COR_PROFILER {71DA0A04-7777-4EC6-9643-7D28B46A8A41} COR_PROFILER_PATH D:\\Home\\site\\wwwroot\\newrelic\\NewRelic.Profiler.dll NEWRELIC_HOME D:\\Home\\site\\wwwroot\\newrelic In the Azure portal, add New Relic app settings to your Azure App Service. Restart your web app. Install using NuGet (.NET Core) New Relic .NET Core agent supports Linux and Windows applications on Azure App Services. The installation process for Azure App Services differs from the .NET Core agent installation procedures for Linux and Windows. To install the .NET agent on an Azure Web App using NuGet: Install the NewRelic.Agent NuGet package. Modify the log node by adding a directory attribute to your newrelic.config file: Log file configuration for Windows log directory=\"D:\\Home\\LogFiles\\NewRelic\" level=\"info\"/log Copy Log file configuration for Linux log directory=\"/home/LogFiles/NewRelic\" level=\"info\"/log Copy Publish your application. In the Azure portal, open the web app you want to monitor, then select Settings > Configuration. From Configuration, select + New application setting and add these key/value pairs: Environment variables for Windows Key Value CORECLR_ENABLE_PROFILING 1 CORECLR_PROFILER {36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_PROFILER_PATH_32 D:\\Home\\site\\wwwroot\\newrelic\\x86\\NewRelic.Profiler.dll CORECLR_PROFILER_PATH_64 D:\\Home\\site\\wwwroot\\newrelic\\NewRelic.Profiler.dll CORECLR_NEWRELIC_HOME D:\\Home\\site\\wwwroot\\newrelic Environment variables for Linux Key Value CORECLR_ENABLE_PROFILING 1 CORECLR_PROFILER {36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_PROFILER_PATH /home/site/wwwroot/newrelic/libNewRelicProfiler.so CORECLR_NEWRELIC_HOME /home/site/wwwroot/newrelic In the Azure portal, add New Relic app settings to your Azure App Service. Restart your web app. Add New Relic app settings to Azure App Services To add your app settings: Make sure you have your license key before adding the New Relic .NET agent's app settings. In the Azure portal, open the web app you want to monitor, then select Configuration > Application settings. From Application settings, select + New application setting and add these key/value pairs: Key Value NEW_RELIC_LICENSE_KEY YOUR_LICENSE_KEY NEW_RELIC_APP_NAME YOUR_APP_NAME Save and restart your web app. Setting the license key and app name with Application settings will override the newrelic.config. To verify your app's environment variables in your app's Kudu diagnostic console, go to Environment > Environment variables. For example: https://myappname.scm.azurewebsites.net/Env.cshtml#envVariables Copy View your app's performance Your application must receive traffic in order for you to view its performance in New Relic. You may need to wait a few minutes for data to start appearing. If no data appears, see the troubleshooting procedures for Azure Web Apps. To view your app's performance in New Relic: Go to one.newrelic.com > APM > (select an app). The APM Summary page automatically appears. You can also view detailed information about errors, database and instance performance issues, and more. If you created your New Relic app prior to October 2017, you can use the Azure portal to select the New Relic account blade. You will be automatically logged in with SAML Single Sign-on (SSO) to APM. You can also view your application's error rate and throughput data in the Azure portal by going to New Relic Accounts > (select your app). Troubleshooting If no data appears after installing the agent, generating traffic for your app, and waiting a few minutes, try these troubleshooting tips: Make sure that all files in the newrelic directory at the root of your app got published to Azure. Make sure the environment variables are set correctly. Make sure Microsoft Application Insights is not installed and configured on the application. For more information, see the Application Insights troubleshooting procedures. Refer to additional Azure troubleshooting procedures as applicable.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.17722,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Web Apps",
        "sections": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Web Apps",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": ". Restart your web app. Install using NuGet (.<em>NET</em> Core) New Relic .<em>NET</em> Core <em>agent</em> supports Linux and Windows applications on <em>Azure</em> App Services. The <em>installation</em> process for <em>Azure</em> App Services differs from the .<em>NET</em> Core <em>agent</em> <em>installation</em> procedures for Linux and Windows. To install the .<em>NET</em> <em>agent</em>"
      },
      "id": "603e8e7c28ccbc420ceba748"
    },
    {
      "sections": [
        "Install .NET agent on Azure Service Fabric",
        "Important",
        "Install using NuGet",
        ".NET Framework",
        ".NET Core for Windows",
        ".NET Core for Linux"
      ],
      "title": "Install .NET agent on Azure Service Fabric",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "c520de26567fd173a0ac7b19ac0044a5757862bb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-installation/install-net-agent-azure-service-fabric/",
      "published_at": "2021-06-02T17:51:59Z",
      "updated_at": "2021-03-13T02:21:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install APM's .NET Framework agent and .NET Core agent on Azure Service Fabric. This is not the same as installing the Infrastructure integrations for Microsoft Azure. Install .NET agent on Azure Service Fabric Important In most cases, installing the .NET agent in an Azure Service Fabric environment can be performed using the standard install procedures for either Windows or Linux. This document highlights some alternate ways you can install the agent. You will need to ensure the agent gets installed on all nodes in your cluster. To monitor multiple nodes, you may want to integrate the install into your deployment process. If you are using containers in your Service Fabric environment you should read Install for Docker. You can also install the agent in a Service Fabric environment using NuGet. NuGet is often a good option for developers because the agent gets deployed along with your application. Though, using NuGet requires some manual installation procedures. See Install with NuGet. Install using NuGet To install the .NET agent using NuGet: Follow the standard NuGet install procedures. When using NuGet, you must set some environment variables. This can be done in your application's ServiceManifest.xml file. See the relevant instructions below: .NET Framework In the ServiceManifest.xml file in your project, include the following under the CodePackage node: <CodePackage Name=\"Code\" Version=\"1.0.0\"> </CodePackage> <CodePackage> ... <EntryPoint> <ExeHost> ... <!-- It is important for the WorkingFolder to be set to CodePackage --> <!-- This is because the environment variables set below rely on this being the working folder for the agent to work --> <WorkingFolder>CodePackage</WorkingFolder> ... </ExeHost> </EntryPoint> ... <EnvironmentVariables> ... <EnvironmentVariable Name=\"COR_ENABLE_PROFILING\" Value=\"1\" /> <EnvironmentVariable Name=\"COR_PROFILER\" Value=\"{71DA0A04-7777-4EC6-9643-7D28B46A8A41}\" /> <EnvironmentVariable Name=\"COR_PROFILER_PATH\" Value=\".\\newrelic\\NewRelic.Profiler.dll\" /> <EnvironmentVariable Name=\"NEWRELIC_HOME\" Value=\".\\newrelic\" /> <EnvironmentVariable Name=\"NEW_RELIC_LICENSE_KEY\" Value=\"YOUR_LICENSE_KEY\" /> <EnvironmentVariable Name=\"NEW_RELIC_APP_NAME\" Value=\"YOUR_APP_NAME\" /> ... </EnvironmentVariables> ... </CodePackage> Copy .NET Core for Windows In the ServiceManifest.xml file in your project, include the following under the CodePackage node: <CodePackage> ... <EntryPoint> <ExeHost> ... <!-- It is important for the WorkingFolder to be set to CodePackage --> <!-- This is because the environment variables set below rely on this being the working folder for the agent to work --> <WorkingFolder>CodePackage</WorkingFolder> ... </ExeHost> </EntryPoint> ... <EnvironmentVariables> ... <EnvironmentVariable Name=\"CORECLR_ENABLE_PROFILING\" Value=\"1\" /> <EnvironmentVariable Name=\"CORECLR_PROFILER\" Value=\"{36032161-FFC0-4B61-B559-F6C5D41BAE5A}\" /> <EnvironmentVariable Name=\"CORECLR_PROFILER_PATH\" Value=\".\\newrelic\\NewRelic.Profiler.dll\" /> <EnvironmentVariable Name=\"CORECLR_NEWRELIC_HOME\" Value=\".\\newrelic\" /> <EnvironmentVariable Name=\"NEW_RELIC_LICENSE_KEY\" Value=\"YOUR_LICENSE_KEY\" /> <EnvironmentVariable Name=\"NEW_RELIC_APP_NAME\" Value=\"YOUR_APP_NAME\" /> ... </EnvironmentVariables> ... </CodePackage> Copy .NET Core for Linux In the ServiceManifest.xml file in your project, include the following under the CodePackage node: <CodePackage> ... <EntryPoint> <ExeHost> ... <!-- It is important for the WorkingFolder to be set to CodePackage --> <!-- This is because the environment variables set below rely on this being the working folder for the agent to work --> <WorkingFolder>CodePackage</WorkingFolder> ... </ExeHost> </EntryPoint> ... <EnvironmentVariables> ... <EnvironmentVariable Name=\"CORECLR_ENABLE_PROFILING\" Value=\"1\" /> <EnvironmentVariable Name=\"CORECLR_PROFILER\" Value=\"{36032161-FFC0-4B61-B559-F6C5D41BAE5A}\" /> <EnvironmentVariable Name=\"CORECLR_PROFILER_PATH\" Value=\"./newrelic/libNewRelicProfiler.so\" /> <EnvironmentVariable Name=\"CORECLR_NEWRELIC_HOME\" Value=\"./newrelic\" /> <EnvironmentVariable Name=\"NEW_RELIC_LICENSE_KEY\" Value=\"YOUR_LICENSE_KEY\" /> <EnvironmentVariable Name=\"NEW_RELIC_APP_NAME\" Value=\"YOUR_APP_NAME\" /> ... </EnvironmentVariables> ... </CodePackage> Copy For the .NET Framework only: Edit your app.config file and add the NewRelic.AgentEnabled app setting: <appSettings> ... <add key=\"NewRelic.AgentEnabled\" value=\"true\" /> ... </appSettings> Copy If your application is generating traffic, data should appear in your APM account in several minutes. If data does not appear, try these troubleshooting steps: Make sure that all files in the newrelic directory at the root of your app was published to Azure. Make sure the environment variables are set correctly. See the general troubleshooting documentation to check for common errors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.435974,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .<em>NET</em> <em>agent</em> on <em>Azure</em> Service Fabric",
        "sections": "<em>Install</em> .<em>NET</em> <em>agent</em> on <em>Azure</em> Service Fabric",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": "This document explains how to install APM&#x27;s .<em>NET</em> Framework <em>agent</em> and .<em>NET</em> Core <em>agent</em> on <em>Azure</em> Service Fabric. This is not the same as installing the Infrastructure integrations for Microsoft <em>Azure</em>. Install .<em>NET</em> <em>agent</em> on <em>Azure</em> Service Fabric Important In most cases, installing the .<em>NET</em> <em>agent</em>"
      },
      "id": "6043c8a6e7b9d24fa25799bc"
    }
  ],
  "/docs/agents/net-agent/azure-installation/install-net-agent-azure-cloud-services": [
    {
      "sections": [
        "Install Azure Marketplace app with New Relic",
        "End of life notice",
        "Install New Relic .NET agent"
      ],
      "title": "Install Azure Marketplace app with New Relic",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "aef2e193486dd4993ae483d01735a03537b138b2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-installation/install-azure-marketplace-app-new-relic/",
      "published_at": "2021-06-02T20:23:49Z",
      "updated_at": "2021-03-13T02:42:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "End of life notice As of October 2017 you cannot create a New Relic account through Microsoft's Azure Marketplace Portal. Instead, if you have an Azure ID but do not already have a New Relic account, contact New Relic Sales. For more information, see the Azure transition information in New Relic's Online Technical Community. Install New Relic .NET agent Continue with the procedures to install the New Relic .NET agent with your Azure app as applicable for: Microsoft's Web App Services in the Azure Portal Microsoft's Cloud Services platform The .NET agent's support for Microsoft Azure is not the same as Infrastructure monitoring's integrations with Azure. Azure integrations have separate integration installation procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.13605,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>Azure</em> Marketplace app with New Relic",
        "sections": "<em>Install</em> New Relic .<em>NET</em> <em>agent</em>",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": "&#x27;s Online Technical Community. Install New Relic .<em>NET</em> <em>agent</em> Continue with the procedures to install the New Relic .<em>NET</em> <em>agent</em> with your <em>Azure</em> app as applicable for: Microsoft&#x27;s Web App Services in the <em>Azure</em> Portal Microsoft&#x27;s Cloud Services platform The .<em>NET</em> <em>agent</em>&#x27;s support for Microsoft <em>Azure</em> is not the same as Infrastructure monitoring&#x27;s integrations with <em>Azure</em>. <em>Azure</em> integrations have separate integration <em>installation</em> procedures."
      },
      "id": "6043c3ade7b9d24ead5799b2"
    },
    {
      "sections": [
        "Install the .NET agent on Azure Web Apps",
        "Installation options",
        "Tip",
        "Disable Application Insights",
        "Install using the New Relic Azure Site Extension",
        "Install using NuGet (.NET Framework)",
        "Install using NuGet (.NET Core)",
        "Log file configuration for Windows",
        "Log file configuration for Linux",
        "Environment variables for Windows",
        "Environment variables for Linux",
        "Add New Relic app settings to Azure App Services",
        "View your app's performance",
        "Troubleshooting"
      ],
      "title": "Install the .NET agent on Azure Web Apps",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "5cb6afb3ad05fdc243d2cf110f4df1e7e027740d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-installation/install-net-agent-azure-web-apps/",
      "published_at": "2021-06-02T14:45:45Z",
      "updated_at": "2021-03-16T14:55:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install New Relic's .NET agent for application performance monitoring on your Azure Web App. (This is not the same as installing the infrastructure monitoring integrations for Microsoft Azure.) Recommendation: Before following these instructions, read the .NET agent installation overview. Installation options Tip To use .NET or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Use any of the following methods to add the New Relic .NET agent to your Azure-deployed web app. The best option depends on your role, environment, deployments, etc. For example: For operations teams that need to monitor the app, best practice may be to: Install using the Azure Site Extension For developer teams, best practice may be to use NuGet: Install using NuGet (.NET Framework) Install using NuGet (.NET Core) In order to monitor non-web apps (including WebJobs), or ASP.NET Core apps targeting .NET Framework, you must explicitly enable the agent for that application's .exe process via one of these two methods: Enable via placement of local newrelic.config file. Enable via application config file In addition, WebJobs may need custom instrumentation for transactions to appear in APM, and additional configuration if they run for less than one minute. Disable Application Insights Both New Relic's .NET agent and Microsoft Application Insights rely on the CLR Profiler, but only one may be active at a time. You must disable Application Insights in order for the .NET agent to function properly. For more information, see our Application Insights troubleshooting procedures. Install using the New Relic Azure Site Extension To install the .NET agent for an Azure Web App using the New Relic Azure Site Extension: Shut down your web application before installing the New Relic Azure Site Extension. Add the site extension: Navigate to http://[yoursitename].scm.azurewebsites.net, then select Site extensions > Gallery. Select the plus icon next to the New Relic site extension. In the Azure portal, add New Relic app settings to your Azure App Service. Restart your web app to use the new version of the agent. Install using NuGet (.NET Framework) The NuGet packages in this procedure support only the old packages.config. They do not support the current PackageReference format. For more information, see Microsoft's package reference documentation. For multi-project solutions, make sure you have selected the correct project (for example, a specific web app project) before installing the NuGet package. If you are upgrading the .NET Framework agent using NuGet, any changes you made in the newrelic.config will be overwritten. To preserve any changes, save your newrelic.config outside of your project, then restore it after upgrading. To install the .NET agent on an Azure Web App using NuGet: In the Azure portal, verify your Azure Platform (32-bit or 64-bit): From the Azure sidebar menu, select App Services > Your Application > Settings > Configuration > General settings. Open your application in Visual Studio, and install the New Relic NuGet package by running the appropriate command from the Package manager console: 32-bit: Install-Package NewRelic.Azure.WebSites 64-bit: Install-Package NewRelic.Azure.WebSites.x64 Publish your application. In the Azure portal, open the web app you want to monitor, then select Settings > Configuration. From Configuration, select + New application setting and add these key/value pairs: Key Value COR_ENABLE_PROFILING 1 COR_PROFILER {71DA0A04-7777-4EC6-9643-7D28B46A8A41} COR_PROFILER_PATH D:\\Home\\site\\wwwroot\\newrelic\\NewRelic.Profiler.dll NEWRELIC_HOME D:\\Home\\site\\wwwroot\\newrelic In the Azure portal, add New Relic app settings to your Azure App Service. Restart your web app. Install using NuGet (.NET Core) New Relic .NET Core agent supports Linux and Windows applications on Azure App Services. The installation process for Azure App Services differs from the .NET Core agent installation procedures for Linux and Windows. To install the .NET agent on an Azure Web App using NuGet: Install the NewRelic.Agent NuGet package. Modify the log node by adding a directory attribute to your newrelic.config file: Log file configuration for Windows log directory=\"D:\\Home\\LogFiles\\NewRelic\" level=\"info\"/log Copy Log file configuration for Linux log directory=\"/home/LogFiles/NewRelic\" level=\"info\"/log Copy Publish your application. In the Azure portal, open the web app you want to monitor, then select Settings > Configuration. From Configuration, select + New application setting and add these key/value pairs: Environment variables for Windows Key Value CORECLR_ENABLE_PROFILING 1 CORECLR_PROFILER {36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_PROFILER_PATH_32 D:\\Home\\site\\wwwroot\\newrelic\\x86\\NewRelic.Profiler.dll CORECLR_PROFILER_PATH_64 D:\\Home\\site\\wwwroot\\newrelic\\NewRelic.Profiler.dll CORECLR_NEWRELIC_HOME D:\\Home\\site\\wwwroot\\newrelic Environment variables for Linux Key Value CORECLR_ENABLE_PROFILING 1 CORECLR_PROFILER {36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_PROFILER_PATH /home/site/wwwroot/newrelic/libNewRelicProfiler.so CORECLR_NEWRELIC_HOME /home/site/wwwroot/newrelic In the Azure portal, add New Relic app settings to your Azure App Service. Restart your web app. Add New Relic app settings to Azure App Services To add your app settings: Make sure you have your license key before adding the New Relic .NET agent's app settings. In the Azure portal, open the web app you want to monitor, then select Configuration > Application settings. From Application settings, select + New application setting and add these key/value pairs: Key Value NEW_RELIC_LICENSE_KEY YOUR_LICENSE_KEY NEW_RELIC_APP_NAME YOUR_APP_NAME Save and restart your web app. Setting the license key and app name with Application settings will override the newrelic.config. To verify your app's environment variables in your app's Kudu diagnostic console, go to Environment > Environment variables. For example: https://myappname.scm.azurewebsites.net/Env.cshtml#envVariables Copy View your app's performance Your application must receive traffic in order for you to view its performance in New Relic. You may need to wait a few minutes for data to start appearing. If no data appears, see the troubleshooting procedures for Azure Web Apps. To view your app's performance in New Relic: Go to one.newrelic.com > APM > (select an app). The APM Summary page automatically appears. You can also view detailed information about errors, database and instance performance issues, and more. If you created your New Relic app prior to October 2017, you can use the Azure portal to select the New Relic account blade. You will be automatically logged in with SAML Single Sign-on (SSO) to APM. You can also view your application's error rate and throughput data in the Azure portal by going to New Relic Accounts > (select your app). Troubleshooting If no data appears after installing the agent, generating traffic for your app, and waiting a few minutes, try these troubleshooting tips: Make sure that all files in the newrelic directory at the root of your app got published to Azure. Make sure the environment variables are set correctly. Make sure Microsoft Application Insights is not installed and configured on the application. For more information, see the Application Insights troubleshooting procedures. Refer to additional Azure troubleshooting procedures as applicable.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.17722,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Web Apps",
        "sections": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Web Apps",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": ". Restart your web app. Install using NuGet (.<em>NET</em> Core) New Relic .<em>NET</em> Core <em>agent</em> supports Linux and Windows applications on <em>Azure</em> App Services. The <em>installation</em> process for <em>Azure</em> App Services differs from the .<em>NET</em> Core <em>agent</em> <em>installation</em> procedures for Linux and Windows. To install the .<em>NET</em> <em>agent</em>"
      },
      "id": "603e8e7c28ccbc420ceba748"
    },
    {
      "sections": [
        "Install .NET agent on Azure Service Fabric",
        "Important",
        "Install using NuGet",
        ".NET Framework",
        ".NET Core for Windows",
        ".NET Core for Linux"
      ],
      "title": "Install .NET agent on Azure Service Fabric",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "c520de26567fd173a0ac7b19ac0044a5757862bb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-installation/install-net-agent-azure-service-fabric/",
      "published_at": "2021-06-02T17:51:59Z",
      "updated_at": "2021-03-13T02:21:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install APM's .NET Framework agent and .NET Core agent on Azure Service Fabric. This is not the same as installing the Infrastructure integrations for Microsoft Azure. Install .NET agent on Azure Service Fabric Important In most cases, installing the .NET agent in an Azure Service Fabric environment can be performed using the standard install procedures for either Windows or Linux. This document highlights some alternate ways you can install the agent. You will need to ensure the agent gets installed on all nodes in your cluster. To monitor multiple nodes, you may want to integrate the install into your deployment process. If you are using containers in your Service Fabric environment you should read Install for Docker. You can also install the agent in a Service Fabric environment using NuGet. NuGet is often a good option for developers because the agent gets deployed along with your application. Though, using NuGet requires some manual installation procedures. See Install with NuGet. Install using NuGet To install the .NET agent using NuGet: Follow the standard NuGet install procedures. When using NuGet, you must set some environment variables. This can be done in your application's ServiceManifest.xml file. See the relevant instructions below: .NET Framework In the ServiceManifest.xml file in your project, include the following under the CodePackage node: <CodePackage Name=\"Code\" Version=\"1.0.0\"> </CodePackage> <CodePackage> ... <EntryPoint> <ExeHost> ... <!-- It is important for the WorkingFolder to be set to CodePackage --> <!-- This is because the environment variables set below rely on this being the working folder for the agent to work --> <WorkingFolder>CodePackage</WorkingFolder> ... </ExeHost> </EntryPoint> ... <EnvironmentVariables> ... <EnvironmentVariable Name=\"COR_ENABLE_PROFILING\" Value=\"1\" /> <EnvironmentVariable Name=\"COR_PROFILER\" Value=\"{71DA0A04-7777-4EC6-9643-7D28B46A8A41}\" /> <EnvironmentVariable Name=\"COR_PROFILER_PATH\" Value=\".\\newrelic\\NewRelic.Profiler.dll\" /> <EnvironmentVariable Name=\"NEWRELIC_HOME\" Value=\".\\newrelic\" /> <EnvironmentVariable Name=\"NEW_RELIC_LICENSE_KEY\" Value=\"YOUR_LICENSE_KEY\" /> <EnvironmentVariable Name=\"NEW_RELIC_APP_NAME\" Value=\"YOUR_APP_NAME\" /> ... </EnvironmentVariables> ... </CodePackage> Copy .NET Core for Windows In the ServiceManifest.xml file in your project, include the following under the CodePackage node: <CodePackage> ... <EntryPoint> <ExeHost> ... <!-- It is important for the WorkingFolder to be set to CodePackage --> <!-- This is because the environment variables set below rely on this being the working folder for the agent to work --> <WorkingFolder>CodePackage</WorkingFolder> ... </ExeHost> </EntryPoint> ... <EnvironmentVariables> ... <EnvironmentVariable Name=\"CORECLR_ENABLE_PROFILING\" Value=\"1\" /> <EnvironmentVariable Name=\"CORECLR_PROFILER\" Value=\"{36032161-FFC0-4B61-B559-F6C5D41BAE5A}\" /> <EnvironmentVariable Name=\"CORECLR_PROFILER_PATH\" Value=\".\\newrelic\\NewRelic.Profiler.dll\" /> <EnvironmentVariable Name=\"CORECLR_NEWRELIC_HOME\" Value=\".\\newrelic\" /> <EnvironmentVariable Name=\"NEW_RELIC_LICENSE_KEY\" Value=\"YOUR_LICENSE_KEY\" /> <EnvironmentVariable Name=\"NEW_RELIC_APP_NAME\" Value=\"YOUR_APP_NAME\" /> ... </EnvironmentVariables> ... </CodePackage> Copy .NET Core for Linux In the ServiceManifest.xml file in your project, include the following under the CodePackage node: <CodePackage> ... <EntryPoint> <ExeHost> ... <!-- It is important for the WorkingFolder to be set to CodePackage --> <!-- This is because the environment variables set below rely on this being the working folder for the agent to work --> <WorkingFolder>CodePackage</WorkingFolder> ... </ExeHost> </EntryPoint> ... <EnvironmentVariables> ... <EnvironmentVariable Name=\"CORECLR_ENABLE_PROFILING\" Value=\"1\" /> <EnvironmentVariable Name=\"CORECLR_PROFILER\" Value=\"{36032161-FFC0-4B61-B559-F6C5D41BAE5A}\" /> <EnvironmentVariable Name=\"CORECLR_PROFILER_PATH\" Value=\"./newrelic/libNewRelicProfiler.so\" /> <EnvironmentVariable Name=\"CORECLR_NEWRELIC_HOME\" Value=\"./newrelic\" /> <EnvironmentVariable Name=\"NEW_RELIC_LICENSE_KEY\" Value=\"YOUR_LICENSE_KEY\" /> <EnvironmentVariable Name=\"NEW_RELIC_APP_NAME\" Value=\"YOUR_APP_NAME\" /> ... </EnvironmentVariables> ... </CodePackage> Copy For the .NET Framework only: Edit your app.config file and add the NewRelic.AgentEnabled app setting: <appSettings> ... <add key=\"NewRelic.AgentEnabled\" value=\"true\" /> ... </appSettings> Copy If your application is generating traffic, data should appear in your APM account in several minutes. If data does not appear, try these troubleshooting steps: Make sure that all files in the newrelic directory at the root of your app was published to Azure. Make sure the environment variables are set correctly. See the general troubleshooting documentation to check for common errors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.435974,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .<em>NET</em> <em>agent</em> on <em>Azure</em> Service Fabric",
        "sections": "<em>Install</em> .<em>NET</em> <em>agent</em> on <em>Azure</em> Service Fabric",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": "This document explains how to install APM&#x27;s .<em>NET</em> Framework <em>agent</em> and .<em>NET</em> Core <em>agent</em> on <em>Azure</em> Service Fabric. This is not the same as installing the Infrastructure integrations for Microsoft <em>Azure</em>. Install .<em>NET</em> <em>agent</em> on <em>Azure</em> Service Fabric Important In most cases, installing the .<em>NET</em> <em>agent</em>"
      },
      "id": "6043c8a6e7b9d24fa25799bc"
    }
  ],
  "/docs/agents/net-agent/azure-installation/install-net-agent-azure-service-fabric": [
    {
      "sections": [
        "Install Azure Marketplace app with New Relic",
        "End of life notice",
        "Install New Relic .NET agent"
      ],
      "title": "Install Azure Marketplace app with New Relic",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "aef2e193486dd4993ae483d01735a03537b138b2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-installation/install-azure-marketplace-app-new-relic/",
      "published_at": "2021-06-02T20:23:49Z",
      "updated_at": "2021-03-13T02:42:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "End of life notice As of October 2017 you cannot create a New Relic account through Microsoft's Azure Marketplace Portal. Instead, if you have an Azure ID but do not already have a New Relic account, contact New Relic Sales. For more information, see the Azure transition information in New Relic's Online Technical Community. Install New Relic .NET agent Continue with the procedures to install the New Relic .NET agent with your Azure app as applicable for: Microsoft's Web App Services in the Azure Portal Microsoft's Cloud Services platform The .NET agent's support for Microsoft Azure is not the same as Infrastructure monitoring's integrations with Azure. Azure integrations have separate integration installation procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.13605,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>Azure</em> Marketplace app with New Relic",
        "sections": "<em>Install</em> New Relic .<em>NET</em> <em>agent</em>",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": "&#x27;s Online Technical Community. Install New Relic .<em>NET</em> <em>agent</em> Continue with the procedures to install the New Relic .<em>NET</em> <em>agent</em> with your <em>Azure</em> app as applicable for: Microsoft&#x27;s Web App Services in the <em>Azure</em> Portal Microsoft&#x27;s Cloud Services platform The .<em>NET</em> <em>agent</em>&#x27;s support for Microsoft <em>Azure</em> is not the same as Infrastructure monitoring&#x27;s integrations with <em>Azure</em>. <em>Azure</em> integrations have separate integration <em>installation</em> procedures."
      },
      "id": "6043c3ade7b9d24ead5799b2"
    },
    {
      "sections": [
        "Install the .NET agent on Azure Cloud Services",
        "Important",
        "Check Web or Worker role's location",
        "Install the NuGet package for Cloud Services",
        "Instrument Worker role",
        "Custom instrumentation example for Worker role",
        "Custom instrumentation file deployment",
        "Optional: Create custom config file",
        "View your app's performance"
      ],
      "title": "Install the .NET agent on Azure Cloud Services",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "afe3e181b9ec18fa0b2be3e76f7c9b20d247d21e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-installation/install-net-agent-azure-cloud-services/",
      "published_at": "2021-06-02T20:23:51Z",
      "updated_at": "2021-03-16T14:55:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install APM's .NET agent on Microsoft's Azure Cloud Services platform. This is not the same as installing the Infrastructure integrations for Microsoft Azure. To make sure you are using the most relevant instructions, first see the .NET agent install overview. Important Before installing the NuGet package into a multi-project Visual Studio solution, make sure you have selected the correct project for your New Relic .NET application (for example, a specific website project). Check Web or Worker role's location If Service files are nested within a Solution folder, the NuGet installer cannot locate or update the necessary files. This will cause issues with the .NET agent setup, which will in turn prevent the agent from reporting metrics on your Cloud Service. Recommendation: Place the Web or Worker role at the root of the solution before installing the NuGet package. Once the New Relic .NET agent is installed, you can move the Cloud role back into the Solution folder. Install the NuGet package for Cloud Services Important The NuGet packages in this procedure support only the old packages.config. They do not support the new PackageReference format. For more information see Microsoft's package reference documentation For multi-project solutions, make sure you have selected the correct project (for example, a specific website project) before installing the NuGet package. Open your Visual Studio solution, or create a new one by selecting File > New > Project. For multi-project solutions, make sure you have selected the correct project (for example, a specific website project). If you do not already have an Azure Cloud Service project in your solution, add one by right-clicking your app in the Solution Explorer and selecting Add Windows Azure Cloud Service Project. Open the Package Manager console by selecting Tools > Library Package Manager > Package Manager Console. Set your project as the default project. From the Package Manager command prompt, type Install-Package NewRelicWindowsAzure and press Enter. Follow the prompts to enter your New Relic license key and your application name as you want it to appear in the New Relic UI. Or, use your solution name as the default app name. From the Solution Explorer, right-click your Azure Cloud Service project, and select Publish. If this is your first time deploying this app to Azure, enter your Azure credentials. If applicable, instrument methods for Worker roles. Instrument Worker role A Worker role is a non-web process run as an Azure Cloud Service. To instrument a Worker role, you must create custom transactions. The .NET agent automatically instruments external calls and database calls, but it does not instrument default methods for transactions. Creating custom transactions solves this. After the Worker role starts up and the method executes, transaction data will appear in the APM Summary and Transactions pages under the Non-web category. The NuGet installer automatically adds the NewRelic.AppName parameter to the application config. This appears as <YOUR_WORKER_ROLE_NAME>.dll.config in E:\\approot. The .NET agent also automatically instruments WaWorkerHost.exe. This is the name of the actual Worker role process. Custom instrumentation example for Worker role This is a custom instrumentation example for a Worker role. It creates a custom transaction named ProcessMessage. The transaction begins when the ProcessMessage method is entered, and it ends when the method returns. The following example uses MyWorkerRole as the namespace. If you do not specify a name, it will default to the Solution name. namespace MyWorkerRole { public class NotificationQueue { public bool ProcessMessage(Message message) { // code to process message } } } Copy Here is the custom instrumentation file for the code: <?xml version=\"1.0\" encoding=\"utf-8\"?> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerfactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Custom/ProcessMessage\"> <match assemblyname=\"MyWorkerRole\" classname=\"MyWorkerRole.NotificationQueue\"> <exactmethodmatcher methodName=\"ProcessMessage\" /> </match> </tracerfactory> </instrumentation> </extension> Copy On a local installation, place this instrumentation file in C:\\ProgramData\\New Relic\\.NET Agent\\Extensions. Custom instrumentation file deployment Optional: To send the custom instrumentation file up with an Azure Cloud Service deployment: In your Azure Cloud project, add the instrumentation file to your Worker role inside the Roles folder. After installing the New Relic .NET agent NuGet package, locate newrelic.cmd in your Worker Role project. Find the statement IF %ERRORLEVEL% EQU 0 within the :INSTALL_NEWRELIC_AGENT block, and add the following statement to the conditional: IF %ERRORLEVEL% EQU 0 ( copy /Y \"%RoleRoot%\\approot\\MyInstrumentation.xml\" \"%NR_HOME%\\extensions\" >> %RoleRoot%\\nr.log ) ELSE ( Copy In this example, the newrelic.cmd batch file copies the custom instrumentation file to the Extensions folder in D:\\ProgramData\\New Relic\\.NET Agent\\, or %NR_HOME%. This example uses MyInstrumentation.xml, but any name will work as long as the file name and copy command match, and the file is valid XML. Optional: Create custom config file You can create a custom configuration file in Visual Studio. This allows you to make changes to newrelic.config inside Visual Studio, without having to remote into your Azure Role instance every time you make a change. Whenever you publish your app, the config file in Visual Studio is automatically uploaded to the remote host. The choices you make with the installation wizard do not matter. Installing locally does not affect your Azure development environment. In Visual Studio, select the Solution Explorer, then open NewRelicAgent_x64_XYZ.msi. Follow the steps to install the agent locally. Import newrelic.config into your project: In Solution Explorer > Cloud Project, right-click the Web Role, then select Add > Existing Item. Navigate to C: \\ ProgramData \\ New Relic \\ .NET Agent and select newrelic.config. From C: \\ ProgramData \\ New Relic \\ .NET Agent, edit newrelic.cmd. In the :INSTALL_NEWRELIC_AGENT section, find this statement: IF $ERRORLEVEL% EQU 0 ( Copy Add the following code as another statement inside the IF block, then save the file: copy /Y \"%RoleRoot%\\approot\\newrelic.config\" \"%NR_HOME%\" >> %RoleRoot%\\nr.log Copy You can now edit the newrelic.config hosted in Visual Studio. Whenever you publish your app, the copy command will upload the config file to the remote host. View your app's performance Your application must receive traffic in order for you to view its performance in New Relic. You may need to wait a few minutes for data to start appearing. If no data appears, see the troubleshooting procedures for Azure Cloud Services. To view your app's performance in APM: Go to one.newrelic.com > APM > (select an app). The APM Summary page automatically appears. You can also view detailed information about errors, database and instance performance issues, and more. If you created your New Relic app prior to October 2017, you can use the Azure Portal to select the New Relic account blade. You will be automatically logged in with SAML Single Sign-on (SSO) to APM. You can also view your application's error rate and throughput data in the Azure Portal by going to New Relic Accounts > choose your application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.49437,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Cloud Services",
        "sections": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Cloud Services",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": "&gt; &lt;&#x2F;tracerfactory&gt; &lt;&#x2F;instrumentation&gt; &lt;&#x2F;extension&gt; Copy On a local <em>installation</em>, place this instrumentation file in C:\\ProgramData\\New Relic\\.<em>NET</em> <em>Agent</em>\\Extensions. Custom instrumentation file deployment Optional: To send the custom instrumentation file up with an <em>Azure</em> Cloud Service deployment: In your"
      },
      "id": "603e8e7ee7b9d2b4d42a07e3"
    },
    {
      "sections": [
        "Install the .NET agent on Azure Web Apps",
        "Installation options",
        "Tip",
        "Disable Application Insights",
        "Install using the New Relic Azure Site Extension",
        "Install using NuGet (.NET Framework)",
        "Install using NuGet (.NET Core)",
        "Log file configuration for Windows",
        "Log file configuration for Linux",
        "Environment variables for Windows",
        "Environment variables for Linux",
        "Add New Relic app settings to Azure App Services",
        "View your app's performance",
        "Troubleshooting"
      ],
      "title": "Install the .NET agent on Azure Web Apps",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "5cb6afb3ad05fdc243d2cf110f4df1e7e027740d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-installation/install-net-agent-azure-web-apps/",
      "published_at": "2021-06-02T14:45:45Z",
      "updated_at": "2021-03-16T14:55:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install New Relic's .NET agent for application performance monitoring on your Azure Web App. (This is not the same as installing the infrastructure monitoring integrations for Microsoft Azure.) Recommendation: Before following these instructions, read the .NET agent installation overview. Installation options Tip To use .NET or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Use any of the following methods to add the New Relic .NET agent to your Azure-deployed web app. The best option depends on your role, environment, deployments, etc. For example: For operations teams that need to monitor the app, best practice may be to: Install using the Azure Site Extension For developer teams, best practice may be to use NuGet: Install using NuGet (.NET Framework) Install using NuGet (.NET Core) In order to monitor non-web apps (including WebJobs), or ASP.NET Core apps targeting .NET Framework, you must explicitly enable the agent for that application's .exe process via one of these two methods: Enable via placement of local newrelic.config file. Enable via application config file In addition, WebJobs may need custom instrumentation for transactions to appear in APM, and additional configuration if they run for less than one minute. Disable Application Insights Both New Relic's .NET agent and Microsoft Application Insights rely on the CLR Profiler, but only one may be active at a time. You must disable Application Insights in order for the .NET agent to function properly. For more information, see our Application Insights troubleshooting procedures. Install using the New Relic Azure Site Extension To install the .NET agent for an Azure Web App using the New Relic Azure Site Extension: Shut down your web application before installing the New Relic Azure Site Extension. Add the site extension: Navigate to http://[yoursitename].scm.azurewebsites.net, then select Site extensions > Gallery. Select the plus icon next to the New Relic site extension. In the Azure portal, add New Relic app settings to your Azure App Service. Restart your web app to use the new version of the agent. Install using NuGet (.NET Framework) The NuGet packages in this procedure support only the old packages.config. They do not support the current PackageReference format. For more information, see Microsoft's package reference documentation. For multi-project solutions, make sure you have selected the correct project (for example, a specific web app project) before installing the NuGet package. If you are upgrading the .NET Framework agent using NuGet, any changes you made in the newrelic.config will be overwritten. To preserve any changes, save your newrelic.config outside of your project, then restore it after upgrading. To install the .NET agent on an Azure Web App using NuGet: In the Azure portal, verify your Azure Platform (32-bit or 64-bit): From the Azure sidebar menu, select App Services > Your Application > Settings > Configuration > General settings. Open your application in Visual Studio, and install the New Relic NuGet package by running the appropriate command from the Package manager console: 32-bit: Install-Package NewRelic.Azure.WebSites 64-bit: Install-Package NewRelic.Azure.WebSites.x64 Publish your application. In the Azure portal, open the web app you want to monitor, then select Settings > Configuration. From Configuration, select + New application setting and add these key/value pairs: Key Value COR_ENABLE_PROFILING 1 COR_PROFILER {71DA0A04-7777-4EC6-9643-7D28B46A8A41} COR_PROFILER_PATH D:\\Home\\site\\wwwroot\\newrelic\\NewRelic.Profiler.dll NEWRELIC_HOME D:\\Home\\site\\wwwroot\\newrelic In the Azure portal, add New Relic app settings to your Azure App Service. Restart your web app. Install using NuGet (.NET Core) New Relic .NET Core agent supports Linux and Windows applications on Azure App Services. The installation process for Azure App Services differs from the .NET Core agent installation procedures for Linux and Windows. To install the .NET agent on an Azure Web App using NuGet: Install the NewRelic.Agent NuGet package. Modify the log node by adding a directory attribute to your newrelic.config file: Log file configuration for Windows log directory=\"D:\\Home\\LogFiles\\NewRelic\" level=\"info\"/log Copy Log file configuration for Linux log directory=\"/home/LogFiles/NewRelic\" level=\"info\"/log Copy Publish your application. In the Azure portal, open the web app you want to monitor, then select Settings > Configuration. From Configuration, select + New application setting and add these key/value pairs: Environment variables for Windows Key Value CORECLR_ENABLE_PROFILING 1 CORECLR_PROFILER {36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_PROFILER_PATH_32 D:\\Home\\site\\wwwroot\\newrelic\\x86\\NewRelic.Profiler.dll CORECLR_PROFILER_PATH_64 D:\\Home\\site\\wwwroot\\newrelic\\NewRelic.Profiler.dll CORECLR_NEWRELIC_HOME D:\\Home\\site\\wwwroot\\newrelic Environment variables for Linux Key Value CORECLR_ENABLE_PROFILING 1 CORECLR_PROFILER {36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_PROFILER_PATH /home/site/wwwroot/newrelic/libNewRelicProfiler.so CORECLR_NEWRELIC_HOME /home/site/wwwroot/newrelic In the Azure portal, add New Relic app settings to your Azure App Service. Restart your web app. Add New Relic app settings to Azure App Services To add your app settings: Make sure you have your license key before adding the New Relic .NET agent's app settings. In the Azure portal, open the web app you want to monitor, then select Configuration > Application settings. From Application settings, select + New application setting and add these key/value pairs: Key Value NEW_RELIC_LICENSE_KEY YOUR_LICENSE_KEY NEW_RELIC_APP_NAME YOUR_APP_NAME Save and restart your web app. Setting the license key and app name with Application settings will override the newrelic.config. To verify your app's environment variables in your app's Kudu diagnostic console, go to Environment > Environment variables. For example: https://myappname.scm.azurewebsites.net/Env.cshtml#envVariables Copy View your app's performance Your application must receive traffic in order for you to view its performance in New Relic. You may need to wait a few minutes for data to start appearing. If no data appears, see the troubleshooting procedures for Azure Web Apps. To view your app's performance in New Relic: Go to one.newrelic.com > APM > (select an app). The APM Summary page automatically appears. You can also view detailed information about errors, database and instance performance issues, and more. If you created your New Relic app prior to October 2017, you can use the Azure portal to select the New Relic account blade. You will be automatically logged in with SAML Single Sign-on (SSO) to APM. You can also view your application's error rate and throughput data in the Azure portal by going to New Relic Accounts > (select your app). Troubleshooting If no data appears after installing the agent, generating traffic for your app, and waiting a few minutes, try these troubleshooting tips: Make sure that all files in the newrelic directory at the root of your app got published to Azure. Make sure the environment variables are set correctly. Make sure Microsoft Application Insights is not installed and configured on the application. For more information, see the Application Insights troubleshooting procedures. Refer to additional Azure troubleshooting procedures as applicable.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.177216,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Web Apps",
        "sections": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Web Apps",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": ". Restart your web app. Install using NuGet (.<em>NET</em> Core) New Relic .<em>NET</em> Core <em>agent</em> supports Linux and Windows applications on <em>Azure</em> App Services. The <em>installation</em> process for <em>Azure</em> App Services differs from the .<em>NET</em> Core <em>agent</em> <em>installation</em> procedures for Linux and Windows. To install the .<em>NET</em> <em>agent</em>"
      },
      "id": "603e8e7c28ccbc420ceba748"
    }
  ],
  "/docs/agents/net-agent/azure-installation/install-net-agent-azure-web-apps": [
    {
      "sections": [
        "Install Azure Marketplace app with New Relic",
        "End of life notice",
        "Install New Relic .NET agent"
      ],
      "title": "Install Azure Marketplace app with New Relic",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "aef2e193486dd4993ae483d01735a03537b138b2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-installation/install-azure-marketplace-app-new-relic/",
      "published_at": "2021-06-02T20:23:49Z",
      "updated_at": "2021-03-13T02:42:53Z",
      "document_type": "page",
      "popularity": 1,
      "body": "End of life notice As of October 2017 you cannot create a New Relic account through Microsoft's Azure Marketplace Portal. Instead, if you have an Azure ID but do not already have a New Relic account, contact New Relic Sales. For more information, see the Azure transition information in New Relic's Online Technical Community. Install New Relic .NET agent Continue with the procedures to install the New Relic .NET agent with your Azure app as applicable for: Microsoft's Web App Services in the Azure Portal Microsoft's Cloud Services platform The .NET agent's support for Microsoft Azure is not the same as Infrastructure monitoring's integrations with Azure. Azure integrations have separate integration installation procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 111.13605,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> <em>Azure</em> Marketplace app with New Relic",
        "sections": "<em>Install</em> New Relic .<em>NET</em> <em>agent</em>",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": "&#x27;s Online Technical Community. Install New Relic .<em>NET</em> <em>agent</em> Continue with the procedures to install the New Relic .<em>NET</em> <em>agent</em> with your <em>Azure</em> app as applicable for: Microsoft&#x27;s Web App Services in the <em>Azure</em> Portal Microsoft&#x27;s Cloud Services platform The .<em>NET</em> <em>agent</em>&#x27;s support for Microsoft <em>Azure</em> is not the same as Infrastructure monitoring&#x27;s integrations with <em>Azure</em>. <em>Azure</em> integrations have separate integration <em>installation</em> procedures."
      },
      "id": "6043c3ade7b9d24ead5799b2"
    },
    {
      "sections": [
        "Install the .NET agent on Azure Cloud Services",
        "Important",
        "Check Web or Worker role's location",
        "Install the NuGet package for Cloud Services",
        "Instrument Worker role",
        "Custom instrumentation example for Worker role",
        "Custom instrumentation file deployment",
        "Optional: Create custom config file",
        "View your app's performance"
      ],
      "title": "Install the .NET agent on Azure Cloud Services",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "afe3e181b9ec18fa0b2be3e76f7c9b20d247d21e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-installation/install-net-agent-azure-cloud-services/",
      "published_at": "2021-06-02T20:23:51Z",
      "updated_at": "2021-03-16T14:55:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install APM's .NET agent on Microsoft's Azure Cloud Services platform. This is not the same as installing the Infrastructure integrations for Microsoft Azure. To make sure you are using the most relevant instructions, first see the .NET agent install overview. Important Before installing the NuGet package into a multi-project Visual Studio solution, make sure you have selected the correct project for your New Relic .NET application (for example, a specific website project). Check Web or Worker role's location If Service files are nested within a Solution folder, the NuGet installer cannot locate or update the necessary files. This will cause issues with the .NET agent setup, which will in turn prevent the agent from reporting metrics on your Cloud Service. Recommendation: Place the Web or Worker role at the root of the solution before installing the NuGet package. Once the New Relic .NET agent is installed, you can move the Cloud role back into the Solution folder. Install the NuGet package for Cloud Services Important The NuGet packages in this procedure support only the old packages.config. They do not support the new PackageReference format. For more information see Microsoft's package reference documentation For multi-project solutions, make sure you have selected the correct project (for example, a specific website project) before installing the NuGet package. Open your Visual Studio solution, or create a new one by selecting File > New > Project. For multi-project solutions, make sure you have selected the correct project (for example, a specific website project). If you do not already have an Azure Cloud Service project in your solution, add one by right-clicking your app in the Solution Explorer and selecting Add Windows Azure Cloud Service Project. Open the Package Manager console by selecting Tools > Library Package Manager > Package Manager Console. Set your project as the default project. From the Package Manager command prompt, type Install-Package NewRelicWindowsAzure and press Enter. Follow the prompts to enter your New Relic license key and your application name as you want it to appear in the New Relic UI. Or, use your solution name as the default app name. From the Solution Explorer, right-click your Azure Cloud Service project, and select Publish. If this is your first time deploying this app to Azure, enter your Azure credentials. If applicable, instrument methods for Worker roles. Instrument Worker role A Worker role is a non-web process run as an Azure Cloud Service. To instrument a Worker role, you must create custom transactions. The .NET agent automatically instruments external calls and database calls, but it does not instrument default methods for transactions. Creating custom transactions solves this. After the Worker role starts up and the method executes, transaction data will appear in the APM Summary and Transactions pages under the Non-web category. The NuGet installer automatically adds the NewRelic.AppName parameter to the application config. This appears as <YOUR_WORKER_ROLE_NAME>.dll.config in E:\\approot. The .NET agent also automatically instruments WaWorkerHost.exe. This is the name of the actual Worker role process. Custom instrumentation example for Worker role This is a custom instrumentation example for a Worker role. It creates a custom transaction named ProcessMessage. The transaction begins when the ProcessMessage method is entered, and it ends when the method returns. The following example uses MyWorkerRole as the namespace. If you do not specify a name, it will default to the Solution name. namespace MyWorkerRole { public class NotificationQueue { public bool ProcessMessage(Message message) { // code to process message } } } Copy Here is the custom instrumentation file for the code: <?xml version=\"1.0\" encoding=\"utf-8\"?> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerfactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Custom/ProcessMessage\"> <match assemblyname=\"MyWorkerRole\" classname=\"MyWorkerRole.NotificationQueue\"> <exactmethodmatcher methodName=\"ProcessMessage\" /> </match> </tracerfactory> </instrumentation> </extension> Copy On a local installation, place this instrumentation file in C:\\ProgramData\\New Relic\\.NET Agent\\Extensions. Custom instrumentation file deployment Optional: To send the custom instrumentation file up with an Azure Cloud Service deployment: In your Azure Cloud project, add the instrumentation file to your Worker role inside the Roles folder. After installing the New Relic .NET agent NuGet package, locate newrelic.cmd in your Worker Role project. Find the statement IF %ERRORLEVEL% EQU 0 within the :INSTALL_NEWRELIC_AGENT block, and add the following statement to the conditional: IF %ERRORLEVEL% EQU 0 ( copy /Y \"%RoleRoot%\\approot\\MyInstrumentation.xml\" \"%NR_HOME%\\extensions\" >> %RoleRoot%\\nr.log ) ELSE ( Copy In this example, the newrelic.cmd batch file copies the custom instrumentation file to the Extensions folder in D:\\ProgramData\\New Relic\\.NET Agent\\, or %NR_HOME%. This example uses MyInstrumentation.xml, but any name will work as long as the file name and copy command match, and the file is valid XML. Optional: Create custom config file You can create a custom configuration file in Visual Studio. This allows you to make changes to newrelic.config inside Visual Studio, without having to remote into your Azure Role instance every time you make a change. Whenever you publish your app, the config file in Visual Studio is automatically uploaded to the remote host. The choices you make with the installation wizard do not matter. Installing locally does not affect your Azure development environment. In Visual Studio, select the Solution Explorer, then open NewRelicAgent_x64_XYZ.msi. Follow the steps to install the agent locally. Import newrelic.config into your project: In Solution Explorer > Cloud Project, right-click the Web Role, then select Add > Existing Item. Navigate to C: \\ ProgramData \\ New Relic \\ .NET Agent and select newrelic.config. From C: \\ ProgramData \\ New Relic \\ .NET Agent, edit newrelic.cmd. In the :INSTALL_NEWRELIC_AGENT section, find this statement: IF $ERRORLEVEL% EQU 0 ( Copy Add the following code as another statement inside the IF block, then save the file: copy /Y \"%RoleRoot%\\approot\\newrelic.config\" \"%NR_HOME%\" >> %RoleRoot%\\nr.log Copy You can now edit the newrelic.config hosted in Visual Studio. Whenever you publish your app, the copy command will upload the config file to the remote host. View your app's performance Your application must receive traffic in order for you to view its performance in New Relic. You may need to wait a few minutes for data to start appearing. If no data appears, see the troubleshooting procedures for Azure Cloud Services. To view your app's performance in APM: Go to one.newrelic.com > APM > (select an app). The APM Summary page automatically appears. You can also view detailed information about errors, database and instance performance issues, and more. If you created your New Relic app prior to October 2017, you can use the Azure Portal to select the New Relic account blade. You will be automatically logged in with SAML Single Sign-on (SSO) to APM. You can also view your application's error rate and throughput data in the Azure Portal by going to New Relic Accounts > choose your application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.49437,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Cloud Services",
        "sections": "<em>Install</em> the .<em>NET</em> <em>agent</em> on <em>Azure</em> Cloud Services",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": "&gt; &lt;&#x2F;tracerfactory&gt; &lt;&#x2F;instrumentation&gt; &lt;&#x2F;extension&gt; Copy On a local <em>installation</em>, place this instrumentation file in C:\\ProgramData\\New Relic\\.<em>NET</em> <em>Agent</em>\\Extensions. Custom instrumentation file deployment Optional: To send the custom instrumentation file up with an <em>Azure</em> Cloud Service deployment: In your"
      },
      "id": "603e8e7ee7b9d2b4d42a07e3"
    },
    {
      "sections": [
        "Install .NET agent on Azure Service Fabric",
        "Important",
        "Install using NuGet",
        ".NET Framework",
        ".NET Core for Windows",
        ".NET Core for Linux"
      ],
      "title": "Install .NET agent on Azure Service Fabric",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure installation"
      ],
      "external_id": "c520de26567fd173a0ac7b19ac0044a5757862bb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-installation/install-net-agent-azure-service-fabric/",
      "published_at": "2021-06-02T17:51:59Z",
      "updated_at": "2021-03-13T02:21:01Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install APM's .NET Framework agent and .NET Core agent on Azure Service Fabric. This is not the same as installing the Infrastructure integrations for Microsoft Azure. Install .NET agent on Azure Service Fabric Important In most cases, installing the .NET agent in an Azure Service Fabric environment can be performed using the standard install procedures for either Windows or Linux. This document highlights some alternate ways you can install the agent. You will need to ensure the agent gets installed on all nodes in your cluster. To monitor multiple nodes, you may want to integrate the install into your deployment process. If you are using containers in your Service Fabric environment you should read Install for Docker. You can also install the agent in a Service Fabric environment using NuGet. NuGet is often a good option for developers because the agent gets deployed along with your application. Though, using NuGet requires some manual installation procedures. See Install with NuGet. Install using NuGet To install the .NET agent using NuGet: Follow the standard NuGet install procedures. When using NuGet, you must set some environment variables. This can be done in your application's ServiceManifest.xml file. See the relevant instructions below: .NET Framework In the ServiceManifest.xml file in your project, include the following under the CodePackage node: <CodePackage Name=\"Code\" Version=\"1.0.0\"> </CodePackage> <CodePackage> ... <EntryPoint> <ExeHost> ... <!-- It is important for the WorkingFolder to be set to CodePackage --> <!-- This is because the environment variables set below rely on this being the working folder for the agent to work --> <WorkingFolder>CodePackage</WorkingFolder> ... </ExeHost> </EntryPoint> ... <EnvironmentVariables> ... <EnvironmentVariable Name=\"COR_ENABLE_PROFILING\" Value=\"1\" /> <EnvironmentVariable Name=\"COR_PROFILER\" Value=\"{71DA0A04-7777-4EC6-9643-7D28B46A8A41}\" /> <EnvironmentVariable Name=\"COR_PROFILER_PATH\" Value=\".\\newrelic\\NewRelic.Profiler.dll\" /> <EnvironmentVariable Name=\"NEWRELIC_HOME\" Value=\".\\newrelic\" /> <EnvironmentVariable Name=\"NEW_RELIC_LICENSE_KEY\" Value=\"YOUR_LICENSE_KEY\" /> <EnvironmentVariable Name=\"NEW_RELIC_APP_NAME\" Value=\"YOUR_APP_NAME\" /> ... </EnvironmentVariables> ... </CodePackage> Copy .NET Core for Windows In the ServiceManifest.xml file in your project, include the following under the CodePackage node: <CodePackage> ... <EntryPoint> <ExeHost> ... <!-- It is important for the WorkingFolder to be set to CodePackage --> <!-- This is because the environment variables set below rely on this being the working folder for the agent to work --> <WorkingFolder>CodePackage</WorkingFolder> ... </ExeHost> </EntryPoint> ... <EnvironmentVariables> ... <EnvironmentVariable Name=\"CORECLR_ENABLE_PROFILING\" Value=\"1\" /> <EnvironmentVariable Name=\"CORECLR_PROFILER\" Value=\"{36032161-FFC0-4B61-B559-F6C5D41BAE5A}\" /> <EnvironmentVariable Name=\"CORECLR_PROFILER_PATH\" Value=\".\\newrelic\\NewRelic.Profiler.dll\" /> <EnvironmentVariable Name=\"CORECLR_NEWRELIC_HOME\" Value=\".\\newrelic\" /> <EnvironmentVariable Name=\"NEW_RELIC_LICENSE_KEY\" Value=\"YOUR_LICENSE_KEY\" /> <EnvironmentVariable Name=\"NEW_RELIC_APP_NAME\" Value=\"YOUR_APP_NAME\" /> ... </EnvironmentVariables> ... </CodePackage> Copy .NET Core for Linux In the ServiceManifest.xml file in your project, include the following under the CodePackage node: <CodePackage> ... <EntryPoint> <ExeHost> ... <!-- It is important for the WorkingFolder to be set to CodePackage --> <!-- This is because the environment variables set below rely on this being the working folder for the agent to work --> <WorkingFolder>CodePackage</WorkingFolder> ... </ExeHost> </EntryPoint> ... <EnvironmentVariables> ... <EnvironmentVariable Name=\"CORECLR_ENABLE_PROFILING\" Value=\"1\" /> <EnvironmentVariable Name=\"CORECLR_PROFILER\" Value=\"{36032161-FFC0-4B61-B559-F6C5D41BAE5A}\" /> <EnvironmentVariable Name=\"CORECLR_PROFILER_PATH\" Value=\"./newrelic/libNewRelicProfiler.so\" /> <EnvironmentVariable Name=\"CORECLR_NEWRELIC_HOME\" Value=\"./newrelic\" /> <EnvironmentVariable Name=\"NEW_RELIC_LICENSE_KEY\" Value=\"YOUR_LICENSE_KEY\" /> <EnvironmentVariable Name=\"NEW_RELIC_APP_NAME\" Value=\"YOUR_APP_NAME\" /> ... </EnvironmentVariables> ... </CodePackage> Copy For the .NET Framework only: Edit your app.config file and add the NewRelic.AgentEnabled app setting: <appSettings> ... <add key=\"NewRelic.AgentEnabled\" value=\"true\" /> ... </appSettings> Copy If your application is generating traffic, data should appear in your APM account in several minutes. If data does not appear, try these troubleshooting steps: Make sure that all files in the newrelic directory at the root of your app was published to Azure. Make sure the environment variables are set correctly. See the general troubleshooting documentation to check for common errors.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.435974,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .<em>NET</em> <em>agent</em> on <em>Azure</em> Service Fabric",
        "sections": "<em>Install</em> .<em>NET</em> <em>agent</em> on <em>Azure</em> Service Fabric",
        "tags": "<em>Azure</em> <em>installation</em>",
        "body": "This document explains how to install APM&#x27;s .<em>NET</em> Framework <em>agent</em> and .<em>NET</em> Core <em>agent</em> on <em>Azure</em> Service Fabric. This is not the same as installing the Infrastructure integrations for Microsoft <em>Azure</em>. Install .<em>NET</em> <em>agent</em> on <em>Azure</em> Service Fabric Important In most cases, installing the .<em>NET</em> <em>agent</em>"
      },
      "id": "6043c8a6e7b9d24fa25799bc"
    }
  ],
  "/docs/agents/net-agent/azure-troubleshooting/azure-cloud-services-no-data-appears": [
    {
      "sections": [
        "No data reporting with Microsoft Application Insights",
        "Problem",
        "Solution"
      ],
      "title": "No data reporting with Microsoft Application Insights",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure troubleshooting"
      ],
      "external_id": "1b022bab6a2b6e99972745182dcd4340be20bc3f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-troubleshooting/no-data-reporting-microsoft-application-insights/",
      "published_at": "2021-06-02T14:45:45Z",
      "updated_at": "2021-04-15T22:32:46Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem The .NET agent has been installed and the required App Settings are set, but no data appears, and no New Relic logs are created in D:\\Home\\Logfiles\\NewRelic\\. In addition, when you use the Azure Kudu console's Process Explorer to inspect your application's Environment Variables, it shows the COR_PROFILER_PATH_64 and COR_PROFILER_PATH_32 are set and pointing to the following: D:\\Program Files (x86)\\SiteExtensions\\InstrumentationEngine\\1.0.19\\Instrumentation64\\MicrosoftInstrumentationEngine_x64.dll Copy Solution The .NET Common Language Runtime (CLR) only allows one profiler. If Microsoft's Application Insights profiler is installed on the system, the New Relic profiler will not instrument any applications, and no data will appear. For more information, see the Microsoft Azure Web Apps documentation. To resolve this issue, remove or disable Application Insights from your application. To remove the Application Insights Site Extension: Remove all settings related to Application Insights from Application > Settings > Application Settings and Save. This may include the following keys: Any key that begins with APPINSIGHTS_ Any key that begins with APPLICATIONINSIGHTS_ Any key that begins with XDT_MicrosoftApplicationInsights_ DiagnosticServices_EXTENSION_VERSION InstrumentationEngine_EXTENSION_VERSION Remove the extension from Application > Tools > Extensions. Right-click the extension and Delete. Remove the Tile Add-On from your Application Panel (if present). Restart your application. To disable Application Insights through the Azure Portal: Go to the Application Insights panel under the Settings. This may restart your app.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 116.31843,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Azure</em> <em>troubleshooting</em>",
        "body": "Problem The .<em>NET</em> <em>agent</em> has been installed and the required App Settings are set, but no data appears, and no New Relic logs are created in D:\\Home\\Logfiles\\NewRelic\\. In addition, when you use the <em>Azure</em> Kudu console&#x27;s Process Explorer to inspect your application&#x27;s Environment Variables, it shows"
      },
      "id": "6043d56328ccbcd70e2c609a"
    },
    {
      "sections": [
        "Azure Web Apps: Profiler .dll locks during deployment",
        "Problem",
        "Solution",
        "Stop the file from releasing",
        "Use the New Relic Site Extension"
      ],
      "title": "Azure Web Apps: Profiler .dll locks during deployment",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure troubleshooting"
      ],
      "external_id": "d7453c93ccf14de7be798dc0571d18118d82a4fc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-troubleshooting/azure-web-apps-profiler-dll-locks-during-deployment/",
      "published_at": "2021-06-02T13:56:50Z",
      "updated_at": "2021-03-13T05:37:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem When deploying a new version of New Relic's .NET agent (NewRelic.Profiler.dll) for your Microsoft Azure Web App, an error message prevents you from continuing until you stop or restart the process. Solution Normally the process stops, then the assets are overwritten by the assets that New Relic packs in the site root (located at D:\\Home\\site\\wwwroot\\newrelic) during a deployment. To resolve the problem, try either of these solutions. Stop the file from releasing This solution is available for your Azure Web App if you are attempting to deploy a new .NET agent version over an existing version: Stop your web app to release the .dll file. Allow the update to proceed. Once the deploy is complete, restart the instance. Use the New Relic Site Extension You can install New Relic's .NET agent into your Azure Web App by using the New Relic Site Extension. (You should only need to install the extension once.) Navigate to https : //yoursite.scm.azurewebsites.net/ and select Site Extensions. From the Gallery, select the add icon, then select New Relic. Follow the instructions to manually add the configuration keys to your web app, and use the option that best fits your needs. To update the Site Extension: From the Azure Portal, select WebApps > (select your site) > All Settings > Extensions > New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.74366,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Azure</em> Web Apps: Profiler .dll locks during deployment",
        "sections": "<em>Azure</em> Web Apps: Profiler .dll locks during deployment",
        "tags": "<em>Azure</em> <em>troubleshooting</em>",
        "body": "Problem When deploying a new version of New Relic&#x27;s .<em>NET</em> <em>agent</em> (NewRelic.Profiler.dll) for your Microsoft <em>Azure</em> Web App, an error message prevents you from continuing until you stop or restart the process. Solution Normally the process stops, then the assets are overwritten by the assets that New"
      },
      "id": "6043b9c8196a678a1e960f5a"
    },
    {
      "sections": [
        "Azure Web Apps: Using Always On and no data appears",
        "Important",
        "Problem",
        "Cause",
        "Solution",
        "Other options",
        "Use Kudu to name your app.",
        "Use app/web.config to name your app.",
        "Use Synthetic monitoring to monitor your website."
      ],
      "title": "Azure Web Apps: Using Always On and no data appears",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure troubleshooting"
      ],
      "external_id": "15dfcc0c2baf705da5a4fdcc4773307d31285be6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-troubleshooting/azure-web-apps-using-always-no-data-appears/",
      "published_at": "2021-06-02T14:49:04Z",
      "updated_at": "2021-03-13T02:45:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Beginning with .NET agent version 8.22.181.0, Azure's Always On setting may be enabled without interfering with the agent. If you'd like to use Always On, simply update the agent. If your application targets .NET Framework 4.0 or lower, Always On will still interfere with the agent and the workarounds below are still applicable. Problem You installed New Relic's .NET agent through Microsoft Azure Web Apps and are using Azure's Always On setting. After generating some traffic and waiting a few minutes for data collection to start for your app, data still does not appear in the APM user interface. Cause If no data appears within five minutes, Azure's Always On setting may be conflicting with New Relic. This feature is only available in Azure's Basic and Standard modes. The Always On setting prevents the environment variable APP_POOL_ID from being set. New Relic's .NET agent needs this environment variable to get the app name. If the agent cannot determine an application name, then it won't start up. Solution If you are using Microsoft's Standard or Basic tiers with the Azure Portal, ensure that the Always On setting is disabled. In the Azure Portal, select (your app) > Settings > Application Settings. Set the Always On toggle to Off. Other options Here are some other options you can try. If these do not work, you must turn off the Always On setting. Use Kudu to name your app. To name your application in the local newrelic.config using Kudu: From the Microsoft Azure Portal, select (your app) > Tools > Kudu, then select Go. Select Debug Console > CMD. Select Site > wwwroot > newrelic. Select the edit icon for newrelic.config, and add: <application> <name> Your app's name </name> </application> Copy Save and restart your application. Use app/web.config to name your app. Important This option has been found to only be a temporary fix. The .NET agent may stop reporting intermittently. To name your application in its app/web.config file: Add the following key to appSettings: <appSettings> <add key=\"NewRelic.AppName\" value=\"Your app's name\" /> </appSettings> Copy Restart your instance. Use Synthetic monitoring to monitor your website. Depending on your usage of Always On, you can try using Synthetic monitoring to keep your website active. If you are not using the Always On setting, you can try using the Synthetic monitoring free pinger monitor. If you are using the Always On setting, Synthetic monitoring needs to be able to reach an endpoint for your worker roles. If it can't, you can try using a Synthetics scripted monitor to run on your site.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.72878,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Azure</em> Web Apps: Using Always On and no data appears",
        "sections": "<em>Azure</em> Web Apps: Using Always On and no data appears",
        "tags": "<em>Azure</em> <em>troubleshooting</em>",
        "body": "Important Beginning with .<em>NET</em> <em>agent</em> version 8.22.181.0, <em>Azure</em>&#x27;s Always On setting may be enabled without interfering with the <em>agent</em>. If you&#x27;d like to use Always On, simply update the <em>agent</em>. If your application targets .<em>NET</em> Framework 4.0 or lower, Always On will still interfere with the <em>agent</em>"
      },
      "id": "6043b800e7b9d227235799ea"
    }
  ],
  "/docs/agents/net-agent/azure-troubleshooting/azure-web-apps-profiler-dll-locks-during-deployment": [
    {
      "sections": [
        "No data reporting with Microsoft Application Insights",
        "Problem",
        "Solution"
      ],
      "title": "No data reporting with Microsoft Application Insights",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure troubleshooting"
      ],
      "external_id": "1b022bab6a2b6e99972745182dcd4340be20bc3f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-troubleshooting/no-data-reporting-microsoft-application-insights/",
      "published_at": "2021-06-02T14:45:45Z",
      "updated_at": "2021-04-15T22:32:46Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem The .NET agent has been installed and the required App Settings are set, but no data appears, and no New Relic logs are created in D:\\Home\\Logfiles\\NewRelic\\. In addition, when you use the Azure Kudu console's Process Explorer to inspect your application's Environment Variables, it shows the COR_PROFILER_PATH_64 and COR_PROFILER_PATH_32 are set and pointing to the following: D:\\Program Files (x86)\\SiteExtensions\\InstrumentationEngine\\1.0.19\\Instrumentation64\\MicrosoftInstrumentationEngine_x64.dll Copy Solution The .NET Common Language Runtime (CLR) only allows one profiler. If Microsoft's Application Insights profiler is installed on the system, the New Relic profiler will not instrument any applications, and no data will appear. For more information, see the Microsoft Azure Web Apps documentation. To resolve this issue, remove or disable Application Insights from your application. To remove the Application Insights Site Extension: Remove all settings related to Application Insights from Application > Settings > Application Settings and Save. This may include the following keys: Any key that begins with APPINSIGHTS_ Any key that begins with APPLICATIONINSIGHTS_ Any key that begins with XDT_MicrosoftApplicationInsights_ DiagnosticServices_EXTENSION_VERSION InstrumentationEngine_EXTENSION_VERSION Remove the extension from Application > Tools > Extensions. Right-click the extension and Delete. Remove the Tile Add-On from your Application Panel (if present). Restart your application. To disable Application Insights through the Azure Portal: Go to the Application Insights panel under the Settings. This may restart your app.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 116.31843,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Azure</em> <em>troubleshooting</em>",
        "body": "Problem The .<em>NET</em> <em>agent</em> has been installed and the required App Settings are set, but no data appears, and no New Relic logs are created in D:\\Home\\Logfiles\\NewRelic\\. In addition, when you use the <em>Azure</em> Kudu console&#x27;s Process Explorer to inspect your application&#x27;s Environment Variables, it shows"
      },
      "id": "6043d56328ccbcd70e2c609a"
    },
    {
      "sections": [
        "Azure Cloud Services: No data appears",
        "Problem",
        "Solution"
      ],
      "title": "Azure Cloud Services: No data appears",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure troubleshooting"
      ],
      "external_id": "02ccb0a4315ac400995631f6b1967b5581548183",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-troubleshooting/azure-cloud-services-no-data-appears/",
      "published_at": "2021-06-02T13:57:49Z",
      "updated_at": "2021-03-13T02:47:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem You installed New Relic's .NET agent through Microsoft Azure Cloud Services, and then you installed the NuGet package. After generating some traffic and waiting a few minutes for data to start being collected for your app, data still does not appear in the APM user interface. Solution In order for the .NET agent to start up and attach to your app, at least one metric must be collected. If you have an external call or database call that New Relic instruments, then your app will report data to your APM Summary page. In addition, information about external calls will appear on your app's Service maps. Without custom instrumentation, Worker roles only report database calls and external calls. (Instrumenting a Worker Role is similar to instrumenting a custom application.) To view other details, you must gather custom metrics using New Relic's .NET API and view them in a custom dashboard.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.728966,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Azure</em> Cloud Services: No data appears",
        "sections": "<em>Azure</em> Cloud Services: No data appears",
        "tags": "<em>Azure</em> <em>troubleshooting</em>",
        "body": "Problem You installed New Relic&#x27;s .<em>NET</em> <em>agent</em> through Microsoft <em>Azure</em> Cloud Services, and then you installed the NuGet package. After generating some traffic and waiting a few minutes for data to start being collected for your app, data still does not appear in the APM user interface. Solution"
      },
      "id": "6043b66c28ccbc6f972d759d"
    },
    {
      "sections": [
        "Azure Web Apps: Using Always On and no data appears",
        "Important",
        "Problem",
        "Cause",
        "Solution",
        "Other options",
        "Use Kudu to name your app.",
        "Use app/web.config to name your app.",
        "Use Synthetic monitoring to monitor your website."
      ],
      "title": "Azure Web Apps: Using Always On and no data appears",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure troubleshooting"
      ],
      "external_id": "15dfcc0c2baf705da5a4fdcc4773307d31285be6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-troubleshooting/azure-web-apps-using-always-no-data-appears/",
      "published_at": "2021-06-02T14:49:04Z",
      "updated_at": "2021-03-13T02:45:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Beginning with .NET agent version 8.22.181.0, Azure's Always On setting may be enabled without interfering with the agent. If you'd like to use Always On, simply update the agent. If your application targets .NET Framework 4.0 or lower, Always On will still interfere with the agent and the workarounds below are still applicable. Problem You installed New Relic's .NET agent through Microsoft Azure Web Apps and are using Azure's Always On setting. After generating some traffic and waiting a few minutes for data collection to start for your app, data still does not appear in the APM user interface. Cause If no data appears within five minutes, Azure's Always On setting may be conflicting with New Relic. This feature is only available in Azure's Basic and Standard modes. The Always On setting prevents the environment variable APP_POOL_ID from being set. New Relic's .NET agent needs this environment variable to get the app name. If the agent cannot determine an application name, then it won't start up. Solution If you are using Microsoft's Standard or Basic tiers with the Azure Portal, ensure that the Always On setting is disabled. In the Azure Portal, select (your app) > Settings > Application Settings. Set the Always On toggle to Off. Other options Here are some other options you can try. If these do not work, you must turn off the Always On setting. Use Kudu to name your app. To name your application in the local newrelic.config using Kudu: From the Microsoft Azure Portal, select (your app) > Tools > Kudu, then select Go. Select Debug Console > CMD. Select Site > wwwroot > newrelic. Select the edit icon for newrelic.config, and add: <application> <name> Your app's name </name> </application> Copy Save and restart your application. Use app/web.config to name your app. Important This option has been found to only be a temporary fix. The .NET agent may stop reporting intermittently. To name your application in its app/web.config file: Add the following key to appSettings: <appSettings> <add key=\"NewRelic.AppName\" value=\"Your app's name\" /> </appSettings> Copy Restart your instance. Use Synthetic monitoring to monitor your website. Depending on your usage of Always On, you can try using Synthetic monitoring to keep your website active. If you are not using the Always On setting, you can try using the Synthetic monitoring free pinger monitor. If you are using the Always On setting, Synthetic monitoring needs to be able to reach an endpoint for your worker roles. If it can't, you can try using a Synthetics scripted monitor to run on your site.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 109.72878,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Azure</em> Web Apps: Using Always On and no data appears",
        "sections": "<em>Azure</em> Web Apps: Using Always On and no data appears",
        "tags": "<em>Azure</em> <em>troubleshooting</em>",
        "body": "Important Beginning with .<em>NET</em> <em>agent</em> version 8.22.181.0, <em>Azure</em>&#x27;s Always On setting may be enabled without interfering with the <em>agent</em>. If you&#x27;d like to use Always On, simply update the <em>agent</em>. If your application targets .<em>NET</em> Framework 4.0 or lower, Always On will still interfere with the <em>agent</em>"
      },
      "id": "6043b800e7b9d227235799ea"
    }
  ]
}