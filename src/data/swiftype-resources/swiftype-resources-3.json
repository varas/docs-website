{
  "/docs/agents/net-agent/azure-troubleshooting/azure-web-apps-using-always-no-data-appears": [
    {
      "sections": [
        "No data reporting with Microsoft Application Insights",
        "Problem",
        "Solution"
      ],
      "title": "No data reporting with Microsoft Application Insights",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure troubleshooting"
      ],
      "external_id": "1b022bab6a2b6e99972745182dcd4340be20bc3f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-troubleshooting/no-data-reporting-microsoft-application-insights/",
      "published_at": "2021-06-02T14:45:45Z",
      "updated_at": "2021-04-15T22:32:46Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem The .NET agent has been installed and the required App Settings are set, but no data appears, and no New Relic logs are created in D:\\Home\\Logfiles\\NewRelic\\. In addition, when you use the Azure Kudu console's Process Explorer to inspect your application's Environment Variables, it shows the COR_PROFILER_PATH_64 and COR_PROFILER_PATH_32 are set and pointing to the following: D:\\Program Files (x86)\\SiteExtensions\\InstrumentationEngine\\1.0.19\\Instrumentation64\\MicrosoftInstrumentationEngine_x64.dll Copy Solution The .NET Common Language Runtime (CLR) only allows one profiler. If Microsoft's Application Insights profiler is installed on the system, the New Relic profiler will not instrument any applications, and no data will appear. For more information, see the Microsoft Azure Web Apps documentation. To resolve this issue, remove or disable Application Insights from your application. To remove the Application Insights Site Extension: Remove all settings related to Application Insights from Application > Settings > Application Settings and Save. This may include the following keys: Any key that begins with APPINSIGHTS_ Any key that begins with APPLICATIONINSIGHTS_ Any key that begins with XDT_MicrosoftApplicationInsights_ DiagnosticServices_EXTENSION_VERSION InstrumentationEngine_EXTENSION_VERSION Remove the extension from Application > Tools > Extensions. Right-click the extension and Delete. Remove the Tile Add-On from your Application Panel (if present). Restart your application. To disable Application Insights through the Azure Portal: Go to the Application Insights panel under the Settings. This may restart your app.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 105.2008,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Azure</em> <em>troubleshooting</em>",
        "body": "Problem The .<em>NET</em> <em>agent</em> has been installed and the required App Settings are set, but no data appears, and no New Relic logs are created in D:\\Home\\Logfiles\\NewRelic\\. In addition, when you use the <em>Azure</em> Kudu console&#x27;s Process Explorer to inspect your application&#x27;s Environment Variables, it shows"
      },
      "id": "6043d56328ccbcd70e2c609a"
    },
    {
      "sections": [
        "Azure Cloud Services: No data appears",
        "Problem",
        "Solution"
      ],
      "title": "Azure Cloud Services: No data appears",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure troubleshooting"
      ],
      "external_id": "02ccb0a4315ac400995631f6b1967b5581548183",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-troubleshooting/azure-cloud-services-no-data-appears/",
      "published_at": "2021-06-02T13:57:49Z",
      "updated_at": "2021-03-13T02:47:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem You installed New Relic's .NET agent through Microsoft Azure Cloud Services, and then you installed the NuGet package. After generating some traffic and waiting a few minutes for data to start being collected for your app, data still does not appear in the APM user interface. Solution In order for the .NET agent to start up and attach to your app, at least one metric must be collected. If you have an external call or database call that New Relic instruments, then your app will report data to your APM Summary page. In addition, information about external calls will appear on your app's Service maps. Without custom instrumentation, Worker roles only report database calls and external calls. (Instrumenting a Worker Role is similar to instrumenting a custom application.) To view other details, you must gather custom metrics using New Relic's .NET API and view them in a custom dashboard.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.75613,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Azure</em> Cloud Services: No data appears",
        "sections": "<em>Azure</em> Cloud Services: No data appears",
        "tags": "<em>Azure</em> <em>troubleshooting</em>",
        "body": "Problem You installed New Relic&#x27;s .<em>NET</em> <em>agent</em> through Microsoft <em>Azure</em> Cloud Services, and then you installed the NuGet package. After generating some traffic and waiting a few minutes for data to start being collected for your app, data still does not appear in the APM user interface. Solution"
      },
      "id": "6043b66c28ccbc6f972d759d"
    },
    {
      "sections": [
        "Azure Web Apps: Profiler .dll locks during deployment",
        "Problem",
        "Solution",
        "Stop the file from releasing",
        "Use the New Relic Site Extension"
      ],
      "title": "Azure Web Apps: Profiler .dll locks during deployment",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure troubleshooting"
      ],
      "external_id": "d7453c93ccf14de7be798dc0571d18118d82a4fc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-troubleshooting/azure-web-apps-profiler-dll-locks-during-deployment/",
      "published_at": "2021-06-02T13:56:50Z",
      "updated_at": "2021-03-13T05:37:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem When deploying a new version of New Relic's .NET agent (NewRelic.Profiler.dll) for your Microsoft Azure Web App, an error message prevents you from continuing until you stop or restart the process. Solution Normally the process stops, then the assets are overwritten by the assets that New Relic packs in the site root (located at D:\\Home\\site\\wwwroot\\newrelic) during a deployment. To resolve the problem, try either of these solutions. Stop the file from releasing This solution is available for your Azure Web App if you are attempting to deploy a new .NET agent version over an existing version: Stop your web app to release the .dll file. Allow the update to proceed. Once the deploy is complete, restart the instance. Use the New Relic Site Extension You can install New Relic's .NET agent into your Azure Web App by using the New Relic Site Extension. (You should only need to install the extension once.) Navigate to https : //yoursite.scm.azurewebsites.net/ and select Site Extensions. From the Gallery, select the add icon, then select New Relic. Follow the instructions to manually add the configuration keys to your web app, and use the option that best fits your needs. To update the Site Extension: From the Azure Portal, select WebApps > (select your site) > All Settings > Extensions > New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.74942,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Azure</em> Web Apps: Profiler .dll locks during deployment",
        "sections": "<em>Azure</em> Web Apps: Profiler .dll locks during deployment",
        "tags": "<em>Azure</em> <em>troubleshooting</em>",
        "body": "Problem When deploying a new version of New Relic&#x27;s .<em>NET</em> <em>agent</em> (NewRelic.Profiler.dll) for your Microsoft <em>Azure</em> Web App, an error message prevents you from continuing until you stop or restart the process. Solution Normally the process stops, then the assets are overwritten by the assets that New"
      },
      "id": "6043b9c8196a678a1e960f5a"
    }
  ],
  "/docs/agents/net-agent/azure-troubleshooting/no-data-reporting-microsoft-application-insights": [
    {
      "sections": [
        "Azure Web Apps: Using Always On and no data appears",
        "Important",
        "Problem",
        "Cause",
        "Solution",
        "Other options",
        "Use Kudu to name your app.",
        "Use app/web.config to name your app.",
        "Use Synthetic monitoring to monitor your website."
      ],
      "title": "Azure Web Apps: Using Always On and no data appears",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure troubleshooting"
      ],
      "external_id": "15dfcc0c2baf705da5a4fdcc4773307d31285be6",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-troubleshooting/azure-web-apps-using-always-no-data-appears/",
      "published_at": "2021-06-02T14:49:04Z",
      "updated_at": "2021-03-13T02:45:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important Beginning with .NET agent version 8.22.181.0, Azure's Always On setting may be enabled without interfering with the agent. If you'd like to use Always On, simply update the agent. If your application targets .NET Framework 4.0 or lower, Always On will still interfere with the agent and the workarounds below are still applicable. Problem You installed New Relic's .NET agent through Microsoft Azure Web Apps and are using Azure's Always On setting. After generating some traffic and waiting a few minutes for data collection to start for your app, data still does not appear in the APM user interface. Cause If no data appears within five minutes, Azure's Always On setting may be conflicting with New Relic. This feature is only available in Azure's Basic and Standard modes. The Always On setting prevents the environment variable APP_POOL_ID from being set. New Relic's .NET agent needs this environment variable to get the app name. If the agent cannot determine an application name, then it won't start up. Solution If you are using Microsoft's Standard or Basic tiers with the Azure Portal, ensure that the Always On setting is disabled. In the Azure Portal, select (your app) > Settings > Application Settings. Set the Always On toggle to Off. Other options Here are some other options you can try. If these do not work, you must turn off the Always On setting. Use Kudu to name your app. To name your application in the local newrelic.config using Kudu: From the Microsoft Azure Portal, select (your app) > Tools > Kudu, then select Go. Select Debug Console > CMD. Select Site > wwwroot > newrelic. Select the edit icon for newrelic.config, and add: <application> <name> Your app's name </name> </application> Copy Save and restart your application. Use app/web.config to name your app. Important This option has been found to only be a temporary fix. The .NET agent may stop reporting intermittently. To name your application in its app/web.config file: Add the following key to appSettings: <appSettings> <add key=\"NewRelic.AppName\" value=\"Your app's name\" /> </appSettings> Copy Restart your instance. Use Synthetic monitoring to monitor your website. Depending on your usage of Always On, you can try using Synthetic monitoring to keep your website active. If you are not using the Always On setting, you can try using the Synthetic monitoring free pinger monitor. If you are using the Always On setting, Synthetic monitoring needs to be able to reach an endpoint for your worker roles. If it can't, you can try using a Synthetics scripted monitor to run on your site.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.59177,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Azure</em> Web Apps: Using Always On and no data appears",
        "sections": "<em>Azure</em> Web Apps: Using Always On and no data appears",
        "tags": "<em>Azure</em> <em>troubleshooting</em>",
        "body": "Important Beginning with .<em>NET</em> <em>agent</em> version 8.22.181.0, <em>Azure</em>&#x27;s Always On setting may be enabled without interfering with the <em>agent</em>. If you&#x27;d like to use Always On, simply update the <em>agent</em>. If your application targets .<em>NET</em> Framework 4.0 or lower, Always On will still interfere with the <em>agent</em>"
      },
      "id": "6043b800e7b9d227235799ea"
    },
    {
      "sections": [
        "Azure Cloud Services: No data appears",
        "Problem",
        "Solution"
      ],
      "title": "Azure Cloud Services: No data appears",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure troubleshooting"
      ],
      "external_id": "02ccb0a4315ac400995631f6b1967b5581548183",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-troubleshooting/azure-cloud-services-no-data-appears/",
      "published_at": "2021-06-02T13:57:49Z",
      "updated_at": "2021-03-13T02:47:13Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem You installed New Relic's .NET agent through Microsoft Azure Cloud Services, and then you installed the NuGet package. After generating some traffic and waiting a few minutes for data to start being collected for your app, data still does not appear in the APM user interface. Solution In order for the .NET agent to start up and attach to your app, at least one metric must be collected. If you have an external call or database call that New Relic instruments, then your app will report data to your APM Summary page. In addition, information about external calls will appear on your app's Service maps. Without custom instrumentation, Worker roles only report database calls and external calls. (Instrumenting a Worker Role is similar to instrumenting a custom application.) To view other details, you must gather custom metrics using New Relic's .NET API and view them in a custom dashboard.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.75613,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Azure</em> Cloud Services: No data appears",
        "sections": "<em>Azure</em> Cloud Services: No data appears",
        "tags": "<em>Azure</em> <em>troubleshooting</em>",
        "body": "Problem You installed New Relic&#x27;s .<em>NET</em> <em>agent</em> through Microsoft <em>Azure</em> Cloud Services, and then you installed the NuGet package. After generating some traffic and waiting a few minutes for data to start being collected for your app, data still does not appear in the APM user interface. Solution"
      },
      "id": "6043b66c28ccbc6f972d759d"
    },
    {
      "sections": [
        "Azure Web Apps: Profiler .dll locks during deployment",
        "Problem",
        "Solution",
        "Stop the file from releasing",
        "Use the New Relic Site Extension"
      ],
      "title": "Azure Web Apps: Profiler .dll locks during deployment",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Azure troubleshooting"
      ],
      "external_id": "d7453c93ccf14de7be798dc0571d18118d82a4fc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/azure-troubleshooting/azure-web-apps-profiler-dll-locks-during-deployment/",
      "published_at": "2021-06-02T13:56:50Z",
      "updated_at": "2021-03-13T05:37:24Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Problem When deploying a new version of New Relic's .NET agent (NewRelic.Profiler.dll) for your Microsoft Azure Web App, an error message prevents you from continuing until you stop or restart the process. Solution Normally the process stops, then the assets are overwritten by the assets that New Relic packs in the site root (located at D:\\Home\\site\\wwwroot\\newrelic) during a deployment. To resolve the problem, try either of these solutions. Stop the file from releasing This solution is available for your Azure Web App if you are attempting to deploy a new .NET agent version over an existing version: Stop your web app to release the .dll file. Allow the update to proceed. Once the deploy is complete, restart the instance. Use the New Relic Site Extension You can install New Relic's .NET agent into your Azure Web App by using the New Relic Site Extension. (You should only need to install the extension once.) Navigate to https : //yoursite.scm.azurewebsites.net/ and select Site Extensions. From the Gallery, select the add icon, then select New Relic. Follow the instructions to manually add the configuration keys to your web app, and use the option that best fits your needs. To update the Site Extension: From the Azure Portal, select WebApps > (select your site) > All Settings > Extensions > New Relic.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.74942,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Azure</em> Web Apps: Profiler .dll locks during deployment",
        "sections": "<em>Azure</em> Web Apps: Profiler .dll locks during deployment",
        "tags": "<em>Azure</em> <em>troubleshooting</em>",
        "body": "Problem When deploying a new version of New Relic&#x27;s .<em>NET</em> <em>agent</em> (NewRelic.Profiler.dll) for your Microsoft <em>Azure</em> Web App, an error message prevents you from continuing until you stop or restart the process. Solution Normally the process stops, then the assets are overwritten by the assets that New"
      },
      "id": "6043b9c8196a678a1e960f5a"
    }
  ],
  "/docs/agents/net-agent/configuration/name-your-net-application": [
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.673935,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Agents</em>",
        "body": " called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following <em>agents</em> support the addition of custom user attributes to span events: Java <em>agent</em> 5.13.0 and above Go <em>agent</em> 3.6.0 and above .<em>NET</em> <em>agent</em> 8.25 and above Node"
      },
      "id": "603eb9db28ccbc127aeba79e"
    },
    {
      "sections": [
        ".NET agent configuration",
        "Configuration overview",
        "Important",
        "Configuration methods and precedence levels",
        "Required environment variables",
        "Caution",
        ".NET Framework environment variables",
        ".NET Core environment variables",
        "Profiler conflict explanation",
        "Optional environment variables",
        "Setup options, newrelic.config",
        "Configuration element",
        "agentEnabled",
        "maxStackTraceLines",
        "timingPrecision",
        "Service element",
        "licenseKey (required)",
        "sendEnvironmentInfo",
        "syncStartup",
        "sendDataOnExit",
        "sendDataOnExitThreshold",
        "completeTransactionsOnThread",
        "requestTimeout",
        "autoStart",
        "ssl (DEPRECATED)",
        "Obscuring key element",
        "Proxy element",
        "host",
        "port",
        "uriPath",
        "domain",
        "user",
        "password",
        "passwordObfuscated",
        "Log element",
        "level",
        "auditLog",
        "console",
        "directory",
        "fileName",
        "Application element (required)",
        "name",
        "disableSamplers",
        "Data transmission element",
        "putForDataSend",
        "Host name",
        "Set using config file",
        "Set using environment variable",
        "Cloud platform utilization",
        "detectAws",
        "detectAzure",
        "detectGcp",
        "detectPcf",
        "detectDocker",
        "detectKubernetes",
        "Instrumentation options",
        "Instrumentation element",
        "Applications element (instrumentation)",
        "Attributes element",
        "enabled",
        "include",
        "exclude",
        "Feature options",
        "App pools",
        "defaultBehavior",
        "applicationPool",
        "Cross application traces",
        "Error collection",
        "Tip",
        "captureEvents",
        "maxEventSamplesStored",
        "ignoreClasses",
        "ignoreMessages",
        "ignoreErrors (DEPRECATED)",
        "ignoreStatusCodes",
        "expectedClasses",
        "expectedMessages",
        "expectedStatusCodes",
        "attributes",
        "High security mode",
        "Strip exception messages",
        "Transaction events",
        "maximumSamplesStored",
        "Custom events",
        "Custom parameters",
        "Labels (tags)",
        "Browser instrumentation",
        "autoInstrument",
        "requestPathsExcluded",
        "Slow queries",
        "Transaction traces",
        "transactionThreshold",
        "recordSql",
        "explainEnabled",
        "explainThreshold",
        "maxSegments",
        "maxExplainPlans",
        "Datastore tracer",
        "instanceReporting",
        "databaseNameReporting",
        "queryParameters",
        "Distributed tracing",
        "excludeNewrelicHeader",
        "Disable span events via config file",
        "Disable span events via environment variable",
        "Infinite Tracing",
        "trace_observer",
        "Span events",
        "Settings in app.config or web.config",
        "Enable and disable the agent",
        "Application name",
        "License key",
        "Change newrelic.config location",
        "Settings in appsettings.json"
      ],
      "title": ".NET agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Configuration"
      ],
      "external_id": "b89fa7fc399f2729bfee8f5106e777798a73177a",
      "image": "https://docs.newrelic.com/static/cffd7eb2d22c8e338531c38f35208c7c/c1b63/net-agent-config-settings-precedence_0.png",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/configuration/net-agent-configuration/",
      "published_at": "2021-05-28T17:00:56Z",
      "updated_at": "2021-05-15T16:33:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains the configuration options for the APM .NET agent. Configuration overview APM agent configuration options allow you to control some aspects of how the agent behaves. Some of these config options are part of the basic install process (like setting your license key and app name), but most are more advanced settings, such as: setting a log level, setting up proxy host access, excluding certain attributes, and enabling distributed tracing. The .NET agent gets its configuration from the newrelic.config file, which is generated as part of the install process. By default, only a global newrelic.config file is created, but you can also create app-local newrelic.config files for finer control over a multi-app system. Other ways to set config options include: using environment variables, or setting server-side configuration from the UI. For more on the various config options and what overrides what, see Config settings precedence. Support for both .NET Framework and .NET Core use the same configuration options and have the same APM features, unless otherwise stated. If you make changes to the config file and want to validate that it's in the right format, you can check it against the XSD file (for example, at C:\\ProgramData\\New Relic\\.NET Agent\\newrelic.xsd for Windows) with any XSD validator. Important For IIS: after you change your newrelic.config or app.config file, perform an IISRESET from an administrative command prompt. Log level adjustments do not require a reset. Configuration methods and precedence levels Upon installation, the .NET agent's configuration file (newrelic.config) applies to all monitored applications, but you can configure the agent in other ways. Here's a diagram showing how different configuration options take precedence over one another: This diagram explains the order of precedence for different ways you might configure the .NET agent. Here are details about the configuration methods shown in the diagram, and their precedence levels: .NET configuration Details and precedence web.config or app.config or appsettings.json Configuration settings set in these files take highest precedence. However, if the agent is disabled in the local or global newrelic.config, the NewRelic.AgentEnabled settings in these files will be ignored. Environment variables Second-highest precedence. For more about these, see .NET environment variables. Server-side configuration Third-highest precedence. A limited number of server-side configuration settings are available; the other settings will come from other configuration sources. App-local newrelic.config Fourth-highest precedence. You can create app-local newrelic.config files to configure individual apps on a multi-app system. These local configuration files override settings in the global newrelic.config file. The agent looks for app-local config files in the following directories, in this order: A directory specified in your web.config or app.config file with the NewRelic.ConfigFile property The web app's root directory (with the app.config or web.config) The directory containing your app's executable file Note that the app-local config file must be complete and validate against the XSD file (for example, at C:\\ProgramData\\New Relic\\.NET Agent\\newrelic.xsd for Windows). Default (global) newrelic.config Default source and the lowest precedence. Will configure all applications on a host in the absence of other config files. The global config file is located in the New Relic agent home directory: %PROGRAMDATA%\\New Relic\\.NET Agent Required environment variables New Relic's .NET agent relies on environment variables to tell the .NET Common Language Runtime (CLR) to attach New Relic to your processes. Some .NET agent install procedures (like the MSI installer) will automatically set these variables for you; some procedures will require you to manually set them. Caution Security recommendation: You should consider what users can set system environment variables. You should also secure the accounts under which your applications execute to prevent user environment variables overriding system environment variables .NET Framework environment variables For .NET Framework, the following variables are required: COR_ENABLE_PROFILING=1 COR_PROFILER={71DA0A04-7777-4EC6-9643-7D28B46A8A41} NEWRELIC_INSTALL_PATH=path\\to\\agent\\directory Copy The .NET agent installer will add these to IIS or as system-wide environment variables. .NET Core environment variables For .NET Core, the following variables are required: Linux: CORECLR_ENABLE_PROFILING=1 CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_NEWRELIC_HOME=path/to/agent/directory CORECLR_PROFILER_PATH=\"${CORECLR_NEWRELIC_HOME}/libNewRelicProfiler.so\" Copy Windows: CORECLR_ENABLE_PROFILING=1 CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} NEWRELIC_INSTALL_PATH=path\\to\\agent\\directory CORECLR_NEWRELIC_HOME=path\\to\\agent\\directory Copy The .NET agent installer will add these to IIS or as system-wide environment variables. If your system has previously used monitoring services (non-New Relic), you may have a \"profiler conflict\" when trying to install and use the New Relic agent. More details: Profiler conflict explanation New Relic’s .NET agents rely on environment variables to tell the .NET Common Language Runtime (CLR) to load New Relic into your processes. The install-related environment variables are Microsoft variables, not New Relic variables. They can be used by other .NET profilers, and only one profiler can be attached to a process at a time. For this reason, if you have used previous application monitoring products, you may have profiler conflicts. For specific install instructions, see the .NET agent install documentation. Optional environment variables Some configuration options in New Relic's .NET agent can be set via environment variables as an alternative to setting them in a config file. Below is a list of environment variables recognized by the .NET agent with example values. NEW_RELIC_LICENSE_KEY=XXXXXXXX NEW_RELIC_LOG=MyApp.log NEW_RELIC_APP_NAME=Descriptive Name MAX_TRANSACTION_SAMPLES_STORED=500 MAX_EVENT_SAMPLES_STORED=500 NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true NEW_RELIC_SPAN_EVENTS_ENABLED=false NEW_RELIC_LABELS=foo:bar;zip:zap NEW_RELIC_CONFIG_OBSCURING_KEY=XXXXXXXX NEW_RELIC_DISABLE_SAMPLERS=true NEWRELIC_PROFILER_LOG_DIRECTORY=path\\to\\agent\\directory (not configurable via config file) Copy Setup options, newrelic.config Use these options to setup and configure your agent via the newrelic.config file. The New Relic .NET agent supports the following categories of setup options: Configuration element Service element Obscuring key element Proxy element Log element Application element (configuration) Data transmission element Host name Configuration element The root element of the configuration document is a configuration element. <configuration xmlns=\"urn:newrelic-config\" agentEnabled=\"true\" maxStackTraceLines=\"50\" timingPrecision=\"low\"> Copy The configuration element supports the following attributes: agentEnabled Type Boolean Default true Enable or disable the New Relic agent. maxStackTraceLines Type Integer Default 80 The maximum number of stack frames to trace in any stack dump. timingPrecision Type String Default low Controls the precision of the timers. High precision will provide better data, but at a lower execution speed. Possible values are high and low. Service element The first child of the configuration element is a service element. The service element configures the agent's connection to the New Relic service. <service licenseKey=\"YOUR_LICENSE_KEY\" sendEnvironmentInfo=\"true\" syncStartup=\"false\" sendDataOnExit=\"false\" sendDataOnExitThreshold=\"60000\" autoStart=\"true\"/> Copy The service element supports the following attributes: licenseKey (required) Type String Default (none) Your New Relic license key. New Relic uses the license key to match your app's data to the correct account in the UI. Set the license key via environment variable. Alternatively, set the NEW_RELIC_LICENSE_KEY environment variable in the application's environment. NEW_RELIC_LICENSE_KEY=XXXXXXXX Copy sendEnvironmentInfo Type Boolean Default true Instructs the agent to record execution environment information. Environment information includes operating system, agent version, and which assemblies are available. syncStartup Type Boolean Default false Block application startup until the agent connects to New Relic. If set to true, the first transaction may take substantially longer to complete, because it is blocked until the connection to New Relic is finished. sendDataOnExit Type Boolean Default false Block application shutdown until the agent sends all data from the latest harvest cycle. sendDataOnExitThreshold Type Integer Default 60000 Unit Milliseconds The minimum amount of time the process must run before the agent blocks it from shutting down. This setting only applies when sendDataOnExit is true. completeTransactionsOnThread Type Boolean Default false If false, the agent uses a pool thread to complete the transaction processing. If true, the agent will complete transaction processing on the request thread. requestTimeout Type Integer Default 2000 (sendDataOnExit enabled) 120000 (sendDataOnExit disabled) Unit Milliseconds The agent's request timeout when communicating with New Relic. autoStart Type Boolean Default True Automatically start the .NET agent when the first instrumented method is hit. ssl (DEPRECATED) Type Boolean Default true The option to disable SSL is valid only for .NET agent versions 7.x and earlier. .NET agent version 8.x and higher communicate only via SSL. The agent communicates with New Relic via HTTPS by default, and New Relic requires HTTPS for all traffic to APM and the New Relic REST API. Obscuring key element The obscuringKey element is an optional child of the service element. The .NET Agent uses this value to deobfuscate supported configuration values. For example, when an obfuscated proxy password is supplied, it will be deobfuscated using this key. <service licenseKey=\"YOUR_LICENSE_KEY\"> <obscuringKey>OBSCURING_KEY</obscuringKey> </service> Copy The obscuring key may also be configured by setting the NEW_RELIC_CONFIG_OBSCURING_KEY environment variable. Caution Security recommendation: The placement of the obscuring Key in the same configuration file as an obfuscated value may pose a security risk. Consider placing the obscuring key in an environment variable and limiting access to environment variables within your environment. Proxy element The proxy element is an optional child of the service element. The proxy element is used when the agent communicates to the New Relic back-end service via a proxy. <service licenseKey=\"YOUR_LICENSE_KEY\"> <proxy host=\"hostname\" port=\"PROXY_PORT\" uriPath=\"path/to/something.aspx\" domain=\"mydomain.com\" user=\"PROXY_USERNAME\" password=\"PROXY_PASSWORD\" passwordObfuscated=\"OBFUSCATED_PROXY_PASSWORD\"/> </service> Copy The proxy element supports the following attributes: host Type String Default (none) Defines the proxy host. port Type Integer Default 8080 Defines the proxy port. uriPath Type String Default (none) Optionally define a proxy URI path. domain Type String Default (none) Optionally define a domain to use when authenticating with the proxy server. user Type String Default (none) Optionally define a user name for authentication. password Type String Default (none) Optionally define a password for authentication. passwordObfuscated Type String Default (none) For additional security, the .NET Agent supports the use of an obfuscated proxy password with the passwordObfuscated attribute. The obfuscated proxy password is generated using the following New Relic CLI command: newrelic agent config obfuscate --key OBSCURING_KEY --value \"CLEAR_TEXT_PROXY_PASSWORD\" Copy Important When using an obfuscated proxy password, the obscuring key must also be configured. Log element The log element is a child of the configuration element. The log element configures New Relic's logging . The agent generates its own log file to keep its logging information separate from your application's logs. <log level=\"info\" auditLog=\"false\" console=\"false\" directory=\"PATH\\TO\\LOG\\DIRECTORY\" fileName=\"FILENAME.log\" /> Copy The log element supports the following attributes: level Type String Default info Defines the level of detail recorded in the log file. Possible values, in increasing order of detail, are: off error warn info debug finest all Important Increasing the log level will increase New Relic's performance impact. auditLog Type Boolean Default false Records all data sent to and received from New Relic in both an auditlog log file and the standard log file. console Type Boolean Default false Send log messages to the console, in addition to the log file. directory Type String Default C:\\ProgramData\\New Relic\\.NET Agent\\Logs The directory to hold log files generated by the agent. If this is omitted, then a directory named logs in the New Relic agent install area will be used by default. fileName Type String Default (none) Defines a name for the log file. If you do not define a fileName, the name is derived from the name of the monitored process. Alternatively, set the NEW_RELIC_LOG environment variable in the application's environment. NEW_RELIC_LOG=MyApp.log Copy Application element (required) The application element is a child of the configuration element. This required element defines your application name, and disables or enables sampling. name Type String Default My Application The name of your .NET application is a child of the application element. New Relic will aggregate your data according to this name. For example, if you have two running applications named AppA and AppB, you will see two applications in the New Relic interface: AppA and AppB. You can also assign up to three names to your app. The first name is the primary name. For example: <application> <name>MY APPLICATION PRIMARY</name> <name>SECOND APP NAME</name> <name>THIRD APP NAME</name> </application> Copy Alternatively, set the NEW_RELIC_APP_NAME environment variable in the application's environment. NEW_RELIC_APP_NAME=Descriptive Name Copy disableSamplers Type Boolean Default false Samplers collect information about memory and CPU consumption. Set this to true to disable sampling. Alternatively, set the NEW_RELIC_DISABLE_SAMPLERS environment variable in the application's environment. NEW_RELIC_DISABLE_SAMPLERS=true Copy Data transmission element The dataTransmission element is a child of the configuration element. This element affects how data is sent to New Relic and can be used if you have specific data transmission requirements. <dataTransmission putForDataSend=\"false\" compressedContentEncoding=\"deflate\"/> Copy The dataTransmission element supports the following attributes: putForDataSend Type Boolean Default false Defines the HTTP method used when sending data to New Relic. Set this to true to enable using the PUT method when sending data. The POST method is used by default. Host name If the default host name label in the APM UI is not useful, you can decorate that name in the New Relic UI with a display name. After the application process is restarted and the .NET agent is reporting again, the display name will appear in the Servers drop-down list. This host name setting does not affect the list of hosts on your application's Summary page. To set a display name, choose one of the following options. The environment variable takes precedence over the config file value. Then restart your application to see your changes in the New Relic UI. Set using config file Set the displayName attribute in the processHost element in newrelic.config. The processHost element is a child of the configuration element. <configuration . . . > <processHost displayName=\"CUSTOM_NAME\" /> </configuration> Copy Set using environment variable Set the NEW_RELIC_PROCESS_HOST_DISPLAY_NAME environment variable: NEW_RELIC_PROCESS_HOST_DISPLAY_NAME = \"CUSTOM_NAME\" Copy Cloud platform utilization Configures the utilization configuration element to control how the agent collects utilization information and sends it to the New Relic service to determine pricing. The agent can collect information from Amazon Web Services (AWS) EC2 instances, Docker containers, Azure, Google Cloud Platform, Pivotal Cloud Foundry, and Kubernetes. detectAws Type Boolean Default true Determines whether the agent polls AWS metadata API. detectAzure Type Boolean Default true Determines whether the agent polls Azure metadata API. detectGcp Type Boolean Default true Determines whether the agent polls GCP metadata API. detectPcf Type Boolean Default true Determines whether the agent polls PCF information from environment variables. detectDocker Type Boolean Default true Determines whether the agent reads Docker information from the file system. detectKubernetes Type Boolean Default true Determines whether the agent polls Kubernetes information from environment variables. Instrumentation options Use these options to configure which elements of your application and environment to instrument. New Relic for .NET supports the following categories of instrumentation options: Instrumentation element Applications element (instrumentation) Attributes element Instrumentation element The instrumentation element is a child of the configuration element. By default, the .NET agent instruments IIS asp worker processes and Azure web and worker roles. To instrument other processes, see Instrumenting custom applications. Applications element (instrumentation) The applications element is a child of the instrumentation element. The applications element specifies which non-web apps to instrument. It contains a name attribute. Important This is not the same as the application (configuration) element, which is a child of the configuration element. <instrumentation> <applications> <application name=\"MyService1.exe\" /> <application name=\"MyService2.exe\" /> <application name=\"MyService3.exe\" /> </applications> </instrumentation> Copy Attributes element An attribute is a key/value pair that determines the properties of an event or transaction. Each attribute is sent to APM transaction traces, APM error traces, Transaction events, TransactionError events, or PageView events. The primary attributes element enables or disables attribute collection for the .NET agent, and defines specific attributes to collect or exclude. You can also configure attribute settings based on their destination: Error collection, transaction traces, Browser instrumentation, and transaction events. In this example, the agent excludes all attributes whose key begins with myApiKey (myApiKey.bar, myApiKey.value), but collects the custom attribute myApiKey.foo. <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> Copy You can view the .NET APM attributes on the .NET agent attributes page. You can also define custom attributes with the agent API call AddCustomParameter. enabled Type Boolean Default true Enable or disable attribute collection. When set to false in the primary attribute element, this setting overrides all attribute settings for individual destinations. include Type String Default (none) If attributes are enabled, the agent will collect all attribute keys specified in this list. To specify multiple attribute keys, specify each individually. You can also use a * wildcard character at the end of a key to match multiple attributes (for example, myApiKey.*). For more information, see Attribute rules. exclude Type String Default (none) If attributes are enabled, the agent will not collect attribute keys specified in this list. To specify multiple attribute keys, specify each individually. You can also use a * wildcard character at the end of a key to match multiple attributes (for example, myApiKey.*). For more information, see Attribute rules. Feature options Use these options to enable, disable, and configure New Relic features. New Relic for .NET allows you to configure the following features: App pools Cross application traces Error collection High security mode Strip exception messages Transaction events Custom events Custom parameters Tags/labels Browser instrumentation Slow Queries Transaction traces Datastore tracer Distributed tracing Span events App pools Important This is only applicable to a system's global config file. The applicationPools element is a child of the configuration element. The applicationPools element specifies for the profiler exactly which application pools to instrument and uses the same name as the IIS application pool name. This configuration element is useful when you may need to instrument only a small subset of your app pools. For example, a given server might have several hundred application pools, but only a few of those pools need to be instrumented by the .NET agent. Here is an example of disabling instrumentation for specific application pools: <applicationPools> <applicationPool name=\"Foo\" instrument=\"false\"/> <applicationPool name=\"Bar\" instrument=\"false\"/> </applicationPools> Copy Here is an example of disabling instrumentation for all application pools currently executing on the server and enabling instrumentation for specific application pools: <applicationPools> <defaultBehavior instrument=\"false\"/> <applicationPool name=\"Foo\" instrument=\"true\"/> <applicationPool name=\"Bar\" instrument=\"true\"/> </applicationPools> Copy The applicationPools element supports the following elements: defaultBehavior Type Boolean Default false Defines how the .NET agent will behave on a \"global\" level for application pools served via IIS. The .NET agent instruments all application pools by default. When true, application pools listed under applicationPool with an instrument attribute set to false will not be instrumented. Essentially, when set to false, the application pool list acts as an allow list. When set to true, the application pool list acts as a deny list. applicationPool Defines instrumentation behavior for a specific application pool. The name attribute is the name of an application pool. Enable or disable profiling in the instrument attribute. Define this application in the name attribute. Cross application traces The crossApplicationTracer element is a child of the configuration element. crossApplicationTracer links transaction traces across applications. When linked in a service-oriented architecture, all instrumented applications that communicate with each other via HTTP will now \"link\" transaction traces with the applications that they call and the applications they are called by. Cross application tracing makes it easier to understand the performance relationship between services and applications. <crossApplicationTracer enabled=\"true\"/> Copy The crossApplicationTracer element supports the following attribute: enabled Type Boolean Default true Enable or disable cross application tracing Error collection The errorCollector element is a child of the configuration element. errorCollector configures error collection, which captures information about uncaught exceptions and sends them to New Relic. <errorCollector enabled=\"true\" captureEvents=\"true\" maxEventSamplesStored=\"100\"> <ignoreClasses> <errorClass>System.IO.FileNotFoundException</errorClass> <errorClass>System.Threading.ThreadAbortException</errorClass> </ignoreClasses> <ignoreMessages> <errorClass name=\"System.Exception\"> <message>Ignore message</message> <message>Ignore too</message> </errorClass> </ignoreMessages> <ignoreStatusCodes> <code>401</code> <code>404</code> </ignoreStatusCodes> <expectedClasses> <errorClass>System.ArgumentNullException</errorClass> <errorClass>System.ArgumentOutOfRangeException</errorClass> </expectedClasses> <expectedMessages> <errorClass name=\"System.Exception\"> <message>Expected message</message> <message>Expected too</message> </errorClass> </expectedMessages> <expectedStatusCodes>403,500-505</expectedStatusCodes> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </errorCollector> Copy Tip For an overview of error configuration in APM, see Manage errors in APM. The errorCollector element supports the following elements and attributes: enabled Type Boolean Default true Enable or disable the error collector. captureEvents Type Boolean Default true Enable or disable the capturing of error events. maxEventSamplesStored Type Integer Default 100 Reservoir limit for error events. ignoreClasses A list of fully qualified class names to be ignored. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used ignoreMessages An optional map of fully qualified class names to list of strings matching a substring of the message of an error. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used ignoreErrors (DEPRECATED) Type String Default (none) Lists specific exceptions to not report to New Relic. The full name of the exception should be used, such as System.IO.FileNotFoundException. ignoreStatusCodes Type String Default (none) Lists specific HTTP error codes to not report to New Relic. You can use standard integral HTTP error codes, such as just 401, or you may use Microsoft full status codes with decimal points, such as 401.4 or 403.18. The status codes should be equal to or greater than 400. expectedClasses A list of fully qualified class names to be marked as expected. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used expectedMessages An optional map of fully qualified class names to list of strings matching a substring of the message of an error. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used expectedStatusCodes A comma separated list of status codes. The list may include integer ranges, using a single dash (-) and will be inclusive of both the starting and ending integer in the range. attributes Use this sub-element to customize your agent attribute settings for error traces. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. High security mode The highSecurity element is a child of the configuration element. To enable high security mode, set this property to true and enable high security property in the New Relic user interface. Enabling high security means SSL is turned on, request parameters and custom parameters are not collected, strip exception messages is enabled, and queries cannot be sent to New Relic in their raw form. enabled Type Boolean Default false Enable or disable high security mode. Example: <highSecurity enabled=\"true\"/> Copy Strip exception messages The stripExceptionMessages element is a child of the configuration element. To enable strip exception messages, set this property to true. By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. enabled Type Boolean Default false Enable or disable strip exception messages. Example: <stripExceptionMessages enabled=\"true\"/> Copy Transaction events The transactionEvents element is a child of the configuration element. Use transactionEvents to configure transaction events. <transactionEvents enabled=\"true\" maximumSamplesStored=\"10000\"> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </transactionEvents> Copy The transactionEvents element supports the following attributes: enabled Type Boolean Default true Enable or disable the event recorder. maximumSamplesStored Type Integer Default 10000 The maximum number of samples to store in memory at once. Alternatively, set the MAX_TRANSACTION_SAMPLES_STORED environment variable in the application's environment. MAX_TRANSACTION_SAMPLES_STORED=500 Copy attributes Use this sub-element to customize your agent attribute settings for transaction events. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. Tip These attribute settings are specific to transaction events. Attribute settings can be applied globally to all event types to with this configuration setting. Caution When distributed tracing and/or Infinite Tracing are enabled, information from transaction events is applied to the root Span Event of the transaction. Consider applying any attribute settings for transaction events to span events and/or apply them as Global Attribute settings. Custom events The customEvents element is a child of the configuration element. Use customEvents to configure custom events. <customEvents enabled=\"true\" maximumSamplesStored=\"10000\"/> Copy The CustomEvents element supports the following attributes: enabled Type Boolean Default true Enable or disable the event recorder. maximumSamplesStored Type Integer Default 10000 The maximum number of samples to store in memory at once. Alternatively, set the MAX_EVENT_SAMPLES_STORED environment variable in the application's environment. MAX_EVENT_SAMPLES_STORED=500 Copy Custom parameters The customParameters element is a child of the configuration element. Use customParameters to configure custom parameters. <customParameters enabled=\"true\" /> Copy The CustomParameters element supports the following attributes: enabled Type Boolean Default true Enable or disable the capture of custom parameters. Labels (tags) The labels element is a child of the configuration element. This sets tag names and values. The list is a semicolon delimited list of colon-separated name and value pairs. You can also use with the NEW_RELIC_LABELS environment variable. Example: <labels>foo:bar;zip:zap</labels> Copy Browser instrumentation The browserMonitoring element is a child of the configuration element. browserMonitoring configures Browser monitoring in your .NET application. Browser gives you insight your end users' performance experience. This is accomplished by measuring the time it takes for your users' browsers to download and render your webpages by injecting a small amount of JavaScript code into the header and footer of each page. // If you use both the Exclude and Attribute elements // the Exclude element must be listed first. <browserMonitoring autoInstrument=\"true\"> <requestPathsExcluded> <path regex=\"url-regex-1\"/> <path regex=\"url-regex-2\"/> ... <path regex=\"url-regex-n\"/> </requestPathsExcluded> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </browserMonitoring> Copy The browserMonitoring element supports the following attributes: autoInstrument Type Boolean Default true By default the agent automatically injects the Browser agent JavaScript. To turn off automatic injection, set this attribute to false. attributes Use this sub-element to customize your agent attribute settings for Browser. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. requestPathsExcluded Use this sub-element to prevent the Browser agent from being injected in specific pages. The element is used as follows: <requestPathsExcluded> <path regex=\"url-regex-1\"/> <path regex=\"url-regex-2\"/> ... <path regex=\"url-regex-n\"/> </requestPathsExcluded> Copy The agent will not inject the Browser agent into pages whose URL matches one of the specified regular expressions. The regular expression should follow Microsoft guidelines for the Regex class. It is a reference to the virtual directory of the path in your application and not the full URL of the path you wish to exclude. For example, to exclude the pages in https://www.mywebsite.com/mywebpages/ you would simply insert /mywebpages/ as the path regex value. The requestPathsExcluded element should be used in cases where it is impossible or undesirable to use the DisableBrowserMonitoring() call. To minimize a possible performance impact try to use as few regular expressions as possible and keep them as simple as possible. Slow queries The slowSql element is a child of the configuration element. slowSql configures capturing information about slow query executions, and captures and obfuscates explain plans for these queries. <slowSql enabled=\"true\"/> Copy The slowSql element supports the following attribute: enabled Type Boolean Default true Enable or disable slow query tracing. Transaction traces The transactionTracer element is a child of the configuration element. transactionTracer configures transaction traces. Included in the trace is the exact call sequence of the transactions, including any query statements issued. <transactionTracer enabled=\"true\" transactionThreshold=\"apdex_f\" recordSql=\"obfuscated\" explainEnabled=\"true\" explainThreshold=\"500\" maxSegments=\"3000\" maxExplainPlans=\"20\"> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </transactionTracer> Copy The transactionTracer element supports the following attributes: enabled Type Boolean Default true Enable or disable transaction traces. transactionThreshold Type String Default apdex_f Defines the threshold for transaction traces. If a transaction takes longer than the threshold, it is eligible for being traced. See transaction trace basics for more about the rules governing traces. The default value is apdex_f, which sets the threshold to four times the application's apdex_t value. For more information about apdex_t, see Apdex. You can also set the threshold to be a specific time value in milliseconds. recordSql Type String Default obfuscated Select a query tracing policy. Options are off, which records nothing; obfuscated, which records an obfuscated version of the query; or raw, which records the query exactly as it is issued to the database. Caution Recording raw queries may capture sensitive information. explainEnabled Type Boolean Default false When true, the agent captures EXPLAIN statements for slow queries. explainThreshold Type Integer Default 500 Unit Milliseconds The agent collects slow query data for queries that exceed this threshold, along with any available explain plans, as part of transaction traces. maxSegments Type Integer Default 3000 The maximum number of segments to collect in a transaction trace. maxExplainPlans Type Integer Default 20 The maximum number of explain plans to collect during a harvest cycle. attributes Use this sub-element to customize your agent attribute settings for transaction traces. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. Datastore tracer The datastoreTracer element is a child of the configuration element. <datastoreTracer> <instanceReporting enabled=\"true\" /> <databaseNameReporting enabled=\"true\" /> <queryParameters enabled=\"false\" /> </datastoreTracer> Copy The datastoreTracer element supports the following sub-elements: instanceReporting Use this sub-element to enable collection of datastore instance metrics (such as the host and port) for some database drivers. These are reported on slow query traces and transaction traces. The default value of attribute enabled is true. databaseNameReporting Use this sub-element to enable collection of the database name on slow query traces and transaction traces for some database drivers. The default value of attribute enabled is true. queryParameters Use this sub-element to enable collection of the SQL query parameters on slow query traces. The default value of attribute enabled is false. Caution Recording query parameters may capture sensitive information. The transactionTracer.recordSql configuration option must be set to raw or this option is ignored. Distributed tracing The distributedTracing element is a child of the configuration element. <distributedTracing enabled=\"false\" excludeNewrelicHeader=\"false\"/> Copy Distributed tracing lets you see the path that a request takes as it travels through a distributed system. Enabling distributed tracing disables cross application tracing, and has other effects on APM features. Before enabling, read the planning guide. Important Requires .NET agent version 8.6.45.0 or higher. The distributedTracing element supports the following attributes: To enable or disable, see Enable distributed tracing. enabled Type Boolean Default false Alternatively, enable distributed tracing via the NEW_RELIC_DISTRIBUTED_TRACING_ENABLED environment variable in the application's environment. NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true Copy excludeNewrelicHeader Type Boolean Default false By default, supported versions of the agent utilize both the newrelic header and W3C Trace Context headers for distributed tracing. The newrelic distributed tracing header allows interoperability with older agents that don't support W3C Trace Context headers. Agent versions that support W3C Trace Context headers will prioritize them over newrelic headers for distributed tracing. If you do not want to utilize the newrelic header, setting this to true will result in the agent excluding the newrelic header and only using W3C Trace Context headers for distributed tracing. Distributed tracing reports span events. Span event reporting is enabled by default, but distributed tracing must be enabled for spans to be reported. To disable span events, choose one of the following options: Disable span events via config file Set the <spanEvents> element to false to disable via the newrelic.config file. This element is a child of the <configuration> element. <configuration . . . > <spanEvents enabled=\"false\" /> </configuration> Copy Disable span events via environment variable Set the NEW_RELIC_SPAN_EVENTS_ENABLED environment variable in the application's environment. NEW_RELIC_SPAN_EVENTS_ENABLED=false Copy Infinite Tracing Infinite Tracing extends the distributed tracing service by employing a trace observer that is external to the agent. It observes 100% of your application traces across various services and provides actionable data so you can solve issues faster. Important Infinite Tracing requires .NET Agent version 8.30 or higher. To turn on Infinite Tracing, enable distributed tracing and add the additional settings below <configuration . . . > <distributedTracing enabled=\"true\" /> <infiniteTracing> <trace_observer host=\"YOUR_TRACE_OBSERVER_HOST\" /> </infiniteTracing> </configuration> Copy The infiniteTracing element supports the following elements: trace_observer The trace_observer element identifies an observer host that is independent from the agent. For help getting a valid Infinite Tracing trace observer host entry, see Find or create a trace observer endpoint. The trace observer may be configured using the NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST environment variable as well. Important When configuring the trace observer, you should not supply the protocol as part of the host. For example, use myhost.infinitetracing.com instead of https://myhost.infinitetracing.com. Span events The spanEvents element is a child of the configuration element. Use spanEvents to configure span events. <spanEvents enabled=\"true\"> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </spanEvents> Copy The spanEvents element supports the following attributes: enabled Type Boolean Default true Enable or disable the event recorder. attributes Use this sub-element to customize your agent attribute settings for span events. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. Tip These attribute settings are specific to span events. Attribute settings may be applied globally to all event types to with this configuration setting. Settings in app.config or web.config For ASP.NET and .NET Framework console apps you can also configure the following settings in your app's app.config or web.config, within the outermost element, <configuration>: Enable and disable the agent <appSettings> <add key = \"NewRelic.AgentEnabled\" value=\"false\" /> </appSettings> Copy Important If the agent is disabled in the local or global newrelic.config, the NewRelic.AgentEnabled settings in these files will be ignored. Application name For more information, see Name your .NET application. <appSettings> <add key = \"NewRelic.AppName\" value =\"Descriptive Name\" /> </appSettings> Copy License key <appSettings> <add key = \"NewRelic.LicenseKey\" value =\"XXXXXXXX\" /> </appSettings> Copy Change newrelic.config location Designates an alternative location for the config file outside of the local root of the app or global config location. The location entered must be an absolute path. <appSettings> <add key = \"NewRelic.ConfigFile\" value=\"C:\\Path-to-alternate-config-dir\\newrelic.config\" /> </appSettings> Copy Settings in appsettings.json For .NET Core apps, you can configure the following settings in appsettings.json if the following is true: The appsettings.json file must be located in the current working directory of the application. The application must have the following dependencies: Microsoft.Extensions.Configuration Microsoft.Extensions.Configuration.Json Microsoft.Extensions.Configuration.EnvironmentVariables Enable and disable the agent { \"NewRelic.AgentEnabled\":\"false\" } Copy Important If the agent is disabled in the local or global newrelic.config, the NewRelic.AgentEnabled setting in this file will be ignored. Application name For more information, see Name your .NET application. { \"NewRelic.AppName\": \"Descriptive Name\" } Copy License key { \"NewRelic.LicenseKey\": \"XXXXXXXX\" } Copy Change newrelic.config location Designates an alternative location for the config file outside of the local root of the app or global config location. The location entered must be an absolute path. { \"NewRelic.ConfigFile\": \"C:\\\\Path-to-alternate-config-dir\\\\newrelic.config\" } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 102.31112,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> <em>configuration</em>",
        "sections": ".<em>NET</em> <em>agent</em> <em>configuration</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "This document contains the <em>configuration</em> options for the APM .<em>NET</em> <em>agent</em>. <em>Configuration</em> overview APM <em>agent</em> <em>configuration</em> options allow you to control some aspects of how the <em>agent</em> behaves. Some of these config options are part of the basic install process (like setting your license key and app name"
      },
      "id": "60446c3b196a679d6a960f7a"
    },
    {
      "sections": [
        "Go agent configuration",
        "Configuration methods and precedence",
        "Server-side configuration (2.7.0 or higher)",
        "Caution",
        "In process newrelic.Config struct",
        "Change configuration settings",
        "General configuration settings",
        "License (REQUIRED)",
        "AppName (REQUIRED)",
        "Enabled",
        "Labels",
        "Creating four tag pairs",
        "Logger",
        "HighSecurity",
        "Important",
        "UseTLS (DEPRECATED)",
        "HostDisplayName",
        "Transport",
        "RuntimeSampler.Enabled",
        "Custom events configuration",
        "CustomInsightsEvents.Enabled",
        "Transaction events configuration",
        "TransactionEvents.Enabled",
        "TransactionEvents.Attributes",
        "TransactionEvents.MaxSamplesStored",
        "Error collector configuration",
        "Tip",
        "ErrorCollector.Enabled",
        "ErrorCollector.CaptureEvents",
        "ErrorCollector.IgnoreStatusCodes",
        "Example of ignoring error code",
        "ErrorCollector.Attributes",
        "Transaction tracer configuration",
        "TransactionTracer.Enabled",
        "TransactionTracer.Threshold.IsApdexFailing",
        "TransactionTracer.Threshold.Duration",
        "TransactionTracer.Segments.Threshold",
        "TransactionTracer.Segments.Attributes",
        "TransactionTracer.Segments.StackTraceThreshold",
        "TransactionTracer.Attributes",
        "Datastore tracer configuration",
        "DatastoreTracer.InstanceReporting.Enabled",
        "DatastoreTracer.NameReporting.Enabled",
        "DatastoreTracer.QueryParameters.Enabled",
        "DatastoreTracer.SlowQuery.Enabled",
        "DatastoreTracer.SlowQuery.Threshold",
        "Cross application tracing configuration",
        "CrossApplicationTracer.Enabled",
        "Distributed tracing configuration",
        "DistributedTracer.Enabled",
        "DistributedTracer.ExcludeNewRelicHeader",
        "Span events configuration",
        "SpanEvents.Enabled",
        "SpanEvents.Attributes",
        "Infinite Tracing configuration",
        "InfiniteTracing.TraceObserver.Host"
      ],
      "title": "Go agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "Go agent",
        "Configuration"
      ],
      "external_id": "78afde07a4ba5544693cf4465a6e4add240ca2be",
      "image": "https://docs.newrelic.com/static/0ba97f20e12a085ba9ec9d472c59b5b5/9fc4b/go-config-precedence.png",
      "url": "https://docs.newrelic.com/docs/agents/go-agent/configuration/go-agent-configuration/",
      "published_at": "2021-06-02T17:38:42Z",
      "updated_at": "2021-06-02T17:38:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can edit configuration settings for the Go agent to control some aspects of how New Relic monitors your app; for example: Turn high-security mode on. Add custom tags for filtering and sorting in the UI. Turn off the collection of errors, transaction events, transaction traces, and custom events. Configuration methods and precedence The primary way to configure the Go agent is by modifying the newrelic.Config struct as part of calling newrelic.NewApplication(), which is part of the standard installation process. With Go agent versions 2.7.0 or higher, you can also set a limited number of configuration options using server-side configuration in the UI. The Go agent follows this order of precedence for configuration. If enabled, server-side configuration overrides all corresponding values in the newrelic.Config struct, even if the server-side values are left blank. If server-side configuration is enabled with the Go agent, it overrides all corresponding values in the newrelic.Config struct, even if the server-side values are left blank. Here are detailed descriptions of each configuration method: Server-side configuration (2.7.0 or higher) Server-side configuration is available with Go agent versions 2.7.0 or higher. This allows you to configure certain settings in the UI. This applies your changes automatically to all agents even if they run across multiple hosts. Where available, this document includes the UI labels for server-side config under individual config options as the Server-side label. You must still call newrelic.NewApplication() in your application process following the steps described in the in-process configuration. Configuration options set server-side will overwrite those set locally. Since not all configuration options are available server side, you may want to still update your newrelic.Config struct. Caution If server-side config is enabled, the agent ignores any value in the newrelic.Config struct that could be set in the UI. Even if the UI value is empty, the agent treats this as an empty value and does not use the newrelic.Config value. In process newrelic.Config struct You configure your Go agent from the local in process newrelic.Config struct. This struct can be accessed when calling newrelic.NewApplication(). Add the following in the main function or in an init block: app, err := newrelic.NewApplication( newrelic.ConfigAppName(\"Your Application Name\"), newrelic.ConfigLicense(\"__YOUR_NEW_RELIC_LICENSE_KEY__\"), ) Copy Update values on the newrelic.Config struct to configure your application using newrelic.ConfigOptions. These are functions that accept a pointer to the newrelic.Config struct. Add additional newrelic.ConfigOptions to further configure your application. For example, you can use one of the predefined options to do common configurations: app, err := newrelic.NewApplication( newrelic.ConfigAppName(\"Your Application Name\"), newrelic.ConfigLicense(\"__YOUR_NEW_RELIC_LICENSE_KEY__\"), // add debug level logging to stdout newrelic.ConfigDebugLogger(os.Stdout), ) Copy Or, you can create your own newrelic.ConfigOption to do more complex configurations: app, err := newrelic.NewApplication( newrelic.ConfigAppName(\"Your Application Name\"), newrelic.ConfigLicense(\"__YOUR_NEW_RELIC_LICENSE_KEY__\"), newrelic.ConfigDebugLogger(os.Stdout), func(config *newrelic.Config) { // add more specific configuration of the agent within a custom ConfigOption config.HighSecurity = true config.CrossApplicationTracer.Enabled = false }, ) Copy Change configuration settings To make Go agent configuration changes, set the values in the newrelic.Config struct from within a custom newrelic.ConfigOption. For example, to turn New Relic monitoring off temporarily for testing purposes, change the Enabled value to false: app, err := newrelic.NewApplication( newrelic.ConfigAppName(\"Your Application Name\"), newrelic.ConfigLicense(\"__YOUR_NEW_RELIC_LICENSE_KEY__\"), func(config *newrelic.Config) { config.Enabled = false }, ) Copy In this and the following examples, config represents your New Relic config struct, although you may have given it a different variable name when you installed the Go agent and initiated the configuration in your app. General configuration settings License (REQUIRED) Type String Default (none) Set in newrelic.Config struct Specifies your New Relic license key, used to associate your app's metrics with your New Relic account. The license and the app name are both set as part of the New Relic installation process. AppName (REQUIRED) Type String Default (none) Set in newrelic.Config struct This is the application name used to aggregate data in the New Relic UI. You set both the license and the app name as part of the New Relic installation process. To report data to multiple apps at the same time, specify a list of names separated with a semicolon. Do not put a space before the semicolon itself. For example: app, err := newrelic.NewApplication( newrelic.ConfigAppName(\"YOUR_APP_NAME;APP_GROUP_1;ALL_APPS\"), newrelic.ConfigLicense(\"__YOUR_NEW_RELIC_LICENSE_KEY__\"), ) Copy Enabled Type Boolean Default true Set in newrelic.Config struct When true, the agent sends data from your app to the New Relic collector. To turn off New Relic monitoring, set this to false. For example: app, err := newrelic.NewApplication( newrelic.ConfigAppName(\"Your Application Name\"), newrelic.ConfigLicense(\"__YOUR_NEW_RELIC_LICENSE_KEY__\"), func(config *newrelic.Config) { config.Enabled = false }, ) Copy This can be useful for installing New Relic in a development environment or for troubleshooting purposes. When Enabled is set to false: The New Relic Go agent will not communicate with the New Relic collector. The agent will not spawn goroutines. The license key is not required during installation. Labels Type map [ string]string Default (none) Set in newrelic.Config struct Add tags. Creating four tag pairs Here's an example of setting four tags: app, err := newrelic.NewApplication( newrelic.ConfigAppName(\"Your Application Name\"), newrelic.ConfigLicense(\"__YOUR_NEW_RELIC_LICENSE_KEY__\"), func(config *newrelic.Config) { config.Labels := map[string]string{ \"Env\": \"Dev\", \"Label2\": \"label2\", \"Label3\": \"label3\", \"Label4\": \"label4\", } }, ) Copy Logger Type Interface Default (none) Set in newrelic.Config struct You can use the Logger interface to write Go log files to a specific location or logging system. HighSecurity Type Boolean Default false Set in newrelic.Config struct Important This feature requires Enterprise tier. High security mode enforces certain security settings and prevents them from being overridden, so that the agent sends no sensitive data. High security mode does the following: Turns SSL on Turns off reporting of error message strings Turns off reporting of custom events This setting must match the corresponding account setting in the UI. For example: app, err := newrelic.NewApplication( newrelic.ConfigAppName(\"Your Application Name\"), newrelic.ConfigLicense(\"__YOUR_NEW_RELIC_LICENSE_KEY__\"), func(config *newrelic.Config) { config.HighSecurity = true }, ) Copy The agent communicates with New Relic via HTTPS by default, and New Relic requires HTTPS for all traffic to APM and our REST API. UseTLS (DEPRECATED) Type Boolean Default true Set in newrelic.Config struct Important This option was removed in agent version 2.0. Controls whether HTTPS or HTTP is used to send data to New Relic. The agent communicates with New Relic via HTTPS by default (which uses TLS protocol), and New Relic requires HTTPS for all traffic to APM and the New Relic REST API. HostDisplayName Type String Default (none) Set in newrelic.Config struct This sets the hostname displayed in the APM UI. This is an optional configuration. Transport Type http.RoundTripper Default (none) Set in newrelic.Config struct This customizes http.Client communication with New Relic collectors. This can be used to configure a proxy. RuntimeSampler.Enabled Type Boolean Default true Set in newrelic.Config struct When true, the agent captures runtime statistics. Custom events configuration You can create custom events and make them available for querying and analysis. CustomInsightsEvents.Enabled Type Boolean Default true Set in newrelic.Config struct When true, the agent sends custom events to New Relic. This setting is overridden by HighSecurity, which disables custom events. To disable custom events, place the following in your Go app after the New Relic config is initiated: app, err := newrelic.NewApplication( newrelic.ConfigAppName(\"Your Application Name\"), newrelic.ConfigLicense(\"__YOUR_NEW_RELIC_LICENSE_KEY__\"), func(config *newrelic.Config) { config.CustomInsightsEvents.Enabled = false }, ) Copy Transaction events configuration Transaction events are used in collecting events corresponding to web requests and background tasks. Event data allows the New Relic UI to show additional information such as histograms and percentiles. TransactionEvents.Enabled Type Boolean Default true Set in newrelic.Config struct When true, the agent collects transaction events. TransactionEvents.Attributes Type Struct Default Enabled, no exclusions Set in newrelic.Config struct TransactionEvents.Attributes is a struct with three fields: Enabled bool Include []string Exclude []string Copy Use TransactionEvents.Attributes.Enabled to turn attribute collection on or off for transaction events. Use Include and Exclude to include or exclude specific attributes. An example of excluding an attribute slice named allAgentAttributeNames from transaction events: app, err := newrelic.NewApplication( newrelic.ConfigAppName(\"Your Application Name\"), newrelic.ConfigLicense(\"__YOUR_NEW_RELIC_LICENSE_KEY__\"), func(config *newrelic.Config) { config.TransactionEvents.Attributes.Exclude = allAgentAttributeNames }, ) Copy TransactionEvents.MaxSamplesStored Type Integer Default 10000 Set in newrelic.Config struct Defines the maximum number of transaction events per minute to be sent to New Relic, up to the default maximum of 10,000 transaction events. Error collector configuration The following settings are used to configure the error collector: Tip For an overview of error configuration in New Relic, see Manage errors in APM. ErrorCollector.Enabled Type Boolean Default true Set in newrelic.Config struct, Server-side config Server-side label Error Collection on/off When false, the agent collects no errors or error traces. ErrorCollector.CaptureEvents Type Boolean Default true Set in newrelic.Config struct When true, the agent collects error analytic events. ErrorCollector.IgnoreStatusCodes Type Integer Default Error codes 399 and below, and 404, are ignored. Set in newrelic.Config struct, Server-side config Server-side label Error Collection: Ignore from error collection This controls which HTTP response codes are ignored as errors. Response codes that are greater than or equal to 100 and strictly less than 400 are ignored by default and never have to be specified when calling this function. Response codes 0, 5, and 404 are included on the list by default, but must be specified when adding to the ignore list. This function's default form is: config.ErrorCollector.IgnoreStatusCodes = []int{ 0, // gRPC OK 5, // gRPC NOT_FOUND http.StatusNotFound, // 404 } Copy You can also add response codes as HTTPs, as http.StatusNotFound above. Important If used, server-side configuration will override any values set on the newrelic.Config struct. Therefore to ignore 404 when server-side configuration is enabled, you must include 404 in the configuration set in the UI. Example of ignoring error code To add HTTP response code 418 to the default ignore list, which includes 0, 5, and 404: app, err := newrelic.NewApplication( newrelic.ConfigAppName(\"Your Application Name\"), newrelic.ConfigLicense(\"__YOUR_NEW_RELIC_LICENSE_KEY__\"), func(config *newrelic.Config) { config.ErrorCollector.IgnoreStatusCodes = []int{0, 5, 404, 418} }, ) Copy ErrorCollector.Attributes Type Struct Default Enabled, no exclusions Set in newrelic.Config struct ErrorCollector.Attributes is a struct with three fields: Enabled bool Include []string Exclude []string Copy Use ErrorCollector.Attributes.Enabled to turn attribute collection on or off for errors. Use Include and Exclude to include or exclude specific attributes. An example of excluding an attribute slice named allAgentAttributeNames from errors: app, err := newrelic.NewApplication( newrelic.ConfigAppName(\"Your Application Name\"), newrelic.ConfigLicense(\"__YOUR_NEW_RELIC_LICENSE_KEY__\"), func(config *newrelic.Config) { config.ErrorCollector.Attributes.Exclude = allAgentAttributeNames }, ) Copy Transaction tracer configuration Here are settings for changing transaction tracer configuration. For more information about transaction traces, see Transaction traces. TransactionTracer.Enabled Type Boolean Default true Set in newrelic.Config struct, Server-side config Server-side label Transaction Tracing on/off When true, the agent collects transaction traces (detailed information about slow transactions). TransactionTracer.Threshold.IsApdexFailing Type Boolean Default true Set in newrelic.Config struct, Server-side config Server-side label Transaction Tracing: Threshold Controls whether the transaction trace threshold is based on Apdex. If true, then the trace threshold is four times the Apdex threshold. If false, the agent uses Threshold.Duration as the transaction trace threshold. TransactionTracer.Threshold.Duration Type time.Millisecond Default 500 Set in newrelic.Config struct, Server-side config Server-side label Transaction Tracing: Threshold If Threshold.IsApdexFailing is set to false, the agent uses this duration as the transaction trace threshold. TransactionTracer.Segments.Threshold Type time.Millisecond Default 2 Set in newrelic.Config struct This is the threshold at which segments will be added to the trace. TransactionTracer.Segments.Attributes Important Available for Go agent version 2.6.0 or higher. Type Struct Default Enabled, no exclusions Set in newrelic.Config struct TransactionTracer.Segments.Attributes is a struct with three fields: Enabled bool Include []string Exclude []string Copy Use TransactionTracer.Segments.Attributes.Enabled to turn attribute collection on or off for transaction trace segments. Use Include and Exclude to include or exclude specific attributes. An example of excluding an attribute slice named allSegmentAttributeNames from traces: app, err := newrelic.NewApplication( newrelic.ConfigAppName(\"Your Application Name\"), newrelic.ConfigLicense(\"__YOUR_NEW_RELIC_LICENSE_KEY__\"), func(config *newrelic.Config) { config.TransactionTracer.Segments.Attributes.Exclude = allSegmentAttributeNames }, ) Copy TransactionTracer.Segments.StackTraceThreshold Type time.Millisecond Default 500 Set in newrelic.Config struct, Server-side config Server-side label Transaction Tracing: Stack trace threshold This is the threshold at which segments will be given a stack trace in the transaction trace. Caution Lowering this setting may drastically increase agent overhead. TransactionTracer.Attributes Type Struct Default Enabled, no exclusions Set in newrelic.Config struct TransactionTracer.Attributes is a struct with three fields: Enabled bool Include []string Exclude []string Copy Use TransactionTracer.Attributes.Enabled to turn attribute collection on or off for transaction traces. Use Include and Exclude to include or exclude specific attributes. An example of excluding an attribute slice named allAgentAttributeNames from traces: app, err := newrelic.NewApplication( newrelic.ConfigAppName(\"Your Application Name\"), newrelic.ConfigLicense(\"__YOUR_NEW_RELIC_LICENSE_KEY__\"), func(config *newrelic.Config) { config.TransactionTracer.Attributes.Exclude = allAgentAttributeNames }, ) Copy Datastore tracer configuration Here are datastore settings, including slow query enabling and settings. DatastoreTracer.InstanceReporting.Enabled Type Boolean Default true Set in newrelic.Config struct This enables collection of datastore instance metrics (such as the host and port) for some database drivers. These are reported on transaction traces and as part of slow query data. DatastoreTracer.NameReporting.Enabled Type Boolean Default true Set in newrelic.Config struct Use this to enable collection of the database name on slow query traces and transaction traces. The default value of attribute enabled is true. DatastoreTracer.QueryParameters.Enabled Type Boolean Default true Set in newrelic.Config struct When true, the agent collects datastore call query parameters. DatastoreTracer.SlowQuery.Enabled Type Boolean Default true Set in newrelic.Config struct Controls whether slow queries are captured. DatastoreTracer.SlowQuery.Threshold Type time.Millisecond Default 10 Set in newrelic.Config struct The agent captures slow query data for queries slower than this. Cross application tracing configuration Here are settings for changing the cross application tracing feature. CrossApplicationTracer.Enabled Type Boolean Default true Set in newrelic.Config struct, Server-side config Server-side label Cross-application tracing on/off When true, the agent will add cross application tracing headers in outbound requests, and scan incoming requests for cross application tracing headers. Distributed tracing and cross application tracing cannot be used simultaneously. The default configuration for the Go agent disables distributed tracing and enables cross application tracing. Distributed tracing configuration Important Enabling distributed tracing requires Go agent version 2.1.0 or higher, and it disables cross application tracing. It also has effects on other features. Before enabling, read the transition guide. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. When distributed tracing is enabled, you can collect span events. DistributedTracer.Enabled Type Boolean Default false Set in newrelic.Config struct When true, the agent will add distributed tracing headers in outbound requests, and scan incoming requests for distributed tracing headers. Enabling distributed tracing disables cross application tracing. DistributedTracer.ExcludeNewRelicHeader Type Boolean Default false Set in newrelic.Config struct Set this to true to exclude the New Relic header that is attached to outbound requests, and instead only rely on W3C Trace Context Headers for distributed tracing. If this is false then both types of headers are used. Span events configuration Span events are reported for distributed tracing. Distributed tracing must be enabled to report span events. These settings control the collection of span events: SpanEvents.Enabled Type Boolean Default true Set in newrelic.Config struct When true, the agent will collect span events. SpanEvents.Attributes Important Available for Go agent version 2.6.0 or higher. Type Struct Default Enabled, no exclusions Set in newrelic.Config struct SpanEvents.Attributes is a struct with three fields: Enabled bool Include []string Exclude []string Copy Use SpanEvents.Attributes.Enabled to enable or disable attribute collection for span events. Use Include and Exclude to include or exclude specific attributes. An example of excluding an attribute slice named allSpanAttributeNames from traces: app, err := newrelic.NewApplication( newrelic.ConfigAppName(\"Your Application Name\"), newrelic.ConfigLicense(\"__YOUR_NEW_RELIC_LICENSE_KEY__\"), func(config *newrelic.Config) { config.TransactionTracer.Segments.Attributes.Exclude = allSpanAttributeNames }, ) Copy Infinite Tracing configuration To enable Infinite Tracing, enable distributed tracing (set config.DistributedTracer.Enabled = true on the newrelic.Config struct) and add the additional settings below. For an example, see Language agents: Configure distributed tracing. InfiniteTracing.TraceObserver.Host Type string Default (none) Set in newrelic.Config struct For help getting a valid Infinite Tracing trace observer host entry, see Find or create a trace observer endpoint.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 97.484985,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Go <em>agent</em> <em>configuration</em>",
        "sections": "Go <em>agent</em> <em>configuration</em>",
        "tags": "<em>Agents</em>",
        "body": "You can edit <em>configuration</em> settings for the Go <em>agent</em> to control some aspects of how New Relic monitors your app; for example: Turn high-security mode on. Add custom tags for filtering and sorting in the UI. Turn off the collection of errors, transaction events, transaction traces, and custom events"
      },
      "id": "6043f24028ccbcbed32c609e"
    }
  ],
  "/docs/agents/net-agent/configuration/net-agent-configuration": [
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.67384,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Agents</em>",
        "body": " called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following <em>agents</em> support the addition of custom user attributes to span events: Java <em>agent</em> 5.13.0 and above Go <em>agent</em> 3.6.0 and above .<em>NET</em> <em>agent</em> 8.25 and above Node"
      },
      "id": "603eb9db28ccbc127aeba79e"
    },
    {
      "sections": [
        "Go agent configuration",
        "Configuration methods and precedence",
        "Server-side configuration (2.7.0 or higher)",
        "Caution",
        "In process newrelic.Config struct",
        "Change configuration settings",
        "General configuration settings",
        "License (REQUIRED)",
        "AppName (REQUIRED)",
        "Enabled",
        "Labels",
        "Creating four tag pairs",
        "Logger",
        "HighSecurity",
        "Important",
        "UseTLS (DEPRECATED)",
        "HostDisplayName",
        "Transport",
        "RuntimeSampler.Enabled",
        "Custom events configuration",
        "CustomInsightsEvents.Enabled",
        "Transaction events configuration",
        "TransactionEvents.Enabled",
        "TransactionEvents.Attributes",
        "TransactionEvents.MaxSamplesStored",
        "Error collector configuration",
        "Tip",
        "ErrorCollector.Enabled",
        "ErrorCollector.CaptureEvents",
        "ErrorCollector.IgnoreStatusCodes",
        "Example of ignoring error code",
        "ErrorCollector.Attributes",
        "Transaction tracer configuration",
        "TransactionTracer.Enabled",
        "TransactionTracer.Threshold.IsApdexFailing",
        "TransactionTracer.Threshold.Duration",
        "TransactionTracer.Segments.Threshold",
        "TransactionTracer.Segments.Attributes",
        "TransactionTracer.Segments.StackTraceThreshold",
        "TransactionTracer.Attributes",
        "Datastore tracer configuration",
        "DatastoreTracer.InstanceReporting.Enabled",
        "DatastoreTracer.NameReporting.Enabled",
        "DatastoreTracer.QueryParameters.Enabled",
        "DatastoreTracer.SlowQuery.Enabled",
        "DatastoreTracer.SlowQuery.Threshold",
        "Cross application tracing configuration",
        "CrossApplicationTracer.Enabled",
        "Distributed tracing configuration",
        "DistributedTracer.Enabled",
        "DistributedTracer.ExcludeNewRelicHeader",
        "Span events configuration",
        "SpanEvents.Enabled",
        "SpanEvents.Attributes",
        "Infinite Tracing configuration",
        "InfiniteTracing.TraceObserver.Host"
      ],
      "title": "Go agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "Go agent",
        "Configuration"
      ],
      "external_id": "78afde07a4ba5544693cf4465a6e4add240ca2be",
      "image": "https://docs.newrelic.com/static/0ba97f20e12a085ba9ec9d472c59b5b5/9fc4b/go-config-precedence.png",
      "url": "https://docs.newrelic.com/docs/agents/go-agent/configuration/go-agent-configuration/",
      "published_at": "2021-06-02T17:38:42Z",
      "updated_at": "2021-06-02T17:38:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can edit configuration settings for the Go agent to control some aspects of how New Relic monitors your app; for example: Turn high-security mode on. Add custom tags for filtering and sorting in the UI. Turn off the collection of errors, transaction events, transaction traces, and custom events. Configuration methods and precedence The primary way to configure the Go agent is by modifying the newrelic.Config struct as part of calling newrelic.NewApplication(), which is part of the standard installation process. With Go agent versions 2.7.0 or higher, you can also set a limited number of configuration options using server-side configuration in the UI. The Go agent follows this order of precedence for configuration. If enabled, server-side configuration overrides all corresponding values in the newrelic.Config struct, even if the server-side values are left blank. If server-side configuration is enabled with the Go agent, it overrides all corresponding values in the newrelic.Config struct, even if the server-side values are left blank. Here are detailed descriptions of each configuration method: Server-side configuration (2.7.0 or higher) Server-side configuration is available with Go agent versions 2.7.0 or higher. This allows you to configure certain settings in the UI. This applies your changes automatically to all agents even if they run across multiple hosts. Where available, this document includes the UI labels for server-side config under individual config options as the Server-side label. You must still call newrelic.NewApplication() in your application process following the steps described in the in-process configuration. Configuration options set server-side will overwrite those set locally. Since not all configuration options are available server side, you may want to still update your newrelic.Config struct. Caution If server-side config is enabled, the agent ignores any value in the newrelic.Config struct that could be set in the UI. Even if the UI value is empty, the agent treats this as an empty value and does not use the newrelic.Config value. In process newrelic.Config struct You configure your Go agent from the local in process newrelic.Config struct. This struct can be accessed when calling newrelic.NewApplication(). Add the following in the main function or in an init block: app, err := newrelic.NewApplication( newrelic.ConfigAppName(\"Your Application Name\"), newrelic.ConfigLicense(\"__YOUR_NEW_RELIC_LICENSE_KEY__\"), ) Copy Update values on the newrelic.Config struct to configure your application using newrelic.ConfigOptions. These are functions that accept a pointer to the newrelic.Config struct. Add additional newrelic.ConfigOptions to further configure your application. For example, you can use one of the predefined options to do common configurations: app, err := newrelic.NewApplication( newrelic.ConfigAppName(\"Your Application Name\"), newrelic.ConfigLicense(\"__YOUR_NEW_RELIC_LICENSE_KEY__\"), // add debug level logging to stdout newrelic.ConfigDebugLogger(os.Stdout), ) Copy Or, you can create your own newrelic.ConfigOption to do more complex configurations: app, err := newrelic.NewApplication( newrelic.ConfigAppName(\"Your Application Name\"), newrelic.ConfigLicense(\"__YOUR_NEW_RELIC_LICENSE_KEY__\"), newrelic.ConfigDebugLogger(os.Stdout), func(config *newrelic.Config) { // add more specific configuration of the agent within a custom ConfigOption config.HighSecurity = true config.CrossApplicationTracer.Enabled = false }, ) Copy Change configuration settings To make Go agent configuration changes, set the values in the newrelic.Config struct from within a custom newrelic.ConfigOption. For example, to turn New Relic monitoring off temporarily for testing purposes, change the Enabled value to false: app, err := newrelic.NewApplication( newrelic.ConfigAppName(\"Your Application Name\"), newrelic.ConfigLicense(\"__YOUR_NEW_RELIC_LICENSE_KEY__\"), func(config *newrelic.Config) { config.Enabled = false }, ) Copy In this and the following examples, config represents your New Relic config struct, although you may have given it a different variable name when you installed the Go agent and initiated the configuration in your app. General configuration settings License (REQUIRED) Type String Default (none) Set in newrelic.Config struct Specifies your New Relic license key, used to associate your app's metrics with your New Relic account. The license and the app name are both set as part of the New Relic installation process. AppName (REQUIRED) Type String Default (none) Set in newrelic.Config struct This is the application name used to aggregate data in the New Relic UI. You set both the license and the app name as part of the New Relic installation process. To report data to multiple apps at the same time, specify a list of names separated with a semicolon. Do not put a space before the semicolon itself. For example: app, err := newrelic.NewApplication( newrelic.ConfigAppName(\"YOUR_APP_NAME;APP_GROUP_1;ALL_APPS\"), newrelic.ConfigLicense(\"__YOUR_NEW_RELIC_LICENSE_KEY__\"), ) Copy Enabled Type Boolean Default true Set in newrelic.Config struct When true, the agent sends data from your app to the New Relic collector. To turn off New Relic monitoring, set this to false. For example: app, err := newrelic.NewApplication( newrelic.ConfigAppName(\"Your Application Name\"), newrelic.ConfigLicense(\"__YOUR_NEW_RELIC_LICENSE_KEY__\"), func(config *newrelic.Config) { config.Enabled = false }, ) Copy This can be useful for installing New Relic in a development environment or for troubleshooting purposes. When Enabled is set to false: The New Relic Go agent will not communicate with the New Relic collector. The agent will not spawn goroutines. The license key is not required during installation. Labels Type map [ string]string Default (none) Set in newrelic.Config struct Add tags. Creating four tag pairs Here's an example of setting four tags: app, err := newrelic.NewApplication( newrelic.ConfigAppName(\"Your Application Name\"), newrelic.ConfigLicense(\"__YOUR_NEW_RELIC_LICENSE_KEY__\"), func(config *newrelic.Config) { config.Labels := map[string]string{ \"Env\": \"Dev\", \"Label2\": \"label2\", \"Label3\": \"label3\", \"Label4\": \"label4\", } }, ) Copy Logger Type Interface Default (none) Set in newrelic.Config struct You can use the Logger interface to write Go log files to a specific location or logging system. HighSecurity Type Boolean Default false Set in newrelic.Config struct Important This feature requires Enterprise tier. High security mode enforces certain security settings and prevents them from being overridden, so that the agent sends no sensitive data. High security mode does the following: Turns SSL on Turns off reporting of error message strings Turns off reporting of custom events This setting must match the corresponding account setting in the UI. For example: app, err := newrelic.NewApplication( newrelic.ConfigAppName(\"Your Application Name\"), newrelic.ConfigLicense(\"__YOUR_NEW_RELIC_LICENSE_KEY__\"), func(config *newrelic.Config) { config.HighSecurity = true }, ) Copy The agent communicates with New Relic via HTTPS by default, and New Relic requires HTTPS for all traffic to APM and our REST API. UseTLS (DEPRECATED) Type Boolean Default true Set in newrelic.Config struct Important This option was removed in agent version 2.0. Controls whether HTTPS or HTTP is used to send data to New Relic. The agent communicates with New Relic via HTTPS by default (which uses TLS protocol), and New Relic requires HTTPS for all traffic to APM and the New Relic REST API. HostDisplayName Type String Default (none) Set in newrelic.Config struct This sets the hostname displayed in the APM UI. This is an optional configuration. Transport Type http.RoundTripper Default (none) Set in newrelic.Config struct This customizes http.Client communication with New Relic collectors. This can be used to configure a proxy. RuntimeSampler.Enabled Type Boolean Default true Set in newrelic.Config struct When true, the agent captures runtime statistics. Custom events configuration You can create custom events and make them available for querying and analysis. CustomInsightsEvents.Enabled Type Boolean Default true Set in newrelic.Config struct When true, the agent sends custom events to New Relic. This setting is overridden by HighSecurity, which disables custom events. To disable custom events, place the following in your Go app after the New Relic config is initiated: app, err := newrelic.NewApplication( newrelic.ConfigAppName(\"Your Application Name\"), newrelic.ConfigLicense(\"__YOUR_NEW_RELIC_LICENSE_KEY__\"), func(config *newrelic.Config) { config.CustomInsightsEvents.Enabled = false }, ) Copy Transaction events configuration Transaction events are used in collecting events corresponding to web requests and background tasks. Event data allows the New Relic UI to show additional information such as histograms and percentiles. TransactionEvents.Enabled Type Boolean Default true Set in newrelic.Config struct When true, the agent collects transaction events. TransactionEvents.Attributes Type Struct Default Enabled, no exclusions Set in newrelic.Config struct TransactionEvents.Attributes is a struct with three fields: Enabled bool Include []string Exclude []string Copy Use TransactionEvents.Attributes.Enabled to turn attribute collection on or off for transaction events. Use Include and Exclude to include or exclude specific attributes. An example of excluding an attribute slice named allAgentAttributeNames from transaction events: app, err := newrelic.NewApplication( newrelic.ConfigAppName(\"Your Application Name\"), newrelic.ConfigLicense(\"__YOUR_NEW_RELIC_LICENSE_KEY__\"), func(config *newrelic.Config) { config.TransactionEvents.Attributes.Exclude = allAgentAttributeNames }, ) Copy TransactionEvents.MaxSamplesStored Type Integer Default 10000 Set in newrelic.Config struct Defines the maximum number of transaction events per minute to be sent to New Relic, up to the default maximum of 10,000 transaction events. Error collector configuration The following settings are used to configure the error collector: Tip For an overview of error configuration in New Relic, see Manage errors in APM. ErrorCollector.Enabled Type Boolean Default true Set in newrelic.Config struct, Server-side config Server-side label Error Collection on/off When false, the agent collects no errors or error traces. ErrorCollector.CaptureEvents Type Boolean Default true Set in newrelic.Config struct When true, the agent collects error analytic events. ErrorCollector.IgnoreStatusCodes Type Integer Default Error codes 399 and below, and 404, are ignored. Set in newrelic.Config struct, Server-side config Server-side label Error Collection: Ignore from error collection This controls which HTTP response codes are ignored as errors. Response codes that are greater than or equal to 100 and strictly less than 400 are ignored by default and never have to be specified when calling this function. Response codes 0, 5, and 404 are included on the list by default, but must be specified when adding to the ignore list. This function's default form is: config.ErrorCollector.IgnoreStatusCodes = []int{ 0, // gRPC OK 5, // gRPC NOT_FOUND http.StatusNotFound, // 404 } Copy You can also add response codes as HTTPs, as http.StatusNotFound above. Important If used, server-side configuration will override any values set on the newrelic.Config struct. Therefore to ignore 404 when server-side configuration is enabled, you must include 404 in the configuration set in the UI. Example of ignoring error code To add HTTP response code 418 to the default ignore list, which includes 0, 5, and 404: app, err := newrelic.NewApplication( newrelic.ConfigAppName(\"Your Application Name\"), newrelic.ConfigLicense(\"__YOUR_NEW_RELIC_LICENSE_KEY__\"), func(config *newrelic.Config) { config.ErrorCollector.IgnoreStatusCodes = []int{0, 5, 404, 418} }, ) Copy ErrorCollector.Attributes Type Struct Default Enabled, no exclusions Set in newrelic.Config struct ErrorCollector.Attributes is a struct with three fields: Enabled bool Include []string Exclude []string Copy Use ErrorCollector.Attributes.Enabled to turn attribute collection on or off for errors. Use Include and Exclude to include or exclude specific attributes. An example of excluding an attribute slice named allAgentAttributeNames from errors: app, err := newrelic.NewApplication( newrelic.ConfigAppName(\"Your Application Name\"), newrelic.ConfigLicense(\"__YOUR_NEW_RELIC_LICENSE_KEY__\"), func(config *newrelic.Config) { config.ErrorCollector.Attributes.Exclude = allAgentAttributeNames }, ) Copy Transaction tracer configuration Here are settings for changing transaction tracer configuration. For more information about transaction traces, see Transaction traces. TransactionTracer.Enabled Type Boolean Default true Set in newrelic.Config struct, Server-side config Server-side label Transaction Tracing on/off When true, the agent collects transaction traces (detailed information about slow transactions). TransactionTracer.Threshold.IsApdexFailing Type Boolean Default true Set in newrelic.Config struct, Server-side config Server-side label Transaction Tracing: Threshold Controls whether the transaction trace threshold is based on Apdex. If true, then the trace threshold is four times the Apdex threshold. If false, the agent uses Threshold.Duration as the transaction trace threshold. TransactionTracer.Threshold.Duration Type time.Millisecond Default 500 Set in newrelic.Config struct, Server-side config Server-side label Transaction Tracing: Threshold If Threshold.IsApdexFailing is set to false, the agent uses this duration as the transaction trace threshold. TransactionTracer.Segments.Threshold Type time.Millisecond Default 2 Set in newrelic.Config struct This is the threshold at which segments will be added to the trace. TransactionTracer.Segments.Attributes Important Available for Go agent version 2.6.0 or higher. Type Struct Default Enabled, no exclusions Set in newrelic.Config struct TransactionTracer.Segments.Attributes is a struct with three fields: Enabled bool Include []string Exclude []string Copy Use TransactionTracer.Segments.Attributes.Enabled to turn attribute collection on or off for transaction trace segments. Use Include and Exclude to include or exclude specific attributes. An example of excluding an attribute slice named allSegmentAttributeNames from traces: app, err := newrelic.NewApplication( newrelic.ConfigAppName(\"Your Application Name\"), newrelic.ConfigLicense(\"__YOUR_NEW_RELIC_LICENSE_KEY__\"), func(config *newrelic.Config) { config.TransactionTracer.Segments.Attributes.Exclude = allSegmentAttributeNames }, ) Copy TransactionTracer.Segments.StackTraceThreshold Type time.Millisecond Default 500 Set in newrelic.Config struct, Server-side config Server-side label Transaction Tracing: Stack trace threshold This is the threshold at which segments will be given a stack trace in the transaction trace. Caution Lowering this setting may drastically increase agent overhead. TransactionTracer.Attributes Type Struct Default Enabled, no exclusions Set in newrelic.Config struct TransactionTracer.Attributes is a struct with three fields: Enabled bool Include []string Exclude []string Copy Use TransactionTracer.Attributes.Enabled to turn attribute collection on or off for transaction traces. Use Include and Exclude to include or exclude specific attributes. An example of excluding an attribute slice named allAgentAttributeNames from traces: app, err := newrelic.NewApplication( newrelic.ConfigAppName(\"Your Application Name\"), newrelic.ConfigLicense(\"__YOUR_NEW_RELIC_LICENSE_KEY__\"), func(config *newrelic.Config) { config.TransactionTracer.Attributes.Exclude = allAgentAttributeNames }, ) Copy Datastore tracer configuration Here are datastore settings, including slow query enabling and settings. DatastoreTracer.InstanceReporting.Enabled Type Boolean Default true Set in newrelic.Config struct This enables collection of datastore instance metrics (such as the host and port) for some database drivers. These are reported on transaction traces and as part of slow query data. DatastoreTracer.NameReporting.Enabled Type Boolean Default true Set in newrelic.Config struct Use this to enable collection of the database name on slow query traces and transaction traces. The default value of attribute enabled is true. DatastoreTracer.QueryParameters.Enabled Type Boolean Default true Set in newrelic.Config struct When true, the agent collects datastore call query parameters. DatastoreTracer.SlowQuery.Enabled Type Boolean Default true Set in newrelic.Config struct Controls whether slow queries are captured. DatastoreTracer.SlowQuery.Threshold Type time.Millisecond Default 10 Set in newrelic.Config struct The agent captures slow query data for queries slower than this. Cross application tracing configuration Here are settings for changing the cross application tracing feature. CrossApplicationTracer.Enabled Type Boolean Default true Set in newrelic.Config struct, Server-side config Server-side label Cross-application tracing on/off When true, the agent will add cross application tracing headers in outbound requests, and scan incoming requests for cross application tracing headers. Distributed tracing and cross application tracing cannot be used simultaneously. The default configuration for the Go agent disables distributed tracing and enables cross application tracing. Distributed tracing configuration Important Enabling distributed tracing requires Go agent version 2.1.0 or higher, and it disables cross application tracing. It also has effects on other features. Before enabling, read the transition guide. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. When distributed tracing is enabled, you can collect span events. DistributedTracer.Enabled Type Boolean Default false Set in newrelic.Config struct When true, the agent will add distributed tracing headers in outbound requests, and scan incoming requests for distributed tracing headers. Enabling distributed tracing disables cross application tracing. DistributedTracer.ExcludeNewRelicHeader Type Boolean Default false Set in newrelic.Config struct Set this to true to exclude the New Relic header that is attached to outbound requests, and instead only rely on W3C Trace Context Headers for distributed tracing. If this is false then both types of headers are used. Span events configuration Span events are reported for distributed tracing. Distributed tracing must be enabled to report span events. These settings control the collection of span events: SpanEvents.Enabled Type Boolean Default true Set in newrelic.Config struct When true, the agent will collect span events. SpanEvents.Attributes Important Available for Go agent version 2.6.0 or higher. Type Struct Default Enabled, no exclusions Set in newrelic.Config struct SpanEvents.Attributes is a struct with three fields: Enabled bool Include []string Exclude []string Copy Use SpanEvents.Attributes.Enabled to enable or disable attribute collection for span events. Use Include and Exclude to include or exclude specific attributes. An example of excluding an attribute slice named allSpanAttributeNames from traces: app, err := newrelic.NewApplication( newrelic.ConfigAppName(\"Your Application Name\"), newrelic.ConfigLicense(\"__YOUR_NEW_RELIC_LICENSE_KEY__\"), func(config *newrelic.Config) { config.TransactionTracer.Segments.Attributes.Exclude = allSpanAttributeNames }, ) Copy Infinite Tracing configuration To enable Infinite Tracing, enable distributed tracing (set config.DistributedTracer.Enabled = true on the newrelic.Config struct) and add the additional settings below. For an example, see Language agents: Configure distributed tracing. InfiniteTracing.TraceObserver.Host Type string Default (none) Set in newrelic.Config struct For help getting a valid Infinite Tracing trace observer host entry, see Find or create a trace observer endpoint.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 97.48489,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Go <em>agent</em> <em>configuration</em>",
        "sections": "Go <em>agent</em> <em>configuration</em>",
        "tags": "<em>Agents</em>",
        "body": "You can edit <em>configuration</em> settings for the Go <em>agent</em> to control some aspects of how New Relic monitors your app; for example: Turn high-security mode on. Add custom tags for filtering and sorting in the UI. Turn off the collection of errors, transaction events, transaction traces, and custom events"
      },
      "id": "6043f24028ccbcbed32c609e"
    },
    {
      "sections": [
        "Name your .NET application",
        "Set your app name (recommended method)",
        "Other methods",
        "Important",
        "Steps",
        "Use multiple app names",
        "Newrelic.config file",
        "Web.config file",
        "App.config file"
      ],
      "title": "Name your .NET application",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Configuration"
      ],
      "external_id": "5f3a2ac4de57b1dc5ca028fa1f73abb647089391",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/configuration/name-your-net-application/",
      "published_at": "2021-06-02T17:51:59Z",
      "updated_at": "2021-03-16T14:46:28Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent gives you several ways to change the application name reported and displayed in APM. This document gives you an overview of those naming options. For a general overview of APM app naming (not .NET-specific), see Name your application. To change an application's name without breaking data continuity, use the UI alias-change option. Set your app name (recommended method) When you first deploy your app, you can change the default name to a more descriptive one. Since New Relic collects metrics using these names, customizing them allows you to run the same application on multiple hosts and get metrics from all their instances. Typically, configuring your app-local newrelic.config file is the most convenient naming method. Naming method Description Recommended: Configure your app-local newrelic.config file This method lets you give your app a unique name with specific configuration settings. It also works for both IIS and non-IIS hosted apps. Copy the newrelic.config file from the agent home directory into your app's root folder. Default: %ALLUSERSPROFILE%\\New Relic\\.NET Agent Open the copy and set your app name as follows: <application> <name> App Name </name> </application> Copy Restart your application. As long as your app is active, data should appear within a few minutes. If not, follow our troubleshooting procedures. Other methods If you have a specific use or purpose in mind, you may prefer a different naming method. Here's a full list of the alternative methods: Important Some methods take precedence over others. Before choosing a naming method, make sure you understand how your configurations may be affected. Naming method Description Configure your web.config file If you have apps hosted on IIS and prefer not to have a local newrelic.config file, you can configure the naming settings in your web.config file. Steps For .NET Framework apps: Add the following entry to the appSettings section of your file, and then restart your application. <appSettings> <add key = \"NewRelic.AppName\" value = \"App Name\" /> </appSettings> Copy For .NET Core apps: Add the NEW_RELIC_APP_NAME environment variable to your file as follows, and then restart your application. <aspNetCore processPath=\"dotnet\" arguments=\".\\MyApp.dll\" stdoutLogEnabled=\"false\" stdoutLogFile=\".\\logs\\stdout\" hostingModel=\"InProcess\" > <environmentVariables> <environmentVariable name=\"NEW_RELIC_APP_NAME\" value=\"App Name\" /> </environmentVariables> </aspNetCore> Copy Set app name using environment variables If you want to easily set app names during the deployment of containers, set an environment variable in the application's environment. Steps Set the environmental variable NEW_RELIC_APP_NAME in your application's environment: NEW_RELIC_APP_NAME = \"App name\" Copy Important This method only works if you're using .NET agent version 6.17.387.0 or higher. Name after app pools If your IIS application pools already have unique names you like, or if you're using a shared network content infrastructure (SNCI), you can name your app after its assigned app pool. Steps Remove any NewRelic.AppName keys from the <appSettings> section in web.config. Make sure not to delete the surrounding <appSettings> tags. Remove any <name> child elements from the <application> parent element in newrelic.config. Make sure not to delete the surrounding <application> tags. Each app will then report according to its app pool name. Configure your app.config file If you have applications not hosted on IIS and prefer not to have a local newrelic.config file, you can configure the naming settings in your app.config file. Steps Add the following entry to your app.config file (for example, applicationname.exe.config), and then restart your application. <appSettings> <add key = \"NewRelic.AppName\" value = \"App Name\" /> </appSettings> Copy Use the .NET agent API If you want to rename your app programmatically, you can use the SetApplicationName() agent API call to set the app name at run time. This name will take priority over all other application naming sources. As long as your app is active, data should appear within a few minutes. If not, make sure you've performed an IISRESET from an administrative command prompt if you've changed your .NET app's configuration file (newrelic.config or app.config). Otherwise, follow our troubleshooting procedures. Use multiple app names You can use multiple app names to aggregate data from your applications. We sometimes call this \"rolling up\" your data. For the .NET agent, you can set up to three application names. The first name is the primary application name, and the second and third names are used for the more general data aggregation categories. For more about how multiple app names work, see Use multiple app names. Newrelic.config file Here's an example of setting multiple names in your app-local newrelic.config file: <application> <name>Primary App Name</name> <name>Second App Name</name> <name>Third App Name</name> </application> Copy Web.config file Here's an example of setting multiple names in your web.config file: <appSettings> <add key=\"NewRelic.AppName\" value=\"App Name, App Name 2, App Name 3\" /> </appSettings> Copy App.config file Here's an example of setting multiple names in your app.config file: <appSettings> <add key=\"NewRelic.AppName\" value=\"App Name, App Name 2, App Name 3\" / </appSettings> Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 80.807434,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Name your .<em>NET</em> application",
        "sections": "Name your .<em>NET</em> application",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " <em>configuration</em> settings. It also works for both IIS and non-IIS hosted apps. Copy the newrelic.config file from the <em>agent</em> home directory into your app&#x27;s root folder. Default: %ALLUSERSPROFILE%\\New Relic\\.<em>NET</em> <em>Agent</em> Open the copy and set your app name as follows: &lt;application&gt; &lt;name&gt; App Name &lt;&#x2F;name"
      },
      "id": "603ec833196a6793d5a83db2"
    }
  ],
  "/docs/agents/net-agent/custom-instrumentation/add-detail-transactions-xml-net": [
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "68ae52e48b04bfe2279bcd038778cc5eebf53d1d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-06-02T17:53:04Z",
      "updated_at": "2021-05-15T18:25:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.48181,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Custom</em> <em>instrumentation</em> via attributes (.<em>NET</em>)",
        "sections": "<em>Custom</em> <em>instrumentation</em> via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> provides several options for <em>custom</em> <em>instrumentation</em>. <em>Custom</em> <em>instrumentation</em> allows you to <em>instrument</em> parts of your app that are not instrumented automatically. This document describes how to <em>instrument</em> your app by decorating the methods in your app code with attributes. Use"
      },
      "id": "6043cd9528ccbcfe1e2c60aa"
    },
    {
      "sections": [
        "Introduction to .NET custom instrumentation",
        "Important",
        "Choose a method of custom instrumentation",
        "Creating transactions vs. adding detail",
        "Classify as \"web\" or \"non-web\" (attribute method only)"
      ],
      "title": "Introduction to .NET custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "7c00fa1a58c9c0818e21c28797eec710b0e8dbce",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/custom-instrumentation/introduction-net-custom-instrumentation/",
      "published_at": "2021-06-02T17:53:04Z",
      "updated_at": "2021-03-11T06:46:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For fully supported frameworks (.NET Framework | .NET Core), the New Relic .NET agent automatically collects and reports information on web transactions and browser tasks. However, if you are using an application framework that isn't automatically instrumented (or not using a framework) you may see large blocks of time in the New Relic UI lacking detail, or you may not see any transactions. In this case, you can use custom instrumentation to add transactions and detail. This document describes how to instrument activity that is not instrumented by the .NET agent by default. For other ways of configuring your app's instrumentation, see Guide to using the .NET agent API. Important For both of the agent's supported frameworks (.NET Framework and .NET Core), custom instrumentation is done the same way, unless otherwise stated. Choose a method of custom instrumentation The .NET agent supports two methods of custom instrumentation: Method Description Attribute custom instrumentation Instrument your code by decorating your methods with an attribute. Attribute instrumentation is simpler to implement than XML instrumentation because you only need to add a single decorator, in the same place in your code as the method you want to instrument. For instructions, see Custom instrumentation via attributes. XML custom instrumentation Instrument your code by listing the target methods in an XML file. XML instrumentation is more complex than attribute instrumentation, and it will fail if you change the name of the assembly, class, or method you want to instrument. However, XML instrumentation does not require you to modify your source code. For instructions, see Create transactions via XML and Add detail to transactions via XML. Creating transactions vs. adding detail When you add custom instrumentation via either method, you need to choose between creating a new transaction and adding instrumentation to an existing transaction: Situation Recommendation The method you want to instrument does not appear in the New Relic UI at all Create a new transaction. For details, see: Custom instrumentation via attributes Create transactions via XML The transaction appears in the New Relic UI but contains sections of uninstrumented time Add detail to an existing transaction. For details, see: Custom instrumentation via attributes Add detail to transactions via XML Classify as \"web\" or \"non-web\" (attribute method only) APM separates transactions into web transactions and non-web transactions in the UI. When you add detail to an existing transaction, its category is determined by the category of the parent transaction. When you create a transaction via custom instrumentation using the attribute method, you must categorize it as web or non-web. (This is not possible with XML instrumentation; all XML-created transactions are classified as non-web.) Category When to use Web Use web for web requests. You can only mark new transactions as web transactions with custom instrumentation using attributes, not by using XML. Non-web Use non-web for other types of background requests, such as console apps and services. All transactions created using XML are classified as non-web. Transactions created using attributes can be classified either as web or non-web.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.56323,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to .<em>NET</em> <em>custom</em> <em>instrumentation</em>",
        "sections": "Introduction to .<em>NET</em> <em>custom</em> <em>instrumentation</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " large blocks of time in the New Relic UI lacking detail, or you may not see any transactions. In this case, you can use <em>custom</em> <em>instrumentation</em> to add transactions and detail. This document describes how to <em>instrument</em> activity that is not instrumented by the .<em>NET</em> <em>agent</em> by default. For other ways"
      },
      "id": "6043d1f8196a6778ee960f2f"
    },
    {
      "sections": [
        "APM agent security: Java",
        "Default security settings",
        "Caution",
        "High security mode settings",
        "Custom security settings"
      ],
      "title": "APM agent security: Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "fd9f5744c001453dbb9f129480f4e7e5ce42a176",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/apm-agent-security-java/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives, you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see Java agent error configuration. By default, here is how the New Relic Java agent handles the following potentially sensitive data:: Request parameters: The agent does not capture HTTP request parameters. HTTPS: The agent communicates with New Relic using HTTPS. SQL: The agent sets SQL recording to obfuscated, which removes the potentially sensitive numeric and string literal values. High security mode settings When you enable high security mode, the default settings are locked so that users cannot change them. In addition: The agent does not collect message queue parameters. You cannot create custom events. You cannot implement custom instrumentation using the Custom Instrumentation Editor. You cannot collect user attributes. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: Java agent configuration file Custom attributes Java agent API Setting Effects on data security audit_mode boolean Default: false By default, the Java agent does not log all data sent to New Relic in the agent log file. If you set this to true, the agent logs data sent to the New Relic collector in the agent log file. You can then evaluate the information that the agent sends by reviewing the agent log file to see if it includes sensitive information. high_security boolean Default: false To enable high security mode, set this to true and enable high security in New Relic. This restricts the information you can send to New Relic. proxy_host string Default: (none) Some proxies default to using HTTP, which is a less secure protocol. attributes.enabled boolean Default: true Default for the Custom Instrumentation Editor: false By default, you are sending attributes to New Relic, except for methods instrumented using the Custom Instrumentation Editor. If you do not want to send attributes to New Relic, set this to false. attributes.exclude string Default: (none) If there are specific attribute keys that you do not want to send to New Relic in transaction traces, identify them using attributes.exclude. This restricts the information sent to New Relic. Consider if you want to exclude these potentially sensitive attributes using attributes.exclude or if you need the information sent to New Relic: request.headers.*: Removes all request headers. (Note that HTTP headers that contain sensitive data such as cookie and authorization are never collected.) response.headers.*: Removes all response headers. request_uri: Removes the path for the transaction's incoming request. log_sql boolean Default: false By default, you are sending queries to New Relic using record_sql. If you want to log queries in the agent log file as well as send them to New Relic, set this to true. record_sql string Default: obfuscated By default, record_sql is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to off. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. strip_exception_messages boolean Default: false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. If you are not using high security mode but still want to strip messages from all exceptions except those in your allow list, set this to true. custom_insights_events.enabled boolean Default: true By default, the agent records events sent to the Event API via recordCustomEvent(). If you enable high security mode, this is automatically set to false.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.55765,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>agent</em> security: Java",
        "sections": "APM <em>agent</em> security: Java",
        "tags": "<em>Agents</em>",
        "body": " enable high security mode, the default settings are locked so that users cannot change them. In addition: The <em>agent</em> does not collect message queue parameters. You cannot create <em>custom</em> events. You cannot implement <em>custom</em> <em>instrumentation</em> using the <em>Custom</em> <em>Instrumentation</em> Editor. You cannot collect user"
      },
      "id": "6043b8bb28ccbc3db92c60b7"
    }
  ],
  "/docs/agents/net-agent/custom-instrumentation/create-transactions-xml-net": [
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "68ae52e48b04bfe2279bcd038778cc5eebf53d1d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-06-02T17:53:04Z",
      "updated_at": "2021-05-15T18:25:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.48178,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Custom</em> <em>instrumentation</em> via attributes (.<em>NET</em>)",
        "sections": "<em>Custom</em> <em>instrumentation</em> via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> provides several options for <em>custom</em> <em>instrumentation</em>. <em>Custom</em> <em>instrumentation</em> allows you to <em>instrument</em> parts of your app that are not instrumented automatically. This document describes how to <em>instrument</em> your app by decorating the methods in your app code with attributes. Use"
      },
      "id": "6043cd9528ccbcfe1e2c60aa"
    },
    {
      "sections": [
        "Introduction to .NET custom instrumentation",
        "Important",
        "Choose a method of custom instrumentation",
        "Creating transactions vs. adding detail",
        "Classify as \"web\" or \"non-web\" (attribute method only)"
      ],
      "title": "Introduction to .NET custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "7c00fa1a58c9c0818e21c28797eec710b0e8dbce",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/custom-instrumentation/introduction-net-custom-instrumentation/",
      "published_at": "2021-06-02T17:53:04Z",
      "updated_at": "2021-03-11T06:46:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For fully supported frameworks (.NET Framework | .NET Core), the New Relic .NET agent automatically collects and reports information on web transactions and browser tasks. However, if you are using an application framework that isn't automatically instrumented (or not using a framework) you may see large blocks of time in the New Relic UI lacking detail, or you may not see any transactions. In this case, you can use custom instrumentation to add transactions and detail. This document describes how to instrument activity that is not instrumented by the .NET agent by default. For other ways of configuring your app's instrumentation, see Guide to using the .NET agent API. Important For both of the agent's supported frameworks (.NET Framework and .NET Core), custom instrumentation is done the same way, unless otherwise stated. Choose a method of custom instrumentation The .NET agent supports two methods of custom instrumentation: Method Description Attribute custom instrumentation Instrument your code by decorating your methods with an attribute. Attribute instrumentation is simpler to implement than XML instrumentation because you only need to add a single decorator, in the same place in your code as the method you want to instrument. For instructions, see Custom instrumentation via attributes. XML custom instrumentation Instrument your code by listing the target methods in an XML file. XML instrumentation is more complex than attribute instrumentation, and it will fail if you change the name of the assembly, class, or method you want to instrument. However, XML instrumentation does not require you to modify your source code. For instructions, see Create transactions via XML and Add detail to transactions via XML. Creating transactions vs. adding detail When you add custom instrumentation via either method, you need to choose between creating a new transaction and adding instrumentation to an existing transaction: Situation Recommendation The method you want to instrument does not appear in the New Relic UI at all Create a new transaction. For details, see: Custom instrumentation via attributes Create transactions via XML The transaction appears in the New Relic UI but contains sections of uninstrumented time Add detail to an existing transaction. For details, see: Custom instrumentation via attributes Add detail to transactions via XML Classify as \"web\" or \"non-web\" (attribute method only) APM separates transactions into web transactions and non-web transactions in the UI. When you add detail to an existing transaction, its category is determined by the category of the parent transaction. When you create a transaction via custom instrumentation using the attribute method, you must categorize it as web or non-web. (This is not possible with XML instrumentation; all XML-created transactions are classified as non-web.) Category When to use Web Use web for web requests. You can only mark new transactions as web transactions with custom instrumentation using attributes, not by using XML. Non-web Use non-web for other types of background requests, such as console apps and services. All transactions created using XML are classified as non-web. Transactions created using attributes can be classified either as web or non-web.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.56323,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to .<em>NET</em> <em>custom</em> <em>instrumentation</em>",
        "sections": "Introduction to .<em>NET</em> <em>custom</em> <em>instrumentation</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " large blocks of time in the New Relic UI lacking detail, or you may not see any transactions. In this case, you can use <em>custom</em> <em>instrumentation</em> to add transactions and detail. This document describes how to <em>instrument</em> activity that is not instrumented by the .<em>NET</em> <em>agent</em> by default. For other ways"
      },
      "id": "6043d1f8196a6778ee960f2f"
    },
    {
      "sections": [
        "APM agent security: Java",
        "Default security settings",
        "Caution",
        "High security mode settings",
        "Custom security settings"
      ],
      "title": "APM agent security: Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "fd9f5744c001453dbb9f129480f4e7e5ce42a176",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/apm-agent-security-java/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives, you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see Java agent error configuration. By default, here is how the New Relic Java agent handles the following potentially sensitive data:: Request parameters: The agent does not capture HTTP request parameters. HTTPS: The agent communicates with New Relic using HTTPS. SQL: The agent sets SQL recording to obfuscated, which removes the potentially sensitive numeric and string literal values. High security mode settings When you enable high security mode, the default settings are locked so that users cannot change them. In addition: The agent does not collect message queue parameters. You cannot create custom events. You cannot implement custom instrumentation using the Custom Instrumentation Editor. You cannot collect user attributes. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: Java agent configuration file Custom attributes Java agent API Setting Effects on data security audit_mode boolean Default: false By default, the Java agent does not log all data sent to New Relic in the agent log file. If you set this to true, the agent logs data sent to the New Relic collector in the agent log file. You can then evaluate the information that the agent sends by reviewing the agent log file to see if it includes sensitive information. high_security boolean Default: false To enable high security mode, set this to true and enable high security in New Relic. This restricts the information you can send to New Relic. proxy_host string Default: (none) Some proxies default to using HTTP, which is a less secure protocol. attributes.enabled boolean Default: true Default for the Custom Instrumentation Editor: false By default, you are sending attributes to New Relic, except for methods instrumented using the Custom Instrumentation Editor. If you do not want to send attributes to New Relic, set this to false. attributes.exclude string Default: (none) If there are specific attribute keys that you do not want to send to New Relic in transaction traces, identify them using attributes.exclude. This restricts the information sent to New Relic. Consider if you want to exclude these potentially sensitive attributes using attributes.exclude or if you need the information sent to New Relic: request.headers.*: Removes all request headers. (Note that HTTP headers that contain sensitive data such as cookie and authorization are never collected.) response.headers.*: Removes all response headers. request_uri: Removes the path for the transaction's incoming request. log_sql boolean Default: false By default, you are sending queries to New Relic using record_sql. If you want to log queries in the agent log file as well as send them to New Relic, set this to true. record_sql string Default: obfuscated By default, record_sql is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to off. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. strip_exception_messages boolean Default: false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. If you are not using high security mode but still want to strip messages from all exceptions except those in your allow list, set this to true. custom_insights_events.enabled boolean Default: true By default, the agent records events sent to the Event API via recordCustomEvent(). If you enable high security mode, this is automatically set to false.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.55755,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>agent</em> security: Java",
        "sections": "APM <em>agent</em> security: Java",
        "tags": "<em>Agents</em>",
        "body": " enable high security mode, the default settings are locked so that users cannot change them. In addition: The <em>agent</em> does not collect message queue parameters. You cannot create <em>custom</em> events. You cannot implement <em>custom</em> <em>instrumentation</em> using the <em>Custom</em> <em>Instrumentation</em> Editor. You cannot collect user"
      },
      "id": "6043b8bb28ccbc3db92c60b7"
    }
  ],
  "/docs/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net": [
    {
      "sections": [
        "Introduction to .NET custom instrumentation",
        "Important",
        "Choose a method of custom instrumentation",
        "Creating transactions vs. adding detail",
        "Classify as \"web\" or \"non-web\" (attribute method only)"
      ],
      "title": "Introduction to .NET custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "7c00fa1a58c9c0818e21c28797eec710b0e8dbce",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/custom-instrumentation/introduction-net-custom-instrumentation/",
      "published_at": "2021-06-02T17:53:04Z",
      "updated_at": "2021-03-11T06:46:54Z",
      "document_type": "page",
      "popularity": 1,
      "body": "For fully supported frameworks (.NET Framework | .NET Core), the New Relic .NET agent automatically collects and reports information on web transactions and browser tasks. However, if you are using an application framework that isn't automatically instrumented (or not using a framework) you may see large blocks of time in the New Relic UI lacking detail, or you may not see any transactions. In this case, you can use custom instrumentation to add transactions and detail. This document describes how to instrument activity that is not instrumented by the .NET agent by default. For other ways of configuring your app's instrumentation, see Guide to using the .NET agent API. Important For both of the agent's supported frameworks (.NET Framework and .NET Core), custom instrumentation is done the same way, unless otherwise stated. Choose a method of custom instrumentation The .NET agent supports two methods of custom instrumentation: Method Description Attribute custom instrumentation Instrument your code by decorating your methods with an attribute. Attribute instrumentation is simpler to implement than XML instrumentation because you only need to add a single decorator, in the same place in your code as the method you want to instrument. For instructions, see Custom instrumentation via attributes. XML custom instrumentation Instrument your code by listing the target methods in an XML file. XML instrumentation is more complex than attribute instrumentation, and it will fail if you change the name of the assembly, class, or method you want to instrument. However, XML instrumentation does not require you to modify your source code. For instructions, see Create transactions via XML and Add detail to transactions via XML. Creating transactions vs. adding detail When you add custom instrumentation via either method, you need to choose between creating a new transaction and adding instrumentation to an existing transaction: Situation Recommendation The method you want to instrument does not appear in the New Relic UI at all Create a new transaction. For details, see: Custom instrumentation via attributes Create transactions via XML The transaction appears in the New Relic UI but contains sections of uninstrumented time Add detail to an existing transaction. For details, see: Custom instrumentation via attributes Add detail to transactions via XML Classify as \"web\" or \"non-web\" (attribute method only) APM separates transactions into web transactions and non-web transactions in the UI. When you add detail to an existing transaction, its category is determined by the category of the parent transaction. When you create a transaction via custom instrumentation using the attribute method, you must categorize it as web or non-web. (This is not possible with XML instrumentation; all XML-created transactions are classified as non-web.) Category When to use Web Use web for web requests. You can only mark new transactions as web transactions with custom instrumentation using attributes, not by using XML. Non-web Use non-web for other types of background requests, such as console apps and services. All transactions created using XML are classified as non-web. Transactions created using attributes can be classified either as web or non-web.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.56323,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to .<em>NET</em> <em>custom</em> <em>instrumentation</em>",
        "sections": "Introduction to .<em>NET</em> <em>custom</em> <em>instrumentation</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " large blocks of time in the New Relic UI lacking detail, or you may not see any transactions. In this case, you can use <em>custom</em> <em>instrumentation</em> to add transactions and detail. This document describes how to <em>instrument</em> activity that is not instrumented by the .<em>NET</em> <em>agent</em> by default. For other ways"
      },
      "id": "6043d1f8196a6778ee960f2f"
    },
    {
      "sections": [
        "APM agent security: Java",
        "Default security settings",
        "Caution",
        "High security mode settings",
        "Custom security settings"
      ],
      "title": "APM agent security: Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "fd9f5744c001453dbb9f129480f4e7e5ce42a176",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/apm-agent-security-java/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives, you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see Java agent error configuration. By default, here is how the New Relic Java agent handles the following potentially sensitive data:: Request parameters: The agent does not capture HTTP request parameters. HTTPS: The agent communicates with New Relic using HTTPS. SQL: The agent sets SQL recording to obfuscated, which removes the potentially sensitive numeric and string literal values. High security mode settings When you enable high security mode, the default settings are locked so that users cannot change them. In addition: The agent does not collect message queue parameters. You cannot create custom events. You cannot implement custom instrumentation using the Custom Instrumentation Editor. You cannot collect user attributes. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: Java agent configuration file Custom attributes Java agent API Setting Effects on data security audit_mode boolean Default: false By default, the Java agent does not log all data sent to New Relic in the agent log file. If you set this to true, the agent logs data sent to the New Relic collector in the agent log file. You can then evaluate the information that the agent sends by reviewing the agent log file to see if it includes sensitive information. high_security boolean Default: false To enable high security mode, set this to true and enable high security in New Relic. This restricts the information you can send to New Relic. proxy_host string Default: (none) Some proxies default to using HTTP, which is a less secure protocol. attributes.enabled boolean Default: true Default for the Custom Instrumentation Editor: false By default, you are sending attributes to New Relic, except for methods instrumented using the Custom Instrumentation Editor. If you do not want to send attributes to New Relic, set this to false. attributes.exclude string Default: (none) If there are specific attribute keys that you do not want to send to New Relic in transaction traces, identify them using attributes.exclude. This restricts the information sent to New Relic. Consider if you want to exclude these potentially sensitive attributes using attributes.exclude or if you need the information sent to New Relic: request.headers.*: Removes all request headers. (Note that HTTP headers that contain sensitive data such as cookie and authorization are never collected.) response.headers.*: Removes all response headers. request_uri: Removes the path for the transaction's incoming request. log_sql boolean Default: false By default, you are sending queries to New Relic using record_sql. If you want to log queries in the agent log file as well as send them to New Relic, set this to true. record_sql string Default: obfuscated By default, record_sql is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to off. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. strip_exception_messages boolean Default: false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. If you are not using high security mode but still want to strip messages from all exceptions except those in your allow list, set this to true. custom_insights_events.enabled boolean Default: true By default, the agent records events sent to the Event API via recordCustomEvent(). If you enable high security mode, this is automatically set to false.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.55755,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>agent</em> security: Java",
        "sections": "APM <em>agent</em> security: Java",
        "tags": "<em>Agents</em>",
        "body": " enable high security mode, the default settings are locked so that users cannot change them. In addition: The <em>agent</em> does not collect message queue parameters. You cannot create <em>custom</em> events. You cannot implement <em>custom</em> <em>instrumentation</em> using the <em>Custom</em> <em>Instrumentation</em> Editor. You cannot collect user"
      },
      "id": "6043b8bb28ccbc3db92c60b7"
    },
    {
      "sections": [
        "Add detail to transactions via XML (.NET)",
        "Add detail with custom instrumentation",
        "Important",
        "Tip",
        "Ignore a transaction",
        "Track async work in a separate transaction",
        "Example method definitions",
        "Example method invocations",
        "Example MyInstrumentation.xml",
        "Example custom instrumentation file",
        "Example methods to be instrumented",
        "Name metrics",
        "Name transactions",
        "XSD validation",
        "Troubleshooting"
      ],
      "title": "Add detail to transactions via XML (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "0182a8eb2bf7b87e62ac2f86963af72b568e5c18",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/custom-instrumentation/add-detail-transactions-xml-net/",
      "published_at": "2021-06-02T17:51:59Z",
      "updated_at": "2021-03-11T08:11:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic collects and reports information on web browser transactions and non-web transactions (background tasks). Normally the .NET agent produces complete information automatically, without any need for you to modify your application code. However, if New Relic does not support your framework, you may need to add custom instrumentation. New Relic uses method tracers to implement custom instrumentation. A method tracer is a software probe that you can put on a method of any class. The .NET agent loads the instrumentation directives that define which methods should be traced from all XML files in the extensions directory. This document describes instrumenting work when the agent is already collecting transactions, but you want to add more detail to those transactions. To instrument work when the agent isn't creating transactions automatically, see Create transactions via XML. You can also add detail and create transactions by decorating your code with attributes. Add detail with custom instrumentation Extension files define a number of tracer factories in an instrumentation element. Each tracer factory contains match elements that define the assembly, fully qualified class name, and method name to match. To define a new custom instrumentation XML file: Create a new .xml file in the extensions directory used by the .NET agent to read every XML file and define its instrumentation set. For the .NET Framework agent, use the following location: C:\\ ProgramData \\New Relic\\.NET Agent\\Extensions Copy Important Do not put the .xml file in the C:\\Program Files\\New Relic\\.NET agent\\Extensions directory. The file must be in the ProgramData file location for custom instrumentation to work. Do not modify the distributed xml files. These files are overwritten whenever the agent is upgraded. Copy this template into the file you created use the sample as an example. This instruments two methods but you can add methods to your instrumentation file. Tip The values AssemblyName, NameSpace.ClassName, and MethodName are case sensitive. <?xml version=\"1.0\" encoding=\"utf-8\"?> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <!-- These methods appear in the transactions breakdown table and in transaction traces --> <tracerFactory metricName=\"Category/Name\"> <match assemblyName=\"AssemblyName\" className=\"NameSpace.ClassName\"> <exactMethodMatcher methodName=\"MethodName\" /> </match> </tracerFactory> <tracerFactory metricName=\"Category/Name2\"> <match assemblyName=\"AssemblyName\" className=\"NameSpace.ClassName2\"> <exactMethodMatcher methodName=\"MethodName2\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Validate the .xml instrumentation file against extension.xsd. Non-IIS apps (such as a console app or background process): You must also create transactions via XML to contain the methods you instrument. Custom methods instrumented outside of a transaction will not be reported to New Relic. Important If your .NET agent version is 7.0 or higher, this is the end of the procedure. If your .NET agent version is lower than 7.0, continue to the next steps. If your app is IIS-hosted, restart IIS. For non-IIS applications, restart your application's host process or the application itself. Ignore a transaction You can stop a transaction from being reported by using a custom instrumentation file. Whenever an ignored method is called, the .NET agent ignores the entire parent transaction. This is the same as calling IgnoreTransaction(). To ignore a transaction: Add custom instrumentation. Add a tracerFactory whose name is NewRelic.Agent.Core.Tracer.Factories.IgnoreTransactionTracerFactory: <tracerFactory name=\" NewRelic.Agent.Core.Tracer.Factories.IgnoreTransactionTracerFactory \"> <match assemblyName=\"System.Web.Extensions\" className=\"System.Web.Handlers.ScriptResourceHandler\"> <exactMethodMatcher methodName=\"Throw404\" /> </match> </tracerFactory> Copy Track async work in a separate transaction In some cases, asynchronous work can be tracked as a separate transaction by applying the AsyncForceNewTransactionWrapper instrumentation: <tracerFactory name=\" AsyncForceNewTransactionWrapper \"> <match assemblyName=\"AssemblyName\" className=\"Namespace.ClassName\"> <exactMethodMatcher methodName=\"MethodName\" /> </match> </tracerFactory> Copy Async usage considerations Comments Instrumented method The instrumented method must be invoked using Task.Run, Task.Factory.StartNew, or new Thread(). It cannot be invoked using the await keyword. Return type The instrumented method is not required to be async. However, if it is async, it must have a return type of Task or Task<T>. It cannot have a void return type. Attribute instrumentation The instrumented method cannot have attribute instrumentation applied to it. It cannot be decorated with the [Transaction] or [Trace] attributes. Example method definitions The following methods can be instrumented using the AsyncForceNewTransactionWrapper custom instrumentation: private void SyncMethod() { } private async Task AsyncMethod_Task() { } private async Task<string> AsyncMethod_TypedTask() { return \"ok\"; } Copy The following methods cannot be instrumented using the AsyncForceNewTransactionWrapper custom instrumentation: private async void AsyncMethod_Void() { } [Transaction] private void TransactionAttributedMethod() { } [Trace] private void TracedAttributedMethod() { } Copy Example method invocations The following method calls can be used with AsyncForceNewTransactionWrapper instrumentation: Task.Run(SyncMethod); Task.Factory.StartNew(AsyncMethod_Task); var newThread = new Thread(new ThreadStart(SyncMethod)); newThread.Start(); Copy The following method calls cannot be used with AsyncForceNewTransactionWrapper instrumentation: SyncMethod(); //This is not an asynchronous call await AsyncMethod_Task(); //Not started with Task.Run, Task.Factor.StartNew, or new Thread() AsyncMethod_Void(); //Async Void is not supported Copy Example MyInstrumentation.xml This example instruments two methods and ignores another method: Instrument: CustomInstrumentDemo.Controllers.FirstController.FirstExample() Instrument: CustomInstrumentDemo.Controllers.SecondController.SecondExample() Ignore: CustomInstrumentDemo.Controllers.SecondController.ThirdExample() Instrument: CustomInstrumentDemo.Controllers.SecondController.FourthExample(int id, string name) To implement this custom instrumentation scheme, use the following example file and instrumented methods: Example custom instrumentation file The following is an example custom instrumentation file named MyInstrumentation.xml: <?xml version=\"1.0\" encoding=\"utf-8\"?> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <!-- instrument CustomInstrumentDemo.Controllers.FirstController.FirstExample and creates metric named Custom/Foo1 --> <tracerFactory metricName=\"Custom/Foo1\"> <match assemblyName=\"CustomInstrumentDemo\" className=\"CustomInstrumentDemo.Controllers.FirstController\"> <exactMethodMatcher methodName=\"FirstExample\" /> </match> </tracerFactory> <!-- instrument CustomInstrumentDemo.Controllers.SecondController.SecondExample --> <tracerFactory> <match assemblyName=\"CustomInstrumentDemo\" className=\"CustomInstrumentDemo.Controllers.SecondController\"> <exactMethodMatcher methodName=\"SecondExample\" /> </match> </tracerFactory> <!-- ignore CustomInstrumentDemo.Controllers.SecondController.ThirdExample --> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.IgnoreTransactionTracerFactory\"> <match assemblyName=\"CustomInstrumentDemo\" className=\"CustomInstrumentDemo.Controllers.SecondController\"> <exactMethodMatcher methodName=\"ThirdExample\" /> </match> </tracerFactory> <!-- instrument CustomInstrumentDemo.Controllers.SecondController.FourthExample and creates metric named Custom/{value}, where {value} is the value of the first string parameter of the instrumented method (in this case, the first string parameter is \"name\"). --> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.CustomSegmentTracerFactory\"> <match assemblyName=\"CustomInstrumentDemo\" className=\"CustomInstrumentDemo.Controllers.SecondController\"> <exactMethodMatcher methodName=\"FourthExample\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Example methods to be instrumented This code contains the three methods specified by the example custom instrumentation file: using System; using System.Collections.Generic; using System.Linq; using System.Web; using System.Web.Mvc; using System.Threading; namespace CustomInstrumentDemo.Controllers { public class FirstController : Controller { public ActionResult Foo1() { ViewBag.Message = \"Your Sample Page\"; FirstExample(); return View(); } public void FirstExample() { int firstVar = 1; for (int i = 0; i <= 500; i++) { firstVar *= 5; Thread.Sleep(50); } } } public class SecondController : Controller { public ActionResult Foo2() { ViewBag.Message = \"This view will include detailed information on the SecondExample method\"; SecondExample(); return view; } public ActionResult Foo3() { ViewBag.Message = \"This view will be ignored because of the inclusion of the ThirdExample method\"; ThirdExample(); } public void SecondExample() { int secondVar = 2; using (var connection = new SqlConnection(ConnectionStrings[\"MsSqlConnection\"].ConnectionString)) { connection.Open(); using (var command = new SqlCommand(\"SELECT * FROM table\", connection)) using (var reader = command.ExecuteReader()) { reader.Read(); } } } public void ThirdExample() { try { var ImNotABool = \"43\"; bool.Parse(ImNotABool); } catch (Exception ex) { NewRelic.Api.Agent.NewRelic.NoticeError(ex); } } public void FourthExample(int id, string name) { Console.WriteLine(\"The ID passed in was \" + id + \" and the name passed in was \" + name); } } } Copy Name metrics Metrics created from tracers will be named using the class name and method name of the matched method. You can override this name with the metricName attribute. Begin metricName with Custom/ (for example, metricName=\"Custom/OrderSubmissions\"). <!-- instruments MyCompany.Order.Submit() and creates a metric named Custom/OrderSubmissions --> <tracerFactory metricName=\"Custom/OrderSubmissions\"> <match assemblyName=\"MyCompany\" className=\"MyCompany.Order\"> <exactMethodMatcher methodName=\"Submit\" /> </match </tracerFactory> Copy Name transactions The agent names transactions using the tracer in the transaction with the highest naming priority. Web transactions may be named using the HTTP handler, ASP name, MVC controller name, or web service name, depending on the tracers invoked in the transaction's execution. Background transactions with no tracer that explicitly names the transaction are rolled up into a single transaction name. Use the transactionNamingPriority attribute to tell the agent to give a tracer transaction naming priority. Valid values are 1 to 7, where 7 takes precedence over 1 to 6. Also, the metricName attribute must begin with Custom/ (for example, metricName=\"Custom/instance\"). <!-- instructs the agent to create a metric for MyControllerBase.Execute and to name the transaction using this tracer's metric name --> <tracerFactory metricName=\"Custom/instance\" transactionNamingPriority=\"7\"> <match assemblyName=\"MyCompany\" className=\"MyCompany.MyControllerBase\"> <exactMethodMatcher methodName=\"Execute\" /> </match> </tracerFactory> Copy XSD validation The XML instrumentation file can be checked against the XSD file (located at C:\\ProgramData\\New Relic\\.NET Agent\\Extensions\\extension.xsd) with any XSD validator. Troubleshooting The .NET agent will write a log message to NewRelic.Profiler.####.log (where #### is the PID of the instrumented process) as it rewrites methods. This helps to verify that custom instrumentation is being read and that the proper methods are being instrumented. Tip Avoid using the name attribute of the tracerFactory element in custom instrumentation. For more information, review the extension.xsd schema file in the agent directory.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 108.93665,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add detail to transactions via XML (.<em>NET</em>)",
        "sections": "Add detail with <em>custom</em> <em>instrumentation</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": ", you may need to add <em>custom</em> <em>instrumentation</em>. New Relic uses method tracers to implement <em>custom</em> <em>instrumentation</em>. A method tracer is a software probe that you can put on a method of any class. The .<em>NET</em> <em>agent</em> loads the <em>instrumentation</em> directives that define which methods should be traced from all XML"
      },
      "id": "6043f7d5196a6707e3960f33"
    }
  ],
  "/docs/agents/net-agent/custom-instrumentation/introduction-net-custom-instrumentation": [
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "68ae52e48b04bfe2279bcd038778cc5eebf53d1d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-06-02T17:53:04Z",
      "updated_at": "2021-05-15T18:25:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 140.48177,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Custom</em> <em>instrumentation</em> via attributes (.<em>NET</em>)",
        "sections": "<em>Custom</em> <em>instrumentation</em> via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> provides several options for <em>custom</em> <em>instrumentation</em>. <em>Custom</em> <em>instrumentation</em> allows you to <em>instrument</em> parts of your app that are not instrumented automatically. This document describes how to <em>instrument</em> your app by decorating the methods in your app code with attributes. Use"
      },
      "id": "6043cd9528ccbcfe1e2c60aa"
    },
    {
      "sections": [
        "APM agent security: Java",
        "Default security settings",
        "Caution",
        "High security mode settings",
        "Custom security settings"
      ],
      "title": "APM agent security: Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "fd9f5744c001453dbb9f129480f4e7e5ce42a176",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/apm-agent-security-java/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives, you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see Java agent error configuration. By default, here is how the New Relic Java agent handles the following potentially sensitive data:: Request parameters: The agent does not capture HTTP request parameters. HTTPS: The agent communicates with New Relic using HTTPS. SQL: The agent sets SQL recording to obfuscated, which removes the potentially sensitive numeric and string literal values. High security mode settings When you enable high security mode, the default settings are locked so that users cannot change them. In addition: The agent does not collect message queue parameters. You cannot create custom events. You cannot implement custom instrumentation using the Custom Instrumentation Editor. You cannot collect user attributes. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: Java agent configuration file Custom attributes Java agent API Setting Effects on data security audit_mode boolean Default: false By default, the Java agent does not log all data sent to New Relic in the agent log file. If you set this to true, the agent logs data sent to the New Relic collector in the agent log file. You can then evaluate the information that the agent sends by reviewing the agent log file to see if it includes sensitive information. high_security boolean Default: false To enable high security mode, set this to true and enable high security in New Relic. This restricts the information you can send to New Relic. proxy_host string Default: (none) Some proxies default to using HTTP, which is a less secure protocol. attributes.enabled boolean Default: true Default for the Custom Instrumentation Editor: false By default, you are sending attributes to New Relic, except for methods instrumented using the Custom Instrumentation Editor. If you do not want to send attributes to New Relic, set this to false. attributes.exclude string Default: (none) If there are specific attribute keys that you do not want to send to New Relic in transaction traces, identify them using attributes.exclude. This restricts the information sent to New Relic. Consider if you want to exclude these potentially sensitive attributes using attributes.exclude or if you need the information sent to New Relic: request.headers.*: Removes all request headers. (Note that HTTP headers that contain sensitive data such as cookie and authorization are never collected.) response.headers.*: Removes all response headers. request_uri: Removes the path for the transaction's incoming request. log_sql boolean Default: false By default, you are sending queries to New Relic using record_sql. If you want to log queries in the agent log file as well as send them to New Relic, set this to true. record_sql string Default: obfuscated By default, record_sql is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to off. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. strip_exception_messages boolean Default: false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. If you are not using high security mode but still want to strip messages from all exceptions except those in your allow list, set this to true. custom_insights_events.enabled boolean Default: true By default, the agent records events sent to the Event API via recordCustomEvent(). If you enable high security mode, this is automatically set to false.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.55745,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>agent</em> security: Java",
        "sections": "APM <em>agent</em> security: Java",
        "tags": "<em>Agents</em>",
        "body": " enable high security mode, the default settings are locked so that users cannot change them. In addition: The <em>agent</em> does not collect message queue parameters. You cannot create <em>custom</em> events. You cannot implement <em>custom</em> <em>instrumentation</em> using the <em>Custom</em> <em>Instrumentation</em> Editor. You cannot collect user"
      },
      "id": "6043b8bb28ccbc3db92c60b7"
    },
    {
      "sections": [
        "Add detail to transactions via XML (.NET)",
        "Add detail with custom instrumentation",
        "Important",
        "Tip",
        "Ignore a transaction",
        "Track async work in a separate transaction",
        "Example method definitions",
        "Example method invocations",
        "Example MyInstrumentation.xml",
        "Example custom instrumentation file",
        "Example methods to be instrumented",
        "Name metrics",
        "Name transactions",
        "XSD validation",
        "Troubleshooting"
      ],
      "title": "Add detail to transactions via XML (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "0182a8eb2bf7b87e62ac2f86963af72b568e5c18",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/custom-instrumentation/add-detail-transactions-xml-net/",
      "published_at": "2021-06-02T17:51:59Z",
      "updated_at": "2021-03-11T08:11:22Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic collects and reports information on web browser transactions and non-web transactions (background tasks). Normally the .NET agent produces complete information automatically, without any need for you to modify your application code. However, if New Relic does not support your framework, you may need to add custom instrumentation. New Relic uses method tracers to implement custom instrumentation. A method tracer is a software probe that you can put on a method of any class. The .NET agent loads the instrumentation directives that define which methods should be traced from all XML files in the extensions directory. This document describes instrumenting work when the agent is already collecting transactions, but you want to add more detail to those transactions. To instrument work when the agent isn't creating transactions automatically, see Create transactions via XML. You can also add detail and create transactions by decorating your code with attributes. Add detail with custom instrumentation Extension files define a number of tracer factories in an instrumentation element. Each tracer factory contains match elements that define the assembly, fully qualified class name, and method name to match. To define a new custom instrumentation XML file: Create a new .xml file in the extensions directory used by the .NET agent to read every XML file and define its instrumentation set. For the .NET Framework agent, use the following location: C:\\ ProgramData \\New Relic\\.NET Agent\\Extensions Copy Important Do not put the .xml file in the C:\\Program Files\\New Relic\\.NET agent\\Extensions directory. The file must be in the ProgramData file location for custom instrumentation to work. Do not modify the distributed xml files. These files are overwritten whenever the agent is upgraded. Copy this template into the file you created use the sample as an example. This instruments two methods but you can add methods to your instrumentation file. Tip The values AssemblyName, NameSpace.ClassName, and MethodName are case sensitive. <?xml version=\"1.0\" encoding=\"utf-8\"?> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <!-- These methods appear in the transactions breakdown table and in transaction traces --> <tracerFactory metricName=\"Category/Name\"> <match assemblyName=\"AssemblyName\" className=\"NameSpace.ClassName\"> <exactMethodMatcher methodName=\"MethodName\" /> </match> </tracerFactory> <tracerFactory metricName=\"Category/Name2\"> <match assemblyName=\"AssemblyName\" className=\"NameSpace.ClassName2\"> <exactMethodMatcher methodName=\"MethodName2\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Validate the .xml instrumentation file against extension.xsd. Non-IIS apps (such as a console app or background process): You must also create transactions via XML to contain the methods you instrument. Custom methods instrumented outside of a transaction will not be reported to New Relic. Important If your .NET agent version is 7.0 or higher, this is the end of the procedure. If your .NET agent version is lower than 7.0, continue to the next steps. If your app is IIS-hosted, restart IIS. For non-IIS applications, restart your application's host process or the application itself. Ignore a transaction You can stop a transaction from being reported by using a custom instrumentation file. Whenever an ignored method is called, the .NET agent ignores the entire parent transaction. This is the same as calling IgnoreTransaction(). To ignore a transaction: Add custom instrumentation. Add a tracerFactory whose name is NewRelic.Agent.Core.Tracer.Factories.IgnoreTransactionTracerFactory: <tracerFactory name=\" NewRelic.Agent.Core.Tracer.Factories.IgnoreTransactionTracerFactory \"> <match assemblyName=\"System.Web.Extensions\" className=\"System.Web.Handlers.ScriptResourceHandler\"> <exactMethodMatcher methodName=\"Throw404\" /> </match> </tracerFactory> Copy Track async work in a separate transaction In some cases, asynchronous work can be tracked as a separate transaction by applying the AsyncForceNewTransactionWrapper instrumentation: <tracerFactory name=\" AsyncForceNewTransactionWrapper \"> <match assemblyName=\"AssemblyName\" className=\"Namespace.ClassName\"> <exactMethodMatcher methodName=\"MethodName\" /> </match> </tracerFactory> Copy Async usage considerations Comments Instrumented method The instrumented method must be invoked using Task.Run, Task.Factory.StartNew, or new Thread(). It cannot be invoked using the await keyword. Return type The instrumented method is not required to be async. However, if it is async, it must have a return type of Task or Task<T>. It cannot have a void return type. Attribute instrumentation The instrumented method cannot have attribute instrumentation applied to it. It cannot be decorated with the [Transaction] or [Trace] attributes. Example method definitions The following methods can be instrumented using the AsyncForceNewTransactionWrapper custom instrumentation: private void SyncMethod() { } private async Task AsyncMethod_Task() { } private async Task<string> AsyncMethod_TypedTask() { return \"ok\"; } Copy The following methods cannot be instrumented using the AsyncForceNewTransactionWrapper custom instrumentation: private async void AsyncMethod_Void() { } [Transaction] private void TransactionAttributedMethod() { } [Trace] private void TracedAttributedMethod() { } Copy Example method invocations The following method calls can be used with AsyncForceNewTransactionWrapper instrumentation: Task.Run(SyncMethod); Task.Factory.StartNew(AsyncMethod_Task); var newThread = new Thread(new ThreadStart(SyncMethod)); newThread.Start(); Copy The following method calls cannot be used with AsyncForceNewTransactionWrapper instrumentation: SyncMethod(); //This is not an asynchronous call await AsyncMethod_Task(); //Not started with Task.Run, Task.Factor.StartNew, or new Thread() AsyncMethod_Void(); //Async Void is not supported Copy Example MyInstrumentation.xml This example instruments two methods and ignores another method: Instrument: CustomInstrumentDemo.Controllers.FirstController.FirstExample() Instrument: CustomInstrumentDemo.Controllers.SecondController.SecondExample() Ignore: CustomInstrumentDemo.Controllers.SecondController.ThirdExample() Instrument: CustomInstrumentDemo.Controllers.SecondController.FourthExample(int id, string name) To implement this custom instrumentation scheme, use the following example file and instrumented methods: Example custom instrumentation file The following is an example custom instrumentation file named MyInstrumentation.xml: <?xml version=\"1.0\" encoding=\"utf-8\"?> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <!-- instrument CustomInstrumentDemo.Controllers.FirstController.FirstExample and creates metric named Custom/Foo1 --> <tracerFactory metricName=\"Custom/Foo1\"> <match assemblyName=\"CustomInstrumentDemo\" className=\"CustomInstrumentDemo.Controllers.FirstController\"> <exactMethodMatcher methodName=\"FirstExample\" /> </match> </tracerFactory> <!-- instrument CustomInstrumentDemo.Controllers.SecondController.SecondExample --> <tracerFactory> <match assemblyName=\"CustomInstrumentDemo\" className=\"CustomInstrumentDemo.Controllers.SecondController\"> <exactMethodMatcher methodName=\"SecondExample\" /> </match> </tracerFactory> <!-- ignore CustomInstrumentDemo.Controllers.SecondController.ThirdExample --> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.IgnoreTransactionTracerFactory\"> <match assemblyName=\"CustomInstrumentDemo\" className=\"CustomInstrumentDemo.Controllers.SecondController\"> <exactMethodMatcher methodName=\"ThirdExample\" /> </match> </tracerFactory> <!-- instrument CustomInstrumentDemo.Controllers.SecondController.FourthExample and creates metric named Custom/{value}, where {value} is the value of the first string parameter of the instrumented method (in this case, the first string parameter is \"name\"). --> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.CustomSegmentTracerFactory\"> <match assemblyName=\"CustomInstrumentDemo\" className=\"CustomInstrumentDemo.Controllers.SecondController\"> <exactMethodMatcher methodName=\"FourthExample\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Example methods to be instrumented This code contains the three methods specified by the example custom instrumentation file: using System; using System.Collections.Generic; using System.Linq; using System.Web; using System.Web.Mvc; using System.Threading; namespace CustomInstrumentDemo.Controllers { public class FirstController : Controller { public ActionResult Foo1() { ViewBag.Message = \"Your Sample Page\"; FirstExample(); return View(); } public void FirstExample() { int firstVar = 1; for (int i = 0; i <= 500; i++) { firstVar *= 5; Thread.Sleep(50); } } } public class SecondController : Controller { public ActionResult Foo2() { ViewBag.Message = \"This view will include detailed information on the SecondExample method\"; SecondExample(); return view; } public ActionResult Foo3() { ViewBag.Message = \"This view will be ignored because of the inclusion of the ThirdExample method\"; ThirdExample(); } public void SecondExample() { int secondVar = 2; using (var connection = new SqlConnection(ConnectionStrings[\"MsSqlConnection\"].ConnectionString)) { connection.Open(); using (var command = new SqlCommand(\"SELECT * FROM table\", connection)) using (var reader = command.ExecuteReader()) { reader.Read(); } } } public void ThirdExample() { try { var ImNotABool = \"43\"; bool.Parse(ImNotABool); } catch (Exception ex) { NewRelic.Api.Agent.NewRelic.NoticeError(ex); } } public void FourthExample(int id, string name) { Console.WriteLine(\"The ID passed in was \" + id + \" and the name passed in was \" + name); } } } Copy Name metrics Metrics created from tracers will be named using the class name and method name of the matched method. You can override this name with the metricName attribute. Begin metricName with Custom/ (for example, metricName=\"Custom/OrderSubmissions\"). <!-- instruments MyCompany.Order.Submit() and creates a metric named Custom/OrderSubmissions --> <tracerFactory metricName=\"Custom/OrderSubmissions\"> <match assemblyName=\"MyCompany\" className=\"MyCompany.Order\"> <exactMethodMatcher methodName=\"Submit\" /> </match </tracerFactory> Copy Name transactions The agent names transactions using the tracer in the transaction with the highest naming priority. Web transactions may be named using the HTTP handler, ASP name, MVC controller name, or web service name, depending on the tracers invoked in the transaction's execution. Background transactions with no tracer that explicitly names the transaction are rolled up into a single transaction name. Use the transactionNamingPriority attribute to tell the agent to give a tracer transaction naming priority. Valid values are 1 to 7, where 7 takes precedence over 1 to 6. Also, the metricName attribute must begin with Custom/ (for example, metricName=\"Custom/instance\"). <!-- instructs the agent to create a metric for MyControllerBase.Execute and to name the transaction using this tracer's metric name --> <tracerFactory metricName=\"Custom/instance\" transactionNamingPriority=\"7\"> <match assemblyName=\"MyCompany\" className=\"MyCompany.MyControllerBase\"> <exactMethodMatcher methodName=\"Execute\" /> </match> </tracerFactory> Copy XSD validation The XML instrumentation file can be checked against the XSD file (located at C:\\ProgramData\\New Relic\\.NET Agent\\Extensions\\extension.xsd) with any XSD validator. Troubleshooting The .NET agent will write a log message to NewRelic.Profiler.####.log (where #### is the PID of the instrumented process) as it rewrites methods. This helps to verify that custom instrumentation is being read and that the proper methods are being instrumented. Tip Avoid using the name attribute of the tracerFactory element in custom instrumentation. For more information, review the extension.xsd schema file in the agent directory.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 108.936646,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Add detail to transactions via XML (.<em>NET</em>)",
        "sections": "Add detail with <em>custom</em> <em>instrumentation</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": ", you may need to add <em>custom</em> <em>instrumentation</em>. New Relic uses method tracers to implement <em>custom</em> <em>instrumentation</em>. A method tracer is a software probe that you can put on a method of any class. The .<em>NET</em> <em>agent</em> loads the <em>instrumentation</em> directives that define which methods should be traced from all XML"
      },
      "id": "6043f7d5196a6707e3960f33"
    }
  ],
  "/docs/agents/net-agent/getting-started/apm-agent-security-net": [
    {
      "sections": [
        "Introduction to New Relic APIs",
        "Tip",
        "NerdGraph (GraphQL)",
        "REST APIs by capability",
        "Alerts",
        "APM",
        "Browser monitoring",
        "Infrastructure monitoring",
        "Mobile monitoring",
        "Synthetic monitoring",
        "Telemetry APIs for core data types",
        "Account management, admin, and usage APIs",
        "Other APIs",
        "Insights",
        "Plugins",
        "See APIs in action"
      ],
      "title": "Introduction to New Relic APIs",
      "type": "docs",
      "tags": [
        "APIs",
        "Get started",
        "Intro to APIs"
      ],
      "external_id": "01e9799a214baad5de04de6146483f6dbbc198aa",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/intro-apis/introduction-new-relic-apis/",
      "published_at": "2021-06-02T16:33:26Z",
      "updated_at": "2021-06-02T16:33:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers a variety of APIs and SDKs you can use to: Retrieve data from New Relic. Send data to New Relic. Adjust settings. This document provides examples and reference information for our API endpoints. For developer-focused content on how to use and customize New Relic, see developer.newrelic.com. Tip To use APIs and SDKs, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. NerdGraph (GraphQL) NerdGraph is New Relic's GraphQL-format API, an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph is the preferred API for querying New Relic data and making a range of feature configurations. To get started, see Introduction to NerdGraph. REST APIs by capability New Relic capabilities, like APM, infrastructure monitoring, or alerts, are often used together, and sometimes they overlap in functionality. This is why multiple APIs may be relevant to each area. Some API functionality will depend on your access to features and data. Tip To learn more about different API key types, see Understand New Relic API keys. Alerts Use the REST API for alerts and the API Explorer to: Create and manage policies, conditions, and notification channels. Create alert conditions based on NRQL queries. Create alert conditions based on data from other New Relic capabilities. APM API resources for application monitoring include: Resource Details REST API REST API features include: Retrieve APM data, including metrics, Apdex, error rates, and host data. Report deployments. Change the app name in the UI. Agent APIs Every APM language agent has an API that lets you customize the agent's default behavior, including reporting custom data. APM agent APIs include: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Python agent API Ruby agent API Query API To query APM data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Browser monitoring The Browser API resources include: Resource Details Browser agent API Use the Browser agent API for tasks such as: Report custom end user data to browser monitoring. Monitor asynchronous browser activity using SPA API calls. Insert custom data into New Relic dashboards . Manage source maps. REST API With the REST API you can: Retrieve page load timing data and throughput. Add or list apps monitored by browser monitoring. Manage alerts conditions for your browser data. Query API To retrieve browser monitoring data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Infrastructure monitoring The Infrastructure API resources include: Resource Details Query API To retrieve infrastructure data, use the Query API. This API can also be used to retrieve subscription usage data. Infrastructure alert API To manage your infrastructure alerts, use the Infrastructure alert API. Integrations SDK To make your own custom integrations for reporting data to infrastructure monitoring, use the Integrations SDK. NerdGraph You can use NerdGraph (our GraphQL API) to query your cloud integration data and make changes to cloud integration settings. Mobile monitoring Mobile API resources include: Resource Details Mobile agent APIs Mobile APIs let you custom instrument your own code and send events to New Relic. See the platform-specific documentation: iOS Android Unity REST API Use the REST API for such tasks as: Retrieve a list of monitored apps. Get subscription usage data. Get metric names and data. Get crash count and crash rate data. Manage New Relic alerts conditions for your mobile apps. Query API To retrieve Mobile data from New Relic, use the Query API. Account management APIs For account-related APIs, see Account APIs. Synthetic monitoring Synthetics API resources include: Resource Details Synthetics REST API The Synthetics REST API functionality includes: Create and manage synthetics monitors. Manage synthetics alert notifications. Add labels to monitors, and retrieve monitors with specific labels. Query API To retrieve synthetics event data, use the Query API. Alerts API To create and manage alert conditions that target synthetics monitors, use the Alerts API. Telemetry APIs for core data types We offer several APIs that allow you to get our core data types (metrics, logs, traces, and events) into New Relic without the use of an installed agent. Data type Description Trace API Send distributed tracing data to New Relic. Event API Send event data to New Relic. Metric API Send metrics to New Relic from any source (including other telemetry monitoring services). Log API Send your log data to New Relic. Account management, admin, and usage APIs Like any other New Relic product or service, you want to be confident that your APIs protect you and your customers' data privacy. The following are API resources related to New Relic account administration and usage. For more information about API capabilities, see the specific New Relic API. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Resource Details REST API REST API features include: Find your API keys, account ID, and information needed to use the REST API. Return a list of account users (original user model only). Get SLA report data for browser and application monitoring. Subscription usage You can use the Query API to retrieve subscription usage data. This can be helpful to see how usage compares to your current subscription level, or for doing departmental chargebacks. Partner API To retrieve information about your New Relic partner account, sub-accounts, and users, use the Partner API. Other APIs Insights New Relic Insights was the name of our original product that governed custom event reporting and querying. The features associated with Insights have been rolled into our New Relic One platform (learn more), but there are still some APIs and original pricing plans that use the term \"Insights\" for these historical reasons. Insights-related APIs include: Resource Details Event API To report custom events, use the Event API. Query API To query your data using NRQL-format queries, you can use the Query API. Note that this API is deprecated and NerdGraph is preferred for querying your data. Dashboard API See the Insights Dashboard API. Plugins Use the REST API for New Relic plugins and the API Explorer to: Get a list of plugins, including their names, IDs, and GUIDs. List one or more plugin components, their output, and their metric timeslice data. Developers and New Relic partners can also use New Relic's Plugin API to write an agent in any language that can work directly with the API for plugins. This allows you to send your own metric data to our plugins and view data received from the API in New Relic. See APIs in action For more on how you as a developer can optimize your ability to solve problems using New Relic, go to developer.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.05001,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Get</em> <em>started</em>",
        "body": ", an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph is the preferred API for querying New Relic data and making a range of feature configurations. To <em>get</em> <em>started</em>, see Introduction to NerdGraph. REST APIs"
      },
      "id": "609fa5cf196a67066022b194"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.82179,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the Java <em>agent</em>",
        "sections": "Compatibility and requirements for the Java <em>agent</em>",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " method. The Java <em>agent</em> reports the database name and database server&#x2F;identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, <em>get</em> support at support.newrelic.com. Hosting services You can install"
      },
      "id": "6043b8f6196a6771a9960f87"
    },
    {
      "sections": [
        "APM agent security: Java",
        "Default security settings",
        "Caution",
        "High security mode settings",
        "Custom security settings"
      ],
      "title": "APM agent security: Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "fd9f5744c001453dbb9f129480f4e7e5ce42a176",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/apm-agent-security-java/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives, you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see Java agent error configuration. By default, here is how the New Relic Java agent handles the following potentially sensitive data:: Request parameters: The agent does not capture HTTP request parameters. HTTPS: The agent communicates with New Relic using HTTPS. SQL: The agent sets SQL recording to obfuscated, which removes the potentially sensitive numeric and string literal values. High security mode settings When you enable high security mode, the default settings are locked so that users cannot change them. In addition: The agent does not collect message queue parameters. You cannot create custom events. You cannot implement custom instrumentation using the Custom Instrumentation Editor. You cannot collect user attributes. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: Java agent configuration file Custom attributes Java agent API Setting Effects on data security audit_mode boolean Default: false By default, the Java agent does not log all data sent to New Relic in the agent log file. If you set this to true, the agent logs data sent to the New Relic collector in the agent log file. You can then evaluate the information that the agent sends by reviewing the agent log file to see if it includes sensitive information. high_security boolean Default: false To enable high security mode, set this to true and enable high security in New Relic. This restricts the information you can send to New Relic. proxy_host string Default: (none) Some proxies default to using HTTP, which is a less secure protocol. attributes.enabled boolean Default: true Default for the Custom Instrumentation Editor: false By default, you are sending attributes to New Relic, except for methods instrumented using the Custom Instrumentation Editor. If you do not want to send attributes to New Relic, set this to false. attributes.exclude string Default: (none) If there are specific attribute keys that you do not want to send to New Relic in transaction traces, identify them using attributes.exclude. This restricts the information sent to New Relic. Consider if you want to exclude these potentially sensitive attributes using attributes.exclude or if you need the information sent to New Relic: request.headers.*: Removes all request headers. (Note that HTTP headers that contain sensitive data such as cookie and authorization are never collected.) response.headers.*: Removes all response headers. request_uri: Removes the path for the transaction's incoming request. log_sql boolean Default: false By default, you are sending queries to New Relic using record_sql. If you want to log queries in the agent log file as well as send them to New Relic, set this to true. record_sql string Default: obfuscated By default, record_sql is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to off. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. strip_exception_messages boolean Default: false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. If you are not using high security mode but still want to strip messages from all exceptions except those in your allow list, set this to true. custom_insights_events.enabled boolean Default: true By default, the agent records events sent to the Event API via recordCustomEvent(). If you enable high security mode, this is automatically set to false.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.821686,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>agent</em> security: Java",
        "sections": "APM <em>agent</em> security: Java",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": "The New Relic Java <em>agent</em> default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives"
      },
      "id": "6043b8bb28ccbc3db92c60b7"
    }
  ],
  "/docs/agents/net-agent/getting-started/introduction-new-relic-net": [
    {
      "sections": [
        "Introduction to New Relic APIs",
        "Tip",
        "NerdGraph (GraphQL)",
        "REST APIs by capability",
        "Alerts",
        "APM",
        "Browser monitoring",
        "Infrastructure monitoring",
        "Mobile monitoring",
        "Synthetic monitoring",
        "Telemetry APIs for core data types",
        "Account management, admin, and usage APIs",
        "Other APIs",
        "Insights",
        "Plugins",
        "See APIs in action"
      ],
      "title": "Introduction to New Relic APIs",
      "type": "docs",
      "tags": [
        "APIs",
        "Get started",
        "Intro to APIs"
      ],
      "external_id": "01e9799a214baad5de04de6146483f6dbbc198aa",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/intro-apis/introduction-new-relic-apis/",
      "published_at": "2021-06-02T16:33:26Z",
      "updated_at": "2021-06-02T16:33:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers a variety of APIs and SDKs you can use to: Retrieve data from New Relic. Send data to New Relic. Adjust settings. This document provides examples and reference information for our API endpoints. For developer-focused content on how to use and customize New Relic, see developer.newrelic.com. Tip To use APIs and SDKs, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. NerdGraph (GraphQL) NerdGraph is New Relic's GraphQL-format API, an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph is the preferred API for querying New Relic data and making a range of feature configurations. To get started, see Introduction to NerdGraph. REST APIs by capability New Relic capabilities, like APM, infrastructure monitoring, or alerts, are often used together, and sometimes they overlap in functionality. This is why multiple APIs may be relevant to each area. Some API functionality will depend on your access to features and data. Tip To learn more about different API key types, see Understand New Relic API keys. Alerts Use the REST API for alerts and the API Explorer to: Create and manage policies, conditions, and notification channels. Create alert conditions based on NRQL queries. Create alert conditions based on data from other New Relic capabilities. APM API resources for application monitoring include: Resource Details REST API REST API features include: Retrieve APM data, including metrics, Apdex, error rates, and host data. Report deployments. Change the app name in the UI. Agent APIs Every APM language agent has an API that lets you customize the agent's default behavior, including reporting custom data. APM agent APIs include: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Python agent API Ruby agent API Query API To query APM data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Browser monitoring The Browser API resources include: Resource Details Browser agent API Use the Browser agent API for tasks such as: Report custom end user data to browser monitoring. Monitor asynchronous browser activity using SPA API calls. Insert custom data into New Relic dashboards . Manage source maps. REST API With the REST API you can: Retrieve page load timing data and throughput. Add or list apps monitored by browser monitoring. Manage alerts conditions for your browser data. Query API To retrieve browser monitoring data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Infrastructure monitoring The Infrastructure API resources include: Resource Details Query API To retrieve infrastructure data, use the Query API. This API can also be used to retrieve subscription usage data. Infrastructure alert API To manage your infrastructure alerts, use the Infrastructure alert API. Integrations SDK To make your own custom integrations for reporting data to infrastructure monitoring, use the Integrations SDK. NerdGraph You can use NerdGraph (our GraphQL API) to query your cloud integration data and make changes to cloud integration settings. Mobile monitoring Mobile API resources include: Resource Details Mobile agent APIs Mobile APIs let you custom instrument your own code and send events to New Relic. See the platform-specific documentation: iOS Android Unity REST API Use the REST API for such tasks as: Retrieve a list of monitored apps. Get subscription usage data. Get metric names and data. Get crash count and crash rate data. Manage New Relic alerts conditions for your mobile apps. Query API To retrieve Mobile data from New Relic, use the Query API. Account management APIs For account-related APIs, see Account APIs. Synthetic monitoring Synthetics API resources include: Resource Details Synthetics REST API The Synthetics REST API functionality includes: Create and manage synthetics monitors. Manage synthetics alert notifications. Add labels to monitors, and retrieve monitors with specific labels. Query API To retrieve synthetics event data, use the Query API. Alerts API To create and manage alert conditions that target synthetics monitors, use the Alerts API. Telemetry APIs for core data types We offer several APIs that allow you to get our core data types (metrics, logs, traces, and events) into New Relic without the use of an installed agent. Data type Description Trace API Send distributed tracing data to New Relic. Event API Send event data to New Relic. Metric API Send metrics to New Relic from any source (including other telemetry monitoring services). Log API Send your log data to New Relic. Account management, admin, and usage APIs Like any other New Relic product or service, you want to be confident that your APIs protect you and your customers' data privacy. The following are API resources related to New Relic account administration and usage. For more information about API capabilities, see the specific New Relic API. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Resource Details REST API REST API features include: Find your API keys, account ID, and information needed to use the REST API. Return a list of account users (original user model only). Get SLA report data for browser and application monitoring. Subscription usage You can use the Query API to retrieve subscription usage data. This can be helpful to see how usage compares to your current subscription level, or for doing departmental chargebacks. Partner API To retrieve information about your New Relic partner account, sub-accounts, and users, use the Partner API. Other APIs Insights New Relic Insights was the name of our original product that governed custom event reporting and querying. The features associated with Insights have been rolled into our New Relic One platform (learn more), but there are still some APIs and original pricing plans that use the term \"Insights\" for these historical reasons. Insights-related APIs include: Resource Details Event API To report custom events, use the Event API. Query API To query your data using NRQL-format queries, you can use the Query API. Note that this API is deprecated and NerdGraph is preferred for querying your data. Dashboard API See the Insights Dashboard API. Plugins Use the REST API for New Relic plugins and the API Explorer to: Get a list of plugins, including their names, IDs, and GUIDs. List one or more plugin components, their output, and their metric timeslice data. Developers and New Relic partners can also use New Relic's Plugin API to write an agent in any language that can work directly with the API for plugins. This allows you to send your own metric data to our plugins and view data received from the API in New Relic. See APIs in action For more on how you as a developer can optimize your ability to solve problems using New Relic, go to developer.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.0499,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Get</em> <em>started</em>",
        "body": ", an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph is the preferred API for querying New Relic data and making a range of feature configurations. To <em>get</em> <em>started</em>, see Introduction to NerdGraph. REST APIs"
      },
      "id": "609fa5cf196a67066022b194"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.821686,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the Java <em>agent</em>",
        "sections": "Compatibility and requirements for the Java <em>agent</em>",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " method. The Java <em>agent</em> reports the database name and database server&#x2F;identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, <em>get</em> support at support.newrelic.com. Hosting services You can install"
      },
      "id": "6043b8f6196a6771a9960f87"
    },
    {
      "sections": [
        "APM agent security: Java",
        "Default security settings",
        "Caution",
        "High security mode settings",
        "Custom security settings"
      ],
      "title": "APM agent security: Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "fd9f5744c001453dbb9f129480f4e7e5ce42a176",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/apm-agent-security-java/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives, you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see Java agent error configuration. By default, here is how the New Relic Java agent handles the following potentially sensitive data:: Request parameters: The agent does not capture HTTP request parameters. HTTPS: The agent communicates with New Relic using HTTPS. SQL: The agent sets SQL recording to obfuscated, which removes the potentially sensitive numeric and string literal values. High security mode settings When you enable high security mode, the default settings are locked so that users cannot change them. In addition: The agent does not collect message queue parameters. You cannot create custom events. You cannot implement custom instrumentation using the Custom Instrumentation Editor. You cannot collect user attributes. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: Java agent configuration file Custom attributes Java agent API Setting Effects on data security audit_mode boolean Default: false By default, the Java agent does not log all data sent to New Relic in the agent log file. If you set this to true, the agent logs data sent to the New Relic collector in the agent log file. You can then evaluate the information that the agent sends by reviewing the agent log file to see if it includes sensitive information. high_security boolean Default: false To enable high security mode, set this to true and enable high security in New Relic. This restricts the information you can send to New Relic. proxy_host string Default: (none) Some proxies default to using HTTP, which is a less secure protocol. attributes.enabled boolean Default: true Default for the Custom Instrumentation Editor: false By default, you are sending attributes to New Relic, except for methods instrumented using the Custom Instrumentation Editor. If you do not want to send attributes to New Relic, set this to false. attributes.exclude string Default: (none) If there are specific attribute keys that you do not want to send to New Relic in transaction traces, identify them using attributes.exclude. This restricts the information sent to New Relic. Consider if you want to exclude these potentially sensitive attributes using attributes.exclude or if you need the information sent to New Relic: request.headers.*: Removes all request headers. (Note that HTTP headers that contain sensitive data such as cookie and authorization are never collected.) response.headers.*: Removes all response headers. request_uri: Removes the path for the transaction's incoming request. log_sql boolean Default: false By default, you are sending queries to New Relic using record_sql. If you want to log queries in the agent log file as well as send them to New Relic, set this to true. record_sql string Default: obfuscated By default, record_sql is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to off. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. strip_exception_messages boolean Default: false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. If you are not using high security mode but still want to strip messages from all exceptions except those in your allow list, set this to true. custom_insights_events.enabled boolean Default: true By default, the agent records events sent to the Event API via recordCustomEvent(). If you enable high security mode, this is automatically set to false.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.82158,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>agent</em> security: Java",
        "sections": "APM <em>agent</em> security: Java",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": "The New Relic Java <em>agent</em> default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives"
      },
      "id": "6043b8bb28ccbc3db92c60b7"
    }
  ],
  "/docs/agents/net-agent/getting-started/net-agent-compatibility-requirements-net-core": [
    {
      "sections": [
        "Introduction to New Relic APIs",
        "Tip",
        "NerdGraph (GraphQL)",
        "REST APIs by capability",
        "Alerts",
        "APM",
        "Browser monitoring",
        "Infrastructure monitoring",
        "Mobile monitoring",
        "Synthetic monitoring",
        "Telemetry APIs for core data types",
        "Account management, admin, and usage APIs",
        "Other APIs",
        "Insights",
        "Plugins",
        "See APIs in action"
      ],
      "title": "Introduction to New Relic APIs",
      "type": "docs",
      "tags": [
        "APIs",
        "Get started",
        "Intro to APIs"
      ],
      "external_id": "01e9799a214baad5de04de6146483f6dbbc198aa",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/intro-apis/introduction-new-relic-apis/",
      "published_at": "2021-06-02T16:33:26Z",
      "updated_at": "2021-06-02T16:33:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers a variety of APIs and SDKs you can use to: Retrieve data from New Relic. Send data to New Relic. Adjust settings. This document provides examples and reference information for our API endpoints. For developer-focused content on how to use and customize New Relic, see developer.newrelic.com. Tip To use APIs and SDKs, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. NerdGraph (GraphQL) NerdGraph is New Relic's GraphQL-format API, an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph is the preferred API for querying New Relic data and making a range of feature configurations. To get started, see Introduction to NerdGraph. REST APIs by capability New Relic capabilities, like APM, infrastructure monitoring, or alerts, are often used together, and sometimes they overlap in functionality. This is why multiple APIs may be relevant to each area. Some API functionality will depend on your access to features and data. Tip To learn more about different API key types, see Understand New Relic API keys. Alerts Use the REST API for alerts and the API Explorer to: Create and manage policies, conditions, and notification channels. Create alert conditions based on NRQL queries. Create alert conditions based on data from other New Relic capabilities. APM API resources for application monitoring include: Resource Details REST API REST API features include: Retrieve APM data, including metrics, Apdex, error rates, and host data. Report deployments. Change the app name in the UI. Agent APIs Every APM language agent has an API that lets you customize the agent's default behavior, including reporting custom data. APM agent APIs include: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Python agent API Ruby agent API Query API To query APM data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Browser monitoring The Browser API resources include: Resource Details Browser agent API Use the Browser agent API for tasks such as: Report custom end user data to browser monitoring. Monitor asynchronous browser activity using SPA API calls. Insert custom data into New Relic dashboards . Manage source maps. REST API With the REST API you can: Retrieve page load timing data and throughput. Add or list apps monitored by browser monitoring. Manage alerts conditions for your browser data. Query API To retrieve browser monitoring data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Infrastructure monitoring The Infrastructure API resources include: Resource Details Query API To retrieve infrastructure data, use the Query API. This API can also be used to retrieve subscription usage data. Infrastructure alert API To manage your infrastructure alerts, use the Infrastructure alert API. Integrations SDK To make your own custom integrations for reporting data to infrastructure monitoring, use the Integrations SDK. NerdGraph You can use NerdGraph (our GraphQL API) to query your cloud integration data and make changes to cloud integration settings. Mobile monitoring Mobile API resources include: Resource Details Mobile agent APIs Mobile APIs let you custom instrument your own code and send events to New Relic. See the platform-specific documentation: iOS Android Unity REST API Use the REST API for such tasks as: Retrieve a list of monitored apps. Get subscription usage data. Get metric names and data. Get crash count and crash rate data. Manage New Relic alerts conditions for your mobile apps. Query API To retrieve Mobile data from New Relic, use the Query API. Account management APIs For account-related APIs, see Account APIs. Synthetic monitoring Synthetics API resources include: Resource Details Synthetics REST API The Synthetics REST API functionality includes: Create and manage synthetics monitors. Manage synthetics alert notifications. Add labels to monitors, and retrieve monitors with specific labels. Query API To retrieve synthetics event data, use the Query API. Alerts API To create and manage alert conditions that target synthetics monitors, use the Alerts API. Telemetry APIs for core data types We offer several APIs that allow you to get our core data types (metrics, logs, traces, and events) into New Relic without the use of an installed agent. Data type Description Trace API Send distributed tracing data to New Relic. Event API Send event data to New Relic. Metric API Send metrics to New Relic from any source (including other telemetry monitoring services). Log API Send your log data to New Relic. Account management, admin, and usage APIs Like any other New Relic product or service, you want to be confident that your APIs protect you and your customers' data privacy. The following are API resources related to New Relic account administration and usage. For more information about API capabilities, see the specific New Relic API. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Resource Details REST API REST API features include: Find your API keys, account ID, and information needed to use the REST API. Return a list of account users (original user model only). Get SLA report data for browser and application monitoring. Subscription usage You can use the Query API to retrieve subscription usage data. This can be helpful to see how usage compares to your current subscription level, or for doing departmental chargebacks. Partner API To retrieve information about your New Relic partner account, sub-accounts, and users, use the Partner API. Other APIs Insights New Relic Insights was the name of our original product that governed custom event reporting and querying. The features associated with Insights have been rolled into our New Relic One platform (learn more), but there are still some APIs and original pricing plans that use the term \"Insights\" for these historical reasons. Insights-related APIs include: Resource Details Event API To report custom events, use the Event API. Query API To query your data using NRQL-format queries, you can use the Query API. Note that this API is deprecated and NerdGraph is preferred for querying your data. Dashboard API See the Insights Dashboard API. Plugins Use the REST API for New Relic plugins and the API Explorer to: Get a list of plugins, including their names, IDs, and GUIDs. List one or more plugin components, their output, and their metric timeslice data. Developers and New Relic partners can also use New Relic's Plugin API to write an agent in any language that can work directly with the API for plugins. This allows you to send your own metric data to our plugins and view data received from the API in New Relic. See APIs in action For more on how you as a developer can optimize your ability to solve problems using New Relic, go to developer.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.0499,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Get</em> <em>started</em>",
        "body": ", an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph is the preferred API for querying New Relic data and making a range of feature configurations. To <em>get</em> <em>started</em>, see Introduction to NerdGraph. REST APIs"
      },
      "id": "609fa5cf196a67066022b194"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.821686,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the Java <em>agent</em>",
        "sections": "Compatibility and requirements for the Java <em>agent</em>",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " method. The Java <em>agent</em> reports the database name and database server&#x2F;identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, <em>get</em> support at support.newrelic.com. Hosting services You can install"
      },
      "id": "6043b8f6196a6771a9960f87"
    },
    {
      "sections": [
        "APM agent security: Java",
        "Default security settings",
        "Caution",
        "High security mode settings",
        "Custom security settings"
      ],
      "title": "APM agent security: Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "fd9f5744c001453dbb9f129480f4e7e5ce42a176",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/apm-agent-security-java/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives, you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see Java agent error configuration. By default, here is how the New Relic Java agent handles the following potentially sensitive data:: Request parameters: The agent does not capture HTTP request parameters. HTTPS: The agent communicates with New Relic using HTTPS. SQL: The agent sets SQL recording to obfuscated, which removes the potentially sensitive numeric and string literal values. High security mode settings When you enable high security mode, the default settings are locked so that users cannot change them. In addition: The agent does not collect message queue parameters. You cannot create custom events. You cannot implement custom instrumentation using the Custom Instrumentation Editor. You cannot collect user attributes. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: Java agent configuration file Custom attributes Java agent API Setting Effects on data security audit_mode boolean Default: false By default, the Java agent does not log all data sent to New Relic in the agent log file. If you set this to true, the agent logs data sent to the New Relic collector in the agent log file. You can then evaluate the information that the agent sends by reviewing the agent log file to see if it includes sensitive information. high_security boolean Default: false To enable high security mode, set this to true and enable high security in New Relic. This restricts the information you can send to New Relic. proxy_host string Default: (none) Some proxies default to using HTTP, which is a less secure protocol. attributes.enabled boolean Default: true Default for the Custom Instrumentation Editor: false By default, you are sending attributes to New Relic, except for methods instrumented using the Custom Instrumentation Editor. If you do not want to send attributes to New Relic, set this to false. attributes.exclude string Default: (none) If there are specific attribute keys that you do not want to send to New Relic in transaction traces, identify them using attributes.exclude. This restricts the information sent to New Relic. Consider if you want to exclude these potentially sensitive attributes using attributes.exclude or if you need the information sent to New Relic: request.headers.*: Removes all request headers. (Note that HTTP headers that contain sensitive data such as cookie and authorization are never collected.) response.headers.*: Removes all response headers. request_uri: Removes the path for the transaction's incoming request. log_sql boolean Default: false By default, you are sending queries to New Relic using record_sql. If you want to log queries in the agent log file as well as send them to New Relic, set this to true. record_sql string Default: obfuscated By default, record_sql is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to off. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. strip_exception_messages boolean Default: false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. If you are not using high security mode but still want to strip messages from all exceptions except those in your allow list, set this to true. custom_insights_events.enabled boolean Default: true By default, the agent records events sent to the Event API via recordCustomEvent(). If you enable high security mode, this is automatically set to false.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.82158,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>agent</em> security: Java",
        "sections": "APM <em>agent</em> security: Java",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": "The New Relic Java <em>agent</em> default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives"
      },
      "id": "6043b8bb28ccbc3db92c60b7"
    }
  ],
  "/docs/agents/net-agent/getting-started/net-agent-compatibility-requirements-net-framework": [
    {
      "sections": [
        "Introduction to New Relic APIs",
        "Tip",
        "NerdGraph (GraphQL)",
        "REST APIs by capability",
        "Alerts",
        "APM",
        "Browser monitoring",
        "Infrastructure monitoring",
        "Mobile monitoring",
        "Synthetic monitoring",
        "Telemetry APIs for core data types",
        "Account management, admin, and usage APIs",
        "Other APIs",
        "Insights",
        "Plugins",
        "See APIs in action"
      ],
      "title": "Introduction to New Relic APIs",
      "type": "docs",
      "tags": [
        "APIs",
        "Get started",
        "Intro to APIs"
      ],
      "external_id": "01e9799a214baad5de04de6146483f6dbbc198aa",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/intro-apis/introduction-new-relic-apis/",
      "published_at": "2021-06-02T16:33:26Z",
      "updated_at": "2021-06-02T16:33:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers a variety of APIs and SDKs you can use to: Retrieve data from New Relic. Send data to New Relic. Adjust settings. This document provides examples and reference information for our API endpoints. For developer-focused content on how to use and customize New Relic, see developer.newrelic.com. Tip To use APIs and SDKs, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. NerdGraph (GraphQL) NerdGraph is New Relic's GraphQL-format API, an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph is the preferred API for querying New Relic data and making a range of feature configurations. To get started, see Introduction to NerdGraph. REST APIs by capability New Relic capabilities, like APM, infrastructure monitoring, or alerts, are often used together, and sometimes they overlap in functionality. This is why multiple APIs may be relevant to each area. Some API functionality will depend on your access to features and data. Tip To learn more about different API key types, see Understand New Relic API keys. Alerts Use the REST API for alerts and the API Explorer to: Create and manage policies, conditions, and notification channels. Create alert conditions based on NRQL queries. Create alert conditions based on data from other New Relic capabilities. APM API resources for application monitoring include: Resource Details REST API REST API features include: Retrieve APM data, including metrics, Apdex, error rates, and host data. Report deployments. Change the app name in the UI. Agent APIs Every APM language agent has an API that lets you customize the agent's default behavior, including reporting custom data. APM agent APIs include: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Python agent API Ruby agent API Query API To query APM data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Browser monitoring The Browser API resources include: Resource Details Browser agent API Use the Browser agent API for tasks such as: Report custom end user data to browser monitoring. Monitor asynchronous browser activity using SPA API calls. Insert custom data into New Relic dashboards . Manage source maps. REST API With the REST API you can: Retrieve page load timing data and throughput. Add or list apps monitored by browser monitoring. Manage alerts conditions for your browser data. Query API To retrieve browser monitoring data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Infrastructure monitoring The Infrastructure API resources include: Resource Details Query API To retrieve infrastructure data, use the Query API. This API can also be used to retrieve subscription usage data. Infrastructure alert API To manage your infrastructure alerts, use the Infrastructure alert API. Integrations SDK To make your own custom integrations for reporting data to infrastructure monitoring, use the Integrations SDK. NerdGraph You can use NerdGraph (our GraphQL API) to query your cloud integration data and make changes to cloud integration settings. Mobile monitoring Mobile API resources include: Resource Details Mobile agent APIs Mobile APIs let you custom instrument your own code and send events to New Relic. See the platform-specific documentation: iOS Android Unity REST API Use the REST API for such tasks as: Retrieve a list of monitored apps. Get subscription usage data. Get metric names and data. Get crash count and crash rate data. Manage New Relic alerts conditions for your mobile apps. Query API To retrieve Mobile data from New Relic, use the Query API. Account management APIs For account-related APIs, see Account APIs. Synthetic monitoring Synthetics API resources include: Resource Details Synthetics REST API The Synthetics REST API functionality includes: Create and manage synthetics monitors. Manage synthetics alert notifications. Add labels to monitors, and retrieve monitors with specific labels. Query API To retrieve synthetics event data, use the Query API. Alerts API To create and manage alert conditions that target synthetics monitors, use the Alerts API. Telemetry APIs for core data types We offer several APIs that allow you to get our core data types (metrics, logs, traces, and events) into New Relic without the use of an installed agent. Data type Description Trace API Send distributed tracing data to New Relic. Event API Send event data to New Relic. Metric API Send metrics to New Relic from any source (including other telemetry monitoring services). Log API Send your log data to New Relic. Account management, admin, and usage APIs Like any other New Relic product or service, you want to be confident that your APIs protect you and your customers' data privacy. The following are API resources related to New Relic account administration and usage. For more information about API capabilities, see the specific New Relic API. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Resource Details REST API REST API features include: Find your API keys, account ID, and information needed to use the REST API. Return a list of account users (original user model only). Get SLA report data for browser and application monitoring. Subscription usage You can use the Query API to retrieve subscription usage data. This can be helpful to see how usage compares to your current subscription level, or for doing departmental chargebacks. Partner API To retrieve information about your New Relic partner account, sub-accounts, and users, use the Partner API. Other APIs Insights New Relic Insights was the name of our original product that governed custom event reporting and querying. The features associated with Insights have been rolled into our New Relic One platform (learn more), but there are still some APIs and original pricing plans that use the term \"Insights\" for these historical reasons. Insights-related APIs include: Resource Details Event API To report custom events, use the Event API. Query API To query your data using NRQL-format queries, you can use the Query API. Note that this API is deprecated and NerdGraph is preferred for querying your data. Dashboard API See the Insights Dashboard API. Plugins Use the REST API for New Relic plugins and the API Explorer to: Get a list of plugins, including their names, IDs, and GUIDs. List one or more plugin components, their output, and their metric timeslice data. Developers and New Relic partners can also use New Relic's Plugin API to write an agent in any language that can work directly with the API for plugins. This allows you to send your own metric data to our plugins and view data received from the API in New Relic. See APIs in action For more on how you as a developer can optimize your ability to solve problems using New Relic, go to developer.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 123.0499,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Get</em> <em>started</em>",
        "body": ", an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph is the preferred API for querying New Relic data and making a range of feature configurations. To <em>get</em> <em>started</em>, see Introduction to NerdGraph. REST APIs"
      },
      "id": "609fa5cf196a67066022b194"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.821686,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the Java <em>agent</em>",
        "sections": "Compatibility and requirements for the Java <em>agent</em>",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " method. The Java <em>agent</em> reports the database name and database server&#x2F;identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, <em>get</em> support at support.newrelic.com. Hosting services You can install"
      },
      "id": "6043b8f6196a6771a9960f87"
    },
    {
      "sections": [
        "APM agent security: Java",
        "Default security settings",
        "Caution",
        "High security mode settings",
        "Custom security settings"
      ],
      "title": "APM agent security: Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "fd9f5744c001453dbb9f129480f4e7e5ce42a176",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/apm-agent-security-java/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives, you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see Java agent error configuration. By default, here is how the New Relic Java agent handles the following potentially sensitive data:: Request parameters: The agent does not capture HTTP request parameters. HTTPS: The agent communicates with New Relic using HTTPS. SQL: The agent sets SQL recording to obfuscated, which removes the potentially sensitive numeric and string literal values. High security mode settings When you enable high security mode, the default settings are locked so that users cannot change them. In addition: The agent does not collect message queue parameters. You cannot create custom events. You cannot implement custom instrumentation using the Custom Instrumentation Editor. You cannot collect user attributes. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: Java agent configuration file Custom attributes Java agent API Setting Effects on data security audit_mode boolean Default: false By default, the Java agent does not log all data sent to New Relic in the agent log file. If you set this to true, the agent logs data sent to the New Relic collector in the agent log file. You can then evaluate the information that the agent sends by reviewing the agent log file to see if it includes sensitive information. high_security boolean Default: false To enable high security mode, set this to true and enable high security in New Relic. This restricts the information you can send to New Relic. proxy_host string Default: (none) Some proxies default to using HTTP, which is a less secure protocol. attributes.enabled boolean Default: true Default for the Custom Instrumentation Editor: false By default, you are sending attributes to New Relic, except for methods instrumented using the Custom Instrumentation Editor. If you do not want to send attributes to New Relic, set this to false. attributes.exclude string Default: (none) If there are specific attribute keys that you do not want to send to New Relic in transaction traces, identify them using attributes.exclude. This restricts the information sent to New Relic. Consider if you want to exclude these potentially sensitive attributes using attributes.exclude or if you need the information sent to New Relic: request.headers.*: Removes all request headers. (Note that HTTP headers that contain sensitive data such as cookie and authorization are never collected.) response.headers.*: Removes all response headers. request_uri: Removes the path for the transaction's incoming request. log_sql boolean Default: false By default, you are sending queries to New Relic using record_sql. If you want to log queries in the agent log file as well as send them to New Relic, set this to true. record_sql string Default: obfuscated By default, record_sql is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to off. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. strip_exception_messages boolean Default: false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. If you are not using high security mode but still want to strip messages from all exceptions except those in your allow list, set this to true. custom_insights_events.enabled boolean Default: true By default, the agent records events sent to the Event API via recordCustomEvent(). If you enable high security mode, this is automatically set to false.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.82158,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>agent</em> security: Java",
        "sections": "APM <em>agent</em> security: Java",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": "The New Relic Java <em>agent</em> default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives"
      },
      "id": "6043b8bb28ccbc3db92c60b7"
    }
  ],
  "/docs/agents/net-agent/index": [
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 76.12555,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> attributes",
        "sections": "<em>Agent</em> attributes",
        "tags": "<em>Agents</em>",
        "body": " called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following <em>agents</em> support the addition of custom user attributes to span events: Java <em>agent</em> 5.13.0 and above Go <em>agent</em> 3.6.0 and above .<em>NET</em> <em>agent</em> 8.25 and above Node"
      },
      "id": "603eb9db28ccbc127aeba79e"
    },
    {
      "sections": [
        ".NET agent configuration",
        "Configuration overview",
        "Important",
        "Configuration methods and precedence levels",
        "Required environment variables",
        "Caution",
        ".NET Framework environment variables",
        ".NET Core environment variables",
        "Profiler conflict explanation",
        "Optional environment variables",
        "Setup options, newrelic.config",
        "Configuration element",
        "agentEnabled",
        "maxStackTraceLines",
        "timingPrecision",
        "Service element",
        "licenseKey (required)",
        "sendEnvironmentInfo",
        "syncStartup",
        "sendDataOnExit",
        "sendDataOnExitThreshold",
        "completeTransactionsOnThread",
        "requestTimeout",
        "autoStart",
        "ssl (DEPRECATED)",
        "Obscuring key element",
        "Proxy element",
        "host",
        "port",
        "uriPath",
        "domain",
        "user",
        "password",
        "passwordObfuscated",
        "Log element",
        "level",
        "auditLog",
        "console",
        "directory",
        "fileName",
        "Application element (required)",
        "name",
        "disableSamplers",
        "Data transmission element",
        "putForDataSend",
        "Host name",
        "Set using config file",
        "Set using environment variable",
        "Cloud platform utilization",
        "detectAws",
        "detectAzure",
        "detectGcp",
        "detectPcf",
        "detectDocker",
        "detectKubernetes",
        "Instrumentation options",
        "Instrumentation element",
        "Applications element (instrumentation)",
        "Attributes element",
        "enabled",
        "include",
        "exclude",
        "Feature options",
        "App pools",
        "defaultBehavior",
        "applicationPool",
        "Cross application traces",
        "Error collection",
        "Tip",
        "captureEvents",
        "maxEventSamplesStored",
        "ignoreClasses",
        "ignoreMessages",
        "ignoreErrors (DEPRECATED)",
        "ignoreStatusCodes",
        "expectedClasses",
        "expectedMessages",
        "expectedStatusCodes",
        "attributes",
        "High security mode",
        "Strip exception messages",
        "Transaction events",
        "maximumSamplesStored",
        "Custom events",
        "Custom parameters",
        "Labels (tags)",
        "Browser instrumentation",
        "autoInstrument",
        "requestPathsExcluded",
        "Slow queries",
        "Transaction traces",
        "transactionThreshold",
        "recordSql",
        "explainEnabled",
        "explainThreshold",
        "maxSegments",
        "maxExplainPlans",
        "Datastore tracer",
        "instanceReporting",
        "databaseNameReporting",
        "queryParameters",
        "Distributed tracing",
        "excludeNewrelicHeader",
        "Disable span events via config file",
        "Disable span events via environment variable",
        "Infinite Tracing",
        "trace_observer",
        "Span events",
        "Settings in app.config or web.config",
        "Enable and disable the agent",
        "Application name",
        "License key",
        "Change newrelic.config location",
        "Settings in appsettings.json"
      ],
      "title": ".NET agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Configuration"
      ],
      "external_id": "b89fa7fc399f2729bfee8f5106e777798a73177a",
      "image": "https://docs.newrelic.com/static/cffd7eb2d22c8e338531c38f35208c7c/c1b63/net-agent-config-settings-precedence_0.png",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/configuration/net-agent-configuration/",
      "published_at": "2021-05-28T17:00:56Z",
      "updated_at": "2021-05-15T16:33:07Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains the configuration options for the APM .NET agent. Configuration overview APM agent configuration options allow you to control some aspects of how the agent behaves. Some of these config options are part of the basic install process (like setting your license key and app name), but most are more advanced settings, such as: setting a log level, setting up proxy host access, excluding certain attributes, and enabling distributed tracing. The .NET agent gets its configuration from the newrelic.config file, which is generated as part of the install process. By default, only a global newrelic.config file is created, but you can also create app-local newrelic.config files for finer control over a multi-app system. Other ways to set config options include: using environment variables, or setting server-side configuration from the UI. For more on the various config options and what overrides what, see Config settings precedence. Support for both .NET Framework and .NET Core use the same configuration options and have the same APM features, unless otherwise stated. If you make changes to the config file and want to validate that it's in the right format, you can check it against the XSD file (for example, at C:\\ProgramData\\New Relic\\.NET Agent\\newrelic.xsd for Windows) with any XSD validator. Important For IIS: after you change your newrelic.config or app.config file, perform an IISRESET from an administrative command prompt. Log level adjustments do not require a reset. Configuration methods and precedence levels Upon installation, the .NET agent's configuration file (newrelic.config) applies to all monitored applications, but you can configure the agent in other ways. Here's a diagram showing how different configuration options take precedence over one another: This diagram explains the order of precedence for different ways you might configure the .NET agent. Here are details about the configuration methods shown in the diagram, and their precedence levels: .NET configuration Details and precedence web.config or app.config or appsettings.json Configuration settings set in these files take highest precedence. However, if the agent is disabled in the local or global newrelic.config, the NewRelic.AgentEnabled settings in these files will be ignored. Environment variables Second-highest precedence. For more about these, see .NET environment variables. Server-side configuration Third-highest precedence. A limited number of server-side configuration settings are available; the other settings will come from other configuration sources. App-local newrelic.config Fourth-highest precedence. You can create app-local newrelic.config files to configure individual apps on a multi-app system. These local configuration files override settings in the global newrelic.config file. The agent looks for app-local config files in the following directories, in this order: A directory specified in your web.config or app.config file with the NewRelic.ConfigFile property The web app's root directory (with the app.config or web.config) The directory containing your app's executable file Note that the app-local config file must be complete and validate against the XSD file (for example, at C:\\ProgramData\\New Relic\\.NET Agent\\newrelic.xsd for Windows). Default (global) newrelic.config Default source and the lowest precedence. Will configure all applications on a host in the absence of other config files. The global config file is located in the New Relic agent home directory: %PROGRAMDATA%\\New Relic\\.NET Agent Required environment variables New Relic's .NET agent relies on environment variables to tell the .NET Common Language Runtime (CLR) to attach New Relic to your processes. Some .NET agent install procedures (like the MSI installer) will automatically set these variables for you; some procedures will require you to manually set them. Caution Security recommendation: You should consider what users can set system environment variables. You should also secure the accounts under which your applications execute to prevent user environment variables overriding system environment variables .NET Framework environment variables For .NET Framework, the following variables are required: COR_ENABLE_PROFILING=1 COR_PROFILER={71DA0A04-7777-4EC6-9643-7D28B46A8A41} NEWRELIC_INSTALL_PATH=path\\to\\agent\\directory Copy The .NET agent installer will add these to IIS or as system-wide environment variables. .NET Core environment variables For .NET Core, the following variables are required: Linux: CORECLR_ENABLE_PROFILING=1 CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_NEWRELIC_HOME=path/to/agent/directory CORECLR_PROFILER_PATH=\"${CORECLR_NEWRELIC_HOME}/libNewRelicProfiler.so\" Copy Windows: CORECLR_ENABLE_PROFILING=1 CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} NEWRELIC_INSTALL_PATH=path\\to\\agent\\directory CORECLR_NEWRELIC_HOME=path\\to\\agent\\directory Copy The .NET agent installer will add these to IIS or as system-wide environment variables. If your system has previously used monitoring services (non-New Relic), you may have a \"profiler conflict\" when trying to install and use the New Relic agent. More details: Profiler conflict explanation New Relic’s .NET agents rely on environment variables to tell the .NET Common Language Runtime (CLR) to load New Relic into your processes. The install-related environment variables are Microsoft variables, not New Relic variables. They can be used by other .NET profilers, and only one profiler can be attached to a process at a time. For this reason, if you have used previous application monitoring products, you may have profiler conflicts. For specific install instructions, see the .NET agent install documentation. Optional environment variables Some configuration options in New Relic's .NET agent can be set via environment variables as an alternative to setting them in a config file. Below is a list of environment variables recognized by the .NET agent with example values. NEW_RELIC_LICENSE_KEY=XXXXXXXX NEW_RELIC_LOG=MyApp.log NEW_RELIC_APP_NAME=Descriptive Name MAX_TRANSACTION_SAMPLES_STORED=500 MAX_EVENT_SAMPLES_STORED=500 NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true NEW_RELIC_SPAN_EVENTS_ENABLED=false NEW_RELIC_LABELS=foo:bar;zip:zap NEW_RELIC_CONFIG_OBSCURING_KEY=XXXXXXXX NEW_RELIC_DISABLE_SAMPLERS=true NEWRELIC_PROFILER_LOG_DIRECTORY=path\\to\\agent\\directory (not configurable via config file) Copy Setup options, newrelic.config Use these options to setup and configure your agent via the newrelic.config file. The New Relic .NET agent supports the following categories of setup options: Configuration element Service element Obscuring key element Proxy element Log element Application element (configuration) Data transmission element Host name Configuration element The root element of the configuration document is a configuration element. <configuration xmlns=\"urn:newrelic-config\" agentEnabled=\"true\" maxStackTraceLines=\"50\" timingPrecision=\"low\"> Copy The configuration element supports the following attributes: agentEnabled Type Boolean Default true Enable or disable the New Relic agent. maxStackTraceLines Type Integer Default 80 The maximum number of stack frames to trace in any stack dump. timingPrecision Type String Default low Controls the precision of the timers. High precision will provide better data, but at a lower execution speed. Possible values are high and low. Service element The first child of the configuration element is a service element. The service element configures the agent's connection to the New Relic service. <service licenseKey=\"YOUR_LICENSE_KEY\" sendEnvironmentInfo=\"true\" syncStartup=\"false\" sendDataOnExit=\"false\" sendDataOnExitThreshold=\"60000\" autoStart=\"true\"/> Copy The service element supports the following attributes: licenseKey (required) Type String Default (none) Your New Relic license key. New Relic uses the license key to match your app's data to the correct account in the UI. Set the license key via environment variable. Alternatively, set the NEW_RELIC_LICENSE_KEY environment variable in the application's environment. NEW_RELIC_LICENSE_KEY=XXXXXXXX Copy sendEnvironmentInfo Type Boolean Default true Instructs the agent to record execution environment information. Environment information includes operating system, agent version, and which assemblies are available. syncStartup Type Boolean Default false Block application startup until the agent connects to New Relic. If set to true, the first transaction may take substantially longer to complete, because it is blocked until the connection to New Relic is finished. sendDataOnExit Type Boolean Default false Block application shutdown until the agent sends all data from the latest harvest cycle. sendDataOnExitThreshold Type Integer Default 60000 Unit Milliseconds The minimum amount of time the process must run before the agent blocks it from shutting down. This setting only applies when sendDataOnExit is true. completeTransactionsOnThread Type Boolean Default false If false, the agent uses a pool thread to complete the transaction processing. If true, the agent will complete transaction processing on the request thread. requestTimeout Type Integer Default 2000 (sendDataOnExit enabled) 120000 (sendDataOnExit disabled) Unit Milliseconds The agent's request timeout when communicating with New Relic. autoStart Type Boolean Default True Automatically start the .NET agent when the first instrumented method is hit. ssl (DEPRECATED) Type Boolean Default true The option to disable SSL is valid only for .NET agent versions 7.x and earlier. .NET agent version 8.x and higher communicate only via SSL. The agent communicates with New Relic via HTTPS by default, and New Relic requires HTTPS for all traffic to APM and the New Relic REST API. Obscuring key element The obscuringKey element is an optional child of the service element. The .NET Agent uses this value to deobfuscate supported configuration values. For example, when an obfuscated proxy password is supplied, it will be deobfuscated using this key. <service licenseKey=\"YOUR_LICENSE_KEY\"> <obscuringKey>OBSCURING_KEY</obscuringKey> </service> Copy The obscuring key may also be configured by setting the NEW_RELIC_CONFIG_OBSCURING_KEY environment variable. Caution Security recommendation: The placement of the obscuring Key in the same configuration file as an obfuscated value may pose a security risk. Consider placing the obscuring key in an environment variable and limiting access to environment variables within your environment. Proxy element The proxy element is an optional child of the service element. The proxy element is used when the agent communicates to the New Relic back-end service via a proxy. <service licenseKey=\"YOUR_LICENSE_KEY\"> <proxy host=\"hostname\" port=\"PROXY_PORT\" uriPath=\"path/to/something.aspx\" domain=\"mydomain.com\" user=\"PROXY_USERNAME\" password=\"PROXY_PASSWORD\" passwordObfuscated=\"OBFUSCATED_PROXY_PASSWORD\"/> </service> Copy The proxy element supports the following attributes: host Type String Default (none) Defines the proxy host. port Type Integer Default 8080 Defines the proxy port. uriPath Type String Default (none) Optionally define a proxy URI path. domain Type String Default (none) Optionally define a domain to use when authenticating with the proxy server. user Type String Default (none) Optionally define a user name for authentication. password Type String Default (none) Optionally define a password for authentication. passwordObfuscated Type String Default (none) For additional security, the .NET Agent supports the use of an obfuscated proxy password with the passwordObfuscated attribute. The obfuscated proxy password is generated using the following New Relic CLI command: newrelic agent config obfuscate --key OBSCURING_KEY --value \"CLEAR_TEXT_PROXY_PASSWORD\" Copy Important When using an obfuscated proxy password, the obscuring key must also be configured. Log element The log element is a child of the configuration element. The log element configures New Relic's logging . The agent generates its own log file to keep its logging information separate from your application's logs. <log level=\"info\" auditLog=\"false\" console=\"false\" directory=\"PATH\\TO\\LOG\\DIRECTORY\" fileName=\"FILENAME.log\" /> Copy The log element supports the following attributes: level Type String Default info Defines the level of detail recorded in the log file. Possible values, in increasing order of detail, are: off error warn info debug finest all Important Increasing the log level will increase New Relic's performance impact. auditLog Type Boolean Default false Records all data sent to and received from New Relic in both an auditlog log file and the standard log file. console Type Boolean Default false Send log messages to the console, in addition to the log file. directory Type String Default C:\\ProgramData\\New Relic\\.NET Agent\\Logs The directory to hold log files generated by the agent. If this is omitted, then a directory named logs in the New Relic agent install area will be used by default. fileName Type String Default (none) Defines a name for the log file. If you do not define a fileName, the name is derived from the name of the monitored process. Alternatively, set the NEW_RELIC_LOG environment variable in the application's environment. NEW_RELIC_LOG=MyApp.log Copy Application element (required) The application element is a child of the configuration element. This required element defines your application name, and disables or enables sampling. name Type String Default My Application The name of your .NET application is a child of the application element. New Relic will aggregate your data according to this name. For example, if you have two running applications named AppA and AppB, you will see two applications in the New Relic interface: AppA and AppB. You can also assign up to three names to your app. The first name is the primary name. For example: <application> <name>MY APPLICATION PRIMARY</name> <name>SECOND APP NAME</name> <name>THIRD APP NAME</name> </application> Copy Alternatively, set the NEW_RELIC_APP_NAME environment variable in the application's environment. NEW_RELIC_APP_NAME=Descriptive Name Copy disableSamplers Type Boolean Default false Samplers collect information about memory and CPU consumption. Set this to true to disable sampling. Alternatively, set the NEW_RELIC_DISABLE_SAMPLERS environment variable in the application's environment. NEW_RELIC_DISABLE_SAMPLERS=true Copy Data transmission element The dataTransmission element is a child of the configuration element. This element affects how data is sent to New Relic and can be used if you have specific data transmission requirements. <dataTransmission putForDataSend=\"false\" compressedContentEncoding=\"deflate\"/> Copy The dataTransmission element supports the following attributes: putForDataSend Type Boolean Default false Defines the HTTP method used when sending data to New Relic. Set this to true to enable using the PUT method when sending data. The POST method is used by default. Host name If the default host name label in the APM UI is not useful, you can decorate that name in the New Relic UI with a display name. After the application process is restarted and the .NET agent is reporting again, the display name will appear in the Servers drop-down list. This host name setting does not affect the list of hosts on your application's Summary page. To set a display name, choose one of the following options. The environment variable takes precedence over the config file value. Then restart your application to see your changes in the New Relic UI. Set using config file Set the displayName attribute in the processHost element in newrelic.config. The processHost element is a child of the configuration element. <configuration . . . > <processHost displayName=\"CUSTOM_NAME\" /> </configuration> Copy Set using environment variable Set the NEW_RELIC_PROCESS_HOST_DISPLAY_NAME environment variable: NEW_RELIC_PROCESS_HOST_DISPLAY_NAME = \"CUSTOM_NAME\" Copy Cloud platform utilization Configures the utilization configuration element to control how the agent collects utilization information and sends it to the New Relic service to determine pricing. The agent can collect information from Amazon Web Services (AWS) EC2 instances, Docker containers, Azure, Google Cloud Platform, Pivotal Cloud Foundry, and Kubernetes. detectAws Type Boolean Default true Determines whether the agent polls AWS metadata API. detectAzure Type Boolean Default true Determines whether the agent polls Azure metadata API. detectGcp Type Boolean Default true Determines whether the agent polls GCP metadata API. detectPcf Type Boolean Default true Determines whether the agent polls PCF information from environment variables. detectDocker Type Boolean Default true Determines whether the agent reads Docker information from the file system. detectKubernetes Type Boolean Default true Determines whether the agent polls Kubernetes information from environment variables. Instrumentation options Use these options to configure which elements of your application and environment to instrument. New Relic for .NET supports the following categories of instrumentation options: Instrumentation element Applications element (instrumentation) Attributes element Instrumentation element The instrumentation element is a child of the configuration element. By default, the .NET agent instruments IIS asp worker processes and Azure web and worker roles. To instrument other processes, see Instrumenting custom applications. Applications element (instrumentation) The applications element is a child of the instrumentation element. The applications element specifies which non-web apps to instrument. It contains a name attribute. Important This is not the same as the application (configuration) element, which is a child of the configuration element. <instrumentation> <applications> <application name=\"MyService1.exe\" /> <application name=\"MyService2.exe\" /> <application name=\"MyService3.exe\" /> </applications> </instrumentation> Copy Attributes element An attribute is a key/value pair that determines the properties of an event or transaction. Each attribute is sent to APM transaction traces, APM error traces, Transaction events, TransactionError events, or PageView events. The primary attributes element enables or disables attribute collection for the .NET agent, and defines specific attributes to collect or exclude. You can also configure attribute settings based on their destination: Error collection, transaction traces, Browser instrumentation, and transaction events. In this example, the agent excludes all attributes whose key begins with myApiKey (myApiKey.bar, myApiKey.value), but collects the custom attribute myApiKey.foo. <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> Copy You can view the .NET APM attributes on the .NET agent attributes page. You can also define custom attributes with the agent API call AddCustomParameter. enabled Type Boolean Default true Enable or disable attribute collection. When set to false in the primary attribute element, this setting overrides all attribute settings for individual destinations. include Type String Default (none) If attributes are enabled, the agent will collect all attribute keys specified in this list. To specify multiple attribute keys, specify each individually. You can also use a * wildcard character at the end of a key to match multiple attributes (for example, myApiKey.*). For more information, see Attribute rules. exclude Type String Default (none) If attributes are enabled, the agent will not collect attribute keys specified in this list. To specify multiple attribute keys, specify each individually. You can also use a * wildcard character at the end of a key to match multiple attributes (for example, myApiKey.*). For more information, see Attribute rules. Feature options Use these options to enable, disable, and configure New Relic features. New Relic for .NET allows you to configure the following features: App pools Cross application traces Error collection High security mode Strip exception messages Transaction events Custom events Custom parameters Tags/labels Browser instrumentation Slow Queries Transaction traces Datastore tracer Distributed tracing Span events App pools Important This is only applicable to a system's global config file. The applicationPools element is a child of the configuration element. The applicationPools element specifies for the profiler exactly which application pools to instrument and uses the same name as the IIS application pool name. This configuration element is useful when you may need to instrument only a small subset of your app pools. For example, a given server might have several hundred application pools, but only a few of those pools need to be instrumented by the .NET agent. Here is an example of disabling instrumentation for specific application pools: <applicationPools> <applicationPool name=\"Foo\" instrument=\"false\"/> <applicationPool name=\"Bar\" instrument=\"false\"/> </applicationPools> Copy Here is an example of disabling instrumentation for all application pools currently executing on the server and enabling instrumentation for specific application pools: <applicationPools> <defaultBehavior instrument=\"false\"/> <applicationPool name=\"Foo\" instrument=\"true\"/> <applicationPool name=\"Bar\" instrument=\"true\"/> </applicationPools> Copy The applicationPools element supports the following elements: defaultBehavior Type Boolean Default false Defines how the .NET agent will behave on a \"global\" level for application pools served via IIS. The .NET agent instruments all application pools by default. When true, application pools listed under applicationPool with an instrument attribute set to false will not be instrumented. Essentially, when set to false, the application pool list acts as an allow list. When set to true, the application pool list acts as a deny list. applicationPool Defines instrumentation behavior for a specific application pool. The name attribute is the name of an application pool. Enable or disable profiling in the instrument attribute. Define this application in the name attribute. Cross application traces The crossApplicationTracer element is a child of the configuration element. crossApplicationTracer links transaction traces across applications. When linked in a service-oriented architecture, all instrumented applications that communicate with each other via HTTP will now \"link\" transaction traces with the applications that they call and the applications they are called by. Cross application tracing makes it easier to understand the performance relationship between services and applications. <crossApplicationTracer enabled=\"true\"/> Copy The crossApplicationTracer element supports the following attribute: enabled Type Boolean Default true Enable or disable cross application tracing Error collection The errorCollector element is a child of the configuration element. errorCollector configures error collection, which captures information about uncaught exceptions and sends them to New Relic. <errorCollector enabled=\"true\" captureEvents=\"true\" maxEventSamplesStored=\"100\"> <ignoreClasses> <errorClass>System.IO.FileNotFoundException</errorClass> <errorClass>System.Threading.ThreadAbortException</errorClass> </ignoreClasses> <ignoreMessages> <errorClass name=\"System.Exception\"> <message>Ignore message</message> <message>Ignore too</message> </errorClass> </ignoreMessages> <ignoreStatusCodes> <code>401</code> <code>404</code> </ignoreStatusCodes> <expectedClasses> <errorClass>System.ArgumentNullException</errorClass> <errorClass>System.ArgumentOutOfRangeException</errorClass> </expectedClasses> <expectedMessages> <errorClass name=\"System.Exception\"> <message>Expected message</message> <message>Expected too</message> </errorClass> </expectedMessages> <expectedStatusCodes>403,500-505</expectedStatusCodes> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </errorCollector> Copy Tip For an overview of error configuration in APM, see Manage errors in APM. The errorCollector element supports the following elements and attributes: enabled Type Boolean Default true Enable or disable the error collector. captureEvents Type Boolean Default true Enable or disable the capturing of error events. maxEventSamplesStored Type Integer Default 100 Reservoir limit for error events. ignoreClasses A list of fully qualified class names to be ignored. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used ignoreMessages An optional map of fully qualified class names to list of strings matching a substring of the message of an error. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used ignoreErrors (DEPRECATED) Type String Default (none) Lists specific exceptions to not report to New Relic. The full name of the exception should be used, such as System.IO.FileNotFoundException. ignoreStatusCodes Type String Default (none) Lists specific HTTP error codes to not report to New Relic. You can use standard integral HTTP error codes, such as just 401, or you may use Microsoft full status codes with decimal points, such as 401.4 or 403.18. The status codes should be equal to or greater than 400. expectedClasses A list of fully qualified class names to be marked as expected. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used expectedMessages An optional map of fully qualified class names to list of strings matching a substring of the message of an error. The maximum number of error class and message combinations that SHOULD be reported is 50. If more than 50 are listed, then only the first 50 SHOULD be used expectedStatusCodes A comma separated list of status codes. The list may include integer ranges, using a single dash (-) and will be inclusive of both the starting and ending integer in the range. attributes Use this sub-element to customize your agent attribute settings for error traces. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. High security mode The highSecurity element is a child of the configuration element. To enable high security mode, set this property to true and enable high security property in the New Relic user interface. Enabling high security means SSL is turned on, request parameters and custom parameters are not collected, strip exception messages is enabled, and queries cannot be sent to New Relic in their raw form. enabled Type Boolean Default false Enable or disable high security mode. Example: <highSecurity enabled=\"true\"/> Copy Strip exception messages The stripExceptionMessages element is a child of the configuration element. To enable strip exception messages, set this property to true. By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. enabled Type Boolean Default false Enable or disable strip exception messages. Example: <stripExceptionMessages enabled=\"true\"/> Copy Transaction events The transactionEvents element is a child of the configuration element. Use transactionEvents to configure transaction events. <transactionEvents enabled=\"true\" maximumSamplesStored=\"10000\"> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </transactionEvents> Copy The transactionEvents element supports the following attributes: enabled Type Boolean Default true Enable or disable the event recorder. maximumSamplesStored Type Integer Default 10000 The maximum number of samples to store in memory at once. Alternatively, set the MAX_TRANSACTION_SAMPLES_STORED environment variable in the application's environment. MAX_TRANSACTION_SAMPLES_STORED=500 Copy attributes Use this sub-element to customize your agent attribute settings for transaction events. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. Tip These attribute settings are specific to transaction events. Attribute settings can be applied globally to all event types to with this configuration setting. Caution When distributed tracing and/or Infinite Tracing are enabled, information from transaction events is applied to the root Span Event of the transaction. Consider applying any attribute settings for transaction events to span events and/or apply them as Global Attribute settings. Custom events The customEvents element is a child of the configuration element. Use customEvents to configure custom events. <customEvents enabled=\"true\" maximumSamplesStored=\"10000\"/> Copy The CustomEvents element supports the following attributes: enabled Type Boolean Default true Enable or disable the event recorder. maximumSamplesStored Type Integer Default 10000 The maximum number of samples to store in memory at once. Alternatively, set the MAX_EVENT_SAMPLES_STORED environment variable in the application's environment. MAX_EVENT_SAMPLES_STORED=500 Copy Custom parameters The customParameters element is a child of the configuration element. Use customParameters to configure custom parameters. <customParameters enabled=\"true\" /> Copy The CustomParameters element supports the following attributes: enabled Type Boolean Default true Enable or disable the capture of custom parameters. Labels (tags) The labels element is a child of the configuration element. This sets tag names and values. The list is a semicolon delimited list of colon-separated name and value pairs. You can also use with the NEW_RELIC_LABELS environment variable. Example: <labels>foo:bar;zip:zap</labels> Copy Browser instrumentation The browserMonitoring element is a child of the configuration element. browserMonitoring configures Browser monitoring in your .NET application. Browser gives you insight your end users' performance experience. This is accomplished by measuring the time it takes for your users' browsers to download and render your webpages by injecting a small amount of JavaScript code into the header and footer of each page. // If you use both the Exclude and Attribute elements // the Exclude element must be listed first. <browserMonitoring autoInstrument=\"true\"> <requestPathsExcluded> <path regex=\"url-regex-1\"/> <path regex=\"url-regex-2\"/> ... <path regex=\"url-regex-n\"/> </requestPathsExcluded> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </browserMonitoring> Copy The browserMonitoring element supports the following attributes: autoInstrument Type Boolean Default true By default the agent automatically injects the Browser agent JavaScript. To turn off automatic injection, set this attribute to false. attributes Use this sub-element to customize your agent attribute settings for Browser. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. requestPathsExcluded Use this sub-element to prevent the Browser agent from being injected in specific pages. The element is used as follows: <requestPathsExcluded> <path regex=\"url-regex-1\"/> <path regex=\"url-regex-2\"/> ... <path regex=\"url-regex-n\"/> </requestPathsExcluded> Copy The agent will not inject the Browser agent into pages whose URL matches one of the specified regular expressions. The regular expression should follow Microsoft guidelines for the Regex class. It is a reference to the virtual directory of the path in your application and not the full URL of the path you wish to exclude. For example, to exclude the pages in https://www.mywebsite.com/mywebpages/ you would simply insert /mywebpages/ as the path regex value. The requestPathsExcluded element should be used in cases where it is impossible or undesirable to use the DisableBrowserMonitoring() call. To minimize a possible performance impact try to use as few regular expressions as possible and keep them as simple as possible. Slow queries The slowSql element is a child of the configuration element. slowSql configures capturing information about slow query executions, and captures and obfuscates explain plans for these queries. <slowSql enabled=\"true\"/> Copy The slowSql element supports the following attribute: enabled Type Boolean Default true Enable or disable slow query tracing. Transaction traces The transactionTracer element is a child of the configuration element. transactionTracer configures transaction traces. Included in the trace is the exact call sequence of the transactions, including any query statements issued. <transactionTracer enabled=\"true\" transactionThreshold=\"apdex_f\" recordSql=\"obfuscated\" explainEnabled=\"true\" explainThreshold=\"500\" maxSegments=\"3000\" maxExplainPlans=\"20\"> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </transactionTracer> Copy The transactionTracer element supports the following attributes: enabled Type Boolean Default true Enable or disable transaction traces. transactionThreshold Type String Default apdex_f Defines the threshold for transaction traces. If a transaction takes longer than the threshold, it is eligible for being traced. See transaction trace basics for more about the rules governing traces. The default value is apdex_f, which sets the threshold to four times the application's apdex_t value. For more information about apdex_t, see Apdex. You can also set the threshold to be a specific time value in milliseconds. recordSql Type String Default obfuscated Select a query tracing policy. Options are off, which records nothing; obfuscated, which records an obfuscated version of the query; or raw, which records the query exactly as it is issued to the database. Caution Recording raw queries may capture sensitive information. explainEnabled Type Boolean Default false When true, the agent captures EXPLAIN statements for slow queries. explainThreshold Type Integer Default 500 Unit Milliseconds The agent collects slow query data for queries that exceed this threshold, along with any available explain plans, as part of transaction traces. maxSegments Type Integer Default 3000 The maximum number of segments to collect in a transaction trace. maxExplainPlans Type Integer Default 20 The maximum number of explain plans to collect during a harvest cycle. attributes Use this sub-element to customize your agent attribute settings for transaction traces. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. Datastore tracer The datastoreTracer element is a child of the configuration element. <datastoreTracer> <instanceReporting enabled=\"true\" /> <databaseNameReporting enabled=\"true\" /> <queryParameters enabled=\"false\" /> </datastoreTracer> Copy The datastoreTracer element supports the following sub-elements: instanceReporting Use this sub-element to enable collection of datastore instance metrics (such as the host and port) for some database drivers. These are reported on slow query traces and transaction traces. The default value of attribute enabled is true. databaseNameReporting Use this sub-element to enable collection of the database name on slow query traces and transaction traces for some database drivers. The default value of attribute enabled is true. queryParameters Use this sub-element to enable collection of the SQL query parameters on slow query traces. The default value of attribute enabled is false. Caution Recording query parameters may capture sensitive information. The transactionTracer.recordSql configuration option must be set to raw or this option is ignored. Distributed tracing The distributedTracing element is a child of the configuration element. <distributedTracing enabled=\"false\" excludeNewrelicHeader=\"false\"/> Copy Distributed tracing lets you see the path that a request takes as it travels through a distributed system. Enabling distributed tracing disables cross application tracing, and has other effects on APM features. Before enabling, read the planning guide. Important Requires .NET agent version 8.6.45.0 or higher. The distributedTracing element supports the following attributes: To enable or disable, see Enable distributed tracing. enabled Type Boolean Default false Alternatively, enable distributed tracing via the NEW_RELIC_DISTRIBUTED_TRACING_ENABLED environment variable in the application's environment. NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true Copy excludeNewrelicHeader Type Boolean Default false By default, supported versions of the agent utilize both the newrelic header and W3C Trace Context headers for distributed tracing. The newrelic distributed tracing header allows interoperability with older agents that don't support W3C Trace Context headers. Agent versions that support W3C Trace Context headers will prioritize them over newrelic headers for distributed tracing. If you do not want to utilize the newrelic header, setting this to true will result in the agent excluding the newrelic header and only using W3C Trace Context headers for distributed tracing. Distributed tracing reports span events. Span event reporting is enabled by default, but distributed tracing must be enabled for spans to be reported. To disable span events, choose one of the following options: Disable span events via config file Set the <spanEvents> element to false to disable via the newrelic.config file. This element is a child of the <configuration> element. <configuration . . . > <spanEvents enabled=\"false\" /> </configuration> Copy Disable span events via environment variable Set the NEW_RELIC_SPAN_EVENTS_ENABLED environment variable in the application's environment. NEW_RELIC_SPAN_EVENTS_ENABLED=false Copy Infinite Tracing Infinite Tracing extends the distributed tracing service by employing a trace observer that is external to the agent. It observes 100% of your application traces across various services and provides actionable data so you can solve issues faster. Important Infinite Tracing requires .NET Agent version 8.30 or higher. To turn on Infinite Tracing, enable distributed tracing and add the additional settings below <configuration . . . > <distributedTracing enabled=\"true\" /> <infiniteTracing> <trace_observer host=\"YOUR_TRACE_OBSERVER_HOST\" /> </infiniteTracing> </configuration> Copy The infiniteTracing element supports the following elements: trace_observer The trace_observer element identifies an observer host that is independent from the agent. For help getting a valid Infinite Tracing trace observer host entry, see Find or create a trace observer endpoint. The trace observer may be configured using the NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST environment variable as well. Important When configuring the trace observer, you should not supply the protocol as part of the host. For example, use myhost.infinitetracing.com instead of https://myhost.infinitetracing.com. Span events The spanEvents element is a child of the configuration element. Use spanEvents to configure span events. <spanEvents enabled=\"true\"> <attributes enabled=\"true\"> <exclude>myApiKey.*</exclude> <include>myApiKey.foo</include> </attributes> </spanEvents> Copy The spanEvents element supports the following attributes: enabled Type Boolean Default true Enable or disable the event recorder. attributes Use this sub-element to customize your agent attribute settings for span events. This sub-element uses the same settings as the primary attributes element: enabled, include, and exclude. Tip These attribute settings are specific to span events. Attribute settings may be applied globally to all event types to with this configuration setting. Settings in app.config or web.config For ASP.NET and .NET Framework console apps you can also configure the following settings in your app's app.config or web.config, within the outermost element, <configuration>: Enable and disable the agent <appSettings> <add key = \"NewRelic.AgentEnabled\" value=\"false\" /> </appSettings> Copy Important If the agent is disabled in the local or global newrelic.config, the NewRelic.AgentEnabled settings in these files will be ignored. Application name For more information, see Name your .NET application. <appSettings> <add key = \"NewRelic.AppName\" value =\"Descriptive Name\" /> </appSettings> Copy License key <appSettings> <add key = \"NewRelic.LicenseKey\" value =\"XXXXXXXX\" /> </appSettings> Copy Change newrelic.config location Designates an alternative location for the config file outside of the local root of the app or global config location. The location entered must be an absolute path. <appSettings> <add key = \"NewRelic.ConfigFile\" value=\"C:\\Path-to-alternate-config-dir\\newrelic.config\" /> </appSettings> Copy Settings in appsettings.json For .NET Core apps, you can configure the following settings in appsettings.json if the following is true: The appsettings.json file must be located in the current working directory of the application. The application must have the following dependencies: Microsoft.Extensions.Configuration Microsoft.Extensions.Configuration.Json Microsoft.Extensions.Configuration.EnvironmentVariables Enable and disable the agent { \"NewRelic.AgentEnabled\":\"false\" } Copy Important If the agent is disabled in the local or global newrelic.config, the NewRelic.AgentEnabled setting in this file will be ignored. Application name For more information, see Name your .NET application. { \"NewRelic.AppName\": \"Descriptive Name\" } Copy License key { \"NewRelic.LicenseKey\": \"XXXXXXXX\" } Copy Change newrelic.config location Designates an alternative location for the config file outside of the local root of the app or global config location. The location entered must be an absolute path. { \"NewRelic.ConfigFile\": \"C:\\\\Path-to-alternate-config-dir\\\\newrelic.config\" } Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 61.369225,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> configuration",
        "sections": ".<em>NET</em> <em>agent</em> configuration",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " Relic), you may have a &quot;profiler conflict&quot; when trying to install and use the New Relic <em>agent</em>. More details: Profiler conflict explanation New Relic’s .<em>NET</em> <em>agents</em> rely on environment variables to tell the .<em>NET</em> Common Language Runtime (CLR) to load New Relic into your processes. The install-related"
      },
      "id": "60446c3b196a679d6a960f7a"
    },
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "68ae52e48b04bfe2279bcd038778cc5eebf53d1d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-06-02T17:53:04Z",
      "updated_at": "2021-05-15T18:25:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 61.108566,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use"
      },
      "id": "6043cd9528ccbcfe1e2c60aa"
    }
  ],
  "/docs/agents/net-agent/install-guides/install-net-agent-using-nuget": [
    {
      "sections": [
        "Install .NET agent for Windows Communication Foundation (WCF)",
        "Install for WCF applications",
        "Important",
        "ASP.NET pipeline events and WCF events",
        "Only WCF events"
      ],
      "title": "Install .NET agent for Windows Communication Foundation (WCF)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "c39d558ff81b712496798549087933ccabcc2586",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/other-installation/install-net-agent-windows-communication-foundation-wcf/",
      "published_at": "2021-06-02T16:16:56Z",
      "updated_at": "2021-03-16T04:35:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install the .NET agent and monitor WCF applications. Install for WCF applications To install the .NET agent on IIS-hosted WCF apps: Install the latest .NET agent. Important For self-hosted WCF applications (hosted as a custom Windows Service, a console app, or a Windows Forms app) take note of the instructions to enable the agent for your application. Ensure you give each WCF app a descriptive name. Enable or disable ASP.NET compatibility mode in your WCF application depending on which type of events you want monitored: ASP.NET pipeline events and WCF events When ASP.NET compatibility mode is enabled, the .NET agent instruments ASP.NET pipeline events as well as WCF events. In this mode, the agent provides you with a full view of your application stack. Only WCF events When ASP.NET compatibility mode is disabled, the .NET agent only instruments WCF events. Any activity that occurs as part of the ASP.NET pipeline will not be captured, such as agent API calls that are made outside of a WCF transaction. If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.88524,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .<em>NET</em> <em>agent</em> for Windows Communication Foundation (WCF)",
        "sections": "<em>Install</em> .<em>NET</em> <em>agent</em> for Windows Communication Foundation (WCF)",
        "tags": "<em>Other</em> <em>installation</em>",
        "body": "This document explains how to install the .<em>NET</em> <em>agent</em> and monitor WCF applications. Install for WCF applications To install the .<em>NET</em> <em>agent</em> on IIS-hosted WCF apps: Install the latest .<em>NET</em> <em>agent</em>. Important For self-hosted WCF applications (hosted as a custom Windows Service, a console app"
      },
      "id": "603ea62e196a679eb4a83d8d"
    },
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Tip",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "d0515c81825c0b108418459b6c14a510b540c206",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-06-02T16:16:54Z",
      "updated_at": "2021-03-16T14:59:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Tip To use .NET or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile FROM microsoft/dotnet:2.2-aspnetcore-runtime # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile FROM microsoft/dotnet:2.2-sdk AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet build -c Release -o /app/ ./YOUR_APP_NAME FROM microsoft/dotnet:2.2-aspnetcore-runtime AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM microsoft/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Copy the New Relic .NET agent installer COPY ./NewRelicDotNetAgent_x64.msi / # Install the agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i,\\ \"C:\\NewRelicDotNetAgent_x64.msi\",\\ /qn,NR_LICENSE_KEY=YOUR_LICENSE_KEY # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Copy the New Relic .NET agent installer COPY ./NewRelicDotNetAgent_x64.msi / # Install the agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"C:\\NewRelicDotNetAgent_x64.msi\", /qn, NR_LICENSE_KEY=YOUR_LICENSE_KEY # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windowsservercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.38911,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "<em>Install</em> .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>Other</em> <em>installation</em>",
        "body": " for either Windows or Linux. It&#x27;s just a matter of configuring your Dockerfile to perform the procedure. Tip To use .<em>NET</em> or any <em>other</em> <em>agent</em>, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB"
      },
      "id": "603e85bde7b9d2b26c2a07fd"
    },
    {
      "sections": [
        ".NET agent install resources",
        "Important",
        "Microsoft's .NET profiler",
        ".NET agent download library",
        "Zip files for manual .NET agent install (Windows)",
        "Caution",
        ".NET Framework environment variables for manual install",
        ".NET Core environment variables for manual install",
        "Need for custom instrumentation",
        "Install-related environment variables",
        "Scriptable installers (Windows only)",
        "Scriptable installer for .NET Framework",
        "Tip",
        "Scriptable installer for .NET Core",
        "Local install",
        "Global install"
      ],
      "title": ".NET agent install resources",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "15e6347108ca11e12ccb535fb9fc3fa90d3f4a40",
      "image": "",
      "url": "https://docs.newrelic.com/docs/net-agent-install-resources/",
      "published_at": "2021-06-02T15:59:06Z",
      "updated_at": "2021-03-16T02:42:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains detailed descriptions of resources and procedures that are referenced in the New Relic .NET agent install procedures. Important This document is not meant to be read as a standalone document. For install instructions, see Introduction to .NET agent install. Microsoft's .NET profiler New Relic’s .NET agent relies on the Microsoft profiling API to report data from your .NET application. .NET monitoring solutions other than New Relic can use this profiling API. But only one service can use the profiler at a time. This means that if you have used a .NET monitoring service in the past and haven’t completely disabled/removed it, the profiler may still be in use, which will cause profiler conflicts when you try to enable the .NET agent. .NET agent download library The New Relic .NET agent download library contains install file packages that are referenced in specific install procedures. For more on these files, see the download library’s ReadMe file. Zip files for manual .NET agent install (Windows) To manually install the agent using a ZIP file, choose the correct file for the application you wish to monitor: Go to the .NET agent download site and get the file matching your application's runtime and architecture: .NET Framework (32-bit): newrelic-agent-win-x86-VERSION.zip .NET Framework (64-bit): newrelic-agent-win-x64-VERSION.zip .NET Core (32-bit): newrelic-netcore20-agent-win-x86-VERSION.zip .NET Core (64-bit): newrelic-netcore20-agent-win-x64-VERSION.zip Unzip the agent folder in the desired location. Set environment variables for the process you wish to monitor. Caution We do not recommend setting these environment variables globally. Setting these environment variables globally can cause all .NET processes running on the system to get instrumented and report to New Relic. If you are installing the agent manually, we expect that you have the means to set these environment variables only for the processes you wish to monitor. .NET Framework environment variables for manual install For .NET Framework, the following variables are required: COR_ENABLE_PROFILING=1 COR_PROFILER={71DA0A04-7777-4EC6-9643-7D28B46A8A41} NEWRELIC_HOME=path\\to\\agent\\directory COR_PROFILER_PATH=path\\to\\agent\\directory\\NewRelic.Profiler.dll Copy .NET Core environment variables for manual install For .NET Core, the following variables are required: CORECLR_ENABLE_PROFILING=1 CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_NEWRELIC_HOME=path\\to\\agent\\directory CORECLR_PROFILER_PATH=path\\to\\agent\\directory\\NewRelic.Profiler.dll Copy Restart your application. If using IIS, restart IIS. If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears. Need for custom instrumentation After installing a .NET agent, most .NET application frameworks will automatically report data to your New Relic account. (See app framework compatibility: .NET Framework | .NET Core.) If your .NET application uses an application framework that is not automatically instrumented, or if the app has no framework (like a console app), after the install you will need to manually set up instrumentation of your app. Here are the steps to do that: Follow the relevant install instructions for your application and framework. Custom instrument your application to define what activity is reported to New Relic. Install-related environment variables A .NET agent install requires setting environment variables. For some install procedures (like for IIS-hosted .NET applications), these environment variables are set automatically. For other install procedures, you will have to manually set them. To see the required environment variables for both .NET Framework and .NET Core applications, see Environment variables. For installations requiring you to manually set environment variables, you can also set other configuration options via environment variables. Here's a look at two that are commonly set: License key. The environment variable for setting the New Relic license key is: NEW_RELIC_LICENSE_KEY = YOUR_LICENSE_KEY Copy You can also set this in the newrelic.config file or the app's config file. App name. Setting a meaningful application name is recommended, but you can also set this after install. The environment variable is: NEW_RELIC_APP_NAME = YOUR_APP_NAME Copy You can also set this via the newrelic.config, the app's config file, or the API. Scriptable installers (Windows only) The scriptable installers are ZIP archives containing a PowerShell script for installing the .NET agent. There is a separate zip archive for .NET Framework versus .NET Core. Important We recommend using the MSI installer over the scriptable installer. If you want to automate your install, consider running the MSI installer from the command line. Scriptable installer for .NET Framework To use the scriptable installer to install the .NET agent for a .NET Framework app: Ensure you have administrator rights for your Windows admin group. For more details on this, see the permissions documentation. Download the scriptable installer package for .NET Framework from the download site. By downloading or using one of these packages, you agree to and accept the license terms. Unzip the package. Open a command shell and navigate into the unzipped package's folder. For a simple install with no options, use this command: .\\install.cmd -LicenseKey YOUR_LICENSE_KEY Copy To install with one or more additional options, use the format below. See table below for a description of the install options. install.cmd -LicenseKey YOUR_LICENSE_KEY [-NoIISReset] [-InstrumentAll] [-InstallPath PATH_TO_INSTALL] Copy If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears. Install options Description LicenseKey Required. Your New Relic license key. NoIISReset Optional. Use this option to prevent the installer from initiating an IIS reset. Important If you use this option, you need to do an IIS reset manually before New Relic starts instrumenting any IIS-hosted applications. InstrumentAll Optional. By default, the .NET agent will instrument all IIS-hosted applications. Use this option to enable instrumentation of other types of .NET applications. InstallPath Optional. Use this option to choose a different installation location. The default install location is C:\\Program Files\\New Relic. Uninstalling the agent with the scriptable uninstaller: Tip You can add the Force option to the uninstall script to force an uninstall without prompting to restart IIS. Execute the following command to uninstall the .NET Framework agent: .\\uninstall.cmd Copy Scriptable installer for .NET Core Important Before installing the agent: Understand the agent requirements, including the permissions requirements. Note that admin rights in an elevated shell are required (specifically for selecting a custom log directory and performing an IISReset). Caution For security reasons, it is necessary to execute the installAgent.ps1 script as shown below, by prepending ./ to the script filename, rather than by prepending powershell to the script. If you execute the script by prepending powershell, and any of your supplied arguments (e.g. the install path or custom log path) have spaces in them, these arguments will be corrupted, which would lead to the agent being installed to a location other than the intended location, which could be unsecure. To use the scriptable installer to install the .NET agent for a .NET Core application: Ensure you have administrator rights for your Windows admin group. For more details on this, see the permissions documentation Download the .NET Core agent's scriptable installer package from the .NET agent download site . By downloading or using one of these packages, you agree to and accept the license terms. Unzip the package in the desired location. Open a command shell and navigate into the unzipped package's folder. You can install the agent either locally or globally: Local install For a simple install, with no options, use this command: ./installAgent.ps1 -destination PATH -installType global -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\"] Copy To install with one or more additional options, use the same command with desired options. For option descriptions, see table below. ./installAgent.ps1 -destination PATH -installType local -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\" -X86 -ResetIIS -Force] Copy Global install Important The global install will instrument all .NET Core processes on your system. Only choose the global install if you want all .NET Core processes monitored. For a simple install with no options, use this command: ./installAgent.ps1 -destination PATH -installType global -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\"] Copy To install with one or more additional options, use the same command with desired options. For option descriptions, see table below. ./installAgent.ps1 -destination PATH -installType local -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\" -X86 -ResetIIS -Force] Copy If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears. Install options Description Destination Required. The location where the agent is installed. This can be an absolute or relative path. Wrapping quotes are required. InstallType Required. Determines whether this is a local (app-specific) or global (system-wide) install. LicenseKey Required. Your New Relic license key. AppName Optional. Sets the default application name associated with your agent installation. LogDir Optional. Sets a custom logging location for the agent. By default, the agent puts the logs directory in the install directory. X86 Optional. Installs the 32-bit version of the agent rather than the 64-bit version. New Relic does not recommend installing the 32-bit version of the agent globally. ResetIIS Optional. Performs an iisreset after the installation. Important Only use this if your .NET Core app is hosted via an IIS reverse proxy. Force Optional. Forces the installation process to overwrite a previous install or to install into an existing folder. Caution This overwrites any configuration customizations. New Relic recommends backing up your configuration file and any custom instrumentation files prior to forcing an over-install. Help Optional. Displays usage information for this script.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.09369,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> <em>install</em> resources",
        "sections": ".<em>NET</em> <em>agent</em> <em>install</em> resources",
        "tags": "<em>Other</em> <em>installation</em>",
        "body": " profiler New Relic’s .<em>NET</em> <em>agent</em> relies on the Microsoft profiling API to report data from your .<em>NET</em> application. .<em>NET</em> monitoring solutions <em>other</em> than New Relic can use this profiling API. But only one service can use the profiler at a time. This means that if you have used a .<em>NET</em> monitoring service"
      },
      "id": "603eb8ba28ccbc3daceba773"
    }
  ],
  "/docs/agents/net-agent/install-guides/install-overview": [
    {
      "sections": [
        "PHP agent installation overview",
        "Tip",
        "PHP components",
        "Install the agent",
        "RedHat or CentOS",
        "Ubuntu or Debian",
        "Tar archive",
        "Install PHP with partnership accounts",
        "For more help"
      ],
      "title": "PHP agent installation overview",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "Installation"
      ],
      "external_id": "e2acdb74f9365baa40b0b07a0bb638d19dbe6f5c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/installation/php-agent-installation-overview/",
      "published_at": "2021-06-02T15:10:21Z",
      "updated_at": "2021-04-16T06:02:17Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our PHP agent auto-instruments your code so you can start monitoring applications. You can use our launcher, or follow the instructions in this document to complete a basic PHP agent installation. Tip To use PHP or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Add PHP data PHP components Our PHP agent consists of two basic components: A PHP extension, which collects data from your application A local proxy daemon, which transmits the data to New Relic Your system's configuration components, including the web server, operating system, system permissions, PHP installation itself, package manager, etc., are all important factors during installation and configuration, because the agent is a part of that. For more information about supported PHP releases, frameworks, and other system requirements, see PHP compatibility and requirements. Install the agent Follow this general process to install the agent on your system. The agent installation package or tar archive includes the interactive newrelic-install script, which automates some installation tasks. Tip If your application is frequently inactive, we recommend you generate some data by interacting with the application or site. This will help ensure the agent initially connects. Ensure your system meets the agent's requirements, including appropriate system permissions. If you do not already have a New Relic account, create one. From your Account settings, copy your license key information. Install the agent package or tar archive on your system. RedHat or CentOS The most common way to install the agent on RedHat or CentOS is with the installation package (.rpm) and the package manager. You can tell the package manager to get it from the New Relic repository, or you can download the .rpm file directly from the New Relic website. Install the package with your preferred package manager (yum or rpm) and then run the newrelic-install script. Ubuntu or Debian Install the package either with apt-get or with dpkg commands. Typically, running the newrelic-install script is not required. Tar archive The .tar archive method is the most generic method you can use on all supported operating systems. Download the compressed tar archive for your system if any of these situations apply to you: Your operating system is not listed here. You are not using a package manager. Other methods are unsuccessful. Install the tar archive of the agent on any supported platform. Change the default application name to a meaningful name. Optional: Change other agent configuration settings to further customize your installation. Restart your web server (Apache, Nginx, PHP-FPM, etc.). Recommendation: To help ensure the PHP agent is initiated, especially if your application has infrequent activity, generate some data by using the app for a few seconds. Wait a few minutes for your application to send data to New Relic. Then, check your app's performance in the New Relic UI. Install PHP with partnership accounts Installation procedures may be different for admins who install the PHP agent through a New Relic partnership. For more information, see: AWS Heroku Magento Shared hosting providers Other partnership installation procedures Not all partners support PHP agents. For more help If you need more help, check out these support and learning resources: Suggest a change and learn how to contribute to our PHP agent open source repository. Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 241.3005,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "PHP agent <em>installation</em> <em>overview</em>",
        "sections": "PHP agent <em>installation</em> <em>overview</em>",
        "tags": "<em>Installation</em>",
        "body": " information about supported PHP releases, frameworks, and other system requirements, see PHP compatibility and requirements. <em>Install</em> the agent Follow this general process to <em>install</em> the agent on your system. The agent installation package or tar archive includes the interactive newrelic-<em>install</em> script, which"
      },
      "id": "6043c95064441f9382378ebf"
    },
    {
      "sections": [
        "New Relic guided install overview",
        "Supported APM agents",
        "Why it matters",
        "Some technical detail",
        "Important",
        "On-host integration (OHI) recipes",
        "Troubleshoot common problems",
        "MySQL: Incorrect user permissions",
        "NGINX: No status URL"
      ],
      "title": "New Relic guided install overview",
      "type": "docs",
      "tags": [
        "Full-Stack Observability",
        "Observe everything",
        "Get started"
      ],
      "external_id": "2058522f6cb1e82dbbe111a176c22ec4aa515ae5",
      "image": "https://docs.newrelic.com/static/6bf45ccf002250f7ebaa69cbe3ff706c/c1b63/guided-install-cli.png",
      "url": "https://docs.newrelic.com/docs/full-stack-observability/observe-everything/get-started/new-relic-guided-install-overview/",
      "published_at": "2021-05-27T20:49:10Z",
      "updated_at": "2021-05-09T18:29:35Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Instrument your systems and send telemetry data to New Relic with guided install. Our guided install creates a customized CLI command for your environment that downloads and installs the New Relic CLI and the infrastructure agent. Ready to get started? Click the Guided install button. If your account reports data through our EU datacenter, click EU Guided install. Guided install EU Guided install Our infrastructure agent discovers the applications and infrastructure and log sources running in your environment, and recommends which ones should be instrumented. The install automates the configuration and deployment of each system you choose to instrument. Supported APM agents If you have a .NET Windows application on IIS, the guided install configures and enables an APM agent. Guided install for .NET EU Guided install for .NET Why it matters With our guided install, you can instrument your applications and infrastructure and start seeing your data in New Relic in minutes. The guided install uses our command line interface (CLI), the infrastructure agent for your host environment, and a library of installation recipes to instrument your applications and infrastructure for you. That means less toil for you. Because our instrumentation recipes are open source, you can modify existing recipes, or build new ones, to suit your needs. Some technical detail The New Relic guided install uses open source installation recipes to instrument on-host integrations. These recipes include installation and setup commands, information about logs, and metadata related to what’s being installed. They're collected in a YAML file for each type of system and have all of the installation details necessary to install the infrastructure agent for a specific integration. Important On Windows, our guided install only supports Microsoft SQL Server, logs, and the infrastructure agent. All other integrations are only supported on Linux. On-host integration (OHI) recipes The guided install automates the discovery, configuration, and installation of OHIs. However, there may be times when you want to instrument them one-by-one using the CLI install command. To install any individual on-host integration, run this command: curl -Ls https://raw.githubusercontent.com/newrelic/newrelic-cli/master/scripts/install.sh | bash && sudo NEW_RELIC_API_KEY=API_KEY NEW_RELIC_ACCOUNT_ID=ACCOUNT_ID /usr/local/bin/newrelic install -n INTEGRATION-FLAG Copy For example: curl -Ls https://raw.githubusercontent.com/newrelic/newrelic-cli/master/scripts/install.sh | bash && sudo NEW_RELIC_API_KEY=<API_KEY> NEW_RELIC_ACCOUNT_ID=<ACCOUNT_ID> /usr/local/bin/newrelic install -n apache-open-source-integration Copy The table lists the integrations supported by the guided install CLI command. The specific on-host integration commands are provided for your reference. Our open source integrations send performance metrics and inventory data from your servers and applications to the New Relic platform. You can view pre-built dashboards of your metric data, create alert policies, and create your own custom queries and charts. Integration Command Apache newrelic install -n apache-open-source-integration Cassandra newrelic install -n cassandra-open-source-integration Couchbase newrelic install -n couchbase-open-source-integration ElasticSearch newrelic install -n elasticsearch-open-source-integration HAProxy newrelic install -n haproxy-open-source-integration HashiCorp Consul newrelic install -n hashicorp-consul-open-source-integration JMX newrelic install -n jmx-open-source-integration Memcached newrelic install -n memcached-open-source-integration Microsoft SQL Server (Windows only) newrelic install -n mssql-server-integration-installer MongoDB newrelic install -n mongodb-open-source-integration MySQL newrelic install -n mysql-open-source-integration Nagios newrelic install -n nagios-open-source-integration Nginx newrelic install -n nginx-open-source-integration PostgreSQL newrelic install -n postgres-open-source-integration RabbitMQ newrelic install -n rabbitmq-open-source-integration Redis newrelic install -n redis-open-source-integration Varnish Cache newrelic install -n varnish-cache-open-source-integration Troubleshoot common problems As we identify areas where the guided install fails, we'll document them here and provide some troubleshooting guidance. MySQL: Incorrect user permissions To monitor MySQL health data, you need a valid username and password with specific permissions. These commands will create a user and grant the required permissions: Create a user newrelic@localhost with a specific password. sudo mysql -e \"CREATE USER 'newrelic'@'localhost' IDENTIFIED BY 'YOUR_SELECTED_PASSWORD';\" Copy Give replication privileges to newrelic@localhost with a maximum of 5 connections. sudo mysql -e \"GRANT REPLICATION CLIENT ON *.* TO 'newrelic'@'localhost' WITH MAX_USER_CONNECTIONS 5;\" Copy Give select privileges to newrelic@localhost with a maximum of 5 connections. sudo mysql -e \"GRANT SELECT ON *.* TO 'newrelic'@'localhost' WITH MAX_USER_CONNECTIONS 5;\" Copy Once done, your next guided install attempt should work. NGINX: No status URL To monitor your NGINX server, you'll need to configure a valid status URL. status_url: The URL set up to provide the metrics using the status module. If the default value of 127.0.0.1 is incorrect, substitute the address/FQDN/URL for your system. Example: status_url: http://127.0.0.1/status You can read more about the status_url in these NGINX docs: For NGINX Open Source: HTTP stub status module For NGINX Plus: HTTP status module and HTTP API module There are different ways to set status_url, depending on how NGINX was installed: If enabled via Kubernetes: See Monitor services running on Kubernetes. If enabled via Amazon ECS: See Monitor services running on ECS. If installed on-host: Edit the config in the integration's YAML config file, nginx-config.yml.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 239.81161,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic guided <em>install</em> <em>overview</em>",
        "sections": "New Relic guided <em>install</em> <em>overview</em>",
        "body": "Instrument your systems and send telemetry data to New Relic with guided <em>install</em>. Our guided <em>install</em> creates a customized CLI command for your environment that downloads and installs the New Relic CLI and the infrastructure agent. Ready to get started? Click the Guided <em>install</em> button. If your"
      },
      "id": "604130a7e7b9d299cb2a07c0"
    },
    {
      "sections": [
        "Requirements for the infrastructure agent",
        "Processor architectures",
        "Operating systems",
        "Important",
        "Tip",
        "Unique hostname",
        "Permissions",
        "Libraries",
        "Network access",
        "Container software",
        "CPU, memory, and disk usage",
        "Configuration management tools"
      ],
      "title": "Requirements for the infrastructure agent",
      "type": "docs",
      "tags": [
        "Infrastructure",
        "Install the infrastructure agent",
        "Get started"
      ],
      "external_id": "517b5d94efa0139aa3ef5238569d5b04d28fb932",
      "image": "https://docs.newrelic.com/static/8de19e871ebba1c3d12258efc569dc6f/103b3/amazon-linux.png",
      "url": "https://docs.newrelic.com/docs/infrastructure/install-infrastructure-agent/get-started/requirements-infrastructure-agent/",
      "published_at": "2021-06-02T22:28:05Z",
      "updated_at": "2021-06-02T22:28:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Before installing our infrastructure agent, make sure your system and any on-host integrations you configure meet the requirements. Processor architectures The infrastructure agent supports only x86 processor architectures: Linux: 64-bit architecture (also requires 64-bit package manager and dependencies) Windows: both 32 and 64-bit architectures ARM: arm64 architecture including AWS Graviton 2 processor is supported on compatible linux operating sytems. Built-in log forwarding and on-host integrations are not yet available. Operating systems The infrastructure agent supports these operating systems: Operating system Supported by the infrastructure agent Amazon Linux All versions CentOS Version 7 or higher Debian Version 8 (\"Jessie\") or higher Docker Docker 1.12 Kubernetes Tested with versions 1.10 to 1.16 Red Hat Enterprise Linux (RHEL) Version 6 or higher SUSE Linux Enterprise Server (SLES) Versions 11.4, 12.1, 12.2, 12.3, and 12.4 Ubuntu LTS versions 16.04.x, 18.04.x, 20.04.x Windows Windows Server 2012, 2016, and 2019, and their service packs. Windows 10 (only the infrastructure agent is supported). Important Operating systems are not supported beyond manufacturer end-of-life. Tip You can monitor Amazon BottleRocket workloads: When running EC2 instances, use the containerized agent. On EKS, install the Kubernetes integration. For ECS clusters, deploy the ECS integration. Unique hostname The infrastructure agent uses the hostname to uniquely identify each server. To avoid inaccurate metrics from combining multiple servers under a single hostname, make sure that each monitored server has a unique hostname. You can use the optional display_name setting to override the default hostname. Important Servers named localhost are not reported: it's a default name and inherently non-unique. Permissions The infrastructure agent requires these permissions: Linux: By default, the agent runs and installs as root. You can also select privileged or unprivileged run modes. Windows: The agent must be installed from an Administrator account and requires Administrator privileges to run. Libraries For agent versions 1.1.19 or higher, you need the libcap library in order to install Infrastructure. It's available in the official repositories of your distribution. Network access In order to report data to New Relic, our infrastructure agent must have outbound access to certain domains and ports. If your system needs a proxy to connect to these domains, use the proxy setting. Container software The infrastructure agent instruments Docker containers when installed on the host server. We support Docker versions 1.12 or higher. CPU, memory, and disk usage The infrastructure agent is fairly lightweight. For typical CPU, memory, and disk usage, see our page on agent performance overhead. For more information on supported file systems, see Storage sample attributes. Configuration management tools The infrastructure agent can be deployed programmatically using several config management and deploy tools: Ansible Chef Elastic Beanstalk Puppet",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 218.93094,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Install</em> the infrastructure agent",
        "body": ". Tip You can monitor Amazon BottleRocket workloads: When running EC2 instances, use the containerized agent. On EKS, <em>install</em> the Kubernetes integration. For ECS clusters, deploy the ECS integration. Unique hostname The infrastructure agent uses the hostname to uniquely identify each server. To avoid"
      },
      "id": "60440aca28ccbc8ce02c60cf"
    }
  ],
  "/docs/agents/net-agent/installation/install-net-agent-linux": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.55151,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the Ruby <em>agent</em> <em>installation</em> doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "New Relic for .NET status monitor",
        "Important",
        "View the status of monitored apps",
        "Repair installations"
      ],
      "title": "New Relic for .NET status monitor",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "5827145411de961dea183ff1bfd20492413a448d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/new-relic-net-status-monitor/",
      "published_at": "2021-06-02T16:50:18Z",
      "updated_at": "2021-03-11T02:33:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of .NET agent release 6.20, New Relic's.NET status monitor is no longer available. For .NET agent versions 6.20 or higher, use New Relic Diagnostics. The status monitor is a deprecated diagnostic and status tool for New Relic's .NET agent. It is designed to: Give you visibility into the current status of the .NET agent running on your server. Help you fix common installation issues. Provide a quick link to each of your instrumented applications in newrelic.com. Provide quick access to the New Relic log file for each instrumented application. For additional help, view the New Relic .NET agent's troubleshooting documentation. View the status of monitored apps Important As of .NET agent release 6.20, New Relic's.NET status monitor is no longer available. For .NET agent versions 6.20 or higher, use New Relic Diagnostics. The status monitor provides visibility into which applications are currently being instrumented by the .NET agent and the status of each application. You will not see any data on an application unless there has been traffic on it recently. In order to conserve your system resources, the status monitor does not automatically refresh. To launch the status monitor: From your Windows Start menu or Start screen, search for Status monitor. OR Right-click the New Relic icon in the Windows task bar status area (system tray), then select Monitored applications. To view whether an application is being instrumented, make sure all of its checkboxes are green. After you select a specific application, select any of the available options to view the app in New Relic, view log files, repair the installation if errors are found, or refresh and then view the latest status for your monitored processes and applications. Repair installations New Relic's .NET agent installation is robust and simple to use. However, there are certain scenarios when previous installations may conflict with the latest version. To fix common problems, repair your installation: From the status monitor's list of apps, select an app, then select Repair installation. OR From the Windows system tray, select the New Relic icon, then select Tools > Repair installation. After the installation repair is finished: From the command line, perform an IISRESET.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 87.29141,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic for .<em>NET</em> status monitor",
        "sections": "Repair <em>installations</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " into the current status of the .<em>NET</em> <em>agent</em> running on your server. Help you fix common <em>installation</em> issues. Provide a quick link to each of your instrumented applications in newrelic.com. Provide quick access to the New Relic log file for each instrumented application. For additional help, view the New"
      },
      "id": "6043f88c28ccbc95632c6062"
    },
    {
      "sections": [
        "Introduction to .NET agent install",
        "Tip",
        "Compatibility and requirements",
        "Install the .NET agent"
      ],
      "title": "Introduction to .NET agent install",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Installation"
      ],
      "external_id": "541834d75a01dc99a4fdd2d3cfa64cae418429ee",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/installation/introduction-net-agent-install/",
      "published_at": "2021-06-02T15:31:28Z",
      "updated_at": "2021-04-12T12:40:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our .NET agent auto-instruments your code so you can start monitoring applications. You can use our launcher, or follow the instructions in this document to complete a basic .NET agent installation. To learn more about what APM for .NET does, see Introduction to New Relic for .NET. Tip To use .NET or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Add .NET data Compatibility and requirements Compatibility and requirements: .NET Framework .NET Core Install the .NET agent See the appropriate install instructions for your operating system and find the download link: Windows For Windows .NET applications on IIS, use our guided install to get started with APM. If you're on an EU server, use this link instead. Linux Tip Find all binaries and packages for the .NET Agent in our latest releases. Historical releases can be found in our previous releases.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 87.01554,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to .<em>NET</em> <em>agent</em> <em>install</em>",
        "sections": "Introduction to .<em>NET</em> <em>agent</em> <em>install</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Our .<em>NET</em> <em>agent</em> auto-instruments your code so you can start monitoring applications. You can use our launcher, or follow the instructions in this document to complete a basic .<em>NET</em> <em>agent</em> <em>installation</em>. To learn more about what APM for .<em>NET</em> does, see Introduction to New Relic for .<em>NET</em>. Tip To use .<em>NET</em>"
      },
      "id": "604411b6e7b9d2cf7c5799f8"
    }
  ],
  "/docs/agents/net-agent/installation/install-net-agent-windows": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.55144,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the Ruby <em>agent</em> <em>installation</em> doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "New Relic for .NET status monitor",
        "Important",
        "View the status of monitored apps",
        "Repair installations"
      ],
      "title": "New Relic for .NET status monitor",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "5827145411de961dea183ff1bfd20492413a448d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/new-relic-net-status-monitor/",
      "published_at": "2021-06-02T16:50:18Z",
      "updated_at": "2021-03-11T02:33:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of .NET agent release 6.20, New Relic's.NET status monitor is no longer available. For .NET agent versions 6.20 or higher, use New Relic Diagnostics. The status monitor is a deprecated diagnostic and status tool for New Relic's .NET agent. It is designed to: Give you visibility into the current status of the .NET agent running on your server. Help you fix common installation issues. Provide a quick link to each of your instrumented applications in newrelic.com. Provide quick access to the New Relic log file for each instrumented application. For additional help, view the New Relic .NET agent's troubleshooting documentation. View the status of monitored apps Important As of .NET agent release 6.20, New Relic's.NET status monitor is no longer available. For .NET agent versions 6.20 or higher, use New Relic Diagnostics. The status monitor provides visibility into which applications are currently being instrumented by the .NET agent and the status of each application. You will not see any data on an application unless there has been traffic on it recently. In order to conserve your system resources, the status monitor does not automatically refresh. To launch the status monitor: From your Windows Start menu or Start screen, search for Status monitor. OR Right-click the New Relic icon in the Windows task bar status area (system tray), then select Monitored applications. To view whether an application is being instrumented, make sure all of its checkboxes are green. After you select a specific application, select any of the available options to view the app in New Relic, view log files, repair the installation if errors are found, or refresh and then view the latest status for your monitored processes and applications. Repair installations New Relic's .NET agent installation is robust and simple to use. However, there are certain scenarios when previous installations may conflict with the latest version. To fix common problems, repair your installation: From the status monitor's list of apps, select an app, then select Repair installation. OR From the Windows system tray, select the New Relic icon, then select Tools > Repair installation. After the installation repair is finished: From the command line, perform an IISRESET.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 87.29141,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic for .<em>NET</em> status monitor",
        "sections": "Repair <em>installations</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " into the current status of the .<em>NET</em> <em>agent</em> running on your server. Help you fix common <em>installation</em> issues. Provide a quick link to each of your instrumented applications in newrelic.com. Provide quick access to the New Relic log file for each instrumented application. For additional help, view the New"
      },
      "id": "6043f88c28ccbc95632c6062"
    },
    {
      "sections": [
        "Introduction to .NET agent install",
        "Tip",
        "Compatibility and requirements",
        "Install the .NET agent"
      ],
      "title": "Introduction to .NET agent install",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Installation"
      ],
      "external_id": "541834d75a01dc99a4fdd2d3cfa64cae418429ee",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/installation/introduction-net-agent-install/",
      "published_at": "2021-06-02T15:31:28Z",
      "updated_at": "2021-04-12T12:40:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our .NET agent auto-instruments your code so you can start monitoring applications. You can use our launcher, or follow the instructions in this document to complete a basic .NET agent installation. To learn more about what APM for .NET does, see Introduction to New Relic for .NET. Tip To use .NET or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Add .NET data Compatibility and requirements Compatibility and requirements: .NET Framework .NET Core Install the .NET agent See the appropriate install instructions for your operating system and find the download link: Windows For Windows .NET applications on IIS, use our guided install to get started with APM. If you're on an EU server, use this link instead. Linux Tip Find all binaries and packages for the .NET Agent in our latest releases. Historical releases can be found in our previous releases.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 87.01554,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to .<em>NET</em> <em>agent</em> <em>install</em>",
        "sections": "Introduction to .<em>NET</em> <em>agent</em> <em>install</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Our .<em>NET</em> <em>agent</em> auto-instruments your code so you can start monitoring applications. You can use our launcher, or follow the instructions in this document to complete a basic .<em>NET</em> <em>agent</em> <em>installation</em>. To learn more about what APM for .<em>NET</em> does, see Introduction to New Relic for .<em>NET</em>. Tip To use .<em>NET</em>"
      },
      "id": "604411b6e7b9d2cf7c5799f8"
    }
  ],
  "/docs/agents/net-agent/installation/introduction-net-agent-install": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.55144,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the Ruby <em>agent</em> <em>installation</em> doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "New Relic for .NET status monitor",
        "Important",
        "View the status of monitored apps",
        "Repair installations"
      ],
      "title": "New Relic for .NET status monitor",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "5827145411de961dea183ff1bfd20492413a448d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/new-relic-net-status-monitor/",
      "published_at": "2021-06-02T16:50:18Z",
      "updated_at": "2021-03-11T02:33:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of .NET agent release 6.20, New Relic's.NET status monitor is no longer available. For .NET agent versions 6.20 or higher, use New Relic Diagnostics. The status monitor is a deprecated diagnostic and status tool for New Relic's .NET agent. It is designed to: Give you visibility into the current status of the .NET agent running on your server. Help you fix common installation issues. Provide a quick link to each of your instrumented applications in newrelic.com. Provide quick access to the New Relic log file for each instrumented application. For additional help, view the New Relic .NET agent's troubleshooting documentation. View the status of monitored apps Important As of .NET agent release 6.20, New Relic's.NET status monitor is no longer available. For .NET agent versions 6.20 or higher, use New Relic Diagnostics. The status monitor provides visibility into which applications are currently being instrumented by the .NET agent and the status of each application. You will not see any data on an application unless there has been traffic on it recently. In order to conserve your system resources, the status monitor does not automatically refresh. To launch the status monitor: From your Windows Start menu or Start screen, search for Status monitor. OR Right-click the New Relic icon in the Windows task bar status area (system tray), then select Monitored applications. To view whether an application is being instrumented, make sure all of its checkboxes are green. After you select a specific application, select any of the available options to view the app in New Relic, view log files, repair the installation if errors are found, or refresh and then view the latest status for your monitored processes and applications. Repair installations New Relic's .NET agent installation is robust and simple to use. However, there are certain scenarios when previous installations may conflict with the latest version. To fix common problems, repair your installation: From the status monitor's list of apps, select an app, then select Repair installation. OR From the Windows system tray, select the New Relic icon, then select Tools > Repair installation. After the installation repair is finished: From the command line, perform an IISRESET.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 87.29141,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic for .<em>NET</em> status monitor",
        "sections": "Repair <em>installations</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " into the current status of the .<em>NET</em> <em>agent</em> running on your server. Help you fix common <em>installation</em> issues. Provide a quick link to each of your instrumented applications in newrelic.com. Provide quick access to the New Relic log file for each instrumented application. For additional help, view the New"
      },
      "id": "6043f88c28ccbc95632c6062"
    },
    {
      "sections": [
        "Uninstall the .NET agent",
        "Uninstall the .NET agent (Windows)",
        "Tip",
        "Uninstall the .NET agent (Linux)",
        "Important",
        "Uninstall with apt (Debian, Ubuntu, and Linux Mint)",
        "Uninstall with dpkg (Debian, Ubuntu, and Linux Mint)",
        "Uninstall with yum (CentOS, Red Hat Enterprise Linux, Oracle Linux)",
        "Uninstall with rpm (CentOS, Red Hat Enterprise Linux, Oracle Linux)",
        "Uninstall tarball"
      ],
      "title": "Uninstall the .NET agent",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Installation"
      ],
      "external_id": "842dc67f8324154906178a9c56e50c9a7fcdeb64",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/installation/uninstall-net-agent/",
      "published_at": "2021-06-02T15:27:26Z",
      "updated_at": "2021-03-11T03:42:16Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to uninstall the New Relic .NET agent. For instructions on how to temporarily disable the agent, see Disable the agent. To uninstall the .NET agent, follow the procedure that corresponds to your operating system: Windows Linux Uninstall the .NET agent (Windows) Tip Requires Administrator rights in your Windows admin group. This procedure assumes you installed the .NET agent with the MSI installer: To shut down any running agents, stop IIS. If you don't stop IIS, you may need to reboot after uninstalling the agent. Select Start > All Programs > New Relic .NET Agent > Uninstall the .NET agent. Follow the prompts to complete uninstallation. Restart IIS. After uninstalling the agent, you may want to remove all agent-related files. Be sure to check other paths to remove any other New Relic files. For example, uninstalling the .NET agent does not delete your newrelic.config file. From Control Panel > Programs > Programs and Features, right-click and delete any files named New Relic .NET Agent. Delete the entire folder at C:\\ProgramData\\New Relic\\.NET Agent. Delete the entire folder at C:\\Program Files\\New Relic\\.NET Agent. Delete the entire folder at C:\\Program Files (x86)\\New Relic\\.NET Agent. Remove your app from the APM UI. Uninstall the .NET agent (Linux) To uninstall the .NET agent on Linux, use your package management tool. Important You must restart your application once the uninstall is finished. Uninstall with apt (Debian, Ubuntu, and Linux Mint) Execute the following command as root: sudo apt-get remove newrelic-netcore20-agent Copy Uninstall with dpkg (Debian, Ubuntu, and Linux Mint) Execute the following command as root: sudo dpkg --remove newrelic-netcore20-agent Copy Uninstall with yum (CentOS, Red Hat Enterprise Linux, Oracle Linux) Execute the following command as root: sudo yum remove newrelic-netcore20-agent Copy Uninstall with rpm (CentOS, Red Hat Enterprise Linux, Oracle Linux) Execute the following command as root: sudo rpm -e newrelic-netcore20-agent Copy Uninstall tarball Delete all New Relic files from your app folder. Unset New Relic environment variables: CORECLR_ENABLE_PROFILING=1 CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_NEWRELIC_HOME=PATH_TO_INSTALL CORECLR_PROFILER_PATH=%CORECLR_NEWRELIC_HOME%\\NewRelic.Profiler.dll Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 85.16284,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Uninstall the .<em>NET</em> <em>agent</em>",
        "sections": "Uninstall the .<em>NET</em> <em>agent</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " Requires Administrator rights in your Windows admin group. This procedure assumes you installed the .<em>NET</em> <em>agent</em> with the MSI installer: To shut down any running <em>agents</em>, stop IIS. If you don&#x27;t stop IIS, you may need to reboot after uninstalling the <em>agent</em>. Select Start &gt; All Programs &gt; New Relic .<em>NET</em> <em>Agent</em>"
      },
      "id": "604411b564441f868f378f04"
    }
  ],
  "/docs/agents/net-agent/installation/uninstall-net-agent": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.551346,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the Ruby <em>agent</em> <em>installation</em> doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "New Relic for .NET status monitor",
        "Important",
        "View the status of monitored apps",
        "Repair installations"
      ],
      "title": "New Relic for .NET status monitor",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "5827145411de961dea183ff1bfd20492413a448d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/new-relic-net-status-monitor/",
      "published_at": "2021-06-02T16:50:18Z",
      "updated_at": "2021-03-11T02:33:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of .NET agent release 6.20, New Relic's.NET status monitor is no longer available. For .NET agent versions 6.20 or higher, use New Relic Diagnostics. The status monitor is a deprecated diagnostic and status tool for New Relic's .NET agent. It is designed to: Give you visibility into the current status of the .NET agent running on your server. Help you fix common installation issues. Provide a quick link to each of your instrumented applications in newrelic.com. Provide quick access to the New Relic log file for each instrumented application. For additional help, view the New Relic .NET agent's troubleshooting documentation. View the status of monitored apps Important As of .NET agent release 6.20, New Relic's.NET status monitor is no longer available. For .NET agent versions 6.20 or higher, use New Relic Diagnostics. The status monitor provides visibility into which applications are currently being instrumented by the .NET agent and the status of each application. You will not see any data on an application unless there has been traffic on it recently. In order to conserve your system resources, the status monitor does not automatically refresh. To launch the status monitor: From your Windows Start menu or Start screen, search for Status monitor. OR Right-click the New Relic icon in the Windows task bar status area (system tray), then select Monitored applications. To view whether an application is being instrumented, make sure all of its checkboxes are green. After you select a specific application, select any of the available options to view the app in New Relic, view log files, repair the installation if errors are found, or refresh and then view the latest status for your monitored processes and applications. Repair installations New Relic's .NET agent installation is robust and simple to use. However, there are certain scenarios when previous installations may conflict with the latest version. To fix common problems, repair your installation: From the status monitor's list of apps, select an app, then select Repair installation. OR From the Windows system tray, select the New Relic icon, then select Tools > Repair installation. After the installation repair is finished: From the command line, perform an IISRESET.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 87.29141,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic for .<em>NET</em> status monitor",
        "sections": "Repair <em>installations</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " into the current status of the .<em>NET</em> <em>agent</em> running on your server. Help you fix common <em>installation</em> issues. Provide a quick link to each of your instrumented applications in newrelic.com. Provide quick access to the New Relic log file for each instrumented application. For additional help, view the New"
      },
      "id": "6043f88c28ccbc95632c6062"
    },
    {
      "sections": [
        "Introduction to .NET agent install",
        "Tip",
        "Compatibility and requirements",
        "Install the .NET agent"
      ],
      "title": "Introduction to .NET agent install",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Installation"
      ],
      "external_id": "541834d75a01dc99a4fdd2d3cfa64cae418429ee",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/installation/introduction-net-agent-install/",
      "published_at": "2021-06-02T15:31:28Z",
      "updated_at": "2021-04-12T12:40:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our .NET agent auto-instruments your code so you can start monitoring applications. You can use our launcher, or follow the instructions in this document to complete a basic .NET agent installation. To learn more about what APM for .NET does, see Introduction to New Relic for .NET. Tip To use .NET or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Add .NET data Compatibility and requirements Compatibility and requirements: .NET Framework .NET Core Install the .NET agent See the appropriate install instructions for your operating system and find the download link: Windows For Windows .NET applications on IIS, use our guided install to get started with APM. If you're on an EU server, use this link instead. Linux Tip Find all binaries and packages for the .NET Agent in our latest releases. Historical releases can be found in our previous releases.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 87.01553,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to .<em>NET</em> <em>agent</em> <em>install</em>",
        "sections": "Introduction to .<em>NET</em> <em>agent</em> <em>install</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Our .<em>NET</em> <em>agent</em> auto-instruments your code so you can start monitoring applications. You can use our launcher, or follow the instructions in this document to complete a basic .<em>NET</em> <em>agent</em> <em>installation</em>. To learn more about what APM for .<em>NET</em> does, see Introduction to New Relic for .<em>NET</em>. Tip To use .<em>NET</em>"
      },
      "id": "604411b6e7b9d2cf7c5799f8"
    }
  ],
  "/docs/agents/net-agent/installation/update-net-agent": [
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/style-guide/processes-procedures/include-a-doc-in-multiple-menus/",
      "sections": [
        "Include a doc in multiple menus"
      ],
      "published_at": "2021-06-02T17:05:52Z",
      "title": "Include a doc in multiple menus",
      "updated_at": "2021-06-02T17:05:51Z",
      "type": "docs",
      "external_id": "281e8e849c2b4fdd56046513c8ae2eecf24392f7",
      "document_type": "page",
      "popularity": 1,
      "body": "If you have a document that should appear in multiple menus, you can include the same path in multiple taxonomy locations. For example, if you wanted to link to the APM landing page from another location of taxonomy (such as a differnt taxonomy level, a different category, etc.), you’d add a new entry in the navigation YAML file (for example, /src/nav/agents.yml). In this example, we add a link to the Ruby agent installation doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby agent category. - title: Distributed tracing path: /docs/distributed-tracing pages: - title: Concepts path: /docs/distributed-tracing/concepts pages: - title: Intro to distributed tracing path: /docs/distributed-tracing/concepts/introduction-distributed-tracing - title: Planning guide path: /docs/distributed-tracing/concepts/distributed-tracing-planning-guide - title: How distributed tracing works path: /docs/distributed-tracing/concepts/how-new-relic-distributed-tracing-works - title: This is a dummy doc path: /docs/agents/ruby-agent/installation/install-new-relic-ruby-agent Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 94.551346,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "body": " entry in the navigation YAML file (for example, &#x2F;src&#x2F;nav&#x2F;<em>agents</em>.yml). In this example, we add a link to the Ruby <em>agent</em> <em>installation</em> doc from the Distributed tracing category. You can now access this doc from either the Distributed tracing category or the Ruby <em>agent</em> category. - title: Distributed"
      },
      "id": "604220ec196a67358ea83da5"
    },
    {
      "sections": [
        "New Relic for .NET status monitor",
        "Important",
        "View the status of monitored apps",
        "Repair installations"
      ],
      "title": "New Relic for .NET status monitor",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "5827145411de961dea183ff1bfd20492413a448d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/new-relic-net-status-monitor/",
      "published_at": "2021-06-02T16:50:18Z",
      "updated_at": "2021-03-11T02:33:49Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Important As of .NET agent release 6.20, New Relic's.NET status monitor is no longer available. For .NET agent versions 6.20 or higher, use New Relic Diagnostics. The status monitor is a deprecated diagnostic and status tool for New Relic's .NET agent. It is designed to: Give you visibility into the current status of the .NET agent running on your server. Help you fix common installation issues. Provide a quick link to each of your instrumented applications in newrelic.com. Provide quick access to the New Relic log file for each instrumented application. For additional help, view the New Relic .NET agent's troubleshooting documentation. View the status of monitored apps Important As of .NET agent release 6.20, New Relic's.NET status monitor is no longer available. For .NET agent versions 6.20 or higher, use New Relic Diagnostics. The status monitor provides visibility into which applications are currently being instrumented by the .NET agent and the status of each application. You will not see any data on an application unless there has been traffic on it recently. In order to conserve your system resources, the status monitor does not automatically refresh. To launch the status monitor: From your Windows Start menu or Start screen, search for Status monitor. OR Right-click the New Relic icon in the Windows task bar status area (system tray), then select Monitored applications. To view whether an application is being instrumented, make sure all of its checkboxes are green. After you select a specific application, select any of the available options to view the app in New Relic, view log files, repair the installation if errors are found, or refresh and then view the latest status for your monitored processes and applications. Repair installations New Relic's .NET agent installation is robust and simple to use. However, there are certain scenarios when previous installations may conflict with the latest version. To fix common problems, repair your installation: From the status monitor's list of apps, select an app, then select Repair installation. OR From the Windows system tray, select the New Relic icon, then select Tools > Repair installation. After the installation repair is finished: From the command line, perform an IISRESET.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 87.29141,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "New Relic for .<em>NET</em> status monitor",
        "sections": "Repair <em>installations</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " into the current status of the .<em>NET</em> <em>agent</em> running on your server. Help you fix common <em>installation</em> issues. Provide a quick link to each of your instrumented applications in newrelic.com. Provide quick access to the New Relic log file for each instrumented application. For additional help, view the New"
      },
      "id": "6043f88c28ccbc95632c6062"
    },
    {
      "sections": [
        "Introduction to .NET agent install",
        "Tip",
        "Compatibility and requirements",
        "Install the .NET agent"
      ],
      "title": "Introduction to .NET agent install",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Installation"
      ],
      "external_id": "541834d75a01dc99a4fdd2d3cfa64cae418429ee",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/installation/introduction-net-agent-install/",
      "published_at": "2021-06-02T15:31:28Z",
      "updated_at": "2021-04-12T12:40:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our .NET agent auto-instruments your code so you can start monitoring applications. You can use our launcher, or follow the instructions in this document to complete a basic .NET agent installation. To learn more about what APM for .NET does, see Introduction to New Relic for .NET. Tip To use .NET or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Add .NET data Compatibility and requirements Compatibility and requirements: .NET Framework .NET Core Install the .NET agent See the appropriate install instructions for your operating system and find the download link: Windows For Windows .NET applications on IIS, use our guided install to get started with APM. If you're on an EU server, use this link instead. Linux Tip Find all binaries and packages for the .NET Agent in our latest releases. Historical releases can be found in our previous releases.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 87.01553,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to .<em>NET</em> <em>agent</em> <em>install</em>",
        "sections": "Introduction to .<em>NET</em> <em>agent</em> <em>install</em>",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Our .<em>NET</em> <em>agent</em> auto-instruments your code so you can start monitoring applications. You can use our launcher, or follow the instructions in this document to complete a basic .<em>NET</em> <em>agent</em> <em>installation</em>. To learn more about what APM for .<em>NET</em> does, see Introduction to New Relic for .<em>NET</em>. Tip To use .<em>NET</em>"
      },
      "id": "604411b6e7b9d2cf7c5799f8"
    }
  ],
  "/docs/agents/net-agent/net-agent-api/addcustomparameter-net-agent-api": [
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "68ae52e48b04bfe2279bcd038778cc5eebf53d1d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-06-02T17:53:04Z",
      "updated_at": "2021-05-15T18:25:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.94934,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "6043cd9528ccbcfe1e2c60aa"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8252140/",
      "sections": [
        ".NET agent v8.25.214.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.25.214.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "8d905601b21cbe7e6884c5f649ea9ecfb1e35737",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Thread profiling support for Linux Thread profiling on Linux will be supported on .NET Core 3.0 or later applications when running .NET agent version 8.23 or later. Triggering a thread profile is done from the Thread profiler page in APM. Accessing Span-Specific information using the .NET Agent API New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the API. Adding Custom Span Attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ISpan. This new method accepts and supports all data-types. Further information may be found within .NET Agent API documentation. Adding custom attributes to spans requires distributed tracing and span events to be enabled. See .NET agent configuration Fixes Fixes issue where adding multiple custom attributes on a Transaction using ITransaction.AddCustomAttribute causes the agent to ignore additional attempts to add custom attributes to any transaction. Fixes issue that prevented Custom Events from being sent to New Relic until the agent shuts down. Fixes issue that can cause asynchronous Redis calls in an ASP.NET MVC application to report an inflated duration. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.91678,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "body": " the .<em>NET</em> <em>Agent</em> <em>API</em> New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the <em>API</em>. Adding Custom Span Attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been"
      },
      "id": "60445f8a196a673516960f8e"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8242440/",
      "sections": [
        ".NET agent v8.24.244.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.24.244.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "0df5ec86ce9abcad1d49457c32b2dec3873354b8",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Adding custom transaction attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type support; however, this method should be considered obsolete and will be removed in a future release of the agent API. Further information may be found within .NET Agent API documentation. Enhanced type support for RecordCustomEvent and NoticeError API methods. APIs for recording exceptions and custom events now support values of all types. The NoticeError API method has new overloads that accept an IDictionary<string, object>. The RecordCustomEvent methods have been modified to handle all types of data. In that past, they only handled string and float types. Further information may be found within .NET agent API documentation. New attributes on span events Spans created for external HTTP calls now include the http.statusCode attribute representing the status code of the call. Spans created for calls to a datastore now include the db.collection attribute. For instance, this will be the table name for a call to MS SQL Server. Ability to exclude attributes from span events Attributes on span events (e.g., http.url) can now be excluded via configuration. See .NET agent configuration for further information. Fixes New Relic distributed tracing relies on propagating trace and span identifiers in the headers of external calls (e.g., an HTTP call). These identifiers now only contain lowercase alphanumeric characters. Previous versions of the .NET agent used uppercase alphanumeric characters. The usage of uppercase alphanumeric characters can break traces when calling downstream services also monitored by a New Relic agent that supports W3C trace context (New Relic's .NET agent does not currently support W3C trace context. Support for W3C trace context for .NET will be in an upcoming release). This is only a problem if a .NET application is the originator of the trace. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.0688,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "body": "New Features Adding custom transaction attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type"
      },
      "id": "60445fcc28ccbc43b42c60c5"
    }
  ],
  "/docs/agents/net-agent/net-agent-api/disablebrowsermonitoring-net-agent-api": [
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "68ae52e48b04bfe2279bcd038778cc5eebf53d1d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-06-02T17:53:04Z",
      "updated_at": "2021-05-15T18:25:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.94934,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "6043cd9528ccbcfe1e2c60aa"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8252140/",
      "sections": [
        ".NET agent v8.25.214.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.25.214.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "8d905601b21cbe7e6884c5f649ea9ecfb1e35737",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Thread profiling support for Linux Thread profiling on Linux will be supported on .NET Core 3.0 or later applications when running .NET agent version 8.23 or later. Triggering a thread profile is done from the Thread profiler page in APM. Accessing Span-Specific information using the .NET Agent API New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the API. Adding Custom Span Attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ISpan. This new method accepts and supports all data-types. Further information may be found within .NET Agent API documentation. Adding custom attributes to spans requires distributed tracing and span events to be enabled. See .NET agent configuration Fixes Fixes issue where adding multiple custom attributes on a Transaction using ITransaction.AddCustomAttribute causes the agent to ignore additional attempts to add custom attributes to any transaction. Fixes issue that prevented Custom Events from being sent to New Relic until the agent shuts down. Fixes issue that can cause asynchronous Redis calls in an ASP.NET MVC application to report an inflated duration. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.91678,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "body": " the .<em>NET</em> <em>Agent</em> <em>API</em> New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the <em>API</em>. Adding Custom Span Attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been"
      },
      "id": "60445f8a196a673516960f8e"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8242440/",
      "sections": [
        ".NET agent v8.24.244.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.24.244.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "0df5ec86ce9abcad1d49457c32b2dec3873354b8",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Adding custom transaction attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type support; however, this method should be considered obsolete and will be removed in a future release of the agent API. Further information may be found within .NET Agent API documentation. Enhanced type support for RecordCustomEvent and NoticeError API methods. APIs for recording exceptions and custom events now support values of all types. The NoticeError API method has new overloads that accept an IDictionary<string, object>. The RecordCustomEvent methods have been modified to handle all types of data. In that past, they only handled string and float types. Further information may be found within .NET agent API documentation. New attributes on span events Spans created for external HTTP calls now include the http.statusCode attribute representing the status code of the call. Spans created for calls to a datastore now include the db.collection attribute. For instance, this will be the table name for a call to MS SQL Server. Ability to exclude attributes from span events Attributes on span events (e.g., http.url) can now be excluded via configuration. See .NET agent configuration for further information. Fixes New Relic distributed tracing relies on propagating trace and span identifiers in the headers of external calls (e.g., an HTTP call). These identifiers now only contain lowercase alphanumeric characters. Previous versions of the .NET agent used uppercase alphanumeric characters. The usage of uppercase alphanumeric characters can break traces when calling downstream services also monitored by a New Relic agent that supports W3C trace context (New Relic's .NET agent does not currently support W3C trace context. Support for W3C trace context for .NET will be in an upcoming release). This is only a problem if a .NET application is the originator of the trace. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.0688,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "body": "New Features Adding custom transaction attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type"
      },
      "id": "60445fcc28ccbc43b42c60c5"
    }
  ],
  "/docs/agents/net-agent/net-agent-api/getagent": [
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "68ae52e48b04bfe2279bcd038778cc5eebf53d1d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-06-02T17:53:04Z",
      "updated_at": "2021-05-15T18:25:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.949326,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "6043cd9528ccbcfe1e2c60aa"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8252140/",
      "sections": [
        ".NET agent v8.25.214.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.25.214.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "8d905601b21cbe7e6884c5f649ea9ecfb1e35737",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Thread profiling support for Linux Thread profiling on Linux will be supported on .NET Core 3.0 or later applications when running .NET agent version 8.23 or later. Triggering a thread profile is done from the Thread profiler page in APM. Accessing Span-Specific information using the .NET Agent API New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the API. Adding Custom Span Attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ISpan. This new method accepts and supports all data-types. Further information may be found within .NET Agent API documentation. Adding custom attributes to spans requires distributed tracing and span events to be enabled. See .NET agent configuration Fixes Fixes issue where adding multiple custom attributes on a Transaction using ITransaction.AddCustomAttribute causes the agent to ignore additional attempts to add custom attributes to any transaction. Fixes issue that prevented Custom Events from being sent to New Relic until the agent shuts down. Fixes issue that can cause asynchronous Redis calls in an ASP.NET MVC application to report an inflated duration. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.91678,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "body": " the .<em>NET</em> <em>Agent</em> <em>API</em> New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the <em>API</em>. Adding Custom Span Attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been"
      },
      "id": "60445f8a196a673516960f8e"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8242440/",
      "sections": [
        ".NET agent v8.24.244.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.24.244.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "0df5ec86ce9abcad1d49457c32b2dec3873354b8",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Adding custom transaction attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type support; however, this method should be considered obsolete and will be removed in a future release of the agent API. Further information may be found within .NET Agent API documentation. Enhanced type support for RecordCustomEvent and NoticeError API methods. APIs for recording exceptions and custom events now support values of all types. The NoticeError API method has new overloads that accept an IDictionary<string, object>. The RecordCustomEvent methods have been modified to handle all types of data. In that past, they only handled string and float types. Further information may be found within .NET agent API documentation. New attributes on span events Spans created for external HTTP calls now include the http.statusCode attribute representing the status code of the call. Spans created for calls to a datastore now include the db.collection attribute. For instance, this will be the table name for a call to MS SQL Server. Ability to exclude attributes from span events Attributes on span events (e.g., http.url) can now be excluded via configuration. See .NET agent configuration for further information. Fixes New Relic distributed tracing relies on propagating trace and span identifiers in the headers of external calls (e.g., an HTTP call). These identifiers now only contain lowercase alphanumeric characters. Previous versions of the .NET agent used uppercase alphanumeric characters. The usage of uppercase alphanumeric characters can break traces when calling downstream services also monitored by a New Relic agent that supports W3C trace context (New Relic's .NET agent does not currently support W3C trace context. Support for W3C trace context for .NET will be in an upcoming release). This is only a problem if a .NET application is the originator of the trace. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.0688,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "body": "New Features Adding custom transaction attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type"
      },
      "id": "60445fcc28ccbc43b42c60c5"
    }
  ],
  "/docs/agents/net-agent/net-agent-api/getbrowsertimingheader-net-agent-api": [
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "68ae52e48b04bfe2279bcd038778cc5eebf53d1d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-06-02T17:53:04Z",
      "updated_at": "2021-05-15T18:25:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.949326,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "6043cd9528ccbcfe1e2c60aa"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8252140/",
      "sections": [
        ".NET agent v8.25.214.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.25.214.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "8d905601b21cbe7e6884c5f649ea9ecfb1e35737",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Thread profiling support for Linux Thread profiling on Linux will be supported on .NET Core 3.0 or later applications when running .NET agent version 8.23 or later. Triggering a thread profile is done from the Thread profiler page in APM. Accessing Span-Specific information using the .NET Agent API New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the API. Adding Custom Span Attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ISpan. This new method accepts and supports all data-types. Further information may be found within .NET Agent API documentation. Adding custom attributes to spans requires distributed tracing and span events to be enabled. See .NET agent configuration Fixes Fixes issue where adding multiple custom attributes on a Transaction using ITransaction.AddCustomAttribute causes the agent to ignore additional attempts to add custom attributes to any transaction. Fixes issue that prevented Custom Events from being sent to New Relic until the agent shuts down. Fixes issue that can cause asynchronous Redis calls in an ASP.NET MVC application to report an inflated duration. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.91678,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "body": " the .<em>NET</em> <em>Agent</em> <em>API</em> New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the <em>API</em>. Adding Custom Span Attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been"
      },
      "id": "60445f8a196a673516960f8e"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8242440/",
      "sections": [
        ".NET agent v8.24.244.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.24.244.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "0df5ec86ce9abcad1d49457c32b2dec3873354b8",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Adding custom transaction attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type support; however, this method should be considered obsolete and will be removed in a future release of the agent API. Further information may be found within .NET Agent API documentation. Enhanced type support for RecordCustomEvent and NoticeError API methods. APIs for recording exceptions and custom events now support values of all types. The NoticeError API method has new overloads that accept an IDictionary<string, object>. The RecordCustomEvent methods have been modified to handle all types of data. In that past, they only handled string and float types. Further information may be found within .NET agent API documentation. New attributes on span events Spans created for external HTTP calls now include the http.statusCode attribute representing the status code of the call. Spans created for calls to a datastore now include the db.collection attribute. For instance, this will be the table name for a call to MS SQL Server. Ability to exclude attributes from span events Attributes on span events (e.g., http.url) can now be excluded via configuration. See .NET agent configuration for further information. Fixes New Relic distributed tracing relies on propagating trace and span identifiers in the headers of external calls (e.g., an HTTP call). These identifiers now only contain lowercase alphanumeric characters. Previous versions of the .NET agent used uppercase alphanumeric characters. The usage of uppercase alphanumeric characters can break traces when calling downstream services also monitored by a New Relic agent that supports W3C trace context (New Relic's .NET agent does not currently support W3C trace context. Support for W3C trace context for .NET will be in an upcoming release). This is only a problem if a .NET application is the originator of the trace. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.0688,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "body": "New Features Adding custom transaction attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type"
      },
      "id": "60445fcc28ccbc43b42c60c5"
    }
  ],
  "/docs/agents/net-agent/net-agent-api/getlinkingmetadata-net-agent-api": [
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "68ae52e48b04bfe2279bcd038778cc5eebf53d1d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-06-02T17:53:04Z",
      "updated_at": "2021-05-15T18:25:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.949326,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "6043cd9528ccbcfe1e2c60aa"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8252140/",
      "sections": [
        ".NET agent v8.25.214.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.25.214.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "8d905601b21cbe7e6884c5f649ea9ecfb1e35737",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Thread profiling support for Linux Thread profiling on Linux will be supported on .NET Core 3.0 or later applications when running .NET agent version 8.23 or later. Triggering a thread profile is done from the Thread profiler page in APM. Accessing Span-Specific information using the .NET Agent API New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the API. Adding Custom Span Attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ISpan. This new method accepts and supports all data-types. Further information may be found within .NET Agent API documentation. Adding custom attributes to spans requires distributed tracing and span events to be enabled. See .NET agent configuration Fixes Fixes issue where adding multiple custom attributes on a Transaction using ITransaction.AddCustomAttribute causes the agent to ignore additional attempts to add custom attributes to any transaction. Fixes issue that prevented Custom Events from being sent to New Relic until the agent shuts down. Fixes issue that can cause asynchronous Redis calls in an ASP.NET MVC application to report an inflated duration. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.91678,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "body": " the .<em>NET</em> <em>Agent</em> <em>API</em> New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the <em>API</em>. Adding Custom Span Attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been"
      },
      "id": "60445f8a196a673516960f8e"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8242440/",
      "sections": [
        ".NET agent v8.24.244.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.24.244.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "0df5ec86ce9abcad1d49457c32b2dec3873354b8",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Adding custom transaction attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type support; however, this method should be considered obsolete and will be removed in a future release of the agent API. Further information may be found within .NET Agent API documentation. Enhanced type support for RecordCustomEvent and NoticeError API methods. APIs for recording exceptions and custom events now support values of all types. The NoticeError API method has new overloads that accept an IDictionary<string, object>. The RecordCustomEvent methods have been modified to handle all types of data. In that past, they only handled string and float types. Further information may be found within .NET agent API documentation. New attributes on span events Spans created for external HTTP calls now include the http.statusCode attribute representing the status code of the call. Spans created for calls to a datastore now include the db.collection attribute. For instance, this will be the table name for a call to MS SQL Server. Ability to exclude attributes from span events Attributes on span events (e.g., http.url) can now be excluded via configuration. See .NET agent configuration for further information. Fixes New Relic distributed tracing relies on propagating trace and span identifiers in the headers of external calls (e.g., an HTTP call). These identifiers now only contain lowercase alphanumeric characters. Previous versions of the .NET agent used uppercase alphanumeric characters. The usage of uppercase alphanumeric characters can break traces when calling downstream services also monitored by a New Relic agent that supports W3C trace context (New Relic's .NET agent does not currently support W3C trace context. Support for W3C trace context for .NET will be in an upcoming release). This is only a problem if a .NET application is the originator of the trace. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.0688,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "body": "New Features Adding custom transaction attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type"
      },
      "id": "60445fcc28ccbc43b42c60c5"
    }
  ],
  "/docs/agents/net-agent/net-agent-api/iagent": [
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "68ae52e48b04bfe2279bcd038778cc5eebf53d1d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-06-02T17:53:04Z",
      "updated_at": "2021-05-15T18:25:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.94931,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "6043cd9528ccbcfe1e2c60aa"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8252140/",
      "sections": [
        ".NET agent v8.25.214.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.25.214.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "8d905601b21cbe7e6884c5f649ea9ecfb1e35737",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Thread profiling support for Linux Thread profiling on Linux will be supported on .NET Core 3.0 or later applications when running .NET agent version 8.23 or later. Triggering a thread profile is done from the Thread profiler page in APM. Accessing Span-Specific information using the .NET Agent API New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the API. Adding Custom Span Attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ISpan. This new method accepts and supports all data-types. Further information may be found within .NET Agent API documentation. Adding custom attributes to spans requires distributed tracing and span events to be enabled. See .NET agent configuration Fixes Fixes issue where adding multiple custom attributes on a Transaction using ITransaction.AddCustomAttribute causes the agent to ignore additional attempts to add custom attributes to any transaction. Fixes issue that prevented Custom Events from being sent to New Relic until the agent shuts down. Fixes issue that can cause asynchronous Redis calls in an ASP.NET MVC application to report an inflated duration. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.91678,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "body": " the .<em>NET</em> <em>Agent</em> <em>API</em> New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the <em>API</em>. Adding Custom Span Attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been"
      },
      "id": "60445f8a196a673516960f8e"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8242440/",
      "sections": [
        ".NET agent v8.24.244.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.24.244.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "0df5ec86ce9abcad1d49457c32b2dec3873354b8",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Adding custom transaction attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type support; however, this method should be considered obsolete and will be removed in a future release of the agent API. Further information may be found within .NET Agent API documentation. Enhanced type support for RecordCustomEvent and NoticeError API methods. APIs for recording exceptions and custom events now support values of all types. The NoticeError API method has new overloads that accept an IDictionary<string, object>. The RecordCustomEvent methods have been modified to handle all types of data. In that past, they only handled string and float types. Further information may be found within .NET agent API documentation. New attributes on span events Spans created for external HTTP calls now include the http.statusCode attribute representing the status code of the call. Spans created for calls to a datastore now include the db.collection attribute. For instance, this will be the table name for a call to MS SQL Server. Ability to exclude attributes from span events Attributes on span events (e.g., http.url) can now be excluded via configuration. See .NET agent configuration for further information. Fixes New Relic distributed tracing relies on propagating trace and span identifiers in the headers of external calls (e.g., an HTTP call). These identifiers now only contain lowercase alphanumeric characters. Previous versions of the .NET agent used uppercase alphanumeric characters. The usage of uppercase alphanumeric characters can break traces when calling downstream services also monitored by a New Relic agent that supports W3C trace context (New Relic's .NET agent does not currently support W3C trace context. Support for W3C trace context for .NET will be in an upcoming release). This is only a problem if a .NET application is the originator of the trace. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.068794,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "body": "New Features Adding custom transaction attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type"
      },
      "id": "60445fcc28ccbc43b42c60c5"
    }
  ],
  "/docs/agents/net-agent/net-agent-api/idistributedtracepayload-net-agent-api": [
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "68ae52e48b04bfe2279bcd038778cc5eebf53d1d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-06-02T17:53:04Z",
      "updated_at": "2021-05-15T18:25:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.94931,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "6043cd9528ccbcfe1e2c60aa"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8252140/",
      "sections": [
        ".NET agent v8.25.214.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.25.214.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "8d905601b21cbe7e6884c5f649ea9ecfb1e35737",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Thread profiling support for Linux Thread profiling on Linux will be supported on .NET Core 3.0 or later applications when running .NET agent version 8.23 or later. Triggering a thread profile is done from the Thread profiler page in APM. Accessing Span-Specific information using the .NET Agent API New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the API. Adding Custom Span Attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ISpan. This new method accepts and supports all data-types. Further information may be found within .NET Agent API documentation. Adding custom attributes to spans requires distributed tracing and span events to be enabled. See .NET agent configuration Fixes Fixes issue where adding multiple custom attributes on a Transaction using ITransaction.AddCustomAttribute causes the agent to ignore additional attempts to add custom attributes to any transaction. Fixes issue that prevented Custom Events from being sent to New Relic until the agent shuts down. Fixes issue that can cause asynchronous Redis calls in an ASP.NET MVC application to report an inflated duration. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.91678,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "body": " the .<em>NET</em> <em>Agent</em> <em>API</em> New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the <em>API</em>. Adding Custom Span Attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been"
      },
      "id": "60445f8a196a673516960f8e"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8242440/",
      "sections": [
        ".NET agent v8.24.244.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.24.244.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "0df5ec86ce9abcad1d49457c32b2dec3873354b8",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Adding custom transaction attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type support; however, this method should be considered obsolete and will be removed in a future release of the agent API. Further information may be found within .NET Agent API documentation. Enhanced type support for RecordCustomEvent and NoticeError API methods. APIs for recording exceptions and custom events now support values of all types. The NoticeError API method has new overloads that accept an IDictionary<string, object>. The RecordCustomEvent methods have been modified to handle all types of data. In that past, they only handled string and float types. Further information may be found within .NET agent API documentation. New attributes on span events Spans created for external HTTP calls now include the http.statusCode attribute representing the status code of the call. Spans created for calls to a datastore now include the db.collection attribute. For instance, this will be the table name for a call to MS SQL Server. Ability to exclude attributes from span events Attributes on span events (e.g., http.url) can now be excluded via configuration. See .NET agent configuration for further information. Fixes New Relic distributed tracing relies on propagating trace and span identifiers in the headers of external calls (e.g., an HTTP call). These identifiers now only contain lowercase alphanumeric characters. Previous versions of the .NET agent used uppercase alphanumeric characters. The usage of uppercase alphanumeric characters can break traces when calling downstream services also monitored by a New Relic agent that supports W3C trace context (New Relic's .NET agent does not currently support W3C trace context. Support for W3C trace context for .NET will be in an upcoming release). This is only a problem if a .NET application is the originator of the trace. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.068794,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "body": "New Features Adding custom transaction attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type"
      },
      "id": "60445fcc28ccbc43b42c60c5"
    }
  ],
  "/docs/agents/net-agent/net-agent-api/ignore-apdex": [
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "68ae52e48b04bfe2279bcd038778cc5eebf53d1d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-06-02T17:53:04Z",
      "updated_at": "2021-05-15T18:25:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.949295,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "6043cd9528ccbcfe1e2c60aa"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8252140/",
      "sections": [
        ".NET agent v8.25.214.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.25.214.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "8d905601b21cbe7e6884c5f649ea9ecfb1e35737",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Thread profiling support for Linux Thread profiling on Linux will be supported on .NET Core 3.0 or later applications when running .NET agent version 8.23 or later. Triggering a thread profile is done from the Thread profiler page in APM. Accessing Span-Specific information using the .NET Agent API New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the API. Adding Custom Span Attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ISpan. This new method accepts and supports all data-types. Further information may be found within .NET Agent API documentation. Adding custom attributes to spans requires distributed tracing and span events to be enabled. See .NET agent configuration Fixes Fixes issue where adding multiple custom attributes on a Transaction using ITransaction.AddCustomAttribute causes the agent to ignore additional attempts to add custom attributes to any transaction. Fixes issue that prevented Custom Events from being sent to New Relic until the agent shuts down. Fixes issue that can cause asynchronous Redis calls in an ASP.NET MVC application to report an inflated duration. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.91678,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "body": " the .<em>NET</em> <em>Agent</em> <em>API</em> New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the <em>API</em>. Adding Custom Span Attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been"
      },
      "id": "60445f8a196a673516960f8e"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8242440/",
      "sections": [
        ".NET agent v8.24.244.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.24.244.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "0df5ec86ce9abcad1d49457c32b2dec3873354b8",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Adding custom transaction attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type support; however, this method should be considered obsolete and will be removed in a future release of the agent API. Further information may be found within .NET Agent API documentation. Enhanced type support for RecordCustomEvent and NoticeError API methods. APIs for recording exceptions and custom events now support values of all types. The NoticeError API method has new overloads that accept an IDictionary<string, object>. The RecordCustomEvent methods have been modified to handle all types of data. In that past, they only handled string and float types. Further information may be found within .NET agent API documentation. New attributes on span events Spans created for external HTTP calls now include the http.statusCode attribute representing the status code of the call. Spans created for calls to a datastore now include the db.collection attribute. For instance, this will be the table name for a call to MS SQL Server. Ability to exclude attributes from span events Attributes on span events (e.g., http.url) can now be excluded via configuration. See .NET agent configuration for further information. Fixes New Relic distributed tracing relies on propagating trace and span identifiers in the headers of external calls (e.g., an HTTP call). These identifiers now only contain lowercase alphanumeric characters. Previous versions of the .NET agent used uppercase alphanumeric characters. The usage of uppercase alphanumeric characters can break traces when calling downstream services also monitored by a New Relic agent that supports W3C trace context (New Relic's .NET agent does not currently support W3C trace context. Support for W3C trace context for .NET will be in an upcoming release). This is only a problem if a .NET application is the originator of the trace. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.068794,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "body": "New Features Adding custom transaction attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type"
      },
      "id": "60445fcc28ccbc43b42c60c5"
    }
  ],
  "/docs/agents/net-agent/net-agent-api/ignore-transaction": [
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "68ae52e48b04bfe2279bcd038778cc5eebf53d1d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-06-02T17:53:04Z",
      "updated_at": "2021-05-15T18:25:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.949295,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "6043cd9528ccbcfe1e2c60aa"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8252140/",
      "sections": [
        ".NET agent v8.25.214.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.25.214.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "8d905601b21cbe7e6884c5f649ea9ecfb1e35737",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Thread profiling support for Linux Thread profiling on Linux will be supported on .NET Core 3.0 or later applications when running .NET agent version 8.23 or later. Triggering a thread profile is done from the Thread profiler page in APM. Accessing Span-Specific information using the .NET Agent API New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the API. Adding Custom Span Attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ISpan. This new method accepts and supports all data-types. Further information may be found within .NET Agent API documentation. Adding custom attributes to spans requires distributed tracing and span events to be enabled. See .NET agent configuration Fixes Fixes issue where adding multiple custom attributes on a Transaction using ITransaction.AddCustomAttribute causes the agent to ignore additional attempts to add custom attributes to any transaction. Fixes issue that prevented Custom Events from being sent to New Relic until the agent shuts down. Fixes issue that can cause asynchronous Redis calls in an ASP.NET MVC application to report an inflated duration. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.91678,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "body": " the .<em>NET</em> <em>Agent</em> <em>API</em> New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the <em>API</em>. Adding Custom Span Attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been"
      },
      "id": "60445f8a196a673516960f8e"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8242440/",
      "sections": [
        ".NET agent v8.24.244.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.24.244.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "0df5ec86ce9abcad1d49457c32b2dec3873354b8",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Adding custom transaction attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type support; however, this method should be considered obsolete and will be removed in a future release of the agent API. Further information may be found within .NET Agent API documentation. Enhanced type support for RecordCustomEvent and NoticeError API methods. APIs for recording exceptions and custom events now support values of all types. The NoticeError API method has new overloads that accept an IDictionary<string, object>. The RecordCustomEvent methods have been modified to handle all types of data. In that past, they only handled string and float types. Further information may be found within .NET agent API documentation. New attributes on span events Spans created for external HTTP calls now include the http.statusCode attribute representing the status code of the call. Spans created for calls to a datastore now include the db.collection attribute. For instance, this will be the table name for a call to MS SQL Server. Ability to exclude attributes from span events Attributes on span events (e.g., http.url) can now be excluded via configuration. See .NET agent configuration for further information. Fixes New Relic distributed tracing relies on propagating trace and span identifiers in the headers of external calls (e.g., an HTTP call). These identifiers now only contain lowercase alphanumeric characters. Previous versions of the .NET agent used uppercase alphanumeric characters. The usage of uppercase alphanumeric characters can break traces when calling downstream services also monitored by a New Relic agent that supports W3C trace context (New Relic's .NET agent does not currently support W3C trace context. Support for W3C trace context for .NET will be in an upcoming release). This is only a problem if a .NET application is the originator of the trace. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.068794,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "body": "New Features Adding custom transaction attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type"
      },
      "id": "60445fcc28ccbc43b42c60c5"
    }
  ],
  "/docs/agents/net-agent/net-agent-api/incrementcounter-net-agent-api": [
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "68ae52e48b04bfe2279bcd038778cc5eebf53d1d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-06-02T17:53:04Z",
      "updated_at": "2021-05-15T18:25:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.94928,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "6043cd9528ccbcfe1e2c60aa"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8252140/",
      "sections": [
        ".NET agent v8.25.214.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.25.214.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "8d905601b21cbe7e6884c5f649ea9ecfb1e35737",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Thread profiling support for Linux Thread profiling on Linux will be supported on .NET Core 3.0 or later applications when running .NET agent version 8.23 or later. Triggering a thread profile is done from the Thread profiler page in APM. Accessing Span-Specific information using the .NET Agent API New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the API. Adding Custom Span Attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ISpan. This new method accepts and supports all data-types. Further information may be found within .NET Agent API documentation. Adding custom attributes to spans requires distributed tracing and span events to be enabled. See .NET agent configuration Fixes Fixes issue where adding multiple custom attributes on a Transaction using ITransaction.AddCustomAttribute causes the agent to ignore additional attempts to add custom attributes to any transaction. Fixes issue that prevented Custom Events from being sent to New Relic until the agent shuts down. Fixes issue that can cause asynchronous Redis calls in an ASP.NET MVC application to report an inflated duration. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.91678,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "body": " the .<em>NET</em> <em>Agent</em> <em>API</em> New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the <em>API</em>. Adding Custom Span Attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been"
      },
      "id": "60445f8a196a673516960f8e"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8242440/",
      "sections": [
        ".NET agent v8.24.244.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.24.244.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "0df5ec86ce9abcad1d49457c32b2dec3873354b8",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Adding custom transaction attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type support; however, this method should be considered obsolete and will be removed in a future release of the agent API. Further information may be found within .NET Agent API documentation. Enhanced type support for RecordCustomEvent and NoticeError API methods. APIs for recording exceptions and custom events now support values of all types. The NoticeError API method has new overloads that accept an IDictionary<string, object>. The RecordCustomEvent methods have been modified to handle all types of data. In that past, they only handled string and float types. Further information may be found within .NET agent API documentation. New attributes on span events Spans created for external HTTP calls now include the http.statusCode attribute representing the status code of the call. Spans created for calls to a datastore now include the db.collection attribute. For instance, this will be the table name for a call to MS SQL Server. Ability to exclude attributes from span events Attributes on span events (e.g., http.url) can now be excluded via configuration. See .NET agent configuration for further information. Fixes New Relic distributed tracing relies on propagating trace and span identifiers in the headers of external calls (e.g., an HTTP call). These identifiers now only contain lowercase alphanumeric characters. Previous versions of the .NET agent used uppercase alphanumeric characters. The usage of uppercase alphanumeric characters can break traces when calling downstream services also monitored by a New Relic agent that supports W3C trace context (New Relic's .NET agent does not currently support W3C trace context. Support for W3C trace context for .NET will be in an upcoming release). This is only a problem if a .NET application is the originator of the trace. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.068794,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "body": "New Features Adding custom transaction attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type"
      },
      "id": "60445fcc28ccbc43b42c60c5"
    }
  ],
  "/docs/agents/net-agent/net-agent-api/index": [
    {
      "sections": [
        "Introduction to New Relic APIs",
        "Tip",
        "NerdGraph (GraphQL)",
        "REST APIs by capability",
        "Alerts",
        "APM",
        "Browser monitoring",
        "Infrastructure monitoring",
        "Mobile monitoring",
        "Synthetic monitoring",
        "Telemetry APIs for core data types",
        "Account management, admin, and usage APIs",
        "Other APIs",
        "Insights",
        "Plugins",
        "See APIs in action"
      ],
      "title": "Introduction to New Relic APIs",
      "type": "docs",
      "tags": [
        "APIs",
        "Get started",
        "Intro to APIs"
      ],
      "external_id": "01e9799a214baad5de04de6146483f6dbbc198aa",
      "image": "",
      "url": "https://docs.newrelic.com/docs/apis/intro-apis/introduction-new-relic-apis/",
      "published_at": "2021-06-02T16:33:26Z",
      "updated_at": "2021-06-02T16:33:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers a variety of APIs and SDKs you can use to: Retrieve data from New Relic. Send data to New Relic. Adjust settings. This document provides examples and reference information for our API endpoints. For developer-focused content on how to use and customize New Relic, see developer.newrelic.com. Tip To use APIs and SDKs, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. NerdGraph (GraphQL) NerdGraph is New Relic's GraphQL-format API, an efficient and flexible query language that lets you request exactly the data you need, without over-fetching or under-fetching. NerdGraph is the preferred API for querying New Relic data and making a range of feature configurations. To get started, see Introduction to NerdGraph. REST APIs by capability New Relic capabilities, like APM, infrastructure monitoring, or alerts, are often used together, and sometimes they overlap in functionality. This is why multiple APIs may be relevant to each area. Some API functionality will depend on your access to features and data. Tip To learn more about different API key types, see Understand New Relic API keys. Alerts Use the REST API for alerts and the API Explorer to: Create and manage policies, conditions, and notification channels. Create alert conditions based on NRQL queries. Create alert conditions based on data from other New Relic capabilities. APM API resources for application monitoring include: Resource Details REST API REST API features include: Retrieve APM data, including metrics, Apdex, error rates, and host data. Report deployments. Change the app name in the UI. Agent APIs Every APM language agent has an API that lets you customize the agent's default behavior, including reporting custom data. APM agent APIs include: C SDK API Go agent API Java agent API .NET agent API Node.js agent API PHP agent API Python agent API Ruby agent API Query API To query APM data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Browser monitoring The Browser API resources include: Resource Details Browser agent API Use the Browser agent API for tasks such as: Report custom end user data to browser monitoring. Monitor asynchronous browser activity using SPA API calls. Insert custom data into New Relic dashboards . Manage source maps. REST API With the REST API you can: Retrieve page load timing data and throughput. Add or list apps monitored by browser monitoring. Manage alerts conditions for your browser data. Query API To retrieve browser monitoring data, use the Query API. Account management APIs For APIs related to accounts and subscription usage, see the account-related APIs. Infrastructure monitoring The Infrastructure API resources include: Resource Details Query API To retrieve infrastructure data, use the Query API. This API can also be used to retrieve subscription usage data. Infrastructure alert API To manage your infrastructure alerts, use the Infrastructure alert API. Integrations SDK To make your own custom integrations for reporting data to infrastructure monitoring, use the Integrations SDK. NerdGraph You can use NerdGraph (our GraphQL API) to query your cloud integration data and make changes to cloud integration settings. Mobile monitoring Mobile API resources include: Resource Details Mobile agent APIs Mobile APIs let you custom instrument your own code and send events to New Relic. See the platform-specific documentation: iOS Android Unity REST API Use the REST API for such tasks as: Retrieve a list of monitored apps. Get subscription usage data. Get metric names and data. Get crash count and crash rate data. Manage New Relic alerts conditions for your mobile apps. Query API To retrieve Mobile data from New Relic, use the Query API. Account management APIs For account-related APIs, see Account APIs. Synthetic monitoring Synthetics API resources include: Resource Details Synthetics REST API The Synthetics REST API functionality includes: Create and manage synthetics monitors. Manage synthetics alert notifications. Add labels to monitors, and retrieve monitors with specific labels. Query API To retrieve synthetics event data, use the Query API. Alerts API To create and manage alert conditions that target synthetics monitors, use the Alerts API. Telemetry APIs for core data types We offer several APIs that allow you to get our core data types (metrics, logs, traces, and events) into New Relic without the use of an installed agent. Data type Description Trace API Send distributed tracing data to New Relic. Event API Send event data to New Relic. Metric API Send metrics to New Relic from any source (including other telemetry monitoring services). Log API Send your log data to New Relic. Account management, admin, and usage APIs Like any other New Relic product or service, you want to be confident that your APIs protect you and your customers' data privacy. The following are API resources related to New Relic account administration and usage. For more information about API capabilities, see the specific New Relic API. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Resource Details REST API REST API features include: Find your API keys, account ID, and information needed to use the REST API. Return a list of account users (original user model only). Get SLA report data for browser and application monitoring. Subscription usage You can use the Query API to retrieve subscription usage data. This can be helpful to see how usage compares to your current subscription level, or for doing departmental chargebacks. Partner API To retrieve information about your New Relic partner account, sub-accounts, and users, use the Partner API. Other APIs Insights New Relic Insights was the name of our original product that governed custom event reporting and querying. The features associated with Insights have been rolled into our New Relic One platform (learn more), but there are still some APIs and original pricing plans that use the term \"Insights\" for these historical reasons. Insights-related APIs include: Resource Details Event API To report custom events, use the Event API. Query API To query your data using NRQL-format queries, you can use the Query API. Note that this API is deprecated and NerdGraph is preferred for querying your data. Dashboard API See the Insights Dashboard API. Plugins Use the REST API for New Relic plugins and the API Explorer to: Get a list of plugins, including their names, IDs, and GUIDs. List one or more plugin components, their output, and their metric timeslice data. Developers and New Relic partners can also use New Relic's Plugin API to write an agent in any language that can work directly with the API for plugins. This allows you to send your own metric data to our plugins and view data received from the API in New Relic. See APIs in action For more on how you as a developer can optimize your ability to solve problems using New Relic, go to developer.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 634.48737,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Introduction to New Relic <em>APIs</em>",
        "sections": "Introduction to New Relic <em>APIs</em>",
        "tags": "<em>APIs</em>",
        "body": " customize the <em>agent</em>&#x27;s default behavior, including reporting custom data. APM <em>agent</em> APIs include: C SDK <em>API</em> Go <em>agent</em> <em>API</em> Java <em>agent</em> <em>API</em> .<em>NET</em> <em>agent</em> <em>API</em> Node.js <em>agent</em> <em>API</em> PHP <em>agent</em> <em>API</em> Python <em>agent</em> <em>API</em> Ruby <em>agent</em> <em>API</em> Query <em>API</em> To query APM data, use the Query <em>API</em>. Account management APIs For APIs"
      },
      "id": "609fa5cf196a67066022b194"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8252140/",
      "sections": [
        ".NET agent v8.25.214.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.25.214.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "8d905601b21cbe7e6884c5f649ea9ecfb1e35737",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Thread profiling support for Linux Thread profiling on Linux will be supported on .NET Core 3.0 or later applications when running .NET agent version 8.23 or later. Triggering a thread profile is done from the Thread profiler page in APM. Accessing Span-Specific information using the .NET Agent API New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the API. Adding Custom Span Attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ISpan. This new method accepts and supports all data-types. Further information may be found within .NET Agent API documentation. Adding custom attributes to spans requires distributed tracing and span events to be enabled. See .NET agent configuration Fixes Fixes issue where adding multiple custom attributes on a Transaction using ITransaction.AddCustomAttribute causes the agent to ignore additional attempts to add custom attributes to any transaction. Fixes issue that prevented Custom Events from being sent to New Relic until the agent shuts down. Fixes issue that can cause asynchronous Redis calls in an ASP.NET MVC application to report an inflated duration. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 548.8854,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "body": " the .<em>NET</em> <em>Agent</em> <em>API</em> New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the <em>API</em>. Adding Custom Span Attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been"
      },
      "id": "60445f8a196a673516960f8e"
    },
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "68ae52e48b04bfe2279bcd038778cc5eebf53d1d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-06-02T17:53:04Z",
      "updated_at": "2021-05-15T18:25:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 537.3185,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "6043cd9528ccbcfe1e2c60aa"
    }
  ],
  "/docs/agents/net-agent/net-agent-api/ispan": [
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "68ae52e48b04bfe2279bcd038778cc5eebf53d1d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-06-02T17:53:04Z",
      "updated_at": "2021-05-15T18:25:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.949265,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "6043cd9528ccbcfe1e2c60aa"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8252140/",
      "sections": [
        ".NET agent v8.25.214.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.25.214.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "8d905601b21cbe7e6884c5f649ea9ecfb1e35737",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Thread profiling support for Linux Thread profiling on Linux will be supported on .NET Core 3.0 or later applications when running .NET agent version 8.23 or later. Triggering a thread profile is done from the Thread profiler page in APM. Accessing Span-Specific information using the .NET Agent API New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the API. Adding Custom Span Attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ISpan. This new method accepts and supports all data-types. Further information may be found within .NET Agent API documentation. Adding custom attributes to spans requires distributed tracing and span events to be enabled. See .NET agent configuration Fixes Fixes issue where adding multiple custom attributes on a Transaction using ITransaction.AddCustomAttribute causes the agent to ignore additional attempts to add custom attributes to any transaction. Fixes issue that prevented Custom Events from being sent to New Relic until the agent shuts down. Fixes issue that can cause asynchronous Redis calls in an ASP.NET MVC application to report an inflated duration. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.91678,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "body": " the .<em>NET</em> <em>Agent</em> <em>API</em> New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the <em>API</em>. Adding Custom Span Attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been"
      },
      "id": "60445f8a196a673516960f8e"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8242440/",
      "sections": [
        ".NET agent v8.24.244.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.24.244.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "0df5ec86ce9abcad1d49457c32b2dec3873354b8",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Adding custom transaction attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type support; however, this method should be considered obsolete and will be removed in a future release of the agent API. Further information may be found within .NET Agent API documentation. Enhanced type support for RecordCustomEvent and NoticeError API methods. APIs for recording exceptions and custom events now support values of all types. The NoticeError API method has new overloads that accept an IDictionary<string, object>. The RecordCustomEvent methods have been modified to handle all types of data. In that past, they only handled string and float types. Further information may be found within .NET agent API documentation. New attributes on span events Spans created for external HTTP calls now include the http.statusCode attribute representing the status code of the call. Spans created for calls to a datastore now include the db.collection attribute. For instance, this will be the table name for a call to MS SQL Server. Ability to exclude attributes from span events Attributes on span events (e.g., http.url) can now be excluded via configuration. See .NET agent configuration for further information. Fixes New Relic distributed tracing relies on propagating trace and span identifiers in the headers of external calls (e.g., an HTTP call). These identifiers now only contain lowercase alphanumeric characters. Previous versions of the .NET agent used uppercase alphanumeric characters. The usage of uppercase alphanumeric characters can break traces when calling downstream services also monitored by a New Relic agent that supports W3C trace context (New Relic's .NET agent does not currently support W3C trace context. Support for W3C trace context for .NET will be in an upcoming release). This is only a problem if a .NET application is the originator of the trace. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.068794,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "body": "New Features Adding custom transaction attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type"
      },
      "id": "60445fcc28ccbc43b42c60c5"
    }
  ],
  "/docs/agents/net-agent/net-agent-api/itransaction": [
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "68ae52e48b04bfe2279bcd038778cc5eebf53d1d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-06-02T17:53:04Z",
      "updated_at": "2021-05-15T18:25:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.949265,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "6043cd9528ccbcfe1e2c60aa"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8252140/",
      "sections": [
        ".NET agent v8.25.214.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.25.214.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "8d905601b21cbe7e6884c5f649ea9ecfb1e35737",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Thread profiling support for Linux Thread profiling on Linux will be supported on .NET Core 3.0 or later applications when running .NET agent version 8.23 or later. Triggering a thread profile is done from the Thread profiler page in APM. Accessing Span-Specific information using the .NET Agent API New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the API. Adding Custom Span Attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ISpan. This new method accepts and supports all data-types. Further information may be found within .NET Agent API documentation. Adding custom attributes to spans requires distributed tracing and span events to be enabled. See .NET agent configuration Fixes Fixes issue where adding multiple custom attributes on a Transaction using ITransaction.AddCustomAttribute causes the agent to ignore additional attempts to add custom attributes to any transaction. Fixes issue that prevented Custom Events from being sent to New Relic until the agent shuts down. Fixes issue that can cause asynchronous Redis calls in an ASP.NET MVC application to report an inflated duration. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.91678,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "body": " the .<em>NET</em> <em>Agent</em> <em>API</em> New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the <em>API</em>. Adding Custom Span Attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been"
      },
      "id": "60445f8a196a673516960f8e"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8242440/",
      "sections": [
        ".NET agent v8.24.244.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.24.244.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "0df5ec86ce9abcad1d49457c32b2dec3873354b8",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Adding custom transaction attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type support; however, this method should be considered obsolete and will be removed in a future release of the agent API. Further information may be found within .NET Agent API documentation. Enhanced type support for RecordCustomEvent and NoticeError API methods. APIs for recording exceptions and custom events now support values of all types. The NoticeError API method has new overloads that accept an IDictionary<string, object>. The RecordCustomEvent methods have been modified to handle all types of data. In that past, they only handled string and float types. Further information may be found within .NET agent API documentation. New attributes on span events Spans created for external HTTP calls now include the http.statusCode attribute representing the status code of the call. Spans created for calls to a datastore now include the db.collection attribute. For instance, this will be the table name for a call to MS SQL Server. Ability to exclude attributes from span events Attributes on span events (e.g., http.url) can now be excluded via configuration. See .NET agent configuration for further information. Fixes New Relic distributed tracing relies on propagating trace and span identifiers in the headers of external calls (e.g., an HTTP call). These identifiers now only contain lowercase alphanumeric characters. Previous versions of the .NET agent used uppercase alphanumeric characters. The usage of uppercase alphanumeric characters can break traces when calling downstream services also monitored by a New Relic agent that supports W3C trace context (New Relic's .NET agent does not currently support W3C trace context. Support for W3C trace context for .NET will be in an upcoming release). This is only a problem if a .NET application is the originator of the trace. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.068794,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "body": "New Features Adding custom transaction attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type"
      },
      "id": "60445fcc28ccbc43b42c60c5"
    }
  ],
  "/docs/agents/net-agent/net-agent-api/noticeerror-net-agent-api": [
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "68ae52e48b04bfe2279bcd038778cc5eebf53d1d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-06-02T17:53:04Z",
      "updated_at": "2021-05-15T18:25:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.94925,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "6043cd9528ccbcfe1e2c60aa"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8252140/",
      "sections": [
        ".NET agent v8.25.214.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.25.214.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "8d905601b21cbe7e6884c5f649ea9ecfb1e35737",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Thread profiling support for Linux Thread profiling on Linux will be supported on .NET Core 3.0 or later applications when running .NET agent version 8.23 or later. Triggering a thread profile is done from the Thread profiler page in APM. Accessing Span-Specific information using the .NET Agent API New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the API. Adding Custom Span Attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ISpan. This new method accepts and supports all data-types. Further information may be found within .NET Agent API documentation. Adding custom attributes to spans requires distributed tracing and span events to be enabled. See .NET agent configuration Fixes Fixes issue where adding multiple custom attributes on a Transaction using ITransaction.AddCustomAttribute causes the agent to ignore additional attempts to add custom attributes to any transaction. Fixes issue that prevented Custom Events from being sent to New Relic until the agent shuts down. Fixes issue that can cause asynchronous Redis calls in an ASP.NET MVC application to report an inflated duration. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.91677,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "body": " the .<em>NET</em> <em>Agent</em> <em>API</em> New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the <em>API</em>. Adding Custom Span Attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been"
      },
      "id": "60445f8a196a673516960f8e"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8242440/",
      "sections": [
        ".NET agent v8.24.244.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.24.244.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "0df5ec86ce9abcad1d49457c32b2dec3873354b8",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Adding custom transaction attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type support; however, this method should be considered obsolete and will be removed in a future release of the agent API. Further information may be found within .NET Agent API documentation. Enhanced type support for RecordCustomEvent and NoticeError API methods. APIs for recording exceptions and custom events now support values of all types. The NoticeError API method has new overloads that accept an IDictionary<string, object>. The RecordCustomEvent methods have been modified to handle all types of data. In that past, they only handled string and float types. Further information may be found within .NET agent API documentation. New attributes on span events Spans created for external HTTP calls now include the http.statusCode attribute representing the status code of the call. Spans created for calls to a datastore now include the db.collection attribute. For instance, this will be the table name for a call to MS SQL Server. Ability to exclude attributes from span events Attributes on span events (e.g., http.url) can now be excluded via configuration. See .NET agent configuration for further information. Fixes New Relic distributed tracing relies on propagating trace and span identifiers in the headers of external calls (e.g., an HTTP call). These identifiers now only contain lowercase alphanumeric characters. Previous versions of the .NET agent used uppercase alphanumeric characters. The usage of uppercase alphanumeric characters can break traces when calling downstream services also monitored by a New Relic agent that supports W3C trace context (New Relic's .NET agent does not currently support W3C trace context. Support for W3C trace context for .NET will be in an upcoming release). This is only a problem if a .NET application is the originator of the trace. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.068794,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "body": "New Features Adding custom transaction attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type"
      },
      "id": "60445fcc28ccbc43b42c60c5"
    }
  ],
  "/docs/agents/net-agent/net-agent-api/recordcustomevent-net-agent-api": [
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "68ae52e48b04bfe2279bcd038778cc5eebf53d1d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-06-02T17:53:04Z",
      "updated_at": "2021-05-15T18:25:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.94925,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "6043cd9528ccbcfe1e2c60aa"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8252140/",
      "sections": [
        ".NET agent v8.25.214.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.25.214.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "8d905601b21cbe7e6884c5f649ea9ecfb1e35737",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Thread profiling support for Linux Thread profiling on Linux will be supported on .NET Core 3.0 or later applications when running .NET agent version 8.23 or later. Triggering a thread profile is done from the Thread profiler page in APM. Accessing Span-Specific information using the .NET Agent API New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the API. Adding Custom Span Attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ISpan. This new method accepts and supports all data-types. Further information may be found within .NET Agent API documentation. Adding custom attributes to spans requires distributed tracing and span events to be enabled. See .NET agent configuration Fixes Fixes issue where adding multiple custom attributes on a Transaction using ITransaction.AddCustomAttribute causes the agent to ignore additional attempts to add custom attributes to any transaction. Fixes issue that prevented Custom Events from being sent to New Relic until the agent shuts down. Fixes issue that can cause asynchronous Redis calls in an ASP.NET MVC application to report an inflated duration. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.91677,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "body": " the .<em>NET</em> <em>Agent</em> <em>API</em> New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the <em>API</em>. Adding Custom Span Attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been"
      },
      "id": "60445f8a196a673516960f8e"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8242440/",
      "sections": [
        ".NET agent v8.24.244.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.24.244.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "0df5ec86ce9abcad1d49457c32b2dec3873354b8",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Adding custom transaction attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type support; however, this method should be considered obsolete and will be removed in a future release of the agent API. Further information may be found within .NET Agent API documentation. Enhanced type support for RecordCustomEvent and NoticeError API methods. APIs for recording exceptions and custom events now support values of all types. The NoticeError API method has new overloads that accept an IDictionary<string, object>. The RecordCustomEvent methods have been modified to handle all types of data. In that past, they only handled string and float types. Further information may be found within .NET agent API documentation. New attributes on span events Spans created for external HTTP calls now include the http.statusCode attribute representing the status code of the call. Spans created for calls to a datastore now include the db.collection attribute. For instance, this will be the table name for a call to MS SQL Server. Ability to exclude attributes from span events Attributes on span events (e.g., http.url) can now be excluded via configuration. See .NET agent configuration for further information. Fixes New Relic distributed tracing relies on propagating trace and span identifiers in the headers of external calls (e.g., an HTTP call). These identifiers now only contain lowercase alphanumeric characters. Previous versions of the .NET agent used uppercase alphanumeric characters. The usage of uppercase alphanumeric characters can break traces when calling downstream services also monitored by a New Relic agent that supports W3C trace context (New Relic's .NET agent does not currently support W3C trace context. Support for W3C trace context for .NET will be in an upcoming release). This is only a problem if a .NET application is the originator of the trace. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.068794,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "body": "New Features Adding custom transaction attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type"
      },
      "id": "60445fcc28ccbc43b42c60c5"
    }
  ],
  "/docs/agents/net-agent/net-agent-api/recordmetric-net-agent-api": [
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "68ae52e48b04bfe2279bcd038778cc5eebf53d1d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-06-02T17:53:04Z",
      "updated_at": "2021-05-15T18:25:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.94925,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "6043cd9528ccbcfe1e2c60aa"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8252140/",
      "sections": [
        ".NET agent v8.25.214.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.25.214.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "8d905601b21cbe7e6884c5f649ea9ecfb1e35737",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Thread profiling support for Linux Thread profiling on Linux will be supported on .NET Core 3.0 or later applications when running .NET agent version 8.23 or later. Triggering a thread profile is done from the Thread profiler page in APM. Accessing Span-Specific information using the .NET Agent API New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the API. Adding Custom Span Attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ISpan. This new method accepts and supports all data-types. Further information may be found within .NET Agent API documentation. Adding custom attributes to spans requires distributed tracing and span events to be enabled. See .NET agent configuration Fixes Fixes issue where adding multiple custom attributes on a Transaction using ITransaction.AddCustomAttribute causes the agent to ignore additional attempts to add custom attributes to any transaction. Fixes issue that prevented Custom Events from being sent to New Relic until the agent shuts down. Fixes issue that can cause asynchronous Redis calls in an ASP.NET MVC application to report an inflated duration. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.91677,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "body": " the .<em>NET</em> <em>Agent</em> <em>API</em> New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the <em>API</em>. Adding Custom Span Attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been"
      },
      "id": "60445f8a196a673516960f8e"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8242440/",
      "sections": [
        ".NET agent v8.24.244.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.24.244.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "0df5ec86ce9abcad1d49457c32b2dec3873354b8",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Adding custom transaction attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type support; however, this method should be considered obsolete and will be removed in a future release of the agent API. Further information may be found within .NET Agent API documentation. Enhanced type support for RecordCustomEvent and NoticeError API methods. APIs for recording exceptions and custom events now support values of all types. The NoticeError API method has new overloads that accept an IDictionary<string, object>. The RecordCustomEvent methods have been modified to handle all types of data. In that past, they only handled string and float types. Further information may be found within .NET agent API documentation. New attributes on span events Spans created for external HTTP calls now include the http.statusCode attribute representing the status code of the call. Spans created for calls to a datastore now include the db.collection attribute. For instance, this will be the table name for a call to MS SQL Server. Ability to exclude attributes from span events Attributes on span events (e.g., http.url) can now be excluded via configuration. See .NET agent configuration for further information. Fixes New Relic distributed tracing relies on propagating trace and span identifiers in the headers of external calls (e.g., an HTTP call). These identifiers now only contain lowercase alphanumeric characters. Previous versions of the .NET agent used uppercase alphanumeric characters. The usage of uppercase alphanumeric characters can break traces when calling downstream services also monitored by a New Relic agent that supports W3C trace context (New Relic's .NET agent does not currently support W3C trace context. Support for W3C trace context for .NET will be in an upcoming release). This is only a problem if a .NET application is the originator of the trace. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.068794,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "body": "New Features Adding custom transaction attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type"
      },
      "id": "60445fcc28ccbc43b42c60c5"
    }
  ],
  "/docs/agents/net-agent/net-agent-api/recordresponsetimemetric-net-agent-api": [
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "68ae52e48b04bfe2279bcd038778cc5eebf53d1d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-06-02T17:53:04Z",
      "updated_at": "2021-05-15T18:25:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.949234,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "6043cd9528ccbcfe1e2c60aa"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8252140/",
      "sections": [
        ".NET agent v8.25.214.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.25.214.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "8d905601b21cbe7e6884c5f649ea9ecfb1e35737",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Thread profiling support for Linux Thread profiling on Linux will be supported on .NET Core 3.0 or later applications when running .NET agent version 8.23 or later. Triggering a thread profile is done from the Thread profiler page in APM. Accessing Span-Specific information using the .NET Agent API New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the API. Adding Custom Span Attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ISpan. This new method accepts and supports all data-types. Further information may be found within .NET Agent API documentation. Adding custom attributes to spans requires distributed tracing and span events to be enabled. See .NET agent configuration Fixes Fixes issue where adding multiple custom attributes on a Transaction using ITransaction.AddCustomAttribute causes the agent to ignore additional attempts to add custom attributes to any transaction. Fixes issue that prevented Custom Events from being sent to New Relic until the agent shuts down. Fixes issue that can cause asynchronous Redis calls in an ASP.NET MVC application to report an inflated duration. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.91677,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "body": " the .<em>NET</em> <em>Agent</em> <em>API</em> New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the <em>API</em>. Adding Custom Span Attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been"
      },
      "id": "60445f8a196a673516960f8e"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8242440/",
      "sections": [
        ".NET agent v8.24.244.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.24.244.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "0df5ec86ce9abcad1d49457c32b2dec3873354b8",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Adding custom transaction attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type support; however, this method should be considered obsolete and will be removed in a future release of the agent API. Further information may be found within .NET Agent API documentation. Enhanced type support for RecordCustomEvent and NoticeError API methods. APIs for recording exceptions and custom events now support values of all types. The NoticeError API method has new overloads that accept an IDictionary<string, object>. The RecordCustomEvent methods have been modified to handle all types of data. In that past, they only handled string and float types. Further information may be found within .NET agent API documentation. New attributes on span events Spans created for external HTTP calls now include the http.statusCode attribute representing the status code of the call. Spans created for calls to a datastore now include the db.collection attribute. For instance, this will be the table name for a call to MS SQL Server. Ability to exclude attributes from span events Attributes on span events (e.g., http.url) can now be excluded via configuration. See .NET agent configuration for further information. Fixes New Relic distributed tracing relies on propagating trace and span identifiers in the headers of external calls (e.g., an HTTP call). These identifiers now only contain lowercase alphanumeric characters. Previous versions of the .NET agent used uppercase alphanumeric characters. The usage of uppercase alphanumeric characters can break traces when calling downstream services also monitored by a New Relic agent that supports W3C trace context (New Relic's .NET agent does not currently support W3C trace context. Support for W3C trace context for .NET will be in an upcoming release). This is only a problem if a .NET application is the originator of the trace. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.06879,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "body": "New Features Adding custom transaction attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type"
      },
      "id": "60445fcc28ccbc43b42c60c5"
    }
  ],
  "/docs/agents/net-agent/net-agent-api/set-application-name": [
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "68ae52e48b04bfe2279bcd038778cc5eebf53d1d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-06-02T17:53:04Z",
      "updated_at": "2021-05-15T18:25:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.949234,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "6043cd9528ccbcfe1e2c60aa"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8252140/",
      "sections": [
        ".NET agent v8.25.214.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.25.214.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "8d905601b21cbe7e6884c5f649ea9ecfb1e35737",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Thread profiling support for Linux Thread profiling on Linux will be supported on .NET Core 3.0 or later applications when running .NET agent version 8.23 or later. Triggering a thread profile is done from the Thread profiler page in APM. Accessing Span-Specific information using the .NET Agent API New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the API. Adding Custom Span Attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ISpan. This new method accepts and supports all data-types. Further information may be found within .NET Agent API documentation. Adding custom attributes to spans requires distributed tracing and span events to be enabled. See .NET agent configuration Fixes Fixes issue where adding multiple custom attributes on a Transaction using ITransaction.AddCustomAttribute causes the agent to ignore additional attempts to add custom attributes to any transaction. Fixes issue that prevented Custom Events from being sent to New Relic until the agent shuts down. Fixes issue that can cause asynchronous Redis calls in an ASP.NET MVC application to report an inflated duration. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.91677,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "body": " the .<em>NET</em> <em>Agent</em> <em>API</em> New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the <em>API</em>. Adding Custom Span Attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been"
      },
      "id": "60445f8a196a673516960f8e"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8242440/",
      "sections": [
        ".NET agent v8.24.244.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.24.244.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "0df5ec86ce9abcad1d49457c32b2dec3873354b8",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Adding custom transaction attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type support; however, this method should be considered obsolete and will be removed in a future release of the agent API. Further information may be found within .NET Agent API documentation. Enhanced type support for RecordCustomEvent and NoticeError API methods. APIs for recording exceptions and custom events now support values of all types. The NoticeError API method has new overloads that accept an IDictionary<string, object>. The RecordCustomEvent methods have been modified to handle all types of data. In that past, they only handled string and float types. Further information may be found within .NET agent API documentation. New attributes on span events Spans created for external HTTP calls now include the http.statusCode attribute representing the status code of the call. Spans created for calls to a datastore now include the db.collection attribute. For instance, this will be the table name for a call to MS SQL Server. Ability to exclude attributes from span events Attributes on span events (e.g., http.url) can now be excluded via configuration. See .NET agent configuration for further information. Fixes New Relic distributed tracing relies on propagating trace and span identifiers in the headers of external calls (e.g., an HTTP call). These identifiers now only contain lowercase alphanumeric characters. Previous versions of the .NET agent used uppercase alphanumeric characters. The usage of uppercase alphanumeric characters can break traces when calling downstream services also monitored by a New Relic agent that supports W3C trace context (New Relic's .NET agent does not currently support W3C trace context. Support for W3C trace context for .NET will be in an upcoming release). This is only a problem if a .NET application is the originator of the trace. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.06879,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "body": "New Features Adding custom transaction attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type"
      },
      "id": "60445fcc28ccbc43b42c60c5"
    }
  ],
  "/docs/agents/net-agent/net-agent-api/set-transaction-uri": [
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "68ae52e48b04bfe2279bcd038778cc5eebf53d1d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-06-02T17:53:04Z",
      "updated_at": "2021-05-15T18:25:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.94922,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "6043cd9528ccbcfe1e2c60aa"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8252140/",
      "sections": [
        ".NET agent v8.25.214.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.25.214.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "8d905601b21cbe7e6884c5f649ea9ecfb1e35737",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Thread profiling support for Linux Thread profiling on Linux will be supported on .NET Core 3.0 or later applications when running .NET agent version 8.23 or later. Triggering a thread profile is done from the Thread profiler page in APM. Accessing Span-Specific information using the .NET Agent API New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the API. Adding Custom Span Attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ISpan. This new method accepts and supports all data-types. Further information may be found within .NET Agent API documentation. Adding custom attributes to spans requires distributed tracing and span events to be enabled. See .NET agent configuration Fixes Fixes issue where adding multiple custom attributes on a Transaction using ITransaction.AddCustomAttribute causes the agent to ignore additional attempts to add custom attributes to any transaction. Fixes issue that prevented Custom Events from being sent to New Relic until the agent shuts down. Fixes issue that can cause asynchronous Redis calls in an ASP.NET MVC application to report an inflated duration. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.91677,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "body": " the .<em>NET</em> <em>Agent</em> <em>API</em> New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the <em>API</em>. Adding Custom Span Attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been"
      },
      "id": "60445f8a196a673516960f8e"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8242440/",
      "sections": [
        ".NET agent v8.24.244.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.24.244.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "0df5ec86ce9abcad1d49457c32b2dec3873354b8",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Adding custom transaction attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type support; however, this method should be considered obsolete and will be removed in a future release of the agent API. Further information may be found within .NET Agent API documentation. Enhanced type support for RecordCustomEvent and NoticeError API methods. APIs for recording exceptions and custom events now support values of all types. The NoticeError API method has new overloads that accept an IDictionary<string, object>. The RecordCustomEvent methods have been modified to handle all types of data. In that past, they only handled string and float types. Further information may be found within .NET agent API documentation. New attributes on span events Spans created for external HTTP calls now include the http.statusCode attribute representing the status code of the call. Spans created for calls to a datastore now include the db.collection attribute. For instance, this will be the table name for a call to MS SQL Server. Ability to exclude attributes from span events Attributes on span events (e.g., http.url) can now be excluded via configuration. See .NET agent configuration for further information. Fixes New Relic distributed tracing relies on propagating trace and span identifiers in the headers of external calls (e.g., an HTTP call). These identifiers now only contain lowercase alphanumeric characters. Previous versions of the .NET agent used uppercase alphanumeric characters. The usage of uppercase alphanumeric characters can break traces when calling downstream services also monitored by a New Relic agent that supports W3C trace context (New Relic's .NET agent does not currently support W3C trace context. Support for W3C trace context for .NET will be in an upcoming release). This is only a problem if a .NET application is the originator of the trace. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.06879,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "body": "New Features Adding custom transaction attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type"
      },
      "id": "60445fcc28ccbc43b42c60c5"
    }
  ],
  "/docs/agents/net-agent/net-agent-api/set-user-parameters": [
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "68ae52e48b04bfe2279bcd038778cc5eebf53d1d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-06-02T17:53:04Z",
      "updated_at": "2021-05-15T18:25:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.94922,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "6043cd9528ccbcfe1e2c60aa"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8252140/",
      "sections": [
        ".NET agent v8.25.214.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.25.214.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "8d905601b21cbe7e6884c5f649ea9ecfb1e35737",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Thread profiling support for Linux Thread profiling on Linux will be supported on .NET Core 3.0 or later applications when running .NET agent version 8.23 or later. Triggering a thread profile is done from the Thread profiler page in APM. Accessing Span-Specific information using the .NET Agent API New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the API. Adding Custom Span Attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ISpan. This new method accepts and supports all data-types. Further information may be found within .NET Agent API documentation. Adding custom attributes to spans requires distributed tracing and span events to be enabled. See .NET agent configuration Fixes Fixes issue where adding multiple custom attributes on a Transaction using ITransaction.AddCustomAttribute causes the agent to ignore additional attempts to add custom attributes to any transaction. Fixes issue that prevented Custom Events from being sent to New Relic until the agent shuts down. Fixes issue that can cause asynchronous Redis calls in an ASP.NET MVC application to report an inflated duration. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.91677,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "body": " the .<em>NET</em> <em>Agent</em> <em>API</em> New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the <em>API</em>. Adding Custom Span Attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been"
      },
      "id": "60445f8a196a673516960f8e"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8242440/",
      "sections": [
        ".NET agent v8.24.244.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.24.244.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "0df5ec86ce9abcad1d49457c32b2dec3873354b8",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Adding custom transaction attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type support; however, this method should be considered obsolete and will be removed in a future release of the agent API. Further information may be found within .NET Agent API documentation. Enhanced type support for RecordCustomEvent and NoticeError API methods. APIs for recording exceptions and custom events now support values of all types. The NoticeError API method has new overloads that accept an IDictionary<string, object>. The RecordCustomEvent methods have been modified to handle all types of data. In that past, they only handled string and float types. Further information may be found within .NET agent API documentation. New attributes on span events Spans created for external HTTP calls now include the http.statusCode attribute representing the status code of the call. Spans created for calls to a datastore now include the db.collection attribute. For instance, this will be the table name for a call to MS SQL Server. Ability to exclude attributes from span events Attributes on span events (e.g., http.url) can now be excluded via configuration. See .NET agent configuration for further information. Fixes New Relic distributed tracing relies on propagating trace and span identifiers in the headers of external calls (e.g., an HTTP call). These identifiers now only contain lowercase alphanumeric characters. Previous versions of the .NET agent used uppercase alphanumeric characters. The usage of uppercase alphanumeric characters can break traces when calling downstream services also monitored by a New Relic agent that supports W3C trace context (New Relic's .NET agent does not currently support W3C trace context. Support for W3C trace context for .NET will be in an upcoming release). This is only a problem if a .NET application is the originator of the trace. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.06879,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "body": "New Features Adding custom transaction attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type"
      },
      "id": "60445fcc28ccbc43b42c60c5"
    }
  ],
  "/docs/agents/net-agent/net-agent-api/settransactionname-net-agent-api": [
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "68ae52e48b04bfe2279bcd038778cc5eebf53d1d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-06-02T17:53:04Z",
      "updated_at": "2021-05-15T18:25:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.9492,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "6043cd9528ccbcfe1e2c60aa"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8252140/",
      "sections": [
        ".NET agent v8.25.214.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.25.214.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "8d905601b21cbe7e6884c5f649ea9ecfb1e35737",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Thread profiling support for Linux Thread profiling on Linux will be supported on .NET Core 3.0 or later applications when running .NET agent version 8.23 or later. Triggering a thread profile is done from the Thread profiler page in APM. Accessing Span-Specific information using the .NET Agent API New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the API. Adding Custom Span Attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ISpan. This new method accepts and supports all data-types. Further information may be found within .NET Agent API documentation. Adding custom attributes to spans requires distributed tracing and span events to be enabled. See .NET agent configuration Fixes Fixes issue where adding multiple custom attributes on a Transaction using ITransaction.AddCustomAttribute causes the agent to ignore additional attempts to add custom attributes to any transaction. Fixes issue that prevented Custom Events from being sent to New Relic until the agent shuts down. Fixes issue that can cause asynchronous Redis calls in an ASP.NET MVC application to report an inflated duration. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.91677,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "body": " the .<em>NET</em> <em>Agent</em> <em>API</em> New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the <em>API</em>. Adding Custom Span Attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been"
      },
      "id": "60445f8a196a673516960f8e"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8242440/",
      "sections": [
        ".NET agent v8.24.244.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.24.244.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "0df5ec86ce9abcad1d49457c32b2dec3873354b8",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Adding custom transaction attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type support; however, this method should be considered obsolete and will be removed in a future release of the agent API. Further information may be found within .NET Agent API documentation. Enhanced type support for RecordCustomEvent and NoticeError API methods. APIs for recording exceptions and custom events now support values of all types. The NoticeError API method has new overloads that accept an IDictionary<string, object>. The RecordCustomEvent methods have been modified to handle all types of data. In that past, they only handled string and float types. Further information may be found within .NET agent API documentation. New attributes on span events Spans created for external HTTP calls now include the http.statusCode attribute representing the status code of the call. Spans created for calls to a datastore now include the db.collection attribute. For instance, this will be the table name for a call to MS SQL Server. Ability to exclude attributes from span events Attributes on span events (e.g., http.url) can now be excluded via configuration. See .NET agent configuration for further information. Fixes New Relic distributed tracing relies on propagating trace and span identifiers in the headers of external calls (e.g., an HTTP call). These identifiers now only contain lowercase alphanumeric characters. Previous versions of the .NET agent used uppercase alphanumeric characters. The usage of uppercase alphanumeric characters can break traces when calling downstream services also monitored by a New Relic agent that supports W3C trace context (New Relic's .NET agent does not currently support W3C trace context. Support for W3C trace context for .NET will be in an upcoming release). This is only a problem if a .NET application is the originator of the trace. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.06879,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "body": "New Features Adding custom transaction attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type"
      },
      "id": "60445fcc28ccbc43b42c60c5"
    }
  ],
  "/docs/agents/net-agent/net-agent-api/start-agent": [
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "68ae52e48b04bfe2279bcd038778cc5eebf53d1d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-06-02T17:53:04Z",
      "updated_at": "2021-05-15T18:25:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.9492,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "6043cd9528ccbcfe1e2c60aa"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8252140/",
      "sections": [
        ".NET agent v8.25.214.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.25.214.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "8d905601b21cbe7e6884c5f649ea9ecfb1e35737",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Thread profiling support for Linux Thread profiling on Linux will be supported on .NET Core 3.0 or later applications when running .NET agent version 8.23 or later. Triggering a thread profile is done from the Thread profiler page in APM. Accessing Span-Specific information using the .NET Agent API New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the API. Adding Custom Span Attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ISpan. This new method accepts and supports all data-types. Further information may be found within .NET Agent API documentation. Adding custom attributes to spans requires distributed tracing and span events to be enabled. See .NET agent configuration Fixes Fixes issue where adding multiple custom attributes on a Transaction using ITransaction.AddCustomAttribute causes the agent to ignore additional attempts to add custom attributes to any transaction. Fixes issue that prevented Custom Events from being sent to New Relic until the agent shuts down. Fixes issue that can cause asynchronous Redis calls in an ASP.NET MVC application to report an inflated duration. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.91677,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "body": " the .<em>NET</em> <em>Agent</em> <em>API</em> New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the <em>API</em>. Adding Custom Span Attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been"
      },
      "id": "60445f8a196a673516960f8e"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8242440/",
      "sections": [
        ".NET agent v8.24.244.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.24.244.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "0df5ec86ce9abcad1d49457c32b2dec3873354b8",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Adding custom transaction attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type support; however, this method should be considered obsolete and will be removed in a future release of the agent API. Further information may be found within .NET Agent API documentation. Enhanced type support for RecordCustomEvent and NoticeError API methods. APIs for recording exceptions and custom events now support values of all types. The NoticeError API method has new overloads that accept an IDictionary<string, object>. The RecordCustomEvent methods have been modified to handle all types of data. In that past, they only handled string and float types. Further information may be found within .NET agent API documentation. New attributes on span events Spans created for external HTTP calls now include the http.statusCode attribute representing the status code of the call. Spans created for calls to a datastore now include the db.collection attribute. For instance, this will be the table name for a call to MS SQL Server. Ability to exclude attributes from span events Attributes on span events (e.g., http.url) can now be excluded via configuration. See .NET agent configuration for further information. Fixes New Relic distributed tracing relies on propagating trace and span identifiers in the headers of external calls (e.g., an HTTP call). These identifiers now only contain lowercase alphanumeric characters. Previous versions of the .NET agent used uppercase alphanumeric characters. The usage of uppercase alphanumeric characters can break traces when calling downstream services also monitored by a New Relic agent that supports W3C trace context (New Relic's .NET agent does not currently support W3C trace context. Support for W3C trace context for .NET will be in an upcoming release). This is only a problem if a .NET application is the originator of the trace. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.06879,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "body": "New Features Adding custom transaction attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type"
      },
      "id": "60445fcc28ccbc43b42c60c5"
    }
  ],
  "/docs/agents/net-agent/net-agent-api/tracemetadata-net-agent-api-0": [
    {
      "sections": [
        "Custom instrumentation via attributes (.NET)",
        "Requirements and recommendations",
        "Transactions called within transactions",
        "Example: Calling Transaction in an already-started transaction",
        "Create a new non-web transaction",
        "Create a new web transaction",
        "Add detail to existing transactions with Trace",
        "Properties for [Transaction]",
        "Web",
        "Read forum posts about instrumentation",
        "Use other API functions"
      ],
      "title": "Custom instrumentation via attributes (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Custom instrumentation"
      ],
      "external_id": "68ae52e48b04bfe2279bcd038778cc5eebf53d1d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/custom-instrumentation/custom-instrumentation-attributes-net/",
      "published_at": "2021-06-02T17:53:04Z",
      "updated_at": "2021-05-15T18:25:50Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent provides several options for custom instrumentation. Custom instrumentation allows you to instrument parts of your app that are not instrumented automatically. This document describes how to instrument your app by decorating the methods in your app code with attributes. Use the Transaction attribute to create a custom transaction. You can also mark the custom transaction as a web transaction with the attribute's Web property. Use the Trace attribute to add custom instrumentation to methods that are invoked within a preexisting transaction. Requirements and recommendations Requirements include: .NET agent version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.Api.Agent.dll (for example, installing the package and placing using NewRelic.Api.Agent; in your code). This package is in the NuGet gallery. The Transaction and Trace attributes must be applied to concrete implementations of methods. They cannot be applied on interfaces or super class method definitions. Transactions called within transactions Methods decorated with the [Transaction] attribute will only create a new transaction when one does not already exist. When a method decorated with [Transaction] is called from within a previously started transaction, it will be treated as the [Trace] attribute instead, and will provide more information about the existing transaction. Example: Calling Transaction in an already-started transaction During the execution of this console application, OuterMethod will be called first and create a new transaction. The InnerMethod is called from within the transaction started by OuterMethod, so it will not create a new transaction. Instead, information about the execution of InnerMethod will be tracked as if the [Trace] attribute had been applied. static void Main(string[] args) { OuterMethod(); } [Transaction] public void OuterMethod() { InnerMethod(); } [Transaction] public void InnerMethod() { } Copy Create a new non-web transaction To start a non-web transaction (also known as a background request) with the Transaction attribute: [Transaction] public void Run() { // your background task } Copy For details about why to use either web or non-web, see Classify as web or non-web. Create a new web transaction To tell the agent to mark a non-web task as a web browser transaction, use either of these options: Set the Web property of the Transaction attribute to true. Set the transaction's URI with SetTransactionUri(). [Transaction(Web = true)] public void Run() { var uri = new Uri(\"http://www.mydomain.com/path\"); NewRelic.Api.Agent.NewRelic.SetTransactionUri(uri); // your web task } Copy When used inside a previously started transaction, this will be treated as a [Trace] attribute. For details about why to use either web or non-web, see Classify as web or non-web. Add detail to existing transactions with Trace If your transaction traces show large blocks of un-instrumented time and you want to include additional methods within the trace, you can use the Trace attribute: [Trace] protected void MethodWithinTransaction() { // your app code } Copy Properties for [ Transaction] The Transaction attribute supports the following properties: Web Type: Boolean Default: false If true, the agent starts a web transaction when it reaches this Transaction attribute. If a transaction is in progress, then that transaction will continue. If false (default), the agent starts a non-web transaction when it reaches this Transaction attribute. For example: [Transaction(Web = true)] Copy Read forum posts about instrumentation For more specific recommendations, check out these posts in our Explorers Hub community: Troubleshoot attribute-based custom instrumentation issues Build custom instrumentation tracer factories from .NET agent log files Use other API functions For more about the .NET agent API and its functionality, see New Relic's .NET agent API guide. For custom instrumentation without modifying your source code, see Create transactions via XML and Add detail to transactions via XML.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 110.94919,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Custom instrumentation via attributes (.<em>NET</em>)",
        "sections": "Custom instrumentation via attributes (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": " and recommendations Requirements include: .<em>NET</em> <em>agent</em> version 6.16.178.0 or higher. You must be willing to modify your source code. If you cannot or do not want to modify your source code, use custom instrumentation via XML. Your project must have a reference to NewRelic.<em>Api.Agent</em>.dll (for example, installing"
      },
      "id": "6043cd9528ccbcfe1e2c60aa"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8252140/",
      "sections": [
        ".NET agent v8.25.214.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.25.214.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "8d905601b21cbe7e6884c5f649ea9ecfb1e35737",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Thread profiling support for Linux Thread profiling on Linux will be supported on .NET Core 3.0 or later applications when running .NET agent version 8.23 or later. Triggering a thread profile is done from the Thread profiler page in APM. Accessing Span-Specific information using the .NET Agent API New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the API. Adding Custom Span Attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ISpan. This new method accepts and supports all data-types. Further information may be found within .NET Agent API documentation. Adding custom attributes to spans requires distributed tracing and span events to be enabled. See .NET agent configuration Fixes Fixes issue where adding multiple custom attributes on a Transaction using ITransaction.AddCustomAttribute causes the agent to ignore additional attempts to add custom attributes to any transaction. Fixes issue that prevented Custom Events from being sent to New Relic until the agent shuts down. Fixes issue that can cause asynchronous Redis calls in an ASP.NET MVC application to report an inflated duration. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 106.91677,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.25.214.0",
        "body": " the .<em>NET</em> <em>Agent</em> <em>API</em> New property, CurrentSpan has been added to IAgent and ITransaction. It returns an object implementing ISpan which provides access to span-specific functions within the <em>API</em>. Adding Custom Span Attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been"
      },
      "id": "60445f8a196a673516960f8e"
    },
    {
      "image": "",
      "url": "https://docs.newrelic.com/docs/release-notes/agent-release-notes/net-release-notes/net-agent-8242440/",
      "sections": [
        ".NET agent v8.24.244.0",
        "New Features",
        "Fixes",
        "Upgrading"
      ],
      "published_at": "2021-05-27T16:42:49Z",
      "title": ".NET agent v8.24.244.0",
      "updated_at": "2021-03-11T04:24:19Z",
      "type": "docs",
      "external_id": "0df5ec86ce9abcad1d49457c32b2dec3873354b8",
      "document_type": "release_notes",
      "popularity": 1,
      "body": "New Features Adding custom transaction attributes using the .NET Agent API New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type support; however, this method should be considered obsolete and will be removed in a future release of the agent API. Further information may be found within .NET Agent API documentation. Enhanced type support for RecordCustomEvent and NoticeError API methods. APIs for recording exceptions and custom events now support values of all types. The NoticeError API method has new overloads that accept an IDictionary<string, object>. The RecordCustomEvent methods have been modified to handle all types of data. In that past, they only handled string and float types. Further information may be found within .NET agent API documentation. New attributes on span events Spans created for external HTTP calls now include the http.statusCode attribute representing the status code of the call. Spans created for calls to a datastore now include the db.collection attribute. For instance, this will be the table name for a call to MS SQL Server. Ability to exclude attributes from span events Attributes on span events (e.g., http.url) can now be excluded via configuration. See .NET agent configuration for further information. Fixes New Relic distributed tracing relies on propagating trace and span identifiers in the headers of external calls (e.g., an HTTP call). These identifiers now only contain lowercase alphanumeric characters. Previous versions of the .NET agent used uppercase alphanumeric characters. The usage of uppercase alphanumeric characters can break traces when calling downstream services also monitored by a New Relic agent that supports W3C trace context (New Relic's .NET agent does not currently support W3C trace context. Support for W3C trace context for .NET will be in an upcoming release). This is only a problem if a .NET application is the originator of the trace. Upgrading Follow standard procedures to update the .NET agent. If you are upgrading from a particularly old agent, review the list of major changes and procedures to upgrade legacy .NET agents.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 104.06879,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "sections": ".<em>NET</em> <em>agent</em> v8.24.244.0",
        "body": "New Features Adding custom transaction attributes using the .<em>NET</em> <em>Agent</em> <em>API</em> New method, AddCustomAttribute(string, object) has been added to ITransaction. This new method accepts and supports all data types. Method AddCustomParameter(string, IConvertable) is still available with limited data-type"
      },
      "id": "60445fcc28ccbc43b42c60c5"
    }
  ],
  "/docs/agents/net-agent/other-features/async-support-net": [
    {
      "sections": [
        "Browser monitoring and the .NET agent",
        "Auto-instrumentation",
        "Important",
        "Manual instrumentation via agent API",
        ".NET Web Forms view engine",
        "Other view engines such as Razor",
        ".NET MVC",
        "Disable instrumentation",
        "Disable auto-instrumentation",
        "Disable auto-instrumentation on a particular view",
        "Disable both automatic and manual instrumentation on a particular view",
        "Troubleshooting"
      ],
      "title": "Browser monitoring and the .NET agent",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "746e8fe73518ac456d3dea8c3524822766fe5e74",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/other-features/browser-monitoring-net-agent/",
      "published_at": "2021-06-02T16:51:10Z",
      "updated_at": "2021-03-13T02:40:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the .NET agent, you can add Browser monitoring instrumentation to your webpages. Before you use Browser with your .NET agent, refer to the .NET agent release notes, and make sure you have the installed the latest .NET agent release. Follow the .NET agent requirements to install Browser monitoring. Then follow the procedures in this document to manually instrument the .NET agent. Auto-instrumentation Important This feature is not available for asp.net core applications whether they are monitored by the .NET Framework or Core agent. Browser auto-instrumentation is enabled by default. With Browser auto-instrumentation, the .NET Framework agent automatically injects the Browser JavaScript header into any page that has a content-type of text/html and also has <head> tag within the page. The <head> tag search starts at the beginning of the DOM. The .NET agent injects the JavaScript header through the addition of an HttpModule that modifies the page using HTTP response filters before streaming the content to the user. The first time you enable auto-instrumentation, you may need to clean your asp.net cache directory so that aspx pages are recompiled. Use the following command: flush_dotnet_temp.cmd Copy With this injection, previously functioning pages may stop working if a content-type is not set correctly. To correct, review and update the content-types in your app or disable auto-instrumentation. Manual instrumentation via agent API If you cannot enable auto-instrumentation, you can still include the Browser agent manually by using the New Relic .NET agent API and including appropriate code in your pages. To download the NewRelic.Api.agent.dll, re-run the installation and reference the .dll: From the New Relic .NET agent directory, select the New Relic.Net agent section, then select API Assembly. NuGet: Install and reference the .dll by running Install-package NewRelic.Agent.Api. To set up your web application to call the New Relic .NET agent API, add a reference to NewRelic.Api.Agent.dll to your project. Optional: If you are modifying the deployed application directory on the web server, copy NewRelic.Api.Agent.dll into the application's bin directory. Call the API in your <head> tag. If a meta-tag with the X-UA-COMPATIBLE http-equiv attribute exists, set it after that meta tag. .NET Web Forms view engine When using .NET Web Forms view engine, be sure to use = and not :. That way the view engine will recognize the string of HTML returned from the API as HTML / JavaScript and render it appropriately. If you are using .NET ASP Web Forms with master pages, add the header manually by calling GetBrowserTimingHeader() in your master page under the <head> tag: <%= NewRelic.Api.Agent.NewRelic.GetBrowserTimingHeader() %> Copy Import the namespace with: <%@ Import Namespace=\"NewRelic.Api.Agent\" %> Copy Other view engines such as Razor For other view engines such as Razor, you can use the GetBrowserTimingHeader() method to generate the header string. Here is a Razor-based view example: <!DOCTYPE html> <html lang=\"en\"> <head> @Html.Raw(NewRelic.Api.Agent.NewRelic.GetBrowserTimingHeader()) ... </head> </html> Copy .NET MVC When using .NET MVC, call the Html.Raw helper. That way, .NET MVC will recognize the string of HTML returned from the API as HTML / JavaScript and render it appropriately. Disable instrumentation To disable instrumentation: Disable auto-instrumentation To fully disable auto-instrumentation, edit newrelic.config and set the autoInstrument flag to false: <!-- disable auto instrumentation --> <browserMonitoring autoInstrument=\"false\"/> Copy Important If you change the flag or uninstall the .NET agent, be sure to flush your cache again so that references to the agent are removed from compiled files. Disable auto-instrumentation on a particular view To disable only auto-instrumentation on a particular view, use the agent API call DisableBrowserMonitoring(). Add this call in any view where Browser scripts are not needed or wanted. Put this API call as close as possible to the top of the view where you want it disabled. Disable both automatic and manual instrumentation on a particular view To disable both auto-instrumentation and manual instrumentation for individual webpages, use the agent API call DisableBrowserMonitoring(true). Troubleshooting Follow the troubleshooting procedures if you are unable to view any Browser timing data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 122.4801,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Browser monitoring and the .<em>NET</em> <em>agent</em>",
        "sections": "Browser monitoring and the .<em>NET</em> <em>agent</em>",
        "tags": "<em>Other</em> <em>features</em>",
        "body": "With the .<em>NET</em> <em>agent</em>, you can add Browser monitoring instrumentation to your webpages. Before you use Browser with your .<em>NET</em> <em>agent</em>, refer to the .<em>NET</em> <em>agent</em> release notes, and make sure you have the installed the latest .<em>NET</em> <em>agent</em> release. Follow the .<em>NET</em> <em>agent</em> requirements to install Browser"
      },
      "id": "6043d3b664441f6d66378ed5"
    },
    {
      "sections": [
        "Limit log disk space with log rolling"
      ],
      "title": "Limit log disk space with log rolling",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "35ad3dc2e183ec2658d288e185a63ed1c4b4521f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/other-features/limit-log-disk-space-log-rolling/",
      "published_at": "2021-06-02T16:51:09Z",
      "updated_at": "2021-03-16T14:58:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To balance the need for logs while considering disk usage, each .NET agent will limit disk usage to 250MB using log rolling. The agent will first log to the file newrelic_agent_UNIQUENAME.log and create the file if it doesn't exist. Once that file reaches 50MB in size, the agent will: Create a new log file. Roll each existing log file to a new, sequentially numbered name (up to four archived files). Delete the fourth archive. To roll the log files, the old newrelic_agent_UNIQUENAME.log becomes the new newrelic_agent_UNIQUENAME.log(1). Then, the old newrelic_agent_UNIQUENAME.log(1) becomes the new newrelic_agent_UNIQUENAME.log(2), and so on. The old newrelic_agent_UNIQUENAME.log(4) is deleted.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.35112,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Other</em> <em>features</em>",
        "body": "To balance the need for logs while considering disk usage, each .<em>NET</em> <em>agent</em> will limit disk usage to 250MB using log rolling. The <em>agent</em> will first log to the file newrelic_<em>agent</em>_UNIQUENAME.log and create the file if it doesn&#x27;t exist. Once that file reaches 50MB in size, the <em>agent</em> will: Create a new"
      },
      "id": "603ea2f628ccbc9822eba77b"
    },
    {
      "sections": [
        ".Net Performance Metrics",
        "CPU Metrics",
        "Memory Metrics",
        "Garbage Collection Metrics",
        "Tip",
        "Important",
        "Overall Metrics",
        "Generation - 0 Heap",
        "Generation - 1 Heap",
        "Generation - 2 Heap",
        "Large Object Heap (LOH)",
        "Managed Thread Pool Metrics",
        "Worker Threads",
        "Completion Threads",
        "Throughput"
      ],
      "title": ".Net Performance Metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "e5f9bd93b19834319b08c0b64afb53fb1cdba0dc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/other-features/net-performance-metrics/",
      "published_at": "2021-06-02T16:52:04Z",
      "updated_at": "2021-03-16T14:58:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .Net Agent collects metrics from the .Net runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool resource contention. The full suite of .Net Performance Metrics is available .Net Agent versions 8.20 and higher. To view these metrics, create a custom dashboard. CPU Metrics The following CPU Metrics are collected: CPU/User/Utilization The percentage of CPU that is consumed by this process. CPU/User Time The amount of time the process has spent executing application code. Memory Metrics The following Memory Metrics are collected: Memory/Physical The amount of private (physical) memory, in MB, allocated to the process. Memory/WorkingSet Amount of physical memory allocated to the process. Garbage Collection Metrics The .Net Garbage collector runs in the background and is responsible for identifying and reclaiming memory tied to objects that are no longer referenced by an application. The following metrics may be useful in identifying patterns of object allocation and potential over-allocation scenarios. This article further explains the fundamentals of garbage collection in .Net. Tip Garbage collection metrics are available for: All versions of the .Net Framework .Net Core 3.0 and above. Important For .Net Framework applications, the Windows User under which your application runs must have access to windows performance counter data. Usually this is accomplished by adding the user to \"Performance Monitor Users\" and \"Performance Log Users\" groups. Insufficient permissions will result in the agent not collecting garbage collection metrics. Overall Metrics Additionally, the following Garbage collection metrics are collected: GC/Handles The number of references to objects. GC/Induced Normally, the runtime performs garbage collection automatically. This metric identifies the number of times that Garbage Collection was manually invoked by an explicit call to GC.Collect from within application code. GC/PercentTimeInGC (.Net Framework only) The percentage of elapsed time that the .Net runtime has spent performing garbage collection since the last garbage collection cycle. Generation - 0 Heap The following GC Gen0 metrics are collected: GC/Gen0/Size The amount of memory (in MB) that is available to be allocated in Generation 0. This does not indicate the amount of memory that is being used by Generation 0, but the maximum available to be allocated. GC/Gen0/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen0 to Gen1. Memory survives garbage collection when there is an active reference to it. GC/Gen0/Collections The number of times Generation 0 Garbage Collection was executed by the garbage collector. Generation - 1 Heap The following GC Gen1 metrics are collected: GC/Gen1/Size The amount of memory (in MB) that is used in the Generation 1 heap. This differs from Gen0/Size which measure the maximum amount of memory available for the generation 0 heap. GC/Gen1/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen1 to Gen2. Memory survives garbage collection when there is an active reference to it. GC/Gen1/Collections The number of times Generation 1 Garbage Collection was executed by the garbage collector. Generation - 2 Heap The following GC Gen2 metrics are collected: GC/Gen2/Size The amount of memory (in MB) that is being used by the Gen2 Heap. GC/Gen2/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. GC/Gen2/Collections The number of times Generation 2 Garbage Collection was executed by the garbage collector. Large Object Heap (LOH) The following GC LOH metrics are collected: GC/LOH/Size The amount of memory (in MB) that is being used by the Large Object Heap (LOH). In .Net Core, the Large Object Heap is sometimes referred to as Gen3. GC/LOH/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. Managed Thread Pool Metrics The .Net runtime manages a pool of threads. The following metrics provide visibility into the performance of an application in terms of the thread pool and may help identify areas of thread pool starvation. Thread pool starvation/contention occurs when there are not enough threads available to process the requests made by an application. The following article describes the various features of the managed thread pool. Please note that these metrics do not include information about threads that are not managed by the thread pool. Worker Threads Worker threads are CPU-bound threads that are employed to perform work on behalf of a process. Threadpool/Worker/Available Identifies the number of managed threads available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Worker/InUse Identifies the number of worker threads that are currently in use by the process. Completion Threads Completion threads, sometimes referred to as I/O threads, are employed to monitor the completion of I/O operations. Threadpool/Completion/Available This metric identifies the number of threads that are currently available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Completion/InUse This metric identifies the number of completion threads currently in use by the process. Throughput Throughput metrics measure how much work has been requested to be performed on a different thread, the amount of work that has been started, and how much work is waiting for a thread pool resource to become available. Threadpool/Throughput/Requested Identifies the number of times that work has been requested to be run on a different thread pool managed thread. Threadpool/Throughput/Started Identifies the number of work items requested to be run on a separate thread that have started execution. Threadpool/Throughput/QueueLength Identifies the number of work items that have been requested, but are waiting to start. Numbers that consistently increase indicate a potential thread pool starvation situation. The following article describes how to modify the number of threads that are available to an application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.35112,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>Net</em> Performance Metrics",
        "sections": ".<em>Net</em> Performance Metrics",
        "tags": "<em>Other</em> <em>features</em>",
        "body": "New Relic&#x27;s .<em>Net</em> <em>Agent</em> collects metrics from the .<em>Net</em> runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool"
      },
      "id": "603eb36864441fdc6d4e88a2"
    }
  ],
  "/docs/agents/net-agent/other-features/browser-monitoring-net-agent": [
    {
      "sections": [
        "Async support in .NET",
        "Features supporting async instrumentation",
        "HttpClient async methods",
        "RestClient async methods",
        "SqlCommand async methods",
        "SqlDataReader async methods",
        "NpgsqlCommand async methods (Postgres)",
        "Custom instrumentation",
        "Known limitations",
        "Requires updated ASP pipeline",
        "Instrumented async methods must have return type of Task or Task<T>, not void",
        "No instrumentation for begin* and end* style",
        "No capture of scoped metrics/segments in manually created threads",
        "For instrumented async methods, use await, not Task.Result()",
        "ContinueWith({}) block may affect timing measurements",
        "Problem with nesting in IIS-hosted WCF apps",
        "Segments don't auto-create stack traces"
      ],
      "title": "Async support in .NET",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "8e1bd3f7d576bde032c478dbd4586e6c24c0fd85",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/other-features/async-support-net/",
      "published_at": "2021-06-02T16:51:10Z",
      "updated_at": "2021-03-13T02:40:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent automatically includes asynchronous framework instrumentation as of agent version 6.0. With the standard async-await pattern, introduced in .NET 4.5, calls to async methods can return even though the work being done in the called method is still in progress. The .NET agent observes this in-progress asynchronous work and waits for it to complete before recording timings. Features supporting async instrumentation With the addition of async support, new features are available in New Relic's .NET agent. However, as part of this enhancement, a small number of features previously provided by the agent currently are not available. Except as noted, the agent does not instrument async methods for any of the other supported frameworks for the .NET agent. HttpClient async methods The agent instruments these HttpClient async methods: SendAsync GetAsync PostAsync PutAsync DeleteAsync GetStringAsync GetStreamAsync GetByteArrayAsync RestClient async methods The agent instruments these RestClient async methods: ExecuteTaskAsync ExecuteGetTaskAsync ExecutePostTaskAsync SqlCommand async methods The agent instruments these SqlCommand async methods: ExecuteReaderAsync ExecuteNonQueryAsync ExecuteScalarAsync ExecuteXmlReaderAsync SqlDataReader async methods The agent instruments these SqlDataReader async methods: NextResultAsync ReadAsync NpgsqlCommand async methods (Postgres) The agent instruments these NpgsqlCommand async methods (Postgres): ExecuteReaderAsync ExecuteNonQueryAsync ExecuteScalarAsync Custom instrumentation The .NET agent supports custom instrumentation of your own async methods. Known limitations Here is a summary of known limitations for async instrumentation with New Relic's .NET agent. Requires updated ASP pipeline The .NET agent will not instrument async methods if the legacy ASP pipeline is present. Since Microsoft replaced the legacy ASP pipeline well before async methods were introduced, this issue typically only affects applications created under .NET Framework 4.0 or lower, then migrated to .NET Framework 4.5 or higher. To see if this issue affects your application, and how to resolve it if it does, review the troubleshooting procedures. Instrumented async methods must have return type of Task or Task<T>, not void The .NET agent does not support instrumentation of async methods that have return type of anything other than Task or Task<T>. The agent does not support async void methods. For more information, refer to the Microsoft documentation about async return types: Task < TResult> return type Async void and generalized async return types No instrumentation for begin* and end* style The .NET agent does not instrument any .NET methods that use the begin* and end* style, except for WCF applications. Outside of this exception, if your application calls these types of methods, the agent will not create segments for them. However, the rest of your transactions and segments will be created correctly. No capture of scoped metrics/segments in manually created threads The .NET agent does not capture scoped metrics or segments within threads that are manually created by your application. For instrumented async methods, use await, not Task.Result() If your application calls instrumented async methods, use await rather than Task related methods like Task.Result() to wait for the results. Otherwise, instrumentation may not work properly. In general, avoid using Task.Result() when calling async methods. It can lead to deadlocks. ContinueWith({}) block may affect timing measurements If you add your own ContinueWith({}) block to the promise returned by an instrumented async method, it may affect timing measurements reported by the instrumentation. For example, the time may include the time your ContinueWith takes to execute. Problem with nesting in IIS-hosted WCF apps IIS-hosted WCF services do not properly nest the WCF segment under the ExecuteRequestHandler segment. The two segments will appear to be siblings within a transaction trace, even though their reported total time will be accurate. Segments don't auto-create stack traces Segments in a transaction trace will not generate stack traces automatically, even if they run longer than transaction_tracer.stack_trace_threshold.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.408066,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Async support in .<em>NET</em>",
        "sections": "<em>Features</em> supporting async instrumentation",
        "tags": "<em>Other</em> <em>features</em>",
        "body": " observes this in-progress asynchronous work and waits for it to complete before recording timings. <em>Features</em> supporting async instrumentation With the addition of async support, new <em>features</em> are available in New Relic&#x27;s .<em>NET</em> <em>agent</em>. However, as part of this enhancement, a small number of <em>features</em>"
      },
      "id": "6043d96b28ccbc24e92c6094"
    },
    {
      "sections": [
        "Limit log disk space with log rolling"
      ],
      "title": "Limit log disk space with log rolling",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "35ad3dc2e183ec2658d288e185a63ed1c4b4521f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/other-features/limit-log-disk-space-log-rolling/",
      "published_at": "2021-06-02T16:51:09Z",
      "updated_at": "2021-03-16T14:58:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To balance the need for logs while considering disk usage, each .NET agent will limit disk usage to 250MB using log rolling. The agent will first log to the file newrelic_agent_UNIQUENAME.log and create the file if it doesn't exist. Once that file reaches 50MB in size, the agent will: Create a new log file. Roll each existing log file to a new, sequentially numbered name (up to four archived files). Delete the fourth archive. To roll the log files, the old newrelic_agent_UNIQUENAME.log becomes the new newrelic_agent_UNIQUENAME.log(1). Then, the old newrelic_agent_UNIQUENAME.log(1) becomes the new newrelic_agent_UNIQUENAME.log(2), and so on. The old newrelic_agent_UNIQUENAME.log(4) is deleted.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.35111,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Other</em> <em>features</em>",
        "body": "To balance the need for logs while considering disk usage, each .<em>NET</em> <em>agent</em> will limit disk usage to 250MB using log rolling. The <em>agent</em> will first log to the file newrelic_<em>agent</em>_UNIQUENAME.log and create the file if it doesn&#x27;t exist. Once that file reaches 50MB in size, the <em>agent</em> will: Create a new"
      },
      "id": "603ea2f628ccbc9822eba77b"
    },
    {
      "sections": [
        ".Net Performance Metrics",
        "CPU Metrics",
        "Memory Metrics",
        "Garbage Collection Metrics",
        "Tip",
        "Important",
        "Overall Metrics",
        "Generation - 0 Heap",
        "Generation - 1 Heap",
        "Generation - 2 Heap",
        "Large Object Heap (LOH)",
        "Managed Thread Pool Metrics",
        "Worker Threads",
        "Completion Threads",
        "Throughput"
      ],
      "title": ".Net Performance Metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "e5f9bd93b19834319b08c0b64afb53fb1cdba0dc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/other-features/net-performance-metrics/",
      "published_at": "2021-06-02T16:52:04Z",
      "updated_at": "2021-03-16T14:58:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .Net Agent collects metrics from the .Net runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool resource contention. The full suite of .Net Performance Metrics is available .Net Agent versions 8.20 and higher. To view these metrics, create a custom dashboard. CPU Metrics The following CPU Metrics are collected: CPU/User/Utilization The percentage of CPU that is consumed by this process. CPU/User Time The amount of time the process has spent executing application code. Memory Metrics The following Memory Metrics are collected: Memory/Physical The amount of private (physical) memory, in MB, allocated to the process. Memory/WorkingSet Amount of physical memory allocated to the process. Garbage Collection Metrics The .Net Garbage collector runs in the background and is responsible for identifying and reclaiming memory tied to objects that are no longer referenced by an application. The following metrics may be useful in identifying patterns of object allocation and potential over-allocation scenarios. This article further explains the fundamentals of garbage collection in .Net. Tip Garbage collection metrics are available for: All versions of the .Net Framework .Net Core 3.0 and above. Important For .Net Framework applications, the Windows User under which your application runs must have access to windows performance counter data. Usually this is accomplished by adding the user to \"Performance Monitor Users\" and \"Performance Log Users\" groups. Insufficient permissions will result in the agent not collecting garbage collection metrics. Overall Metrics Additionally, the following Garbage collection metrics are collected: GC/Handles The number of references to objects. GC/Induced Normally, the runtime performs garbage collection automatically. This metric identifies the number of times that Garbage Collection was manually invoked by an explicit call to GC.Collect from within application code. GC/PercentTimeInGC (.Net Framework only) The percentage of elapsed time that the .Net runtime has spent performing garbage collection since the last garbage collection cycle. Generation - 0 Heap The following GC Gen0 metrics are collected: GC/Gen0/Size The amount of memory (in MB) that is available to be allocated in Generation 0. This does not indicate the amount of memory that is being used by Generation 0, but the maximum available to be allocated. GC/Gen0/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen0 to Gen1. Memory survives garbage collection when there is an active reference to it. GC/Gen0/Collections The number of times Generation 0 Garbage Collection was executed by the garbage collector. Generation - 1 Heap The following GC Gen1 metrics are collected: GC/Gen1/Size The amount of memory (in MB) that is used in the Generation 1 heap. This differs from Gen0/Size which measure the maximum amount of memory available for the generation 0 heap. GC/Gen1/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen1 to Gen2. Memory survives garbage collection when there is an active reference to it. GC/Gen1/Collections The number of times Generation 1 Garbage Collection was executed by the garbage collector. Generation - 2 Heap The following GC Gen2 metrics are collected: GC/Gen2/Size The amount of memory (in MB) that is being used by the Gen2 Heap. GC/Gen2/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. GC/Gen2/Collections The number of times Generation 2 Garbage Collection was executed by the garbage collector. Large Object Heap (LOH) The following GC LOH metrics are collected: GC/LOH/Size The amount of memory (in MB) that is being used by the Large Object Heap (LOH). In .Net Core, the Large Object Heap is sometimes referred to as Gen3. GC/LOH/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. Managed Thread Pool Metrics The .Net runtime manages a pool of threads. The following metrics provide visibility into the performance of an application in terms of the thread pool and may help identify areas of thread pool starvation. Thread pool starvation/contention occurs when there are not enough threads available to process the requests made by an application. The following article describes the various features of the managed thread pool. Please note that these metrics do not include information about threads that are not managed by the thread pool. Worker Threads Worker threads are CPU-bound threads that are employed to perform work on behalf of a process. Threadpool/Worker/Available Identifies the number of managed threads available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Worker/InUse Identifies the number of worker threads that are currently in use by the process. Completion Threads Completion threads, sometimes referred to as I/O threads, are employed to monitor the completion of I/O operations. Threadpool/Completion/Available This metric identifies the number of threads that are currently available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Completion/InUse This metric identifies the number of completion threads currently in use by the process. Throughput Throughput metrics measure how much work has been requested to be performed on a different thread, the amount of work that has been started, and how much work is waiting for a thread pool resource to become available. Threadpool/Throughput/Requested Identifies the number of times that work has been requested to be run on a different thread pool managed thread. Threadpool/Throughput/Started Identifies the number of work items requested to be run on a separate thread that have started execution. Threadpool/Throughput/QueueLength Identifies the number of work items that have been requested, but are waiting to start. Numbers that consistently increase indicate a potential thread pool starvation situation. The following article describes how to modify the number of threads that are available to an application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.35111,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>Net</em> Performance Metrics",
        "sections": ".<em>Net</em> Performance Metrics",
        "tags": "<em>Other</em> <em>features</em>",
        "body": "New Relic&#x27;s .<em>Net</em> <em>Agent</em> collects metrics from the .<em>Net</em> runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool"
      },
      "id": "603eb36864441fdc6d4e88a2"
    }
  ],
  "/docs/agents/net-agent/other-features/limit-log-disk-space-log-rolling": [
    {
      "sections": [
        "Browser monitoring and the .NET agent",
        "Auto-instrumentation",
        "Important",
        "Manual instrumentation via agent API",
        ".NET Web Forms view engine",
        "Other view engines such as Razor",
        ".NET MVC",
        "Disable instrumentation",
        "Disable auto-instrumentation",
        "Disable auto-instrumentation on a particular view",
        "Disable both automatic and manual instrumentation on a particular view",
        "Troubleshooting"
      ],
      "title": "Browser monitoring and the .NET agent",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "746e8fe73518ac456d3dea8c3524822766fe5e74",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/other-features/browser-monitoring-net-agent/",
      "published_at": "2021-06-02T16:51:10Z",
      "updated_at": "2021-03-13T02:40:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the .NET agent, you can add Browser monitoring instrumentation to your webpages. Before you use Browser with your .NET agent, refer to the .NET agent release notes, and make sure you have the installed the latest .NET agent release. Follow the .NET agent requirements to install Browser monitoring. Then follow the procedures in this document to manually instrument the .NET agent. Auto-instrumentation Important This feature is not available for asp.net core applications whether they are monitored by the .NET Framework or Core agent. Browser auto-instrumentation is enabled by default. With Browser auto-instrumentation, the .NET Framework agent automatically injects the Browser JavaScript header into any page that has a content-type of text/html and also has <head> tag within the page. The <head> tag search starts at the beginning of the DOM. The .NET agent injects the JavaScript header through the addition of an HttpModule that modifies the page using HTTP response filters before streaming the content to the user. The first time you enable auto-instrumentation, you may need to clean your asp.net cache directory so that aspx pages are recompiled. Use the following command: flush_dotnet_temp.cmd Copy With this injection, previously functioning pages may stop working if a content-type is not set correctly. To correct, review and update the content-types in your app or disable auto-instrumentation. Manual instrumentation via agent API If you cannot enable auto-instrumentation, you can still include the Browser agent manually by using the New Relic .NET agent API and including appropriate code in your pages. To download the NewRelic.Api.agent.dll, re-run the installation and reference the .dll: From the New Relic .NET agent directory, select the New Relic.Net agent section, then select API Assembly. NuGet: Install and reference the .dll by running Install-package NewRelic.Agent.Api. To set up your web application to call the New Relic .NET agent API, add a reference to NewRelic.Api.Agent.dll to your project. Optional: If you are modifying the deployed application directory on the web server, copy NewRelic.Api.Agent.dll into the application's bin directory. Call the API in your <head> tag. If a meta-tag with the X-UA-COMPATIBLE http-equiv attribute exists, set it after that meta tag. .NET Web Forms view engine When using .NET Web Forms view engine, be sure to use = and not :. That way the view engine will recognize the string of HTML returned from the API as HTML / JavaScript and render it appropriately. If you are using .NET ASP Web Forms with master pages, add the header manually by calling GetBrowserTimingHeader() in your master page under the <head> tag: <%= NewRelic.Api.Agent.NewRelic.GetBrowserTimingHeader() %> Copy Import the namespace with: <%@ Import Namespace=\"NewRelic.Api.Agent\" %> Copy Other view engines such as Razor For other view engines such as Razor, you can use the GetBrowserTimingHeader() method to generate the header string. Here is a Razor-based view example: <!DOCTYPE html> <html lang=\"en\"> <head> @Html.Raw(NewRelic.Api.Agent.NewRelic.GetBrowserTimingHeader()) ... </head> </html> Copy .NET MVC When using .NET MVC, call the Html.Raw helper. That way, .NET MVC will recognize the string of HTML returned from the API as HTML / JavaScript and render it appropriately. Disable instrumentation To disable instrumentation: Disable auto-instrumentation To fully disable auto-instrumentation, edit newrelic.config and set the autoInstrument flag to false: <!-- disable auto instrumentation --> <browserMonitoring autoInstrument=\"false\"/> Copy Important If you change the flag or uninstall the .NET agent, be sure to flush your cache again so that references to the agent are removed from compiled files. Disable auto-instrumentation on a particular view To disable only auto-instrumentation on a particular view, use the agent API call DisableBrowserMonitoring(). Add this call in any view where Browser scripts are not needed or wanted. Put this API call as close as possible to the top of the view where you want it disabled. Disable both automatic and manual instrumentation on a particular view To disable both auto-instrumentation and manual instrumentation for individual webpages, use the agent API call DisableBrowserMonitoring(true). Troubleshooting Follow the troubleshooting procedures if you are unable to view any Browser timing data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 122.480095,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Browser monitoring and the .<em>NET</em> <em>agent</em>",
        "sections": "Browser monitoring and the .<em>NET</em> <em>agent</em>",
        "tags": "<em>Other</em> <em>features</em>",
        "body": "With the .<em>NET</em> <em>agent</em>, you can add Browser monitoring instrumentation to your webpages. Before you use Browser with your .<em>NET</em> <em>agent</em>, refer to the .<em>NET</em> <em>agent</em> release notes, and make sure you have the installed the latest .<em>NET</em> <em>agent</em> release. Follow the .<em>NET</em> <em>agent</em> requirements to install Browser"
      },
      "id": "6043d3b664441f6d66378ed5"
    },
    {
      "sections": [
        "Async support in .NET",
        "Features supporting async instrumentation",
        "HttpClient async methods",
        "RestClient async methods",
        "SqlCommand async methods",
        "SqlDataReader async methods",
        "NpgsqlCommand async methods (Postgres)",
        "Custom instrumentation",
        "Known limitations",
        "Requires updated ASP pipeline",
        "Instrumented async methods must have return type of Task or Task<T>, not void",
        "No instrumentation for begin* and end* style",
        "No capture of scoped metrics/segments in manually created threads",
        "For instrumented async methods, use await, not Task.Result()",
        "ContinueWith({}) block may affect timing measurements",
        "Problem with nesting in IIS-hosted WCF apps",
        "Segments don't auto-create stack traces"
      ],
      "title": "Async support in .NET",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "8e1bd3f7d576bde032c478dbd4586e6c24c0fd85",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/other-features/async-support-net/",
      "published_at": "2021-06-02T16:51:10Z",
      "updated_at": "2021-03-13T02:40:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent automatically includes asynchronous framework instrumentation as of agent version 6.0. With the standard async-await pattern, introduced in .NET 4.5, calls to async methods can return even though the work being done in the called method is still in progress. The .NET agent observes this in-progress asynchronous work and waits for it to complete before recording timings. Features supporting async instrumentation With the addition of async support, new features are available in New Relic's .NET agent. However, as part of this enhancement, a small number of features previously provided by the agent currently are not available. Except as noted, the agent does not instrument async methods for any of the other supported frameworks for the .NET agent. HttpClient async methods The agent instruments these HttpClient async methods: SendAsync GetAsync PostAsync PutAsync DeleteAsync GetStringAsync GetStreamAsync GetByteArrayAsync RestClient async methods The agent instruments these RestClient async methods: ExecuteTaskAsync ExecuteGetTaskAsync ExecutePostTaskAsync SqlCommand async methods The agent instruments these SqlCommand async methods: ExecuteReaderAsync ExecuteNonQueryAsync ExecuteScalarAsync ExecuteXmlReaderAsync SqlDataReader async methods The agent instruments these SqlDataReader async methods: NextResultAsync ReadAsync NpgsqlCommand async methods (Postgres) The agent instruments these NpgsqlCommand async methods (Postgres): ExecuteReaderAsync ExecuteNonQueryAsync ExecuteScalarAsync Custom instrumentation The .NET agent supports custom instrumentation of your own async methods. Known limitations Here is a summary of known limitations for async instrumentation with New Relic's .NET agent. Requires updated ASP pipeline The .NET agent will not instrument async methods if the legacy ASP pipeline is present. Since Microsoft replaced the legacy ASP pipeline well before async methods were introduced, this issue typically only affects applications created under .NET Framework 4.0 or lower, then migrated to .NET Framework 4.5 or higher. To see if this issue affects your application, and how to resolve it if it does, review the troubleshooting procedures. Instrumented async methods must have return type of Task or Task<T>, not void The .NET agent does not support instrumentation of async methods that have return type of anything other than Task or Task<T>. The agent does not support async void methods. For more information, refer to the Microsoft documentation about async return types: Task < TResult> return type Async void and generalized async return types No instrumentation for begin* and end* style The .NET agent does not instrument any .NET methods that use the begin* and end* style, except for WCF applications. Outside of this exception, if your application calls these types of methods, the agent will not create segments for them. However, the rest of your transactions and segments will be created correctly. No capture of scoped metrics/segments in manually created threads The .NET agent does not capture scoped metrics or segments within threads that are manually created by your application. For instrumented async methods, use await, not Task.Result() If your application calls instrumented async methods, use await rather than Task related methods like Task.Result() to wait for the results. Otherwise, instrumentation may not work properly. In general, avoid using Task.Result() when calling async methods. It can lead to deadlocks. ContinueWith({}) block may affect timing measurements If you add your own ContinueWith({}) block to the promise returned by an instrumented async method, it may affect timing measurements reported by the instrumentation. For example, the time may include the time your ContinueWith takes to execute. Problem with nesting in IIS-hosted WCF apps IIS-hosted WCF services do not properly nest the WCF segment under the ExecuteRequestHandler segment. The two segments will appear to be siblings within a transaction trace, even though their reported total time will be accurate. Segments don't auto-create stack traces Segments in a transaction trace will not generate stack traces automatically, even if they run longer than transaction_tracer.stack_trace_threshold.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.408066,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Async support in .<em>NET</em>",
        "sections": "<em>Features</em> supporting async instrumentation",
        "tags": "<em>Other</em> <em>features</em>",
        "body": " observes this in-progress asynchronous work and waits for it to complete before recording timings. <em>Features</em> supporting async instrumentation With the addition of async support, new <em>features</em> are available in New Relic&#x27;s .<em>NET</em> <em>agent</em>. However, as part of this enhancement, a small number of <em>features</em>"
      },
      "id": "6043d96b28ccbc24e92c6094"
    },
    {
      "sections": [
        ".Net Performance Metrics",
        "CPU Metrics",
        "Memory Metrics",
        "Garbage Collection Metrics",
        "Tip",
        "Important",
        "Overall Metrics",
        "Generation - 0 Heap",
        "Generation - 1 Heap",
        "Generation - 2 Heap",
        "Large Object Heap (LOH)",
        "Managed Thread Pool Metrics",
        "Worker Threads",
        "Completion Threads",
        "Throughput"
      ],
      "title": ".Net Performance Metrics",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "e5f9bd93b19834319b08c0b64afb53fb1cdba0dc",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/other-features/net-performance-metrics/",
      "published_at": "2021-06-02T16:52:04Z",
      "updated_at": "2021-03-16T14:58:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .Net Agent collects metrics from the .Net runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool resource contention. The full suite of .Net Performance Metrics is available .Net Agent versions 8.20 and higher. To view these metrics, create a custom dashboard. CPU Metrics The following CPU Metrics are collected: CPU/User/Utilization The percentage of CPU that is consumed by this process. CPU/User Time The amount of time the process has spent executing application code. Memory Metrics The following Memory Metrics are collected: Memory/Physical The amount of private (physical) memory, in MB, allocated to the process. Memory/WorkingSet Amount of physical memory allocated to the process. Garbage Collection Metrics The .Net Garbage collector runs in the background and is responsible for identifying and reclaiming memory tied to objects that are no longer referenced by an application. The following metrics may be useful in identifying patterns of object allocation and potential over-allocation scenarios. This article further explains the fundamentals of garbage collection in .Net. Tip Garbage collection metrics are available for: All versions of the .Net Framework .Net Core 3.0 and above. Important For .Net Framework applications, the Windows User under which your application runs must have access to windows performance counter data. Usually this is accomplished by adding the user to \"Performance Monitor Users\" and \"Performance Log Users\" groups. Insufficient permissions will result in the agent not collecting garbage collection metrics. Overall Metrics Additionally, the following Garbage collection metrics are collected: GC/Handles The number of references to objects. GC/Induced Normally, the runtime performs garbage collection automatically. This metric identifies the number of times that Garbage Collection was manually invoked by an explicit call to GC.Collect from within application code. GC/PercentTimeInGC (.Net Framework only) The percentage of elapsed time that the .Net runtime has spent performing garbage collection since the last garbage collection cycle. Generation - 0 Heap The following GC Gen0 metrics are collected: GC/Gen0/Size The amount of memory (in MB) that is available to be allocated in Generation 0. This does not indicate the amount of memory that is being used by Generation 0, but the maximum available to be allocated. GC/Gen0/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen0 to Gen1. Memory survives garbage collection when there is an active reference to it. GC/Gen0/Collections The number of times Generation 0 Garbage Collection was executed by the garbage collector. Generation - 1 Heap The following GC Gen1 metrics are collected: GC/Gen1/Size The amount of memory (in MB) that is used in the Generation 1 heap. This differs from Gen0/Size which measure the maximum amount of memory available for the generation 0 heap. GC/Gen1/Promoted The amount of memory (in MB) that has survived garbage collection and has been promoted from Gen1 to Gen2. Memory survives garbage collection when there is an active reference to it. GC/Gen1/Collections The number of times Generation 1 Garbage Collection was executed by the garbage collector. Generation - 2 Heap The following GC Gen2 metrics are collected: GC/Gen2/Size The amount of memory (in MB) that is being used by the Gen2 Heap. GC/Gen2/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. GC/Gen2/Collections The number of times Generation 2 Garbage Collection was executed by the garbage collector. Large Object Heap (LOH) The following GC LOH metrics are collected: GC/LOH/Size The amount of memory (in MB) that is being used by the Large Object Heap (LOH). In .Net Core, the Large Object Heap is sometimes referred to as Gen3. GC/LOH/Survived (.Net Core Only) The amount of memory (in MB) that has survived garbage collection. Memory survives garbage collection when there is an active reference to it. Unlike Gen0 and Gen1, memory that survives garbage collection is not promoted. Managed Thread Pool Metrics The .Net runtime manages a pool of threads. The following metrics provide visibility into the performance of an application in terms of the thread pool and may help identify areas of thread pool starvation. Thread pool starvation/contention occurs when there are not enough threads available to process the requests made by an application. The following article describes the various features of the managed thread pool. Please note that these metrics do not include information about threads that are not managed by the thread pool. Worker Threads Worker threads are CPU-bound threads that are employed to perform work on behalf of a process. Threadpool/Worker/Available Identifies the number of managed threads available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Worker/InUse Identifies the number of worker threads that are currently in use by the process. Completion Threads Completion threads, sometimes referred to as I/O threads, are employed to monitor the completion of I/O operations. Threadpool/Completion/Available This metric identifies the number of threads that are currently available to the process. Consistently low numbers indicate a potential starvation scenario. Threadpool/Completion/InUse This metric identifies the number of completion threads currently in use by the process. Throughput Throughput metrics measure how much work has been requested to be performed on a different thread, the amount of work that has been started, and how much work is waiting for a thread pool resource to become available. Threadpool/Throughput/Requested Identifies the number of times that work has been requested to be run on a different thread pool managed thread. Threadpool/Throughput/Started Identifies the number of work items requested to be run on a separate thread that have started execution. Threadpool/Throughput/QueueLength Identifies the number of work items that have been requested, but are waiting to start. Numbers that consistently increase indicate a potential thread pool starvation situation. The following article describes how to modify the number of threads that are available to an application.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.35111,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>Net</em> Performance Metrics",
        "sections": ".<em>Net</em> Performance Metrics",
        "tags": "<em>Other</em> <em>features</em>",
        "body": "New Relic&#x27;s .<em>Net</em> <em>Agent</em> collects metrics from the .<em>Net</em> runtime about the performance of your application. These metrics can provide insight into how much CPU and memory an application consumes as well as how the performance of an application may be impacted by garbage collection and thread pool"
      },
      "id": "603eb36864441fdc6d4e88a2"
    }
  ],
  "/docs/agents/net-agent/other-features/net-performance-metrics": [
    {
      "sections": [
        "Browser monitoring and the .NET agent",
        "Auto-instrumentation",
        "Important",
        "Manual instrumentation via agent API",
        ".NET Web Forms view engine",
        "Other view engines such as Razor",
        ".NET MVC",
        "Disable instrumentation",
        "Disable auto-instrumentation",
        "Disable auto-instrumentation on a particular view",
        "Disable both automatic and manual instrumentation on a particular view",
        "Troubleshooting"
      ],
      "title": "Browser monitoring and the .NET agent",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "746e8fe73518ac456d3dea8c3524822766fe5e74",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/other-features/browser-monitoring-net-agent/",
      "published_at": "2021-06-02T16:51:10Z",
      "updated_at": "2021-03-13T02:40:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the .NET agent, you can add Browser monitoring instrumentation to your webpages. Before you use Browser with your .NET agent, refer to the .NET agent release notes, and make sure you have the installed the latest .NET agent release. Follow the .NET agent requirements to install Browser monitoring. Then follow the procedures in this document to manually instrument the .NET agent. Auto-instrumentation Important This feature is not available for asp.net core applications whether they are monitored by the .NET Framework or Core agent. Browser auto-instrumentation is enabled by default. With Browser auto-instrumentation, the .NET Framework agent automatically injects the Browser JavaScript header into any page that has a content-type of text/html and also has <head> tag within the page. The <head> tag search starts at the beginning of the DOM. The .NET agent injects the JavaScript header through the addition of an HttpModule that modifies the page using HTTP response filters before streaming the content to the user. The first time you enable auto-instrumentation, you may need to clean your asp.net cache directory so that aspx pages are recompiled. Use the following command: flush_dotnet_temp.cmd Copy With this injection, previously functioning pages may stop working if a content-type is not set correctly. To correct, review and update the content-types in your app or disable auto-instrumentation. Manual instrumentation via agent API If you cannot enable auto-instrumentation, you can still include the Browser agent manually by using the New Relic .NET agent API and including appropriate code in your pages. To download the NewRelic.Api.agent.dll, re-run the installation and reference the .dll: From the New Relic .NET agent directory, select the New Relic.Net agent section, then select API Assembly. NuGet: Install and reference the .dll by running Install-package NewRelic.Agent.Api. To set up your web application to call the New Relic .NET agent API, add a reference to NewRelic.Api.Agent.dll to your project. Optional: If you are modifying the deployed application directory on the web server, copy NewRelic.Api.Agent.dll into the application's bin directory. Call the API in your <head> tag. If a meta-tag with the X-UA-COMPATIBLE http-equiv attribute exists, set it after that meta tag. .NET Web Forms view engine When using .NET Web Forms view engine, be sure to use = and not :. That way the view engine will recognize the string of HTML returned from the API as HTML / JavaScript and render it appropriately. If you are using .NET ASP Web Forms with master pages, add the header manually by calling GetBrowserTimingHeader() in your master page under the <head> tag: <%= NewRelic.Api.Agent.NewRelic.GetBrowserTimingHeader() %> Copy Import the namespace with: <%@ Import Namespace=\"NewRelic.Api.Agent\" %> Copy Other view engines such as Razor For other view engines such as Razor, you can use the GetBrowserTimingHeader() method to generate the header string. Here is a Razor-based view example: <!DOCTYPE html> <html lang=\"en\"> <head> @Html.Raw(NewRelic.Api.Agent.NewRelic.GetBrowserTimingHeader()) ... </head> </html> Copy .NET MVC When using .NET MVC, call the Html.Raw helper. That way, .NET MVC will recognize the string of HTML returned from the API as HTML / JavaScript and render it appropriately. Disable instrumentation To disable instrumentation: Disable auto-instrumentation To fully disable auto-instrumentation, edit newrelic.config and set the autoInstrument flag to false: <!-- disable auto instrumentation --> <browserMonitoring autoInstrument=\"false\"/> Copy Important If you change the flag or uninstall the .NET agent, be sure to flush your cache again so that references to the agent are removed from compiled files. Disable auto-instrumentation on a particular view To disable only auto-instrumentation on a particular view, use the agent API call DisableBrowserMonitoring(). Add this call in any view where Browser scripts are not needed or wanted. Put this API call as close as possible to the top of the view where you want it disabled. Disable both automatic and manual instrumentation on a particular view To disable both auto-instrumentation and manual instrumentation for individual webpages, use the agent API call DisableBrowserMonitoring(true). Troubleshooting Follow the troubleshooting procedures if you are unable to view any Browser timing data.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 122.480095,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Browser monitoring and the .<em>NET</em> <em>agent</em>",
        "sections": "Browser monitoring and the .<em>NET</em> <em>agent</em>",
        "tags": "<em>Other</em> <em>features</em>",
        "body": "With the .<em>NET</em> <em>agent</em>, you can add Browser monitoring instrumentation to your webpages. Before you use Browser with your .<em>NET</em> <em>agent</em>, refer to the .<em>NET</em> <em>agent</em> release notes, and make sure you have the installed the latest .<em>NET</em> <em>agent</em> release. Follow the .<em>NET</em> <em>agent</em> requirements to install Browser"
      },
      "id": "6043d3b664441f6d66378ed5"
    },
    {
      "sections": [
        "Async support in .NET",
        "Features supporting async instrumentation",
        "HttpClient async methods",
        "RestClient async methods",
        "SqlCommand async methods",
        "SqlDataReader async methods",
        "NpgsqlCommand async methods (Postgres)",
        "Custom instrumentation",
        "Known limitations",
        "Requires updated ASP pipeline",
        "Instrumented async methods must have return type of Task or Task<T>, not void",
        "No instrumentation for begin* and end* style",
        "No capture of scoped metrics/segments in manually created threads",
        "For instrumented async methods, use await, not Task.Result()",
        "ContinueWith({}) block may affect timing measurements",
        "Problem with nesting in IIS-hosted WCF apps",
        "Segments don't auto-create stack traces"
      ],
      "title": "Async support in .NET",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "8e1bd3f7d576bde032c478dbd4586e6c24c0fd85",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/other-features/async-support-net/",
      "published_at": "2021-06-02T16:51:10Z",
      "updated_at": "2021-03-13T02:40:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent automatically includes asynchronous framework instrumentation as of agent version 6.0. With the standard async-await pattern, introduced in .NET 4.5, calls to async methods can return even though the work being done in the called method is still in progress. The .NET agent observes this in-progress asynchronous work and waits for it to complete before recording timings. Features supporting async instrumentation With the addition of async support, new features are available in New Relic's .NET agent. However, as part of this enhancement, a small number of features previously provided by the agent currently are not available. Except as noted, the agent does not instrument async methods for any of the other supported frameworks for the .NET agent. HttpClient async methods The agent instruments these HttpClient async methods: SendAsync GetAsync PostAsync PutAsync DeleteAsync GetStringAsync GetStreamAsync GetByteArrayAsync RestClient async methods The agent instruments these RestClient async methods: ExecuteTaskAsync ExecuteGetTaskAsync ExecutePostTaskAsync SqlCommand async methods The agent instruments these SqlCommand async methods: ExecuteReaderAsync ExecuteNonQueryAsync ExecuteScalarAsync ExecuteXmlReaderAsync SqlDataReader async methods The agent instruments these SqlDataReader async methods: NextResultAsync ReadAsync NpgsqlCommand async methods (Postgres) The agent instruments these NpgsqlCommand async methods (Postgres): ExecuteReaderAsync ExecuteNonQueryAsync ExecuteScalarAsync Custom instrumentation The .NET agent supports custom instrumentation of your own async methods. Known limitations Here is a summary of known limitations for async instrumentation with New Relic's .NET agent. Requires updated ASP pipeline The .NET agent will not instrument async methods if the legacy ASP pipeline is present. Since Microsoft replaced the legacy ASP pipeline well before async methods were introduced, this issue typically only affects applications created under .NET Framework 4.0 or lower, then migrated to .NET Framework 4.5 or higher. To see if this issue affects your application, and how to resolve it if it does, review the troubleshooting procedures. Instrumented async methods must have return type of Task or Task<T>, not void The .NET agent does not support instrumentation of async methods that have return type of anything other than Task or Task<T>. The agent does not support async void methods. For more information, refer to the Microsoft documentation about async return types: Task < TResult> return type Async void and generalized async return types No instrumentation for begin* and end* style The .NET agent does not instrument any .NET methods that use the begin* and end* style, except for WCF applications. Outside of this exception, if your application calls these types of methods, the agent will not create segments for them. However, the rest of your transactions and segments will be created correctly. No capture of scoped metrics/segments in manually created threads The .NET agent does not capture scoped metrics or segments within threads that are manually created by your application. For instrumented async methods, use await, not Task.Result() If your application calls instrumented async methods, use await rather than Task related methods like Task.Result() to wait for the results. Otherwise, instrumentation may not work properly. In general, avoid using Task.Result() when calling async methods. It can lead to deadlocks. ContinueWith({}) block may affect timing measurements If you add your own ContinueWith({}) block to the promise returned by an instrumented async method, it may affect timing measurements reported by the instrumentation. For example, the time may include the time your ContinueWith takes to execute. Problem with nesting in IIS-hosted WCF apps IIS-hosted WCF services do not properly nest the WCF segment under the ExecuteRequestHandler segment. The two segments will appear to be siblings within a transaction trace, even though their reported total time will be accurate. Segments don't auto-create stack traces Segments in a transaction trace will not generate stack traces automatically, even if they run longer than transaction_tracer.stack_trace_threshold.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.408066,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Async support in .<em>NET</em>",
        "sections": "<em>Features</em> supporting async instrumentation",
        "tags": "<em>Other</em> <em>features</em>",
        "body": " observes this in-progress asynchronous work and waits for it to complete before recording timings. <em>Features</em> supporting async instrumentation With the addition of async support, new <em>features</em> are available in New Relic&#x27;s .<em>NET</em> <em>agent</em>. However, as part of this enhancement, a small number of <em>features</em>"
      },
      "id": "6043d96b28ccbc24e92c6094"
    },
    {
      "sections": [
        "Limit log disk space with log rolling"
      ],
      "title": "Limit log disk space with log rolling",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other features"
      ],
      "external_id": "35ad3dc2e183ec2658d288e185a63ed1c4b4521f",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/other-features/limit-log-disk-space-log-rolling/",
      "published_at": "2021-06-02T16:51:09Z",
      "updated_at": "2021-03-16T14:58:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "To balance the need for logs while considering disk usage, each .NET agent will limit disk usage to 250MB using log rolling. The agent will first log to the file newrelic_agent_UNIQUENAME.log and create the file if it doesn't exist. Once that file reaches 50MB in size, the agent will: Create a new log file. Roll each existing log file to a new, sequentially numbered name (up to four archived files). Delete the fourth archive. To roll the log files, the old newrelic_agent_UNIQUENAME.log becomes the new newrelic_agent_UNIQUENAME.log(1). Then, the old newrelic_agent_UNIQUENAME.log(1) becomes the new newrelic_agent_UNIQUENAME.log(2), and so on. The old newrelic_agent_UNIQUENAME.log(4) is deleted.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.35111,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Other</em> <em>features</em>",
        "body": "To balance the need for logs while considering disk usage, each .<em>NET</em> <em>agent</em> will limit disk usage to 250MB using log rolling. The <em>agent</em> will first log to the file newrelic_<em>agent</em>_UNIQUENAME.log and create the file if it doesn&#x27;t exist. Once that file reaches 50MB in size, the <em>agent</em> will: Create a new"
      },
      "id": "603ea2f628ccbc9822eba77b"
    }
  ],
  "/docs/agents/net-agent/other-installation/how-verify-checksum-net-agent-downloads": [
    {
      "sections": [
        "Install .NET agent for Windows Communication Foundation (WCF)",
        "Install for WCF applications",
        "Important",
        "ASP.NET pipeline events and WCF events",
        "Only WCF events"
      ],
      "title": "Install .NET agent for Windows Communication Foundation (WCF)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "c39d558ff81b712496798549087933ccabcc2586",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/other-installation/install-net-agent-windows-communication-foundation-wcf/",
      "published_at": "2021-06-02T16:16:56Z",
      "updated_at": "2021-03-16T04:35:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install the .NET agent and monitor WCF applications. Install for WCF applications To install the .NET agent on IIS-hosted WCF apps: Install the latest .NET agent. Important For self-hosted WCF applications (hosted as a custom Windows Service, a console app, or a Windows Forms app) take note of the instructions to enable the agent for your application. Ensure you give each WCF app a descriptive name. Enable or disable ASP.NET compatibility mode in your WCF application depending on which type of events you want monitored: ASP.NET pipeline events and WCF events When ASP.NET compatibility mode is enabled, the .NET agent instruments ASP.NET pipeline events as well as WCF events. In this mode, the agent provides you with a full view of your application stack. Only WCF events When ASP.NET compatibility mode is disabled, the .NET agent only instruments WCF events. Any activity that occurs as part of the ASP.NET pipeline will not be captured, such as agent API calls that are made outside of a WCF transaction. If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.885216,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .<em>NET</em> <em>agent</em> for Windows Communication Foundation (WCF)",
        "sections": "<em>Install</em> .<em>NET</em> <em>agent</em> for Windows Communication Foundation (WCF)",
        "tags": "<em>Other</em> <em>installation</em>",
        "body": "This document explains how to install the .<em>NET</em> <em>agent</em> and monitor WCF applications. Install for WCF applications To install the .<em>NET</em> <em>agent</em> on IIS-hosted WCF apps: Install the latest .<em>NET</em> <em>agent</em>. Important For self-hosted WCF applications (hosted as a custom Windows Service, a console app"
      },
      "id": "603ea62e196a679eb4a83d8d"
    },
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Tip",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "d0515c81825c0b108418459b6c14a510b540c206",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-06-02T16:16:54Z",
      "updated_at": "2021-03-16T14:59:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Tip To use .NET or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile FROM microsoft/dotnet:2.2-aspnetcore-runtime # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile FROM microsoft/dotnet:2.2-sdk AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet build -c Release -o /app/ ./YOUR_APP_NAME FROM microsoft/dotnet:2.2-aspnetcore-runtime AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM microsoft/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Copy the New Relic .NET agent installer COPY ./NewRelicDotNetAgent_x64.msi / # Install the agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i,\\ \"C:\\NewRelicDotNetAgent_x64.msi\",\\ /qn,NR_LICENSE_KEY=YOUR_LICENSE_KEY # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Copy the New Relic .NET agent installer COPY ./NewRelicDotNetAgent_x64.msi / # Install the agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"C:\\NewRelicDotNetAgent_x64.msi\", /qn, NR_LICENSE_KEY=YOUR_LICENSE_KEY # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windowsservercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.38908,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "<em>Install</em> .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>Other</em> <em>installation</em>",
        "body": " for either Windows or Linux. It&#x27;s just a matter of configuring your Dockerfile to perform the procedure. Tip To use .<em>NET</em> or any <em>other</em> <em>agent</em>, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB"
      },
      "id": "603e85bde7b9d2b26c2a07fd"
    },
    {
      "sections": [
        ".NET agent install resources",
        "Important",
        "Microsoft's .NET profiler",
        ".NET agent download library",
        "Zip files for manual .NET agent install (Windows)",
        "Caution",
        ".NET Framework environment variables for manual install",
        ".NET Core environment variables for manual install",
        "Need for custom instrumentation",
        "Install-related environment variables",
        "Scriptable installers (Windows only)",
        "Scriptable installer for .NET Framework",
        "Tip",
        "Scriptable installer for .NET Core",
        "Local install",
        "Global install"
      ],
      "title": ".NET agent install resources",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "15e6347108ca11e12ccb535fb9fc3fa90d3f4a40",
      "image": "",
      "url": "https://docs.newrelic.com/docs/net-agent-install-resources/",
      "published_at": "2021-06-02T15:59:06Z",
      "updated_at": "2021-03-16T02:42:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains detailed descriptions of resources and procedures that are referenced in the New Relic .NET agent install procedures. Important This document is not meant to be read as a standalone document. For install instructions, see Introduction to .NET agent install. Microsoft's .NET profiler New Relic’s .NET agent relies on the Microsoft profiling API to report data from your .NET application. .NET monitoring solutions other than New Relic can use this profiling API. But only one service can use the profiler at a time. This means that if you have used a .NET monitoring service in the past and haven’t completely disabled/removed it, the profiler may still be in use, which will cause profiler conflicts when you try to enable the .NET agent. .NET agent download library The New Relic .NET agent download library contains install file packages that are referenced in specific install procedures. For more on these files, see the download library’s ReadMe file. Zip files for manual .NET agent install (Windows) To manually install the agent using a ZIP file, choose the correct file for the application you wish to monitor: Go to the .NET agent download site and get the file matching your application's runtime and architecture: .NET Framework (32-bit): newrelic-agent-win-x86-VERSION.zip .NET Framework (64-bit): newrelic-agent-win-x64-VERSION.zip .NET Core (32-bit): newrelic-netcore20-agent-win-x86-VERSION.zip .NET Core (64-bit): newrelic-netcore20-agent-win-x64-VERSION.zip Unzip the agent folder in the desired location. Set environment variables for the process you wish to monitor. Caution We do not recommend setting these environment variables globally. Setting these environment variables globally can cause all .NET processes running on the system to get instrumented and report to New Relic. If you are installing the agent manually, we expect that you have the means to set these environment variables only for the processes you wish to monitor. .NET Framework environment variables for manual install For .NET Framework, the following variables are required: COR_ENABLE_PROFILING=1 COR_PROFILER={71DA0A04-7777-4EC6-9643-7D28B46A8A41} NEWRELIC_HOME=path\\to\\agent\\directory COR_PROFILER_PATH=path\\to\\agent\\directory\\NewRelic.Profiler.dll Copy .NET Core environment variables for manual install For .NET Core, the following variables are required: CORECLR_ENABLE_PROFILING=1 CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_NEWRELIC_HOME=path\\to\\agent\\directory CORECLR_PROFILER_PATH=path\\to\\agent\\directory\\NewRelic.Profiler.dll Copy Restart your application. If using IIS, restart IIS. If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears. Need for custom instrumentation After installing a .NET agent, most .NET application frameworks will automatically report data to your New Relic account. (See app framework compatibility: .NET Framework | .NET Core.) If your .NET application uses an application framework that is not automatically instrumented, or if the app has no framework (like a console app), after the install you will need to manually set up instrumentation of your app. Here are the steps to do that: Follow the relevant install instructions for your application and framework. Custom instrument your application to define what activity is reported to New Relic. Install-related environment variables A .NET agent install requires setting environment variables. For some install procedures (like for IIS-hosted .NET applications), these environment variables are set automatically. For other install procedures, you will have to manually set them. To see the required environment variables for both .NET Framework and .NET Core applications, see Environment variables. For installations requiring you to manually set environment variables, you can also set other configuration options via environment variables. Here's a look at two that are commonly set: License key. The environment variable for setting the New Relic license key is: NEW_RELIC_LICENSE_KEY = YOUR_LICENSE_KEY Copy You can also set this in the newrelic.config file or the app's config file. App name. Setting a meaningful application name is recommended, but you can also set this after install. The environment variable is: NEW_RELIC_APP_NAME = YOUR_APP_NAME Copy You can also set this via the newrelic.config, the app's config file, or the API. Scriptable installers (Windows only) The scriptable installers are ZIP archives containing a PowerShell script for installing the .NET agent. There is a separate zip archive for .NET Framework versus .NET Core. Important We recommend using the MSI installer over the scriptable installer. If you want to automate your install, consider running the MSI installer from the command line. Scriptable installer for .NET Framework To use the scriptable installer to install the .NET agent for a .NET Framework app: Ensure you have administrator rights for your Windows admin group. For more details on this, see the permissions documentation. Download the scriptable installer package for .NET Framework from the download site. By downloading or using one of these packages, you agree to and accept the license terms. Unzip the package. Open a command shell and navigate into the unzipped package's folder. For a simple install with no options, use this command: .\\install.cmd -LicenseKey YOUR_LICENSE_KEY Copy To install with one or more additional options, use the format below. See table below for a description of the install options. install.cmd -LicenseKey YOUR_LICENSE_KEY [-NoIISReset] [-InstrumentAll] [-InstallPath PATH_TO_INSTALL] Copy If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears. Install options Description LicenseKey Required. Your New Relic license key. NoIISReset Optional. Use this option to prevent the installer from initiating an IIS reset. Important If you use this option, you need to do an IIS reset manually before New Relic starts instrumenting any IIS-hosted applications. InstrumentAll Optional. By default, the .NET agent will instrument all IIS-hosted applications. Use this option to enable instrumentation of other types of .NET applications. InstallPath Optional. Use this option to choose a different installation location. The default install location is C:\\Program Files\\New Relic. Uninstalling the agent with the scriptable uninstaller: Tip You can add the Force option to the uninstall script to force an uninstall without prompting to restart IIS. Execute the following command to uninstall the .NET Framework agent: .\\uninstall.cmd Copy Scriptable installer for .NET Core Important Before installing the agent: Understand the agent requirements, including the permissions requirements. Note that admin rights in an elevated shell are required (specifically for selecting a custom log directory and performing an IISReset). Caution For security reasons, it is necessary to execute the installAgent.ps1 script as shown below, by prepending ./ to the script filename, rather than by prepending powershell to the script. If you execute the script by prepending powershell, and any of your supplied arguments (e.g. the install path or custom log path) have spaces in them, these arguments will be corrupted, which would lead to the agent being installed to a location other than the intended location, which could be unsecure. To use the scriptable installer to install the .NET agent for a .NET Core application: Ensure you have administrator rights for your Windows admin group. For more details on this, see the permissions documentation Download the .NET Core agent's scriptable installer package from the .NET agent download site . By downloading or using one of these packages, you agree to and accept the license terms. Unzip the package in the desired location. Open a command shell and navigate into the unzipped package's folder. You can install the agent either locally or globally: Local install For a simple install, with no options, use this command: ./installAgent.ps1 -destination PATH -installType global -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\"] Copy To install with one or more additional options, use the same command with desired options. For option descriptions, see table below. ./installAgent.ps1 -destination PATH -installType local -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\" -X86 -ResetIIS -Force] Copy Global install Important The global install will instrument all .NET Core processes on your system. Only choose the global install if you want all .NET Core processes monitored. For a simple install with no options, use this command: ./installAgent.ps1 -destination PATH -installType global -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\"] Copy To install with one or more additional options, use the same command with desired options. For option descriptions, see table below. ./installAgent.ps1 -destination PATH -installType local -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\" -X86 -ResetIIS -Force] Copy If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears. Install options Description Destination Required. The location where the agent is installed. This can be an absolute or relative path. Wrapping quotes are required. InstallType Required. Determines whether this is a local (app-specific) or global (system-wide) install. LicenseKey Required. Your New Relic license key. AppName Optional. Sets the default application name associated with your agent installation. LogDir Optional. Sets a custom logging location for the agent. By default, the agent puts the logs directory in the install directory. X86 Optional. Installs the 32-bit version of the agent rather than the 64-bit version. New Relic does not recommend installing the 32-bit version of the agent globally. ResetIIS Optional. Performs an iisreset after the installation. Important Only use this if your .NET Core app is hosted via an IIS reverse proxy. Force Optional. Forces the installation process to overwrite a previous install or to install into an existing folder. Caution This overwrites any configuration customizations. New Relic recommends backing up your configuration file and any custom instrumentation files prior to forcing an over-install. Help Optional. Displays usage information for this script.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.09366,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> <em>install</em> resources",
        "sections": ".<em>NET</em> <em>agent</em> <em>install</em> resources",
        "tags": "<em>Other</em> <em>installation</em>",
        "body": " profiler New Relic’s .<em>NET</em> <em>agent</em> relies on the Microsoft profiling API to report data from your .<em>NET</em> application. .<em>NET</em> monitoring solutions <em>other</em> than New Relic can use this profiling API. But only one service can use the profiler at a time. This means that if you have used a .<em>NET</em> monitoring service"
      },
      "id": "603eb8ba28ccbc3daceba773"
    }
  ],
  "/docs/agents/net-agent/other-installation/install-net-agent-aspnet-core": [
    {
      "sections": [
        "Install .NET agent for Windows Communication Foundation (WCF)",
        "Install for WCF applications",
        "Important",
        "ASP.NET pipeline events and WCF events",
        "Only WCF events"
      ],
      "title": "Install .NET agent for Windows Communication Foundation (WCF)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "c39d558ff81b712496798549087933ccabcc2586",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/other-installation/install-net-agent-windows-communication-foundation-wcf/",
      "published_at": "2021-06-02T16:16:56Z",
      "updated_at": "2021-03-16T04:35:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install the .NET agent and monitor WCF applications. Install for WCF applications To install the .NET agent on IIS-hosted WCF apps: Install the latest .NET agent. Important For self-hosted WCF applications (hosted as a custom Windows Service, a console app, or a Windows Forms app) take note of the instructions to enable the agent for your application. Ensure you give each WCF app a descriptive name. Enable or disable ASP.NET compatibility mode in your WCF application depending on which type of events you want monitored: ASP.NET pipeline events and WCF events When ASP.NET compatibility mode is enabled, the .NET agent instruments ASP.NET pipeline events as well as WCF events. In this mode, the agent provides you with a full view of your application stack. Only WCF events When ASP.NET compatibility mode is disabled, the .NET agent only instruments WCF events. Any activity that occurs as part of the ASP.NET pipeline will not be captured, such as agent API calls that are made outside of a WCF transaction. If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.885216,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .<em>NET</em> <em>agent</em> for Windows Communication Foundation (WCF)",
        "sections": "<em>Install</em> .<em>NET</em> <em>agent</em> for Windows Communication Foundation (WCF)",
        "tags": "<em>Other</em> <em>installation</em>",
        "body": "This document explains how to install the .<em>NET</em> <em>agent</em> and monitor WCF applications. Install for WCF applications To install the .<em>NET</em> <em>agent</em> on IIS-hosted WCF apps: Install the latest .<em>NET</em> <em>agent</em>. Important For self-hosted WCF applications (hosted as a custom Windows Service, a console app"
      },
      "id": "603ea62e196a679eb4a83d8d"
    },
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Tip",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "d0515c81825c0b108418459b6c14a510b540c206",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-06-02T16:16:54Z",
      "updated_at": "2021-03-16T14:59:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Tip To use .NET or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile FROM microsoft/dotnet:2.2-aspnetcore-runtime # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile FROM microsoft/dotnet:2.2-sdk AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet build -c Release -o /app/ ./YOUR_APP_NAME FROM microsoft/dotnet:2.2-aspnetcore-runtime AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM microsoft/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Copy the New Relic .NET agent installer COPY ./NewRelicDotNetAgent_x64.msi / # Install the agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i,\\ \"C:\\NewRelicDotNetAgent_x64.msi\",\\ /qn,NR_LICENSE_KEY=YOUR_LICENSE_KEY # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Copy the New Relic .NET agent installer COPY ./NewRelicDotNetAgent_x64.msi / # Install the agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"C:\\NewRelicDotNetAgent_x64.msi\", /qn, NR_LICENSE_KEY=YOUR_LICENSE_KEY # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windowsservercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.38908,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "<em>Install</em> .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>Other</em> <em>installation</em>",
        "body": " for either Windows or Linux. It&#x27;s just a matter of configuring your Dockerfile to perform the procedure. Tip To use .<em>NET</em> or any <em>other</em> <em>agent</em>, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB"
      },
      "id": "603e85bde7b9d2b26c2a07fd"
    },
    {
      "sections": [
        ".NET agent install resources",
        "Important",
        "Microsoft's .NET profiler",
        ".NET agent download library",
        "Zip files for manual .NET agent install (Windows)",
        "Caution",
        ".NET Framework environment variables for manual install",
        ".NET Core environment variables for manual install",
        "Need for custom instrumentation",
        "Install-related environment variables",
        "Scriptable installers (Windows only)",
        "Scriptable installer for .NET Framework",
        "Tip",
        "Scriptable installer for .NET Core",
        "Local install",
        "Global install"
      ],
      "title": ".NET agent install resources",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "15e6347108ca11e12ccb535fb9fc3fa90d3f4a40",
      "image": "",
      "url": "https://docs.newrelic.com/docs/net-agent-install-resources/",
      "published_at": "2021-06-02T15:59:06Z",
      "updated_at": "2021-03-16T02:42:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains detailed descriptions of resources and procedures that are referenced in the New Relic .NET agent install procedures. Important This document is not meant to be read as a standalone document. For install instructions, see Introduction to .NET agent install. Microsoft's .NET profiler New Relic’s .NET agent relies on the Microsoft profiling API to report data from your .NET application. .NET monitoring solutions other than New Relic can use this profiling API. But only one service can use the profiler at a time. This means that if you have used a .NET monitoring service in the past and haven’t completely disabled/removed it, the profiler may still be in use, which will cause profiler conflicts when you try to enable the .NET agent. .NET agent download library The New Relic .NET agent download library contains install file packages that are referenced in specific install procedures. For more on these files, see the download library’s ReadMe file. Zip files for manual .NET agent install (Windows) To manually install the agent using a ZIP file, choose the correct file for the application you wish to monitor: Go to the .NET agent download site and get the file matching your application's runtime and architecture: .NET Framework (32-bit): newrelic-agent-win-x86-VERSION.zip .NET Framework (64-bit): newrelic-agent-win-x64-VERSION.zip .NET Core (32-bit): newrelic-netcore20-agent-win-x86-VERSION.zip .NET Core (64-bit): newrelic-netcore20-agent-win-x64-VERSION.zip Unzip the agent folder in the desired location. Set environment variables for the process you wish to monitor. Caution We do not recommend setting these environment variables globally. Setting these environment variables globally can cause all .NET processes running on the system to get instrumented and report to New Relic. If you are installing the agent manually, we expect that you have the means to set these environment variables only for the processes you wish to monitor. .NET Framework environment variables for manual install For .NET Framework, the following variables are required: COR_ENABLE_PROFILING=1 COR_PROFILER={71DA0A04-7777-4EC6-9643-7D28B46A8A41} NEWRELIC_HOME=path\\to\\agent\\directory COR_PROFILER_PATH=path\\to\\agent\\directory\\NewRelic.Profiler.dll Copy .NET Core environment variables for manual install For .NET Core, the following variables are required: CORECLR_ENABLE_PROFILING=1 CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_NEWRELIC_HOME=path\\to\\agent\\directory CORECLR_PROFILER_PATH=path\\to\\agent\\directory\\NewRelic.Profiler.dll Copy Restart your application. If using IIS, restart IIS. If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears. Need for custom instrumentation After installing a .NET agent, most .NET application frameworks will automatically report data to your New Relic account. (See app framework compatibility: .NET Framework | .NET Core.) If your .NET application uses an application framework that is not automatically instrumented, or if the app has no framework (like a console app), after the install you will need to manually set up instrumentation of your app. Here are the steps to do that: Follow the relevant install instructions for your application and framework. Custom instrument your application to define what activity is reported to New Relic. Install-related environment variables A .NET agent install requires setting environment variables. For some install procedures (like for IIS-hosted .NET applications), these environment variables are set automatically. For other install procedures, you will have to manually set them. To see the required environment variables for both .NET Framework and .NET Core applications, see Environment variables. For installations requiring you to manually set environment variables, you can also set other configuration options via environment variables. Here's a look at two that are commonly set: License key. The environment variable for setting the New Relic license key is: NEW_RELIC_LICENSE_KEY = YOUR_LICENSE_KEY Copy You can also set this in the newrelic.config file or the app's config file. App name. Setting a meaningful application name is recommended, but you can also set this after install. The environment variable is: NEW_RELIC_APP_NAME = YOUR_APP_NAME Copy You can also set this via the newrelic.config, the app's config file, or the API. Scriptable installers (Windows only) The scriptable installers are ZIP archives containing a PowerShell script for installing the .NET agent. There is a separate zip archive for .NET Framework versus .NET Core. Important We recommend using the MSI installer over the scriptable installer. If you want to automate your install, consider running the MSI installer from the command line. Scriptable installer for .NET Framework To use the scriptable installer to install the .NET agent for a .NET Framework app: Ensure you have administrator rights for your Windows admin group. For more details on this, see the permissions documentation. Download the scriptable installer package for .NET Framework from the download site. By downloading or using one of these packages, you agree to and accept the license terms. Unzip the package. Open a command shell and navigate into the unzipped package's folder. For a simple install with no options, use this command: .\\install.cmd -LicenseKey YOUR_LICENSE_KEY Copy To install with one or more additional options, use the format below. See table below for a description of the install options. install.cmd -LicenseKey YOUR_LICENSE_KEY [-NoIISReset] [-InstrumentAll] [-InstallPath PATH_TO_INSTALL] Copy If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears. Install options Description LicenseKey Required. Your New Relic license key. NoIISReset Optional. Use this option to prevent the installer from initiating an IIS reset. Important If you use this option, you need to do an IIS reset manually before New Relic starts instrumenting any IIS-hosted applications. InstrumentAll Optional. By default, the .NET agent will instrument all IIS-hosted applications. Use this option to enable instrumentation of other types of .NET applications. InstallPath Optional. Use this option to choose a different installation location. The default install location is C:\\Program Files\\New Relic. Uninstalling the agent with the scriptable uninstaller: Tip You can add the Force option to the uninstall script to force an uninstall without prompting to restart IIS. Execute the following command to uninstall the .NET Framework agent: .\\uninstall.cmd Copy Scriptable installer for .NET Core Important Before installing the agent: Understand the agent requirements, including the permissions requirements. Note that admin rights in an elevated shell are required (specifically for selecting a custom log directory and performing an IISReset). Caution For security reasons, it is necessary to execute the installAgent.ps1 script as shown below, by prepending ./ to the script filename, rather than by prepending powershell to the script. If you execute the script by prepending powershell, and any of your supplied arguments (e.g. the install path or custom log path) have spaces in them, these arguments will be corrupted, which would lead to the agent being installed to a location other than the intended location, which could be unsecure. To use the scriptable installer to install the .NET agent for a .NET Core application: Ensure you have administrator rights for your Windows admin group. For more details on this, see the permissions documentation Download the .NET Core agent's scriptable installer package from the .NET agent download site . By downloading or using one of these packages, you agree to and accept the license terms. Unzip the package in the desired location. Open a command shell and navigate into the unzipped package's folder. You can install the agent either locally or globally: Local install For a simple install, with no options, use this command: ./installAgent.ps1 -destination PATH -installType global -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\"] Copy To install with one or more additional options, use the same command with desired options. For option descriptions, see table below. ./installAgent.ps1 -destination PATH -installType local -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\" -X86 -ResetIIS -Force] Copy Global install Important The global install will instrument all .NET Core processes on your system. Only choose the global install if you want all .NET Core processes monitored. For a simple install with no options, use this command: ./installAgent.ps1 -destination PATH -installType global -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\"] Copy To install with one or more additional options, use the same command with desired options. For option descriptions, see table below. ./installAgent.ps1 -destination PATH -installType local -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\" -X86 -ResetIIS -Force] Copy If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears. Install options Description Destination Required. The location where the agent is installed. This can be an absolute or relative path. Wrapping quotes are required. InstallType Required. Determines whether this is a local (app-specific) or global (system-wide) install. LicenseKey Required. Your New Relic license key. AppName Optional. Sets the default application name associated with your agent installation. LogDir Optional. Sets a custom logging location for the agent. By default, the agent puts the logs directory in the install directory. X86 Optional. Installs the 32-bit version of the agent rather than the 64-bit version. New Relic does not recommend installing the 32-bit version of the agent globally. ResetIIS Optional. Performs an iisreset after the installation. Important Only use this if your .NET Core app is hosted via an IIS reverse proxy. Force Optional. Forces the installation process to overwrite a previous install or to install into an existing folder. Caution This overwrites any configuration customizations. New Relic recommends backing up your configuration file and any custom instrumentation files prior to forcing an over-install. Help Optional. Displays usage information for this script.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.09366,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> <em>install</em> resources",
        "sections": ".<em>NET</em> <em>agent</em> <em>install</em> resources",
        "tags": "<em>Other</em> <em>installation</em>",
        "body": " profiler New Relic’s .<em>NET</em> <em>agent</em> relies on the Microsoft profiling API to report data from your .<em>NET</em> application. .<em>NET</em> monitoring solutions <em>other</em> than New Relic can use this profiling API. But only one service can use the profiler at a time. This means that if you have used a .<em>NET</em> monitoring service"
      },
      "id": "603eb8ba28ccbc3daceba773"
    }
  ],
  "/docs/agents/net-agent/other-installation/install-net-agent-docker-container": [
    {
      "sections": [
        "Install .NET agent for Windows Communication Foundation (WCF)",
        "Install for WCF applications",
        "Important",
        "ASP.NET pipeline events and WCF events",
        "Only WCF events"
      ],
      "title": "Install .NET agent for Windows Communication Foundation (WCF)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "c39d558ff81b712496798549087933ccabcc2586",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/other-installation/install-net-agent-windows-communication-foundation-wcf/",
      "published_at": "2021-06-02T16:16:56Z",
      "updated_at": "2021-03-16T04:35:05Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document explains how to install the .NET agent and monitor WCF applications. Install for WCF applications To install the .NET agent on IIS-hosted WCF apps: Install the latest .NET agent. Important For self-hosted WCF applications (hosted as a custom Windows Service, a console app, or a Windows Forms app) take note of the instructions to enable the agent for your application. Ensure you give each WCF app a descriptive name. Enable or disable ASP.NET compatibility mode in your WCF application depending on which type of events you want monitored: ASP.NET pipeline events and WCF events When ASP.NET compatibility mode is enabled, the .NET agent instruments ASP.NET pipeline events as well as WCF events. In this mode, the agent provides you with a full view of your application stack. Only WCF events When ASP.NET compatibility mode is disabled, the .NET agent only instruments WCF events. Any activity that occurs as part of the ASP.NET pipeline will not be captured, such as agent API calls that are made outside of a WCF transaction. If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.885216,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .<em>NET</em> <em>agent</em> for Windows Communication Foundation (WCF)",
        "sections": "<em>Install</em> .<em>NET</em> <em>agent</em> for Windows Communication Foundation (WCF)",
        "tags": "<em>Other</em> <em>installation</em>",
        "body": "This document explains how to install the .<em>NET</em> <em>agent</em> and monitor WCF applications. Install for WCF applications To install the .<em>NET</em> <em>agent</em> on IIS-hosted WCF apps: Install the latest .<em>NET</em> <em>agent</em>. Important For self-hosted WCF applications (hosted as a custom Windows Service, a console app"
      },
      "id": "603ea62e196a679eb4a83d8d"
    },
    {
      "sections": [
        ".NET agent install resources",
        "Important",
        "Microsoft's .NET profiler",
        ".NET agent download library",
        "Zip files for manual .NET agent install (Windows)",
        "Caution",
        ".NET Framework environment variables for manual install",
        ".NET Core environment variables for manual install",
        "Need for custom instrumentation",
        "Install-related environment variables",
        "Scriptable installers (Windows only)",
        "Scriptable installer for .NET Framework",
        "Tip",
        "Scriptable installer for .NET Core",
        "Local install",
        "Global install"
      ],
      "title": ".NET agent install resources",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "15e6347108ca11e12ccb535fb9fc3fa90d3f4a40",
      "image": "",
      "url": "https://docs.newrelic.com/docs/net-agent-install-resources/",
      "published_at": "2021-06-02T15:59:06Z",
      "updated_at": "2021-03-16T02:42:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains detailed descriptions of resources and procedures that are referenced in the New Relic .NET agent install procedures. Important This document is not meant to be read as a standalone document. For install instructions, see Introduction to .NET agent install. Microsoft's .NET profiler New Relic’s .NET agent relies on the Microsoft profiling API to report data from your .NET application. .NET monitoring solutions other than New Relic can use this profiling API. But only one service can use the profiler at a time. This means that if you have used a .NET monitoring service in the past and haven’t completely disabled/removed it, the profiler may still be in use, which will cause profiler conflicts when you try to enable the .NET agent. .NET agent download library The New Relic .NET agent download library contains install file packages that are referenced in specific install procedures. For more on these files, see the download library’s ReadMe file. Zip files for manual .NET agent install (Windows) To manually install the agent using a ZIP file, choose the correct file for the application you wish to monitor: Go to the .NET agent download site and get the file matching your application's runtime and architecture: .NET Framework (32-bit): newrelic-agent-win-x86-VERSION.zip .NET Framework (64-bit): newrelic-agent-win-x64-VERSION.zip .NET Core (32-bit): newrelic-netcore20-agent-win-x86-VERSION.zip .NET Core (64-bit): newrelic-netcore20-agent-win-x64-VERSION.zip Unzip the agent folder in the desired location. Set environment variables for the process you wish to monitor. Caution We do not recommend setting these environment variables globally. Setting these environment variables globally can cause all .NET processes running on the system to get instrumented and report to New Relic. If you are installing the agent manually, we expect that you have the means to set these environment variables only for the processes you wish to monitor. .NET Framework environment variables for manual install For .NET Framework, the following variables are required: COR_ENABLE_PROFILING=1 COR_PROFILER={71DA0A04-7777-4EC6-9643-7D28B46A8A41} NEWRELIC_HOME=path\\to\\agent\\directory COR_PROFILER_PATH=path\\to\\agent\\directory\\NewRelic.Profiler.dll Copy .NET Core environment variables for manual install For .NET Core, the following variables are required: CORECLR_ENABLE_PROFILING=1 CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_NEWRELIC_HOME=path\\to\\agent\\directory CORECLR_PROFILER_PATH=path\\to\\agent\\directory\\NewRelic.Profiler.dll Copy Restart your application. If using IIS, restart IIS. If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears. Need for custom instrumentation After installing a .NET agent, most .NET application frameworks will automatically report data to your New Relic account. (See app framework compatibility: .NET Framework | .NET Core.) If your .NET application uses an application framework that is not automatically instrumented, or if the app has no framework (like a console app), after the install you will need to manually set up instrumentation of your app. Here are the steps to do that: Follow the relevant install instructions for your application and framework. Custom instrument your application to define what activity is reported to New Relic. Install-related environment variables A .NET agent install requires setting environment variables. For some install procedures (like for IIS-hosted .NET applications), these environment variables are set automatically. For other install procedures, you will have to manually set them. To see the required environment variables for both .NET Framework and .NET Core applications, see Environment variables. For installations requiring you to manually set environment variables, you can also set other configuration options via environment variables. Here's a look at two that are commonly set: License key. The environment variable for setting the New Relic license key is: NEW_RELIC_LICENSE_KEY = YOUR_LICENSE_KEY Copy You can also set this in the newrelic.config file or the app's config file. App name. Setting a meaningful application name is recommended, but you can also set this after install. The environment variable is: NEW_RELIC_APP_NAME = YOUR_APP_NAME Copy You can also set this via the newrelic.config, the app's config file, or the API. Scriptable installers (Windows only) The scriptable installers are ZIP archives containing a PowerShell script for installing the .NET agent. There is a separate zip archive for .NET Framework versus .NET Core. Important We recommend using the MSI installer over the scriptable installer. If you want to automate your install, consider running the MSI installer from the command line. Scriptable installer for .NET Framework To use the scriptable installer to install the .NET agent for a .NET Framework app: Ensure you have administrator rights for your Windows admin group. For more details on this, see the permissions documentation. Download the scriptable installer package for .NET Framework from the download site. By downloading or using one of these packages, you agree to and accept the license terms. Unzip the package. Open a command shell and navigate into the unzipped package's folder. For a simple install with no options, use this command: .\\install.cmd -LicenseKey YOUR_LICENSE_KEY Copy To install with one or more additional options, use the format below. See table below for a description of the install options. install.cmd -LicenseKey YOUR_LICENSE_KEY [-NoIISReset] [-InstrumentAll] [-InstallPath PATH_TO_INSTALL] Copy If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears. Install options Description LicenseKey Required. Your New Relic license key. NoIISReset Optional. Use this option to prevent the installer from initiating an IIS reset. Important If you use this option, you need to do an IIS reset manually before New Relic starts instrumenting any IIS-hosted applications. InstrumentAll Optional. By default, the .NET agent will instrument all IIS-hosted applications. Use this option to enable instrumentation of other types of .NET applications. InstallPath Optional. Use this option to choose a different installation location. The default install location is C:\\Program Files\\New Relic. Uninstalling the agent with the scriptable uninstaller: Tip You can add the Force option to the uninstall script to force an uninstall without prompting to restart IIS. Execute the following command to uninstall the .NET Framework agent: .\\uninstall.cmd Copy Scriptable installer for .NET Core Important Before installing the agent: Understand the agent requirements, including the permissions requirements. Note that admin rights in an elevated shell are required (specifically for selecting a custom log directory and performing an IISReset). Caution For security reasons, it is necessary to execute the installAgent.ps1 script as shown below, by prepending ./ to the script filename, rather than by prepending powershell to the script. If you execute the script by prepending powershell, and any of your supplied arguments (e.g. the install path or custom log path) have spaces in them, these arguments will be corrupted, which would lead to the agent being installed to a location other than the intended location, which could be unsecure. To use the scriptable installer to install the .NET agent for a .NET Core application: Ensure you have administrator rights for your Windows admin group. For more details on this, see the permissions documentation Download the .NET Core agent's scriptable installer package from the .NET agent download site . By downloading or using one of these packages, you agree to and accept the license terms. Unzip the package in the desired location. Open a command shell and navigate into the unzipped package's folder. You can install the agent either locally or globally: Local install For a simple install, with no options, use this command: ./installAgent.ps1 -destination PATH -installType global -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\"] Copy To install with one or more additional options, use the same command with desired options. For option descriptions, see table below. ./installAgent.ps1 -destination PATH -installType local -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\" -X86 -ResetIIS -Force] Copy Global install Important The global install will instrument all .NET Core processes on your system. Only choose the global install if you want all .NET Core processes monitored. For a simple install with no options, use this command: ./installAgent.ps1 -destination PATH -installType global -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\"] Copy To install with one or more additional options, use the same command with desired options. For option descriptions, see table below. ./installAgent.ps1 -destination PATH -installType local -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\" -X86 -ResetIIS -Force] Copy If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears. Install options Description Destination Required. The location where the agent is installed. This can be an absolute or relative path. Wrapping quotes are required. InstallType Required. Determines whether this is a local (app-specific) or global (system-wide) install. LicenseKey Required. Your New Relic license key. AppName Optional. Sets the default application name associated with your agent installation. LogDir Optional. Sets a custom logging location for the agent. By default, the agent puts the logs directory in the install directory. X86 Optional. Installs the 32-bit version of the agent rather than the 64-bit version. New Relic does not recommend installing the 32-bit version of the agent globally. ResetIIS Optional. Performs an iisreset after the installation. Important Only use this if your .NET Core app is hosted via an IIS reverse proxy. Force Optional. Forces the installation process to overwrite a previous install or to install into an existing folder. Caution This overwrites any configuration customizations. New Relic recommends backing up your configuration file and any custom instrumentation files prior to forcing an over-install. Help Optional. Displays usage information for this script.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.09366,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> <em>install</em> resources",
        "sections": ".<em>NET</em> <em>agent</em> <em>install</em> resources",
        "tags": "<em>Other</em> <em>installation</em>",
        "body": " profiler New Relic’s .<em>NET</em> <em>agent</em> relies on the Microsoft profiling API to report data from your .<em>NET</em> application. .<em>NET</em> monitoring solutions <em>other</em> than New Relic can use this profiling API. But only one service can use the profiler at a time. This means that if you have used a .<em>NET</em> monitoring service"
      },
      "id": "603eb8ba28ccbc3daceba773"
    },
    {
      "sections": [
        "Install .NET agent for ASP.NET Core",
        "Tip",
        "ASP.NET Core apps targeting .NET Core",
        "ASP.NET Core apps targeting .NET Framework"
      ],
      "title": "Install .NET agent for ASP.NET Core ",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "dd06632bf62131d96c30b411e2a085d87901dbbd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/other-installation/install-net-agent-aspnet-core/",
      "published_at": "2021-06-02T16:52:05Z",
      "updated_at": "2021-03-16T14:58:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains instructions for installing New Relic's .NET agent to monitor an ASP.NET Core application. These are additional caveats and instructions that supplement the standard installation procedures for Windows and Linux. Tip To use .NET or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. ASP.NET Core apps targeting .NET Core New Relic automatically instruments ASP.NET Core apps targeting .NET Core that are hosted in IIS. For applications not using IIS, follow the standard installation procedures for Windows or Linux as applicable. In addition, you must enable the agent for your application and, if monitoring doesn't happen automatically, set up custom instrumentation: Enabling your app: See instructions for Windows and for Linux. Custom instrumentation: If you're not using Kestral, or if instrumentation doesn't happen by default for some other reason, you must custom instrument your app. ASP.NET Core apps targeting .NET Framework For applications not hosted in IIS, or for ASP.NET Core apps targeting .NET Framework, follow the standard installation procedure for Windows. In addition, you must follow these procedures to explicitly enable the .NET agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 108.186035,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .<em>NET</em> <em>agent</em> for ASP.NET Core ",
        "sections": "<em>Install</em> .<em>NET</em> <em>agent</em> for ASP.NET Core",
        "tags": "<em>Other</em> <em>installation</em>",
        "body": "This document contains instructions for installing New Relic&#x27;s .<em>NET</em> <em>agent</em> to monitor an ASP.<em>NET</em> Core application. These are additional caveats and instructions that supplement the standard <em>installation</em> procedures for Windows and Linux. Tip To use .<em>NET</em> or any <em>other</em> <em>agent</em>, as well as the rest of our"
      },
      "id": "603ea701196a67c41ba83db7"
    }
  ],
  "/docs/agents/net-agent/other-installation/install-net-agent-windows-communication-foundation-wcf": [
    {
      "sections": [
        "Install .NET agent on Docker container",
        "Tip",
        "Overview for install of .NET agent on Docker",
        "Install for Linux Docker containers",
        "Example Linux Dockerfile",
        "Example Linux Multi-stage Dockerfile",
        "Install for Windows Docker containers",
        "Important",
        "Example Windows Dockerfile for .NET Framework application",
        "Example Windows Dockerfile for .NET Core application"
      ],
      "title": "Install .NET agent on Docker container",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "d0515c81825c0b108418459b6c14a510b540c206",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/other-installation/install-net-agent-docker-container/",
      "published_at": "2021-06-02T16:16:54Z",
      "updated_at": "2021-03-16T14:59:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document provides some samples for how you can configure a Dockerfile to install the New Relic .NET agent. Examples are included for both Windows and Linux containers. Installing the .NET agent in a Docker container can be performed using the same procedures as a standard .NET agent install for either Windows or Linux. It's just a matter of configuring your Dockerfile to perform the procedure. Tip To use .NET or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Overview for install of .NET agent on Docker Requirements include: The agent must be installed on the containers you want to monitor. Install the agent with one of the standard install procedures. Enable the agent by setting the required environment variables as applicable. The .NET agent must be installed and enabled at runtime. Install for Linux Docker containers Example Linux Dockerfile FROM microsoft/dotnet:2.2-aspnetcore-runtime # Publish your application. COPY your app to be published /app # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Example Linux Multi-stage Dockerfile FROM microsoft/dotnet:2.2-sdk AS base # Build your application WORKDIR /src RUN dotnet new mvc -o YOUR_APP_NAME RUN dotnet build -c Release -o /app/ ./YOUR_APP_NAME FROM microsoft/dotnet:2.2-aspnetcore-runtime AS final # Install the agent RUN apt-get update && apt-get install -y wget ca-certificates gnupg \\ && echo 'deb http://apt.newrelic.com/debian/ newrelic non-free' | tee /etc/apt/sources.list.d/newrelic.list \\ && wget https://download.newrelic.com/548C16BF.gpg \\ && apt-key add 548C16BF.gpg \\ && apt-get update \\ && apt-get install -y newrelic-netcore20-agent # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 \\ CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} \\ CORECLR_NEWRELIC_HOME=/usr/local/newrelic-netcore20-agent \\ CORECLR_PROFILER_PATH=/usr/local/newrelic-netcore20-agent/libNewRelicProfiler.so \\ NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ NEW_RELIC_APP_NAME=YOUR_APP_NAME WORKDIR /app COPY --from=base /app . ENTRYPOINT [\"dotnet\", \"./YOUR_APP_NAME.dll\"] Copy Install for Windows Docker containers Important Windows Nano Server images are not supported. Example Windows Dockerfile for .NET Framework application FROM microsoft/aspnet # Publish your application. COPY your app to be published /inetpub/wwwroot # Copy the New Relic .NET agent installer COPY ./NewRelicDotNetAgent_x64.msi / # Install the agent RUN powershell.exe Start-Process -Wait -FilePath msiexec -ArgumentList /i,\\ \"C:\\NewRelicDotNetAgent_x64.msi\",\\ /qn,NR_LICENSE_KEY=YOUR_LICENSE_KEY # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Example Windows Dockerfile for .NET Core application FROM mcr.microsoft.com/windows/servercore:ltsc2019 # Publish your application. COPY your app to be published /app # Copy the New Relic .NET agent installer COPY ./NewRelicDotNetAgent_x64.msi / # Install the agent RUN Start-Process -Wait -FilePath msiexec -ArgumentList /i, \"C:\\NewRelicDotNetAgent_x64.msi\", /qn, NR_LICENSE_KEY=YOUR_LICENSE_KEY # Enable the agent ENV CORECLR_ENABLE_PROFILING=1 # Set your application name ENV NEW_RELIC_APP_NAME=YOUR_APP_NAME # windowsservercore images may not include the .NET Core SDK or runtime RUN dotnet sdk/runtime installer WORKDIR /app ENTRYPOINT [\"dotnet\", \".\\\\YOUR_APP_NAME.dll\"] Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 113.38908,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .<em>NET</em> <em>agent</em> on Docker container",
        "sections": "<em>Install</em> .<em>NET</em> <em>agent</em> on Docker container",
        "tags": "<em>Other</em> <em>installation</em>",
        "body": " for either Windows or Linux. It&#x27;s just a matter of configuring your Dockerfile to perform the procedure. Tip To use .<em>NET</em> or any <em>other</em> <em>agent</em>, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB"
      },
      "id": "603e85bde7b9d2b26c2a07fd"
    },
    {
      "sections": [
        ".NET agent install resources",
        "Important",
        "Microsoft's .NET profiler",
        ".NET agent download library",
        "Zip files for manual .NET agent install (Windows)",
        "Caution",
        ".NET Framework environment variables for manual install",
        ".NET Core environment variables for manual install",
        "Need for custom instrumentation",
        "Install-related environment variables",
        "Scriptable installers (Windows only)",
        "Scriptable installer for .NET Framework",
        "Tip",
        "Scriptable installer for .NET Core",
        "Local install",
        "Global install"
      ],
      "title": ".NET agent install resources",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "15e6347108ca11e12ccb535fb9fc3fa90d3f4a40",
      "image": "",
      "url": "https://docs.newrelic.com/docs/net-agent-install-resources/",
      "published_at": "2021-06-02T15:59:06Z",
      "updated_at": "2021-03-16T02:42:12Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains detailed descriptions of resources and procedures that are referenced in the New Relic .NET agent install procedures. Important This document is not meant to be read as a standalone document. For install instructions, see Introduction to .NET agent install. Microsoft's .NET profiler New Relic’s .NET agent relies on the Microsoft profiling API to report data from your .NET application. .NET monitoring solutions other than New Relic can use this profiling API. But only one service can use the profiler at a time. This means that if you have used a .NET monitoring service in the past and haven’t completely disabled/removed it, the profiler may still be in use, which will cause profiler conflicts when you try to enable the .NET agent. .NET agent download library The New Relic .NET agent download library contains install file packages that are referenced in specific install procedures. For more on these files, see the download library’s ReadMe file. Zip files for manual .NET agent install (Windows) To manually install the agent using a ZIP file, choose the correct file for the application you wish to monitor: Go to the .NET agent download site and get the file matching your application's runtime and architecture: .NET Framework (32-bit): newrelic-agent-win-x86-VERSION.zip .NET Framework (64-bit): newrelic-agent-win-x64-VERSION.zip .NET Core (32-bit): newrelic-netcore20-agent-win-x86-VERSION.zip .NET Core (64-bit): newrelic-netcore20-agent-win-x64-VERSION.zip Unzip the agent folder in the desired location. Set environment variables for the process you wish to monitor. Caution We do not recommend setting these environment variables globally. Setting these environment variables globally can cause all .NET processes running on the system to get instrumented and report to New Relic. If you are installing the agent manually, we expect that you have the means to set these environment variables only for the processes you wish to monitor. .NET Framework environment variables for manual install For .NET Framework, the following variables are required: COR_ENABLE_PROFILING=1 COR_PROFILER={71DA0A04-7777-4EC6-9643-7D28B46A8A41} NEWRELIC_HOME=path\\to\\agent\\directory COR_PROFILER_PATH=path\\to\\agent\\directory\\NewRelic.Profiler.dll Copy .NET Core environment variables for manual install For .NET Core, the following variables are required: CORECLR_ENABLE_PROFILING=1 CORECLR_PROFILER={36032161-FFC0-4B61-B559-F6C5D41BAE5A} CORECLR_NEWRELIC_HOME=path\\to\\agent\\directory CORECLR_PROFILER_PATH=path\\to\\agent\\directory\\NewRelic.Profiler.dll Copy Restart your application. If using IIS, restart IIS. If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears. Need for custom instrumentation After installing a .NET agent, most .NET application frameworks will automatically report data to your New Relic account. (See app framework compatibility: .NET Framework | .NET Core.) If your .NET application uses an application framework that is not automatically instrumented, or if the app has no framework (like a console app), after the install you will need to manually set up instrumentation of your app. Here are the steps to do that: Follow the relevant install instructions for your application and framework. Custom instrument your application to define what activity is reported to New Relic. Install-related environment variables A .NET agent install requires setting environment variables. For some install procedures (like for IIS-hosted .NET applications), these environment variables are set automatically. For other install procedures, you will have to manually set them. To see the required environment variables for both .NET Framework and .NET Core applications, see Environment variables. For installations requiring you to manually set environment variables, you can also set other configuration options via environment variables. Here's a look at two that are commonly set: License key. The environment variable for setting the New Relic license key is: NEW_RELIC_LICENSE_KEY = YOUR_LICENSE_KEY Copy You can also set this in the newrelic.config file or the app's config file. App name. Setting a meaningful application name is recommended, but you can also set this after install. The environment variable is: NEW_RELIC_APP_NAME = YOUR_APP_NAME Copy You can also set this via the newrelic.config, the app's config file, or the API. Scriptable installers (Windows only) The scriptable installers are ZIP archives containing a PowerShell script for installing the .NET agent. There is a separate zip archive for .NET Framework versus .NET Core. Important We recommend using the MSI installer over the scriptable installer. If you want to automate your install, consider running the MSI installer from the command line. Scriptable installer for .NET Framework To use the scriptable installer to install the .NET agent for a .NET Framework app: Ensure you have administrator rights for your Windows admin group. For more details on this, see the permissions documentation. Download the scriptable installer package for .NET Framework from the download site. By downloading or using one of these packages, you agree to and accept the license terms. Unzip the package. Open a command shell and navigate into the unzipped package's folder. For a simple install with no options, use this command: .\\install.cmd -LicenseKey YOUR_LICENSE_KEY Copy To install with one or more additional options, use the format below. See table below for a description of the install options. install.cmd -LicenseKey YOUR_LICENSE_KEY [-NoIISReset] [-InstrumentAll] [-InstallPath PATH_TO_INSTALL] Copy If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears. Install options Description LicenseKey Required. Your New Relic license key. NoIISReset Optional. Use this option to prevent the installer from initiating an IIS reset. Important If you use this option, you need to do an IIS reset manually before New Relic starts instrumenting any IIS-hosted applications. InstrumentAll Optional. By default, the .NET agent will instrument all IIS-hosted applications. Use this option to enable instrumentation of other types of .NET applications. InstallPath Optional. Use this option to choose a different installation location. The default install location is C:\\Program Files\\New Relic. Uninstalling the agent with the scriptable uninstaller: Tip You can add the Force option to the uninstall script to force an uninstall without prompting to restart IIS. Execute the following command to uninstall the .NET Framework agent: .\\uninstall.cmd Copy Scriptable installer for .NET Core Important Before installing the agent: Understand the agent requirements, including the permissions requirements. Note that admin rights in an elevated shell are required (specifically for selecting a custom log directory and performing an IISReset). Caution For security reasons, it is necessary to execute the installAgent.ps1 script as shown below, by prepending ./ to the script filename, rather than by prepending powershell to the script. If you execute the script by prepending powershell, and any of your supplied arguments (e.g. the install path or custom log path) have spaces in them, these arguments will be corrupted, which would lead to the agent being installed to a location other than the intended location, which could be unsecure. To use the scriptable installer to install the .NET agent for a .NET Core application: Ensure you have administrator rights for your Windows admin group. For more details on this, see the permissions documentation Download the .NET Core agent's scriptable installer package from the .NET agent download site . By downloading or using one of these packages, you agree to and accept the license terms. Unzip the package in the desired location. Open a command shell and navigate into the unzipped package's folder. You can install the agent either locally or globally: Local install For a simple install, with no options, use this command: ./installAgent.ps1 -destination PATH -installType global -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\"] Copy To install with one or more additional options, use the same command with desired options. For option descriptions, see table below. ./installAgent.ps1 -destination PATH -installType local -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\" -X86 -ResetIIS -Force] Copy Global install Important The global install will instrument all .NET Core processes on your system. Only choose the global install if you want all .NET Core processes monitored. For a simple install with no options, use this command: ./installAgent.ps1 -destination PATH -installType global -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\"] Copy To install with one or more additional options, use the same command with desired options. For option descriptions, see table below. ./installAgent.ps1 -destination PATH -installType local -licenseKey YOUR_LICENSE_KEY \\ [-appName \"YOUR_APPLICATION_NAME\" -logDir \"PATH_TO_CUSTOM_LOG_LOCATION\" -X86 -ResetIIS -Force] Copy If your application is receiving traffic, data should appear within a few minutes. If it doesn't, see No data appears. Install options Description Destination Required. The location where the agent is installed. This can be an absolute or relative path. Wrapping quotes are required. InstallType Required. Determines whether this is a local (app-specific) or global (system-wide) install. LicenseKey Required. Your New Relic license key. AppName Optional. Sets the default application name associated with your agent installation. LogDir Optional. Sets a custom logging location for the agent. By default, the agent puts the logs directory in the install directory. X86 Optional. Installs the 32-bit version of the agent rather than the 64-bit version. New Relic does not recommend installing the 32-bit version of the agent globally. ResetIIS Optional. Performs an iisreset after the installation. Important Only use this if your .NET Core app is hosted via an IIS reverse proxy. Force Optional. Forces the installation process to overwrite a previous install or to install into an existing folder. Caution This overwrites any configuration customizations. New Relic recommends backing up your configuration file and any custom instrumentation files prior to forcing an over-install. Help Optional. Displays usage information for this script.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 112.09366,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> <em>install</em> resources",
        "sections": ".<em>NET</em> <em>agent</em> <em>install</em> resources",
        "tags": "<em>Other</em> <em>installation</em>",
        "body": " profiler New Relic’s .<em>NET</em> <em>agent</em> relies on the Microsoft profiling API to report data from your .<em>NET</em> application. .<em>NET</em> monitoring solutions <em>other</em> than New Relic can use this profiling API. But only one service can use the profiler at a time. This means that if you have used a .<em>NET</em> monitoring service"
      },
      "id": "603eb8ba28ccbc3daceba773"
    },
    {
      "sections": [
        "Install .NET agent for ASP.NET Core",
        "Tip",
        "ASP.NET Core apps targeting .NET Core",
        "ASP.NET Core apps targeting .NET Framework"
      ],
      "title": "Install .NET agent for ASP.NET Core ",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Other installation"
      ],
      "external_id": "dd06632bf62131d96c30b411e2a085d87901dbbd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/other-installation/install-net-agent-aspnet-core/",
      "published_at": "2021-06-02T16:52:05Z",
      "updated_at": "2021-03-16T14:58:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "This document contains instructions for installing New Relic's .NET agent to monitor an ASP.NET Core application. These are additional caveats and instructions that supplement the standard installation procedures for Windows and Linux. Tip To use .NET or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. ASP.NET Core apps targeting .NET Core New Relic automatically instruments ASP.NET Core apps targeting .NET Core that are hosted in IIS. For applications not using IIS, follow the standard installation procedures for Windows or Linux as applicable. In addition, you must enable the agent for your application and, if monitoring doesn't happen automatically, set up custom instrumentation: Enabling your app: See instructions for Windows and for Linux. Custom instrumentation: If you're not using Kestral, or if instrumentation doesn't happen by default for some other reason, you must custom instrument your app. ASP.NET Core apps targeting .NET Framework For applications not hosted in IIS, or for ASP.NET Core apps targeting .NET Framework, follow the standard installation procedure for Windows. In addition, you must follow these procedures to explicitly enable the .NET agent.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 108.186035,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> .<em>NET</em> <em>agent</em> for ASP.NET Core ",
        "sections": "<em>Install</em> .<em>NET</em> <em>agent</em> for ASP.NET Core",
        "tags": "<em>Other</em> <em>installation</em>",
        "body": "This document contains instructions for installing New Relic&#x27;s .<em>NET</em> <em>agent</em> to monitor an ASP.<em>NET</em> Core application. These are additional caveats and instructions that supplement the standard <em>installation</em> procedures for Windows and Linux. Tip To use .<em>NET</em> or any <em>other</em> <em>agent</em>, as well as the rest of our"
      },
      "id": "603ea701196a67c41ba83db7"
    }
  ],
  "/docs/agents/net-agent/troubleshooting/agent-changes-content-type-header-wcf-apps-net": [
    {
      "sections": [
        "Generate logs for troubleshooting (.NET)",
        "Generate log files",
        "Important",
        "Generate Azure Web App log files",
        "Collect system information",
        "Check permissions",
        "For more help"
      ],
      "title": "Generate logs for troubleshooting (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "3f0c136f4228951c3d2f4bfa1f28e5331b5fa5ca",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/generate-logs-troubleshooting-net/",
      "published_at": "2021-06-02T16:17:55Z",
      "updated_at": "2021-03-16T13:04:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent stores two types of log files in the Logs directory at %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. Both are needed for troubleshooting; for example, if no data appears in the New Relic UI for your app. If either log type is missing, some component of the .NET agent did not start. Agent logs: These file names begin with newrelic_agent_. Profiler logs: These file names begin with NewRelic.Profiler. Generate log files Important When troubleshooting your New Relic .NET agent, ensure it has been configured to generate debug level log files, and monitor the size of your log file closely. Logging at debug generates a lot of data very quickly. After reproducing your problem, return the log level to info. If your C:\\ProgramData\\New Relic\\.NET Agent is in a hidden folder, update your Windows settings so that you can see it. To generate New Relic for .NET log files: Open newrelic.config, usually located in C:\\ProgramData\\New Relic\\.NET Agent (or %ALLUSERSPROFILE%\\New Relic\\.NET Agent). Change the <log level=\"info\" /> setting to <log level=\"debug\" />. Save and close the file, then wait a few minutes for the agent to read the new settings. Generate a few minutes of traffic to your app. If sending your log file to New Relic Support: In your New Relic support ticket, attach the newrelic.config file (not the text of the file), and attach the entire Logs folder from C:\\ProgramData\\New Relic\\.NET Agent\\Logs or from %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. In newrelic.config, change <log level=\"debug\" /> to <log level=\"info\" />. Generate Azure Web App log files Kudu Console manages Microsoft Azure Web App log reporting. To use the Kudu Console, first log into Azure. Navigate to the URL of your Azure Web app; for example: https://example.azurewebsites.net Copy Insert the Kudu Console URL scmsnippet into the URL; for example: https://example.scm.azurewebsites.net Copy Check for the Kudu logo with a black navigation bar at the top left of the page and your Azure username at the top right of the page. Then, to change the log level within the Kudu Console: From the Kudu Console navigation bar, select the Debug console menu, then select either CMD or PowerShell. Navigate to D:\\home\\site\\wwwroot\\newrelic. To edit newrelic.config, select the pencil icon. Change <log level=\"info\"> to <log level=\"debug\"> Save the change to newrelic.config. Wait a few minutes for the debug logs to be generated. Use the same steps to switch the log level back to info. Collect system information In addition to agent logs, a Microsoft System Information file is also useful for troubleshooting: From the Windows task bar, select Start > Run and enter msinfo32. Select OK. After the system information page loads, select File > Save. Wait a few minutes for the server to save the file. Attach the file to your New Relic support ticket. Check permissions Sometimes the .NET agent will start but not be able to write to its logs because it does not have the necessary permissions to create the log directory and log files. Permissions management varies by environment, so you will need to work with your system administrator to verify that this is not an issue. For more help For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 83.135345,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate logs for <em>troubleshooting</em> (.<em>NET</em>)",
        "sections": "Generate logs for <em>troubleshooting</em> (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> stores two types of log files in the Logs directory at %ALLUSERSPROFILE%\\New Relic\\.<em>NET</em> <em>Agent</em>\\Logs. Both are needed for <em>troubleshooting</em>; for example, if no data appears in the New Relic UI for your app. If either log type is missing, some component of the .<em>NET</em> <em>agent</em> did"
      },
      "id": "603eb5da196a67556aa83dd8"
    },
    {
      "sections": [
        "No Browser data appears (.NET)",
        "Problem",
        "Solution"
      ],
      "title": "No Browser data appears (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "61a0ca0687aa9ebea7c0ce8d99e38822db0eb1cd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/no-browser-data-appears-net/",
      "published_at": "2021-06-02T16:50:18Z",
      "updated_at": "2021-03-11T02:34:52Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem After generating traffic and waiting five minutes, you do not see any browser monitoring data for your .NET app. Solution To troubleshoot missing data: Make sure you have installed the latest release of the .NET agent. Follow the troubleshooting procedures for missing data as applicable. Verify whether your pages are rendered using ASPs. If you use another rendering technology, use manual instrumentation. Flush your .NET cache. Set the <head> tag of your pages to render on the server. Verify that your agent is configured to auto-instrument pages. Edit newrelic.config and verify that autoInstrument is set to true: <browserMonitoring autoInstrument=\"true\"/> Copy Check whether IIS page compression is disabled. If compressed before the .NET agent attempts browser instrumentation, the necessary <HEAD> tag won't be found. For instructions on how to check that, see Microsoft documentation. Look at the source of one of your pages through a browser. Look for a script with references to NREUMQ at the top and bottom of your pages. If you get support at support.newrelic.com, mention whether you are seeing this JavaScript in the page header or in some other location in the page, or you are not seeing it at all. Here are some additional troubleshooting tips: Browser problems Additional troubleshooting tips for .NET agent IIS exception error With IIS, you may receive an InvalidOperationException that states: Post cache substitution is not compatible with modules in the IIS integrated pipeline that modify the response buffers. Copy To solve this problem, you must manually implement the Browser agent: Set browserMonitoring to false in newrelic.config, and follow the manual instrumentation procedures. Razor framework error With the Razor framework, you may encounter the following message: Parser Error Message: \"\").pop().split(\"\" is not valid at the start of a code block. Only identifiers, keywords, comments, \"(\" and \"{\" are valid. Copy To solve this problem, follow the Browser troubleshooting procedures for Razor frameworks.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 79.93087,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No Browser data appears (.<em>NET</em>)",
        "sections": "No Browser data appears (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem After generating traffic and waiting five minutes, you do not see any browser monitoring data for your .<em>NET</em> app. Solution To <em>troubleshoot</em> missing data: Make sure you have installed the latest release of the .<em>NET</em> <em>agent</em>. Follow the <em>troubleshooting</em> procedures for missing data as applicable"
      },
      "id": "6043f856e7b9d202d65799b5"
    },
    {
      "sections": [
        ".NET agent reports handled errors",
        "Problem",
        "Solution",
        "GetResponse() throws an error",
        "Define a custom instrumentation file",
        "Wrap the method in a custom transaction",
        "Cause"
      ],
      "title": ".NET agent reports handled errors",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "5cd50fdec02b9d8e48348c183e786eac54c312e8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/net-agent-reports-handled-errors/",
      "published_at": "2021-06-02T16:49:23Z",
      "updated_at": "2021-04-29T00:18:04Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem New Relic's .NET agent reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception handler. Instrument the target method by defining a custom instrumentation file, or by wrapping the method in a custom transaction, as shown in this example: GetResponse() throws an error In this example, New Relic reports an error from GetResponse() unless the method Foo() is instrumented. As long is Foo is instrumented, New Relic begins a transaction when Foo is called and ends the transaction when Foo ends. Because the error is handled before Foo ends, New Relic will not report an error. Note also that GetResponse() becomes a segment of the Foo transaction. using System; using System.Collections.Generic; using System.Threading; using System.Threading.Tasks; using System.Net; using System.IO; namespace ErrorTester { class Program { static void Main(string[] args) { var i = 0; while (true) { Foo(++i); } } static void Foo(int i) { try { GetNotFound(); } catch (Exception ex) { Console.WriteLine(\"Got it \" + i + \"!\"); Thread.Sleep(1000); } } static string GetNotFound() { string uri = \"http://localhost/Test/this/is/not/a/real/page\"; var request = (HttpWebRequest)WebRequest.Create(uri); var response = request.GetResponse(); var data = new StreamReader(response.GetResponseStream()).ReadToEnd(); response.Close(); return data; } } } Copy Define a custom instrumentation file To instrument Foo: Define a custom instrumentation file; for example, CustomInstrumentation.xml: <?xml version=\"1.0\" encoding=\"utf-8\"?> <!-- © 2008-2014 New Relic, Inc. All rights reserved. --> <!-- When you edit this file, please use an XML aware editor (such as Visual Studio), and pair with the companion file extension.xsd to minimize the chance of introducing typos that may confuse the agent when it is run. --> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory > <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Place CustomInstrumenation.xml in the New Relic extensions folder, alongside CoreInstrumentation.xml, and restart your application. Wrap the method in a custom transaction To instrument Foo, wrap it in a custom transaction: <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Background/Task\"> <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Cause The only errors New Relic's .NET agent reports are unhandled errors that end a transaction. If your app calls an exception handler before the transaction ends, New Relic will not report an error. However, New Relic does not always detect exception handlers when the error occurs outside of a web transaction, WCF transaction, or custom transaction. This is because the agent creates \"mini-transactions\" for instrumented methods that are not associated with a transaction. When the instrumented method exits, the mini-transaction ends. If the mini-transaction throws an error and the instrumented method does not handle it, then New Relic will report an error. You can see this in a console app that calls GetResponse(), as shown in the example. If GetResponse throws an error, then New Relic will report it, even though GetResponse() is called within a try/catch block. The agent reports an error because the GetResponse() \"mini-transaction\" ended and the error was still unhandled on transaction exit.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 78.57179,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> reports handled errors",
        "sections": ".<em>NET</em> <em>agent</em> reports handled errors",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem New Relic&#x27;s .<em>NET</em> <em>agent</em> reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception"
      },
      "id": "603e910028ccbcc7c0eba7b4"
    }
  ],
  "/docs/agents/net-agent/troubleshooting/azure-pipelines-wipes-out-newrelicazurewebsitesextension-directories": [
    {
      "sections": [
        "Generate logs for troubleshooting (.NET)",
        "Generate log files",
        "Important",
        "Generate Azure Web App log files",
        "Collect system information",
        "Check permissions",
        "For more help"
      ],
      "title": "Generate logs for troubleshooting (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "3f0c136f4228951c3d2f4bfa1f28e5331b5fa5ca",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/generate-logs-troubleshooting-net/",
      "published_at": "2021-06-02T16:17:55Z",
      "updated_at": "2021-03-16T13:04:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent stores two types of log files in the Logs directory at %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. Both are needed for troubleshooting; for example, if no data appears in the New Relic UI for your app. If either log type is missing, some component of the .NET agent did not start. Agent logs: These file names begin with newrelic_agent_. Profiler logs: These file names begin with NewRelic.Profiler. Generate log files Important When troubleshooting your New Relic .NET agent, ensure it has been configured to generate debug level log files, and monitor the size of your log file closely. Logging at debug generates a lot of data very quickly. After reproducing your problem, return the log level to info. If your C:\\ProgramData\\New Relic\\.NET Agent is in a hidden folder, update your Windows settings so that you can see it. To generate New Relic for .NET log files: Open newrelic.config, usually located in C:\\ProgramData\\New Relic\\.NET Agent (or %ALLUSERSPROFILE%\\New Relic\\.NET Agent). Change the <log level=\"info\" /> setting to <log level=\"debug\" />. Save and close the file, then wait a few minutes for the agent to read the new settings. Generate a few minutes of traffic to your app. If sending your log file to New Relic Support: In your New Relic support ticket, attach the newrelic.config file (not the text of the file), and attach the entire Logs folder from C:\\ProgramData\\New Relic\\.NET Agent\\Logs or from %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. In newrelic.config, change <log level=\"debug\" /> to <log level=\"info\" />. Generate Azure Web App log files Kudu Console manages Microsoft Azure Web App log reporting. To use the Kudu Console, first log into Azure. Navigate to the URL of your Azure Web app; for example: https://example.azurewebsites.net Copy Insert the Kudu Console URL scmsnippet into the URL; for example: https://example.scm.azurewebsites.net Copy Check for the Kudu logo with a black navigation bar at the top left of the page and your Azure username at the top right of the page. Then, to change the log level within the Kudu Console: From the Kudu Console navigation bar, select the Debug console menu, then select either CMD or PowerShell. Navigate to D:\\home\\site\\wwwroot\\newrelic. To edit newrelic.config, select the pencil icon. Change <log level=\"info\"> to <log level=\"debug\"> Save the change to newrelic.config. Wait a few minutes for the debug logs to be generated. Use the same steps to switch the log level back to info. Collect system information In addition to agent logs, a Microsoft System Information file is also useful for troubleshooting: From the Windows task bar, select Start > Run and enter msinfo32. Select OK. After the system information page loads, select File > Save. Wait a few minutes for the server to save the file. Attach the file to your New Relic support ticket. Check permissions Sometimes the .NET agent will start but not be able to write to its logs because it does not have the necessary permissions to create the log directory and log files. Permissions management varies by environment, so you will need to work with your system administrator to verify that this is not an issue. For more help For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 83.135345,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate logs for <em>troubleshooting</em> (.<em>NET</em>)",
        "sections": "Generate logs for <em>troubleshooting</em> (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> stores two types of log files in the Logs directory at %ALLUSERSPROFILE%\\New Relic\\.<em>NET</em> <em>Agent</em>\\Logs. Both are needed for <em>troubleshooting</em>; for example, if no data appears in the New Relic UI for your app. If either log type is missing, some component of the .<em>NET</em> <em>agent</em> did"
      },
      "id": "603eb5da196a67556aa83dd8"
    },
    {
      "sections": [
        "No Browser data appears (.NET)",
        "Problem",
        "Solution"
      ],
      "title": "No Browser data appears (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "61a0ca0687aa9ebea7c0ce8d99e38822db0eb1cd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/no-browser-data-appears-net/",
      "published_at": "2021-06-02T16:50:18Z",
      "updated_at": "2021-03-11T02:34:52Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem After generating traffic and waiting five minutes, you do not see any browser monitoring data for your .NET app. Solution To troubleshoot missing data: Make sure you have installed the latest release of the .NET agent. Follow the troubleshooting procedures for missing data as applicable. Verify whether your pages are rendered using ASPs. If you use another rendering technology, use manual instrumentation. Flush your .NET cache. Set the <head> tag of your pages to render on the server. Verify that your agent is configured to auto-instrument pages. Edit newrelic.config and verify that autoInstrument is set to true: <browserMonitoring autoInstrument=\"true\"/> Copy Check whether IIS page compression is disabled. If compressed before the .NET agent attempts browser instrumentation, the necessary <HEAD> tag won't be found. For instructions on how to check that, see Microsoft documentation. Look at the source of one of your pages through a browser. Look for a script with references to NREUMQ at the top and bottom of your pages. If you get support at support.newrelic.com, mention whether you are seeing this JavaScript in the page header or in some other location in the page, or you are not seeing it at all. Here are some additional troubleshooting tips: Browser problems Additional troubleshooting tips for .NET agent IIS exception error With IIS, you may receive an InvalidOperationException that states: Post cache substitution is not compatible with modules in the IIS integrated pipeline that modify the response buffers. Copy To solve this problem, you must manually implement the Browser agent: Set browserMonitoring to false in newrelic.config, and follow the manual instrumentation procedures. Razor framework error With the Razor framework, you may encounter the following message: Parser Error Message: \"\").pop().split(\"\" is not valid at the start of a code block. Only identifiers, keywords, comments, \"(\" and \"{\" are valid. Copy To solve this problem, follow the Browser troubleshooting procedures for Razor frameworks.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 79.93087,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No Browser data appears (.<em>NET</em>)",
        "sections": "No Browser data appears (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem After generating traffic and waiting five minutes, you do not see any browser monitoring data for your .<em>NET</em> app. Solution To <em>troubleshoot</em> missing data: Make sure you have installed the latest release of the .<em>NET</em> <em>agent</em>. Follow the <em>troubleshooting</em> procedures for missing data as applicable"
      },
      "id": "6043f856e7b9d202d65799b5"
    },
    {
      "sections": [
        ".NET agent reports handled errors",
        "Problem",
        "Solution",
        "GetResponse() throws an error",
        "Define a custom instrumentation file",
        "Wrap the method in a custom transaction",
        "Cause"
      ],
      "title": ".NET agent reports handled errors",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "5cd50fdec02b9d8e48348c183e786eac54c312e8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/net-agent-reports-handled-errors/",
      "published_at": "2021-06-02T16:49:23Z",
      "updated_at": "2021-04-29T00:18:04Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem New Relic's .NET agent reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception handler. Instrument the target method by defining a custom instrumentation file, or by wrapping the method in a custom transaction, as shown in this example: GetResponse() throws an error In this example, New Relic reports an error from GetResponse() unless the method Foo() is instrumented. As long is Foo is instrumented, New Relic begins a transaction when Foo is called and ends the transaction when Foo ends. Because the error is handled before Foo ends, New Relic will not report an error. Note also that GetResponse() becomes a segment of the Foo transaction. using System; using System.Collections.Generic; using System.Threading; using System.Threading.Tasks; using System.Net; using System.IO; namespace ErrorTester { class Program { static void Main(string[] args) { var i = 0; while (true) { Foo(++i); } } static void Foo(int i) { try { GetNotFound(); } catch (Exception ex) { Console.WriteLine(\"Got it \" + i + \"!\"); Thread.Sleep(1000); } } static string GetNotFound() { string uri = \"http://localhost/Test/this/is/not/a/real/page\"; var request = (HttpWebRequest)WebRequest.Create(uri); var response = request.GetResponse(); var data = new StreamReader(response.GetResponseStream()).ReadToEnd(); response.Close(); return data; } } } Copy Define a custom instrumentation file To instrument Foo: Define a custom instrumentation file; for example, CustomInstrumentation.xml: <?xml version=\"1.0\" encoding=\"utf-8\"?> <!-- © 2008-2014 New Relic, Inc. All rights reserved. --> <!-- When you edit this file, please use an XML aware editor (such as Visual Studio), and pair with the companion file extension.xsd to minimize the chance of introducing typos that may confuse the agent when it is run. --> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory > <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Place CustomInstrumenation.xml in the New Relic extensions folder, alongside CoreInstrumentation.xml, and restart your application. Wrap the method in a custom transaction To instrument Foo, wrap it in a custom transaction: <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Background/Task\"> <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Cause The only errors New Relic's .NET agent reports are unhandled errors that end a transaction. If your app calls an exception handler before the transaction ends, New Relic will not report an error. However, New Relic does not always detect exception handlers when the error occurs outside of a web transaction, WCF transaction, or custom transaction. This is because the agent creates \"mini-transactions\" for instrumented methods that are not associated with a transaction. When the instrumented method exits, the mini-transaction ends. If the mini-transaction throws an error and the instrumented method does not handle it, then New Relic will report an error. You can see this in a console app that calls GetResponse(), as shown in the example. If GetResponse throws an error, then New Relic will report it, even though GetResponse() is called within a try/catch block. The agent reports an error because the GetResponse() \"mini-transaction\" ended and the error was still unhandled on transaction exit.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 78.571785,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> reports handled errors",
        "sections": ".<em>NET</em> <em>agent</em> reports handled errors",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem New Relic&#x27;s .<em>NET</em> <em>agent</em> reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception"
      },
      "id": "603e910028ccbcc7c0eba7b4"
    }
  ],
  "/docs/agents/net-agent/troubleshooting/browser-injection-health-check-conflict": [
    {
      "sections": [
        "Generate logs for troubleshooting (.NET)",
        "Generate log files",
        "Important",
        "Generate Azure Web App log files",
        "Collect system information",
        "Check permissions",
        "For more help"
      ],
      "title": "Generate logs for troubleshooting (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "3f0c136f4228951c3d2f4bfa1f28e5331b5fa5ca",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/generate-logs-troubleshooting-net/",
      "published_at": "2021-06-02T16:17:55Z",
      "updated_at": "2021-03-16T13:04:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent stores two types of log files in the Logs directory at %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. Both are needed for troubleshooting; for example, if no data appears in the New Relic UI for your app. If either log type is missing, some component of the .NET agent did not start. Agent logs: These file names begin with newrelic_agent_. Profiler logs: These file names begin with NewRelic.Profiler. Generate log files Important When troubleshooting your New Relic .NET agent, ensure it has been configured to generate debug level log files, and monitor the size of your log file closely. Logging at debug generates a lot of data very quickly. After reproducing your problem, return the log level to info. If your C:\\ProgramData\\New Relic\\.NET Agent is in a hidden folder, update your Windows settings so that you can see it. To generate New Relic for .NET log files: Open newrelic.config, usually located in C:\\ProgramData\\New Relic\\.NET Agent (or %ALLUSERSPROFILE%\\New Relic\\.NET Agent). Change the <log level=\"info\" /> setting to <log level=\"debug\" />. Save and close the file, then wait a few minutes for the agent to read the new settings. Generate a few minutes of traffic to your app. If sending your log file to New Relic Support: In your New Relic support ticket, attach the newrelic.config file (not the text of the file), and attach the entire Logs folder from C:\\ProgramData\\New Relic\\.NET Agent\\Logs or from %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. In newrelic.config, change <log level=\"debug\" /> to <log level=\"info\" />. Generate Azure Web App log files Kudu Console manages Microsoft Azure Web App log reporting. To use the Kudu Console, first log into Azure. Navigate to the URL of your Azure Web app; for example: https://example.azurewebsites.net Copy Insert the Kudu Console URL scmsnippet into the URL; for example: https://example.scm.azurewebsites.net Copy Check for the Kudu logo with a black navigation bar at the top left of the page and your Azure username at the top right of the page. Then, to change the log level within the Kudu Console: From the Kudu Console navigation bar, select the Debug console menu, then select either CMD or PowerShell. Navigate to D:\\home\\site\\wwwroot\\newrelic. To edit newrelic.config, select the pencil icon. Change <log level=\"info\"> to <log level=\"debug\"> Save the change to newrelic.config. Wait a few minutes for the debug logs to be generated. Use the same steps to switch the log level back to info. Collect system information In addition to agent logs, a Microsoft System Information file is also useful for troubleshooting: From the Windows task bar, select Start > Run and enter msinfo32. Select OK. After the system information page loads, select File > Save. Wait a few minutes for the server to save the file. Attach the file to your New Relic support ticket. Check permissions Sometimes the .NET agent will start but not be able to write to its logs because it does not have the necessary permissions to create the log directory and log files. Permissions management varies by environment, so you will need to work with your system administrator to verify that this is not an issue. For more help For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 83.135345,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate logs for <em>troubleshooting</em> (.<em>NET</em>)",
        "sections": "Generate logs for <em>troubleshooting</em> (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> stores two types of log files in the Logs directory at %ALLUSERSPROFILE%\\New Relic\\.<em>NET</em> <em>Agent</em>\\Logs. Both are needed for <em>troubleshooting</em>; for example, if no data appears in the New Relic UI for your app. If either log type is missing, some component of the .<em>NET</em> <em>agent</em> did"
      },
      "id": "603eb5da196a67556aa83dd8"
    },
    {
      "sections": [
        "No Browser data appears (.NET)",
        "Problem",
        "Solution"
      ],
      "title": "No Browser data appears (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "61a0ca0687aa9ebea7c0ce8d99e38822db0eb1cd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/no-browser-data-appears-net/",
      "published_at": "2021-06-02T16:50:18Z",
      "updated_at": "2021-03-11T02:34:52Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem After generating traffic and waiting five minutes, you do not see any browser monitoring data for your .NET app. Solution To troubleshoot missing data: Make sure you have installed the latest release of the .NET agent. Follow the troubleshooting procedures for missing data as applicable. Verify whether your pages are rendered using ASPs. If you use another rendering technology, use manual instrumentation. Flush your .NET cache. Set the <head> tag of your pages to render on the server. Verify that your agent is configured to auto-instrument pages. Edit newrelic.config and verify that autoInstrument is set to true: <browserMonitoring autoInstrument=\"true\"/> Copy Check whether IIS page compression is disabled. If compressed before the .NET agent attempts browser instrumentation, the necessary <HEAD> tag won't be found. For instructions on how to check that, see Microsoft documentation. Look at the source of one of your pages through a browser. Look for a script with references to NREUMQ at the top and bottom of your pages. If you get support at support.newrelic.com, mention whether you are seeing this JavaScript in the page header or in some other location in the page, or you are not seeing it at all. Here are some additional troubleshooting tips: Browser problems Additional troubleshooting tips for .NET agent IIS exception error With IIS, you may receive an InvalidOperationException that states: Post cache substitution is not compatible with modules in the IIS integrated pipeline that modify the response buffers. Copy To solve this problem, you must manually implement the Browser agent: Set browserMonitoring to false in newrelic.config, and follow the manual instrumentation procedures. Razor framework error With the Razor framework, you may encounter the following message: Parser Error Message: \"\").pop().split(\"\" is not valid at the start of a code block. Only identifiers, keywords, comments, \"(\" and \"{\" are valid. Copy To solve this problem, follow the Browser troubleshooting procedures for Razor frameworks.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 79.93087,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No Browser data appears (.<em>NET</em>)",
        "sections": "No Browser data appears (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem After generating traffic and waiting five minutes, you do not see any browser monitoring data for your .<em>NET</em> app. Solution To <em>troubleshoot</em> missing data: Make sure you have installed the latest release of the .<em>NET</em> <em>agent</em>. Follow the <em>troubleshooting</em> procedures for missing data as applicable"
      },
      "id": "6043f856e7b9d202d65799b5"
    },
    {
      "sections": [
        ".NET agent reports handled errors",
        "Problem",
        "Solution",
        "GetResponse() throws an error",
        "Define a custom instrumentation file",
        "Wrap the method in a custom transaction",
        "Cause"
      ],
      "title": ".NET agent reports handled errors",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "5cd50fdec02b9d8e48348c183e786eac54c312e8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/net-agent-reports-handled-errors/",
      "published_at": "2021-06-02T16:49:23Z",
      "updated_at": "2021-04-29T00:18:04Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem New Relic's .NET agent reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception handler. Instrument the target method by defining a custom instrumentation file, or by wrapping the method in a custom transaction, as shown in this example: GetResponse() throws an error In this example, New Relic reports an error from GetResponse() unless the method Foo() is instrumented. As long is Foo is instrumented, New Relic begins a transaction when Foo is called and ends the transaction when Foo ends. Because the error is handled before Foo ends, New Relic will not report an error. Note also that GetResponse() becomes a segment of the Foo transaction. using System; using System.Collections.Generic; using System.Threading; using System.Threading.Tasks; using System.Net; using System.IO; namespace ErrorTester { class Program { static void Main(string[] args) { var i = 0; while (true) { Foo(++i); } } static void Foo(int i) { try { GetNotFound(); } catch (Exception ex) { Console.WriteLine(\"Got it \" + i + \"!\"); Thread.Sleep(1000); } } static string GetNotFound() { string uri = \"http://localhost/Test/this/is/not/a/real/page\"; var request = (HttpWebRequest)WebRequest.Create(uri); var response = request.GetResponse(); var data = new StreamReader(response.GetResponseStream()).ReadToEnd(); response.Close(); return data; } } } Copy Define a custom instrumentation file To instrument Foo: Define a custom instrumentation file; for example, CustomInstrumentation.xml: <?xml version=\"1.0\" encoding=\"utf-8\"?> <!-- © 2008-2014 New Relic, Inc. All rights reserved. --> <!-- When you edit this file, please use an XML aware editor (such as Visual Studio), and pair with the companion file extension.xsd to minimize the chance of introducing typos that may confuse the agent when it is run. --> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory > <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Place CustomInstrumenation.xml in the New Relic extensions folder, alongside CoreInstrumentation.xml, and restart your application. Wrap the method in a custom transaction To instrument Foo, wrap it in a custom transaction: <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Background/Task\"> <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Cause The only errors New Relic's .NET agent reports are unhandled errors that end a transaction. If your app calls an exception handler before the transaction ends, New Relic will not report an error. However, New Relic does not always detect exception handlers when the error occurs outside of a web transaction, WCF transaction, or custom transaction. This is because the agent creates \"mini-transactions\" for instrumented methods that are not associated with a transaction. When the instrumented method exits, the mini-transaction ends. If the mini-transaction throws an error and the instrumented method does not handle it, then New Relic will report an error. You can see this in a console app that calls GetResponse(), as shown in the example. If GetResponse throws an error, then New Relic will report it, even though GetResponse() is called within a try/catch block. The agent reports an error because the GetResponse() \"mini-transaction\" ended and the error was still unhandled on transaction exit.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 78.571785,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> reports handled errors",
        "sections": ".<em>NET</em> <em>agent</em> reports handled errors",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem New Relic&#x27;s .<em>NET</em> <em>agent</em> reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception"
      },
      "id": "603e910028ccbcc7c0eba7b4"
    }
  ],
  "/docs/agents/net-agent/troubleshooting/cocreate-errors-no-event-log": [
    {
      "sections": [
        "Generate logs for troubleshooting (.NET)",
        "Generate log files",
        "Important",
        "Generate Azure Web App log files",
        "Collect system information",
        "Check permissions",
        "For more help"
      ],
      "title": "Generate logs for troubleshooting (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "3f0c136f4228951c3d2f4bfa1f28e5331b5fa5ca",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/generate-logs-troubleshooting-net/",
      "published_at": "2021-06-02T16:17:55Z",
      "updated_at": "2021-03-16T13:04:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent stores two types of log files in the Logs directory at %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. Both are needed for troubleshooting; for example, if no data appears in the New Relic UI for your app. If either log type is missing, some component of the .NET agent did not start. Agent logs: These file names begin with newrelic_agent_. Profiler logs: These file names begin with NewRelic.Profiler. Generate log files Important When troubleshooting your New Relic .NET agent, ensure it has been configured to generate debug level log files, and monitor the size of your log file closely. Logging at debug generates a lot of data very quickly. After reproducing your problem, return the log level to info. If your C:\\ProgramData\\New Relic\\.NET Agent is in a hidden folder, update your Windows settings so that you can see it. To generate New Relic for .NET log files: Open newrelic.config, usually located in C:\\ProgramData\\New Relic\\.NET Agent (or %ALLUSERSPROFILE%\\New Relic\\.NET Agent). Change the <log level=\"info\" /> setting to <log level=\"debug\" />. Save and close the file, then wait a few minutes for the agent to read the new settings. Generate a few minutes of traffic to your app. If sending your log file to New Relic Support: In your New Relic support ticket, attach the newrelic.config file (not the text of the file), and attach the entire Logs folder from C:\\ProgramData\\New Relic\\.NET Agent\\Logs or from %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. In newrelic.config, change <log level=\"debug\" /> to <log level=\"info\" />. Generate Azure Web App log files Kudu Console manages Microsoft Azure Web App log reporting. To use the Kudu Console, first log into Azure. Navigate to the URL of your Azure Web app; for example: https://example.azurewebsites.net Copy Insert the Kudu Console URL scmsnippet into the URL; for example: https://example.scm.azurewebsites.net Copy Check for the Kudu logo with a black navigation bar at the top left of the page and your Azure username at the top right of the page. Then, to change the log level within the Kudu Console: From the Kudu Console navigation bar, select the Debug console menu, then select either CMD or PowerShell. Navigate to D:\\home\\site\\wwwroot\\newrelic. To edit newrelic.config, select the pencil icon. Change <log level=\"info\"> to <log level=\"debug\"> Save the change to newrelic.config. Wait a few minutes for the debug logs to be generated. Use the same steps to switch the log level back to info. Collect system information In addition to agent logs, a Microsoft System Information file is also useful for troubleshooting: From the Windows task bar, select Start > Run and enter msinfo32. Select OK. After the system information page loads, select File > Save. Wait a few minutes for the server to save the file. Attach the file to your New Relic support ticket. Check permissions Sometimes the .NET agent will start but not be able to write to its logs because it does not have the necessary permissions to create the log directory and log files. Permissions management varies by environment, so you will need to work with your system administrator to verify that this is not an issue. For more help For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 83.135345,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate logs for <em>troubleshooting</em> (.<em>NET</em>)",
        "sections": "Generate logs for <em>troubleshooting</em> (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> stores two types of log files in the Logs directory at %ALLUSERSPROFILE%\\New Relic\\.<em>NET</em> <em>Agent</em>\\Logs. Both are needed for <em>troubleshooting</em>; for example, if no data appears in the New Relic UI for your app. If either log type is missing, some component of the .<em>NET</em> <em>agent</em> did"
      },
      "id": "603eb5da196a67556aa83dd8"
    },
    {
      "sections": [
        "No Browser data appears (.NET)",
        "Problem",
        "Solution"
      ],
      "title": "No Browser data appears (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "61a0ca0687aa9ebea7c0ce8d99e38822db0eb1cd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/no-browser-data-appears-net/",
      "published_at": "2021-06-02T16:50:18Z",
      "updated_at": "2021-03-11T02:34:52Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem After generating traffic and waiting five minutes, you do not see any browser monitoring data for your .NET app. Solution To troubleshoot missing data: Make sure you have installed the latest release of the .NET agent. Follow the troubleshooting procedures for missing data as applicable. Verify whether your pages are rendered using ASPs. If you use another rendering technology, use manual instrumentation. Flush your .NET cache. Set the <head> tag of your pages to render on the server. Verify that your agent is configured to auto-instrument pages. Edit newrelic.config and verify that autoInstrument is set to true: <browserMonitoring autoInstrument=\"true\"/> Copy Check whether IIS page compression is disabled. If compressed before the .NET agent attempts browser instrumentation, the necessary <HEAD> tag won't be found. For instructions on how to check that, see Microsoft documentation. Look at the source of one of your pages through a browser. Look for a script with references to NREUMQ at the top and bottom of your pages. If you get support at support.newrelic.com, mention whether you are seeing this JavaScript in the page header or in some other location in the page, or you are not seeing it at all. Here are some additional troubleshooting tips: Browser problems Additional troubleshooting tips for .NET agent IIS exception error With IIS, you may receive an InvalidOperationException that states: Post cache substitution is not compatible with modules in the IIS integrated pipeline that modify the response buffers. Copy To solve this problem, you must manually implement the Browser agent: Set browserMonitoring to false in newrelic.config, and follow the manual instrumentation procedures. Razor framework error With the Razor framework, you may encounter the following message: Parser Error Message: \"\").pop().split(\"\" is not valid at the start of a code block. Only identifiers, keywords, comments, \"(\" and \"{\" are valid. Copy To solve this problem, follow the Browser troubleshooting procedures for Razor frameworks.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 79.93087,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No Browser data appears (.<em>NET</em>)",
        "sections": "No Browser data appears (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem After generating traffic and waiting five minutes, you do not see any browser monitoring data for your .<em>NET</em> app. Solution To <em>troubleshoot</em> missing data: Make sure you have installed the latest release of the .<em>NET</em> <em>agent</em>. Follow the <em>troubleshooting</em> procedures for missing data as applicable"
      },
      "id": "6043f856e7b9d202d65799b5"
    },
    {
      "sections": [
        ".NET agent reports handled errors",
        "Problem",
        "Solution",
        "GetResponse() throws an error",
        "Define a custom instrumentation file",
        "Wrap the method in a custom transaction",
        "Cause"
      ],
      "title": ".NET agent reports handled errors",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "5cd50fdec02b9d8e48348c183e786eac54c312e8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/net-agent-reports-handled-errors/",
      "published_at": "2021-06-02T16:49:23Z",
      "updated_at": "2021-04-29T00:18:04Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem New Relic's .NET agent reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception handler. Instrument the target method by defining a custom instrumentation file, or by wrapping the method in a custom transaction, as shown in this example: GetResponse() throws an error In this example, New Relic reports an error from GetResponse() unless the method Foo() is instrumented. As long is Foo is instrumented, New Relic begins a transaction when Foo is called and ends the transaction when Foo ends. Because the error is handled before Foo ends, New Relic will not report an error. Note also that GetResponse() becomes a segment of the Foo transaction. using System; using System.Collections.Generic; using System.Threading; using System.Threading.Tasks; using System.Net; using System.IO; namespace ErrorTester { class Program { static void Main(string[] args) { var i = 0; while (true) { Foo(++i); } } static void Foo(int i) { try { GetNotFound(); } catch (Exception ex) { Console.WriteLine(\"Got it \" + i + \"!\"); Thread.Sleep(1000); } } static string GetNotFound() { string uri = \"http://localhost/Test/this/is/not/a/real/page\"; var request = (HttpWebRequest)WebRequest.Create(uri); var response = request.GetResponse(); var data = new StreamReader(response.GetResponseStream()).ReadToEnd(); response.Close(); return data; } } } Copy Define a custom instrumentation file To instrument Foo: Define a custom instrumentation file; for example, CustomInstrumentation.xml: <?xml version=\"1.0\" encoding=\"utf-8\"?> <!-- © 2008-2014 New Relic, Inc. All rights reserved. --> <!-- When you edit this file, please use an XML aware editor (such as Visual Studio), and pair with the companion file extension.xsd to minimize the chance of introducing typos that may confuse the agent when it is run. --> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory > <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Place CustomInstrumenation.xml in the New Relic extensions folder, alongside CoreInstrumentation.xml, and restart your application. Wrap the method in a custom transaction To instrument Foo, wrap it in a custom transaction: <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Background/Task\"> <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Cause The only errors New Relic's .NET agent reports are unhandled errors that end a transaction. If your app calls an exception handler before the transaction ends, New Relic will not report an error. However, New Relic does not always detect exception handlers when the error occurs outside of a web transaction, WCF transaction, or custom transaction. This is because the agent creates \"mini-transactions\" for instrumented methods that are not associated with a transaction. When the instrumented method exits, the mini-transaction ends. If the mini-transaction throws an error and the instrumented method does not handle it, then New Relic will report an error. You can see this in a console app that calls GetResponse(), as shown in the example. If GetResponse throws an error, then New Relic will report it, even though GetResponse() is called within a try/catch block. The agent reports an error because the GetResponse() \"mini-transaction\" ended and the error was still unhandled on transaction exit.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 78.571785,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> reports handled errors",
        "sections": ".<em>NET</em> <em>agent</em> reports handled errors",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem New Relic&#x27;s .<em>NET</em> <em>agent</em> reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception"
      },
      "id": "603e910028ccbcc7c0eba7b4"
    }
  ],
  "/docs/agents/net-agent/troubleshooting/cocreateinstance-errors-no-profiler-log": [
    {
      "sections": [
        "Generate logs for troubleshooting (.NET)",
        "Generate log files",
        "Important",
        "Generate Azure Web App log files",
        "Collect system information",
        "Check permissions",
        "For more help"
      ],
      "title": "Generate logs for troubleshooting (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "3f0c136f4228951c3d2f4bfa1f28e5331b5fa5ca",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/generate-logs-troubleshooting-net/",
      "published_at": "2021-06-02T16:17:55Z",
      "updated_at": "2021-03-16T13:04:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent stores two types of log files in the Logs directory at %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. Both are needed for troubleshooting; for example, if no data appears in the New Relic UI for your app. If either log type is missing, some component of the .NET agent did not start. Agent logs: These file names begin with newrelic_agent_. Profiler logs: These file names begin with NewRelic.Profiler. Generate log files Important When troubleshooting your New Relic .NET agent, ensure it has been configured to generate debug level log files, and monitor the size of your log file closely. Logging at debug generates a lot of data very quickly. After reproducing your problem, return the log level to info. If your C:\\ProgramData\\New Relic\\.NET Agent is in a hidden folder, update your Windows settings so that you can see it. To generate New Relic for .NET log files: Open newrelic.config, usually located in C:\\ProgramData\\New Relic\\.NET Agent (or %ALLUSERSPROFILE%\\New Relic\\.NET Agent). Change the <log level=\"info\" /> setting to <log level=\"debug\" />. Save and close the file, then wait a few minutes for the agent to read the new settings. Generate a few minutes of traffic to your app. If sending your log file to New Relic Support: In your New Relic support ticket, attach the newrelic.config file (not the text of the file), and attach the entire Logs folder from C:\\ProgramData\\New Relic\\.NET Agent\\Logs or from %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. In newrelic.config, change <log level=\"debug\" /> to <log level=\"info\" />. Generate Azure Web App log files Kudu Console manages Microsoft Azure Web App log reporting. To use the Kudu Console, first log into Azure. Navigate to the URL of your Azure Web app; for example: https://example.azurewebsites.net Copy Insert the Kudu Console URL scmsnippet into the URL; for example: https://example.scm.azurewebsites.net Copy Check for the Kudu logo with a black navigation bar at the top left of the page and your Azure username at the top right of the page. Then, to change the log level within the Kudu Console: From the Kudu Console navigation bar, select the Debug console menu, then select either CMD or PowerShell. Navigate to D:\\home\\site\\wwwroot\\newrelic. To edit newrelic.config, select the pencil icon. Change <log level=\"info\"> to <log level=\"debug\"> Save the change to newrelic.config. Wait a few minutes for the debug logs to be generated. Use the same steps to switch the log level back to info. Collect system information In addition to agent logs, a Microsoft System Information file is also useful for troubleshooting: From the Windows task bar, select Start > Run and enter msinfo32. Select OK. After the system information page loads, select File > Save. Wait a few minutes for the server to save the file. Attach the file to your New Relic support ticket. Check permissions Sometimes the .NET agent will start but not be able to write to its logs because it does not have the necessary permissions to create the log directory and log files. Permissions management varies by environment, so you will need to work with your system administrator to verify that this is not an issue. For more help For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 83.13534,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate logs for <em>troubleshooting</em> (.<em>NET</em>)",
        "sections": "Generate logs for <em>troubleshooting</em> (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> stores two types of log files in the Logs directory at %ALLUSERSPROFILE%\\New Relic\\.<em>NET</em> <em>Agent</em>\\Logs. Both are needed for <em>troubleshooting</em>; for example, if no data appears in the New Relic UI for your app. If either log type is missing, some component of the .<em>NET</em> <em>agent</em> did"
      },
      "id": "603eb5da196a67556aa83dd8"
    },
    {
      "sections": [
        "No Browser data appears (.NET)",
        "Problem",
        "Solution"
      ],
      "title": "No Browser data appears (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "61a0ca0687aa9ebea7c0ce8d99e38822db0eb1cd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/no-browser-data-appears-net/",
      "published_at": "2021-06-02T16:50:18Z",
      "updated_at": "2021-03-11T02:34:52Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem After generating traffic and waiting five minutes, you do not see any browser monitoring data for your .NET app. Solution To troubleshoot missing data: Make sure you have installed the latest release of the .NET agent. Follow the troubleshooting procedures for missing data as applicable. Verify whether your pages are rendered using ASPs. If you use another rendering technology, use manual instrumentation. Flush your .NET cache. Set the <head> tag of your pages to render on the server. Verify that your agent is configured to auto-instrument pages. Edit newrelic.config and verify that autoInstrument is set to true: <browserMonitoring autoInstrument=\"true\"/> Copy Check whether IIS page compression is disabled. If compressed before the .NET agent attempts browser instrumentation, the necessary <HEAD> tag won't be found. For instructions on how to check that, see Microsoft documentation. Look at the source of one of your pages through a browser. Look for a script with references to NREUMQ at the top and bottom of your pages. If you get support at support.newrelic.com, mention whether you are seeing this JavaScript in the page header or in some other location in the page, or you are not seeing it at all. Here are some additional troubleshooting tips: Browser problems Additional troubleshooting tips for .NET agent IIS exception error With IIS, you may receive an InvalidOperationException that states: Post cache substitution is not compatible with modules in the IIS integrated pipeline that modify the response buffers. Copy To solve this problem, you must manually implement the Browser agent: Set browserMonitoring to false in newrelic.config, and follow the manual instrumentation procedures. Razor framework error With the Razor framework, you may encounter the following message: Parser Error Message: \"\").pop().split(\"\" is not valid at the start of a code block. Only identifiers, keywords, comments, \"(\" and \"{\" are valid. Copy To solve this problem, follow the Browser troubleshooting procedures for Razor frameworks.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 79.93086,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No Browser data appears (.<em>NET</em>)",
        "sections": "No Browser data appears (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem After generating traffic and waiting five minutes, you do not see any browser monitoring data for your .<em>NET</em> app. Solution To <em>troubleshoot</em> missing data: Make sure you have installed the latest release of the .<em>NET</em> <em>agent</em>. Follow the <em>troubleshooting</em> procedures for missing data as applicable"
      },
      "id": "6043f856e7b9d202d65799b5"
    },
    {
      "sections": [
        ".NET agent reports handled errors",
        "Problem",
        "Solution",
        "GetResponse() throws an error",
        "Define a custom instrumentation file",
        "Wrap the method in a custom transaction",
        "Cause"
      ],
      "title": ".NET agent reports handled errors",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "5cd50fdec02b9d8e48348c183e786eac54c312e8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/net-agent-reports-handled-errors/",
      "published_at": "2021-06-02T16:49:23Z",
      "updated_at": "2021-04-29T00:18:04Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem New Relic's .NET agent reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception handler. Instrument the target method by defining a custom instrumentation file, or by wrapping the method in a custom transaction, as shown in this example: GetResponse() throws an error In this example, New Relic reports an error from GetResponse() unless the method Foo() is instrumented. As long is Foo is instrumented, New Relic begins a transaction when Foo is called and ends the transaction when Foo ends. Because the error is handled before Foo ends, New Relic will not report an error. Note also that GetResponse() becomes a segment of the Foo transaction. using System; using System.Collections.Generic; using System.Threading; using System.Threading.Tasks; using System.Net; using System.IO; namespace ErrorTester { class Program { static void Main(string[] args) { var i = 0; while (true) { Foo(++i); } } static void Foo(int i) { try { GetNotFound(); } catch (Exception ex) { Console.WriteLine(\"Got it \" + i + \"!\"); Thread.Sleep(1000); } } static string GetNotFound() { string uri = \"http://localhost/Test/this/is/not/a/real/page\"; var request = (HttpWebRequest)WebRequest.Create(uri); var response = request.GetResponse(); var data = new StreamReader(response.GetResponseStream()).ReadToEnd(); response.Close(); return data; } } } Copy Define a custom instrumentation file To instrument Foo: Define a custom instrumentation file; for example, CustomInstrumentation.xml: <?xml version=\"1.0\" encoding=\"utf-8\"?> <!-- © 2008-2014 New Relic, Inc. All rights reserved. --> <!-- When you edit this file, please use an XML aware editor (such as Visual Studio), and pair with the companion file extension.xsd to minimize the chance of introducing typos that may confuse the agent when it is run. --> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory > <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Place CustomInstrumenation.xml in the New Relic extensions folder, alongside CoreInstrumentation.xml, and restart your application. Wrap the method in a custom transaction To instrument Foo, wrap it in a custom transaction: <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Background/Task\"> <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Cause The only errors New Relic's .NET agent reports are unhandled errors that end a transaction. If your app calls an exception handler before the transaction ends, New Relic will not report an error. However, New Relic does not always detect exception handlers when the error occurs outside of a web transaction, WCF transaction, or custom transaction. This is because the agent creates \"mini-transactions\" for instrumented methods that are not associated with a transaction. When the instrumented method exits, the mini-transaction ends. If the mini-transaction throws an error and the instrumented method does not handle it, then New Relic will report an error. You can see this in a console app that calls GetResponse(), as shown in the example. If GetResponse throws an error, then New Relic will report it, even though GetResponse() is called within a try/catch block. The agent reports an error because the GetResponse() \"mini-transaction\" ended and the error was still unhandled on transaction exit.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 78.57178,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> reports handled errors",
        "sections": ".<em>NET</em> <em>agent</em> reports handled errors",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem New Relic&#x27;s .<em>NET</em> <em>agent</em> reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception"
      },
      "id": "603e910028ccbcc7c0eba7b4"
    }
  ],
  "/docs/agents/net-agent/troubleshooting/debugging-net-core-agent-linux": [
    {
      "sections": [
        "Generate logs for troubleshooting (.NET)",
        "Generate log files",
        "Important",
        "Generate Azure Web App log files",
        "Collect system information",
        "Check permissions",
        "For more help"
      ],
      "title": "Generate logs for troubleshooting (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "3f0c136f4228951c3d2f4bfa1f28e5331b5fa5ca",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/generate-logs-troubleshooting-net/",
      "published_at": "2021-06-02T16:17:55Z",
      "updated_at": "2021-03-16T13:04:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent stores two types of log files in the Logs directory at %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. Both are needed for troubleshooting; for example, if no data appears in the New Relic UI for your app. If either log type is missing, some component of the .NET agent did not start. Agent logs: These file names begin with newrelic_agent_. Profiler logs: These file names begin with NewRelic.Profiler. Generate log files Important When troubleshooting your New Relic .NET agent, ensure it has been configured to generate debug level log files, and monitor the size of your log file closely. Logging at debug generates a lot of data very quickly. After reproducing your problem, return the log level to info. If your C:\\ProgramData\\New Relic\\.NET Agent is in a hidden folder, update your Windows settings so that you can see it. To generate New Relic for .NET log files: Open newrelic.config, usually located in C:\\ProgramData\\New Relic\\.NET Agent (or %ALLUSERSPROFILE%\\New Relic\\.NET Agent). Change the <log level=\"info\" /> setting to <log level=\"debug\" />. Save and close the file, then wait a few minutes for the agent to read the new settings. Generate a few minutes of traffic to your app. If sending your log file to New Relic Support: In your New Relic support ticket, attach the newrelic.config file (not the text of the file), and attach the entire Logs folder from C:\\ProgramData\\New Relic\\.NET Agent\\Logs or from %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. In newrelic.config, change <log level=\"debug\" /> to <log level=\"info\" />. Generate Azure Web App log files Kudu Console manages Microsoft Azure Web App log reporting. To use the Kudu Console, first log into Azure. Navigate to the URL of your Azure Web app; for example: https://example.azurewebsites.net Copy Insert the Kudu Console URL scmsnippet into the URL; for example: https://example.scm.azurewebsites.net Copy Check for the Kudu logo with a black navigation bar at the top left of the page and your Azure username at the top right of the page. Then, to change the log level within the Kudu Console: From the Kudu Console navigation bar, select the Debug console menu, then select either CMD or PowerShell. Navigate to D:\\home\\site\\wwwroot\\newrelic. To edit newrelic.config, select the pencil icon. Change <log level=\"info\"> to <log level=\"debug\"> Save the change to newrelic.config. Wait a few minutes for the debug logs to be generated. Use the same steps to switch the log level back to info. Collect system information In addition to agent logs, a Microsoft System Information file is also useful for troubleshooting: From the Windows task bar, select Start > Run and enter msinfo32. Select OK. After the system information page loads, select File > Save. Wait a few minutes for the server to save the file. Attach the file to your New Relic support ticket. Check permissions Sometimes the .NET agent will start but not be able to write to its logs because it does not have the necessary permissions to create the log directory and log files. Permissions management varies by environment, so you will need to work with your system administrator to verify that this is not an issue. For more help For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 83.13534,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate logs for <em>troubleshooting</em> (.<em>NET</em>)",
        "sections": "Generate logs for <em>troubleshooting</em> (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> stores two types of log files in the Logs directory at %ALLUSERSPROFILE%\\New Relic\\.<em>NET</em> <em>Agent</em>\\Logs. Both are needed for <em>troubleshooting</em>; for example, if no data appears in the New Relic UI for your app. If either log type is missing, some component of the .<em>NET</em> <em>agent</em> did"
      },
      "id": "603eb5da196a67556aa83dd8"
    },
    {
      "sections": [
        "No Browser data appears (.NET)",
        "Problem",
        "Solution"
      ],
      "title": "No Browser data appears (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "61a0ca0687aa9ebea7c0ce8d99e38822db0eb1cd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/no-browser-data-appears-net/",
      "published_at": "2021-06-02T16:50:18Z",
      "updated_at": "2021-03-11T02:34:52Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem After generating traffic and waiting five minutes, you do not see any browser monitoring data for your .NET app. Solution To troubleshoot missing data: Make sure you have installed the latest release of the .NET agent. Follow the troubleshooting procedures for missing data as applicable. Verify whether your pages are rendered using ASPs. If you use another rendering technology, use manual instrumentation. Flush your .NET cache. Set the <head> tag of your pages to render on the server. Verify that your agent is configured to auto-instrument pages. Edit newrelic.config and verify that autoInstrument is set to true: <browserMonitoring autoInstrument=\"true\"/> Copy Check whether IIS page compression is disabled. If compressed before the .NET agent attempts browser instrumentation, the necessary <HEAD> tag won't be found. For instructions on how to check that, see Microsoft documentation. Look at the source of one of your pages through a browser. Look for a script with references to NREUMQ at the top and bottom of your pages. If you get support at support.newrelic.com, mention whether you are seeing this JavaScript in the page header or in some other location in the page, or you are not seeing it at all. Here are some additional troubleshooting tips: Browser problems Additional troubleshooting tips for .NET agent IIS exception error With IIS, you may receive an InvalidOperationException that states: Post cache substitution is not compatible with modules in the IIS integrated pipeline that modify the response buffers. Copy To solve this problem, you must manually implement the Browser agent: Set browserMonitoring to false in newrelic.config, and follow the manual instrumentation procedures. Razor framework error With the Razor framework, you may encounter the following message: Parser Error Message: \"\").pop().split(\"\" is not valid at the start of a code block. Only identifiers, keywords, comments, \"(\" and \"{\" are valid. Copy To solve this problem, follow the Browser troubleshooting procedures for Razor frameworks.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 79.93086,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No Browser data appears (.<em>NET</em>)",
        "sections": "No Browser data appears (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem After generating traffic and waiting five minutes, you do not see any browser monitoring data for your .<em>NET</em> app. Solution To <em>troubleshoot</em> missing data: Make sure you have installed the latest release of the .<em>NET</em> <em>agent</em>. Follow the <em>troubleshooting</em> procedures for missing data as applicable"
      },
      "id": "6043f856e7b9d202d65799b5"
    },
    {
      "sections": [
        ".NET agent reports handled errors",
        "Problem",
        "Solution",
        "GetResponse() throws an error",
        "Define a custom instrumentation file",
        "Wrap the method in a custom transaction",
        "Cause"
      ],
      "title": ".NET agent reports handled errors",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "5cd50fdec02b9d8e48348c183e786eac54c312e8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/net-agent-reports-handled-errors/",
      "published_at": "2021-06-02T16:49:23Z",
      "updated_at": "2021-04-29T00:18:04Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem New Relic's .NET agent reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception handler. Instrument the target method by defining a custom instrumentation file, or by wrapping the method in a custom transaction, as shown in this example: GetResponse() throws an error In this example, New Relic reports an error from GetResponse() unless the method Foo() is instrumented. As long is Foo is instrumented, New Relic begins a transaction when Foo is called and ends the transaction when Foo ends. Because the error is handled before Foo ends, New Relic will not report an error. Note also that GetResponse() becomes a segment of the Foo transaction. using System; using System.Collections.Generic; using System.Threading; using System.Threading.Tasks; using System.Net; using System.IO; namespace ErrorTester { class Program { static void Main(string[] args) { var i = 0; while (true) { Foo(++i); } } static void Foo(int i) { try { GetNotFound(); } catch (Exception ex) { Console.WriteLine(\"Got it \" + i + \"!\"); Thread.Sleep(1000); } } static string GetNotFound() { string uri = \"http://localhost/Test/this/is/not/a/real/page\"; var request = (HttpWebRequest)WebRequest.Create(uri); var response = request.GetResponse(); var data = new StreamReader(response.GetResponseStream()).ReadToEnd(); response.Close(); return data; } } } Copy Define a custom instrumentation file To instrument Foo: Define a custom instrumentation file; for example, CustomInstrumentation.xml: <?xml version=\"1.0\" encoding=\"utf-8\"?> <!-- © 2008-2014 New Relic, Inc. All rights reserved. --> <!-- When you edit this file, please use an XML aware editor (such as Visual Studio), and pair with the companion file extension.xsd to minimize the chance of introducing typos that may confuse the agent when it is run. --> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory > <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Place CustomInstrumenation.xml in the New Relic extensions folder, alongside CoreInstrumentation.xml, and restart your application. Wrap the method in a custom transaction To instrument Foo, wrap it in a custom transaction: <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Background/Task\"> <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Cause The only errors New Relic's .NET agent reports are unhandled errors that end a transaction. If your app calls an exception handler before the transaction ends, New Relic will not report an error. However, New Relic does not always detect exception handlers when the error occurs outside of a web transaction, WCF transaction, or custom transaction. This is because the agent creates \"mini-transactions\" for instrumented methods that are not associated with a transaction. When the instrumented method exits, the mini-transaction ends. If the mini-transaction throws an error and the instrumented method does not handle it, then New Relic will report an error. You can see this in a console app that calls GetResponse(), as shown in the example. If GetResponse throws an error, then New Relic will report it, even though GetResponse() is called within a try/catch block. The agent reports an error because the GetResponse() \"mini-transaction\" ended and the error was still unhandled on transaction exit.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 78.57178,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> reports handled errors",
        "sections": ".<em>NET</em> <em>agent</em> reports handled errors",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem New Relic&#x27;s .<em>NET</em> <em>agent</em> reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception"
      },
      "id": "603e910028ccbcc7c0eba7b4"
    }
  ],
  "/docs/agents/net-agent/troubleshooting/generate-logs-troubleshooting-net": [
    {
      "sections": [
        "No Browser data appears (.NET)",
        "Problem",
        "Solution"
      ],
      "title": "No Browser data appears (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "61a0ca0687aa9ebea7c0ce8d99e38822db0eb1cd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/no-browser-data-appears-net/",
      "published_at": "2021-06-02T16:50:18Z",
      "updated_at": "2021-03-11T02:34:52Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem After generating traffic and waiting five minutes, you do not see any browser monitoring data for your .NET app. Solution To troubleshoot missing data: Make sure you have installed the latest release of the .NET agent. Follow the troubleshooting procedures for missing data as applicable. Verify whether your pages are rendered using ASPs. If you use another rendering technology, use manual instrumentation. Flush your .NET cache. Set the <head> tag of your pages to render on the server. Verify that your agent is configured to auto-instrument pages. Edit newrelic.config and verify that autoInstrument is set to true: <browserMonitoring autoInstrument=\"true\"/> Copy Check whether IIS page compression is disabled. If compressed before the .NET agent attempts browser instrumentation, the necessary <HEAD> tag won't be found. For instructions on how to check that, see Microsoft documentation. Look at the source of one of your pages through a browser. Look for a script with references to NREUMQ at the top and bottom of your pages. If you get support at support.newrelic.com, mention whether you are seeing this JavaScript in the page header or in some other location in the page, or you are not seeing it at all. Here are some additional troubleshooting tips: Browser problems Additional troubleshooting tips for .NET agent IIS exception error With IIS, you may receive an InvalidOperationException that states: Post cache substitution is not compatible with modules in the IIS integrated pipeline that modify the response buffers. Copy To solve this problem, you must manually implement the Browser agent: Set browserMonitoring to false in newrelic.config, and follow the manual instrumentation procedures. Razor framework error With the Razor framework, you may encounter the following message: Parser Error Message: \"\").pop().split(\"\" is not valid at the start of a code block. Only identifiers, keywords, comments, \"(\" and \"{\" are valid. Copy To solve this problem, follow the Browser troubleshooting procedures for Razor frameworks.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 79.93086,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No Browser data appears (.<em>NET</em>)",
        "sections": "No Browser data appears (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem After generating traffic and waiting five minutes, you do not see any browser monitoring data for your .<em>NET</em> app. Solution To <em>troubleshoot</em> missing data: Make sure you have installed the latest release of the .<em>NET</em> <em>agent</em>. Follow the <em>troubleshooting</em> procedures for missing data as applicable"
      },
      "id": "6043f856e7b9d202d65799b5"
    },
    {
      "sections": [
        ".NET agent reports handled errors",
        "Problem",
        "Solution",
        "GetResponse() throws an error",
        "Define a custom instrumentation file",
        "Wrap the method in a custom transaction",
        "Cause"
      ],
      "title": ".NET agent reports handled errors",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "5cd50fdec02b9d8e48348c183e786eac54c312e8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/net-agent-reports-handled-errors/",
      "published_at": "2021-06-02T16:49:23Z",
      "updated_at": "2021-04-29T00:18:04Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem New Relic's .NET agent reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception handler. Instrument the target method by defining a custom instrumentation file, or by wrapping the method in a custom transaction, as shown in this example: GetResponse() throws an error In this example, New Relic reports an error from GetResponse() unless the method Foo() is instrumented. As long is Foo is instrumented, New Relic begins a transaction when Foo is called and ends the transaction when Foo ends. Because the error is handled before Foo ends, New Relic will not report an error. Note also that GetResponse() becomes a segment of the Foo transaction. using System; using System.Collections.Generic; using System.Threading; using System.Threading.Tasks; using System.Net; using System.IO; namespace ErrorTester { class Program { static void Main(string[] args) { var i = 0; while (true) { Foo(++i); } } static void Foo(int i) { try { GetNotFound(); } catch (Exception ex) { Console.WriteLine(\"Got it \" + i + \"!\"); Thread.Sleep(1000); } } static string GetNotFound() { string uri = \"http://localhost/Test/this/is/not/a/real/page\"; var request = (HttpWebRequest)WebRequest.Create(uri); var response = request.GetResponse(); var data = new StreamReader(response.GetResponseStream()).ReadToEnd(); response.Close(); return data; } } } Copy Define a custom instrumentation file To instrument Foo: Define a custom instrumentation file; for example, CustomInstrumentation.xml: <?xml version=\"1.0\" encoding=\"utf-8\"?> <!-- © 2008-2014 New Relic, Inc. All rights reserved. --> <!-- When you edit this file, please use an XML aware editor (such as Visual Studio), and pair with the companion file extension.xsd to minimize the chance of introducing typos that may confuse the agent when it is run. --> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory > <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Place CustomInstrumenation.xml in the New Relic extensions folder, alongside CoreInstrumentation.xml, and restart your application. Wrap the method in a custom transaction To instrument Foo, wrap it in a custom transaction: <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Background/Task\"> <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Cause The only errors New Relic's .NET agent reports are unhandled errors that end a transaction. If your app calls an exception handler before the transaction ends, New Relic will not report an error. However, New Relic does not always detect exception handlers when the error occurs outside of a web transaction, WCF transaction, or custom transaction. This is because the agent creates \"mini-transactions\" for instrumented methods that are not associated with a transaction. When the instrumented method exits, the mini-transaction ends. If the mini-transaction throws an error and the instrumented method does not handle it, then New Relic will report an error. You can see this in a console app that calls GetResponse(), as shown in the example. If GetResponse throws an error, then New Relic will report it, even though GetResponse() is called within a try/catch block. The agent reports an error because the GetResponse() \"mini-transaction\" ended and the error was still unhandled on transaction exit.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 78.57178,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> reports handled errors",
        "sections": ".<em>NET</em> <em>agent</em> reports handled errors",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem New Relic&#x27;s .<em>NET</em> <em>agent</em> reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception"
      },
      "id": "603e910028ccbcc7c0eba7b4"
    },
    {
      "sections": [
        "No data appears (.NET)",
        "Problem",
        "Solution",
        "Basic solutions",
        "Advanced solutions"
      ],
      "title": "No data appears (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "ac2a9d51d0845b16c586c49d32266565a7691fad",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/no-data-appears-net/",
      "published_at": "2021-06-02T13:56:50Z",
      "updated_at": "2021-03-16T02:06:20Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem After generating traffic for your app and waiting five minutes, none of your .NET agent data appears in the New Relic UI. Solution The absence of data may occur for several reasons. Common causes for missing data: See the basic troubleshooting solutions. Other situations: If the basic solutions do not solve the problem, the lack of data may be more intrinsic to your system. For more information, see the advanced troubleshooting solutions. Microsoft Azure users: See the Azure troubleshooting solutions. No Browser data appears: See the troubleshooting tips when using the Browser agent. Basic solutions To troubleshoot the most common reasons for missing data, try these solutions as applicable. Basic solutions Comments Check app and framework for compatibility with agent .NET Framework compatibility and requirements or .NET Core compatibility and requirements Configure for short-lived .NET process If you have a short-lived (below 60 seconds) process, it may not report data. For more information, see Monitor short-lived processes. .NET Core: Check Kestrel requirements. Make sure you are using a Kestrel app/web server supported by New Relic. Otherwise, you may need to ensure your .NET agent has .NET Framework support enabled. .NET Core: Check environment variables. Make sure you have configured all the required environment variables, then restart the agent. .NET Framework: Restart IIS. If your app is not receiving traffic, no data will be reported to New Relic. To restart IIS: From a command line, run IISRESET. Verify that traffic is being sent to your application. Run New Relic Diagnostics. To try to automatically identify the issue, use New Relic Diagnostics. Check for profiler conflicts. If you are using Microsoft's System Center Operations Manager (SCOM), follow the troubleshooting procedures to resolve .NET and SCOM conflicts. Review log files. If log files exist, open them and review for errors. Advanced solutions To remedy more complex issues when no data appears, try these solutions as applicable: Advanced solutions Comments .NET Framework: Check Registry permissions. Check for a registry key permissions error. .NET Framework: Run Windows Event Viewer. If applicable: Run the Windows Event Viewer, and look for application events from the New Relic .NET Profiler. Search for messages whose source is the New Relic .NET Profiler or New Relic .NET agent. If there are no New Relic event messages, look for messages from the .NET Runtime. For more information, see No data or event log: CoCreate errors. Get debug logs. If your logs did not show errors, increase the logging level temporarily to collect debug logs. Check proxy settings. Ensure your proxy settings are correct and that your settings include a host attribute. Get additional help. If data still does not appear, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 78.13378,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No data appears (.<em>NET</em>)",
        "sections": "No data appears (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem After generating traffic for your app and waiting five minutes, none of your .<em>NET</em> <em>agent</em> data appears in the New Relic UI. Solution The absence of data may occur for several reasons. Common causes for missing data: See the basic <em>troubleshooting</em> solutions. Other situations: If the basic"
      },
      "id": "603e7f2728ccbc2cc8eba7a6"
    }
  ],
  "/docs/agents/net-agent/troubleshooting/high-memory-usage-net": [
    {
      "sections": [
        "Generate logs for troubleshooting (.NET)",
        "Generate log files",
        "Important",
        "Generate Azure Web App log files",
        "Collect system information",
        "Check permissions",
        "For more help"
      ],
      "title": "Generate logs for troubleshooting (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "3f0c136f4228951c3d2f4bfa1f28e5331b5fa5ca",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/generate-logs-troubleshooting-net/",
      "published_at": "2021-06-02T16:17:55Z",
      "updated_at": "2021-03-16T13:04:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent stores two types of log files in the Logs directory at %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. Both are needed for troubleshooting; for example, if no data appears in the New Relic UI for your app. If either log type is missing, some component of the .NET agent did not start. Agent logs: These file names begin with newrelic_agent_. Profiler logs: These file names begin with NewRelic.Profiler. Generate log files Important When troubleshooting your New Relic .NET agent, ensure it has been configured to generate debug level log files, and monitor the size of your log file closely. Logging at debug generates a lot of data very quickly. After reproducing your problem, return the log level to info. If your C:\\ProgramData\\New Relic\\.NET Agent is in a hidden folder, update your Windows settings so that you can see it. To generate New Relic for .NET log files: Open newrelic.config, usually located in C:\\ProgramData\\New Relic\\.NET Agent (or %ALLUSERSPROFILE%\\New Relic\\.NET Agent). Change the <log level=\"info\" /> setting to <log level=\"debug\" />. Save and close the file, then wait a few minutes for the agent to read the new settings. Generate a few minutes of traffic to your app. If sending your log file to New Relic Support: In your New Relic support ticket, attach the newrelic.config file (not the text of the file), and attach the entire Logs folder from C:\\ProgramData\\New Relic\\.NET Agent\\Logs or from %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. In newrelic.config, change <log level=\"debug\" /> to <log level=\"info\" />. Generate Azure Web App log files Kudu Console manages Microsoft Azure Web App log reporting. To use the Kudu Console, first log into Azure. Navigate to the URL of your Azure Web app; for example: https://example.azurewebsites.net Copy Insert the Kudu Console URL scmsnippet into the URL; for example: https://example.scm.azurewebsites.net Copy Check for the Kudu logo with a black navigation bar at the top left of the page and your Azure username at the top right of the page. Then, to change the log level within the Kudu Console: From the Kudu Console navigation bar, select the Debug console menu, then select either CMD or PowerShell. Navigate to D:\\home\\site\\wwwroot\\newrelic. To edit newrelic.config, select the pencil icon. Change <log level=\"info\"> to <log level=\"debug\"> Save the change to newrelic.config. Wait a few minutes for the debug logs to be generated. Use the same steps to switch the log level back to info. Collect system information In addition to agent logs, a Microsoft System Information file is also useful for troubleshooting: From the Windows task bar, select Start > Run and enter msinfo32. Select OK. After the system information page loads, select File > Save. Wait a few minutes for the server to save the file. Attach the file to your New Relic support ticket. Check permissions Sometimes the .NET agent will start but not be able to write to its logs because it does not have the necessary permissions to create the log directory and log files. Permissions management varies by environment, so you will need to work with your system administrator to verify that this is not an issue. For more help For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 83.13534,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate logs for <em>troubleshooting</em> (.<em>NET</em>)",
        "sections": "Generate logs for <em>troubleshooting</em> (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> stores two types of log files in the Logs directory at %ALLUSERSPROFILE%\\New Relic\\.<em>NET</em> <em>Agent</em>\\Logs. Both are needed for <em>troubleshooting</em>; for example, if no data appears in the New Relic UI for your app. If either log type is missing, some component of the .<em>NET</em> <em>agent</em> did"
      },
      "id": "603eb5da196a67556aa83dd8"
    },
    {
      "sections": [
        "No Browser data appears (.NET)",
        "Problem",
        "Solution"
      ],
      "title": "No Browser data appears (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "61a0ca0687aa9ebea7c0ce8d99e38822db0eb1cd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/no-browser-data-appears-net/",
      "published_at": "2021-06-02T16:50:18Z",
      "updated_at": "2021-03-11T02:34:52Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem After generating traffic and waiting five minutes, you do not see any browser monitoring data for your .NET app. Solution To troubleshoot missing data: Make sure you have installed the latest release of the .NET agent. Follow the troubleshooting procedures for missing data as applicable. Verify whether your pages are rendered using ASPs. If you use another rendering technology, use manual instrumentation. Flush your .NET cache. Set the <head> tag of your pages to render on the server. Verify that your agent is configured to auto-instrument pages. Edit newrelic.config and verify that autoInstrument is set to true: <browserMonitoring autoInstrument=\"true\"/> Copy Check whether IIS page compression is disabled. If compressed before the .NET agent attempts browser instrumentation, the necessary <HEAD> tag won't be found. For instructions on how to check that, see Microsoft documentation. Look at the source of one of your pages through a browser. Look for a script with references to NREUMQ at the top and bottom of your pages. If you get support at support.newrelic.com, mention whether you are seeing this JavaScript in the page header or in some other location in the page, or you are not seeing it at all. Here are some additional troubleshooting tips: Browser problems Additional troubleshooting tips for .NET agent IIS exception error With IIS, you may receive an InvalidOperationException that states: Post cache substitution is not compatible with modules in the IIS integrated pipeline that modify the response buffers. Copy To solve this problem, you must manually implement the Browser agent: Set browserMonitoring to false in newrelic.config, and follow the manual instrumentation procedures. Razor framework error With the Razor framework, you may encounter the following message: Parser Error Message: \"\").pop().split(\"\" is not valid at the start of a code block. Only identifiers, keywords, comments, \"(\" and \"{\" are valid. Copy To solve this problem, follow the Browser troubleshooting procedures for Razor frameworks.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 79.93086,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No Browser data appears (.<em>NET</em>)",
        "sections": "No Browser data appears (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem After generating traffic and waiting five minutes, you do not see any browser monitoring data for your .<em>NET</em> app. Solution To <em>troubleshoot</em> missing data: Make sure you have installed the latest release of the .<em>NET</em> <em>agent</em>. Follow the <em>troubleshooting</em> procedures for missing data as applicable"
      },
      "id": "6043f856e7b9d202d65799b5"
    },
    {
      "sections": [
        ".NET agent reports handled errors",
        "Problem",
        "Solution",
        "GetResponse() throws an error",
        "Define a custom instrumentation file",
        "Wrap the method in a custom transaction",
        "Cause"
      ],
      "title": ".NET agent reports handled errors",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "5cd50fdec02b9d8e48348c183e786eac54c312e8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/net-agent-reports-handled-errors/",
      "published_at": "2021-06-02T16:49:23Z",
      "updated_at": "2021-04-29T00:18:04Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem New Relic's .NET agent reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception handler. Instrument the target method by defining a custom instrumentation file, or by wrapping the method in a custom transaction, as shown in this example: GetResponse() throws an error In this example, New Relic reports an error from GetResponse() unless the method Foo() is instrumented. As long is Foo is instrumented, New Relic begins a transaction when Foo is called and ends the transaction when Foo ends. Because the error is handled before Foo ends, New Relic will not report an error. Note also that GetResponse() becomes a segment of the Foo transaction. using System; using System.Collections.Generic; using System.Threading; using System.Threading.Tasks; using System.Net; using System.IO; namespace ErrorTester { class Program { static void Main(string[] args) { var i = 0; while (true) { Foo(++i); } } static void Foo(int i) { try { GetNotFound(); } catch (Exception ex) { Console.WriteLine(\"Got it \" + i + \"!\"); Thread.Sleep(1000); } } static string GetNotFound() { string uri = \"http://localhost/Test/this/is/not/a/real/page\"; var request = (HttpWebRequest)WebRequest.Create(uri); var response = request.GetResponse(); var data = new StreamReader(response.GetResponseStream()).ReadToEnd(); response.Close(); return data; } } } Copy Define a custom instrumentation file To instrument Foo: Define a custom instrumentation file; for example, CustomInstrumentation.xml: <?xml version=\"1.0\" encoding=\"utf-8\"?> <!-- © 2008-2014 New Relic, Inc. All rights reserved. --> <!-- When you edit this file, please use an XML aware editor (such as Visual Studio), and pair with the companion file extension.xsd to minimize the chance of introducing typos that may confuse the agent when it is run. --> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory > <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Place CustomInstrumenation.xml in the New Relic extensions folder, alongside CoreInstrumentation.xml, and restart your application. Wrap the method in a custom transaction To instrument Foo, wrap it in a custom transaction: <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Background/Task\"> <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Cause The only errors New Relic's .NET agent reports are unhandled errors that end a transaction. If your app calls an exception handler before the transaction ends, New Relic will not report an error. However, New Relic does not always detect exception handlers when the error occurs outside of a web transaction, WCF transaction, or custom transaction. This is because the agent creates \"mini-transactions\" for instrumented methods that are not associated with a transaction. When the instrumented method exits, the mini-transaction ends. If the mini-transaction throws an error and the instrumented method does not handle it, then New Relic will report an error. You can see this in a console app that calls GetResponse(), as shown in the example. If GetResponse throws an error, then New Relic will report it, even though GetResponse() is called within a try/catch block. The agent reports an error because the GetResponse() \"mini-transaction\" ended and the error was still unhandled on transaction exit.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 78.57178,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> reports handled errors",
        "sections": ".<em>NET</em> <em>agent</em> reports handled errors",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem New Relic&#x27;s .<em>NET</em> <em>agent</em> reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception"
      },
      "id": "603e910028ccbcc7c0eba7b4"
    }
  ],
  "/docs/agents/net-agent/troubleshooting/missing-couchbase-metrics-net": [
    {
      "sections": [
        "Generate logs for troubleshooting (.NET)",
        "Generate log files",
        "Important",
        "Generate Azure Web App log files",
        "Collect system information",
        "Check permissions",
        "For more help"
      ],
      "title": "Generate logs for troubleshooting (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "3f0c136f4228951c3d2f4bfa1f28e5331b5fa5ca",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/generate-logs-troubleshooting-net/",
      "published_at": "2021-06-02T16:17:55Z",
      "updated_at": "2021-03-16T13:04:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent stores two types of log files in the Logs directory at %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. Both are needed for troubleshooting; for example, if no data appears in the New Relic UI for your app. If either log type is missing, some component of the .NET agent did not start. Agent logs: These file names begin with newrelic_agent_. Profiler logs: These file names begin with NewRelic.Profiler. Generate log files Important When troubleshooting your New Relic .NET agent, ensure it has been configured to generate debug level log files, and monitor the size of your log file closely. Logging at debug generates a lot of data very quickly. After reproducing your problem, return the log level to info. If your C:\\ProgramData\\New Relic\\.NET Agent is in a hidden folder, update your Windows settings so that you can see it. To generate New Relic for .NET log files: Open newrelic.config, usually located in C:\\ProgramData\\New Relic\\.NET Agent (or %ALLUSERSPROFILE%\\New Relic\\.NET Agent). Change the <log level=\"info\" /> setting to <log level=\"debug\" />. Save and close the file, then wait a few minutes for the agent to read the new settings. Generate a few minutes of traffic to your app. If sending your log file to New Relic Support: In your New Relic support ticket, attach the newrelic.config file (not the text of the file), and attach the entire Logs folder from C:\\ProgramData\\New Relic\\.NET Agent\\Logs or from %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. In newrelic.config, change <log level=\"debug\" /> to <log level=\"info\" />. Generate Azure Web App log files Kudu Console manages Microsoft Azure Web App log reporting. To use the Kudu Console, first log into Azure. Navigate to the URL of your Azure Web app; for example: https://example.azurewebsites.net Copy Insert the Kudu Console URL scmsnippet into the URL; for example: https://example.scm.azurewebsites.net Copy Check for the Kudu logo with a black navigation bar at the top left of the page and your Azure username at the top right of the page. Then, to change the log level within the Kudu Console: From the Kudu Console navigation bar, select the Debug console menu, then select either CMD or PowerShell. Navigate to D:\\home\\site\\wwwroot\\newrelic. To edit newrelic.config, select the pencil icon. Change <log level=\"info\"> to <log level=\"debug\"> Save the change to newrelic.config. Wait a few minutes for the debug logs to be generated. Use the same steps to switch the log level back to info. Collect system information In addition to agent logs, a Microsoft System Information file is also useful for troubleshooting: From the Windows task bar, select Start > Run and enter msinfo32. Select OK. After the system information page loads, select File > Save. Wait a few minutes for the server to save the file. Attach the file to your New Relic support ticket. Check permissions Sometimes the .NET agent will start but not be able to write to its logs because it does not have the necessary permissions to create the log directory and log files. Permissions management varies by environment, so you will need to work with your system administrator to verify that this is not an issue. For more help For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 83.13534,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate logs for <em>troubleshooting</em> (.<em>NET</em>)",
        "sections": "Generate logs for <em>troubleshooting</em> (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> stores two types of log files in the Logs directory at %ALLUSERSPROFILE%\\New Relic\\.<em>NET</em> <em>Agent</em>\\Logs. Both are needed for <em>troubleshooting</em>; for example, if no data appears in the New Relic UI for your app. If either log type is missing, some component of the .<em>NET</em> <em>agent</em> did"
      },
      "id": "603eb5da196a67556aa83dd8"
    },
    {
      "sections": [
        "No Browser data appears (.NET)",
        "Problem",
        "Solution"
      ],
      "title": "No Browser data appears (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "61a0ca0687aa9ebea7c0ce8d99e38822db0eb1cd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/no-browser-data-appears-net/",
      "published_at": "2021-06-02T16:50:18Z",
      "updated_at": "2021-03-11T02:34:52Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem After generating traffic and waiting five minutes, you do not see any browser monitoring data for your .NET app. Solution To troubleshoot missing data: Make sure you have installed the latest release of the .NET agent. Follow the troubleshooting procedures for missing data as applicable. Verify whether your pages are rendered using ASPs. If you use another rendering technology, use manual instrumentation. Flush your .NET cache. Set the <head> tag of your pages to render on the server. Verify that your agent is configured to auto-instrument pages. Edit newrelic.config and verify that autoInstrument is set to true: <browserMonitoring autoInstrument=\"true\"/> Copy Check whether IIS page compression is disabled. If compressed before the .NET agent attempts browser instrumentation, the necessary <HEAD> tag won't be found. For instructions on how to check that, see Microsoft documentation. Look at the source of one of your pages through a browser. Look for a script with references to NREUMQ at the top and bottom of your pages. If you get support at support.newrelic.com, mention whether you are seeing this JavaScript in the page header or in some other location in the page, or you are not seeing it at all. Here are some additional troubleshooting tips: Browser problems Additional troubleshooting tips for .NET agent IIS exception error With IIS, you may receive an InvalidOperationException that states: Post cache substitution is not compatible with modules in the IIS integrated pipeline that modify the response buffers. Copy To solve this problem, you must manually implement the Browser agent: Set browserMonitoring to false in newrelic.config, and follow the manual instrumentation procedures. Razor framework error With the Razor framework, you may encounter the following message: Parser Error Message: \"\").pop().split(\"\" is not valid at the start of a code block. Only identifiers, keywords, comments, \"(\" and \"{\" are valid. Copy To solve this problem, follow the Browser troubleshooting procedures for Razor frameworks.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 79.93086,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No Browser data appears (.<em>NET</em>)",
        "sections": "No Browser data appears (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem After generating traffic and waiting five minutes, you do not see any browser monitoring data for your .<em>NET</em> app. Solution To <em>troubleshoot</em> missing data: Make sure you have installed the latest release of the .<em>NET</em> <em>agent</em>. Follow the <em>troubleshooting</em> procedures for missing data as applicable"
      },
      "id": "6043f856e7b9d202d65799b5"
    },
    {
      "sections": [
        ".NET agent reports handled errors",
        "Problem",
        "Solution",
        "GetResponse() throws an error",
        "Define a custom instrumentation file",
        "Wrap the method in a custom transaction",
        "Cause"
      ],
      "title": ".NET agent reports handled errors",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "5cd50fdec02b9d8e48348c183e786eac54c312e8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/net-agent-reports-handled-errors/",
      "published_at": "2021-06-02T16:49:23Z",
      "updated_at": "2021-04-29T00:18:04Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem New Relic's .NET agent reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception handler. Instrument the target method by defining a custom instrumentation file, or by wrapping the method in a custom transaction, as shown in this example: GetResponse() throws an error In this example, New Relic reports an error from GetResponse() unless the method Foo() is instrumented. As long is Foo is instrumented, New Relic begins a transaction when Foo is called and ends the transaction when Foo ends. Because the error is handled before Foo ends, New Relic will not report an error. Note also that GetResponse() becomes a segment of the Foo transaction. using System; using System.Collections.Generic; using System.Threading; using System.Threading.Tasks; using System.Net; using System.IO; namespace ErrorTester { class Program { static void Main(string[] args) { var i = 0; while (true) { Foo(++i); } } static void Foo(int i) { try { GetNotFound(); } catch (Exception ex) { Console.WriteLine(\"Got it \" + i + \"!\"); Thread.Sleep(1000); } } static string GetNotFound() { string uri = \"http://localhost/Test/this/is/not/a/real/page\"; var request = (HttpWebRequest)WebRequest.Create(uri); var response = request.GetResponse(); var data = new StreamReader(response.GetResponseStream()).ReadToEnd(); response.Close(); return data; } } } Copy Define a custom instrumentation file To instrument Foo: Define a custom instrumentation file; for example, CustomInstrumentation.xml: <?xml version=\"1.0\" encoding=\"utf-8\"?> <!-- © 2008-2014 New Relic, Inc. All rights reserved. --> <!-- When you edit this file, please use an XML aware editor (such as Visual Studio), and pair with the companion file extension.xsd to minimize the chance of introducing typos that may confuse the agent when it is run. --> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory > <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Place CustomInstrumenation.xml in the New Relic extensions folder, alongside CoreInstrumentation.xml, and restart your application. Wrap the method in a custom transaction To instrument Foo, wrap it in a custom transaction: <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Background/Task\"> <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Cause The only errors New Relic's .NET agent reports are unhandled errors that end a transaction. If your app calls an exception handler before the transaction ends, New Relic will not report an error. However, New Relic does not always detect exception handlers when the error occurs outside of a web transaction, WCF transaction, or custom transaction. This is because the agent creates \"mini-transactions\" for instrumented methods that are not associated with a transaction. When the instrumented method exits, the mini-transaction ends. If the mini-transaction throws an error and the instrumented method does not handle it, then New Relic will report an error. You can see this in a console app that calls GetResponse(), as shown in the example. If GetResponse throws an error, then New Relic will report it, even though GetResponse() is called within a try/catch block. The agent reports an error because the GetResponse() \"mini-transaction\" ended and the error was still unhandled on transaction exit.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 78.57177,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> reports handled errors",
        "sections": ".<em>NET</em> <em>agent</em> reports handled errors",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem New Relic&#x27;s .<em>NET</em> <em>agent</em> reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception"
      },
      "id": "603e910028ccbcc7c0eba7b4"
    }
  ],
  "/docs/agents/net-agent/troubleshooting/missing-net-async-metrics": [
    {
      "sections": [
        "Generate logs for troubleshooting (.NET)",
        "Generate log files",
        "Important",
        "Generate Azure Web App log files",
        "Collect system information",
        "Check permissions",
        "For more help"
      ],
      "title": "Generate logs for troubleshooting (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "3f0c136f4228951c3d2f4bfa1f28e5331b5fa5ca",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/generate-logs-troubleshooting-net/",
      "published_at": "2021-06-02T16:17:55Z",
      "updated_at": "2021-03-16T13:04:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent stores two types of log files in the Logs directory at %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. Both are needed for troubleshooting; for example, if no data appears in the New Relic UI for your app. If either log type is missing, some component of the .NET agent did not start. Agent logs: These file names begin with newrelic_agent_. Profiler logs: These file names begin with NewRelic.Profiler. Generate log files Important When troubleshooting your New Relic .NET agent, ensure it has been configured to generate debug level log files, and monitor the size of your log file closely. Logging at debug generates a lot of data very quickly. After reproducing your problem, return the log level to info. If your C:\\ProgramData\\New Relic\\.NET Agent is in a hidden folder, update your Windows settings so that you can see it. To generate New Relic for .NET log files: Open newrelic.config, usually located in C:\\ProgramData\\New Relic\\.NET Agent (or %ALLUSERSPROFILE%\\New Relic\\.NET Agent). Change the <log level=\"info\" /> setting to <log level=\"debug\" />. Save and close the file, then wait a few minutes for the agent to read the new settings. Generate a few minutes of traffic to your app. If sending your log file to New Relic Support: In your New Relic support ticket, attach the newrelic.config file (not the text of the file), and attach the entire Logs folder from C:\\ProgramData\\New Relic\\.NET Agent\\Logs or from %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. In newrelic.config, change <log level=\"debug\" /> to <log level=\"info\" />. Generate Azure Web App log files Kudu Console manages Microsoft Azure Web App log reporting. To use the Kudu Console, first log into Azure. Navigate to the URL of your Azure Web app; for example: https://example.azurewebsites.net Copy Insert the Kudu Console URL scmsnippet into the URL; for example: https://example.scm.azurewebsites.net Copy Check for the Kudu logo with a black navigation bar at the top left of the page and your Azure username at the top right of the page. Then, to change the log level within the Kudu Console: From the Kudu Console navigation bar, select the Debug console menu, then select either CMD or PowerShell. Navigate to D:\\home\\site\\wwwroot\\newrelic. To edit newrelic.config, select the pencil icon. Change <log level=\"info\"> to <log level=\"debug\"> Save the change to newrelic.config. Wait a few minutes for the debug logs to be generated. Use the same steps to switch the log level back to info. Collect system information In addition to agent logs, a Microsoft System Information file is also useful for troubleshooting: From the Windows task bar, select Start > Run and enter msinfo32. Select OK. After the system information page loads, select File > Save. Wait a few minutes for the server to save the file. Attach the file to your New Relic support ticket. Check permissions Sometimes the .NET agent will start but not be able to write to its logs because it does not have the necessary permissions to create the log directory and log files. Permissions management varies by environment, so you will need to work with your system administrator to verify that this is not an issue. For more help For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 83.13534,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate logs for <em>troubleshooting</em> (.<em>NET</em>)",
        "sections": "Generate logs for <em>troubleshooting</em> (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> stores two types of log files in the Logs directory at %ALLUSERSPROFILE%\\New Relic\\.<em>NET</em> <em>Agent</em>\\Logs. Both are needed for <em>troubleshooting</em>; for example, if no data appears in the New Relic UI for your app. If either log type is missing, some component of the .<em>NET</em> <em>agent</em> did"
      },
      "id": "603eb5da196a67556aa83dd8"
    },
    {
      "sections": [
        "No Browser data appears (.NET)",
        "Problem",
        "Solution"
      ],
      "title": "No Browser data appears (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "61a0ca0687aa9ebea7c0ce8d99e38822db0eb1cd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/no-browser-data-appears-net/",
      "published_at": "2021-06-02T16:50:18Z",
      "updated_at": "2021-03-11T02:34:52Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem After generating traffic and waiting five minutes, you do not see any browser monitoring data for your .NET app. Solution To troubleshoot missing data: Make sure you have installed the latest release of the .NET agent. Follow the troubleshooting procedures for missing data as applicable. Verify whether your pages are rendered using ASPs. If you use another rendering technology, use manual instrumentation. Flush your .NET cache. Set the <head> tag of your pages to render on the server. Verify that your agent is configured to auto-instrument pages. Edit newrelic.config and verify that autoInstrument is set to true: <browserMonitoring autoInstrument=\"true\"/> Copy Check whether IIS page compression is disabled. If compressed before the .NET agent attempts browser instrumentation, the necessary <HEAD> tag won't be found. For instructions on how to check that, see Microsoft documentation. Look at the source of one of your pages through a browser. Look for a script with references to NREUMQ at the top and bottom of your pages. If you get support at support.newrelic.com, mention whether you are seeing this JavaScript in the page header or in some other location in the page, or you are not seeing it at all. Here are some additional troubleshooting tips: Browser problems Additional troubleshooting tips for .NET agent IIS exception error With IIS, you may receive an InvalidOperationException that states: Post cache substitution is not compatible with modules in the IIS integrated pipeline that modify the response buffers. Copy To solve this problem, you must manually implement the Browser agent: Set browserMonitoring to false in newrelic.config, and follow the manual instrumentation procedures. Razor framework error With the Razor framework, you may encounter the following message: Parser Error Message: \"\").pop().split(\"\" is not valid at the start of a code block. Only identifiers, keywords, comments, \"(\" and \"{\" are valid. Copy To solve this problem, follow the Browser troubleshooting procedures for Razor frameworks.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 79.93086,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No Browser data appears (.<em>NET</em>)",
        "sections": "No Browser data appears (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem After generating traffic and waiting five minutes, you do not see any browser monitoring data for your .<em>NET</em> app. Solution To <em>troubleshoot</em> missing data: Make sure you have installed the latest release of the .<em>NET</em> <em>agent</em>. Follow the <em>troubleshooting</em> procedures for missing data as applicable"
      },
      "id": "6043f856e7b9d202d65799b5"
    },
    {
      "sections": [
        ".NET agent reports handled errors",
        "Problem",
        "Solution",
        "GetResponse() throws an error",
        "Define a custom instrumentation file",
        "Wrap the method in a custom transaction",
        "Cause"
      ],
      "title": ".NET agent reports handled errors",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "5cd50fdec02b9d8e48348c183e786eac54c312e8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/net-agent-reports-handled-errors/",
      "published_at": "2021-06-02T16:49:23Z",
      "updated_at": "2021-04-29T00:18:04Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem New Relic's .NET agent reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception handler. Instrument the target method by defining a custom instrumentation file, or by wrapping the method in a custom transaction, as shown in this example: GetResponse() throws an error In this example, New Relic reports an error from GetResponse() unless the method Foo() is instrumented. As long is Foo is instrumented, New Relic begins a transaction when Foo is called and ends the transaction when Foo ends. Because the error is handled before Foo ends, New Relic will not report an error. Note also that GetResponse() becomes a segment of the Foo transaction. using System; using System.Collections.Generic; using System.Threading; using System.Threading.Tasks; using System.Net; using System.IO; namespace ErrorTester { class Program { static void Main(string[] args) { var i = 0; while (true) { Foo(++i); } } static void Foo(int i) { try { GetNotFound(); } catch (Exception ex) { Console.WriteLine(\"Got it \" + i + \"!\"); Thread.Sleep(1000); } } static string GetNotFound() { string uri = \"http://localhost/Test/this/is/not/a/real/page\"; var request = (HttpWebRequest)WebRequest.Create(uri); var response = request.GetResponse(); var data = new StreamReader(response.GetResponseStream()).ReadToEnd(); response.Close(); return data; } } } Copy Define a custom instrumentation file To instrument Foo: Define a custom instrumentation file; for example, CustomInstrumentation.xml: <?xml version=\"1.0\" encoding=\"utf-8\"?> <!-- © 2008-2014 New Relic, Inc. All rights reserved. --> <!-- When you edit this file, please use an XML aware editor (such as Visual Studio), and pair with the companion file extension.xsd to minimize the chance of introducing typos that may confuse the agent when it is run. --> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory > <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Place CustomInstrumenation.xml in the New Relic extensions folder, alongside CoreInstrumentation.xml, and restart your application. Wrap the method in a custom transaction To instrument Foo, wrap it in a custom transaction: <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Background/Task\"> <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Cause The only errors New Relic's .NET agent reports are unhandled errors that end a transaction. If your app calls an exception handler before the transaction ends, New Relic will not report an error. However, New Relic does not always detect exception handlers when the error occurs outside of a web transaction, WCF transaction, or custom transaction. This is because the agent creates \"mini-transactions\" for instrumented methods that are not associated with a transaction. When the instrumented method exits, the mini-transaction ends. If the mini-transaction throws an error and the instrumented method does not handle it, then New Relic will report an error. You can see this in a console app that calls GetResponse(), as shown in the example. If GetResponse throws an error, then New Relic will report it, even though GetResponse() is called within a try/catch block. The agent reports an error because the GetResponse() \"mini-transaction\" ended and the error was still unhandled on transaction exit.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 78.57177,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> reports handled errors",
        "sections": ".<em>NET</em> <em>agent</em> reports handled errors",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem New Relic&#x27;s .<em>NET</em> <em>agent</em> reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception"
      },
      "id": "603e910028ccbcc7c0eba7b4"
    }
  ],
  "/docs/agents/net-agent/troubleshooting/monitor-short-lived-net-processes": [
    {
      "sections": [
        "Generate logs for troubleshooting (.NET)",
        "Generate log files",
        "Important",
        "Generate Azure Web App log files",
        "Collect system information",
        "Check permissions",
        "For more help"
      ],
      "title": "Generate logs for troubleshooting (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "3f0c136f4228951c3d2f4bfa1f28e5331b5fa5ca",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/generate-logs-troubleshooting-net/",
      "published_at": "2021-06-02T16:17:55Z",
      "updated_at": "2021-03-16T13:04:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent stores two types of log files in the Logs directory at %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. Both are needed for troubleshooting; for example, if no data appears in the New Relic UI for your app. If either log type is missing, some component of the .NET agent did not start. Agent logs: These file names begin with newrelic_agent_. Profiler logs: These file names begin with NewRelic.Profiler. Generate log files Important When troubleshooting your New Relic .NET agent, ensure it has been configured to generate debug level log files, and monitor the size of your log file closely. Logging at debug generates a lot of data very quickly. After reproducing your problem, return the log level to info. If your C:\\ProgramData\\New Relic\\.NET Agent is in a hidden folder, update your Windows settings so that you can see it. To generate New Relic for .NET log files: Open newrelic.config, usually located in C:\\ProgramData\\New Relic\\.NET Agent (or %ALLUSERSPROFILE%\\New Relic\\.NET Agent). Change the <log level=\"info\" /> setting to <log level=\"debug\" />. Save and close the file, then wait a few minutes for the agent to read the new settings. Generate a few minutes of traffic to your app. If sending your log file to New Relic Support: In your New Relic support ticket, attach the newrelic.config file (not the text of the file), and attach the entire Logs folder from C:\\ProgramData\\New Relic\\.NET Agent\\Logs or from %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. In newrelic.config, change <log level=\"debug\" /> to <log level=\"info\" />. Generate Azure Web App log files Kudu Console manages Microsoft Azure Web App log reporting. To use the Kudu Console, first log into Azure. Navigate to the URL of your Azure Web app; for example: https://example.azurewebsites.net Copy Insert the Kudu Console URL scmsnippet into the URL; for example: https://example.scm.azurewebsites.net Copy Check for the Kudu logo with a black navigation bar at the top left of the page and your Azure username at the top right of the page. Then, to change the log level within the Kudu Console: From the Kudu Console navigation bar, select the Debug console menu, then select either CMD or PowerShell. Navigate to D:\\home\\site\\wwwroot\\newrelic. To edit newrelic.config, select the pencil icon. Change <log level=\"info\"> to <log level=\"debug\"> Save the change to newrelic.config. Wait a few minutes for the debug logs to be generated. Use the same steps to switch the log level back to info. Collect system information In addition to agent logs, a Microsoft System Information file is also useful for troubleshooting: From the Windows task bar, select Start > Run and enter msinfo32. Select OK. After the system information page loads, select File > Save. Wait a few minutes for the server to save the file. Attach the file to your New Relic support ticket. Check permissions Sometimes the .NET agent will start but not be able to write to its logs because it does not have the necessary permissions to create the log directory and log files. Permissions management varies by environment, so you will need to work with your system administrator to verify that this is not an issue. For more help For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 83.13534,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate logs for <em>troubleshooting</em> (.<em>NET</em>)",
        "sections": "Generate logs for <em>troubleshooting</em> (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> stores two types of log files in the Logs directory at %ALLUSERSPROFILE%\\New Relic\\.<em>NET</em> <em>Agent</em>\\Logs. Both are needed for <em>troubleshooting</em>; for example, if no data appears in the New Relic UI for your app. If either log type is missing, some component of the .<em>NET</em> <em>agent</em> did"
      },
      "id": "603eb5da196a67556aa83dd8"
    },
    {
      "sections": [
        "No Browser data appears (.NET)",
        "Problem",
        "Solution"
      ],
      "title": "No Browser data appears (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "61a0ca0687aa9ebea7c0ce8d99e38822db0eb1cd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/no-browser-data-appears-net/",
      "published_at": "2021-06-02T16:50:18Z",
      "updated_at": "2021-03-11T02:34:52Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem After generating traffic and waiting five minutes, you do not see any browser monitoring data for your .NET app. Solution To troubleshoot missing data: Make sure you have installed the latest release of the .NET agent. Follow the troubleshooting procedures for missing data as applicable. Verify whether your pages are rendered using ASPs. If you use another rendering technology, use manual instrumentation. Flush your .NET cache. Set the <head> tag of your pages to render on the server. Verify that your agent is configured to auto-instrument pages. Edit newrelic.config and verify that autoInstrument is set to true: <browserMonitoring autoInstrument=\"true\"/> Copy Check whether IIS page compression is disabled. If compressed before the .NET agent attempts browser instrumentation, the necessary <HEAD> tag won't be found. For instructions on how to check that, see Microsoft documentation. Look at the source of one of your pages through a browser. Look for a script with references to NREUMQ at the top and bottom of your pages. If you get support at support.newrelic.com, mention whether you are seeing this JavaScript in the page header or in some other location in the page, or you are not seeing it at all. Here are some additional troubleshooting tips: Browser problems Additional troubleshooting tips for .NET agent IIS exception error With IIS, you may receive an InvalidOperationException that states: Post cache substitution is not compatible with modules in the IIS integrated pipeline that modify the response buffers. Copy To solve this problem, you must manually implement the Browser agent: Set browserMonitoring to false in newrelic.config, and follow the manual instrumentation procedures. Razor framework error With the Razor framework, you may encounter the following message: Parser Error Message: \"\").pop().split(\"\" is not valid at the start of a code block. Only identifiers, keywords, comments, \"(\" and \"{\" are valid. Copy To solve this problem, follow the Browser troubleshooting procedures for Razor frameworks.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 79.93086,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No Browser data appears (.<em>NET</em>)",
        "sections": "No Browser data appears (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem After generating traffic and waiting five minutes, you do not see any browser monitoring data for your .<em>NET</em> app. Solution To <em>troubleshoot</em> missing data: Make sure you have installed the latest release of the .<em>NET</em> <em>agent</em>. Follow the <em>troubleshooting</em> procedures for missing data as applicable"
      },
      "id": "6043f856e7b9d202d65799b5"
    },
    {
      "sections": [
        ".NET agent reports handled errors",
        "Problem",
        "Solution",
        "GetResponse() throws an error",
        "Define a custom instrumentation file",
        "Wrap the method in a custom transaction",
        "Cause"
      ],
      "title": ".NET agent reports handled errors",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "5cd50fdec02b9d8e48348c183e786eac54c312e8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/net-agent-reports-handled-errors/",
      "published_at": "2021-06-02T16:49:23Z",
      "updated_at": "2021-04-29T00:18:04Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem New Relic's .NET agent reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception handler. Instrument the target method by defining a custom instrumentation file, or by wrapping the method in a custom transaction, as shown in this example: GetResponse() throws an error In this example, New Relic reports an error from GetResponse() unless the method Foo() is instrumented. As long is Foo is instrumented, New Relic begins a transaction when Foo is called and ends the transaction when Foo ends. Because the error is handled before Foo ends, New Relic will not report an error. Note also that GetResponse() becomes a segment of the Foo transaction. using System; using System.Collections.Generic; using System.Threading; using System.Threading.Tasks; using System.Net; using System.IO; namespace ErrorTester { class Program { static void Main(string[] args) { var i = 0; while (true) { Foo(++i); } } static void Foo(int i) { try { GetNotFound(); } catch (Exception ex) { Console.WriteLine(\"Got it \" + i + \"!\"); Thread.Sleep(1000); } } static string GetNotFound() { string uri = \"http://localhost/Test/this/is/not/a/real/page\"; var request = (HttpWebRequest)WebRequest.Create(uri); var response = request.GetResponse(); var data = new StreamReader(response.GetResponseStream()).ReadToEnd(); response.Close(); return data; } } } Copy Define a custom instrumentation file To instrument Foo: Define a custom instrumentation file; for example, CustomInstrumentation.xml: <?xml version=\"1.0\" encoding=\"utf-8\"?> <!-- © 2008-2014 New Relic, Inc. All rights reserved. --> <!-- When you edit this file, please use an XML aware editor (such as Visual Studio), and pair with the companion file extension.xsd to minimize the chance of introducing typos that may confuse the agent when it is run. --> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory > <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Place CustomInstrumenation.xml in the New Relic extensions folder, alongside CoreInstrumentation.xml, and restart your application. Wrap the method in a custom transaction To instrument Foo, wrap it in a custom transaction: <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Background/Task\"> <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Cause The only errors New Relic's .NET agent reports are unhandled errors that end a transaction. If your app calls an exception handler before the transaction ends, New Relic will not report an error. However, New Relic does not always detect exception handlers when the error occurs outside of a web transaction, WCF transaction, or custom transaction. This is because the agent creates \"mini-transactions\" for instrumented methods that are not associated with a transaction. When the instrumented method exits, the mini-transaction ends. If the mini-transaction throws an error and the instrumented method does not handle it, then New Relic will report an error. You can see this in a console app that calls GetResponse(), as shown in the example. If GetResponse throws an error, then New Relic will report it, even though GetResponse() is called within a try/catch block. The agent reports an error because the GetResponse() \"mini-transaction\" ended and the error was still unhandled on transaction exit.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 78.57177,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> reports handled errors",
        "sections": ".<em>NET</em> <em>agent</em> reports handled errors",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem New Relic&#x27;s .<em>NET</em> <em>agent</em> reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception"
      },
      "id": "603e910028ccbcc7c0eba7b4"
    }
  ],
  "/docs/agents/net-agent/troubleshooting/net-agent-reports-handled-errors": [
    {
      "sections": [
        "Generate logs for troubleshooting (.NET)",
        "Generate log files",
        "Important",
        "Generate Azure Web App log files",
        "Collect system information",
        "Check permissions",
        "For more help"
      ],
      "title": "Generate logs for troubleshooting (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "3f0c136f4228951c3d2f4bfa1f28e5331b5fa5ca",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/generate-logs-troubleshooting-net/",
      "published_at": "2021-06-02T16:17:55Z",
      "updated_at": "2021-03-16T13:04:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent stores two types of log files in the Logs directory at %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. Both are needed for troubleshooting; for example, if no data appears in the New Relic UI for your app. If either log type is missing, some component of the .NET agent did not start. Agent logs: These file names begin with newrelic_agent_. Profiler logs: These file names begin with NewRelic.Profiler. Generate log files Important When troubleshooting your New Relic .NET agent, ensure it has been configured to generate debug level log files, and monitor the size of your log file closely. Logging at debug generates a lot of data very quickly. After reproducing your problem, return the log level to info. If your C:\\ProgramData\\New Relic\\.NET Agent is in a hidden folder, update your Windows settings so that you can see it. To generate New Relic for .NET log files: Open newrelic.config, usually located in C:\\ProgramData\\New Relic\\.NET Agent (or %ALLUSERSPROFILE%\\New Relic\\.NET Agent). Change the <log level=\"info\" /> setting to <log level=\"debug\" />. Save and close the file, then wait a few minutes for the agent to read the new settings. Generate a few minutes of traffic to your app. If sending your log file to New Relic Support: In your New Relic support ticket, attach the newrelic.config file (not the text of the file), and attach the entire Logs folder from C:\\ProgramData\\New Relic\\.NET Agent\\Logs or from %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. In newrelic.config, change <log level=\"debug\" /> to <log level=\"info\" />. Generate Azure Web App log files Kudu Console manages Microsoft Azure Web App log reporting. To use the Kudu Console, first log into Azure. Navigate to the URL of your Azure Web app; for example: https://example.azurewebsites.net Copy Insert the Kudu Console URL scmsnippet into the URL; for example: https://example.scm.azurewebsites.net Copy Check for the Kudu logo with a black navigation bar at the top left of the page and your Azure username at the top right of the page. Then, to change the log level within the Kudu Console: From the Kudu Console navigation bar, select the Debug console menu, then select either CMD or PowerShell. Navigate to D:\\home\\site\\wwwroot\\newrelic. To edit newrelic.config, select the pencil icon. Change <log level=\"info\"> to <log level=\"debug\"> Save the change to newrelic.config. Wait a few minutes for the debug logs to be generated. Use the same steps to switch the log level back to info. Collect system information In addition to agent logs, a Microsoft System Information file is also useful for troubleshooting: From the Windows task bar, select Start > Run and enter msinfo32. Select OK. After the system information page loads, select File > Save. Wait a few minutes for the server to save the file. Attach the file to your New Relic support ticket. Check permissions Sometimes the .NET agent will start but not be able to write to its logs because it does not have the necessary permissions to create the log directory and log files. Permissions management varies by environment, so you will need to work with your system administrator to verify that this is not an issue. For more help For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 83.13534,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate logs for <em>troubleshooting</em> (.<em>NET</em>)",
        "sections": "Generate logs for <em>troubleshooting</em> (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> stores two types of log files in the Logs directory at %ALLUSERSPROFILE%\\New Relic\\.<em>NET</em> <em>Agent</em>\\Logs. Both are needed for <em>troubleshooting</em>; for example, if no data appears in the New Relic UI for your app. If either log type is missing, some component of the .<em>NET</em> <em>agent</em> did"
      },
      "id": "603eb5da196a67556aa83dd8"
    },
    {
      "sections": [
        "No Browser data appears (.NET)",
        "Problem",
        "Solution"
      ],
      "title": "No Browser data appears (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "61a0ca0687aa9ebea7c0ce8d99e38822db0eb1cd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/no-browser-data-appears-net/",
      "published_at": "2021-06-02T16:50:18Z",
      "updated_at": "2021-03-11T02:34:52Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem After generating traffic and waiting five minutes, you do not see any browser monitoring data for your .NET app. Solution To troubleshoot missing data: Make sure you have installed the latest release of the .NET agent. Follow the troubleshooting procedures for missing data as applicable. Verify whether your pages are rendered using ASPs. If you use another rendering technology, use manual instrumentation. Flush your .NET cache. Set the <head> tag of your pages to render on the server. Verify that your agent is configured to auto-instrument pages. Edit newrelic.config and verify that autoInstrument is set to true: <browserMonitoring autoInstrument=\"true\"/> Copy Check whether IIS page compression is disabled. If compressed before the .NET agent attempts browser instrumentation, the necessary <HEAD> tag won't be found. For instructions on how to check that, see Microsoft documentation. Look at the source of one of your pages through a browser. Look for a script with references to NREUMQ at the top and bottom of your pages. If you get support at support.newrelic.com, mention whether you are seeing this JavaScript in the page header or in some other location in the page, or you are not seeing it at all. Here are some additional troubleshooting tips: Browser problems Additional troubleshooting tips for .NET agent IIS exception error With IIS, you may receive an InvalidOperationException that states: Post cache substitution is not compatible with modules in the IIS integrated pipeline that modify the response buffers. Copy To solve this problem, you must manually implement the Browser agent: Set browserMonitoring to false in newrelic.config, and follow the manual instrumentation procedures. Razor framework error With the Razor framework, you may encounter the following message: Parser Error Message: \"\").pop().split(\"\" is not valid at the start of a code block. Only identifiers, keywords, comments, \"(\" and \"{\" are valid. Copy To solve this problem, follow the Browser troubleshooting procedures for Razor frameworks.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 79.93086,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No Browser data appears (.<em>NET</em>)",
        "sections": "No Browser data appears (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem After generating traffic and waiting five minutes, you do not see any browser monitoring data for your .<em>NET</em> app. Solution To <em>troubleshoot</em> missing data: Make sure you have installed the latest release of the .<em>NET</em> <em>agent</em>. Follow the <em>troubleshooting</em> procedures for missing data as applicable"
      },
      "id": "6043f856e7b9d202d65799b5"
    },
    {
      "sections": [
        "No data appears (.NET)",
        "Problem",
        "Solution",
        "Basic solutions",
        "Advanced solutions"
      ],
      "title": "No data appears (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "ac2a9d51d0845b16c586c49d32266565a7691fad",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/no-data-appears-net/",
      "published_at": "2021-06-02T13:56:50Z",
      "updated_at": "2021-03-16T02:06:20Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem After generating traffic for your app and waiting five minutes, none of your .NET agent data appears in the New Relic UI. Solution The absence of data may occur for several reasons. Common causes for missing data: See the basic troubleshooting solutions. Other situations: If the basic solutions do not solve the problem, the lack of data may be more intrinsic to your system. For more information, see the advanced troubleshooting solutions. Microsoft Azure users: See the Azure troubleshooting solutions. No Browser data appears: See the troubleshooting tips when using the Browser agent. Basic solutions To troubleshoot the most common reasons for missing data, try these solutions as applicable. Basic solutions Comments Check app and framework for compatibility with agent .NET Framework compatibility and requirements or .NET Core compatibility and requirements Configure for short-lived .NET process If you have a short-lived (below 60 seconds) process, it may not report data. For more information, see Monitor short-lived processes. .NET Core: Check Kestrel requirements. Make sure you are using a Kestrel app/web server supported by New Relic. Otherwise, you may need to ensure your .NET agent has .NET Framework support enabled. .NET Core: Check environment variables. Make sure you have configured all the required environment variables, then restart the agent. .NET Framework: Restart IIS. If your app is not receiving traffic, no data will be reported to New Relic. To restart IIS: From a command line, run IISRESET. Verify that traffic is being sent to your application. Run New Relic Diagnostics. To try to automatically identify the issue, use New Relic Diagnostics. Check for profiler conflicts. If you are using Microsoft's System Center Operations Manager (SCOM), follow the troubleshooting procedures to resolve .NET and SCOM conflicts. Review log files. If log files exist, open them and review for errors. Advanced solutions To remedy more complex issues when no data appears, try these solutions as applicable: Advanced solutions Comments .NET Framework: Check Registry permissions. Check for a registry key permissions error. .NET Framework: Run Windows Event Viewer. If applicable: Run the Windows Event Viewer, and look for application events from the New Relic .NET Profiler. Search for messages whose source is the New Relic .NET Profiler or New Relic .NET agent. If there are no New Relic event messages, look for messages from the .NET Runtime. For more information, see No data or event log: CoCreate errors. Get debug logs. If your logs did not show errors, increase the logging level temporarily to collect debug logs. Check proxy settings. Ensure your proxy settings are correct and that your settings include a host attribute. Get additional help. If data still does not appear, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 78.13378,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No data appears (.<em>NET</em>)",
        "sections": "No data appears (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem After generating traffic for your app and waiting five minutes, none of your .<em>NET</em> <em>agent</em> data appears in the New Relic UI. Solution The absence of data may occur for several reasons. Common causes for missing data: See the basic <em>troubleshooting</em> solutions. Other situations: If the basic"
      },
      "id": "603e7f2728ccbc2cc8eba7a6"
    }
  ],
  "/docs/agents/net-agent/troubleshooting/new-relic-net-status-monitor": [
    {
      "sections": [
        "Generate logs for troubleshooting (.NET)",
        "Generate log files",
        "Important",
        "Generate Azure Web App log files",
        "Collect system information",
        "Check permissions",
        "For more help"
      ],
      "title": "Generate logs for troubleshooting (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "3f0c136f4228951c3d2f4bfa1f28e5331b5fa5ca",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/generate-logs-troubleshooting-net/",
      "published_at": "2021-06-02T16:17:55Z",
      "updated_at": "2021-03-16T13:04:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent stores two types of log files in the Logs directory at %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. Both are needed for troubleshooting; for example, if no data appears in the New Relic UI for your app. If either log type is missing, some component of the .NET agent did not start. Agent logs: These file names begin with newrelic_agent_. Profiler logs: These file names begin with NewRelic.Profiler. Generate log files Important When troubleshooting your New Relic .NET agent, ensure it has been configured to generate debug level log files, and monitor the size of your log file closely. Logging at debug generates a lot of data very quickly. After reproducing your problem, return the log level to info. If your C:\\ProgramData\\New Relic\\.NET Agent is in a hidden folder, update your Windows settings so that you can see it. To generate New Relic for .NET log files: Open newrelic.config, usually located in C:\\ProgramData\\New Relic\\.NET Agent (or %ALLUSERSPROFILE%\\New Relic\\.NET Agent). Change the <log level=\"info\" /> setting to <log level=\"debug\" />. Save and close the file, then wait a few minutes for the agent to read the new settings. Generate a few minutes of traffic to your app. If sending your log file to New Relic Support: In your New Relic support ticket, attach the newrelic.config file (not the text of the file), and attach the entire Logs folder from C:\\ProgramData\\New Relic\\.NET Agent\\Logs or from %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. In newrelic.config, change <log level=\"debug\" /> to <log level=\"info\" />. Generate Azure Web App log files Kudu Console manages Microsoft Azure Web App log reporting. To use the Kudu Console, first log into Azure. Navigate to the URL of your Azure Web app; for example: https://example.azurewebsites.net Copy Insert the Kudu Console URL scmsnippet into the URL; for example: https://example.scm.azurewebsites.net Copy Check for the Kudu logo with a black navigation bar at the top left of the page and your Azure username at the top right of the page. Then, to change the log level within the Kudu Console: From the Kudu Console navigation bar, select the Debug console menu, then select either CMD or PowerShell. Navigate to D:\\home\\site\\wwwroot\\newrelic. To edit newrelic.config, select the pencil icon. Change <log level=\"info\"> to <log level=\"debug\"> Save the change to newrelic.config. Wait a few minutes for the debug logs to be generated. Use the same steps to switch the log level back to info. Collect system information In addition to agent logs, a Microsoft System Information file is also useful for troubleshooting: From the Windows task bar, select Start > Run and enter msinfo32. Select OK. After the system information page loads, select File > Save. Wait a few minutes for the server to save the file. Attach the file to your New Relic support ticket. Check permissions Sometimes the .NET agent will start but not be able to write to its logs because it does not have the necessary permissions to create the log directory and log files. Permissions management varies by environment, so you will need to work with your system administrator to verify that this is not an issue. For more help For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 83.13534,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate logs for <em>troubleshooting</em> (.<em>NET</em>)",
        "sections": "Generate logs for <em>troubleshooting</em> (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> stores two types of log files in the Logs directory at %ALLUSERSPROFILE%\\New Relic\\.<em>NET</em> <em>Agent</em>\\Logs. Both are needed for <em>troubleshooting</em>; for example, if no data appears in the New Relic UI for your app. If either log type is missing, some component of the .<em>NET</em> <em>agent</em> did"
      },
      "id": "603eb5da196a67556aa83dd8"
    },
    {
      "sections": [
        "No Browser data appears (.NET)",
        "Problem",
        "Solution"
      ],
      "title": "No Browser data appears (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "61a0ca0687aa9ebea7c0ce8d99e38822db0eb1cd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/no-browser-data-appears-net/",
      "published_at": "2021-06-02T16:50:18Z",
      "updated_at": "2021-03-11T02:34:52Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem After generating traffic and waiting five minutes, you do not see any browser monitoring data for your .NET app. Solution To troubleshoot missing data: Make sure you have installed the latest release of the .NET agent. Follow the troubleshooting procedures for missing data as applicable. Verify whether your pages are rendered using ASPs. If you use another rendering technology, use manual instrumentation. Flush your .NET cache. Set the <head> tag of your pages to render on the server. Verify that your agent is configured to auto-instrument pages. Edit newrelic.config and verify that autoInstrument is set to true: <browserMonitoring autoInstrument=\"true\"/> Copy Check whether IIS page compression is disabled. If compressed before the .NET agent attempts browser instrumentation, the necessary <HEAD> tag won't be found. For instructions on how to check that, see Microsoft documentation. Look at the source of one of your pages through a browser. Look for a script with references to NREUMQ at the top and bottom of your pages. If you get support at support.newrelic.com, mention whether you are seeing this JavaScript in the page header or in some other location in the page, or you are not seeing it at all. Here are some additional troubleshooting tips: Browser problems Additional troubleshooting tips for .NET agent IIS exception error With IIS, you may receive an InvalidOperationException that states: Post cache substitution is not compatible with modules in the IIS integrated pipeline that modify the response buffers. Copy To solve this problem, you must manually implement the Browser agent: Set browserMonitoring to false in newrelic.config, and follow the manual instrumentation procedures. Razor framework error With the Razor framework, you may encounter the following message: Parser Error Message: \"\").pop().split(\"\" is not valid at the start of a code block. Only identifiers, keywords, comments, \"(\" and \"{\" are valid. Copy To solve this problem, follow the Browser troubleshooting procedures for Razor frameworks.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 79.93086,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No Browser data appears (.<em>NET</em>)",
        "sections": "No Browser data appears (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem After generating traffic and waiting five minutes, you do not see any browser monitoring data for your .<em>NET</em> app. Solution To <em>troubleshoot</em> missing data: Make sure you have installed the latest release of the .<em>NET</em> <em>agent</em>. Follow the <em>troubleshooting</em> procedures for missing data as applicable"
      },
      "id": "6043f856e7b9d202d65799b5"
    },
    {
      "sections": [
        ".NET agent reports handled errors",
        "Problem",
        "Solution",
        "GetResponse() throws an error",
        "Define a custom instrumentation file",
        "Wrap the method in a custom transaction",
        "Cause"
      ],
      "title": ".NET agent reports handled errors",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "5cd50fdec02b9d8e48348c183e786eac54c312e8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/net-agent-reports-handled-errors/",
      "published_at": "2021-06-02T16:49:23Z",
      "updated_at": "2021-04-29T00:18:04Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem New Relic's .NET agent reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception handler. Instrument the target method by defining a custom instrumentation file, or by wrapping the method in a custom transaction, as shown in this example: GetResponse() throws an error In this example, New Relic reports an error from GetResponse() unless the method Foo() is instrumented. As long is Foo is instrumented, New Relic begins a transaction when Foo is called and ends the transaction when Foo ends. Because the error is handled before Foo ends, New Relic will not report an error. Note also that GetResponse() becomes a segment of the Foo transaction. using System; using System.Collections.Generic; using System.Threading; using System.Threading.Tasks; using System.Net; using System.IO; namespace ErrorTester { class Program { static void Main(string[] args) { var i = 0; while (true) { Foo(++i); } } static void Foo(int i) { try { GetNotFound(); } catch (Exception ex) { Console.WriteLine(\"Got it \" + i + \"!\"); Thread.Sleep(1000); } } static string GetNotFound() { string uri = \"http://localhost/Test/this/is/not/a/real/page\"; var request = (HttpWebRequest)WebRequest.Create(uri); var response = request.GetResponse(); var data = new StreamReader(response.GetResponseStream()).ReadToEnd(); response.Close(); return data; } } } Copy Define a custom instrumentation file To instrument Foo: Define a custom instrumentation file; for example, CustomInstrumentation.xml: <?xml version=\"1.0\" encoding=\"utf-8\"?> <!-- © 2008-2014 New Relic, Inc. All rights reserved. --> <!-- When you edit this file, please use an XML aware editor (such as Visual Studio), and pair with the companion file extension.xsd to minimize the chance of introducing typos that may confuse the agent when it is run. --> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory > <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Place CustomInstrumenation.xml in the New Relic extensions folder, alongside CoreInstrumentation.xml, and restart your application. Wrap the method in a custom transaction To instrument Foo, wrap it in a custom transaction: <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Background/Task\"> <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Cause The only errors New Relic's .NET agent reports are unhandled errors that end a transaction. If your app calls an exception handler before the transaction ends, New Relic will not report an error. However, New Relic does not always detect exception handlers when the error occurs outside of a web transaction, WCF transaction, or custom transaction. This is because the agent creates \"mini-transactions\" for instrumented methods that are not associated with a transaction. When the instrumented method exits, the mini-transaction ends. If the mini-transaction throws an error and the instrumented method does not handle it, then New Relic will report an error. You can see this in a console app that calls GetResponse(), as shown in the example. If GetResponse throws an error, then New Relic will report it, even though GetResponse() is called within a try/catch block. The agent reports an error because the GetResponse() \"mini-transaction\" ended and the error was still unhandled on transaction exit.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 78.57176,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> reports handled errors",
        "sections": ".<em>NET</em> <em>agent</em> reports handled errors",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem New Relic&#x27;s .<em>NET</em> <em>agent</em> reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception"
      },
      "id": "603e910028ccbcc7c0eba7b4"
    }
  ],
  "/docs/agents/net-agent/troubleshooting/no-browser-data-appears-net": [
    {
      "sections": [
        "Generate logs for troubleshooting (.NET)",
        "Generate log files",
        "Important",
        "Generate Azure Web App log files",
        "Collect system information",
        "Check permissions",
        "For more help"
      ],
      "title": "Generate logs for troubleshooting (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "3f0c136f4228951c3d2f4bfa1f28e5331b5fa5ca",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/generate-logs-troubleshooting-net/",
      "published_at": "2021-06-02T16:17:55Z",
      "updated_at": "2021-03-16T13:04:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent stores two types of log files in the Logs directory at %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. Both are needed for troubleshooting; for example, if no data appears in the New Relic UI for your app. If either log type is missing, some component of the .NET agent did not start. Agent logs: These file names begin with newrelic_agent_. Profiler logs: These file names begin with NewRelic.Profiler. Generate log files Important When troubleshooting your New Relic .NET agent, ensure it has been configured to generate debug level log files, and monitor the size of your log file closely. Logging at debug generates a lot of data very quickly. After reproducing your problem, return the log level to info. If your C:\\ProgramData\\New Relic\\.NET Agent is in a hidden folder, update your Windows settings so that you can see it. To generate New Relic for .NET log files: Open newrelic.config, usually located in C:\\ProgramData\\New Relic\\.NET Agent (or %ALLUSERSPROFILE%\\New Relic\\.NET Agent). Change the <log level=\"info\" /> setting to <log level=\"debug\" />. Save and close the file, then wait a few minutes for the agent to read the new settings. Generate a few minutes of traffic to your app. If sending your log file to New Relic Support: In your New Relic support ticket, attach the newrelic.config file (not the text of the file), and attach the entire Logs folder from C:\\ProgramData\\New Relic\\.NET Agent\\Logs or from %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. In newrelic.config, change <log level=\"debug\" /> to <log level=\"info\" />. Generate Azure Web App log files Kudu Console manages Microsoft Azure Web App log reporting. To use the Kudu Console, first log into Azure. Navigate to the URL of your Azure Web app; for example: https://example.azurewebsites.net Copy Insert the Kudu Console URL scmsnippet into the URL; for example: https://example.scm.azurewebsites.net Copy Check for the Kudu logo with a black navigation bar at the top left of the page and your Azure username at the top right of the page. Then, to change the log level within the Kudu Console: From the Kudu Console navigation bar, select the Debug console menu, then select either CMD or PowerShell. Navigate to D:\\home\\site\\wwwroot\\newrelic. To edit newrelic.config, select the pencil icon. Change <log level=\"info\"> to <log level=\"debug\"> Save the change to newrelic.config. Wait a few minutes for the debug logs to be generated. Use the same steps to switch the log level back to info. Collect system information In addition to agent logs, a Microsoft System Information file is also useful for troubleshooting: From the Windows task bar, select Start > Run and enter msinfo32. Select OK. After the system information page loads, select File > Save. Wait a few minutes for the server to save the file. Attach the file to your New Relic support ticket. Check permissions Sometimes the .NET agent will start but not be able to write to its logs because it does not have the necessary permissions to create the log directory and log files. Permissions management varies by environment, so you will need to work with your system administrator to verify that this is not an issue. For more help For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 83.13534,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate logs for <em>troubleshooting</em> (.<em>NET</em>)",
        "sections": "Generate logs for <em>troubleshooting</em> (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> stores two types of log files in the Logs directory at %ALLUSERSPROFILE%\\New Relic\\.<em>NET</em> <em>Agent</em>\\Logs. Both are needed for <em>troubleshooting</em>; for example, if no data appears in the New Relic UI for your app. If either log type is missing, some component of the .<em>NET</em> <em>agent</em> did"
      },
      "id": "603eb5da196a67556aa83dd8"
    },
    {
      "sections": [
        ".NET agent reports handled errors",
        "Problem",
        "Solution",
        "GetResponse() throws an error",
        "Define a custom instrumentation file",
        "Wrap the method in a custom transaction",
        "Cause"
      ],
      "title": ".NET agent reports handled errors",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "5cd50fdec02b9d8e48348c183e786eac54c312e8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/net-agent-reports-handled-errors/",
      "published_at": "2021-06-02T16:49:23Z",
      "updated_at": "2021-04-29T00:18:04Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem New Relic's .NET agent reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception handler. Instrument the target method by defining a custom instrumentation file, or by wrapping the method in a custom transaction, as shown in this example: GetResponse() throws an error In this example, New Relic reports an error from GetResponse() unless the method Foo() is instrumented. As long is Foo is instrumented, New Relic begins a transaction when Foo is called and ends the transaction when Foo ends. Because the error is handled before Foo ends, New Relic will not report an error. Note also that GetResponse() becomes a segment of the Foo transaction. using System; using System.Collections.Generic; using System.Threading; using System.Threading.Tasks; using System.Net; using System.IO; namespace ErrorTester { class Program { static void Main(string[] args) { var i = 0; while (true) { Foo(++i); } } static void Foo(int i) { try { GetNotFound(); } catch (Exception ex) { Console.WriteLine(\"Got it \" + i + \"!\"); Thread.Sleep(1000); } } static string GetNotFound() { string uri = \"http://localhost/Test/this/is/not/a/real/page\"; var request = (HttpWebRequest)WebRequest.Create(uri); var response = request.GetResponse(); var data = new StreamReader(response.GetResponseStream()).ReadToEnd(); response.Close(); return data; } } } Copy Define a custom instrumentation file To instrument Foo: Define a custom instrumentation file; for example, CustomInstrumentation.xml: <?xml version=\"1.0\" encoding=\"utf-8\"?> <!-- © 2008-2014 New Relic, Inc. All rights reserved. --> <!-- When you edit this file, please use an XML aware editor (such as Visual Studio), and pair with the companion file extension.xsd to minimize the chance of introducing typos that may confuse the agent when it is run. --> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory > <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Place CustomInstrumenation.xml in the New Relic extensions folder, alongside CoreInstrumentation.xml, and restart your application. Wrap the method in a custom transaction To instrument Foo, wrap it in a custom transaction: <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Background/Task\"> <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Cause The only errors New Relic's .NET agent reports are unhandled errors that end a transaction. If your app calls an exception handler before the transaction ends, New Relic will not report an error. However, New Relic does not always detect exception handlers when the error occurs outside of a web transaction, WCF transaction, or custom transaction. This is because the agent creates \"mini-transactions\" for instrumented methods that are not associated with a transaction. When the instrumented method exits, the mini-transaction ends. If the mini-transaction throws an error and the instrumented method does not handle it, then New Relic will report an error. You can see this in a console app that calls GetResponse(), as shown in the example. If GetResponse throws an error, then New Relic will report it, even though GetResponse() is called within a try/catch block. The agent reports an error because the GetResponse() \"mini-transaction\" ended and the error was still unhandled on transaction exit.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 78.57176,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> reports handled errors",
        "sections": ".<em>NET</em> <em>agent</em> reports handled errors",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem New Relic&#x27;s .<em>NET</em> <em>agent</em> reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception"
      },
      "id": "603e910028ccbcc7c0eba7b4"
    },
    {
      "sections": [
        "No data appears (.NET)",
        "Problem",
        "Solution",
        "Basic solutions",
        "Advanced solutions"
      ],
      "title": "No data appears (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "ac2a9d51d0845b16c586c49d32266565a7691fad",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/no-data-appears-net/",
      "published_at": "2021-06-02T13:56:50Z",
      "updated_at": "2021-03-16T02:06:20Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem After generating traffic for your app and waiting five minutes, none of your .NET agent data appears in the New Relic UI. Solution The absence of data may occur for several reasons. Common causes for missing data: See the basic troubleshooting solutions. Other situations: If the basic solutions do not solve the problem, the lack of data may be more intrinsic to your system. For more information, see the advanced troubleshooting solutions. Microsoft Azure users: See the Azure troubleshooting solutions. No Browser data appears: See the troubleshooting tips when using the Browser agent. Basic solutions To troubleshoot the most common reasons for missing data, try these solutions as applicable. Basic solutions Comments Check app and framework for compatibility with agent .NET Framework compatibility and requirements or .NET Core compatibility and requirements Configure for short-lived .NET process If you have a short-lived (below 60 seconds) process, it may not report data. For more information, see Monitor short-lived processes. .NET Core: Check Kestrel requirements. Make sure you are using a Kestrel app/web server supported by New Relic. Otherwise, you may need to ensure your .NET agent has .NET Framework support enabled. .NET Core: Check environment variables. Make sure you have configured all the required environment variables, then restart the agent. .NET Framework: Restart IIS. If your app is not receiving traffic, no data will be reported to New Relic. To restart IIS: From a command line, run IISRESET. Verify that traffic is being sent to your application. Run New Relic Diagnostics. To try to automatically identify the issue, use New Relic Diagnostics. Check for profiler conflicts. If you are using Microsoft's System Center Operations Manager (SCOM), follow the troubleshooting procedures to resolve .NET and SCOM conflicts. Review log files. If log files exist, open them and review for errors. Advanced solutions To remedy more complex issues when no data appears, try these solutions as applicable: Advanced solutions Comments .NET Framework: Check Registry permissions. Check for a registry key permissions error. .NET Framework: Run Windows Event Viewer. If applicable: Run the Windows Event Viewer, and look for application events from the New Relic .NET Profiler. Search for messages whose source is the New Relic .NET Profiler or New Relic .NET agent. If there are no New Relic event messages, look for messages from the .NET Runtime. For more information, see No data or event log: CoCreate errors. Get debug logs. If your logs did not show errors, increase the logging level temporarily to collect debug logs. Check proxy settings. Ensure your proxy settings are correct and that your settings include a host attribute. Get additional help. If data still does not appear, get support at support.newrelic.com.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 78.13378,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No data appears (.<em>NET</em>)",
        "sections": "No data appears (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem After generating traffic for your app and waiting five minutes, none of your .<em>NET</em> <em>agent</em> data appears in the New Relic UI. Solution The absence of data may occur for several reasons. Common causes for missing data: See the basic <em>troubleshooting</em> solutions. Other situations: If the basic"
      },
      "id": "603e7f2728ccbc2cc8eba7a6"
    }
  ],
  "/docs/agents/net-agent/troubleshooting/no-data-appears-after-disabling-tls-10": [
    {
      "sections": [
        "Generate logs for troubleshooting (.NET)",
        "Generate log files",
        "Important",
        "Generate Azure Web App log files",
        "Collect system information",
        "Check permissions",
        "For more help"
      ],
      "title": "Generate logs for troubleshooting (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "3f0c136f4228951c3d2f4bfa1f28e5331b5fa5ca",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/generate-logs-troubleshooting-net/",
      "published_at": "2021-06-02T16:17:55Z",
      "updated_at": "2021-03-16T13:04:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent stores two types of log files in the Logs directory at %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. Both are needed for troubleshooting; for example, if no data appears in the New Relic UI for your app. If either log type is missing, some component of the .NET agent did not start. Agent logs: These file names begin with newrelic_agent_. Profiler logs: These file names begin with NewRelic.Profiler. Generate log files Important When troubleshooting your New Relic .NET agent, ensure it has been configured to generate debug level log files, and monitor the size of your log file closely. Logging at debug generates a lot of data very quickly. After reproducing your problem, return the log level to info. If your C:\\ProgramData\\New Relic\\.NET Agent is in a hidden folder, update your Windows settings so that you can see it. To generate New Relic for .NET log files: Open newrelic.config, usually located in C:\\ProgramData\\New Relic\\.NET Agent (or %ALLUSERSPROFILE%\\New Relic\\.NET Agent). Change the <log level=\"info\" /> setting to <log level=\"debug\" />. Save and close the file, then wait a few minutes for the agent to read the new settings. Generate a few minutes of traffic to your app. If sending your log file to New Relic Support: In your New Relic support ticket, attach the newrelic.config file (not the text of the file), and attach the entire Logs folder from C:\\ProgramData\\New Relic\\.NET Agent\\Logs or from %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. In newrelic.config, change <log level=\"debug\" /> to <log level=\"info\" />. Generate Azure Web App log files Kudu Console manages Microsoft Azure Web App log reporting. To use the Kudu Console, first log into Azure. Navigate to the URL of your Azure Web app; for example: https://example.azurewebsites.net Copy Insert the Kudu Console URL scmsnippet into the URL; for example: https://example.scm.azurewebsites.net Copy Check for the Kudu logo with a black navigation bar at the top left of the page and your Azure username at the top right of the page. Then, to change the log level within the Kudu Console: From the Kudu Console navigation bar, select the Debug console menu, then select either CMD or PowerShell. Navigate to D:\\home\\site\\wwwroot\\newrelic. To edit newrelic.config, select the pencil icon. Change <log level=\"info\"> to <log level=\"debug\"> Save the change to newrelic.config. Wait a few minutes for the debug logs to be generated. Use the same steps to switch the log level back to info. Collect system information In addition to agent logs, a Microsoft System Information file is also useful for troubleshooting: From the Windows task bar, select Start > Run and enter msinfo32. Select OK. After the system information page loads, select File > Save. Wait a few minutes for the server to save the file. Attach the file to your New Relic support ticket. Check permissions Sometimes the .NET agent will start but not be able to write to its logs because it does not have the necessary permissions to create the log directory and log files. Permissions management varies by environment, so you will need to work with your system administrator to verify that this is not an issue. For more help For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 83.13533,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate logs for <em>troubleshooting</em> (.<em>NET</em>)",
        "sections": "Generate logs for <em>troubleshooting</em> (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> stores two types of log files in the Logs directory at %ALLUSERSPROFILE%\\New Relic\\.<em>NET</em> <em>Agent</em>\\Logs. Both are needed for <em>troubleshooting</em>; for example, if no data appears in the New Relic UI for your app. If either log type is missing, some component of the .<em>NET</em> <em>agent</em> did"
      },
      "id": "603eb5da196a67556aa83dd8"
    },
    {
      "sections": [
        "No Browser data appears (.NET)",
        "Problem",
        "Solution"
      ],
      "title": "No Browser data appears (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "61a0ca0687aa9ebea7c0ce8d99e38822db0eb1cd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/no-browser-data-appears-net/",
      "published_at": "2021-06-02T16:50:18Z",
      "updated_at": "2021-03-11T02:34:52Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem After generating traffic and waiting five minutes, you do not see any browser monitoring data for your .NET app. Solution To troubleshoot missing data: Make sure you have installed the latest release of the .NET agent. Follow the troubleshooting procedures for missing data as applicable. Verify whether your pages are rendered using ASPs. If you use another rendering technology, use manual instrumentation. Flush your .NET cache. Set the <head> tag of your pages to render on the server. Verify that your agent is configured to auto-instrument pages. Edit newrelic.config and verify that autoInstrument is set to true: <browserMonitoring autoInstrument=\"true\"/> Copy Check whether IIS page compression is disabled. If compressed before the .NET agent attempts browser instrumentation, the necessary <HEAD> tag won't be found. For instructions on how to check that, see Microsoft documentation. Look at the source of one of your pages through a browser. Look for a script with references to NREUMQ at the top and bottom of your pages. If you get support at support.newrelic.com, mention whether you are seeing this JavaScript in the page header or in some other location in the page, or you are not seeing it at all. Here are some additional troubleshooting tips: Browser problems Additional troubleshooting tips for .NET agent IIS exception error With IIS, you may receive an InvalidOperationException that states: Post cache substitution is not compatible with modules in the IIS integrated pipeline that modify the response buffers. Copy To solve this problem, you must manually implement the Browser agent: Set browserMonitoring to false in newrelic.config, and follow the manual instrumentation procedures. Razor framework error With the Razor framework, you may encounter the following message: Parser Error Message: \"\").pop().split(\"\" is not valid at the start of a code block. Only identifiers, keywords, comments, \"(\" and \"{\" are valid. Copy To solve this problem, follow the Browser troubleshooting procedures for Razor frameworks.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 79.93086,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No Browser data appears (.<em>NET</em>)",
        "sections": "No Browser data appears (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem After generating traffic and waiting five minutes, you do not see any browser monitoring data for your .<em>NET</em> app. Solution To <em>troubleshoot</em> missing data: Make sure you have installed the latest release of the .<em>NET</em> <em>agent</em>. Follow the <em>troubleshooting</em> procedures for missing data as applicable"
      },
      "id": "6043f856e7b9d202d65799b5"
    },
    {
      "sections": [
        ".NET agent reports handled errors",
        "Problem",
        "Solution",
        "GetResponse() throws an error",
        "Define a custom instrumentation file",
        "Wrap the method in a custom transaction",
        "Cause"
      ],
      "title": ".NET agent reports handled errors",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "5cd50fdec02b9d8e48348c183e786eac54c312e8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/net-agent-reports-handled-errors/",
      "published_at": "2021-06-02T16:49:23Z",
      "updated_at": "2021-04-29T00:18:04Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem New Relic's .NET agent reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception handler. Instrument the target method by defining a custom instrumentation file, or by wrapping the method in a custom transaction, as shown in this example: GetResponse() throws an error In this example, New Relic reports an error from GetResponse() unless the method Foo() is instrumented. As long is Foo is instrumented, New Relic begins a transaction when Foo is called and ends the transaction when Foo ends. Because the error is handled before Foo ends, New Relic will not report an error. Note also that GetResponse() becomes a segment of the Foo transaction. using System; using System.Collections.Generic; using System.Threading; using System.Threading.Tasks; using System.Net; using System.IO; namespace ErrorTester { class Program { static void Main(string[] args) { var i = 0; while (true) { Foo(++i); } } static void Foo(int i) { try { GetNotFound(); } catch (Exception ex) { Console.WriteLine(\"Got it \" + i + \"!\"); Thread.Sleep(1000); } } static string GetNotFound() { string uri = \"http://localhost/Test/this/is/not/a/real/page\"; var request = (HttpWebRequest)WebRequest.Create(uri); var response = request.GetResponse(); var data = new StreamReader(response.GetResponseStream()).ReadToEnd(); response.Close(); return data; } } } Copy Define a custom instrumentation file To instrument Foo: Define a custom instrumentation file; for example, CustomInstrumentation.xml: <?xml version=\"1.0\" encoding=\"utf-8\"?> <!-- © 2008-2014 New Relic, Inc. All rights reserved. --> <!-- When you edit this file, please use an XML aware editor (such as Visual Studio), and pair with the companion file extension.xsd to minimize the chance of introducing typos that may confuse the agent when it is run. --> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory > <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Place CustomInstrumenation.xml in the New Relic extensions folder, alongside CoreInstrumentation.xml, and restart your application. Wrap the method in a custom transaction To instrument Foo, wrap it in a custom transaction: <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Background/Task\"> <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Cause The only errors New Relic's .NET agent reports are unhandled errors that end a transaction. If your app calls an exception handler before the transaction ends, New Relic will not report an error. However, New Relic does not always detect exception handlers when the error occurs outside of a web transaction, WCF transaction, or custom transaction. This is because the agent creates \"mini-transactions\" for instrumented methods that are not associated with a transaction. When the instrumented method exits, the mini-transaction ends. If the mini-transaction throws an error and the instrumented method does not handle it, then New Relic will report an error. You can see this in a console app that calls GetResponse(), as shown in the example. If GetResponse throws an error, then New Relic will report it, even though GetResponse() is called within a try/catch block. The agent reports an error because the GetResponse() \"mini-transaction\" ended and the error was still unhandled on transaction exit.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 78.57176,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> reports handled errors",
        "sections": ".<em>NET</em> <em>agent</em> reports handled errors",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem New Relic&#x27;s .<em>NET</em> <em>agent</em> reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception"
      },
      "id": "603e910028ccbcc7c0eba7b4"
    }
  ],
  "/docs/agents/net-agent/troubleshooting/no-data-appears-net": [
    {
      "sections": [
        "Generate logs for troubleshooting (.NET)",
        "Generate log files",
        "Important",
        "Generate Azure Web App log files",
        "Collect system information",
        "Check permissions",
        "For more help"
      ],
      "title": "Generate logs for troubleshooting (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "3f0c136f4228951c3d2f4bfa1f28e5331b5fa5ca",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/generate-logs-troubleshooting-net/",
      "published_at": "2021-06-02T16:17:55Z",
      "updated_at": "2021-03-16T13:04:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent stores two types of log files in the Logs directory at %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. Both are needed for troubleshooting; for example, if no data appears in the New Relic UI for your app. If either log type is missing, some component of the .NET agent did not start. Agent logs: These file names begin with newrelic_agent_. Profiler logs: These file names begin with NewRelic.Profiler. Generate log files Important When troubleshooting your New Relic .NET agent, ensure it has been configured to generate debug level log files, and monitor the size of your log file closely. Logging at debug generates a lot of data very quickly. After reproducing your problem, return the log level to info. If your C:\\ProgramData\\New Relic\\.NET Agent is in a hidden folder, update your Windows settings so that you can see it. To generate New Relic for .NET log files: Open newrelic.config, usually located in C:\\ProgramData\\New Relic\\.NET Agent (or %ALLUSERSPROFILE%\\New Relic\\.NET Agent). Change the <log level=\"info\" /> setting to <log level=\"debug\" />. Save and close the file, then wait a few minutes for the agent to read the new settings. Generate a few minutes of traffic to your app. If sending your log file to New Relic Support: In your New Relic support ticket, attach the newrelic.config file (not the text of the file), and attach the entire Logs folder from C:\\ProgramData\\New Relic\\.NET Agent\\Logs or from %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. In newrelic.config, change <log level=\"debug\" /> to <log level=\"info\" />. Generate Azure Web App log files Kudu Console manages Microsoft Azure Web App log reporting. To use the Kudu Console, first log into Azure. Navigate to the URL of your Azure Web app; for example: https://example.azurewebsites.net Copy Insert the Kudu Console URL scmsnippet into the URL; for example: https://example.scm.azurewebsites.net Copy Check for the Kudu logo with a black navigation bar at the top left of the page and your Azure username at the top right of the page. Then, to change the log level within the Kudu Console: From the Kudu Console navigation bar, select the Debug console menu, then select either CMD or PowerShell. Navigate to D:\\home\\site\\wwwroot\\newrelic. To edit newrelic.config, select the pencil icon. Change <log level=\"info\"> to <log level=\"debug\"> Save the change to newrelic.config. Wait a few minutes for the debug logs to be generated. Use the same steps to switch the log level back to info. Collect system information In addition to agent logs, a Microsoft System Information file is also useful for troubleshooting: From the Windows task bar, select Start > Run and enter msinfo32. Select OK. After the system information page loads, select File > Save. Wait a few minutes for the server to save the file. Attach the file to your New Relic support ticket. Check permissions Sometimes the .NET agent will start but not be able to write to its logs because it does not have the necessary permissions to create the log directory and log files. Permissions management varies by environment, so you will need to work with your system administrator to verify that this is not an issue. For more help For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 83.13533,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate logs for <em>troubleshooting</em> (.<em>NET</em>)",
        "sections": "Generate logs for <em>troubleshooting</em> (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> stores two types of log files in the Logs directory at %ALLUSERSPROFILE%\\New Relic\\.<em>NET</em> <em>Agent</em>\\Logs. Both are needed for <em>troubleshooting</em>; for example, if no data appears in the New Relic UI for your app. If either log type is missing, some component of the .<em>NET</em> <em>agent</em> did"
      },
      "id": "603eb5da196a67556aa83dd8"
    },
    {
      "sections": [
        "No Browser data appears (.NET)",
        "Problem",
        "Solution"
      ],
      "title": "No Browser data appears (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "61a0ca0687aa9ebea7c0ce8d99e38822db0eb1cd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/no-browser-data-appears-net/",
      "published_at": "2021-06-02T16:50:18Z",
      "updated_at": "2021-03-11T02:34:52Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem After generating traffic and waiting five minutes, you do not see any browser monitoring data for your .NET app. Solution To troubleshoot missing data: Make sure you have installed the latest release of the .NET agent. Follow the troubleshooting procedures for missing data as applicable. Verify whether your pages are rendered using ASPs. If you use another rendering technology, use manual instrumentation. Flush your .NET cache. Set the <head> tag of your pages to render on the server. Verify that your agent is configured to auto-instrument pages. Edit newrelic.config and verify that autoInstrument is set to true: <browserMonitoring autoInstrument=\"true\"/> Copy Check whether IIS page compression is disabled. If compressed before the .NET agent attempts browser instrumentation, the necessary <HEAD> tag won't be found. For instructions on how to check that, see Microsoft documentation. Look at the source of one of your pages through a browser. Look for a script with references to NREUMQ at the top and bottom of your pages. If you get support at support.newrelic.com, mention whether you are seeing this JavaScript in the page header or in some other location in the page, or you are not seeing it at all. Here are some additional troubleshooting tips: Browser problems Additional troubleshooting tips for .NET agent IIS exception error With IIS, you may receive an InvalidOperationException that states: Post cache substitution is not compatible with modules in the IIS integrated pipeline that modify the response buffers. Copy To solve this problem, you must manually implement the Browser agent: Set browserMonitoring to false in newrelic.config, and follow the manual instrumentation procedures. Razor framework error With the Razor framework, you may encounter the following message: Parser Error Message: \"\").pop().split(\"\" is not valid at the start of a code block. Only identifiers, keywords, comments, \"(\" and \"{\" are valid. Copy To solve this problem, follow the Browser troubleshooting procedures for Razor frameworks.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 79.93086,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No Browser data appears (.<em>NET</em>)",
        "sections": "No Browser data appears (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem After generating traffic and waiting five minutes, you do not see any browser monitoring data for your .<em>NET</em> app. Solution To <em>troubleshoot</em> missing data: Make sure you have installed the latest release of the .<em>NET</em> <em>agent</em>. Follow the <em>troubleshooting</em> procedures for missing data as applicable"
      },
      "id": "6043f856e7b9d202d65799b5"
    },
    {
      "sections": [
        ".NET agent reports handled errors",
        "Problem",
        "Solution",
        "GetResponse() throws an error",
        "Define a custom instrumentation file",
        "Wrap the method in a custom transaction",
        "Cause"
      ],
      "title": ".NET agent reports handled errors",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "5cd50fdec02b9d8e48348c183e786eac54c312e8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/net-agent-reports-handled-errors/",
      "published_at": "2021-06-02T16:49:23Z",
      "updated_at": "2021-04-29T00:18:04Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem New Relic's .NET agent reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception handler. Instrument the target method by defining a custom instrumentation file, or by wrapping the method in a custom transaction, as shown in this example: GetResponse() throws an error In this example, New Relic reports an error from GetResponse() unless the method Foo() is instrumented. As long is Foo is instrumented, New Relic begins a transaction when Foo is called and ends the transaction when Foo ends. Because the error is handled before Foo ends, New Relic will not report an error. Note also that GetResponse() becomes a segment of the Foo transaction. using System; using System.Collections.Generic; using System.Threading; using System.Threading.Tasks; using System.Net; using System.IO; namespace ErrorTester { class Program { static void Main(string[] args) { var i = 0; while (true) { Foo(++i); } } static void Foo(int i) { try { GetNotFound(); } catch (Exception ex) { Console.WriteLine(\"Got it \" + i + \"!\"); Thread.Sleep(1000); } } static string GetNotFound() { string uri = \"http://localhost/Test/this/is/not/a/real/page\"; var request = (HttpWebRequest)WebRequest.Create(uri); var response = request.GetResponse(); var data = new StreamReader(response.GetResponseStream()).ReadToEnd(); response.Close(); return data; } } } Copy Define a custom instrumentation file To instrument Foo: Define a custom instrumentation file; for example, CustomInstrumentation.xml: <?xml version=\"1.0\" encoding=\"utf-8\"?> <!-- © 2008-2014 New Relic, Inc. All rights reserved. --> <!-- When you edit this file, please use an XML aware editor (such as Visual Studio), and pair with the companion file extension.xsd to minimize the chance of introducing typos that may confuse the agent when it is run. --> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory > <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Place CustomInstrumenation.xml in the New Relic extensions folder, alongside CoreInstrumentation.xml, and restart your application. Wrap the method in a custom transaction To instrument Foo, wrap it in a custom transaction: <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Background/Task\"> <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Cause The only errors New Relic's .NET agent reports are unhandled errors that end a transaction. If your app calls an exception handler before the transaction ends, New Relic will not report an error. However, New Relic does not always detect exception handlers when the error occurs outside of a web transaction, WCF transaction, or custom transaction. This is because the agent creates \"mini-transactions\" for instrumented methods that are not associated with a transaction. When the instrumented method exits, the mini-transaction ends. If the mini-transaction throws an error and the instrumented method does not handle it, then New Relic will report an error. You can see this in a console app that calls GetResponse(), as shown in the example. If GetResponse throws an error, then New Relic will report it, even though GetResponse() is called within a try/catch block. The agent reports an error because the GetResponse() \"mini-transaction\" ended and the error was still unhandled on transaction exit.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 78.57176,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> reports handled errors",
        "sections": ".<em>NET</em> <em>agent</em> reports handled errors",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem New Relic&#x27;s .<em>NET</em> <em>agent</em> reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception"
      },
      "id": "603e910028ccbcc7c0eba7b4"
    }
  ],
  "/docs/agents/net-agent/troubleshooting/no-data-registry-key-permission-issues": [
    {
      "sections": [
        "Generate logs for troubleshooting (.NET)",
        "Generate log files",
        "Important",
        "Generate Azure Web App log files",
        "Collect system information",
        "Check permissions",
        "For more help"
      ],
      "title": "Generate logs for troubleshooting (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "3f0c136f4228951c3d2f4bfa1f28e5331b5fa5ca",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/generate-logs-troubleshooting-net/",
      "published_at": "2021-06-02T16:17:55Z",
      "updated_at": "2021-03-16T13:04:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent stores two types of log files in the Logs directory at %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. Both are needed for troubleshooting; for example, if no data appears in the New Relic UI for your app. If either log type is missing, some component of the .NET agent did not start. Agent logs: These file names begin with newrelic_agent_. Profiler logs: These file names begin with NewRelic.Profiler. Generate log files Important When troubleshooting your New Relic .NET agent, ensure it has been configured to generate debug level log files, and monitor the size of your log file closely. Logging at debug generates a lot of data very quickly. After reproducing your problem, return the log level to info. If your C:\\ProgramData\\New Relic\\.NET Agent is in a hidden folder, update your Windows settings so that you can see it. To generate New Relic for .NET log files: Open newrelic.config, usually located in C:\\ProgramData\\New Relic\\.NET Agent (or %ALLUSERSPROFILE%\\New Relic\\.NET Agent). Change the <log level=\"info\" /> setting to <log level=\"debug\" />. Save and close the file, then wait a few minutes for the agent to read the new settings. Generate a few minutes of traffic to your app. If sending your log file to New Relic Support: In your New Relic support ticket, attach the newrelic.config file (not the text of the file), and attach the entire Logs folder from C:\\ProgramData\\New Relic\\.NET Agent\\Logs or from %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. In newrelic.config, change <log level=\"debug\" /> to <log level=\"info\" />. Generate Azure Web App log files Kudu Console manages Microsoft Azure Web App log reporting. To use the Kudu Console, first log into Azure. Navigate to the URL of your Azure Web app; for example: https://example.azurewebsites.net Copy Insert the Kudu Console URL scmsnippet into the URL; for example: https://example.scm.azurewebsites.net Copy Check for the Kudu logo with a black navigation bar at the top left of the page and your Azure username at the top right of the page. Then, to change the log level within the Kudu Console: From the Kudu Console navigation bar, select the Debug console menu, then select either CMD or PowerShell. Navigate to D:\\home\\site\\wwwroot\\newrelic. To edit newrelic.config, select the pencil icon. Change <log level=\"info\"> to <log level=\"debug\"> Save the change to newrelic.config. Wait a few minutes for the debug logs to be generated. Use the same steps to switch the log level back to info. Collect system information In addition to agent logs, a Microsoft System Information file is also useful for troubleshooting: From the Windows task bar, select Start > Run and enter msinfo32. Select OK. After the system information page loads, select File > Save. Wait a few minutes for the server to save the file. Attach the file to your New Relic support ticket. Check permissions Sometimes the .NET agent will start but not be able to write to its logs because it does not have the necessary permissions to create the log directory and log files. Permissions management varies by environment, so you will need to work with your system administrator to verify that this is not an issue. For more help For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 83.13496,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate logs for <em>troubleshooting</em> (.<em>NET</em>)",
        "sections": "Generate logs for <em>troubleshooting</em> (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> stores two types of log files in the Logs directory at %ALLUSERSPROFILE%\\New Relic\\.<em>NET</em> <em>Agent</em>\\Logs. Both are needed for <em>troubleshooting</em>; for example, if no data appears in the New Relic UI for your app. If either log type is missing, some component of the .<em>NET</em> <em>agent</em> did"
      },
      "id": "603eb5da196a67556aa83dd8"
    },
    {
      "sections": [
        "No Browser data appears (.NET)",
        "Problem",
        "Solution"
      ],
      "title": "No Browser data appears (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "61a0ca0687aa9ebea7c0ce8d99e38822db0eb1cd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/no-browser-data-appears-net/",
      "published_at": "2021-06-02T16:50:18Z",
      "updated_at": "2021-03-11T02:34:52Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem After generating traffic and waiting five minutes, you do not see any browser monitoring data for your .NET app. Solution To troubleshoot missing data: Make sure you have installed the latest release of the .NET agent. Follow the troubleshooting procedures for missing data as applicable. Verify whether your pages are rendered using ASPs. If you use another rendering technology, use manual instrumentation. Flush your .NET cache. Set the <head> tag of your pages to render on the server. Verify that your agent is configured to auto-instrument pages. Edit newrelic.config and verify that autoInstrument is set to true: <browserMonitoring autoInstrument=\"true\"/> Copy Check whether IIS page compression is disabled. If compressed before the .NET agent attempts browser instrumentation, the necessary <HEAD> tag won't be found. For instructions on how to check that, see Microsoft documentation. Look at the source of one of your pages through a browser. Look for a script with references to NREUMQ at the top and bottom of your pages. If you get support at support.newrelic.com, mention whether you are seeing this JavaScript in the page header or in some other location in the page, or you are not seeing it at all. Here are some additional troubleshooting tips: Browser problems Additional troubleshooting tips for .NET agent IIS exception error With IIS, you may receive an InvalidOperationException that states: Post cache substitution is not compatible with modules in the IIS integrated pipeline that modify the response buffers. Copy To solve this problem, you must manually implement the Browser agent: Set browserMonitoring to false in newrelic.config, and follow the manual instrumentation procedures. Razor framework error With the Razor framework, you may encounter the following message: Parser Error Message: \"\").pop().split(\"\" is not valid at the start of a code block. Only identifiers, keywords, comments, \"(\" and \"{\" are valid. Copy To solve this problem, follow the Browser troubleshooting procedures for Razor frameworks.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 79.93053,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No Browser data appears (.<em>NET</em>)",
        "sections": "No Browser data appears (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem After generating traffic and waiting five minutes, you do not see any browser monitoring data for your .<em>NET</em> app. Solution To <em>troubleshoot</em> missing data: Make sure you have installed the latest release of the .<em>NET</em> <em>agent</em>. Follow the <em>troubleshooting</em> procedures for missing data as applicable"
      },
      "id": "6043f856e7b9d202d65799b5"
    },
    {
      "sections": [
        ".NET agent reports handled errors",
        "Problem",
        "Solution",
        "GetResponse() throws an error",
        "Define a custom instrumentation file",
        "Wrap the method in a custom transaction",
        "Cause"
      ],
      "title": ".NET agent reports handled errors",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "5cd50fdec02b9d8e48348c183e786eac54c312e8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/net-agent-reports-handled-errors/",
      "published_at": "2021-06-02T16:49:23Z",
      "updated_at": "2021-04-29T00:18:04Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem New Relic's .NET agent reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception handler. Instrument the target method by defining a custom instrumentation file, or by wrapping the method in a custom transaction, as shown in this example: GetResponse() throws an error In this example, New Relic reports an error from GetResponse() unless the method Foo() is instrumented. As long is Foo is instrumented, New Relic begins a transaction when Foo is called and ends the transaction when Foo ends. Because the error is handled before Foo ends, New Relic will not report an error. Note also that GetResponse() becomes a segment of the Foo transaction. using System; using System.Collections.Generic; using System.Threading; using System.Threading.Tasks; using System.Net; using System.IO; namespace ErrorTester { class Program { static void Main(string[] args) { var i = 0; while (true) { Foo(++i); } } static void Foo(int i) { try { GetNotFound(); } catch (Exception ex) { Console.WriteLine(\"Got it \" + i + \"!\"); Thread.Sleep(1000); } } static string GetNotFound() { string uri = \"http://localhost/Test/this/is/not/a/real/page\"; var request = (HttpWebRequest)WebRequest.Create(uri); var response = request.GetResponse(); var data = new StreamReader(response.GetResponseStream()).ReadToEnd(); response.Close(); return data; } } } Copy Define a custom instrumentation file To instrument Foo: Define a custom instrumentation file; for example, CustomInstrumentation.xml: <?xml version=\"1.0\" encoding=\"utf-8\"?> <!-- © 2008-2014 New Relic, Inc. All rights reserved. --> <!-- When you edit this file, please use an XML aware editor (such as Visual Studio), and pair with the companion file extension.xsd to minimize the chance of introducing typos that may confuse the agent when it is run. --> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory > <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Place CustomInstrumenation.xml in the New Relic extensions folder, alongside CoreInstrumentation.xml, and restart your application. Wrap the method in a custom transaction To instrument Foo, wrap it in a custom transaction: <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Background/Task\"> <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Cause The only errors New Relic's .NET agent reports are unhandled errors that end a transaction. If your app calls an exception handler before the transaction ends, New Relic will not report an error. However, New Relic does not always detect exception handlers when the error occurs outside of a web transaction, WCF transaction, or custom transaction. This is because the agent creates \"mini-transactions\" for instrumented methods that are not associated with a transaction. When the instrumented method exits, the mini-transaction ends. If the mini-transaction throws an error and the instrumented method does not handle it, then New Relic will report an error. You can see this in a console app that calls GetResponse(), as shown in the example. If GetResponse throws an error, then New Relic will report it, even though GetResponse() is called within a try/catch block. The agent reports an error because the GetResponse() \"mini-transaction\" ended and the error was still unhandled on transaction exit.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 78.57176,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> reports handled errors",
        "sections": ".<em>NET</em> <em>agent</em> reports handled errors",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem New Relic&#x27;s .<em>NET</em> <em>agent</em> reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception"
      },
      "id": "603e910028ccbcc7c0eba7b4"
    }
  ],
  "/docs/agents/net-agent/troubleshooting/profiler-conflicts": [
    {
      "sections": [
        "Generate logs for troubleshooting (.NET)",
        "Generate log files",
        "Important",
        "Generate Azure Web App log files",
        "Collect system information",
        "Check permissions",
        "For more help"
      ],
      "title": "Generate logs for troubleshooting (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "3f0c136f4228951c3d2f4bfa1f28e5331b5fa5ca",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/generate-logs-troubleshooting-net/",
      "published_at": "2021-06-02T16:17:55Z",
      "updated_at": "2021-03-16T13:04:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent stores two types of log files in the Logs directory at %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. Both are needed for troubleshooting; for example, if no data appears in the New Relic UI for your app. If either log type is missing, some component of the .NET agent did not start. Agent logs: These file names begin with newrelic_agent_. Profiler logs: These file names begin with NewRelic.Profiler. Generate log files Important When troubleshooting your New Relic .NET agent, ensure it has been configured to generate debug level log files, and monitor the size of your log file closely. Logging at debug generates a lot of data very quickly. After reproducing your problem, return the log level to info. If your C:\\ProgramData\\New Relic\\.NET Agent is in a hidden folder, update your Windows settings so that you can see it. To generate New Relic for .NET log files: Open newrelic.config, usually located in C:\\ProgramData\\New Relic\\.NET Agent (or %ALLUSERSPROFILE%\\New Relic\\.NET Agent). Change the <log level=\"info\" /> setting to <log level=\"debug\" />. Save and close the file, then wait a few minutes for the agent to read the new settings. Generate a few minutes of traffic to your app. If sending your log file to New Relic Support: In your New Relic support ticket, attach the newrelic.config file (not the text of the file), and attach the entire Logs folder from C:\\ProgramData\\New Relic\\.NET Agent\\Logs or from %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. In newrelic.config, change <log level=\"debug\" /> to <log level=\"info\" />. Generate Azure Web App log files Kudu Console manages Microsoft Azure Web App log reporting. To use the Kudu Console, first log into Azure. Navigate to the URL of your Azure Web app; for example: https://example.azurewebsites.net Copy Insert the Kudu Console URL scmsnippet into the URL; for example: https://example.scm.azurewebsites.net Copy Check for the Kudu logo with a black navigation bar at the top left of the page and your Azure username at the top right of the page. Then, to change the log level within the Kudu Console: From the Kudu Console navigation bar, select the Debug console menu, then select either CMD or PowerShell. Navigate to D:\\home\\site\\wwwroot\\newrelic. To edit newrelic.config, select the pencil icon. Change <log level=\"info\"> to <log level=\"debug\"> Save the change to newrelic.config. Wait a few minutes for the debug logs to be generated. Use the same steps to switch the log level back to info. Collect system information In addition to agent logs, a Microsoft System Information file is also useful for troubleshooting: From the Windows task bar, select Start > Run and enter msinfo32. Select OK. After the system information page loads, select File > Save. Wait a few minutes for the server to save the file. Attach the file to your New Relic support ticket. Check permissions Sometimes the .NET agent will start but not be able to write to its logs because it does not have the necessary permissions to create the log directory and log files. Permissions management varies by environment, so you will need to work with your system administrator to verify that this is not an issue. For more help For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 83.13496,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate logs for <em>troubleshooting</em> (.<em>NET</em>)",
        "sections": "Generate logs for <em>troubleshooting</em> (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> stores two types of log files in the Logs directory at %ALLUSERSPROFILE%\\New Relic\\.<em>NET</em> <em>Agent</em>\\Logs. Both are needed for <em>troubleshooting</em>; for example, if no data appears in the New Relic UI for your app. If either log type is missing, some component of the .<em>NET</em> <em>agent</em> did"
      },
      "id": "603eb5da196a67556aa83dd8"
    },
    {
      "sections": [
        "No Browser data appears (.NET)",
        "Problem",
        "Solution"
      ],
      "title": "No Browser data appears (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "61a0ca0687aa9ebea7c0ce8d99e38822db0eb1cd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/no-browser-data-appears-net/",
      "published_at": "2021-06-02T16:50:18Z",
      "updated_at": "2021-03-11T02:34:52Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem After generating traffic and waiting five minutes, you do not see any browser monitoring data for your .NET app. Solution To troubleshoot missing data: Make sure you have installed the latest release of the .NET agent. Follow the troubleshooting procedures for missing data as applicable. Verify whether your pages are rendered using ASPs. If you use another rendering technology, use manual instrumentation. Flush your .NET cache. Set the <head> tag of your pages to render on the server. Verify that your agent is configured to auto-instrument pages. Edit newrelic.config and verify that autoInstrument is set to true: <browserMonitoring autoInstrument=\"true\"/> Copy Check whether IIS page compression is disabled. If compressed before the .NET agent attempts browser instrumentation, the necessary <HEAD> tag won't be found. For instructions on how to check that, see Microsoft documentation. Look at the source of one of your pages through a browser. Look for a script with references to NREUMQ at the top and bottom of your pages. If you get support at support.newrelic.com, mention whether you are seeing this JavaScript in the page header or in some other location in the page, or you are not seeing it at all. Here are some additional troubleshooting tips: Browser problems Additional troubleshooting tips for .NET agent IIS exception error With IIS, you may receive an InvalidOperationException that states: Post cache substitution is not compatible with modules in the IIS integrated pipeline that modify the response buffers. Copy To solve this problem, you must manually implement the Browser agent: Set browserMonitoring to false in newrelic.config, and follow the manual instrumentation procedures. Razor framework error With the Razor framework, you may encounter the following message: Parser Error Message: \"\").pop().split(\"\" is not valid at the start of a code block. Only identifiers, keywords, comments, \"(\" and \"{\" are valid. Copy To solve this problem, follow the Browser troubleshooting procedures for Razor frameworks.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 79.93053,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No Browser data appears (.<em>NET</em>)",
        "sections": "No Browser data appears (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem After generating traffic and waiting five minutes, you do not see any browser monitoring data for your .<em>NET</em> app. Solution To <em>troubleshoot</em> missing data: Make sure you have installed the latest release of the .<em>NET</em> <em>agent</em>. Follow the <em>troubleshooting</em> procedures for missing data as applicable"
      },
      "id": "6043f856e7b9d202d65799b5"
    },
    {
      "sections": [
        ".NET agent reports handled errors",
        "Problem",
        "Solution",
        "GetResponse() throws an error",
        "Define a custom instrumentation file",
        "Wrap the method in a custom transaction",
        "Cause"
      ],
      "title": ".NET agent reports handled errors",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "5cd50fdec02b9d8e48348c183e786eac54c312e8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/net-agent-reports-handled-errors/",
      "published_at": "2021-06-02T16:49:23Z",
      "updated_at": "2021-04-29T00:18:04Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem New Relic's .NET agent reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception handler. Instrument the target method by defining a custom instrumentation file, or by wrapping the method in a custom transaction, as shown in this example: GetResponse() throws an error In this example, New Relic reports an error from GetResponse() unless the method Foo() is instrumented. As long is Foo is instrumented, New Relic begins a transaction when Foo is called and ends the transaction when Foo ends. Because the error is handled before Foo ends, New Relic will not report an error. Note also that GetResponse() becomes a segment of the Foo transaction. using System; using System.Collections.Generic; using System.Threading; using System.Threading.Tasks; using System.Net; using System.IO; namespace ErrorTester { class Program { static void Main(string[] args) { var i = 0; while (true) { Foo(++i); } } static void Foo(int i) { try { GetNotFound(); } catch (Exception ex) { Console.WriteLine(\"Got it \" + i + \"!\"); Thread.Sleep(1000); } } static string GetNotFound() { string uri = \"http://localhost/Test/this/is/not/a/real/page\"; var request = (HttpWebRequest)WebRequest.Create(uri); var response = request.GetResponse(); var data = new StreamReader(response.GetResponseStream()).ReadToEnd(); response.Close(); return data; } } } Copy Define a custom instrumentation file To instrument Foo: Define a custom instrumentation file; for example, CustomInstrumentation.xml: <?xml version=\"1.0\" encoding=\"utf-8\"?> <!-- © 2008-2014 New Relic, Inc. All rights reserved. --> <!-- When you edit this file, please use an XML aware editor (such as Visual Studio), and pair with the companion file extension.xsd to minimize the chance of introducing typos that may confuse the agent when it is run. --> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory > <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Place CustomInstrumenation.xml in the New Relic extensions folder, alongside CoreInstrumentation.xml, and restart your application. Wrap the method in a custom transaction To instrument Foo, wrap it in a custom transaction: <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Background/Task\"> <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Cause The only errors New Relic's .NET agent reports are unhandled errors that end a transaction. If your app calls an exception handler before the transaction ends, New Relic will not report an error. However, New Relic does not always detect exception handlers when the error occurs outside of a web transaction, WCF transaction, or custom transaction. This is because the agent creates \"mini-transactions\" for instrumented methods that are not associated with a transaction. When the instrumented method exits, the mini-transaction ends. If the mini-transaction throws an error and the instrumented method does not handle it, then New Relic will report an error. You can see this in a console app that calls GetResponse(), as shown in the example. If GetResponse throws an error, then New Relic will report it, even though GetResponse() is called within a try/catch block. The agent reports an error because the GetResponse() \"mini-transaction\" ended and the error was still unhandled on transaction exit.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 78.571754,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> reports handled errors",
        "sections": ".<em>NET</em> <em>agent</em> reports handled errors",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem New Relic&#x27;s .<em>NET</em> <em>agent</em> reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception"
      },
      "id": "603e910028ccbcc7c0eba7b4"
    }
  ],
  "/docs/agents/net-agent/troubleshooting/resolve-net-scom-conflicts": [
    {
      "sections": [
        "Generate logs for troubleshooting (.NET)",
        "Generate log files",
        "Important",
        "Generate Azure Web App log files",
        "Collect system information",
        "Check permissions",
        "For more help"
      ],
      "title": "Generate logs for troubleshooting (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "3f0c136f4228951c3d2f4bfa1f28e5331b5fa5ca",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/generate-logs-troubleshooting-net/",
      "published_at": "2021-06-02T16:17:55Z",
      "updated_at": "2021-03-16T13:04:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent stores two types of log files in the Logs directory at %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. Both are needed for troubleshooting; for example, if no data appears in the New Relic UI for your app. If either log type is missing, some component of the .NET agent did not start. Agent logs: These file names begin with newrelic_agent_. Profiler logs: These file names begin with NewRelic.Profiler. Generate log files Important When troubleshooting your New Relic .NET agent, ensure it has been configured to generate debug level log files, and monitor the size of your log file closely. Logging at debug generates a lot of data very quickly. After reproducing your problem, return the log level to info. If your C:\\ProgramData\\New Relic\\.NET Agent is in a hidden folder, update your Windows settings so that you can see it. To generate New Relic for .NET log files: Open newrelic.config, usually located in C:\\ProgramData\\New Relic\\.NET Agent (or %ALLUSERSPROFILE%\\New Relic\\.NET Agent). Change the <log level=\"info\" /> setting to <log level=\"debug\" />. Save and close the file, then wait a few minutes for the agent to read the new settings. Generate a few minutes of traffic to your app. If sending your log file to New Relic Support: In your New Relic support ticket, attach the newrelic.config file (not the text of the file), and attach the entire Logs folder from C:\\ProgramData\\New Relic\\.NET Agent\\Logs or from %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. In newrelic.config, change <log level=\"debug\" /> to <log level=\"info\" />. Generate Azure Web App log files Kudu Console manages Microsoft Azure Web App log reporting. To use the Kudu Console, first log into Azure. Navigate to the URL of your Azure Web app; for example: https://example.azurewebsites.net Copy Insert the Kudu Console URL scmsnippet into the URL; for example: https://example.scm.azurewebsites.net Copy Check for the Kudu logo with a black navigation bar at the top left of the page and your Azure username at the top right of the page. Then, to change the log level within the Kudu Console: From the Kudu Console navigation bar, select the Debug console menu, then select either CMD or PowerShell. Navigate to D:\\home\\site\\wwwroot\\newrelic. To edit newrelic.config, select the pencil icon. Change <log level=\"info\"> to <log level=\"debug\"> Save the change to newrelic.config. Wait a few minutes for the debug logs to be generated. Use the same steps to switch the log level back to info. Collect system information In addition to agent logs, a Microsoft System Information file is also useful for troubleshooting: From the Windows task bar, select Start > Run and enter msinfo32. Select OK. After the system information page loads, select File > Save. Wait a few minutes for the server to save the file. Attach the file to your New Relic support ticket. Check permissions Sometimes the .NET agent will start but not be able to write to its logs because it does not have the necessary permissions to create the log directory and log files. Permissions management varies by environment, so you will need to work with your system administrator to verify that this is not an issue. For more help For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 83.13537,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate logs for <em>troubleshooting</em> (.<em>NET</em>)",
        "sections": "Generate logs for <em>troubleshooting</em> (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> stores two types of log files in the Logs directory at %ALLUSERSPROFILE%\\New Relic\\.<em>NET</em> <em>Agent</em>\\Logs. Both are needed for <em>troubleshooting</em>; for example, if no data appears in the New Relic UI for your app. If either log type is missing, some component of the .<em>NET</em> <em>agent</em> did"
      },
      "id": "603eb5da196a67556aa83dd8"
    },
    {
      "sections": [
        "No Browser data appears (.NET)",
        "Problem",
        "Solution"
      ],
      "title": "No Browser data appears (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "61a0ca0687aa9ebea7c0ce8d99e38822db0eb1cd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/no-browser-data-appears-net/",
      "published_at": "2021-06-02T16:50:18Z",
      "updated_at": "2021-03-11T02:34:52Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem After generating traffic and waiting five minutes, you do not see any browser monitoring data for your .NET app. Solution To troubleshoot missing data: Make sure you have installed the latest release of the .NET agent. Follow the troubleshooting procedures for missing data as applicable. Verify whether your pages are rendered using ASPs. If you use another rendering technology, use manual instrumentation. Flush your .NET cache. Set the <head> tag of your pages to render on the server. Verify that your agent is configured to auto-instrument pages. Edit newrelic.config and verify that autoInstrument is set to true: <browserMonitoring autoInstrument=\"true\"/> Copy Check whether IIS page compression is disabled. If compressed before the .NET agent attempts browser instrumentation, the necessary <HEAD> tag won't be found. For instructions on how to check that, see Microsoft documentation. Look at the source of one of your pages through a browser. Look for a script with references to NREUMQ at the top and bottom of your pages. If you get support at support.newrelic.com, mention whether you are seeing this JavaScript in the page header or in some other location in the page, or you are not seeing it at all. Here are some additional troubleshooting tips: Browser problems Additional troubleshooting tips for .NET agent IIS exception error With IIS, you may receive an InvalidOperationException that states: Post cache substitution is not compatible with modules in the IIS integrated pipeline that modify the response buffers. Copy To solve this problem, you must manually implement the Browser agent: Set browserMonitoring to false in newrelic.config, and follow the manual instrumentation procedures. Razor framework error With the Razor framework, you may encounter the following message: Parser Error Message: \"\").pop().split(\"\" is not valid at the start of a code block. Only identifiers, keywords, comments, \"(\" and \"{\" are valid. Copy To solve this problem, follow the Browser troubleshooting procedures for Razor frameworks.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 79.9309,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No Browser data appears (.<em>NET</em>)",
        "sections": "No Browser data appears (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem After generating traffic and waiting five minutes, you do not see any browser monitoring data for your .<em>NET</em> app. Solution To <em>troubleshoot</em> missing data: Make sure you have installed the latest release of the .<em>NET</em> <em>agent</em>. Follow the <em>troubleshooting</em> procedures for missing data as applicable"
      },
      "id": "6043f856e7b9d202d65799b5"
    },
    {
      "sections": [
        ".NET agent reports handled errors",
        "Problem",
        "Solution",
        "GetResponse() throws an error",
        "Define a custom instrumentation file",
        "Wrap the method in a custom transaction",
        "Cause"
      ],
      "title": ".NET agent reports handled errors",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "5cd50fdec02b9d8e48348c183e786eac54c312e8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/net-agent-reports-handled-errors/",
      "published_at": "2021-06-02T16:49:23Z",
      "updated_at": "2021-04-29T00:18:04Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem New Relic's .NET agent reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception handler. Instrument the target method by defining a custom instrumentation file, or by wrapping the method in a custom transaction, as shown in this example: GetResponse() throws an error In this example, New Relic reports an error from GetResponse() unless the method Foo() is instrumented. As long is Foo is instrumented, New Relic begins a transaction when Foo is called and ends the transaction when Foo ends. Because the error is handled before Foo ends, New Relic will not report an error. Note also that GetResponse() becomes a segment of the Foo transaction. using System; using System.Collections.Generic; using System.Threading; using System.Threading.Tasks; using System.Net; using System.IO; namespace ErrorTester { class Program { static void Main(string[] args) { var i = 0; while (true) { Foo(++i); } } static void Foo(int i) { try { GetNotFound(); } catch (Exception ex) { Console.WriteLine(\"Got it \" + i + \"!\"); Thread.Sleep(1000); } } static string GetNotFound() { string uri = \"http://localhost/Test/this/is/not/a/real/page\"; var request = (HttpWebRequest)WebRequest.Create(uri); var response = request.GetResponse(); var data = new StreamReader(response.GetResponseStream()).ReadToEnd(); response.Close(); return data; } } } Copy Define a custom instrumentation file To instrument Foo: Define a custom instrumentation file; for example, CustomInstrumentation.xml: <?xml version=\"1.0\" encoding=\"utf-8\"?> <!-- © 2008-2014 New Relic, Inc. All rights reserved. --> <!-- When you edit this file, please use an XML aware editor (such as Visual Studio), and pair with the companion file extension.xsd to minimize the chance of introducing typos that may confuse the agent when it is run. --> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory > <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Place CustomInstrumenation.xml in the New Relic extensions folder, alongside CoreInstrumentation.xml, and restart your application. Wrap the method in a custom transaction To instrument Foo, wrap it in a custom transaction: <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Background/Task\"> <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Cause The only errors New Relic's .NET agent reports are unhandled errors that end a transaction. If your app calls an exception handler before the transaction ends, New Relic will not report an error. However, New Relic does not always detect exception handlers when the error occurs outside of a web transaction, WCF transaction, or custom transaction. This is because the agent creates \"mini-transactions\" for instrumented methods that are not associated with a transaction. When the instrumented method exits, the mini-transaction ends. If the mini-transaction throws an error and the instrumented method does not handle it, then New Relic will report an error. You can see this in a console app that calls GetResponse(), as shown in the example. If GetResponse throws an error, then New Relic will report it, even though GetResponse() is called within a try/catch block. The agent reports an error because the GetResponse() \"mini-transaction\" ended and the error was still unhandled on transaction exit.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 78.571754,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> reports handled errors",
        "sections": ".<em>NET</em> <em>agent</em> reports handled errors",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem New Relic&#x27;s .<em>NET</em> <em>agent</em> reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception"
      },
      "id": "603e910028ccbcc7c0eba7b4"
    }
  ],
  "/docs/agents/net-agent/troubleshooting/technical-support-net-framework-40-or-lower": [
    {
      "sections": [
        "Generate logs for troubleshooting (.NET)",
        "Generate log files",
        "Important",
        "Generate Azure Web App log files",
        "Collect system information",
        "Check permissions",
        "For more help"
      ],
      "title": "Generate logs for troubleshooting (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "3f0c136f4228951c3d2f4bfa1f28e5331b5fa5ca",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/generate-logs-troubleshooting-net/",
      "published_at": "2021-06-02T16:17:55Z",
      "updated_at": "2021-03-16T13:04:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's .NET agent stores two types of log files in the Logs directory at %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. Both are needed for troubleshooting; for example, if no data appears in the New Relic UI for your app. If either log type is missing, some component of the .NET agent did not start. Agent logs: These file names begin with newrelic_agent_. Profiler logs: These file names begin with NewRelic.Profiler. Generate log files Important When troubleshooting your New Relic .NET agent, ensure it has been configured to generate debug level log files, and monitor the size of your log file closely. Logging at debug generates a lot of data very quickly. After reproducing your problem, return the log level to info. If your C:\\ProgramData\\New Relic\\.NET Agent is in a hidden folder, update your Windows settings so that you can see it. To generate New Relic for .NET log files: Open newrelic.config, usually located in C:\\ProgramData\\New Relic\\.NET Agent (or %ALLUSERSPROFILE%\\New Relic\\.NET Agent). Change the <log level=\"info\" /> setting to <log level=\"debug\" />. Save and close the file, then wait a few minutes for the agent to read the new settings. Generate a few minutes of traffic to your app. If sending your log file to New Relic Support: In your New Relic support ticket, attach the newrelic.config file (not the text of the file), and attach the entire Logs folder from C:\\ProgramData\\New Relic\\.NET Agent\\Logs or from %ALLUSERSPROFILE%\\New Relic\\.NET Agent\\Logs. In newrelic.config, change <log level=\"debug\" /> to <log level=\"info\" />. Generate Azure Web App log files Kudu Console manages Microsoft Azure Web App log reporting. To use the Kudu Console, first log into Azure. Navigate to the URL of your Azure Web app; for example: https://example.azurewebsites.net Copy Insert the Kudu Console URL scmsnippet into the URL; for example: https://example.scm.azurewebsites.net Copy Check for the Kudu logo with a black navigation bar at the top left of the page and your Azure username at the top right of the page. Then, to change the log level within the Kudu Console: From the Kudu Console navigation bar, select the Debug console menu, then select either CMD or PowerShell. Navigate to D:\\home\\site\\wwwroot\\newrelic. To edit newrelic.config, select the pencil icon. Change <log level=\"info\"> to <log level=\"debug\"> Save the change to newrelic.config. Wait a few minutes for the debug logs to be generated. Use the same steps to switch the log level back to info. Collect system information In addition to agent logs, a Microsoft System Information file is also useful for troubleshooting: From the Windows task bar, select Start > Run and enter msinfo32. Select OK. After the system information page loads, select File > Save. Wait a few minutes for the server to save the file. Attach the file to your New Relic support ticket. Check permissions Sometimes the .NET agent will start but not be able to write to its logs because it does not have the necessary permissions to create the log directory and log files. Permissions management varies by environment, so you will need to work with your system administrator to verify that this is not an issue. For more help For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 83.13537,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate logs for <em>troubleshooting</em> (.<em>NET</em>)",
        "sections": "Generate logs for <em>troubleshooting</em> (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "New Relic&#x27;s .<em>NET</em> <em>agent</em> stores two types of log files in the Logs directory at %ALLUSERSPROFILE%\\New Relic\\.<em>NET</em> <em>Agent</em>\\Logs. Both are needed for <em>troubleshooting</em>; for example, if no data appears in the New Relic UI for your app. If either log type is missing, some component of the .<em>NET</em> <em>agent</em> did"
      },
      "id": "603eb5da196a67556aa83dd8"
    },
    {
      "sections": [
        "No Browser data appears (.NET)",
        "Problem",
        "Solution"
      ],
      "title": "No Browser data appears (.NET)",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "61a0ca0687aa9ebea7c0ce8d99e38822db0eb1cd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/no-browser-data-appears-net/",
      "published_at": "2021-06-02T16:50:18Z",
      "updated_at": "2021-03-11T02:34:52Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem After generating traffic and waiting five minutes, you do not see any browser monitoring data for your .NET app. Solution To troubleshoot missing data: Make sure you have installed the latest release of the .NET agent. Follow the troubleshooting procedures for missing data as applicable. Verify whether your pages are rendered using ASPs. If you use another rendering technology, use manual instrumentation. Flush your .NET cache. Set the <head> tag of your pages to render on the server. Verify that your agent is configured to auto-instrument pages. Edit newrelic.config and verify that autoInstrument is set to true: <browserMonitoring autoInstrument=\"true\"/> Copy Check whether IIS page compression is disabled. If compressed before the .NET agent attempts browser instrumentation, the necessary <HEAD> tag won't be found. For instructions on how to check that, see Microsoft documentation. Look at the source of one of your pages through a browser. Look for a script with references to NREUMQ at the top and bottom of your pages. If you get support at support.newrelic.com, mention whether you are seeing this JavaScript in the page header or in some other location in the page, or you are not seeing it at all. Here are some additional troubleshooting tips: Browser problems Additional troubleshooting tips for .NET agent IIS exception error With IIS, you may receive an InvalidOperationException that states: Post cache substitution is not compatible with modules in the IIS integrated pipeline that modify the response buffers. Copy To solve this problem, you must manually implement the Browser agent: Set browserMonitoring to false in newrelic.config, and follow the manual instrumentation procedures. Razor framework error With the Razor framework, you may encounter the following message: Parser Error Message: \"\").pop().split(\"\" is not valid at the start of a code block. Only identifiers, keywords, comments, \"(\" and \"{\" are valid. Copy To solve this problem, follow the Browser troubleshooting procedures for Razor frameworks.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 79.9309,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "No Browser data appears (.<em>NET</em>)",
        "sections": "No Browser data appears (.<em>NET</em>)",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem After generating traffic and waiting five minutes, you do not see any browser monitoring data for your .<em>NET</em> app. Solution To <em>troubleshoot</em> missing data: Make sure you have installed the latest release of the .<em>NET</em> <em>agent</em>. Follow the <em>troubleshooting</em> procedures for missing data as applicable"
      },
      "id": "6043f856e7b9d202d65799b5"
    },
    {
      "sections": [
        ".NET agent reports handled errors",
        "Problem",
        "Solution",
        "GetResponse() throws an error",
        "Define a custom instrumentation file",
        "Wrap the method in a custom transaction",
        "Cause"
      ],
      "title": ".NET agent reports handled errors",
      "type": "docs",
      "tags": [
        "Agents",
        "NET agent",
        "Troubleshooting"
      ],
      "external_id": "5cd50fdec02b9d8e48348c183e786eac54c312e8",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/net-agent/troubleshooting/net-agent-reports-handled-errors/",
      "published_at": "2021-06-02T16:49:23Z",
      "updated_at": "2021-04-29T00:18:04Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem New Relic's .NET agent reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception handler. Instrument the target method by defining a custom instrumentation file, or by wrapping the method in a custom transaction, as shown in this example: GetResponse() throws an error In this example, New Relic reports an error from GetResponse() unless the method Foo() is instrumented. As long is Foo is instrumented, New Relic begins a transaction when Foo is called and ends the transaction when Foo ends. Because the error is handled before Foo ends, New Relic will not report an error. Note also that GetResponse() becomes a segment of the Foo transaction. using System; using System.Collections.Generic; using System.Threading; using System.Threading.Tasks; using System.Net; using System.IO; namespace ErrorTester { class Program { static void Main(string[] args) { var i = 0; while (true) { Foo(++i); } } static void Foo(int i) { try { GetNotFound(); } catch (Exception ex) { Console.WriteLine(\"Got it \" + i + \"!\"); Thread.Sleep(1000); } } static string GetNotFound() { string uri = \"http://localhost/Test/this/is/not/a/real/page\"; var request = (HttpWebRequest)WebRequest.Create(uri); var response = request.GetResponse(); var data = new StreamReader(response.GetResponseStream()).ReadToEnd(); response.Close(); return data; } } } Copy Define a custom instrumentation file To instrument Foo: Define a custom instrumentation file; for example, CustomInstrumentation.xml: <?xml version=\"1.0\" encoding=\"utf-8\"?> <!-- © 2008-2014 New Relic, Inc. All rights reserved. --> <!-- When you edit this file, please use an XML aware editor (such as Visual Studio), and pair with the companion file extension.xsd to minimize the chance of introducing typos that may confuse the agent when it is run. --> <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory > <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Place CustomInstrumenation.xml in the New Relic extensions folder, alongside CoreInstrumentation.xml, and restart your application. Wrap the method in a custom transaction To instrument Foo, wrap it in a custom transaction: <extension xmlns=\"urn:newrelic-extension\"> <instrumentation> <tracerFactory name=\"NewRelic.Agent.Core.Tracer.Factories.BackgroundThreadTracerFactory\" metricName=\"Background/Task\"> <match assemblyName=\"ErrorTester\" className=\"ErrorTester.Program\"> <exactMethodMatcher methodName=\"Foo\" /> </match> </tracerFactory> </instrumentation> </extension> Copy Cause The only errors New Relic's .NET agent reports are unhandled errors that end a transaction. If your app calls an exception handler before the transaction ends, New Relic will not report an error. However, New Relic does not always detect exception handlers when the error occurs outside of a web transaction, WCF transaction, or custom transaction. This is because the agent creates \"mini-transactions\" for instrumented methods that are not associated with a transaction. When the instrumented method exits, the mini-transaction ends. If the mini-transaction throws an error and the instrumented method does not handle it, then New Relic will report an error. You can see this in a console app that calls GetResponse(), as shown in the example. If GetResponse throws an error, then New Relic will report it, even though GetResponse() is called within a try/catch block. The agent reports an error because the GetResponse() \"mini-transaction\" ended and the error was still unhandled on transaction exit.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 78.57175,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": ".<em>NET</em> <em>agent</em> reports handled errors",
        "sections": ".<em>NET</em> <em>agent</em> reports handled errors",
        "tags": "<em>NET</em> <em>agent</em>",
        "body": "Problem New Relic&#x27;s .<em>NET</em> <em>agent</em> reports handled errors as though they are standard errors. This is most common with Azure worker roles, console apps, async work, and similar operations. Solution To avoid false error reports, instrument a method that directly or indirectly contains the exception"
      },
      "id": "603e910028ccbcc7c0eba7b4"
    }
  ],
  "/docs/agents/nodejs-agent/api-guides/guide-using-nodejs-agent-api": [
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 117.79295,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Guide</em> to using the Java <em>agent</em> <em>API</em> ",
        "sections": "<em>Guide</em> to using the Java <em>agent</em> <em>API</em>",
        "tags": "<em>API</em> <em>guides</em>",
        "body": "The New Relic Java <em>agent</em> <em>API</em> lets you control, customize, and extend the functionality of the APM Java <em>agent</em>. This <em>API</em> consists of: Static methods on the com.newrelic.<em>api.agent</em>.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of <em>API</em> objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    },
    {
      "sections": [
        "Guide to using the Python agent API",
        "Custom instrumentation or API",
        "Monitor transactions and segments",
        "Add and edit transaction metadata",
        "Report custom events and custom metric data",
        "Message-related calls",
        "Implement distributed tracing",
        "Agent configuration, initialization, shutdown",
        "Control the Browser monitoring agent"
      ],
      "title": "Guide to using the Python agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "Python agent",
        "API guides"
      ],
      "external_id": "41f2cf33977b57e872b8c69a30b77fd603b51926",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/python-agent/api-guides/guide-using-python-agent-api/",
      "published_at": "2021-06-02T13:37:41Z",
      "updated_at": "2021-06-02T13:37:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Python agent API allows you to customize and extend your monitoring. Use the Python agent API to: Manually instrument an unsupported framework or third-party system. Add instrumentation to supplement the agent's default monitoring. This document describes some of the available Python API calls. For a description of all our available APIs, see Introduction to APIs. Custom instrumentation or API If your goal is custom instrumentation, consider using the configuration file method, which allows you to add functions and class methods to the config file that will be auto-instrumented by the agent. The benefit of the config-file method is that it does not require you to change your application code. However, the Python agent API is much more powerful and is best for setting up more complex and tailored instrumentation. To ensure you have access to the full API functionality, update to the latest Python agent. Monitor transactions and segments The Python agent is compatible with most of the common WSGI web frameworks. If the agent supports your framework, web requests automatically will be captured as transactions and displayed in the New Relic One UI. A transaction can also have function-level segments that are captured as part of a transaction trace. Use these methods to monitor web transactions, non-web transactions, and transaction segments: If you want to... Do this... Monitor WSGI web transactions The Python agent automatically captures web transactions for supported frameworks. If you do not have a supported framework, you can use the wsgi_application function to monitor your WSGI entry point. Monitor non-web transactions The Python agent classifies non-web transactions as background tasks. To capture non-web transactions, use background_task. Capture more details about a transaction If your transaction traces do not have the level of detail you want: Use function_trace to capture more function-level detail in transactions. Use datastore_trace to capture more detail about datastore calls. Ignore a transaction Use any of these options: To ignore a transaction altogether, use ignore_transaction. To prevent a transaction from producing a transaction trace, use suppress_transaction_trace. To end a transaction before the agent would end it automatically, use end_of_transaction. Add and edit transaction metadata Sometimes the code you target is visible in our UI, but some details of the method are not useful. For example: The default name is not helpful, or it is causing a metric grouping issue. You want to add custom attributes to your transactions so you can filter them when querying. Use these calls when you want to change the metadata of an existing transaction: If you want to... Do this... Get reference to current transaction To return an object representing the current transaction, use current_transaction. This is required by some other Python agent API calls. Change the name of a transaction Use set_transaction_name. Add metadata (such as a customer's subscription level) to transactions Add custom attributes to your transactions using add_custom_parameter, or use other API calls to report custom data. Mark a transaction as a background job To convert a web transaction into a background task so that it appears as a non-web transaction in the UI, use set_background_task. Prevent a transaction from affecting your Apdex score Use suppress_apdex_metric. Report custom events and custom metric data The agent reports data in two primary forms: Metric data measures numeric, time-based values; for example, connections per minute. Event data captures discrete event information. Events have key-value attributes attached to them. You can analyze and query event data. Use these methods to create new event data and new metric data: If you want to... Do this... Send data about an event for use when querying your data. Use record_custom_event. Report time-based metrics on application performance To report a single metric, use record_custom_metric. To report a set of metrics, use record_custom_metrics. Report an exception as an error By default, the Python agent only reports unhandled exceptions. To report a Python exception as an error, use notice_error. Report query string parameters For security reasons, query string parameters associated with web transactions are disabled by default. Use capture_request_params to enable them. Tag events with metadata To add attributes to events for more detailed analysis in Insights or error analytics, use add_custom_parameter. Generate metrics from data sources and data factories To generate metrics with a pull-style API rather than the push-style API implemented by record_custom_metric(), use these API calls: register_data_source data_source_generator data_source_factory Message-related calls These API calls allow you to collect performance data on your message-passing architecture or service; for example, RabbitMQ. To use these calls, make sure you have Python agent version 2.88.0.72 or higher. If you want to... Do this... Report messages as a transaction Use message_transaction. Report message details as transaction trace segments Use message_trace. Implement distributed tracing These APIs require distributed tracing to be enabled. Services and applications monitored by our agents will automatically pass distributed tracing context to each other when using a supported framework. When not using a supported framework, you will need to use the distributed tracing APIs to manually accept this context. Supported web frameworks (for example, Flask, Django, Tornado) will automatically call accept_distributed_trace_payload when creating a transaction. Supported external web services libraries will automatically call create_distributed_trace_payload before making an external HTTP call. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. If you want to... Do this... Create a payload to be sent to a called service. Use create_distributed_trace_payload. Accept a payload sent from the first service; this will link these services together in a trace Use accept_distributed_trace_payload. Agent configuration, initialization, shutdown These calls help you manage Python agent behavior, such as initializing and integrating the agent, and referencing or changing configuration settings: If you want to... Do this... Initialize the agent To initialize the Python agent with a specific configuration file as part of advanced integration process, use initialize. Get a reference to the application object The application object represents an agent-monitored application and is used by some Python agent API calls. Get a reference to configuration settings To control the Python agent's behavior, you can use configuration settings. To get a reference to config file and environment variable settings and make changes to them, use global_settings. To get a reference to all settings, including server-side configuration from our UI, use application_settings. Shut down the agent To forcibly shut down the agent instead of allowing it to make the standard final attempt to upload data, use shutdown_agent. Control the Browser monitoring agent You can install the browser monitoring agent by automatically adding it to your pages or by deploying it on specific pages by copying and pasting the browser agent JavaScript snippet. You can also control the browser agent by using APM agent API calls. For more information, see Browser agent and the Python agent. If you want to... Do this... Monitor specific page views To inject the browser agent header and footer JavaScript snippets into views you want to monitor, use both get_browser_timing_header and get_browser_timing_footer. Disable monitoring of specific page views To disable browser monitoring for specific page views, use disable_browser_autorum.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 117.0932,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Guide</em> to using the Python <em>agent</em> <em>API</em>",
        "sections": "<em>Guide</em> to using the Python <em>agent</em> <em>API</em>",
        "tags": "<em>API</em> <em>guides</em>",
        "body": "The Python <em>agent</em> <em>API</em> allows you to customize and extend your monitoring. Use the Python <em>agent</em> <em>API</em> to: Manually instrument an unsupported framework or third-party system. Add instrumentation to supplement the <em>agent</em>&#x27;s default monitoring. This document describes some of the available Python <em>API</em> calls"
      },
      "id": "60441c8d64441f0ec7378eff"
    },
    {
      "sections": [
        "Node.js agent API",
        "Request names",
        "Tip",
        "Requirements",
        "Avoid metric grouping issues",
        "Guidelines",
        "URL pattern matching",
        "Load the request naming API",
        "Request API calls",
        "newrelic.setTransactionName(name)",
        "newrelic.setControllerName(name, \\[action])",
        "Custom instrumentation API calls",
        "newrelic.instrument(moduleName, onRequire \\[, onError])",
        "newrelic.instrumentDatastore(moduleName, onRequire \\[, onError])",
        "newrelic.instrumentLoadedModule(moduleName, moduleInstance)",
        "Important",
        "newrelic.instrumentMessages(moduleName, onRequire \\[, onError])",
        "newrelic.instrumentWebframework(moduleName, onRequire \\[, onError])",
        "newrelic.startWebTransaction(url, handle)",
        "newrelic.startBackgroundTransaction(name, \\[group], handle)",
        "newrelic.getTransaction()",
        "newrelic.endTransaction()",
        "newrelic.startSegment(name, record, handler, callback)",
        "Custom metrics API calls",
        "newrelic.recordMetric(name, value)",
        "newrelic.incrementMetric(name, \\[amount])",
        "Custom events API calls",
        "newrelic.recordCustomEvent(eventType, attributes)",
        "Recording a custom event",
        "Transaction handle methods",
        "transactionHandle.end(\\[callback])",
        "transactionHandle.ignore()",
        "transactionHandle.insertDistributedTraceHeaders(headers)",
        "Generating distributed trace headers",
        "transactionHandle.acceptDistributedTraceHeaders(transportType, headers)",
        "Accept incoming distributed trace headers",
        "transactionHandle.createDistributedTracePayload()",
        "Caution",
        "Link a nested background transaction",
        "Place payload on an outgoing request",
        "transactionHandle.acceptDistributedTracePayload(payload)",
        "transactionHandle.isSampled()",
        "Other API calls",
        "newrelic.addCustomAttribute(name, value)",
        "Add custom attribute",
        "newrelic.addCustomAttributes(attributes)",
        "Adding custom attributes",
        "newrelic.addCustomSpanAttribute(name, value)",
        "Add custom span attribute",
        "newrelic.addCustomSpanAttributes(attributes)",
        "Add custom span attributes",
        "newrelic.getBrowserTimingHeader()",
        "newrelic.setIgnoreTransaction(ignored)",
        "newrelic.noticeError(error, \\[customParameters])",
        "newrelic.shutdown(\\[options], callback)",
        "newrelic.getLinkingMetadata()",
        "newrelic.getTraceMetadata()",
        "Rules for naming and ignoring requests",
        "rules.name",
        "Optional rules attributes [#optional-rules]",
        "Testing your naming rules [#testing-rules]",
        "Naming rule examples [#examples-rules]",
        "Match full URL",
        "Replace first match in URL",
        "Replace all matches in any URL",
        "Match group references",
        "rules.ignore",
        "Naming rule example",
        "Ignoring rule example",
        "API calls for rules",
        "newrelic.addNamingRule(pattern, name)",
        "newrelic.addIgnoringRule(pattern)"
      ],
      "title": "Node.js agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "API guides"
      ],
      "external_id": "dd0838adbfafc7e5988ed77ad3ad039cdce29ec0",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/api-guides/nodejs-agent-api/",
      "published_at": "2021-06-02T13:37:41Z",
      "updated_at": "2021-04-16T05:29:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic offers several tools to help obtain the information needed to provide useful metrics about your Node.js application. These include: Reading the route names (if used) from the Express and Restify routers Using the API to name the current request, either with simple names or groups of controllers with actions Support rules that are stored in your agent's configuration that can mark requests to be renamed or ignored based on regular expressions matched against the request's raw URLs (also available as API calls) The number of names that New Relic tracks needs to be small enough so that the user experience is robust. It also needs to be large enough to provide the right amount of information (without overwhelming you with data) so that you can identify problem spots in your applications more easily. For more information, see the Node.js agent configuration documentation and the Node.js agent API documentation on Github. Request names The Node.js agent captures the HTTP method along with a potentially parameterized path (such as /user/:id) or a regular expression (such as /^/user/([-0-9a-f]+)$/). These pieces of information become part of the request name. If you have support for slow transaction traces and have enabled capture_params in your config file, the transaction trace will also have the request's parameters and their values attached to it. If you are dissatisfied with the request names that the Node.js agent uses, you can use API calls to create more descriptive names. Tip If grouping your requests under the generic name, then /* is sufficient, and you do not need to customize your configuration file or API calls. Requirements New Relic uses request names to group requests for many charts and tables. The value of these visualizations will drop as the number of different request names increases. For example, do not include potentially dynamic data like GUIDs, numerical IDs, or timestamps in the request names you create. If your request is slow enough to generate a transaction trace, that trace will contain the original URL. If you enable parameter capture, the parameters will also be attached to the trace. Tip Avoid having more than 50 different transaction names. For example, if you have more than a couple hundred different request names, rethink your naming strategy. Avoid metric grouping issues The request naming API helps New Relic avoid problems with trying to handle too many metrics, which sometimes is referred to as \"metric explosion.\" New Relic has several strategies to deal with these issues; the most severe is simply to add offending applications to your deny list. The main reason for you to be careful in using these request-naming tools is to prevent that from happening to your applications. For more information, see Metric grouping issues. Guidelines Define your configuration rules from the most specific to the most general. The first rules listed in your config file or added with the Node.js transaction naming API will be applied first and should be narrowly targeted. More general \"fall-through\" rules should be added toward the end of the list, because they will be evaluated in the order they were configured or added using the Node.js transaction naming API. URL pattern matching An online retailer has a URL pattern like this: /user/customers/all/prospects /user/customers/all/current /user/customers/all/returning /user/customers/John /user/customers/Jane Copy The retailer could create rules like this: // newrelic.js exports.config={ //other configuration rules:{ name:[ { pattern: \"/user/customers/all/prospects/\", name: \"/user/customers/all/prospects\" }, { pattern: \"/user/customers/all/.*\", name: \"/user/customers/all\" }, { pattern: \"/user/customers/.*\", name: \"/user/customers/:customer\" } ] } } Copy With these rules, the retailer would create three transaction names: /user/customers/:customer /user/customers/all /user/customers/all/prospects If the retailer reversed the order, the rules would catch all transactions in :customer, which would not be as useful. Load the request naming API Make sure that loading the New Relic module is the first thing your application does, as it needs to bootstrap itself before the rest of your application loads: var newrelic = require('newrelic'); Copy This returns the request naming API. You can safely require the module from multiple modules in your application, as it only initializes itself once. Request API calls Here is a summary of the Request API calls for New Relic's Node.js agent. newrelic.setTransactionName(name) newrelic.setTransactionName(name) Copy Name the current request, following the request naming requirements. You can call this function anywhere within the context of an HTTP request handler, at any time after handling of the request has started, but before the request has finished. In general, if the request and response objects are in scope, you can set the name. Explicitly calling newrelic.setTransactionName() will override any names set by Express or Restify routes. Also, calls to newrelic.setTransactionName() and newrelic.setControllerName() will overwrite each other. The last one to run before the request ends wins. newrelic.setControllerName(name, \\[action]) newrelic.setControllerName(name, \\[action]) Copy Name the current request using a controller-style pattern, optionally including the current controller action. If the action is omitted, New Relic will include the HTTP method (GET, POST, etc.) as the action. The rules for when you can call newrelic.setControllerName() are the same as they are for newrelic.setTransactionName(), including the request naming requirements. Explicitly calling newrelic.setControllerName() will override any names set by Express or Restify routes. Also, calls to newrelic.setTransactionName() and newrelic.setControllerName() will overwrite each other. The last one to run before the request ends wins. Custom instrumentation API calls Use these API calls to expand your instrumentation with custom instrumentation. newrelic.instrument(moduleName, onRequire \\[, onError]) newrelic.instrument(moduleName, onRequire \\[, onError]) Copy Sets an instrumentation callback for a specific module. The provided onRequire callback will be fired when the given module is loaded with require. The moduleName parameter should be the string that will be passed to require; for example, 'express' or 'amqplib/callback_api'. The optional onError callback is called if the onRequire parameters throws an error. This is useful for debugging your instrumentation. Use this method to: Add instrumentation for modules not currently instrumented by New Relic. Instrument your own code. Replace the Node.js agent's built-in instrumentation with your own. For more information, see New Relic's Node.js instrumentation tutorial on Github. newrelic.instrumentDatastore(moduleName, onRequire \\[, onError]) newrelic.instrumentDatastore(moduleName, onRequire \\[, onError]) Copy Sets an instrumentation callback for a datastore module. This method is just like newrelic.instrument(), except it provides a datastore-specialized shim. For more information, see New Relic's Node.js datastore instrumentation tutorial on Github. newrelic.instrumentLoadedModule(moduleName, moduleInstance) newrelic.instrumentLoadedModule(moduleName, moduleInstance) Copy The instrumentLoadedModule method allows you to add stock instrumentation to specific modules in situations where it's impossible to have require('newrelic'); as the first line of your app's main module. // load the agent const newrelic = require('newrelic') // module loaded before newrelic const expressModule = require('express') // instrument express _after_ the agent has been loaded newrelic.instrumentLoadedModule( 'express', // the module's name, as a string expressModule // the module instance ); Copy Important This method cannot instrument any arbitrary module. Its purpose is to add modules that were missed because the agent was not loaded as the first thing in your program. The instrumentLoadedModule method can only instrument modules the agent would normally instrument. You can see a list of these modules in the agent's lib/instrumentations module. newrelic.instrumentMessages(moduleName, onRequire \\[, onError]) newrelic.instrumentMessages(moduleName, onRequire \\[, onError]) Copy Sets an instrumentation callback for a message service client module. This method is just like newrelic.instrument(), except it provides a message-service-specialized shim. For more information, see New Relic's Node.js message service instrumentation tutorial on Github. newrelic.instrumentWebframework(moduleName, onRequire \\[, onError]) newrelic.instrumentWebframework(moduleName, onRequire \\[, onError]) Copy Sets an instrumentation callback for a web framework module. This method is just like newrelic.instrument(), except it provides a web-framework-specialized shim. For more information, see New Relic's Node.js web framework instrumentation tutorial on Github. newrelic.startWebTransaction(url, handle) newrelic.startWebTransaction(url, handle) Copy Instrument the specified web transaction. Using this API call, you can instrument transactions that New Relic does not automatically detect. The url defines the transaction name and needs to be static. Do not include variable data such as user ID. The handle defines the function you want to instrument. New Relic will capture any metrics that would be captured by auto-instrumentation, as well as manual instrumentation via startSegment(). You must handle custom transactions manually by calling newrelic.getTransaction() at the start of your transaction, and then call transaction.end() when you are finished. New Relic begins timing the transaction when newrelic.startWebTransaction() is called and ends the transaction when transaction.end() is called. You can also return a promise to indicate the end of the transaction. Please note that if this promise rejects, it does not automatically hook into New Relic’s error tracking. This needs to be done manually with noticeError(). newrelic.startBackgroundTransaction(name, \\[group], handle) newrelic.startBackgroundTransaction(name, \\[group], handle) Copy Instrument the specified background transaction. Using this API call, you can expand New Relic's instrumentation to capture data from background transactions. The name defines the transaction name and needs to be static. Do not include variable data such as user ID. The group is optional, and it allows you to group similar jobs together via the transaction type in the user interface. Like name, the group needs to be static. The handle defines a function that includes the entire background job you want to instrument. New Relic will capture any metrics that would be captured by auto-instrumentation, as well as manual instrumentation via startSegment(). You must handle custom transactions manually by calling newrelic.getTransaction() at the start of your transaction, and then call transaction.end() when you are finished. New Relic begins timing the transaction when newrelic.startBackgroundTransaction() is called and ends the transaction when transaction.end() is called. You can also return a promise to indicate the end of the transaction. Please note that if this promise rejects, it does not automatically hook into New Relic’s error tracking. This needs to be done manually with noticeError(). newrelic.getTransaction() newrelic.getTransaction() Copy Returns a handle on the currently executing transaction. This handle can then be used to interact with a given transaction safely from any context. It is best used with newrelic.startWebTransaction() and newrelic.startBackgroundTransaction(). Please refer to the transaction handle section for more details. newrelic.endTransaction() newrelic.endTransaction() Copy End the current web or background custom transaction. This method requires being in the correct transaction context when called. This API call takes no arguments. newrelic.startSegment(name, record, handler, callback) newrelic.startSegment(name, record, handler, callback) Copy Instrument a particular method to improve visibility into a transaction, or optionally turn it into a metric. The name defines a name for the segment. This name will be visible in transaction traces and as a new metric in the New Relic UI. The record flag defines whether the segment should be recorded as a metric. The handler is the function you want to track as a segment. The optional callback is a function passed to the handler to fire after its work is done. The agent begins timing the segment when startSegment is called. The segment is ended when either the handler finishes executing, or callback is fired, if it is provided. Custom metrics API calls Use these API calls to record additional arbitrary metrics: newrelic.recordMetric(name, value) newrelic.recordMetric(name, value) Copy Use recordMetric to record an event-based metric, usually associated with a particular duration. The name must be a string following standard metric naming rules. The value will usually be a number, but it can also be an object. When value is a numeric value, it should represent the magnitude of a measurement associated with an event; for example, the duration for a particular method call. When value is an object, it must contain count, total, min, max, and sumOfSquares keys, all with number values. This form is useful to aggregate metrics on your own and report them periodically; for example, from a setInterval. These values will be aggregated with any previously collected values for the same metric. The names of these keys match the names of the keys used by the platform API. newrelic.incrementMetric(name, \\[amount]) newrelic.incrementMetric(name, \\[amount]) Copy Use incrementMetric to update a metric that acts as a simple counter. The count of the selected metric will be incremented by the specified amount, defaulting to 1. Custom events API calls Use these API calls to record additional events: newrelic.recordCustomEvent(eventType, attributes) newrelic.recordCustomEvent(eventType, attributes) Copy Use recordCustomEvent to record an event-based metric, usually associated with a particular duration. The eventType must be an alphanumeric string less than 255 characters. The attributes must be an object of key and value pairs. The keys must be shorter than 255 characters, and the values must be string, number, or boolean. Recording a custom event The following example demonstrates recording a custom event with multiple attributes. const attributes = { attribute1: 'value1', attribute2: 2 } newrelic.recordCustomEvent('MessagingEvent', attributes) Copy Transaction handle methods This section details the methods provided by the TransactionHandle class instance that can be obtained through newrelic.getTransaction(). Use these methods to interact directly with the current transaction: transactionHandle.end(\\[callback]) transactionHandle.end(\\[callback]) Copy Use transactionHandle.end to end the transaction referenced by the handle instance. The callback is invoked when the transaction has fully ended. The finished transaction passed to the callback as the first argument. transactionHandle.ignore() transactionHandle.ignore() Copy Use transactionHandle.ignore to ignore the transaction referenced by the handle instance. transactionHandle.insertDistributedTraceHeaders(headers) transactionHandle.insertDistributedTraceHeaders(headers) Copy Important This API requires distributed tracing to be enabled. For context on how to use this call and its partner call acceptDistributedTraceHeaders, first read Enable distributed tracing with agent APIs. transactionHandle.insertDistributedTraceHeaders is used to implement distributed tracing. It modifies the headers map that is passed in by adding W3C Trace Context headers and New Relic Distributed Trace headers. The New Relic headers can be disabled with distributed_tracing.exclude_newrelic_header: true in the config. This method replaces the deprecated createDistributedTracePayload method, which only creates New Relic Distributed Trace payloads. Generating distributed trace headers In the following example, by calling insertDistributedTraceHeaders with an empty object, the appropriate Distributed Trace headers and W3C Trace Context headers will be generated for the transaction. // Call newrelic.getTransaction to retrieve a handle on the current transaction. const transactionHandle = newrelic.getTransaction() // This could be a header object from an incoming request as well const headersObject = {} newrelic.startBackgroundTransaction('background task', function executeTransaction() { const transaction = newrelic.getTransaction() // generate the headers transaction.insertDistributedTraceHeaders(headersObject) }) Copy transactionHandle.acceptDistributedTraceHeaders(transportType, headers) transactionHandle.acceptDistributedTraceHeaders(transportType, headers) Copy Important This API requires distributed tracing to be enabled. For context on how to use this call and its partner call insertDistributedTraceHeaders, first read Enable distributed tracing with agent APIs. transactionHandle.acceptDistributedTraceHeaders is used to instrument the called service for inclusion in a distributed trace. It links the spans in a trace by accepting a payload generated by insertDistributedTraceHeaders or generated by some other W3C Trace Context compliant tracer. This method accepts the headers of an incoming request, looks for W3C Trace Context headers, and if not found, falls back to New Relic distributed trace headers. This method replaces the deprecated (and now removed as of version 7.0.0) acceptDistributedTracePayload method, which only handles New Relic distributed trace payloads. transportType should be one of the following strings: AMQP HTTP HTTPS IronMQ JMS Kafka Other Queue Unknown headers should be an object containing all the headers in the incoming request. The keys must be lowercase. Accept incoming distributed trace headers The following example demonstrates adding distributed trace headers retrieved from a Kafka message. In this example, we assume that the incoming Kafka message has Distributed Trace headers inserted. // incoming Kafka message headers const headersObject = message.headers // Call newrelic.getTransaction to retrieve a handle on the current transaction. const transactionHandle = newrelic.getTransaction() newrelic.startBackgroundTransaction('background task', function executeTransaction() { const transaction = newrelic.getTransaction() // accept the headers transaction.acceptDistributedTraceHeaders('Kafka', headersObject) }) Copy transactionHandle.createDistributedTracePayload() transactionHandle.createDistributedTracePayload() Copy Caution This method is deprecated and was removed in version 7.0.0! Please use insertDistributedTraceHeaders. Important This API requires distributed tracing to be enabled. For instructions on how to use this call, along with its partner call acceptDistributedTracePayload, see Enable distributed tracing with agent APIs. This call is used to implement distributed tracing. It generates a payload that is read by the receiving application with acceptDistributedTracePayload. Important Note: In order to maintain proper ordering of spans in a trace, you must generate the payload in the context of the span that sends it. The DistributedTracePayload object has two available methods used for generating the payload in different formats: DistributedTracePayload#text: returns a JSON representation of the payload. Link a nested background transaction // Call newrelic.getTransaction to retrieve a handle on the current transaction. var transactionHandle = newrelic.getTransaction() var payload = transactionHandle.createDistributedTracePayload() var jsonPayload = payload.text() newrelic.startBackgroundTransaction('background task', function executeTransaction() { var backgroundHandle = newrelic.getTransaction() // Link the nested transaction by accepting the payload with the background transaction's handle backgroundHandle.acceptDistributedTracePayload(jsonPayload) }) Copy DistributedTracePayload#httpSafe: returns a base64 encoded JSON representation of the payload. Place payload on an outgoing request // Call newrelic.getTransaction to retrieve a handle on the current transaction. var transactionHandle = newrelic.getTransaction() var payload = transactionHandle.createDistributedTracePayload() // Place the base64 encoded value on an outbound request header. req.headers[myTracingHeader] = payload.httpSafe() Copy transactionHandle.acceptDistributedTracePayload(payload) transactionHandle.acceptDistributedTracePayload(payload) Copy Caution This method is deprecated and was removed in version 7.0.0! Please use acceptDistributedTraceHeaders. Important This API requires distributed tracing to be enabled. For context on how to use this call and its partner call createDistributedTracePayload, first read Enable distributed tracing with agent APIs. transactionHandle.acceptDistributedTracePayload is used to instrument the called service for inclusion in a distributed trace. It links the spans in a trace by accepting the payload generated by createDistributedTracePayload. transactionHandle.isSampled() transactionHandle.isSampled() Copy Returns whether this trace is being sampled. Other API calls New Relic's Node.js agent includes additional API calls. newrelic.addCustomAttribute(name, value) newrelic.addCustomAttribute(name, value) Copy Set a custom attribute value to be displayed along with the transaction trace in the New Relic UI. This must be called within the context of a transaction so it has a place to set the custom attributes. Custom attributes will appear in New Relic APM's transaction trace detail view and in errors for the transaction. Add custom attribute newrelic.addCustomAttribute('attribute1', 'value1') Copy Caution If you want to use your custom attributes, avoid using any of the reserved terms used by NRQL when naming them. newrelic.addCustomAttributes(attributes) newrelic.addCustomAttributes(attributes) Copy Set multiple custom attribute values to be displayed along with the transaction trace in the New Relic UI. The attributes should be passed as a single object. This must be called within the context of a transaction so it has a place to set the custom attributes. Custom attributes will appear in the transaction trace detail view and in errors for the transaction. Adding custom attributes const attributes = { attribute1: 'value1', attribute2: 2 } newrelic.addCustomAttributes(attributes) Copy Caution If you want to use your custom attributes, avoid using any of the reserved terms used by NRQL when naming them. newrelic.addCustomSpanAttribute(name, value) newrelic.addCustomSpanAttribute(name, value) Copy Set a custom span attribute value to be displayed along with a transaction trace span in the New Relic UI. This must be called within the context of an active segment/span so it has a place to set the custom span attributes. Custom span attributes will appear in the Attributes section of the span detail view. Add custom span attribute newrelic.addCustomSpanAttribute('attribute1', 'value') Copy Important This API requires distributed tracing and span events to be enabled. Caution If you want to use your custom span attributes, avoid using any of the reserved terms used by NRQL when naming them. newrelic.addCustomSpanAttributes(attributes) newrelic.addCustomSpanAttributes(attributes) Copy Set multiple custom span attribute values to be displayed along with the transaction trace spans in the New Relic UI. The attributes should be passed as a single object. This must be called within the context of an active segment/span so it has a place to set the custom span attributes. Custom span attributes will appear in the Attributes section of the span detail view. Add custom span attributes const attributes = { attribute1: 'value1', attribute2: 'value2' } newrelic.addCustomSpanAttributes(attributes) Copy Important This API requires distributed tracing and span events to be enabled. Caution If you want to use your custom span attributes, avoid using any of the reserved terms used by NRQL when naming them. newrelic.getBrowserTimingHeader() newrelic.getBrowserTimingHeader() Copy Returns the HTML snippet to be inserted into the header of HTML pages to enable New Relic Browser. The HTML will instruct the browser to fetch a small JavaScript file and start the page timer. newrelic.setIgnoreTransaction(ignored) newrelic.setIgnoreTransaction(ignored) Copy Tell the module whether or not to ignore a given request. This allows you to explicitly filter long-polling, irrelevant routes or requests you know will be time-consuming. This also allows you to gather metrics for requests that otherwise would be ignored. To ignore the transaction, set the parameter to true will ignore the transaction. To prevent a transaction from being ignored with this function, pass the parameter false. Passing null or undefined will not change whether the transaction is ignored. Caution This method is deprecated and was removed in version 7.0.0. Please use transactionHandle.ignore() newrelic.noticeError(error, \\[customParameters]) newrelic.noticeError(error, \\[customParameters]) Copy Use this call if your app is doing its own error handling with domains or try/catch clauses, but you want all of the information about how many errors are coming out of the app to be centrally managed. Unlike other Node.js calls, this can be used outside of route handlers, but it will have additional context if called from within transaction scope. Caution Errors recorded using this method do not obey the ignore_status_codes configuration value. newrelic.shutdown(\\[options], callback) newrelic.shutdown(\\[options], callback) Copy Use this method to gracefully shut down the agent. options options.collectPendingData - type boolean - Tell the agent whether to send any pending data to the New Relic collector before shutting down. options.timeout - type number (ms) - The default time before forcing a shutdown. When collectPendingData is true, the agent will wait for a connection before shutting down. This timeout is useful for short lived processes, like AWS Lambda, in order to keep the process from staying open too long, while trying to connect. Example: newrelic.shutdown({collectPendingData: true, timeout: 3000}, (error) => { process.exit() }) Copy newrelic.getLinkingMetadata() newrelic.getLinkingMetadata() Copy Returns key/value pairs which can be used to link traces or entities. It will only contain items with meaningful values. For instance, if distributed tracing is disabled, trace.id will not be included. newrelic.getTraceMetadata() newrelic.getTraceMetadata() Copy Returns and object containing the current trace ID and span ID. Important This API requires distributed tracing to be enabled or an empty object will be returned. Rules for naming and ignoring requests If you do not want to put calls to the New Relic module directly into your application code, you can use pattern-based rules to name requests. There are two sets of rules: one for renaming requests, and one to mark requests to be ignored by New Relic's instrumentation. Here is the structure for rules in New Relic's Node.js agent. rules.name A list of rules of the format {pattern : \"pattern\", name : \"name\"} for matching incoming request URLs to pattern and naming the matching New Relic transaction's name. This acts as a regex replace, where you can set the pattern either as a string, or as a JavaScript regular expression literal, and both pattern and name are required. When passing a regex as a string, escape backslashes, as the agent does not keep them when given as a string in a pattern. Define your configuration rules from the most specific to the most general, as the patterns will be evaluated in order and are terminal in nature. For more information, see the naming guidelines. This can also be set with the environment variable NEW_RELIC_NAMING_RULES, with multiple rules passed in as a list of comma-delimited JSON object literals: NEW_RELIC_NAMING_RULES='{\"pattern\":\"^t\",\"name\":\"u\"},{\"pattern\":\"^u\",\"name\":\"t\"}' Copy Optional rules attributes [#optional-rules] Additional optional attributes are available: Optional rules attributes Description terminate_chain Default: true When set to true (default), no further rules will be evaluated if this rule is a match. Setting this to false is useful when multiple rules should be used together. For example, one rule could be replacing a common pattern in many different URLs, while subsequent rule(s) would be more specific. replace_all Default: false When set to true, all matches of the pattern will be replaced. Otherwise, only the first match will be replaced. Using the g flag with regular expression literal will have the same effect. For example: pattern: '[0-9]+', replace_all: true Copy This has the same effect as pattern: /[0-9]+/g. precedence By default the rules are evaluated in order, from first to last. If you prefer to have complete control over the order, you can give each rule a precedence attribute. The precedence is an integer number, and rules are evaluated in ascending order. If precedence is not explicitly defined, it will be set to 500 by default. Additional attributes are ignored. Testing your naming rules [#testing-rules] The Node.js agent comes with a command-line tool for testing naming rules. For more information, run the following command in terminal window in a directory where your app is installed: node node_modules/.bin/newrelic-naming-rules Copy Naming rule examples [#examples-rules] Here are some examples of naming rules and the results. Match full URL pattern: \"^/items/[0-9]+$\", name: \"/items/:id\" Copy will result in: /items/123 => /items/:id /orders/123 => /orders/123 (not replaced since the rule is a full match) Copy Replace first match in URL pattern: \"[0-9]+\", name: \":id\" Copy will result in: /orders/123 => /orders/:id /items/123 => /items/:id /orders/123/items/123 => /orders/:id/items/123 Copy Replace all matches in any URL pattern: \"[0-9]+\", name: \":id\", replace_all: true Copy will result in: /orders/123/items/123 => /orders/:id/items/:id Copy Match group references Using regular expression match group references: pattern: '^/(items|orders)/[0-9]+$', name: '/\\\\1/:id' Copy will result in: /orders/123 => /orders/:id /items/123 => /items/:id Copy rules.ignore This can also be set via the environment variable NEW_RELIC_IGNORING_RULES, with multiple rules passed in as a list of comma-delimited patterns. Currently there is no way to escape commas in patterns. NEW_RELIC_IGNORING_RULES='^/socket\\.io/\\*/xhr-polling,ignore_me' Copy Here are full examples of how rules are included in the configuration file: Naming rule example // newrelic.js exports.config = { // other configuration rules : { name : [ { pattern: \"/tables/name-here\", name: \"/name-hererule1\" } ] } Copy Ignoring rule example If you are using socket.io, you will have a use case for ignoring rules right out of the box. To keep socket.io long-polling from dominating your response-time metrics and affecting the Apdex metrics for your application, add a rule such as: // newrelic.js exports.config = { // other configuration rules : { ignore : [ '^\\/socket\\.io\\/.*\\/xhr-polling' ] } }; Copy API calls for rules Here are the API calls for naming and ignoring rules with New Relic's Node.js agent. newrelic.addNamingRule(pattern, name) Programmatic version of rules.name. Once naming rules are added, they cannot be removed until the Node process is restarted. They can also be added via the Node.js agent's configuration. Both parameters are required. newrelic.addIgnoringRule(pattern) Programmatic version of rules.ignore. Once ignoring rules are added, they cannot be removed until the Node process is restarted. They can also be added via the Node.js agent's configuration. This parameter is required.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 103.31266,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Node.js <em>agent</em> <em>API</em>",
        "sections": "Node.js <em>agent</em> <em>API</em>",
        "tags": "<em>Nodejs</em> <em>agent</em>",
        "body": " and the <em>Node.js</em> <em>agent</em> <em>API</em> documentation on Github. Request names The <em>Node.js</em> <em>agent</em> captures the HTTP method along with a potentially parameterized path (such as &#x2F;user&#x2F;:id) or a regular expression (such as &#x2F;^&#x2F;user&#x2F;([-0-9a-f]+)$&#x2F;). These pieces of information become part of the request name. If you have support"
      },
      "id": "6043daa7196a67e488960f4f"
    }
  ],
  "/docs/agents/nodejs-agent/api-guides/nodejs-agent-api": [
    {
      "sections": [
        "Guide to using the Java agent API",
        "Important",
        "Use the API",
        "Transactions",
        "Instrument asynchronous work",
        "Distributed tracing API usage",
        "Caution",
        "Cross application tracing (CAT) API usage",
        "Obtain references to New Relic API classes",
        "Additional API functionality",
        "Additional API usage examples"
      ],
      "title": "Guide to using the Java agent API ",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "API guides"
      ],
      "external_id": "d2e891456fe10b28930afad273f760ef9f06a85a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/api-guides/guide-using-java-agent-api/",
      "published_at": "2021-06-02T15:30:42Z",
      "updated_at": "2021-06-02T15:30:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent API lets you control, customize, and extend the functionality of the APM Java agent. This API consists of: Static methods on the com.newrelic.api.agent.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of API objects providing additional functionality Use this API to set up custom instrumentation of your Java app and collect more in-depth data. For detailed information about this API, see the complete Javadoc on GitHub. Another way to set up custom instrumentation is to use XML instrumentation. The XML option is simpler and does not require modification of your app code, but it lacks the complete functionality of the Java agent API. Important For best results when using the API, ensure that you have the latest Java agent release. Several APIs used in the examples require Java agent 6.4.0 or higher. For all available New Relic APIs, see Intro to APIs. Use the API To access the API class, add newrelic-api.jar to your application class path. The jar is in the New Relic Java agent's installation zip file. You can call the API when the Java agent is not running. The API methods are just stubs; the implementation is added when the Java agent loads the class. Transactions To instrument Transactions in your application, use the following APIs. If you want to... Use this Create a Transaction when New Relic does not create one automatically @Trace(dispatcher = true) on the method that encompasses the work to be reported. When this annotation is used on a method within the context of an existing transaction, this will not start a new transaction, but rather include the method in the existing transaction. Capture the duration of a method that New Relic does not automatically trace @Trace() on the method you want to time. Set the name of the current Transaction NewRelic.setTransactionName(...) Start the timer for the response time of the current Transaction and to cause a Transaction you create to be reported as a Web transaction, rather than as an Other transaction NewRelic.setRequestAndReponse(...) Add custom attributes to Transactions and TransactionEvents NewRelic.addCustomParameter(...) Prevent a Transaction from being reported to New Relic NewRelic.ignoreTransaction() Exclude a Transaction when calculating your app's Apdex score NewRelic.ignoreApdex() Instrument asynchronous work For detailed information, see Java agent API for asynchronous applications. If you want to... Use this Trace an asynchronous method if it is linked to an existing Transaction... @Trace(async = true) Link the Transaction associated with the Token on the current thread... Token.link() or Token.linkAndExpire() Expire a Token associated with the current Transaction... Token.expire() Stop timing a Segment and have it report as part of its parent Transaction Segment.end() Stop timing a Segment and not have it report as part of its parent Transaction Segment.ignore() Distributed tracing API usage These APIs require distributed tracing to be enabled. See Java agent configuration for all distributed tracing config options. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. To see these APIs in action, see Using Java agent distributing tracing API with Kafka. Important With agent version 6.4.0, the following distributed tracing APIs were introduced, with the exception of addCustomAttribute(), which was introduced in 6.1.0. We highly recommended using these APIs instead of the deprecated ones. If you want to... Use this Create and insert distributed tracing headers into a Headers data structure. This API will insert both newrelic and W3C Trace Context headers (traceparent & tracestate), unless the agent is explicitly configured to exclude newrelic headers. Transaction.insertDistributedTraceHeaders(Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Accept the distributed tracing headers sent from the calling service and link these services together in a distributed trace. Transaction.acceptDistributedTraceHeaders(TransportType, Headers) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. The type-specific headers of an inbound or outbound message. For a provided implementation of Headers use ConcurrentHashMapHeaders. Headers Copy A utility class that provides enum constants for defining the transport type when accepting distributed tracing headers. TransportType Copy Add custom attributes to SpanEvents in distributed traces NewRelic.getAgent().getTracedMethod().addCustomAttribute(...) Caution With agent version 6.4.0, the following distributed tracing APIs have been deprecated and replaced by the APIs in the above table. It's highly recommended to upgrade the agent and use the new APIs instead of these deprecated ones. If you want to... Use this Create a payload to be sent to a called service. Transaction.createDistributedTracePayload() Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Accept a payload sent from the first service; this will link these services together in a trace. Transaction.acceptDistributedTracePayload(...) Copy For more on obtaining references to the current transaction and other API classes, see Obtain references. Caution API deprecated as of agent 6.4.0 Payload used to connect services. The text() call returns a JSON string representation of the payload. DistributedTracePayload.text() Caution API deprecated as of agent 6.4.0 Payload used to connect services. The httpSafe() call returns a base64 encoded JSON string representation of the payload. DistributedTracePayload.httpSafe() Caution API deprecated as of agent 6.4.0 Cross application tracing (CAT) API usage To track external calls and add cross application tracing, use the following APIs: If you want to... Use this Trace across a custom transport channel that New Relic does not support by default, such as a proprietary RPC transport Transaction.getRequestMetadata(), .processRequestMetadata(...), .getResponseMetadata(), .processResponseMetadata(...) Copy Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. View or change the metric name or a rollup metric name of a TracedMethod (A rollup metric name, such as OtherTransaction/all, is not scoped to a specific transaction. It represents all background transactions.) TracedMethod.getMetricName(), .setMetricName(...), .setRollupMetricName(...) Copy Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Report a call to an external HTTP service, database server, message queue, or other external resource that is being traced using the Java agent API's @Trace annotation TracedMethod.reportAsExternal(...) passing arguments constructed using ExternalParameters builder. Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Enable and add cross application tracing when communicating with an external HTTP or JMS service that is instrumented by New Relic TracedMethod.addOutboundRequestHeaders(...) along with TracedMethod.reportAsExternal(...) Also refer to the information in this document about using TracedMethod to obtain references to New Relic API classes. Add timing for an application server or dispatcher that is not supported automatically Transaction.setRequest(...), Transaction.setResponse(...), or NewRelic.setRequestAndResponse(...), and Transaction.markResponseSent() Also refer to the information in this document about using Transaction to obtain references to New Relic API classes. Obtain references to New Relic API classes Other tasks require the New Relic Agent object. The Agent object exposes multiple objects that give you the following functionality: If you want to... Use this Get a reference to the current Transaction NewRelic.getAgent().getTransaction() Get a Token to link asynchronous work NewRelic.getAgent().getTransaction().getToken() Copy Start and get a reference to a Segment NewRelic.getAgent().getTransaction().startSegment() Copy Get a reference to the method currently being traced NewRelic.getAgent().getTracedMethod() Get a reference to the Agent logger NewRelic.getAgent().getLogger() Get a reference to the Agent configuration NewRelic.getAgent().getConfig() Get a reference to an aggregator for custom metrics NewRelic.getAgent().getAggregator() Get a reference to Insights (our original name for the feature that governed custom events) in order to record custom events NewRelic.getAgent().getInsights() Additional API functionality The following APIs provide additional functionality, such as setting app server info, reporting errors, adding page load timing information, recording custom metrics, and sending custom events. If you want to... Use this Explicitly set port, name, and version information for an application server or dispatcher and the instance name for a JVM NewRelic.setAppServerPort(...), .setServerInfo(...), and .setInstanceName(...) Copy Report an error that New Relic does not report automatically NewRelic.noticeError(...) When inside a transaction, the last call to noticeError wins. Only 1 error will be reported per transaction. Add browser page load timing for Transactions that New Relic does not add to the header automatically NewRelic.getBrowserTimingHeader(), .getBrowserTimingFooter(), .setUserName(String name), .setAccountName(String name), and .setProductName(String name) Copy Create and accumulate custom metrics NewRelic.recordMetric(...), .recordResponseTimeMetric(...), or .incrementCounter(...) Record custom events Insights.recordCustomEvent(...) Or, use NewRelic.addCustomParameter(...) to add custom attributes to the New Relic-defined TransactionEvent type. Also refer to the information in this document about using Insights to obtain references to New Relic API classes. Additional API usage examples For detailed code examples about using the APIs, see New Relic's documentation about custom instrumentation for: External calls, cross application traces, messaging, datastores, and web frameworks Cross application tracing and external datastore calls Apps using custom instrumentation with annotation Custom framework instrumentation API Preventing unwanted instrumentation Inserting custom attributes Inserting custom events Collecting custom metrics",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 117.79285,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Guide</em> to using the Java <em>agent</em> <em>API</em> ",
        "sections": "<em>Guide</em> to using the Java <em>agent</em> <em>API</em>",
        "tags": "<em>API</em> <em>guides</em>",
        "body": "The New Relic Java <em>agent</em> <em>API</em> lets you control, customize, and extend the functionality of the APM Java <em>agent</em>. This <em>API</em> consists of: Static methods on the com.newrelic.<em>api.agent</em>.NewRelic class A @Trace annotation for implementing custom instrumentation A hierarchy of <em>API</em> objects providing additional"
      },
      "id": "6043c7f8e7b9d2dd935799df"
    },
    {
      "sections": [
        "Guide to using the Python agent API",
        "Custom instrumentation or API",
        "Monitor transactions and segments",
        "Add and edit transaction metadata",
        "Report custom events and custom metric data",
        "Message-related calls",
        "Implement distributed tracing",
        "Agent configuration, initialization, shutdown",
        "Control the Browser monitoring agent"
      ],
      "title": "Guide to using the Python agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "Python agent",
        "API guides"
      ],
      "external_id": "41f2cf33977b57e872b8c69a30b77fd603b51926",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/python-agent/api-guides/guide-using-python-agent-api/",
      "published_at": "2021-06-02T13:37:41Z",
      "updated_at": "2021-06-02T13:37:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The Python agent API allows you to customize and extend your monitoring. Use the Python agent API to: Manually instrument an unsupported framework or third-party system. Add instrumentation to supplement the agent's default monitoring. This document describes some of the available Python API calls. For a description of all our available APIs, see Introduction to APIs. Custom instrumentation or API If your goal is custom instrumentation, consider using the configuration file method, which allows you to add functions and class methods to the config file that will be auto-instrumented by the agent. The benefit of the config-file method is that it does not require you to change your application code. However, the Python agent API is much more powerful and is best for setting up more complex and tailored instrumentation. To ensure you have access to the full API functionality, update to the latest Python agent. Monitor transactions and segments The Python agent is compatible with most of the common WSGI web frameworks. If the agent supports your framework, web requests automatically will be captured as transactions and displayed in the New Relic One UI. A transaction can also have function-level segments that are captured as part of a transaction trace. Use these methods to monitor web transactions, non-web transactions, and transaction segments: If you want to... Do this... Monitor WSGI web transactions The Python agent automatically captures web transactions for supported frameworks. If you do not have a supported framework, you can use the wsgi_application function to monitor your WSGI entry point. Monitor non-web transactions The Python agent classifies non-web transactions as background tasks. To capture non-web transactions, use background_task. Capture more details about a transaction If your transaction traces do not have the level of detail you want: Use function_trace to capture more function-level detail in transactions. Use datastore_trace to capture more detail about datastore calls. Ignore a transaction Use any of these options: To ignore a transaction altogether, use ignore_transaction. To prevent a transaction from producing a transaction trace, use suppress_transaction_trace. To end a transaction before the agent would end it automatically, use end_of_transaction. Add and edit transaction metadata Sometimes the code you target is visible in our UI, but some details of the method are not useful. For example: The default name is not helpful, or it is causing a metric grouping issue. You want to add custom attributes to your transactions so you can filter them when querying. Use these calls when you want to change the metadata of an existing transaction: If you want to... Do this... Get reference to current transaction To return an object representing the current transaction, use current_transaction. This is required by some other Python agent API calls. Change the name of a transaction Use set_transaction_name. Add metadata (such as a customer's subscription level) to transactions Add custom attributes to your transactions using add_custom_parameter, or use other API calls to report custom data. Mark a transaction as a background job To convert a web transaction into a background task so that it appears as a non-web transaction in the UI, use set_background_task. Prevent a transaction from affecting your Apdex score Use suppress_apdex_metric. Report custom events and custom metric data The agent reports data in two primary forms: Metric data measures numeric, time-based values; for example, connections per minute. Event data captures discrete event information. Events have key-value attributes attached to them. You can analyze and query event data. Use these methods to create new event data and new metric data: If you want to... Do this... Send data about an event for use when querying your data. Use record_custom_event. Report time-based metrics on application performance To report a single metric, use record_custom_metric. To report a set of metrics, use record_custom_metrics. Report an exception as an error By default, the Python agent only reports unhandled exceptions. To report a Python exception as an error, use notice_error. Report query string parameters For security reasons, query string parameters associated with web transactions are disabled by default. Use capture_request_params to enable them. Tag events with metadata To add attributes to events for more detailed analysis in Insights or error analytics, use add_custom_parameter. Generate metrics from data sources and data factories To generate metrics with a pull-style API rather than the push-style API implemented by record_custom_metric(), use these API calls: register_data_source data_source_generator data_source_factory Message-related calls These API calls allow you to collect performance data on your message-passing architecture or service; for example, RabbitMQ. To use these calls, make sure you have Python agent version 2.88.0.72 or higher. If you want to... Do this... Report messages as a transaction Use message_transaction. Report message details as transaction trace segments Use message_trace. Implement distributed tracing These APIs require distributed tracing to be enabled. Services and applications monitored by our agents will automatically pass distributed tracing context to each other when using a supported framework. When not using a supported framework, you will need to use the distributed tracing APIs to manually accept this context. Supported web frameworks (for example, Flask, Django, Tornado) will automatically call accept_distributed_trace_payload when creating a transaction. Supported external web services libraries will automatically call create_distributed_trace_payload before making an external HTTP call. For general instructions on how to use the calls below to implement distributed tracing, see Use distributed tracing APIs. If you want to... Do this... Create a payload to be sent to a called service. Use create_distributed_trace_payload. Accept a payload sent from the first service; this will link these services together in a trace Use accept_distributed_trace_payload. Agent configuration, initialization, shutdown These calls help you manage Python agent behavior, such as initializing and integrating the agent, and referencing or changing configuration settings: If you want to... Do this... Initialize the agent To initialize the Python agent with a specific configuration file as part of advanced integration process, use initialize. Get a reference to the application object The application object represents an agent-monitored application and is used by some Python agent API calls. Get a reference to configuration settings To control the Python agent's behavior, you can use configuration settings. To get a reference to config file and environment variable settings and make changes to them, use global_settings. To get a reference to all settings, including server-side configuration from our UI, use application_settings. Shut down the agent To forcibly shut down the agent instead of allowing it to make the standard final attempt to upload data, use shutdown_agent. Control the Browser monitoring agent You can install the browser monitoring agent by automatically adding it to your pages or by deploying it on specific pages by copying and pasting the browser agent JavaScript snippet. You can also control the browser agent by using APM agent API calls. For more information, see Browser agent and the Python agent. If you want to... Do this... Monitor specific page views To inject the browser agent header and footer JavaScript snippets into views you want to monitor, use both get_browser_timing_header and get_browser_timing_footer. Disable monitoring of specific page views To disable browser monitoring for specific page views, use disable_browser_autorum.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 117.09311,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Guide</em> to using the Python <em>agent</em> <em>API</em>",
        "sections": "<em>Guide</em> to using the Python <em>agent</em> <em>API</em>",
        "tags": "<em>API</em> <em>guides</em>",
        "body": "The Python <em>agent</em> <em>API</em> allows you to customize and extend your monitoring. Use the Python <em>agent</em> <em>API</em> to: Manually instrument an unsupported framework or third-party system. Add instrumentation to supplement the <em>agent</em>&#x27;s default monitoring. This document describes some of the available Python <em>API</em> calls"
      },
      "id": "60441c8d64441f0ec7378eff"
    },
    {
      "sections": [
        "Guide to using the Node.js agent API",
        "Requirements",
        "Instrument missing sections of your code with transactions",
        "Time specific methods using segments",
        "Enhance the metadata of a transaction",
        "Instrument asynchronous work",
        "Instrument calls to external services",
        "Collect or ignore errors",
        "Send custom event and metric data from your app",
        "Control the browser agent",
        "Extend custom instrumentation"
      ],
      "title": "Guide to using the Node.js agent API",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "API guides"
      ],
      "external_id": "0c26c1cc3ef128c47758c020985c2d4942db7fdb",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/api-guides/guide-using-nodejs-agent-api/",
      "published_at": "2021-06-02T15:15:38Z",
      "updated_at": "2021-03-11T08:08:47Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Node.js agent API allows you to extend the agent's standard functionality. You can use this API to: Create custom transaction parameters Report custom errors and metrics You can also use the API for custom instrumentation. For supported frameworks, the agent instruments most activity automatically. Custom instrumentation lets you extend that monitoring to frameworks without default instrumentation. Other resources: The Node.js agent API documentation on GitHub has more detail and practical tutorials. You can also adjust the Node.js agent's default behavior with configuration settings. To see all available New Relic APIs, see Intro to APIs. Requirements To use the Node.js agent API, make sure you have the latest Node.js agent release. In addition, see: Node.js agent API requirements Getting started procedures on GitHub Instrument missing sections of your code with transactions To instrument your app, New Relic separates each path through your code into its own transaction. New Relic times (or \"instruments\") the parent method in these transactions to measure your app's overall performance, and collects transaction traces from long-running transactions for additional detail. Use these methods when New Relic is not instrumenting a particular part of your code at all: If you want to... Do this... Start timing a method New Relic is not instrumenting automatically Create a new transaction. See newrelic.startWebTransaction(). Stop timing a method after its work is completed Use either of these options: Return a promise from the callback handed to newrelic.startWebTransaction. Call end on a handle returned from newrelic.getTransaction. Prevent a transaction from reporting to New Relic Ignore the transaction using any of these options: See Rules for ignoring requests. Call ignore() on a handle returned from newrelic.getTransaction. Time specific methods using segments If a transaction is already visible in New Relic, but you don't have enough data about a particular method that was called during that transaction, you can create segments to time those individual methods in greater detail. For example, you might want to time a particularly critical method with complex logic. Use this method when you want to instrument a method within an existing transaction: If you want to... Do this... Time a particular method See newrelic.startSegment(). For more information about timing, see the instrumentation tutorial on GitHub. Enhance the metadata of a transaction Sometimes the code you are targeting is visible in New Relic, but some details of the method are not useful. For example: The default name might not be helpful. (Perhaps it is causing a metric grouping issue.) You want to add custom attributes to your transactions so you can filter them . Use these methods when you want to change how New Relic instruments a transaction that's already visible in New Relic: If you want to... Do this... Change the name of a transaction See newrelic.setTransactionName and rules.name. Add metadata (such as your customer’s account name or subscription level) to your transactions Use custom attributes. (Custom attribute collection is enabled by default in the Node.js agent.) See newrelic.addCustomAttribute() and newrelic.addCustomAttributes(). Create a new transaction for background work See newrelic.startBackgroundTransaction(). Create a new web transaction Use newrelic.startWebTransaction(). Prevent a transaction from affecting your Apdex score See Rules for naming and ignoring requests, including the ignoring rules example. Record other performance data, such as timing or computer resource data Use the custom metrics API. Instrument asynchronous work For supported frameworks and supported Node.js versions, New Relic's Node.js agent usually correctly instruments async work. However, if your app uses another framework, or if the default async instrumentation is inaccurate, you can explicitly track async work. If you want to... Do this... Trace an async method that New Relic is already instrumenting See newrelic.startSegment. Trace an async method that New Relic is not instrumenting See newrelic.startSegment. Trace a transaction that got lost See newrelic.startSegment. You can also create your own custom instrumentation for libraries that are losing your transactions. Trace a lost transaction state A common issue is the loss of transaction state while using uninstrumented libraries. For more information, see the transaction preservation tutorial on GitHub. Instrument calls to external services Once the request naming API loads, New Relic's Node.js agent can automatically identify external service calls. You can also use these methods to collect data about your app's connections to other apps or databases: If you want to... Do this... Time a call to an external resource (such as an external service, database server, or message queue) Use any of these as appropriate: Custom instrumentation API Message queues Also see the tutorials on GitHub for datastore shims and message shims. Connect activity to another app instrumented by a New Relic agent Use cross application tracing. Collect or ignore errors Usually the agent detects errors automatically. However, you can manually mark an error with the agent. You can also mark errors as ignored. If you want to... Do this... Report an error the agent does not report automatically See newrelic.noticeError(). Send custom event and metric data from your app New Relic includes a number of ways to record arbitrary custom data. For an explanation of New Relic data types, see Data collection. If you want to... Do this... Send data about an event so you can analyze it in New Relic Create a custom event. See newrelic.recordCustomEvent(). Tag your events with metadata to filter and facet them Add custom attributes if needed. (Custom attribute collection is enabled by default in the Node.js agent.) See newrelic.addCustomAttribute() and newrelic.addCustomAttributes(). Report custom performance data Create a custom metric. See newrelic.recordMetric() and newrelic.incrementMetric(). To view the data, use the data explorer. Control the browser agent Usually the browser agent is added automatically to your pages or deployed by copy/pasting the JavaScript snippet. For more information about these recommended methods, see Add browser apps to New Relic. You can also control the browser agent via APM agent API calls. For more information, see Browser monitoring and the Node.js agent. Extend custom instrumentation The newrelic.instrument() provides additional flexibility for custom instrumentation. For more information, including tutorials and examples, see the shims documentation on GitHub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 96.539154,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Guide</em> to using the Node.js <em>agent</em> <em>API</em>",
        "sections": "<em>Guide</em> to using the Node.js <em>agent</em> <em>API</em>",
        "tags": "<em>Nodejs</em> <em>agent</em>",
        "body": "Our <em>Node.js</em> <em>agent</em> <em>API</em> allows you to extend the <em>agent</em>&#x27;s standard functionality. You can use this <em>API</em> to: Create custom transaction parameters Report custom errors and metrics You can also use the <em>API</em> for custom instrumentation. For supported frameworks, the <em>agent</em> instruments most activity"
      },
      "id": "60440faae7b9d29ea8579a05"
    }
  ],
  "/docs/agents/nodejs-agent/attributes/nodejs-agent-attributes": [
    {
      "sections": [
        "Ruby agent attributes",
        "httpResponseCode",
        "request.headers.referer",
        "request.parameters.*",
        "job.resque.args.*",
        "job.sidekiq.args.*",
        "Adding custom attributes",
        "Caution",
        "Upgrading the Ruby agent",
        "For more help"
      ],
      "title": "Ruby agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Ruby agent",
        "Attributes"
      ],
      "external_id": "76453699d829800b2dc9757c66c6f25f6c37f86a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/ruby-agent/attributes/ruby-agent-attributes/",
      "published_at": "2021-06-02T22:15:59Z",
      "updated_at": "2021-06-02T22:15:59Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. These key-value pairs can be viewed within transaction traces in APM, traced errors in APM, transaction events in dashboards, and page views in dashboards. You can customize exactly which attributes will be sent to each of these destinations. These attribute settings apply to version 3.12.0 or higher of the Ruby agent. Ruby agent attributes The following table lists the attributes that can be automatically captured by the Ruby agent: httpResponseCode The response status code for a web request. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Unavailable Note: The httpResponseCode attribute (string value) is deprecated as of agent version 6.12.0. http.statusCode (integer value) should be used instead. request.headers.referer The HTTP referrer header if present (minus the query string). Defaults: Transaction traces: Disabled Error collector (traced errors): Enabled Transaction events: Disabled Page views (browser monitoring): Unavailable request.parameters.* The HTTP request parameters, associated with the transaction. Available for Rails, Sinatra, and Grape applications only. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Disabled Note: The capture_params property is deprecated. However, if set to true, it will enable request parameters for transaction traces and traced errors. job.resque.args.* Job arguments passed to the Resque worker. Arguments passed to Resque workers are positional. These arguments are stored as keys of the form job.resque.args.<position> where position is the index of the argument to the perform method. For example, a Resque job that takes two arguments will have keys job.resque.args.0 and job.resque.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The resque.capture_params property is deprecated. However, if set to true, it will enable capture of Resque arguments for transaction traces, traced errors. job.sidekiq.args.* Job arguments passed to the Sidekiq worker. Arguments passed to Sidekiq workers are positional. These arguments are stored as keys of the form job.sidekiq.args.<position> where position is the index of the argument to the perform method. For example, a Sidekiq job that takes two arguments will have keys job.sidekiq.args.0 and job.sidekiq.args.1. Defaults: Transaction traces: Disabled Error collector (traced errors): Disabled Transaction events: Disabled Page views (browser monitoring): Unavailable Note: The sidekiq.capture_params property is deprecated. However, if set to true, it will enable capture of Sidekiq arguments for transaction traces and traced errors. Adding custom attributes To capture additional custom attributes from your application, use NewRelic::Agent.add_custom_attributes. For full reference see Collecting custom attributes. Defaults: Transaction traces: Enabled Error collector (traced errors): Enabled Transaction events: Enabled Page views (browser monitoring): Disabled Caution If you want to query your custom parameters or attributes, avoid using any of the reserved terms for naming them. Upgrading the Ruby agent When upgrading to Ruby agent 3.12.0 or higher, upgrade your newrelic.yml configuration. For more help Additional documentation resources include: Agent attributes (types, destinations, and limits for attributes used by New Relic agents) Enabling and disabling attributes (properties, rules, and backwards compatibility information for Ruby agent attributes) Attribute examples (scenarios and results of enabling and disabling different Ruby agent attributes)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.99095,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Ruby <em>agent</em> <em>attributes</em>",
        "sections": "Ruby <em>agent</em> <em>attributes</em>",
        "tags": "<em>Agents</em>",
        "body": " <em>attributes</em> (types, destinations, and limits for <em>attributes</em> used by New Relic <em>agents</em>) Enabling and disabling <em>attributes</em> (properties, rules, and backwards compatibility information for Ruby <em>agent</em> <em>attributes</em>) Attribute examples (scenarios and results of enabling and disabling different Ruby <em>agent</em> <em>attributes</em>)"
      },
      "id": "6044042028ccbc7da82c6083"
    },
    {
      "sections": [
        "Enable or disable attributes",
        "Properties",
        "newrelic.attributes.enabled",
        "newrelic.browser_monitoring.attributes.enabled",
        "newrelic.error_collector.attributes.enabled",
        "newrelic.transaction_events.attributes.enabled",
        "newrelic.transaction_tracer.attributes.enabled",
        "newrelic.span_events.attributes.enabled",
        "newrelic.attributes.include",
        "newrelic.attributes.exclude",
        "newrelic.browser_monitoring.attributes.include",
        "newrelic.browser_monitoring.attributes.exclude",
        "newrelic.error_collector.attributes.include",
        "newrelic.error_collector.attributes.exclude",
        "newrelic.transaction_events.attributes.include",
        "newrelic.transaction_events.attributes.exclude",
        "newrelic.transaction_tracer.attributes.include",
        "newrelic.transaction_tracer.attributes.exclude",
        "newrelic.span_events.attributes.include",
        "newrelic.span_events.attributes.exclude",
        "Attribute rules",
        "Root level takes precedence for enabled.",
        "Destination enabled takes precedence over include and exclude.",
        "Attribute is included if the destination is enabled.",
        "Exclude always supersedes include.",
        "Keys are case sensitive.",
        "Use a star (\\*) for wildcards.",
        "Most specific setting for a key takes priority.",
        "Include or exclude affects the specific destination.",
        "Deprecated properties",
        "For more help"
      ],
      "title": "Enable or disable attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "Attributes"
      ],
      "external_id": "6e9bf6c2e32a6add76412e6381a7bd4c99a0bc1c",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/attributes/enable-or-disable-attributes/",
      "published_at": "2021-06-02T20:32:04Z",
      "updated_at": "2021-06-02T20:32:03Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Learn about properties to enable or disable attributes, and the rules that New Relic uses when determining which attributes to include or exclude for a destination. This also includes a summary of the PHP agent properties that have been deprecated with the release of New Relic agent attributes. Properties Use the following destination properties to open or close the destination to any attribute collection: newrelic.attributes.enabled Type Boolean Default True Turns on or turns off all attributes in all destinations. newrelic.browser_monitoring.attributes.enabled Type: Boolean Default: False Turns on or turns off all attributes for browser monitoring. This is the data that gets attached to page view events. If newrelic.attributes.enabled is false, no attributes will be sent to browser monitoring regardless of how this property is set. newrelic.error_collector.attributes.enabled Type: Boolean Default: True Turns on or turns off all attributes for traced errors. If newrelic.attributes.enabled is false, no attributes will be sent to traced errors regardless of how this property is set. newrelic.transaction_events.attributes.enabled Type: Boolean Default: True Turns on or turns off all attributes for transaction events. If newrelic.attributes.enabled is false, no attributes will be sent to transaction events regardless of how this property is set. newrelic.transaction_tracer.attributes.enabled Type Boolean Default True Turns on or off all attributes for transaction traces. If newrelic.attributes.enabled is false, no attributes will be sent to transaction traces regardless of how this property is set. newrelic.span_events.attributes.enabled Type Boolean Default True Turns on or off all attributes for Span data. If newrelic.attributes.enabled is false, no attributes will be sent to spans regardless of how this property is set. Use the following attribute/destination specific .include or .exclude properties to add or remove specific attributes in specific destinations: newrelic.attributes.include Type: Comma-delimited list of strings Default: Empty If attributes are enabled, all attribute keys in this list will be sent to New Relic. newrelic.attributes.exclude Type: Comma-delimited list of strings Default: Empty All attribute keys in this list will not be sent to New Relic. newrelic.browser_monitoring.attributes.include Type: Comma-delimited list of strings Default: Empty If attributes are enabled for browser_monitoring, all attribute keys in this list will be sent to New Relic Browser in page views. newrelic.browser_monitoring.attributes.exclude Type: Comma-delimited list of strings Default: Empty All attribute keys found in this list will not be sent to New Relic in page views. newrelic.error_collector.attributes.include Type: Comma-delimited list of strings Default: Empty If attributes are enabled for traced errors, all attribute keys in this list will be sent to New Relic in traced errors. newrelic.error_collector.attributes.exclude Type: Comma-delimited list of strings Default: Empty All attribute keys in this list will not be sent to New Relic in traced errors. newrelic.transaction_events.attributes.include Type: Comma-delimited list of strings Default: Empty If attributes are enabled for transaction events, all attribute keys in this list will be sent to New Relic in transaction events. newrelic.transaction_events.attributes.exclude Type: Comma-delimited list of strings Default: Empty All attribute keys in this list will not be sent to New Relic in transaction events. newrelic.transaction_tracer.attributes.include Type: Comma-delimited list of strings Default: Empty If attributes are enabled for transaction traces, all attribute keys in this list will be sent to New Relic in transaction traces. newrelic.transaction_tracer.attributes.exclude Type: Comma-delimited list of strings Default: Empty All attribute keys in this list will not be sent to New Relic in transaction traces. newrelic.span_events.attributes.include Type: Comma-delimited list of strings Default: Empty If attributes are enabled for span events, all attribute keys in this list will be sent to New Relic in span events. newrelic.span_events.attributes.exclude Type: Comma-delimited list of strings Default: Empty All attribute keys in this list will not be sent to New Relic in span events. Attribute rules New Relic follows these rules when determining which attributes to include or exclude for a destination. Root level takes precedence for enabled. The newrelic.attributes.enabled field trumps all other settings. When false, no attributes will be reported to New Relic. Example configuration: newrelic.attributes.enabled = false newrelic.attributes.include = foo,bar newrelic.transaction_tracer.attributes.enabled = true Copy Example output: Keys passed in: password, foo, bar, bat Keys included for all destinations: Keys excluded for all destinations: password, foo, bar, bat Copy Destination enabled takes precedence over include and exclude. newrelic.{destination}.attributes.enabled flags take precedence over include and exclude keys. Example configuration: newrelic.transaction_tracer.attributes.enabled = false newrelic.attributes.include = one,two newrelic.transaction_tracer.attributes.include = three,four Copy Example output: Keys passed in: one, two, three, four Keys included for transaction traces: Keys excluded for transaction traces: one, two, three, four Copy Attribute is included if the destination is enabled. If a destination is enabled, all user attributes are sent to that destination by default. All user attributes default to true. However, by default, request attributes and message parameters are disabled for all destinations. Example configuration: newrelic.attributes.enabled = true newrelic.attributes.exclude = myAttKey Copy Example output: Keys passed in: foo, bar, myAttKey Keys included: foo, bar Keys excluded: myAttKey Copy Exclude always supersedes include. If the same key is listed in the include and exclude lists, then attributes with the specified key will be excluded. Example configuration: newrelic.attributes.enabled = true newrelic.attributes.include = foo,myCustomAtt newrelic.attributes.exclude = password,myCustomAtt Copy Example output: Keys passed in: foo, myCustomAtt, password Keys included: foo Keys excluded: password, myCustomAtt Copy Keys are case sensitive. Keys are case sensitive. Example configuration: newrelic.attributes.enabled = true newrelic.attributes.exclude = password,PaSsWoRd Copy Example output: Keys passed in: password, Password, PASSWORD, PaSsWoRd, PassWORD Keys included: Password, PASSWORD, PassWORD Keys excluded: password, PaSsWoRd Copy Use a star (\\*) for wildcards. You can use an asterisk or star (*) at the end of a key as a wildcard. This will match a set of attributes with the same prefix. Example configuration: newrelic.attributes.enabled = true newrelic.attributes.include = custom* newrelic.attributes.exclude = request.parameters.* Copy Example output: Keys passed in: custom, custom.key1, custom.key2, request.parameters., request.parameters.foo, request.parameters.bar Keys included: custom, custom.key1, custom.key2 Keys excluded: request.parameters., request.parameters.foo, request.parameters.bar Copy Most specific setting for a key takes priority. If multiple include or exclude attributes affect the same key, the most specific setting will have priority. Example configuration: newrelic.attributes.enabled = true newrelic.attributes.include = request.parameters.foo newrelic.attributes.exclude = request.parameters.* Copy Example output: Keys passed in: request.parameters., request.parameters.foo, request.parameters.bar Keys included: request.parameters.foo Keys excluded: request.parameters., request.parameters.bar Copy Include or exclude affects the specific destination. If the attribute include or exclude is specified on a destination, then it only impacts that destination. Example configuration: newrelic.attributes.include = foo newrelic.transaction_events.attributes.exclude = foo Copy Example output: Keys passed in: foo Keys included for transaction events: Keys included for other destinations: foo Keys excluded for transaction events: foo Copy Deprecated properties The following properties have been deprecated. Switch to the new attributes configuration for these properties when upgrading your PHP agent. Deprecated property New property newrelic.capture_params newrelic.attributes.include = request.parameters.* By default, request parameters are not sent to New Relic. Add request.parameters.* to the newrelic.attributes.include list to turn on all request parameters. The newrelic.capture_params property has been deprecated. newrelic.ignored_params newrelic.attributes.exclude = request.parameters.{name} Add each request parameter key to the newrelic.attributes.exclude list, delimited by commas. Be sure to prepend the key with request.parameters. The newrelic.ignored_params property has been deprecated. newrelic.{destination}.capture_attributes newrelic.{destination}.attributes.enabled The old newrelic.{destination}.capture_attributes flag would turn off user attribute collection. This has been deprecated. Use newrelic.{destination}.attributes.enabled instead. For more help If you need more help, check out these support and learning resources: Suggest a change and learn how to contribute to our PHP agent open source repository. Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 125.26526,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Enable or disable <em>attributes</em>",
        "sections": "Enable or disable <em>attributes</em>",
        "tags": "<em>Agents</em>",
        "body": "Learn about properties to enable or disable <em>attributes</em>, and the rules that New Relic uses when determining which <em>attributes</em> to include or exclude for a destination. This also includes a summary of the PHP <em>agent</em> properties that have been deprecated with the release of New Relic <em>agent</em> <em>attributes</em>"
      },
      "id": "603e9d6de7b9d22a5f2f3445"
    },
    {
      "sections": [
        "Agent attributes",
        "Attribute destination flow",
        "Types of attributes",
        "Destinations for attributes",
        "Viewing request attributes",
        "Limits",
        "Agent-specific attributes"
      ],
      "title": "Agent attributes",
      "type": "docs",
      "tags": [
        "Agents",
        "Manage APM agents",
        "Agent data"
      ],
      "external_id": "088fa6cfe4cd8dd8f6ee9462a0181497904caf42",
      "image": "https://docs.newrelic.com/static/28e38366587e506dc64423df1bff8073/8c557/screen-tx-trace-attributes.png",
      "url": "https://docs.newrelic.com/docs/agents/manage-apm-agents/agent-data/agent-attributes/",
      "published_at": "2021-06-02T17:50:56Z",
      "updated_at": "2021-06-02T17:50:56Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Attributes are key-value pairs containing information that determines the properties of an event or transaction. You can view these key-value pairs in some places in the UI, or by querying that data using NRQL. New Relic gives users the ability to customize exactly which attributes will be sent to each of these destinations. You can also collect custom attributes to send additional data to New Relic. Attribute destination flow This diagram illustrates how an agent decides to send attributes to each destination. Agent attribute collection: An agent makes three different decisions when sending an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by agent. (The properties in this diagram are specific to the PHP agent, but the general flow is the same for all agents. Property names and syntax vary by agent.) Types of attributes Attributes can be collected in a variety of ways: Message property attributes: These are the properties set on a message received from a queue or topic. HTTP request attributes: These are the parameters for an HTTP request. User attributes: These are attributes provided by the user through each agent's API. Agent attributes: These are attributes captured by the agent; for example, httpResponseCode and httpResponseMessage. Destinations for attributes Collected attributes appear in these locations: Collected attributes Location Transaction traces Each minute transaction traces collect data for your slowest individual HTTP requests. These traces will report attributes collected during the transaction. Traced errors If a transaction results in an error, these traced errors will be reported to New Relic APM. A traced error will contain attributes collected during the transaction. Transaction events APM transactions will contain attributes collected during the transaction. Insights page views Browser page views will contain attributes collected during the transaction. However, attributes collected at the end of a transaction may not appear on PageView events. This destination is also called browser monitoring. Span events Span events collected for distributed tracing will contain attributes collected during the span. The following agents support the addition of custom user attributes to span events: Java agent 5.13.0 and above Go agent 3.6.0 and above .NET agent 8.25 and above Node agent 6.10.0 and above PHP agent 9.12.0.268 and above Python agent 5.8.0.136 and above Ruby agent 6.8.0 and above Transaction segments Each segment in a transaction trace will contain attributes recorded for that segment. Viewing request attributes Request attributes are associated with specific transaction traces, browser traces, and errors in New Relic APM and New Relic Insights. You can see the attributes recorded with a request when viewing the individual trace or error. Custom attributes can be queried via NRQL exactly like any other attribute. APM > (select an app) > Monitoring > Transactions > (select a transaction) > (select a trace): Here is an example from the Ruby agent of the Request attributes and Custom attributes for a transaction trace. Exact attributes depend on your agent and on your attribute configuration. Limits User attributes, request attributes, and message queue parameters are limited by count and size. Parameter Limitations Transaction Limited to 64 user attributes Attribute key Limited to 256 bytes each If the key is more than 256 bytes, then the attribute will not be recorded. Attribute value Limited to 256 bytes each If the value is greater than 256 bytes, then the attribute value will be truncated. Agent-specific attributes Each New Relic APM agent collects custom attributes. The supported attributes depend on the specific agent: C SDK Go Java .NET Node.js PHP Python Ruby",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 101.42665,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Agent</em> <em>attributes</em>",
        "sections": "<em>Agent</em> <em>attributes</em>",
        "tags": "<em>Agents</em>",
        "body": " an attribute to any New Relic destination based on the relevant property settings. Property names and syntax vary by <em>agent</em>. (The properties in this diagram are specific to the PHP <em>agent</em>, but the general flow is the same for all <em>agents</em>. Property names and syntax vary by <em>agent</em>.) Types of <em>attributes</em>"
      },
      "id": "603eb9db28ccbc127aeba79e"
    }
  ],
  "/docs/agents/nodejs-agent/extend-your-instrumentation/apollo-server-plugin-nodejs": [
    {
      "sections": [
        "Node.js VMs statistics page",
        "What you need",
        "View Node VM statistics",
        "Analyze performance issues",
        "GC pause time",
        "GC pause frequency",
        "GC pause time by type",
        "Memory usage",
        "CPU utilization",
        "Event loop — ticks per minute",
        "Event loop — max CPU time per tick",
        "View clusters of multiple processes"
      ],
      "title": "Node.js VMs statistics page",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Extend your instrumentation"
      ],
      "external_id": "b1c5ecf7ca24b63c50ed1021f020d62e513f8455",
      "image": "https://docs.newrelic.com/static/b0ab0aacf7b062b687be29a94ff96a43/8c557/vm-dashboard.png",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/extend-your-instrumentation/nodejs-vms-statistics-page/",
      "published_at": "2021-06-02T20:25:06Z",
      "updated_at": "2021-03-16T15:01:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In New Relic's APM, the Node VMs page provides useful runtime data for troubleshooting performance issues and monitoring the health of your application. What you need Some of the charts on the Node VMs page require you to install the New Relic Native Metrics Module in addition to the Node.js agent. For installation instructions, see Node VM Measurements. View Node VM statistics one.newrelic.com > APM > (select an app) > Node VMs: When multiple servers are reporting to the same application, the page breaks charts down by server. You can view data for an individual server and obtain additional details by selecting a server from the Servers filter at the top of the page. To correlate spikes or upward trends in any of these measurements with specific transactions: Go to one.newrelic.com > APM > (select an app) > Node VMs. Select the time period by clicking and dragging within any of the charts. Navigate to the Transactions page or any other page. As you go to other pages, the time picker selection will remain the same. Analyze performance issues Here is a summary of the data available on individual Node VM charts. By using all of the charts together, you can troubleshoot performance issues. For example: When the application starts using more objects, memory usage will increase, and garbage collection (GC) will run more frequently. CPU utilization will increase due to time spent in GC. Abnormally long synchronous code execution can increase CPU utilization. This will show spikes in the Event loop max CPU time per tick chart. GC pause time The amount of time spent in garbage collection. For a single server, the chart shows average, max, and total time per minute. For multiple servers, the chart shows total time grouped by server. Typically, spikes in GC time or frequency indicate a potential issue. GC pause frequency The number of times GC runs were executed per minute. For a single server, the chart is broken down by the type of GC. For multiple servers, the chart shows total number of GC calls (all types combined) grouped by server. GC pause time by type This chart shows the total time spent in garbage collection per minute, broken down by GC type. It is only shown when viewing a single server. You might see the following types depending on your version of Node.js and app activity: Value Description Scavenge The most common garbage collection method. Node.js will typically trigger one of these every time the VM is idle. MarkSweepCompact The heaviest type of garbage collection V8 may do. If you see many of these happening you will need to either keep fewer objects around in your process or increase V8's heap limit. IncrementalMarking A phased garbage collection that interleaves collection with application logic to reduce the amount of time the application is paused. Only in Node.js v6 or higher. ProcessWeakCallbacks After a garbage collection occurs, V8 will call any weak reference callbacks registered for objects that have been freed. This measurement is from the start of the first weak callback to the end of the last for a given garbage collection. Only in Node.js v6 or higher. Memory usage This chart shows the amount of memory consumed by the Node.js process. For multiple servers, the chart shows total memory grouped by server. For a single server, the chart is segmented by the following types of memory: Value Description Non-heap The memory allocated to data outside V8's heap (for example, buffers, sockets). V8 heap (used) The amount of memory being used by V8 (for example, JavaScript objects). V8 heap (free) The amount of memory set aside by V8 for memory pooling. This memory isn't being actively used, but is set aside for V8 to freely allocate more as needed. CPU utilization This chart shows the CPU utilization of the Node process. For multiple servers, the chart shows total CPU utilization grouped by server. For a single server, the chart is segmented by the following: Value Description User The time spent executing the user code, divided by wall-clock time. System The time spent in the system kernel on behalf of the Node process, divided by wall-clock time. Event loop — ticks per minute This chart shows the number of event loop ticks per minute. A tick is a single turn of the event loop, in which functions that are ready to be executed are run. As a part of each event loop turn, Node waits for pending I/O to complete. Once any I/O events are received, the event loop executes callbacks associated with it. Therefore, the number of ticks per minute corresponds to how frequently I/O events occur. Event loop — max CPU time per tick This chart shows the maximum time spent in a single tick per minute. This is useful with detecting an abnormally long event loop tick, which indicates long synchronous code execution. View clusters of multiple processes When multiple Node.js processes on the same server report to the same New Relic application, these charts will show aggregated data. This is because each worker process in a cluster has its own separate Node.js runtime and collects separate data. Clusters Comments Sum across all workers The following charts show a sum across all workers: GC pause time - Total time per minute GC pause frequency GC pause time by type CPU utilization Event loop ticks per minute Average from all workers The following charts show an average from all workers: Memory usage GC pause time — average Max across all workers The following charts show max across all workers: GC pause time — max Event loop — max CPU time per tick",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.75662,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Extend</em> <em>your</em> <em>instrumentation</em>",
        "body": "In New Relic&#x27;s APM, the Node VMs page provides useful runtime data for troubleshooting performance issues and monitoring the health of <em>your</em> application. What you need Some of the charts on the Node VMs page require you to install the New Relic Native Metrics Module in addition to the <em>Node.js</em> <em>agent</em>"
      },
      "id": "603ea123e7b9d2eb022a0811"
    },
    {
      "sections": [
        "Node.js custom instrumentation",
        "Agent version requirements",
        "Instrument unsupported web frameworks",
        "Instrument unsupported message service clients",
        "Instrument unsupported datastores",
        "Instrument web transactions",
        "Custom web transaction example: Instrument three transactions in socket.io",
        "Instrument background transactions",
        "Custom background transaction example: Instrument within setInterval",
        "Expand instrumentation within transactions",
        "Important",
        "Example: Instrument a callback",
        "Example: Instrument asynchronous functions using callbacks",
        "Example: Instrument asynchronous functions using promises",
        "Example: Instrument async functions",
        "Example: Instrument a synchronous function"
      ],
      "title": "Node.js custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Extend your instrumentation"
      ],
      "external_id": "284f422639e1af4a65c26edd4d3f5bc53106e51a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/extend-your-instrumentation/nodejs-custom-instrumentation/",
      "published_at": "2021-06-02T15:04:34Z",
      "updated_at": "2021-03-16T14:59:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic for Node.js automatically instruments most standard web requests, but sometimes you want expanded instrumentation. With the agent's custom instrumentation API, you can create instrumentation for otherwise unsupported web frameworks, datastores, and message service clients. The Node.js agent's custom instrumentation API also allows you to: Create web transactions (useful for things like web sockets, where transactions can't be automatically created). Create non-web background transactions (useful for recording background jobs). Target specific sections of your code for deeper analysis. Agent version requirements The custom instrumentation methods in this document are available as of Node.js agent version 2.0.0. For information on instrumentation using the custom instrumentation API v1.x, see the documentation for legacy Node.js custom instrumentation. Instrument unsupported web frameworks Beginning with Node.js agent version 2.0.0, New Relic provides an API to expand instrumentation for additional web frameworks. For more information, including a tutorial, see the documentation for Node.js web framework instrumentation on GitHub. Instrument unsupported message service clients Beginning with Node.js agent version 2.0.0, New Relic provides an API to expand instrumentation for additional message service libraries. For more information, including a tutorial, see the documentation for Node.js message service client instrumentation on GitHub. Instrument unsupported datastores Beginning with Node.js agent version 2.0.0, New Relic provides an API to expand instrumentation for additional datastore libraries. For more information, including a tutorial, see the documentation for Node.js datastore instrumentation on GitHub. Instrument web transactions In order to create custom web transactions, call startWebTransaction to start the transaction. To end the transaction, use any of these options: Ending the transaction Comments Promise If the handler passed to startWebTransaction returns a promise, the agent will end the transaction when the returned promise resolves or rejects. Manual If you call getTransaction in the context of the new transaction, this notifies the agent that the transaction will be handled manually. If getTransaction is called in the handler, then you must end the transaction by calling transaction.end(). Synchronous If neither of these options are fulfilled, the transaction will be ended when the handler returns synchronously. Custom web transaction example: Instrument three transactions in socket.io This example instruments a /websocket/ping transaction, a /websocket/update transaction, and a /websocket/new-message transaction within socket.io. The /ping example is synchronous, while the /new-message and /update examples are asynchronous. var nr = require('newrelic') var app = require('http').createServer() var io = require('socket.io')(app) io.on('connection', function (socket) { socket.on('ping', function (data) { nr.startWebTransaction('/websocket/ping', function transactionHandler() { // Ended automatically after synchronously returning socket.emit('pong') }) }) socket.on('update', function (data) { nr.startWebTransaction('/websocket/update', function transactionHandler() { // Using API#getTransaction var transaction = nr.getTransaction() updateChatWindow(data, function transactionHandler() { socket.emit('update-done') transaction.end() }) }) }) socket.on('new-message', function (data) { nr.startWebTransaction('/websocket/new-message', function transactionHandler() { // Returning a promise return new Promise(function (resolve, reject) { addMessageToChat(data, function () { socket.emit('message-received') resolve() }) }) }) }) }) Copy This method only gives basic timing data for the transaction created. To create more intricate timing data and transaction naming for a particular framework, see the Node.js API documentation and the related tutorial on GitHub. Instrument background transactions You can use custom transactions to instrument non-web transactions (background tasks); for example: Periodic jobs within your app Work that continues after a request completes To instrument background tasks, call startBackgroundTransaction in your handler to start a background transaction. To end the transaction, use any of these options: Ending the transaction Comments Promise If the handler passed to startBackgroundTransaction returns a promise, the agent will end the transaction when the returned promise resolves or rejects. Manual If you call getTransaction in the context of the new transaction, this notifies the agent that the transaction will be handled manually. If getTransaction is called in the handler, then you must end the transaction by calling transaction.end(). Synchronous If neither of these options are fulfilled, the transaction will be ended when the handler returns synchronously. Custom background transaction example: Instrument within setInterval This example instruments update:cache within setInterval: var nr = require('newrelic') var redis = require('redis').createClient() // Using API#getTransaction to manage ending the transaction setInterval(function () { nr.startBackgroundTransaction('update:cache', function transactionHandler() { var newValue = someDataGenerator() var transaction = nr.getTransaction() redis.set('some:cache:key', newValue, function () { transaction.end() }) }) }, 30000) // Every 30s //Using a promise to manage ending the transaction setInterval(function () { nr.startBackgroundTransaction('flush:cache', function transactionHandler() { return new Promise(function(resolve, reject) { flushCache(redis, function afterFlush(err) { if (err) { return reject(err) } resolve() }) }) }) }, 60*60*1000) Copy Expand instrumentation within transactions You can create instrumentation using the instrumentation registration methods on the API. Writing instrumentation using the instrumentation API allows you to specify metrics and naming in greater detail by \"monkey patching\" methods (replacing functions) on relevant objects. Other options can offer visibility into web transactions that are already instrumented, or gain insight into databases and other in-transaction work that is not automatically instrumented. To do this, wrap your callbacks in custom tracers. Custom tracers create and collect specific metrics for an additional segment within an existing transaction, such as a particular function or a database call. To instrument individual callbacks, call startSegment() inside the callback, and move the main callback logic to the handler function. To instrument a function that is called inside an asynchronous function, wrap both the target function and its parent asynchronous function with startSegment(). Important These examples must be placed in code that is running under a transaction. The origin of the transaction, custom or automatically created, does not matter. Example: Instrument a callback This example tracks a single callback: // Wrap the method in a segment. nr.startSegment('db:createObject', true, function(cb) { // This is recorded as the `db:createObject` segment. db.createObject(cb) }, function(err, result) { // This is recorded as the callback to the `db:createObject` segment. if (util.handleError(err, res)) { return } res.write(JSON.stringify(result.rows[0].id)) res.write('\\n') res.end() }) Copy Example: Instrument asynchronous functions using callbacks This example tracks both pg.connect and client.query. This is because client.query is called by an asynchronous parent function (pg.connect). Otherwise, you would not get any data from client.query. This allows startSegment() to propagate the active transaction across those asynchronous boundaries. nr.startSegment('pg:connect', true, function(cb) { pg.connect(config.db_string, cb) }, function(err, client, done) { if (util.handleError(err, '500', res)) { return done() } nr.startSegment('pg:query', true, function(cb) { client.query('SELECT count(*) FROM test_count'), cb) }, function(err, result) { if (util.handleError(err, '500', res)) { return done() } res.write(result.rows[0].count) res.write('\\n') }) }) Copy Example: Instrument asynchronous functions using promises This example is the same as the callback one, but for interacting with a promise-based API. For promises, simply return the promise and call then after startSegment to continue your execution. nr.startSegment('pg:connect', true, function() { // This `pg:connect` segment will time until the returned promise // either resolves or rejects. return pg.connect(config.db_string) }).then(function(client) { // The transaction context is propagated into following promises. return nr.startSegment('pg:query', true, function() { return client.query('SELECT count(*) FROM test_count')) }).then(function(result) { res.write(result.rows[0].count) res.write('\\n') res.end() }, function(err) { // Error from querying. util.handleError(err, '500', res) }).finally(function() { return client.release() }) }, function(err) { // Error from connecting. util.handleError(err, '500', res) }) Copy Example: Instrument async functions This example shows how to instrument code using async/await to control asynchronous work. This requires using Node 8 or higher, as well as the New Relic for Node.js agent v2.3.0 or higher. try { const client = await nr.startSegment('pg:connect', true, async () => { // Async functions simply return promises, so this example is // very similar to the promise one. return await pg.connect(config.db_string) }) // The transaction context is propagated into the code following `await`. try { const result = await nr.startSegment('pg:query', true, async () => { return await client.query('SELECT count(*) FROM test_count')) }) res.write(result.rows[0].count) res.write('\\n') res.end() } catch(err) { // Error from querying. util.handleError(err, '500', res) } finally { await client.release() } } catch(err) { // Error from connecting. util.handleError(err, '500', res) } Copy Example: Instrument a synchronous function This example shows how startSegment can be used to record a synchronous function that is responsible for assigning its return value to a variable. var result = nr.startSegment('calculateTotal', true, function() { return calculateTotal(outerVar1, outerVar2) }) Copy Important The startSegment function is available of the Node Agent 3.3.0 release.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.75644,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Node.js custom <em>instrumentation</em>",
        "sections": "Node.js custom <em>instrumentation</em>",
        "tags": "<em>Extend</em> <em>your</em> <em>instrumentation</em>",
        "body": " analysis. <em>Agent</em> version requirements The custom <em>instrumentation</em> methods in this document are available as of <em>Node.js</em> <em>agent</em> version 2.0.0. For information on <em>instrumentation</em> using the custom <em>instrumentation</em> API v1.x, see the documentation for legacy <em>Node.js</em> custom <em>instrumentation</em>. <em>Instrument</em> unsupported web"
      },
      "id": "603ec39964441f02dc4e8882"
    },
    {
      "sections": [
        "Browser monitoring and the Node.js agent",
        "Insert the JavaScript header",
        "Framework examples",
        "Express and jade",
        "Express and Swig",
        "Hapi.js and handlebars",
        "Disable header generation",
        "Caution"
      ],
      "title": "Browser monitoring and the Node.js agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Extend your instrumentation"
      ],
      "external_id": "8b8cba2d5ce2acdc55df2621d850329cf4796bbd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/extend-your-instrumentation/browser-monitoring-nodejs-agent/",
      "published_at": "2021-06-02T15:16:26Z",
      "updated_at": "2021-03-16T09:02:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the Node.js agent, you can add browser instrumentation to your web pages. To use browser monitoring with your Node.js agent, ensure you have the latest release of the Node.js agent. To enable browser monitoring in the user interface, follow the procedures to install the browser agent. Then follow the procedures in this section to set up the Node.js agent. Insert the JavaScript header Instrumentation for the Node.js agent can continue beyond your application into end users' browsers. The newrelic module can generate script headers which, when inserted into your HTML templates, will capture the end users' page load times. The headers must be manually injected, but no extra configuration is necessary. At the beginning of your html page's head tag, insert the results of newrelic.getBrowserTimingHeader() after any CHARSET meta tags. Exception: For maximum Internet Explorer compatibility, insert the results of newrelic.getBrowserTimingHeader() after any X-UA-COMPATIBLE HTTP-EQUIV meta tags. Call the header once for every request. Do not cache the header. Generating headers is fast, and it does not require your application to make extra requests to New Relic. Framework examples Here are some examples of how to set up browser monitoring with different frameworks and templates. Express and jade This example uses Express, a web application framework, and jade, a template module. Although the specifics are different with other frameworks, this general approach should work in most cases. The simplest way to insert browser timing headings is to pass the newrelic module into your template, and then call newrelic.getBrowsertimingHeader() from within the template. In your app.js: var newrelic = require('newrelic'); var app = require('express')(); // in express, this lets you call newrelic from within a template app.locals.newrelic = newrelic; app.get('/user/:id', function (req, res) { res.render('user'); }); app.listen(process.env.PORT); Copy In your layout.jade: doctype html html head != newrelic.getBrowserTimingHeader() title= title link(rel='stylesheet', href='stylesheets/style.css') body block content Copy Express and Swig This example uses Express with Swig. In your app.js: var newrelic = require('newrelic'); var http = require('http') var path = require('path') var swig = require('swig') var app = require('express')(); app.locals.newrelic = newrelic; //taken from http://paularmstrong.github.io/swig/docs/#express app.engine('html', swig.renderFile); app.set('view engine', 'html'); app.set('views', __dirname + '/views'); app.get('/user/:id', function (req, res) { res.render('user'); }); app.listen(process.env.PORT); Copy In your views/user.html: <!DOCTYPE html> <html> <head> {{ newrelic.getBrowserTimingHeader() }} <title>Hello</title> </head> <body> <h1>Hello World</h1> </body> </html> Copy Hapi.js and handlebars This example uses hapi.js and handlebars. Other similar templating languages typically require triple brackets; for example, using mustache with hogan-express. This helps prevent escaping of the script content. Using hapi, in your app.js: var newrelic = require('newrelic'); var Hapi = require('hapi'); var server = new Hapi.Server(parseInt(PORT), '0.0.0.0', { views: { engines : {html: 'handlebars' }, path : __dirname + '/templates' } }); function homepage(request, reply) { var context = { // pass in the header each request nreum : newrelic.getBrowserTimingHeader(), content : ... }; reply.view('homepage', context); }; server.route({ method : 'GET', path : '/', handler : homepage }); server.start(); Copy In your templates/homepage.html: <!DOCTYPE html> <html> <head> {{{ nreum }}} <title>Hello</title> </head> <body> {{ content }} </body> </html> Copy Disable header generation By default, calls to newrelic.getBrowserTimingHeader() should return valid headers. To disable header generation without removing your template code: In your newrelic.js file, add: browser_monitoring : { enable : false } Copy You can also set the environment variable NEW_RELIC_BROWSER_MONITOR_ENABLE=false. Caution Always leave ssl between the agent and the New Relic collector when using browser monitoring. You can safely leave the API calls in place even if you are not using browser monitoring or the newrelic module. If browser monitoring is disabled, or if there is an error so that working headers cannot be generated, the newrelic module generates an innocuous HTML comment. If you disable the newrelic module completely, no content will be generated.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.71094,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Browser monitoring and the Node.js <em>agent</em>",
        "sections": "Browser monitoring and the Node.js <em>agent</em>",
        "tags": "<em>Extend</em> <em>your</em> <em>instrumentation</em>",
        "body": "With the <em>Node.js</em> <em>agent</em>, you can add browser <em>instrumentation</em> to <em>your</em> web pages. To use browser monitoring with <em>your</em> <em>Node.js</em> <em>agent</em>, ensure you have the latest release of the <em>Node.js</em> <em>agent</em>. To enable browser monitoring in the user interface, follow the procedures to install the browser <em>agent</em>"
      },
      "id": "603e8376e7b9d2b7472a07f7"
    }
  ],
  "/docs/agents/nodejs-agent/extend-your-instrumentation/browser-monitoring-nodejs-agent": [
    {
      "sections": [
        "Node.js VMs statistics page",
        "What you need",
        "View Node VM statistics",
        "Analyze performance issues",
        "GC pause time",
        "GC pause frequency",
        "GC pause time by type",
        "Memory usage",
        "CPU utilization",
        "Event loop — ticks per minute",
        "Event loop — max CPU time per tick",
        "View clusters of multiple processes"
      ],
      "title": "Node.js VMs statistics page",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Extend your instrumentation"
      ],
      "external_id": "b1c5ecf7ca24b63c50ed1021f020d62e513f8455",
      "image": "https://docs.newrelic.com/static/b0ab0aacf7b062b687be29a94ff96a43/8c557/vm-dashboard.png",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/extend-your-instrumentation/nodejs-vms-statistics-page/",
      "published_at": "2021-06-02T20:25:06Z",
      "updated_at": "2021-03-16T15:01:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In New Relic's APM, the Node VMs page provides useful runtime data for troubleshooting performance issues and monitoring the health of your application. What you need Some of the charts on the Node VMs page require you to install the New Relic Native Metrics Module in addition to the Node.js agent. For installation instructions, see Node VM Measurements. View Node VM statistics one.newrelic.com > APM > (select an app) > Node VMs: When multiple servers are reporting to the same application, the page breaks charts down by server. You can view data for an individual server and obtain additional details by selecting a server from the Servers filter at the top of the page. To correlate spikes or upward trends in any of these measurements with specific transactions: Go to one.newrelic.com > APM > (select an app) > Node VMs. Select the time period by clicking and dragging within any of the charts. Navigate to the Transactions page or any other page. As you go to other pages, the time picker selection will remain the same. Analyze performance issues Here is a summary of the data available on individual Node VM charts. By using all of the charts together, you can troubleshoot performance issues. For example: When the application starts using more objects, memory usage will increase, and garbage collection (GC) will run more frequently. CPU utilization will increase due to time spent in GC. Abnormally long synchronous code execution can increase CPU utilization. This will show spikes in the Event loop max CPU time per tick chart. GC pause time The amount of time spent in garbage collection. For a single server, the chart shows average, max, and total time per minute. For multiple servers, the chart shows total time grouped by server. Typically, spikes in GC time or frequency indicate a potential issue. GC pause frequency The number of times GC runs were executed per minute. For a single server, the chart is broken down by the type of GC. For multiple servers, the chart shows total number of GC calls (all types combined) grouped by server. GC pause time by type This chart shows the total time spent in garbage collection per minute, broken down by GC type. It is only shown when viewing a single server. You might see the following types depending on your version of Node.js and app activity: Value Description Scavenge The most common garbage collection method. Node.js will typically trigger one of these every time the VM is idle. MarkSweepCompact The heaviest type of garbage collection V8 may do. If you see many of these happening you will need to either keep fewer objects around in your process or increase V8's heap limit. IncrementalMarking A phased garbage collection that interleaves collection with application logic to reduce the amount of time the application is paused. Only in Node.js v6 or higher. ProcessWeakCallbacks After a garbage collection occurs, V8 will call any weak reference callbacks registered for objects that have been freed. This measurement is from the start of the first weak callback to the end of the last for a given garbage collection. Only in Node.js v6 or higher. Memory usage This chart shows the amount of memory consumed by the Node.js process. For multiple servers, the chart shows total memory grouped by server. For a single server, the chart is segmented by the following types of memory: Value Description Non-heap The memory allocated to data outside V8's heap (for example, buffers, sockets). V8 heap (used) The amount of memory being used by V8 (for example, JavaScript objects). V8 heap (free) The amount of memory set aside by V8 for memory pooling. This memory isn't being actively used, but is set aside for V8 to freely allocate more as needed. CPU utilization This chart shows the CPU utilization of the Node process. For multiple servers, the chart shows total CPU utilization grouped by server. For a single server, the chart is segmented by the following: Value Description User The time spent executing the user code, divided by wall-clock time. System The time spent in the system kernel on behalf of the Node process, divided by wall-clock time. Event loop — ticks per minute This chart shows the number of event loop ticks per minute. A tick is a single turn of the event loop, in which functions that are ready to be executed are run. As a part of each event loop turn, Node waits for pending I/O to complete. Once any I/O events are received, the event loop executes callbacks associated with it. Therefore, the number of ticks per minute corresponds to how frequently I/O events occur. Event loop — max CPU time per tick This chart shows the maximum time spent in a single tick per minute. This is useful with detecting an abnormally long event loop tick, which indicates long synchronous code execution. View clusters of multiple processes When multiple Node.js processes on the same server report to the same New Relic application, these charts will show aggregated data. This is because each worker process in a cluster has its own separate Node.js runtime and collects separate data. Clusters Comments Sum across all workers The following charts show a sum across all workers: GC pause time - Total time per minute GC pause frequency GC pause time by type CPU utilization Event loop ticks per minute Average from all workers The following charts show an average from all workers: Memory usage GC pause time — average Max across all workers The following charts show max across all workers: GC pause time — max Event loop — max CPU time per tick",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.75662,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Extend</em> <em>your</em> <em>instrumentation</em>",
        "body": "In New Relic&#x27;s APM, the Node VMs page provides useful runtime data for troubleshooting performance issues and monitoring the health of <em>your</em> application. What you need Some of the charts on the Node VMs page require you to install the New Relic Native Metrics Module in addition to the <em>Node.js</em> <em>agent</em>"
      },
      "id": "603ea123e7b9d2eb022a0811"
    },
    {
      "sections": [
        "Node.js custom instrumentation",
        "Agent version requirements",
        "Instrument unsupported web frameworks",
        "Instrument unsupported message service clients",
        "Instrument unsupported datastores",
        "Instrument web transactions",
        "Custom web transaction example: Instrument three transactions in socket.io",
        "Instrument background transactions",
        "Custom background transaction example: Instrument within setInterval",
        "Expand instrumentation within transactions",
        "Important",
        "Example: Instrument a callback",
        "Example: Instrument asynchronous functions using callbacks",
        "Example: Instrument asynchronous functions using promises",
        "Example: Instrument async functions",
        "Example: Instrument a synchronous function"
      ],
      "title": "Node.js custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Extend your instrumentation"
      ],
      "external_id": "284f422639e1af4a65c26edd4d3f5bc53106e51a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/extend-your-instrumentation/nodejs-custom-instrumentation/",
      "published_at": "2021-06-02T15:04:34Z",
      "updated_at": "2021-03-16T14:59:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic for Node.js automatically instruments most standard web requests, but sometimes you want expanded instrumentation. With the agent's custom instrumentation API, you can create instrumentation for otherwise unsupported web frameworks, datastores, and message service clients. The Node.js agent's custom instrumentation API also allows you to: Create web transactions (useful for things like web sockets, where transactions can't be automatically created). Create non-web background transactions (useful for recording background jobs). Target specific sections of your code for deeper analysis. Agent version requirements The custom instrumentation methods in this document are available as of Node.js agent version 2.0.0. For information on instrumentation using the custom instrumentation API v1.x, see the documentation for legacy Node.js custom instrumentation. Instrument unsupported web frameworks Beginning with Node.js agent version 2.0.0, New Relic provides an API to expand instrumentation for additional web frameworks. For more information, including a tutorial, see the documentation for Node.js web framework instrumentation on GitHub. Instrument unsupported message service clients Beginning with Node.js agent version 2.0.0, New Relic provides an API to expand instrumentation for additional message service libraries. For more information, including a tutorial, see the documentation for Node.js message service client instrumentation on GitHub. Instrument unsupported datastores Beginning with Node.js agent version 2.0.0, New Relic provides an API to expand instrumentation for additional datastore libraries. For more information, including a tutorial, see the documentation for Node.js datastore instrumentation on GitHub. Instrument web transactions In order to create custom web transactions, call startWebTransaction to start the transaction. To end the transaction, use any of these options: Ending the transaction Comments Promise If the handler passed to startWebTransaction returns a promise, the agent will end the transaction when the returned promise resolves or rejects. Manual If you call getTransaction in the context of the new transaction, this notifies the agent that the transaction will be handled manually. If getTransaction is called in the handler, then you must end the transaction by calling transaction.end(). Synchronous If neither of these options are fulfilled, the transaction will be ended when the handler returns synchronously. Custom web transaction example: Instrument three transactions in socket.io This example instruments a /websocket/ping transaction, a /websocket/update transaction, and a /websocket/new-message transaction within socket.io. The /ping example is synchronous, while the /new-message and /update examples are asynchronous. var nr = require('newrelic') var app = require('http').createServer() var io = require('socket.io')(app) io.on('connection', function (socket) { socket.on('ping', function (data) { nr.startWebTransaction('/websocket/ping', function transactionHandler() { // Ended automatically after synchronously returning socket.emit('pong') }) }) socket.on('update', function (data) { nr.startWebTransaction('/websocket/update', function transactionHandler() { // Using API#getTransaction var transaction = nr.getTransaction() updateChatWindow(data, function transactionHandler() { socket.emit('update-done') transaction.end() }) }) }) socket.on('new-message', function (data) { nr.startWebTransaction('/websocket/new-message', function transactionHandler() { // Returning a promise return new Promise(function (resolve, reject) { addMessageToChat(data, function () { socket.emit('message-received') resolve() }) }) }) }) }) Copy This method only gives basic timing data for the transaction created. To create more intricate timing data and transaction naming for a particular framework, see the Node.js API documentation and the related tutorial on GitHub. Instrument background transactions You can use custom transactions to instrument non-web transactions (background tasks); for example: Periodic jobs within your app Work that continues after a request completes To instrument background tasks, call startBackgroundTransaction in your handler to start a background transaction. To end the transaction, use any of these options: Ending the transaction Comments Promise If the handler passed to startBackgroundTransaction returns a promise, the agent will end the transaction when the returned promise resolves or rejects. Manual If you call getTransaction in the context of the new transaction, this notifies the agent that the transaction will be handled manually. If getTransaction is called in the handler, then you must end the transaction by calling transaction.end(). Synchronous If neither of these options are fulfilled, the transaction will be ended when the handler returns synchronously. Custom background transaction example: Instrument within setInterval This example instruments update:cache within setInterval: var nr = require('newrelic') var redis = require('redis').createClient() // Using API#getTransaction to manage ending the transaction setInterval(function () { nr.startBackgroundTransaction('update:cache', function transactionHandler() { var newValue = someDataGenerator() var transaction = nr.getTransaction() redis.set('some:cache:key', newValue, function () { transaction.end() }) }) }, 30000) // Every 30s //Using a promise to manage ending the transaction setInterval(function () { nr.startBackgroundTransaction('flush:cache', function transactionHandler() { return new Promise(function(resolve, reject) { flushCache(redis, function afterFlush(err) { if (err) { return reject(err) } resolve() }) }) }) }, 60*60*1000) Copy Expand instrumentation within transactions You can create instrumentation using the instrumentation registration methods on the API. Writing instrumentation using the instrumentation API allows you to specify metrics and naming in greater detail by \"monkey patching\" methods (replacing functions) on relevant objects. Other options can offer visibility into web transactions that are already instrumented, or gain insight into databases and other in-transaction work that is not automatically instrumented. To do this, wrap your callbacks in custom tracers. Custom tracers create and collect specific metrics for an additional segment within an existing transaction, such as a particular function or a database call. To instrument individual callbacks, call startSegment() inside the callback, and move the main callback logic to the handler function. To instrument a function that is called inside an asynchronous function, wrap both the target function and its parent asynchronous function with startSegment(). Important These examples must be placed in code that is running under a transaction. The origin of the transaction, custom or automatically created, does not matter. Example: Instrument a callback This example tracks a single callback: // Wrap the method in a segment. nr.startSegment('db:createObject', true, function(cb) { // This is recorded as the `db:createObject` segment. db.createObject(cb) }, function(err, result) { // This is recorded as the callback to the `db:createObject` segment. if (util.handleError(err, res)) { return } res.write(JSON.stringify(result.rows[0].id)) res.write('\\n') res.end() }) Copy Example: Instrument asynchronous functions using callbacks This example tracks both pg.connect and client.query. This is because client.query is called by an asynchronous parent function (pg.connect). Otherwise, you would not get any data from client.query. This allows startSegment() to propagate the active transaction across those asynchronous boundaries. nr.startSegment('pg:connect', true, function(cb) { pg.connect(config.db_string, cb) }, function(err, client, done) { if (util.handleError(err, '500', res)) { return done() } nr.startSegment('pg:query', true, function(cb) { client.query('SELECT count(*) FROM test_count'), cb) }, function(err, result) { if (util.handleError(err, '500', res)) { return done() } res.write(result.rows[0].count) res.write('\\n') }) }) Copy Example: Instrument asynchronous functions using promises This example is the same as the callback one, but for interacting with a promise-based API. For promises, simply return the promise and call then after startSegment to continue your execution. nr.startSegment('pg:connect', true, function() { // This `pg:connect` segment will time until the returned promise // either resolves or rejects. return pg.connect(config.db_string) }).then(function(client) { // The transaction context is propagated into following promises. return nr.startSegment('pg:query', true, function() { return client.query('SELECT count(*) FROM test_count')) }).then(function(result) { res.write(result.rows[0].count) res.write('\\n') res.end() }, function(err) { // Error from querying. util.handleError(err, '500', res) }).finally(function() { return client.release() }) }, function(err) { // Error from connecting. util.handleError(err, '500', res) }) Copy Example: Instrument async functions This example shows how to instrument code using async/await to control asynchronous work. This requires using Node 8 or higher, as well as the New Relic for Node.js agent v2.3.0 or higher. try { const client = await nr.startSegment('pg:connect', true, async () => { // Async functions simply return promises, so this example is // very similar to the promise one. return await pg.connect(config.db_string) }) // The transaction context is propagated into the code following `await`. try { const result = await nr.startSegment('pg:query', true, async () => { return await client.query('SELECT count(*) FROM test_count')) }) res.write(result.rows[0].count) res.write('\\n') res.end() } catch(err) { // Error from querying. util.handleError(err, '500', res) } finally { await client.release() } } catch(err) { // Error from connecting. util.handleError(err, '500', res) } Copy Example: Instrument a synchronous function This example shows how startSegment can be used to record a synchronous function that is responsible for assigning its return value to a variable. var result = nr.startSegment('calculateTotal', true, function() { return calculateTotal(outerVar1, outerVar2) }) Copy Important The startSegment function is available of the Node Agent 3.3.0 release.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.75644,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Node.js custom <em>instrumentation</em>",
        "sections": "Node.js custom <em>instrumentation</em>",
        "tags": "<em>Extend</em> <em>your</em> <em>instrumentation</em>",
        "body": " analysis. <em>Agent</em> version requirements The custom <em>instrumentation</em> methods in this document are available as of <em>Node.js</em> <em>agent</em> version 2.0.0. For information on <em>instrumentation</em> using the custom <em>instrumentation</em> API v1.x, see the documentation for legacy <em>Node.js</em> custom <em>instrumentation</em>. <em>Instrument</em> unsupported web"
      },
      "id": "603ec39964441f02dc4e8882"
    },
    {
      "sections": [
        "Apollo Server plugin and Node.js",
        "Compatibility",
        "GitHub documentation"
      ],
      "title": "Apollo Server plugin and Node.js",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Extend your instrumentation"
      ],
      "external_id": "823dc0152fa10c89d0379c58ab3e8599726e56a9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/extend-your-instrumentation/apollo-server-plugin-nodejs/",
      "published_at": "2021-06-02T15:16:26Z",
      "updated_at": "2021-03-13T07:26:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Apollo Server plugin instruments your Apollo Server applications to give visibility into your GraphQL payloads. This helps you uncover and diagnose the cause of your slow GraphQL queries. Our plugin records overall timings for queries and uses distributed tracing to uncover the route problem. Use this instrumentation to see if the problem arises from resolving a piece of requested data or if it stems from work done on other services or databases. Compatibility The New Relic plugin works with the following Apollo Server modules: apollo-server apollo-server-express apollo-server-hapi apollo-server-koa apollo-server-fastify Because fastify is not fully instrumented in the Node.js agent, transactions are prefixed with WebTransaction\\Nodejs. Other plugins may work, depending on their underlying implementation, but they have not been verified. GitHub documentation For detailed information about installation, configuration, transaction details, metrics, segments, errors, testing, troubleshooting, and more, see New Relic's Apollo Server plugin documentation on GitHub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.16946,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Extend</em> <em>your</em> <em>instrumentation</em>",
        "body": "-hapi apollo-server-koa apollo-server-fastify Because fastify is not fully instrumented in the <em>Node.js</em> <em>agent</em>, transactions are prefixed with WebTransaction\\<em>Nodejs</em>. Other plugins may work, depending on their underlying implementation, but they have not been verified. GitHub documentation For detailed"
      },
      "id": "6043cd9528ccbceaf72c60be"
    }
  ],
  "/docs/agents/nodejs-agent/extend-your-instrumentation/message-queues": [
    {
      "sections": [
        "Node.js VMs statistics page",
        "What you need",
        "View Node VM statistics",
        "Analyze performance issues",
        "GC pause time",
        "GC pause frequency",
        "GC pause time by type",
        "Memory usage",
        "CPU utilization",
        "Event loop — ticks per minute",
        "Event loop — max CPU time per tick",
        "View clusters of multiple processes"
      ],
      "title": "Node.js VMs statistics page",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Extend your instrumentation"
      ],
      "external_id": "b1c5ecf7ca24b63c50ed1021f020d62e513f8455",
      "image": "https://docs.newrelic.com/static/b0ab0aacf7b062b687be29a94ff96a43/8c557/vm-dashboard.png",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/extend-your-instrumentation/nodejs-vms-statistics-page/",
      "published_at": "2021-06-02T20:25:06Z",
      "updated_at": "2021-03-16T15:01:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In New Relic's APM, the Node VMs page provides useful runtime data for troubleshooting performance issues and monitoring the health of your application. What you need Some of the charts on the Node VMs page require you to install the New Relic Native Metrics Module in addition to the Node.js agent. For installation instructions, see Node VM Measurements. View Node VM statistics one.newrelic.com > APM > (select an app) > Node VMs: When multiple servers are reporting to the same application, the page breaks charts down by server. You can view data for an individual server and obtain additional details by selecting a server from the Servers filter at the top of the page. To correlate spikes or upward trends in any of these measurements with specific transactions: Go to one.newrelic.com > APM > (select an app) > Node VMs. Select the time period by clicking and dragging within any of the charts. Navigate to the Transactions page or any other page. As you go to other pages, the time picker selection will remain the same. Analyze performance issues Here is a summary of the data available on individual Node VM charts. By using all of the charts together, you can troubleshoot performance issues. For example: When the application starts using more objects, memory usage will increase, and garbage collection (GC) will run more frequently. CPU utilization will increase due to time spent in GC. Abnormally long synchronous code execution can increase CPU utilization. This will show spikes in the Event loop max CPU time per tick chart. GC pause time The amount of time spent in garbage collection. For a single server, the chart shows average, max, and total time per minute. For multiple servers, the chart shows total time grouped by server. Typically, spikes in GC time or frequency indicate a potential issue. GC pause frequency The number of times GC runs were executed per minute. For a single server, the chart is broken down by the type of GC. For multiple servers, the chart shows total number of GC calls (all types combined) grouped by server. GC pause time by type This chart shows the total time spent in garbage collection per minute, broken down by GC type. It is only shown when viewing a single server. You might see the following types depending on your version of Node.js and app activity: Value Description Scavenge The most common garbage collection method. Node.js will typically trigger one of these every time the VM is idle. MarkSweepCompact The heaviest type of garbage collection V8 may do. If you see many of these happening you will need to either keep fewer objects around in your process or increase V8's heap limit. IncrementalMarking A phased garbage collection that interleaves collection with application logic to reduce the amount of time the application is paused. Only in Node.js v6 or higher. ProcessWeakCallbacks After a garbage collection occurs, V8 will call any weak reference callbacks registered for objects that have been freed. This measurement is from the start of the first weak callback to the end of the last for a given garbage collection. Only in Node.js v6 or higher. Memory usage This chart shows the amount of memory consumed by the Node.js process. For multiple servers, the chart shows total memory grouped by server. For a single server, the chart is segmented by the following types of memory: Value Description Non-heap The memory allocated to data outside V8's heap (for example, buffers, sockets). V8 heap (used) The amount of memory being used by V8 (for example, JavaScript objects). V8 heap (free) The amount of memory set aside by V8 for memory pooling. This memory isn't being actively used, but is set aside for V8 to freely allocate more as needed. CPU utilization This chart shows the CPU utilization of the Node process. For multiple servers, the chart shows total CPU utilization grouped by server. For a single server, the chart is segmented by the following: Value Description User The time spent executing the user code, divided by wall-clock time. System The time spent in the system kernel on behalf of the Node process, divided by wall-clock time. Event loop — ticks per minute This chart shows the number of event loop ticks per minute. A tick is a single turn of the event loop, in which functions that are ready to be executed are run. As a part of each event loop turn, Node waits for pending I/O to complete. Once any I/O events are received, the event loop executes callbacks associated with it. Therefore, the number of ticks per minute corresponds to how frequently I/O events occur. Event loop — max CPU time per tick This chart shows the maximum time spent in a single tick per minute. This is useful with detecting an abnormally long event loop tick, which indicates long synchronous code execution. View clusters of multiple processes When multiple Node.js processes on the same server report to the same New Relic application, these charts will show aggregated data. This is because each worker process in a cluster has its own separate Node.js runtime and collects separate data. Clusters Comments Sum across all workers The following charts show a sum across all workers: GC pause time - Total time per minute GC pause frequency GC pause time by type CPU utilization Event loop ticks per minute Average from all workers The following charts show an average from all workers: Memory usage GC pause time — average Max across all workers The following charts show max across all workers: GC pause time — max Event loop — max CPU time per tick",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.75662,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Extend</em> <em>your</em> <em>instrumentation</em>",
        "body": "In New Relic&#x27;s APM, the Node VMs page provides useful runtime data for troubleshooting performance issues and monitoring the health of <em>your</em> application. What you need Some of the charts on the Node VMs page require you to install the New Relic Native Metrics Module in addition to the <em>Node.js</em> <em>agent</em>"
      },
      "id": "603ea123e7b9d2eb022a0811"
    },
    {
      "sections": [
        "Node.js custom instrumentation",
        "Agent version requirements",
        "Instrument unsupported web frameworks",
        "Instrument unsupported message service clients",
        "Instrument unsupported datastores",
        "Instrument web transactions",
        "Custom web transaction example: Instrument three transactions in socket.io",
        "Instrument background transactions",
        "Custom background transaction example: Instrument within setInterval",
        "Expand instrumentation within transactions",
        "Important",
        "Example: Instrument a callback",
        "Example: Instrument asynchronous functions using callbacks",
        "Example: Instrument asynchronous functions using promises",
        "Example: Instrument async functions",
        "Example: Instrument a synchronous function"
      ],
      "title": "Node.js custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Extend your instrumentation"
      ],
      "external_id": "284f422639e1af4a65c26edd4d3f5bc53106e51a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/extend-your-instrumentation/nodejs-custom-instrumentation/",
      "published_at": "2021-06-02T15:04:34Z",
      "updated_at": "2021-03-16T14:59:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic for Node.js automatically instruments most standard web requests, but sometimes you want expanded instrumentation. With the agent's custom instrumentation API, you can create instrumentation for otherwise unsupported web frameworks, datastores, and message service clients. The Node.js agent's custom instrumentation API also allows you to: Create web transactions (useful for things like web sockets, where transactions can't be automatically created). Create non-web background transactions (useful for recording background jobs). Target specific sections of your code for deeper analysis. Agent version requirements The custom instrumentation methods in this document are available as of Node.js agent version 2.0.0. For information on instrumentation using the custom instrumentation API v1.x, see the documentation for legacy Node.js custom instrumentation. Instrument unsupported web frameworks Beginning with Node.js agent version 2.0.0, New Relic provides an API to expand instrumentation for additional web frameworks. For more information, including a tutorial, see the documentation for Node.js web framework instrumentation on GitHub. Instrument unsupported message service clients Beginning with Node.js agent version 2.0.0, New Relic provides an API to expand instrumentation for additional message service libraries. For more information, including a tutorial, see the documentation for Node.js message service client instrumentation on GitHub. Instrument unsupported datastores Beginning with Node.js agent version 2.0.0, New Relic provides an API to expand instrumentation for additional datastore libraries. For more information, including a tutorial, see the documentation for Node.js datastore instrumentation on GitHub. Instrument web transactions In order to create custom web transactions, call startWebTransaction to start the transaction. To end the transaction, use any of these options: Ending the transaction Comments Promise If the handler passed to startWebTransaction returns a promise, the agent will end the transaction when the returned promise resolves or rejects. Manual If you call getTransaction in the context of the new transaction, this notifies the agent that the transaction will be handled manually. If getTransaction is called in the handler, then you must end the transaction by calling transaction.end(). Synchronous If neither of these options are fulfilled, the transaction will be ended when the handler returns synchronously. Custom web transaction example: Instrument three transactions in socket.io This example instruments a /websocket/ping transaction, a /websocket/update transaction, and a /websocket/new-message transaction within socket.io. The /ping example is synchronous, while the /new-message and /update examples are asynchronous. var nr = require('newrelic') var app = require('http').createServer() var io = require('socket.io')(app) io.on('connection', function (socket) { socket.on('ping', function (data) { nr.startWebTransaction('/websocket/ping', function transactionHandler() { // Ended automatically after synchronously returning socket.emit('pong') }) }) socket.on('update', function (data) { nr.startWebTransaction('/websocket/update', function transactionHandler() { // Using API#getTransaction var transaction = nr.getTransaction() updateChatWindow(data, function transactionHandler() { socket.emit('update-done') transaction.end() }) }) }) socket.on('new-message', function (data) { nr.startWebTransaction('/websocket/new-message', function transactionHandler() { // Returning a promise return new Promise(function (resolve, reject) { addMessageToChat(data, function () { socket.emit('message-received') resolve() }) }) }) }) }) Copy This method only gives basic timing data for the transaction created. To create more intricate timing data and transaction naming for a particular framework, see the Node.js API documentation and the related tutorial on GitHub. Instrument background transactions You can use custom transactions to instrument non-web transactions (background tasks); for example: Periodic jobs within your app Work that continues after a request completes To instrument background tasks, call startBackgroundTransaction in your handler to start a background transaction. To end the transaction, use any of these options: Ending the transaction Comments Promise If the handler passed to startBackgroundTransaction returns a promise, the agent will end the transaction when the returned promise resolves or rejects. Manual If you call getTransaction in the context of the new transaction, this notifies the agent that the transaction will be handled manually. If getTransaction is called in the handler, then you must end the transaction by calling transaction.end(). Synchronous If neither of these options are fulfilled, the transaction will be ended when the handler returns synchronously. Custom background transaction example: Instrument within setInterval This example instruments update:cache within setInterval: var nr = require('newrelic') var redis = require('redis').createClient() // Using API#getTransaction to manage ending the transaction setInterval(function () { nr.startBackgroundTransaction('update:cache', function transactionHandler() { var newValue = someDataGenerator() var transaction = nr.getTransaction() redis.set('some:cache:key', newValue, function () { transaction.end() }) }) }, 30000) // Every 30s //Using a promise to manage ending the transaction setInterval(function () { nr.startBackgroundTransaction('flush:cache', function transactionHandler() { return new Promise(function(resolve, reject) { flushCache(redis, function afterFlush(err) { if (err) { return reject(err) } resolve() }) }) }) }, 60*60*1000) Copy Expand instrumentation within transactions You can create instrumentation using the instrumentation registration methods on the API. Writing instrumentation using the instrumentation API allows you to specify metrics and naming in greater detail by \"monkey patching\" methods (replacing functions) on relevant objects. Other options can offer visibility into web transactions that are already instrumented, or gain insight into databases and other in-transaction work that is not automatically instrumented. To do this, wrap your callbacks in custom tracers. Custom tracers create and collect specific metrics for an additional segment within an existing transaction, such as a particular function or a database call. To instrument individual callbacks, call startSegment() inside the callback, and move the main callback logic to the handler function. To instrument a function that is called inside an asynchronous function, wrap both the target function and its parent asynchronous function with startSegment(). Important These examples must be placed in code that is running under a transaction. The origin of the transaction, custom or automatically created, does not matter. Example: Instrument a callback This example tracks a single callback: // Wrap the method in a segment. nr.startSegment('db:createObject', true, function(cb) { // This is recorded as the `db:createObject` segment. db.createObject(cb) }, function(err, result) { // This is recorded as the callback to the `db:createObject` segment. if (util.handleError(err, res)) { return } res.write(JSON.stringify(result.rows[0].id)) res.write('\\n') res.end() }) Copy Example: Instrument asynchronous functions using callbacks This example tracks both pg.connect and client.query. This is because client.query is called by an asynchronous parent function (pg.connect). Otherwise, you would not get any data from client.query. This allows startSegment() to propagate the active transaction across those asynchronous boundaries. nr.startSegment('pg:connect', true, function(cb) { pg.connect(config.db_string, cb) }, function(err, client, done) { if (util.handleError(err, '500', res)) { return done() } nr.startSegment('pg:query', true, function(cb) { client.query('SELECT count(*) FROM test_count'), cb) }, function(err, result) { if (util.handleError(err, '500', res)) { return done() } res.write(result.rows[0].count) res.write('\\n') }) }) Copy Example: Instrument asynchronous functions using promises This example is the same as the callback one, but for interacting with a promise-based API. For promises, simply return the promise and call then after startSegment to continue your execution. nr.startSegment('pg:connect', true, function() { // This `pg:connect` segment will time until the returned promise // either resolves or rejects. return pg.connect(config.db_string) }).then(function(client) { // The transaction context is propagated into following promises. return nr.startSegment('pg:query', true, function() { return client.query('SELECT count(*) FROM test_count')) }).then(function(result) { res.write(result.rows[0].count) res.write('\\n') res.end() }, function(err) { // Error from querying. util.handleError(err, '500', res) }).finally(function() { return client.release() }) }, function(err) { // Error from connecting. util.handleError(err, '500', res) }) Copy Example: Instrument async functions This example shows how to instrument code using async/await to control asynchronous work. This requires using Node 8 or higher, as well as the New Relic for Node.js agent v2.3.0 or higher. try { const client = await nr.startSegment('pg:connect', true, async () => { // Async functions simply return promises, so this example is // very similar to the promise one. return await pg.connect(config.db_string) }) // The transaction context is propagated into the code following `await`. try { const result = await nr.startSegment('pg:query', true, async () => { return await client.query('SELECT count(*) FROM test_count')) }) res.write(result.rows[0].count) res.write('\\n') res.end() } catch(err) { // Error from querying. util.handleError(err, '500', res) } finally { await client.release() } } catch(err) { // Error from connecting. util.handleError(err, '500', res) } Copy Example: Instrument a synchronous function This example shows how startSegment can be used to record a synchronous function that is responsible for assigning its return value to a variable. var result = nr.startSegment('calculateTotal', true, function() { return calculateTotal(outerVar1, outerVar2) }) Copy Important The startSegment function is available of the Node Agent 3.3.0 release.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.75642,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Node.js custom <em>instrumentation</em>",
        "sections": "Node.js custom <em>instrumentation</em>",
        "tags": "<em>Extend</em> <em>your</em> <em>instrumentation</em>",
        "body": " analysis. <em>Agent</em> version requirements The custom <em>instrumentation</em> methods in this document are available as of <em>Node.js</em> <em>agent</em> version 2.0.0. For information on <em>instrumentation</em> using the custom <em>instrumentation</em> API v1.x, see the documentation for legacy <em>Node.js</em> custom <em>instrumentation</em>. <em>Instrument</em> unsupported web"
      },
      "id": "603ec39964441f02dc4e8882"
    },
    {
      "sections": [
        "Browser monitoring and the Node.js agent",
        "Insert the JavaScript header",
        "Framework examples",
        "Express and jade",
        "Express and Swig",
        "Hapi.js and handlebars",
        "Disable header generation",
        "Caution"
      ],
      "title": "Browser monitoring and the Node.js agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Extend your instrumentation"
      ],
      "external_id": "8b8cba2d5ce2acdc55df2621d850329cf4796bbd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/extend-your-instrumentation/browser-monitoring-nodejs-agent/",
      "published_at": "2021-06-02T15:16:26Z",
      "updated_at": "2021-03-16T09:02:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the Node.js agent, you can add browser instrumentation to your web pages. To use browser monitoring with your Node.js agent, ensure you have the latest release of the Node.js agent. To enable browser monitoring in the user interface, follow the procedures to install the browser agent. Then follow the procedures in this section to set up the Node.js agent. Insert the JavaScript header Instrumentation for the Node.js agent can continue beyond your application into end users' browsers. The newrelic module can generate script headers which, when inserted into your HTML templates, will capture the end users' page load times. The headers must be manually injected, but no extra configuration is necessary. At the beginning of your html page's head tag, insert the results of newrelic.getBrowserTimingHeader() after any CHARSET meta tags. Exception: For maximum Internet Explorer compatibility, insert the results of newrelic.getBrowserTimingHeader() after any X-UA-COMPATIBLE HTTP-EQUIV meta tags. Call the header once for every request. Do not cache the header. Generating headers is fast, and it does not require your application to make extra requests to New Relic. Framework examples Here are some examples of how to set up browser monitoring with different frameworks and templates. Express and jade This example uses Express, a web application framework, and jade, a template module. Although the specifics are different with other frameworks, this general approach should work in most cases. The simplest way to insert browser timing headings is to pass the newrelic module into your template, and then call newrelic.getBrowsertimingHeader() from within the template. In your app.js: var newrelic = require('newrelic'); var app = require('express')(); // in express, this lets you call newrelic from within a template app.locals.newrelic = newrelic; app.get('/user/:id', function (req, res) { res.render('user'); }); app.listen(process.env.PORT); Copy In your layout.jade: doctype html html head != newrelic.getBrowserTimingHeader() title= title link(rel='stylesheet', href='stylesheets/style.css') body block content Copy Express and Swig This example uses Express with Swig. In your app.js: var newrelic = require('newrelic'); var http = require('http') var path = require('path') var swig = require('swig') var app = require('express')(); app.locals.newrelic = newrelic; //taken from http://paularmstrong.github.io/swig/docs/#express app.engine('html', swig.renderFile); app.set('view engine', 'html'); app.set('views', __dirname + '/views'); app.get('/user/:id', function (req, res) { res.render('user'); }); app.listen(process.env.PORT); Copy In your views/user.html: <!DOCTYPE html> <html> <head> {{ newrelic.getBrowserTimingHeader() }} <title>Hello</title> </head> <body> <h1>Hello World</h1> </body> </html> Copy Hapi.js and handlebars This example uses hapi.js and handlebars. Other similar templating languages typically require triple brackets; for example, using mustache with hogan-express. This helps prevent escaping of the script content. Using hapi, in your app.js: var newrelic = require('newrelic'); var Hapi = require('hapi'); var server = new Hapi.Server(parseInt(PORT), '0.0.0.0', { views: { engines : {html: 'handlebars' }, path : __dirname + '/templates' } }); function homepage(request, reply) { var context = { // pass in the header each request nreum : newrelic.getBrowserTimingHeader(), content : ... }; reply.view('homepage', context); }; server.route({ method : 'GET', path : '/', handler : homepage }); server.start(); Copy In your templates/homepage.html: <!DOCTYPE html> <html> <head> {{{ nreum }}} <title>Hello</title> </head> <body> {{ content }} </body> </html> Copy Disable header generation By default, calls to newrelic.getBrowserTimingHeader() should return valid headers. To disable header generation without removing your template code: In your newrelic.js file, add: browser_monitoring : { enable : false } Copy You can also set the environment variable NEW_RELIC_BROWSER_MONITOR_ENABLE=false. Caution Always leave ssl between the agent and the New Relic collector when using browser monitoring. You can safely leave the API calls in place even if you are not using browser monitoring or the newrelic module. If browser monitoring is disabled, or if there is an error so that working headers cannot be generated, the newrelic module generates an innocuous HTML comment. If you disable the newrelic module completely, no content will be generated.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.71094,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Browser monitoring and the Node.js <em>agent</em>",
        "sections": "Browser monitoring and the Node.js <em>agent</em>",
        "tags": "<em>Extend</em> <em>your</em> <em>instrumentation</em>",
        "body": "With the <em>Node.js</em> <em>agent</em>, you can add browser <em>instrumentation</em> to <em>your</em> web pages. To use browser monitoring with <em>your</em> <em>Node.js</em> <em>agent</em>, ensure you have the latest release of the <em>Node.js</em> <em>agent</em>. To enable browser monitoring in the user interface, follow the procedures to install the browser <em>agent</em>"
      },
      "id": "603e8376e7b9d2b7472a07f7"
    }
  ],
  "/docs/agents/nodejs-agent/extend-your-instrumentation/nodejs-custom-instrumentation": [
    {
      "sections": [
        "Node.js VMs statistics page",
        "What you need",
        "View Node VM statistics",
        "Analyze performance issues",
        "GC pause time",
        "GC pause frequency",
        "GC pause time by type",
        "Memory usage",
        "CPU utilization",
        "Event loop — ticks per minute",
        "Event loop — max CPU time per tick",
        "View clusters of multiple processes"
      ],
      "title": "Node.js VMs statistics page",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Extend your instrumentation"
      ],
      "external_id": "b1c5ecf7ca24b63c50ed1021f020d62e513f8455",
      "image": "https://docs.newrelic.com/static/b0ab0aacf7b062b687be29a94ff96a43/8c557/vm-dashboard.png",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/extend-your-instrumentation/nodejs-vms-statistics-page/",
      "published_at": "2021-06-02T20:25:06Z",
      "updated_at": "2021-03-16T15:01:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In New Relic's APM, the Node VMs page provides useful runtime data for troubleshooting performance issues and monitoring the health of your application. What you need Some of the charts on the Node VMs page require you to install the New Relic Native Metrics Module in addition to the Node.js agent. For installation instructions, see Node VM Measurements. View Node VM statistics one.newrelic.com > APM > (select an app) > Node VMs: When multiple servers are reporting to the same application, the page breaks charts down by server. You can view data for an individual server and obtain additional details by selecting a server from the Servers filter at the top of the page. To correlate spikes or upward trends in any of these measurements with specific transactions: Go to one.newrelic.com > APM > (select an app) > Node VMs. Select the time period by clicking and dragging within any of the charts. Navigate to the Transactions page or any other page. As you go to other pages, the time picker selection will remain the same. Analyze performance issues Here is a summary of the data available on individual Node VM charts. By using all of the charts together, you can troubleshoot performance issues. For example: When the application starts using more objects, memory usage will increase, and garbage collection (GC) will run more frequently. CPU utilization will increase due to time spent in GC. Abnormally long synchronous code execution can increase CPU utilization. This will show spikes in the Event loop max CPU time per tick chart. GC pause time The amount of time spent in garbage collection. For a single server, the chart shows average, max, and total time per minute. For multiple servers, the chart shows total time grouped by server. Typically, spikes in GC time or frequency indicate a potential issue. GC pause frequency The number of times GC runs were executed per minute. For a single server, the chart is broken down by the type of GC. For multiple servers, the chart shows total number of GC calls (all types combined) grouped by server. GC pause time by type This chart shows the total time spent in garbage collection per minute, broken down by GC type. It is only shown when viewing a single server. You might see the following types depending on your version of Node.js and app activity: Value Description Scavenge The most common garbage collection method. Node.js will typically trigger one of these every time the VM is idle. MarkSweepCompact The heaviest type of garbage collection V8 may do. If you see many of these happening you will need to either keep fewer objects around in your process or increase V8's heap limit. IncrementalMarking A phased garbage collection that interleaves collection with application logic to reduce the amount of time the application is paused. Only in Node.js v6 or higher. ProcessWeakCallbacks After a garbage collection occurs, V8 will call any weak reference callbacks registered for objects that have been freed. This measurement is from the start of the first weak callback to the end of the last for a given garbage collection. Only in Node.js v6 or higher. Memory usage This chart shows the amount of memory consumed by the Node.js process. For multiple servers, the chart shows total memory grouped by server. For a single server, the chart is segmented by the following types of memory: Value Description Non-heap The memory allocated to data outside V8's heap (for example, buffers, sockets). V8 heap (used) The amount of memory being used by V8 (for example, JavaScript objects). V8 heap (free) The amount of memory set aside by V8 for memory pooling. This memory isn't being actively used, but is set aside for V8 to freely allocate more as needed. CPU utilization This chart shows the CPU utilization of the Node process. For multiple servers, the chart shows total CPU utilization grouped by server. For a single server, the chart is segmented by the following: Value Description User The time spent executing the user code, divided by wall-clock time. System The time spent in the system kernel on behalf of the Node process, divided by wall-clock time. Event loop — ticks per minute This chart shows the number of event loop ticks per minute. A tick is a single turn of the event loop, in which functions that are ready to be executed are run. As a part of each event loop turn, Node waits for pending I/O to complete. Once any I/O events are received, the event loop executes callbacks associated with it. Therefore, the number of ticks per minute corresponds to how frequently I/O events occur. Event loop — max CPU time per tick This chart shows the maximum time spent in a single tick per minute. This is useful with detecting an abnormally long event loop tick, which indicates long synchronous code execution. View clusters of multiple processes When multiple Node.js processes on the same server report to the same New Relic application, these charts will show aggregated data. This is because each worker process in a cluster has its own separate Node.js runtime and collects separate data. Clusters Comments Sum across all workers The following charts show a sum across all workers: GC pause time - Total time per minute GC pause frequency GC pause time by type CPU utilization Event loop ticks per minute Average from all workers The following charts show an average from all workers: Memory usage GC pause time — average Max across all workers The following charts show max across all workers: GC pause time — max Event loop — max CPU time per tick",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.75662,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Extend</em> <em>your</em> <em>instrumentation</em>",
        "body": "In New Relic&#x27;s APM, the Node VMs page provides useful runtime data for troubleshooting performance issues and monitoring the health of <em>your</em> application. What you need Some of the charts on the Node VMs page require you to install the New Relic Native Metrics Module in addition to the <em>Node.js</em> <em>agent</em>"
      },
      "id": "603ea123e7b9d2eb022a0811"
    },
    {
      "sections": [
        "Browser monitoring and the Node.js agent",
        "Insert the JavaScript header",
        "Framework examples",
        "Express and jade",
        "Express and Swig",
        "Hapi.js and handlebars",
        "Disable header generation",
        "Caution"
      ],
      "title": "Browser monitoring and the Node.js agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Extend your instrumentation"
      ],
      "external_id": "8b8cba2d5ce2acdc55df2621d850329cf4796bbd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/extend-your-instrumentation/browser-monitoring-nodejs-agent/",
      "published_at": "2021-06-02T15:16:26Z",
      "updated_at": "2021-03-16T09:02:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the Node.js agent, you can add browser instrumentation to your web pages. To use browser monitoring with your Node.js agent, ensure you have the latest release of the Node.js agent. To enable browser monitoring in the user interface, follow the procedures to install the browser agent. Then follow the procedures in this section to set up the Node.js agent. Insert the JavaScript header Instrumentation for the Node.js agent can continue beyond your application into end users' browsers. The newrelic module can generate script headers which, when inserted into your HTML templates, will capture the end users' page load times. The headers must be manually injected, but no extra configuration is necessary. At the beginning of your html page's head tag, insert the results of newrelic.getBrowserTimingHeader() after any CHARSET meta tags. Exception: For maximum Internet Explorer compatibility, insert the results of newrelic.getBrowserTimingHeader() after any X-UA-COMPATIBLE HTTP-EQUIV meta tags. Call the header once for every request. Do not cache the header. Generating headers is fast, and it does not require your application to make extra requests to New Relic. Framework examples Here are some examples of how to set up browser monitoring with different frameworks and templates. Express and jade This example uses Express, a web application framework, and jade, a template module. Although the specifics are different with other frameworks, this general approach should work in most cases. The simplest way to insert browser timing headings is to pass the newrelic module into your template, and then call newrelic.getBrowsertimingHeader() from within the template. In your app.js: var newrelic = require('newrelic'); var app = require('express')(); // in express, this lets you call newrelic from within a template app.locals.newrelic = newrelic; app.get('/user/:id', function (req, res) { res.render('user'); }); app.listen(process.env.PORT); Copy In your layout.jade: doctype html html head != newrelic.getBrowserTimingHeader() title= title link(rel='stylesheet', href='stylesheets/style.css') body block content Copy Express and Swig This example uses Express with Swig. In your app.js: var newrelic = require('newrelic'); var http = require('http') var path = require('path') var swig = require('swig') var app = require('express')(); app.locals.newrelic = newrelic; //taken from http://paularmstrong.github.io/swig/docs/#express app.engine('html', swig.renderFile); app.set('view engine', 'html'); app.set('views', __dirname + '/views'); app.get('/user/:id', function (req, res) { res.render('user'); }); app.listen(process.env.PORT); Copy In your views/user.html: <!DOCTYPE html> <html> <head> {{ newrelic.getBrowserTimingHeader() }} <title>Hello</title> </head> <body> <h1>Hello World</h1> </body> </html> Copy Hapi.js and handlebars This example uses hapi.js and handlebars. Other similar templating languages typically require triple brackets; for example, using mustache with hogan-express. This helps prevent escaping of the script content. Using hapi, in your app.js: var newrelic = require('newrelic'); var Hapi = require('hapi'); var server = new Hapi.Server(parseInt(PORT), '0.0.0.0', { views: { engines : {html: 'handlebars' }, path : __dirname + '/templates' } }); function homepage(request, reply) { var context = { // pass in the header each request nreum : newrelic.getBrowserTimingHeader(), content : ... }; reply.view('homepage', context); }; server.route({ method : 'GET', path : '/', handler : homepage }); server.start(); Copy In your templates/homepage.html: <!DOCTYPE html> <html> <head> {{{ nreum }}} <title>Hello</title> </head> <body> {{ content }} </body> </html> Copy Disable header generation By default, calls to newrelic.getBrowserTimingHeader() should return valid headers. To disable header generation without removing your template code: In your newrelic.js file, add: browser_monitoring : { enable : false } Copy You can also set the environment variable NEW_RELIC_BROWSER_MONITOR_ENABLE=false. Caution Always leave ssl between the agent and the New Relic collector when using browser monitoring. You can safely leave the API calls in place even if you are not using browser monitoring or the newrelic module. If browser monitoring is disabled, or if there is an error so that working headers cannot be generated, the newrelic module generates an innocuous HTML comment. If you disable the newrelic module completely, no content will be generated.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.71094,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Browser monitoring and the Node.js <em>agent</em>",
        "sections": "Browser monitoring and the Node.js <em>agent</em>",
        "tags": "<em>Extend</em> <em>your</em> <em>instrumentation</em>",
        "body": "With the <em>Node.js</em> <em>agent</em>, you can add browser <em>instrumentation</em> to <em>your</em> web pages. To use browser monitoring with <em>your</em> <em>Node.js</em> <em>agent</em>, ensure you have the latest release of the <em>Node.js</em> <em>agent</em>. To enable browser monitoring in the user interface, follow the procedures to install the browser <em>agent</em>"
      },
      "id": "603e8376e7b9d2b7472a07f7"
    },
    {
      "sections": [
        "Apollo Server plugin and Node.js",
        "Compatibility",
        "GitHub documentation"
      ],
      "title": "Apollo Server plugin and Node.js",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Extend your instrumentation"
      ],
      "external_id": "823dc0152fa10c89d0379c58ab3e8599726e56a9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/extend-your-instrumentation/apollo-server-plugin-nodejs/",
      "published_at": "2021-06-02T15:16:26Z",
      "updated_at": "2021-03-13T07:26:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Apollo Server plugin instruments your Apollo Server applications to give visibility into your GraphQL payloads. This helps you uncover and diagnose the cause of your slow GraphQL queries. Our plugin records overall timings for queries and uses distributed tracing to uncover the route problem. Use this instrumentation to see if the problem arises from resolving a piece of requested data or if it stems from work done on other services or databases. Compatibility The New Relic plugin works with the following Apollo Server modules: apollo-server apollo-server-express apollo-server-hapi apollo-server-koa apollo-server-fastify Because fastify is not fully instrumented in the Node.js agent, transactions are prefixed with WebTransaction\\Nodejs. Other plugins may work, depending on their underlying implementation, but they have not been verified. GitHub documentation For detailed information about installation, configuration, transaction details, metrics, segments, errors, testing, troubleshooting, and more, see New Relic's Apollo Server plugin documentation on GitHub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.16946,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Extend</em> <em>your</em> <em>instrumentation</em>",
        "body": "-hapi apollo-server-koa apollo-server-fastify Because fastify is not fully instrumented in the <em>Node.js</em> <em>agent</em>, transactions are prefixed with WebTransaction\\<em>Nodejs</em>. Other plugins may work, depending on their underlying implementation, but they have not been verified. GitHub documentation For detailed"
      },
      "id": "6043cd9528ccbceaf72c60be"
    }
  ],
  "/docs/agents/nodejs-agent/extend-your-instrumentation/nodejs-custom-metrics": [
    {
      "sections": [
        "Node.js VMs statistics page",
        "What you need",
        "View Node VM statistics",
        "Analyze performance issues",
        "GC pause time",
        "GC pause frequency",
        "GC pause time by type",
        "Memory usage",
        "CPU utilization",
        "Event loop — ticks per minute",
        "Event loop — max CPU time per tick",
        "View clusters of multiple processes"
      ],
      "title": "Node.js VMs statistics page",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Extend your instrumentation"
      ],
      "external_id": "b1c5ecf7ca24b63c50ed1021f020d62e513f8455",
      "image": "https://docs.newrelic.com/static/b0ab0aacf7b062b687be29a94ff96a43/8c557/vm-dashboard.png",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/extend-your-instrumentation/nodejs-vms-statistics-page/",
      "published_at": "2021-06-02T20:25:06Z",
      "updated_at": "2021-03-16T15:01:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In New Relic's APM, the Node VMs page provides useful runtime data for troubleshooting performance issues and monitoring the health of your application. What you need Some of the charts on the Node VMs page require you to install the New Relic Native Metrics Module in addition to the Node.js agent. For installation instructions, see Node VM Measurements. View Node VM statistics one.newrelic.com > APM > (select an app) > Node VMs: When multiple servers are reporting to the same application, the page breaks charts down by server. You can view data for an individual server and obtain additional details by selecting a server from the Servers filter at the top of the page. To correlate spikes or upward trends in any of these measurements with specific transactions: Go to one.newrelic.com > APM > (select an app) > Node VMs. Select the time period by clicking and dragging within any of the charts. Navigate to the Transactions page or any other page. As you go to other pages, the time picker selection will remain the same. Analyze performance issues Here is a summary of the data available on individual Node VM charts. By using all of the charts together, you can troubleshoot performance issues. For example: When the application starts using more objects, memory usage will increase, and garbage collection (GC) will run more frequently. CPU utilization will increase due to time spent in GC. Abnormally long synchronous code execution can increase CPU utilization. This will show spikes in the Event loop max CPU time per tick chart. GC pause time The amount of time spent in garbage collection. For a single server, the chart shows average, max, and total time per minute. For multiple servers, the chart shows total time grouped by server. Typically, spikes in GC time or frequency indicate a potential issue. GC pause frequency The number of times GC runs were executed per minute. For a single server, the chart is broken down by the type of GC. For multiple servers, the chart shows total number of GC calls (all types combined) grouped by server. GC pause time by type This chart shows the total time spent in garbage collection per minute, broken down by GC type. It is only shown when viewing a single server. You might see the following types depending on your version of Node.js and app activity: Value Description Scavenge The most common garbage collection method. Node.js will typically trigger one of these every time the VM is idle. MarkSweepCompact The heaviest type of garbage collection V8 may do. If you see many of these happening you will need to either keep fewer objects around in your process or increase V8's heap limit. IncrementalMarking A phased garbage collection that interleaves collection with application logic to reduce the amount of time the application is paused. Only in Node.js v6 or higher. ProcessWeakCallbacks After a garbage collection occurs, V8 will call any weak reference callbacks registered for objects that have been freed. This measurement is from the start of the first weak callback to the end of the last for a given garbage collection. Only in Node.js v6 or higher. Memory usage This chart shows the amount of memory consumed by the Node.js process. For multiple servers, the chart shows total memory grouped by server. For a single server, the chart is segmented by the following types of memory: Value Description Non-heap The memory allocated to data outside V8's heap (for example, buffers, sockets). V8 heap (used) The amount of memory being used by V8 (for example, JavaScript objects). V8 heap (free) The amount of memory set aside by V8 for memory pooling. This memory isn't being actively used, but is set aside for V8 to freely allocate more as needed. CPU utilization This chart shows the CPU utilization of the Node process. For multiple servers, the chart shows total CPU utilization grouped by server. For a single server, the chart is segmented by the following: Value Description User The time spent executing the user code, divided by wall-clock time. System The time spent in the system kernel on behalf of the Node process, divided by wall-clock time. Event loop — ticks per minute This chart shows the number of event loop ticks per minute. A tick is a single turn of the event loop, in which functions that are ready to be executed are run. As a part of each event loop turn, Node waits for pending I/O to complete. Once any I/O events are received, the event loop executes callbacks associated with it. Therefore, the number of ticks per minute corresponds to how frequently I/O events occur. Event loop — max CPU time per tick This chart shows the maximum time spent in a single tick per minute. This is useful with detecting an abnormally long event loop tick, which indicates long synchronous code execution. View clusters of multiple processes When multiple Node.js processes on the same server report to the same New Relic application, these charts will show aggregated data. This is because each worker process in a cluster has its own separate Node.js runtime and collects separate data. Clusters Comments Sum across all workers The following charts show a sum across all workers: GC pause time - Total time per minute GC pause frequency GC pause time by type CPU utilization Event loop ticks per minute Average from all workers The following charts show an average from all workers: Memory usage GC pause time — average Max across all workers The following charts show max across all workers: GC pause time — max Event loop — max CPU time per tick",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.75662,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Extend</em> <em>your</em> <em>instrumentation</em>",
        "body": "In New Relic&#x27;s APM, the Node VMs page provides useful runtime data for troubleshooting performance issues and monitoring the health of <em>your</em> application. What you need Some of the charts on the Node VMs page require you to install the New Relic Native Metrics Module in addition to the <em>Node.js</em> <em>agent</em>"
      },
      "id": "603ea123e7b9d2eb022a0811"
    },
    {
      "sections": [
        "Node.js custom instrumentation",
        "Agent version requirements",
        "Instrument unsupported web frameworks",
        "Instrument unsupported message service clients",
        "Instrument unsupported datastores",
        "Instrument web transactions",
        "Custom web transaction example: Instrument three transactions in socket.io",
        "Instrument background transactions",
        "Custom background transaction example: Instrument within setInterval",
        "Expand instrumentation within transactions",
        "Important",
        "Example: Instrument a callback",
        "Example: Instrument asynchronous functions using callbacks",
        "Example: Instrument asynchronous functions using promises",
        "Example: Instrument async functions",
        "Example: Instrument a synchronous function"
      ],
      "title": "Node.js custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Extend your instrumentation"
      ],
      "external_id": "284f422639e1af4a65c26edd4d3f5bc53106e51a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/extend-your-instrumentation/nodejs-custom-instrumentation/",
      "published_at": "2021-06-02T15:04:34Z",
      "updated_at": "2021-03-16T14:59:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic for Node.js automatically instruments most standard web requests, but sometimes you want expanded instrumentation. With the agent's custom instrumentation API, you can create instrumentation for otherwise unsupported web frameworks, datastores, and message service clients. The Node.js agent's custom instrumentation API also allows you to: Create web transactions (useful for things like web sockets, where transactions can't be automatically created). Create non-web background transactions (useful for recording background jobs). Target specific sections of your code for deeper analysis. Agent version requirements The custom instrumentation methods in this document are available as of Node.js agent version 2.0.0. For information on instrumentation using the custom instrumentation API v1.x, see the documentation for legacy Node.js custom instrumentation. Instrument unsupported web frameworks Beginning with Node.js agent version 2.0.0, New Relic provides an API to expand instrumentation for additional web frameworks. For more information, including a tutorial, see the documentation for Node.js web framework instrumentation on GitHub. Instrument unsupported message service clients Beginning with Node.js agent version 2.0.0, New Relic provides an API to expand instrumentation for additional message service libraries. For more information, including a tutorial, see the documentation for Node.js message service client instrumentation on GitHub. Instrument unsupported datastores Beginning with Node.js agent version 2.0.0, New Relic provides an API to expand instrumentation for additional datastore libraries. For more information, including a tutorial, see the documentation for Node.js datastore instrumentation on GitHub. Instrument web transactions In order to create custom web transactions, call startWebTransaction to start the transaction. To end the transaction, use any of these options: Ending the transaction Comments Promise If the handler passed to startWebTransaction returns a promise, the agent will end the transaction when the returned promise resolves or rejects. Manual If you call getTransaction in the context of the new transaction, this notifies the agent that the transaction will be handled manually. If getTransaction is called in the handler, then you must end the transaction by calling transaction.end(). Synchronous If neither of these options are fulfilled, the transaction will be ended when the handler returns synchronously. Custom web transaction example: Instrument three transactions in socket.io This example instruments a /websocket/ping transaction, a /websocket/update transaction, and a /websocket/new-message transaction within socket.io. The /ping example is synchronous, while the /new-message and /update examples are asynchronous. var nr = require('newrelic') var app = require('http').createServer() var io = require('socket.io')(app) io.on('connection', function (socket) { socket.on('ping', function (data) { nr.startWebTransaction('/websocket/ping', function transactionHandler() { // Ended automatically after synchronously returning socket.emit('pong') }) }) socket.on('update', function (data) { nr.startWebTransaction('/websocket/update', function transactionHandler() { // Using API#getTransaction var transaction = nr.getTransaction() updateChatWindow(data, function transactionHandler() { socket.emit('update-done') transaction.end() }) }) }) socket.on('new-message', function (data) { nr.startWebTransaction('/websocket/new-message', function transactionHandler() { // Returning a promise return new Promise(function (resolve, reject) { addMessageToChat(data, function () { socket.emit('message-received') resolve() }) }) }) }) }) Copy This method only gives basic timing data for the transaction created. To create more intricate timing data and transaction naming for a particular framework, see the Node.js API documentation and the related tutorial on GitHub. Instrument background transactions You can use custom transactions to instrument non-web transactions (background tasks); for example: Periodic jobs within your app Work that continues after a request completes To instrument background tasks, call startBackgroundTransaction in your handler to start a background transaction. To end the transaction, use any of these options: Ending the transaction Comments Promise If the handler passed to startBackgroundTransaction returns a promise, the agent will end the transaction when the returned promise resolves or rejects. Manual If you call getTransaction in the context of the new transaction, this notifies the agent that the transaction will be handled manually. If getTransaction is called in the handler, then you must end the transaction by calling transaction.end(). Synchronous If neither of these options are fulfilled, the transaction will be ended when the handler returns synchronously. Custom background transaction example: Instrument within setInterval This example instruments update:cache within setInterval: var nr = require('newrelic') var redis = require('redis').createClient() // Using API#getTransaction to manage ending the transaction setInterval(function () { nr.startBackgroundTransaction('update:cache', function transactionHandler() { var newValue = someDataGenerator() var transaction = nr.getTransaction() redis.set('some:cache:key', newValue, function () { transaction.end() }) }) }, 30000) // Every 30s //Using a promise to manage ending the transaction setInterval(function () { nr.startBackgroundTransaction('flush:cache', function transactionHandler() { return new Promise(function(resolve, reject) { flushCache(redis, function afterFlush(err) { if (err) { return reject(err) } resolve() }) }) }) }, 60*60*1000) Copy Expand instrumentation within transactions You can create instrumentation using the instrumentation registration methods on the API. Writing instrumentation using the instrumentation API allows you to specify metrics and naming in greater detail by \"monkey patching\" methods (replacing functions) on relevant objects. Other options can offer visibility into web transactions that are already instrumented, or gain insight into databases and other in-transaction work that is not automatically instrumented. To do this, wrap your callbacks in custom tracers. Custom tracers create and collect specific metrics for an additional segment within an existing transaction, such as a particular function or a database call. To instrument individual callbacks, call startSegment() inside the callback, and move the main callback logic to the handler function. To instrument a function that is called inside an asynchronous function, wrap both the target function and its parent asynchronous function with startSegment(). Important These examples must be placed in code that is running under a transaction. The origin of the transaction, custom or automatically created, does not matter. Example: Instrument a callback This example tracks a single callback: // Wrap the method in a segment. nr.startSegment('db:createObject', true, function(cb) { // This is recorded as the `db:createObject` segment. db.createObject(cb) }, function(err, result) { // This is recorded as the callback to the `db:createObject` segment. if (util.handleError(err, res)) { return } res.write(JSON.stringify(result.rows[0].id)) res.write('\\n') res.end() }) Copy Example: Instrument asynchronous functions using callbacks This example tracks both pg.connect and client.query. This is because client.query is called by an asynchronous parent function (pg.connect). Otherwise, you would not get any data from client.query. This allows startSegment() to propagate the active transaction across those asynchronous boundaries. nr.startSegment('pg:connect', true, function(cb) { pg.connect(config.db_string, cb) }, function(err, client, done) { if (util.handleError(err, '500', res)) { return done() } nr.startSegment('pg:query', true, function(cb) { client.query('SELECT count(*) FROM test_count'), cb) }, function(err, result) { if (util.handleError(err, '500', res)) { return done() } res.write(result.rows[0].count) res.write('\\n') }) }) Copy Example: Instrument asynchronous functions using promises This example is the same as the callback one, but for interacting with a promise-based API. For promises, simply return the promise and call then after startSegment to continue your execution. nr.startSegment('pg:connect', true, function() { // This `pg:connect` segment will time until the returned promise // either resolves or rejects. return pg.connect(config.db_string) }).then(function(client) { // The transaction context is propagated into following promises. return nr.startSegment('pg:query', true, function() { return client.query('SELECT count(*) FROM test_count')) }).then(function(result) { res.write(result.rows[0].count) res.write('\\n') res.end() }, function(err) { // Error from querying. util.handleError(err, '500', res) }).finally(function() { return client.release() }) }, function(err) { // Error from connecting. util.handleError(err, '500', res) }) Copy Example: Instrument async functions This example shows how to instrument code using async/await to control asynchronous work. This requires using Node 8 or higher, as well as the New Relic for Node.js agent v2.3.0 or higher. try { const client = await nr.startSegment('pg:connect', true, async () => { // Async functions simply return promises, so this example is // very similar to the promise one. return await pg.connect(config.db_string) }) // The transaction context is propagated into the code following `await`. try { const result = await nr.startSegment('pg:query', true, async () => { return await client.query('SELECT count(*) FROM test_count')) }) res.write(result.rows[0].count) res.write('\\n') res.end() } catch(err) { // Error from querying. util.handleError(err, '500', res) } finally { await client.release() } } catch(err) { // Error from connecting. util.handleError(err, '500', res) } Copy Example: Instrument a synchronous function This example shows how startSegment can be used to record a synchronous function that is responsible for assigning its return value to a variable. var result = nr.startSegment('calculateTotal', true, function() { return calculateTotal(outerVar1, outerVar2) }) Copy Important The startSegment function is available of the Node Agent 3.3.0 release.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.75642,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Node.js custom <em>instrumentation</em>",
        "sections": "Node.js custom <em>instrumentation</em>",
        "tags": "<em>Extend</em> <em>your</em> <em>instrumentation</em>",
        "body": " analysis. <em>Agent</em> version requirements The custom <em>instrumentation</em> methods in this document are available as of <em>Node.js</em> <em>agent</em> version 2.0.0. For information on <em>instrumentation</em> using the custom <em>instrumentation</em> API v1.x, see the documentation for legacy <em>Node.js</em> custom <em>instrumentation</em>. <em>Instrument</em> unsupported web"
      },
      "id": "603ec39964441f02dc4e8882"
    },
    {
      "sections": [
        "Browser monitoring and the Node.js agent",
        "Insert the JavaScript header",
        "Framework examples",
        "Express and jade",
        "Express and Swig",
        "Hapi.js and handlebars",
        "Disable header generation",
        "Caution"
      ],
      "title": "Browser monitoring and the Node.js agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Extend your instrumentation"
      ],
      "external_id": "8b8cba2d5ce2acdc55df2621d850329cf4796bbd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/extend-your-instrumentation/browser-monitoring-nodejs-agent/",
      "published_at": "2021-06-02T15:16:26Z",
      "updated_at": "2021-03-16T09:02:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the Node.js agent, you can add browser instrumentation to your web pages. To use browser monitoring with your Node.js agent, ensure you have the latest release of the Node.js agent. To enable browser monitoring in the user interface, follow the procedures to install the browser agent. Then follow the procedures in this section to set up the Node.js agent. Insert the JavaScript header Instrumentation for the Node.js agent can continue beyond your application into end users' browsers. The newrelic module can generate script headers which, when inserted into your HTML templates, will capture the end users' page load times. The headers must be manually injected, but no extra configuration is necessary. At the beginning of your html page's head tag, insert the results of newrelic.getBrowserTimingHeader() after any CHARSET meta tags. Exception: For maximum Internet Explorer compatibility, insert the results of newrelic.getBrowserTimingHeader() after any X-UA-COMPATIBLE HTTP-EQUIV meta tags. Call the header once for every request. Do not cache the header. Generating headers is fast, and it does not require your application to make extra requests to New Relic. Framework examples Here are some examples of how to set up browser monitoring with different frameworks and templates. Express and jade This example uses Express, a web application framework, and jade, a template module. Although the specifics are different with other frameworks, this general approach should work in most cases. The simplest way to insert browser timing headings is to pass the newrelic module into your template, and then call newrelic.getBrowsertimingHeader() from within the template. In your app.js: var newrelic = require('newrelic'); var app = require('express')(); // in express, this lets you call newrelic from within a template app.locals.newrelic = newrelic; app.get('/user/:id', function (req, res) { res.render('user'); }); app.listen(process.env.PORT); Copy In your layout.jade: doctype html html head != newrelic.getBrowserTimingHeader() title= title link(rel='stylesheet', href='stylesheets/style.css') body block content Copy Express and Swig This example uses Express with Swig. In your app.js: var newrelic = require('newrelic'); var http = require('http') var path = require('path') var swig = require('swig') var app = require('express')(); app.locals.newrelic = newrelic; //taken from http://paularmstrong.github.io/swig/docs/#express app.engine('html', swig.renderFile); app.set('view engine', 'html'); app.set('views', __dirname + '/views'); app.get('/user/:id', function (req, res) { res.render('user'); }); app.listen(process.env.PORT); Copy In your views/user.html: <!DOCTYPE html> <html> <head> {{ newrelic.getBrowserTimingHeader() }} <title>Hello</title> </head> <body> <h1>Hello World</h1> </body> </html> Copy Hapi.js and handlebars This example uses hapi.js and handlebars. Other similar templating languages typically require triple brackets; for example, using mustache with hogan-express. This helps prevent escaping of the script content. Using hapi, in your app.js: var newrelic = require('newrelic'); var Hapi = require('hapi'); var server = new Hapi.Server(parseInt(PORT), '0.0.0.0', { views: { engines : {html: 'handlebars' }, path : __dirname + '/templates' } }); function homepage(request, reply) { var context = { // pass in the header each request nreum : newrelic.getBrowserTimingHeader(), content : ... }; reply.view('homepage', context); }; server.route({ method : 'GET', path : '/', handler : homepage }); server.start(); Copy In your templates/homepage.html: <!DOCTYPE html> <html> <head> {{{ nreum }}} <title>Hello</title> </head> <body> {{ content }} </body> </html> Copy Disable header generation By default, calls to newrelic.getBrowserTimingHeader() should return valid headers. To disable header generation without removing your template code: In your newrelic.js file, add: browser_monitoring : { enable : false } Copy You can also set the environment variable NEW_RELIC_BROWSER_MONITOR_ENABLE=false. Caution Always leave ssl between the agent and the New Relic collector when using browser monitoring. You can safely leave the API calls in place even if you are not using browser monitoring or the newrelic module. If browser monitoring is disabled, or if there is an error so that working headers cannot be generated, the newrelic module generates an innocuous HTML comment. If you disable the newrelic module completely, no content will be generated.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.71094,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Browser monitoring and the Node.js <em>agent</em>",
        "sections": "Browser monitoring and the Node.js <em>agent</em>",
        "tags": "<em>Extend</em> <em>your</em> <em>instrumentation</em>",
        "body": "With the <em>Node.js</em> <em>agent</em>, you can add browser <em>instrumentation</em> to <em>your</em> web pages. To use browser monitoring with <em>your</em> <em>Node.js</em> <em>agent</em>, ensure you have the latest release of the <em>Node.js</em> <em>agent</em>. To enable browser monitoring in the user interface, follow the procedures to install the browser <em>agent</em>"
      },
      "id": "603e8376e7b9d2b7472a07f7"
    }
  ],
  "/docs/agents/nodejs-agent/extend-your-instrumentation/nodejs-v1-custom-instrumentation-legacy": [
    {
      "sections": [
        "Node.js VMs statistics page",
        "What you need",
        "View Node VM statistics",
        "Analyze performance issues",
        "GC pause time",
        "GC pause frequency",
        "GC pause time by type",
        "Memory usage",
        "CPU utilization",
        "Event loop — ticks per minute",
        "Event loop — max CPU time per tick",
        "View clusters of multiple processes"
      ],
      "title": "Node.js VMs statistics page",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Extend your instrumentation"
      ],
      "external_id": "b1c5ecf7ca24b63c50ed1021f020d62e513f8455",
      "image": "https://docs.newrelic.com/static/b0ab0aacf7b062b687be29a94ff96a43/8c557/vm-dashboard.png",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/extend-your-instrumentation/nodejs-vms-statistics-page/",
      "published_at": "2021-06-02T20:25:06Z",
      "updated_at": "2021-03-16T15:01:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In New Relic's APM, the Node VMs page provides useful runtime data for troubleshooting performance issues and monitoring the health of your application. What you need Some of the charts on the Node VMs page require you to install the New Relic Native Metrics Module in addition to the Node.js agent. For installation instructions, see Node VM Measurements. View Node VM statistics one.newrelic.com > APM > (select an app) > Node VMs: When multiple servers are reporting to the same application, the page breaks charts down by server. You can view data for an individual server and obtain additional details by selecting a server from the Servers filter at the top of the page. To correlate spikes or upward trends in any of these measurements with specific transactions: Go to one.newrelic.com > APM > (select an app) > Node VMs. Select the time period by clicking and dragging within any of the charts. Navigate to the Transactions page or any other page. As you go to other pages, the time picker selection will remain the same. Analyze performance issues Here is a summary of the data available on individual Node VM charts. By using all of the charts together, you can troubleshoot performance issues. For example: When the application starts using more objects, memory usage will increase, and garbage collection (GC) will run more frequently. CPU utilization will increase due to time spent in GC. Abnormally long synchronous code execution can increase CPU utilization. This will show spikes in the Event loop max CPU time per tick chart. GC pause time The amount of time spent in garbage collection. For a single server, the chart shows average, max, and total time per minute. For multiple servers, the chart shows total time grouped by server. Typically, spikes in GC time or frequency indicate a potential issue. GC pause frequency The number of times GC runs were executed per minute. For a single server, the chart is broken down by the type of GC. For multiple servers, the chart shows total number of GC calls (all types combined) grouped by server. GC pause time by type This chart shows the total time spent in garbage collection per minute, broken down by GC type. It is only shown when viewing a single server. You might see the following types depending on your version of Node.js and app activity: Value Description Scavenge The most common garbage collection method. Node.js will typically trigger one of these every time the VM is idle. MarkSweepCompact The heaviest type of garbage collection V8 may do. If you see many of these happening you will need to either keep fewer objects around in your process or increase V8's heap limit. IncrementalMarking A phased garbage collection that interleaves collection with application logic to reduce the amount of time the application is paused. Only in Node.js v6 or higher. ProcessWeakCallbacks After a garbage collection occurs, V8 will call any weak reference callbacks registered for objects that have been freed. This measurement is from the start of the first weak callback to the end of the last for a given garbage collection. Only in Node.js v6 or higher. Memory usage This chart shows the amount of memory consumed by the Node.js process. For multiple servers, the chart shows total memory grouped by server. For a single server, the chart is segmented by the following types of memory: Value Description Non-heap The memory allocated to data outside V8's heap (for example, buffers, sockets). V8 heap (used) The amount of memory being used by V8 (for example, JavaScript objects). V8 heap (free) The amount of memory set aside by V8 for memory pooling. This memory isn't being actively used, but is set aside for V8 to freely allocate more as needed. CPU utilization This chart shows the CPU utilization of the Node process. For multiple servers, the chart shows total CPU utilization grouped by server. For a single server, the chart is segmented by the following: Value Description User The time spent executing the user code, divided by wall-clock time. System The time spent in the system kernel on behalf of the Node process, divided by wall-clock time. Event loop — ticks per minute This chart shows the number of event loop ticks per minute. A tick is a single turn of the event loop, in which functions that are ready to be executed are run. As a part of each event loop turn, Node waits for pending I/O to complete. Once any I/O events are received, the event loop executes callbacks associated with it. Therefore, the number of ticks per minute corresponds to how frequently I/O events occur. Event loop — max CPU time per tick This chart shows the maximum time spent in a single tick per minute. This is useful with detecting an abnormally long event loop tick, which indicates long synchronous code execution. View clusters of multiple processes When multiple Node.js processes on the same server report to the same New Relic application, these charts will show aggregated data. This is because each worker process in a cluster has its own separate Node.js runtime and collects separate data. Clusters Comments Sum across all workers The following charts show a sum across all workers: GC pause time - Total time per minute GC pause frequency GC pause time by type CPU utilization Event loop ticks per minute Average from all workers The following charts show an average from all workers: Memory usage GC pause time — average Max across all workers The following charts show max across all workers: GC pause time — max Event loop — max CPU time per tick",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.75662,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Extend</em> <em>your</em> <em>instrumentation</em>",
        "body": "In New Relic&#x27;s APM, the Node VMs page provides useful runtime data for troubleshooting performance issues and monitoring the health of <em>your</em> application. What you need Some of the charts on the Node VMs page require you to install the New Relic Native Metrics Module in addition to the <em>Node.js</em> <em>agent</em>"
      },
      "id": "603ea123e7b9d2eb022a0811"
    },
    {
      "sections": [
        "Node.js custom instrumentation",
        "Agent version requirements",
        "Instrument unsupported web frameworks",
        "Instrument unsupported message service clients",
        "Instrument unsupported datastores",
        "Instrument web transactions",
        "Custom web transaction example: Instrument three transactions in socket.io",
        "Instrument background transactions",
        "Custom background transaction example: Instrument within setInterval",
        "Expand instrumentation within transactions",
        "Important",
        "Example: Instrument a callback",
        "Example: Instrument asynchronous functions using callbacks",
        "Example: Instrument asynchronous functions using promises",
        "Example: Instrument async functions",
        "Example: Instrument a synchronous function"
      ],
      "title": "Node.js custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Extend your instrumentation"
      ],
      "external_id": "284f422639e1af4a65c26edd4d3f5bc53106e51a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/extend-your-instrumentation/nodejs-custom-instrumentation/",
      "published_at": "2021-06-02T15:04:34Z",
      "updated_at": "2021-03-16T14:59:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic for Node.js automatically instruments most standard web requests, but sometimes you want expanded instrumentation. With the agent's custom instrumentation API, you can create instrumentation for otherwise unsupported web frameworks, datastores, and message service clients. The Node.js agent's custom instrumentation API also allows you to: Create web transactions (useful for things like web sockets, where transactions can't be automatically created). Create non-web background transactions (useful for recording background jobs). Target specific sections of your code for deeper analysis. Agent version requirements The custom instrumentation methods in this document are available as of Node.js agent version 2.0.0. For information on instrumentation using the custom instrumentation API v1.x, see the documentation for legacy Node.js custom instrumentation. Instrument unsupported web frameworks Beginning with Node.js agent version 2.0.0, New Relic provides an API to expand instrumentation for additional web frameworks. For more information, including a tutorial, see the documentation for Node.js web framework instrumentation on GitHub. Instrument unsupported message service clients Beginning with Node.js agent version 2.0.0, New Relic provides an API to expand instrumentation for additional message service libraries. For more information, including a tutorial, see the documentation for Node.js message service client instrumentation on GitHub. Instrument unsupported datastores Beginning with Node.js agent version 2.0.0, New Relic provides an API to expand instrumentation for additional datastore libraries. For more information, including a tutorial, see the documentation for Node.js datastore instrumentation on GitHub. Instrument web transactions In order to create custom web transactions, call startWebTransaction to start the transaction. To end the transaction, use any of these options: Ending the transaction Comments Promise If the handler passed to startWebTransaction returns a promise, the agent will end the transaction when the returned promise resolves or rejects. Manual If you call getTransaction in the context of the new transaction, this notifies the agent that the transaction will be handled manually. If getTransaction is called in the handler, then you must end the transaction by calling transaction.end(). Synchronous If neither of these options are fulfilled, the transaction will be ended when the handler returns synchronously. Custom web transaction example: Instrument three transactions in socket.io This example instruments a /websocket/ping transaction, a /websocket/update transaction, and a /websocket/new-message transaction within socket.io. The /ping example is synchronous, while the /new-message and /update examples are asynchronous. var nr = require('newrelic') var app = require('http').createServer() var io = require('socket.io')(app) io.on('connection', function (socket) { socket.on('ping', function (data) { nr.startWebTransaction('/websocket/ping', function transactionHandler() { // Ended automatically after synchronously returning socket.emit('pong') }) }) socket.on('update', function (data) { nr.startWebTransaction('/websocket/update', function transactionHandler() { // Using API#getTransaction var transaction = nr.getTransaction() updateChatWindow(data, function transactionHandler() { socket.emit('update-done') transaction.end() }) }) }) socket.on('new-message', function (data) { nr.startWebTransaction('/websocket/new-message', function transactionHandler() { // Returning a promise return new Promise(function (resolve, reject) { addMessageToChat(data, function () { socket.emit('message-received') resolve() }) }) }) }) }) Copy This method only gives basic timing data for the transaction created. To create more intricate timing data and transaction naming for a particular framework, see the Node.js API documentation and the related tutorial on GitHub. Instrument background transactions You can use custom transactions to instrument non-web transactions (background tasks); for example: Periodic jobs within your app Work that continues after a request completes To instrument background tasks, call startBackgroundTransaction in your handler to start a background transaction. To end the transaction, use any of these options: Ending the transaction Comments Promise If the handler passed to startBackgroundTransaction returns a promise, the agent will end the transaction when the returned promise resolves or rejects. Manual If you call getTransaction in the context of the new transaction, this notifies the agent that the transaction will be handled manually. If getTransaction is called in the handler, then you must end the transaction by calling transaction.end(). Synchronous If neither of these options are fulfilled, the transaction will be ended when the handler returns synchronously. Custom background transaction example: Instrument within setInterval This example instruments update:cache within setInterval: var nr = require('newrelic') var redis = require('redis').createClient() // Using API#getTransaction to manage ending the transaction setInterval(function () { nr.startBackgroundTransaction('update:cache', function transactionHandler() { var newValue = someDataGenerator() var transaction = nr.getTransaction() redis.set('some:cache:key', newValue, function () { transaction.end() }) }) }, 30000) // Every 30s //Using a promise to manage ending the transaction setInterval(function () { nr.startBackgroundTransaction('flush:cache', function transactionHandler() { return new Promise(function(resolve, reject) { flushCache(redis, function afterFlush(err) { if (err) { return reject(err) } resolve() }) }) }) }, 60*60*1000) Copy Expand instrumentation within transactions You can create instrumentation using the instrumentation registration methods on the API. Writing instrumentation using the instrumentation API allows you to specify metrics and naming in greater detail by \"monkey patching\" methods (replacing functions) on relevant objects. Other options can offer visibility into web transactions that are already instrumented, or gain insight into databases and other in-transaction work that is not automatically instrumented. To do this, wrap your callbacks in custom tracers. Custom tracers create and collect specific metrics for an additional segment within an existing transaction, such as a particular function or a database call. To instrument individual callbacks, call startSegment() inside the callback, and move the main callback logic to the handler function. To instrument a function that is called inside an asynchronous function, wrap both the target function and its parent asynchronous function with startSegment(). Important These examples must be placed in code that is running under a transaction. The origin of the transaction, custom or automatically created, does not matter. Example: Instrument a callback This example tracks a single callback: // Wrap the method in a segment. nr.startSegment('db:createObject', true, function(cb) { // This is recorded as the `db:createObject` segment. db.createObject(cb) }, function(err, result) { // This is recorded as the callback to the `db:createObject` segment. if (util.handleError(err, res)) { return } res.write(JSON.stringify(result.rows[0].id)) res.write('\\n') res.end() }) Copy Example: Instrument asynchronous functions using callbacks This example tracks both pg.connect and client.query. This is because client.query is called by an asynchronous parent function (pg.connect). Otherwise, you would not get any data from client.query. This allows startSegment() to propagate the active transaction across those asynchronous boundaries. nr.startSegment('pg:connect', true, function(cb) { pg.connect(config.db_string, cb) }, function(err, client, done) { if (util.handleError(err, '500', res)) { return done() } nr.startSegment('pg:query', true, function(cb) { client.query('SELECT count(*) FROM test_count'), cb) }, function(err, result) { if (util.handleError(err, '500', res)) { return done() } res.write(result.rows[0].count) res.write('\\n') }) }) Copy Example: Instrument asynchronous functions using promises This example is the same as the callback one, but for interacting with a promise-based API. For promises, simply return the promise and call then after startSegment to continue your execution. nr.startSegment('pg:connect', true, function() { // This `pg:connect` segment will time until the returned promise // either resolves or rejects. return pg.connect(config.db_string) }).then(function(client) { // The transaction context is propagated into following promises. return nr.startSegment('pg:query', true, function() { return client.query('SELECT count(*) FROM test_count')) }).then(function(result) { res.write(result.rows[0].count) res.write('\\n') res.end() }, function(err) { // Error from querying. util.handleError(err, '500', res) }).finally(function() { return client.release() }) }, function(err) { // Error from connecting. util.handleError(err, '500', res) }) Copy Example: Instrument async functions This example shows how to instrument code using async/await to control asynchronous work. This requires using Node 8 or higher, as well as the New Relic for Node.js agent v2.3.0 or higher. try { const client = await nr.startSegment('pg:connect', true, async () => { // Async functions simply return promises, so this example is // very similar to the promise one. return await pg.connect(config.db_string) }) // The transaction context is propagated into the code following `await`. try { const result = await nr.startSegment('pg:query', true, async () => { return await client.query('SELECT count(*) FROM test_count')) }) res.write(result.rows[0].count) res.write('\\n') res.end() } catch(err) { // Error from querying. util.handleError(err, '500', res) } finally { await client.release() } } catch(err) { // Error from connecting. util.handleError(err, '500', res) } Copy Example: Instrument a synchronous function This example shows how startSegment can be used to record a synchronous function that is responsible for assigning its return value to a variable. var result = nr.startSegment('calculateTotal', true, function() { return calculateTotal(outerVar1, outerVar2) }) Copy Important The startSegment function is available of the Node Agent 3.3.0 release.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.75642,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Node.js custom <em>instrumentation</em>",
        "sections": "Node.js custom <em>instrumentation</em>",
        "tags": "<em>Extend</em> <em>your</em> <em>instrumentation</em>",
        "body": " analysis. <em>Agent</em> version requirements The custom <em>instrumentation</em> methods in this document are available as of <em>Node.js</em> <em>agent</em> version 2.0.0. For information on <em>instrumentation</em> using the custom <em>instrumentation</em> API v1.x, see the documentation for legacy <em>Node.js</em> custom <em>instrumentation</em>. <em>Instrument</em> unsupported web"
      },
      "id": "603ec39964441f02dc4e8882"
    },
    {
      "sections": [
        "Browser monitoring and the Node.js agent",
        "Insert the JavaScript header",
        "Framework examples",
        "Express and jade",
        "Express and Swig",
        "Hapi.js and handlebars",
        "Disable header generation",
        "Caution"
      ],
      "title": "Browser monitoring and the Node.js agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Extend your instrumentation"
      ],
      "external_id": "8b8cba2d5ce2acdc55df2621d850329cf4796bbd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/extend-your-instrumentation/browser-monitoring-nodejs-agent/",
      "published_at": "2021-06-02T15:16:26Z",
      "updated_at": "2021-03-16T09:02:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the Node.js agent, you can add browser instrumentation to your web pages. To use browser monitoring with your Node.js agent, ensure you have the latest release of the Node.js agent. To enable browser monitoring in the user interface, follow the procedures to install the browser agent. Then follow the procedures in this section to set up the Node.js agent. Insert the JavaScript header Instrumentation for the Node.js agent can continue beyond your application into end users' browsers. The newrelic module can generate script headers which, when inserted into your HTML templates, will capture the end users' page load times. The headers must be manually injected, but no extra configuration is necessary. At the beginning of your html page's head tag, insert the results of newrelic.getBrowserTimingHeader() after any CHARSET meta tags. Exception: For maximum Internet Explorer compatibility, insert the results of newrelic.getBrowserTimingHeader() after any X-UA-COMPATIBLE HTTP-EQUIV meta tags. Call the header once for every request. Do not cache the header. Generating headers is fast, and it does not require your application to make extra requests to New Relic. Framework examples Here are some examples of how to set up browser monitoring with different frameworks and templates. Express and jade This example uses Express, a web application framework, and jade, a template module. Although the specifics are different with other frameworks, this general approach should work in most cases. The simplest way to insert browser timing headings is to pass the newrelic module into your template, and then call newrelic.getBrowsertimingHeader() from within the template. In your app.js: var newrelic = require('newrelic'); var app = require('express')(); // in express, this lets you call newrelic from within a template app.locals.newrelic = newrelic; app.get('/user/:id', function (req, res) { res.render('user'); }); app.listen(process.env.PORT); Copy In your layout.jade: doctype html html head != newrelic.getBrowserTimingHeader() title= title link(rel='stylesheet', href='stylesheets/style.css') body block content Copy Express and Swig This example uses Express with Swig. In your app.js: var newrelic = require('newrelic'); var http = require('http') var path = require('path') var swig = require('swig') var app = require('express')(); app.locals.newrelic = newrelic; //taken from http://paularmstrong.github.io/swig/docs/#express app.engine('html', swig.renderFile); app.set('view engine', 'html'); app.set('views', __dirname + '/views'); app.get('/user/:id', function (req, res) { res.render('user'); }); app.listen(process.env.PORT); Copy In your views/user.html: <!DOCTYPE html> <html> <head> {{ newrelic.getBrowserTimingHeader() }} <title>Hello</title> </head> <body> <h1>Hello World</h1> </body> </html> Copy Hapi.js and handlebars This example uses hapi.js and handlebars. Other similar templating languages typically require triple brackets; for example, using mustache with hogan-express. This helps prevent escaping of the script content. Using hapi, in your app.js: var newrelic = require('newrelic'); var Hapi = require('hapi'); var server = new Hapi.Server(parseInt(PORT), '0.0.0.0', { views: { engines : {html: 'handlebars' }, path : __dirname + '/templates' } }); function homepage(request, reply) { var context = { // pass in the header each request nreum : newrelic.getBrowserTimingHeader(), content : ... }; reply.view('homepage', context); }; server.route({ method : 'GET', path : '/', handler : homepage }); server.start(); Copy In your templates/homepage.html: <!DOCTYPE html> <html> <head> {{{ nreum }}} <title>Hello</title> </head> <body> {{ content }} </body> </html> Copy Disable header generation By default, calls to newrelic.getBrowserTimingHeader() should return valid headers. To disable header generation without removing your template code: In your newrelic.js file, add: browser_monitoring : { enable : false } Copy You can also set the environment variable NEW_RELIC_BROWSER_MONITOR_ENABLE=false. Caution Always leave ssl between the agent and the New Relic collector when using browser monitoring. You can safely leave the API calls in place even if you are not using browser monitoring or the newrelic module. If browser monitoring is disabled, or if there is an error so that working headers cannot be generated, the newrelic module generates an innocuous HTML comment. If you disable the newrelic module completely, no content will be generated.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.71094,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Browser monitoring and the Node.js <em>agent</em>",
        "sections": "Browser monitoring and the Node.js <em>agent</em>",
        "tags": "<em>Extend</em> <em>your</em> <em>instrumentation</em>",
        "body": "With the <em>Node.js</em> <em>agent</em>, you can add browser <em>instrumentation</em> to <em>your</em> web pages. To use browser monitoring with <em>your</em> <em>Node.js</em> <em>agent</em>, ensure you have the latest release of the <em>Node.js</em> <em>agent</em>. To enable browser monitoring in the user interface, follow the procedures to install the browser <em>agent</em>"
      },
      "id": "603e8376e7b9d2b7472a07f7"
    }
  ],
  "/docs/agents/nodejs-agent/extend-your-instrumentation/nodejs-vm-measurements": [
    {
      "sections": [
        "Node.js VMs statistics page",
        "What you need",
        "View Node VM statistics",
        "Analyze performance issues",
        "GC pause time",
        "GC pause frequency",
        "GC pause time by type",
        "Memory usage",
        "CPU utilization",
        "Event loop — ticks per minute",
        "Event loop — max CPU time per tick",
        "View clusters of multiple processes"
      ],
      "title": "Node.js VMs statistics page",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Extend your instrumentation"
      ],
      "external_id": "b1c5ecf7ca24b63c50ed1021f020d62e513f8455",
      "image": "https://docs.newrelic.com/static/b0ab0aacf7b062b687be29a94ff96a43/8c557/vm-dashboard.png",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/extend-your-instrumentation/nodejs-vms-statistics-page/",
      "published_at": "2021-06-02T20:25:06Z",
      "updated_at": "2021-03-16T15:01:04Z",
      "document_type": "page",
      "popularity": 1,
      "body": "In New Relic's APM, the Node VMs page provides useful runtime data for troubleshooting performance issues and monitoring the health of your application. What you need Some of the charts on the Node VMs page require you to install the New Relic Native Metrics Module in addition to the Node.js agent. For installation instructions, see Node VM Measurements. View Node VM statistics one.newrelic.com > APM > (select an app) > Node VMs: When multiple servers are reporting to the same application, the page breaks charts down by server. You can view data for an individual server and obtain additional details by selecting a server from the Servers filter at the top of the page. To correlate spikes or upward trends in any of these measurements with specific transactions: Go to one.newrelic.com > APM > (select an app) > Node VMs. Select the time period by clicking and dragging within any of the charts. Navigate to the Transactions page or any other page. As you go to other pages, the time picker selection will remain the same. Analyze performance issues Here is a summary of the data available on individual Node VM charts. By using all of the charts together, you can troubleshoot performance issues. For example: When the application starts using more objects, memory usage will increase, and garbage collection (GC) will run more frequently. CPU utilization will increase due to time spent in GC. Abnormally long synchronous code execution can increase CPU utilization. This will show spikes in the Event loop max CPU time per tick chart. GC pause time The amount of time spent in garbage collection. For a single server, the chart shows average, max, and total time per minute. For multiple servers, the chart shows total time grouped by server. Typically, spikes in GC time or frequency indicate a potential issue. GC pause frequency The number of times GC runs were executed per minute. For a single server, the chart is broken down by the type of GC. For multiple servers, the chart shows total number of GC calls (all types combined) grouped by server. GC pause time by type This chart shows the total time spent in garbage collection per minute, broken down by GC type. It is only shown when viewing a single server. You might see the following types depending on your version of Node.js and app activity: Value Description Scavenge The most common garbage collection method. Node.js will typically trigger one of these every time the VM is idle. MarkSweepCompact The heaviest type of garbage collection V8 may do. If you see many of these happening you will need to either keep fewer objects around in your process or increase V8's heap limit. IncrementalMarking A phased garbage collection that interleaves collection with application logic to reduce the amount of time the application is paused. Only in Node.js v6 or higher. ProcessWeakCallbacks After a garbage collection occurs, V8 will call any weak reference callbacks registered for objects that have been freed. This measurement is from the start of the first weak callback to the end of the last for a given garbage collection. Only in Node.js v6 or higher. Memory usage This chart shows the amount of memory consumed by the Node.js process. For multiple servers, the chart shows total memory grouped by server. For a single server, the chart is segmented by the following types of memory: Value Description Non-heap The memory allocated to data outside V8's heap (for example, buffers, sockets). V8 heap (used) The amount of memory being used by V8 (for example, JavaScript objects). V8 heap (free) The amount of memory set aside by V8 for memory pooling. This memory isn't being actively used, but is set aside for V8 to freely allocate more as needed. CPU utilization This chart shows the CPU utilization of the Node process. For multiple servers, the chart shows total CPU utilization grouped by server. For a single server, the chart is segmented by the following: Value Description User The time spent executing the user code, divided by wall-clock time. System The time spent in the system kernel on behalf of the Node process, divided by wall-clock time. Event loop — ticks per minute This chart shows the number of event loop ticks per minute. A tick is a single turn of the event loop, in which functions that are ready to be executed are run. As a part of each event loop turn, Node waits for pending I/O to complete. Once any I/O events are received, the event loop executes callbacks associated with it. Therefore, the number of ticks per minute corresponds to how frequently I/O events occur. Event loop — max CPU time per tick This chart shows the maximum time spent in a single tick per minute. This is useful with detecting an abnormally long event loop tick, which indicates long synchronous code execution. View clusters of multiple processes When multiple Node.js processes on the same server report to the same New Relic application, these charts will show aggregated data. This is because each worker process in a cluster has its own separate Node.js runtime and collects separate data. Clusters Comments Sum across all workers The following charts show a sum across all workers: GC pause time - Total time per minute GC pause frequency GC pause time by type CPU utilization Event loop ticks per minute Average from all workers The following charts show an average from all workers: Memory usage GC pause time — average Max across all workers The following charts show max across all workers: GC pause time — max Event loop — max CPU time per tick",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.75662,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Extend</em> <em>your</em> <em>instrumentation</em>",
        "body": "In New Relic&#x27;s APM, the Node VMs page provides useful runtime data for troubleshooting performance issues and monitoring the health of <em>your</em> application. What you need Some of the charts on the Node VMs page require you to install the New Relic Native Metrics Module in addition to the <em>Node.js</em> <em>agent</em>"
      },
      "id": "603ea123e7b9d2eb022a0811"
    },
    {
      "sections": [
        "Node.js custom instrumentation",
        "Agent version requirements",
        "Instrument unsupported web frameworks",
        "Instrument unsupported message service clients",
        "Instrument unsupported datastores",
        "Instrument web transactions",
        "Custom web transaction example: Instrument three transactions in socket.io",
        "Instrument background transactions",
        "Custom background transaction example: Instrument within setInterval",
        "Expand instrumentation within transactions",
        "Important",
        "Example: Instrument a callback",
        "Example: Instrument asynchronous functions using callbacks",
        "Example: Instrument asynchronous functions using promises",
        "Example: Instrument async functions",
        "Example: Instrument a synchronous function"
      ],
      "title": "Node.js custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Extend your instrumentation"
      ],
      "external_id": "284f422639e1af4a65c26edd4d3f5bc53106e51a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/extend-your-instrumentation/nodejs-custom-instrumentation/",
      "published_at": "2021-06-02T15:04:34Z",
      "updated_at": "2021-03-16T14:59:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic for Node.js automatically instruments most standard web requests, but sometimes you want expanded instrumentation. With the agent's custom instrumentation API, you can create instrumentation for otherwise unsupported web frameworks, datastores, and message service clients. The Node.js agent's custom instrumentation API also allows you to: Create web transactions (useful for things like web sockets, where transactions can't be automatically created). Create non-web background transactions (useful for recording background jobs). Target specific sections of your code for deeper analysis. Agent version requirements The custom instrumentation methods in this document are available as of Node.js agent version 2.0.0. For information on instrumentation using the custom instrumentation API v1.x, see the documentation for legacy Node.js custom instrumentation. Instrument unsupported web frameworks Beginning with Node.js agent version 2.0.0, New Relic provides an API to expand instrumentation for additional web frameworks. For more information, including a tutorial, see the documentation for Node.js web framework instrumentation on GitHub. Instrument unsupported message service clients Beginning with Node.js agent version 2.0.0, New Relic provides an API to expand instrumentation for additional message service libraries. For more information, including a tutorial, see the documentation for Node.js message service client instrumentation on GitHub. Instrument unsupported datastores Beginning with Node.js agent version 2.0.0, New Relic provides an API to expand instrumentation for additional datastore libraries. For more information, including a tutorial, see the documentation for Node.js datastore instrumentation on GitHub. Instrument web transactions In order to create custom web transactions, call startWebTransaction to start the transaction. To end the transaction, use any of these options: Ending the transaction Comments Promise If the handler passed to startWebTransaction returns a promise, the agent will end the transaction when the returned promise resolves or rejects. Manual If you call getTransaction in the context of the new transaction, this notifies the agent that the transaction will be handled manually. If getTransaction is called in the handler, then you must end the transaction by calling transaction.end(). Synchronous If neither of these options are fulfilled, the transaction will be ended when the handler returns synchronously. Custom web transaction example: Instrument three transactions in socket.io This example instruments a /websocket/ping transaction, a /websocket/update transaction, and a /websocket/new-message transaction within socket.io. The /ping example is synchronous, while the /new-message and /update examples are asynchronous. var nr = require('newrelic') var app = require('http').createServer() var io = require('socket.io')(app) io.on('connection', function (socket) { socket.on('ping', function (data) { nr.startWebTransaction('/websocket/ping', function transactionHandler() { // Ended automatically after synchronously returning socket.emit('pong') }) }) socket.on('update', function (data) { nr.startWebTransaction('/websocket/update', function transactionHandler() { // Using API#getTransaction var transaction = nr.getTransaction() updateChatWindow(data, function transactionHandler() { socket.emit('update-done') transaction.end() }) }) }) socket.on('new-message', function (data) { nr.startWebTransaction('/websocket/new-message', function transactionHandler() { // Returning a promise return new Promise(function (resolve, reject) { addMessageToChat(data, function () { socket.emit('message-received') resolve() }) }) }) }) }) Copy This method only gives basic timing data for the transaction created. To create more intricate timing data and transaction naming for a particular framework, see the Node.js API documentation and the related tutorial on GitHub. Instrument background transactions You can use custom transactions to instrument non-web transactions (background tasks); for example: Periodic jobs within your app Work that continues after a request completes To instrument background tasks, call startBackgroundTransaction in your handler to start a background transaction. To end the transaction, use any of these options: Ending the transaction Comments Promise If the handler passed to startBackgroundTransaction returns a promise, the agent will end the transaction when the returned promise resolves or rejects. Manual If you call getTransaction in the context of the new transaction, this notifies the agent that the transaction will be handled manually. If getTransaction is called in the handler, then you must end the transaction by calling transaction.end(). Synchronous If neither of these options are fulfilled, the transaction will be ended when the handler returns synchronously. Custom background transaction example: Instrument within setInterval This example instruments update:cache within setInterval: var nr = require('newrelic') var redis = require('redis').createClient() // Using API#getTransaction to manage ending the transaction setInterval(function () { nr.startBackgroundTransaction('update:cache', function transactionHandler() { var newValue = someDataGenerator() var transaction = nr.getTransaction() redis.set('some:cache:key', newValue, function () { transaction.end() }) }) }, 30000) // Every 30s //Using a promise to manage ending the transaction setInterval(function () { nr.startBackgroundTransaction('flush:cache', function transactionHandler() { return new Promise(function(resolve, reject) { flushCache(redis, function afterFlush(err) { if (err) { return reject(err) } resolve() }) }) }) }, 60*60*1000) Copy Expand instrumentation within transactions You can create instrumentation using the instrumentation registration methods on the API. Writing instrumentation using the instrumentation API allows you to specify metrics and naming in greater detail by \"monkey patching\" methods (replacing functions) on relevant objects. Other options can offer visibility into web transactions that are already instrumented, or gain insight into databases and other in-transaction work that is not automatically instrumented. To do this, wrap your callbacks in custom tracers. Custom tracers create and collect specific metrics for an additional segment within an existing transaction, such as a particular function or a database call. To instrument individual callbacks, call startSegment() inside the callback, and move the main callback logic to the handler function. To instrument a function that is called inside an asynchronous function, wrap both the target function and its parent asynchronous function with startSegment(). Important These examples must be placed in code that is running under a transaction. The origin of the transaction, custom or automatically created, does not matter. Example: Instrument a callback This example tracks a single callback: // Wrap the method in a segment. nr.startSegment('db:createObject', true, function(cb) { // This is recorded as the `db:createObject` segment. db.createObject(cb) }, function(err, result) { // This is recorded as the callback to the `db:createObject` segment. if (util.handleError(err, res)) { return } res.write(JSON.stringify(result.rows[0].id)) res.write('\\n') res.end() }) Copy Example: Instrument asynchronous functions using callbacks This example tracks both pg.connect and client.query. This is because client.query is called by an asynchronous parent function (pg.connect). Otherwise, you would not get any data from client.query. This allows startSegment() to propagate the active transaction across those asynchronous boundaries. nr.startSegment('pg:connect', true, function(cb) { pg.connect(config.db_string, cb) }, function(err, client, done) { if (util.handleError(err, '500', res)) { return done() } nr.startSegment('pg:query', true, function(cb) { client.query('SELECT count(*) FROM test_count'), cb) }, function(err, result) { if (util.handleError(err, '500', res)) { return done() } res.write(result.rows[0].count) res.write('\\n') }) }) Copy Example: Instrument asynchronous functions using promises This example is the same as the callback one, but for interacting with a promise-based API. For promises, simply return the promise and call then after startSegment to continue your execution. nr.startSegment('pg:connect', true, function() { // This `pg:connect` segment will time until the returned promise // either resolves or rejects. return pg.connect(config.db_string) }).then(function(client) { // The transaction context is propagated into following promises. return nr.startSegment('pg:query', true, function() { return client.query('SELECT count(*) FROM test_count')) }).then(function(result) { res.write(result.rows[0].count) res.write('\\n') res.end() }, function(err) { // Error from querying. util.handleError(err, '500', res) }).finally(function() { return client.release() }) }, function(err) { // Error from connecting. util.handleError(err, '500', res) }) Copy Example: Instrument async functions This example shows how to instrument code using async/await to control asynchronous work. This requires using Node 8 or higher, as well as the New Relic for Node.js agent v2.3.0 or higher. try { const client = await nr.startSegment('pg:connect', true, async () => { // Async functions simply return promises, so this example is // very similar to the promise one. return await pg.connect(config.db_string) }) // The transaction context is propagated into the code following `await`. try { const result = await nr.startSegment('pg:query', true, async () => { return await client.query('SELECT count(*) FROM test_count')) }) res.write(result.rows[0].count) res.write('\\n') res.end() } catch(err) { // Error from querying. util.handleError(err, '500', res) } finally { await client.release() } } catch(err) { // Error from connecting. util.handleError(err, '500', res) } Copy Example: Instrument a synchronous function This example shows how startSegment can be used to record a synchronous function that is responsible for assigning its return value to a variable. var result = nr.startSegment('calculateTotal', true, function() { return calculateTotal(outerVar1, outerVar2) }) Copy Important The startSegment function is available of the Node Agent 3.3.0 release.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.75642,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Node.js custom <em>instrumentation</em>",
        "sections": "Node.js custom <em>instrumentation</em>",
        "tags": "<em>Extend</em> <em>your</em> <em>instrumentation</em>",
        "body": " analysis. <em>Agent</em> version requirements The custom <em>instrumentation</em> methods in this document are available as of <em>Node.js</em> <em>agent</em> version 2.0.0. For information on <em>instrumentation</em> using the custom <em>instrumentation</em> API v1.x, see the documentation for legacy <em>Node.js</em> custom <em>instrumentation</em>. <em>Instrument</em> unsupported web"
      },
      "id": "603ec39964441f02dc4e8882"
    },
    {
      "sections": [
        "Browser monitoring and the Node.js agent",
        "Insert the JavaScript header",
        "Framework examples",
        "Express and jade",
        "Express and Swig",
        "Hapi.js and handlebars",
        "Disable header generation",
        "Caution"
      ],
      "title": "Browser monitoring and the Node.js agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Extend your instrumentation"
      ],
      "external_id": "8b8cba2d5ce2acdc55df2621d850329cf4796bbd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/extend-your-instrumentation/browser-monitoring-nodejs-agent/",
      "published_at": "2021-06-02T15:16:26Z",
      "updated_at": "2021-03-16T09:02:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the Node.js agent, you can add browser instrumentation to your web pages. To use browser monitoring with your Node.js agent, ensure you have the latest release of the Node.js agent. To enable browser monitoring in the user interface, follow the procedures to install the browser agent. Then follow the procedures in this section to set up the Node.js agent. Insert the JavaScript header Instrumentation for the Node.js agent can continue beyond your application into end users' browsers. The newrelic module can generate script headers which, when inserted into your HTML templates, will capture the end users' page load times. The headers must be manually injected, but no extra configuration is necessary. At the beginning of your html page's head tag, insert the results of newrelic.getBrowserTimingHeader() after any CHARSET meta tags. Exception: For maximum Internet Explorer compatibility, insert the results of newrelic.getBrowserTimingHeader() after any X-UA-COMPATIBLE HTTP-EQUIV meta tags. Call the header once for every request. Do not cache the header. Generating headers is fast, and it does not require your application to make extra requests to New Relic. Framework examples Here are some examples of how to set up browser monitoring with different frameworks and templates. Express and jade This example uses Express, a web application framework, and jade, a template module. Although the specifics are different with other frameworks, this general approach should work in most cases. The simplest way to insert browser timing headings is to pass the newrelic module into your template, and then call newrelic.getBrowsertimingHeader() from within the template. In your app.js: var newrelic = require('newrelic'); var app = require('express')(); // in express, this lets you call newrelic from within a template app.locals.newrelic = newrelic; app.get('/user/:id', function (req, res) { res.render('user'); }); app.listen(process.env.PORT); Copy In your layout.jade: doctype html html head != newrelic.getBrowserTimingHeader() title= title link(rel='stylesheet', href='stylesheets/style.css') body block content Copy Express and Swig This example uses Express with Swig. In your app.js: var newrelic = require('newrelic'); var http = require('http') var path = require('path') var swig = require('swig') var app = require('express')(); app.locals.newrelic = newrelic; //taken from http://paularmstrong.github.io/swig/docs/#express app.engine('html', swig.renderFile); app.set('view engine', 'html'); app.set('views', __dirname + '/views'); app.get('/user/:id', function (req, res) { res.render('user'); }); app.listen(process.env.PORT); Copy In your views/user.html: <!DOCTYPE html> <html> <head> {{ newrelic.getBrowserTimingHeader() }} <title>Hello</title> </head> <body> <h1>Hello World</h1> </body> </html> Copy Hapi.js and handlebars This example uses hapi.js and handlebars. Other similar templating languages typically require triple brackets; for example, using mustache with hogan-express. This helps prevent escaping of the script content. Using hapi, in your app.js: var newrelic = require('newrelic'); var Hapi = require('hapi'); var server = new Hapi.Server(parseInt(PORT), '0.0.0.0', { views: { engines : {html: 'handlebars' }, path : __dirname + '/templates' } }); function homepage(request, reply) { var context = { // pass in the header each request nreum : newrelic.getBrowserTimingHeader(), content : ... }; reply.view('homepage', context); }; server.route({ method : 'GET', path : '/', handler : homepage }); server.start(); Copy In your templates/homepage.html: <!DOCTYPE html> <html> <head> {{{ nreum }}} <title>Hello</title> </head> <body> {{ content }} </body> </html> Copy Disable header generation By default, calls to newrelic.getBrowserTimingHeader() should return valid headers. To disable header generation without removing your template code: In your newrelic.js file, add: browser_monitoring : { enable : false } Copy You can also set the environment variable NEW_RELIC_BROWSER_MONITOR_ENABLE=false. Caution Always leave ssl between the agent and the New Relic collector when using browser monitoring. You can safely leave the API calls in place even if you are not using browser monitoring or the newrelic module. If browser monitoring is disabled, or if there is an error so that working headers cannot be generated, the newrelic module generates an innocuous HTML comment. If you disable the newrelic module completely, no content will be generated.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.71094,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Browser monitoring and the Node.js <em>agent</em>",
        "sections": "Browser monitoring and the Node.js <em>agent</em>",
        "tags": "<em>Extend</em> <em>your</em> <em>instrumentation</em>",
        "body": "With the <em>Node.js</em> <em>agent</em>, you can add browser <em>instrumentation</em> to <em>your</em> web pages. To use browser monitoring with <em>your</em> <em>Node.js</em> <em>agent</em>, ensure you have the latest release of the <em>Node.js</em> <em>agent</em>. To enable browser monitoring in the user interface, follow the procedures to install the browser <em>agent</em>"
      },
      "id": "603e8376e7b9d2b7472a07f7"
    }
  ],
  "/docs/agents/nodejs-agent/extend-your-instrumentation/nodejs-vms-statistics-page": [
    {
      "sections": [
        "Node.js custom instrumentation",
        "Agent version requirements",
        "Instrument unsupported web frameworks",
        "Instrument unsupported message service clients",
        "Instrument unsupported datastores",
        "Instrument web transactions",
        "Custom web transaction example: Instrument three transactions in socket.io",
        "Instrument background transactions",
        "Custom background transaction example: Instrument within setInterval",
        "Expand instrumentation within transactions",
        "Important",
        "Example: Instrument a callback",
        "Example: Instrument asynchronous functions using callbacks",
        "Example: Instrument asynchronous functions using promises",
        "Example: Instrument async functions",
        "Example: Instrument a synchronous function"
      ],
      "title": "Node.js custom instrumentation",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Extend your instrumentation"
      ],
      "external_id": "284f422639e1af4a65c26edd4d3f5bc53106e51a",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/extend-your-instrumentation/nodejs-custom-instrumentation/",
      "published_at": "2021-06-02T15:04:34Z",
      "updated_at": "2021-03-16T14:59:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic for Node.js automatically instruments most standard web requests, but sometimes you want expanded instrumentation. With the agent's custom instrumentation API, you can create instrumentation for otherwise unsupported web frameworks, datastores, and message service clients. The Node.js agent's custom instrumentation API also allows you to: Create web transactions (useful for things like web sockets, where transactions can't be automatically created). Create non-web background transactions (useful for recording background jobs). Target specific sections of your code for deeper analysis. Agent version requirements The custom instrumentation methods in this document are available as of Node.js agent version 2.0.0. For information on instrumentation using the custom instrumentation API v1.x, see the documentation for legacy Node.js custom instrumentation. Instrument unsupported web frameworks Beginning with Node.js agent version 2.0.0, New Relic provides an API to expand instrumentation for additional web frameworks. For more information, including a tutorial, see the documentation for Node.js web framework instrumentation on GitHub. Instrument unsupported message service clients Beginning with Node.js agent version 2.0.0, New Relic provides an API to expand instrumentation for additional message service libraries. For more information, including a tutorial, see the documentation for Node.js message service client instrumentation on GitHub. Instrument unsupported datastores Beginning with Node.js agent version 2.0.0, New Relic provides an API to expand instrumentation for additional datastore libraries. For more information, including a tutorial, see the documentation for Node.js datastore instrumentation on GitHub. Instrument web transactions In order to create custom web transactions, call startWebTransaction to start the transaction. To end the transaction, use any of these options: Ending the transaction Comments Promise If the handler passed to startWebTransaction returns a promise, the agent will end the transaction when the returned promise resolves or rejects. Manual If you call getTransaction in the context of the new transaction, this notifies the agent that the transaction will be handled manually. If getTransaction is called in the handler, then you must end the transaction by calling transaction.end(). Synchronous If neither of these options are fulfilled, the transaction will be ended when the handler returns synchronously. Custom web transaction example: Instrument three transactions in socket.io This example instruments a /websocket/ping transaction, a /websocket/update transaction, and a /websocket/new-message transaction within socket.io. The /ping example is synchronous, while the /new-message and /update examples are asynchronous. var nr = require('newrelic') var app = require('http').createServer() var io = require('socket.io')(app) io.on('connection', function (socket) { socket.on('ping', function (data) { nr.startWebTransaction('/websocket/ping', function transactionHandler() { // Ended automatically after synchronously returning socket.emit('pong') }) }) socket.on('update', function (data) { nr.startWebTransaction('/websocket/update', function transactionHandler() { // Using API#getTransaction var transaction = nr.getTransaction() updateChatWindow(data, function transactionHandler() { socket.emit('update-done') transaction.end() }) }) }) socket.on('new-message', function (data) { nr.startWebTransaction('/websocket/new-message', function transactionHandler() { // Returning a promise return new Promise(function (resolve, reject) { addMessageToChat(data, function () { socket.emit('message-received') resolve() }) }) }) }) }) Copy This method only gives basic timing data for the transaction created. To create more intricate timing data and transaction naming for a particular framework, see the Node.js API documentation and the related tutorial on GitHub. Instrument background transactions You can use custom transactions to instrument non-web transactions (background tasks); for example: Periodic jobs within your app Work that continues after a request completes To instrument background tasks, call startBackgroundTransaction in your handler to start a background transaction. To end the transaction, use any of these options: Ending the transaction Comments Promise If the handler passed to startBackgroundTransaction returns a promise, the agent will end the transaction when the returned promise resolves or rejects. Manual If you call getTransaction in the context of the new transaction, this notifies the agent that the transaction will be handled manually. If getTransaction is called in the handler, then you must end the transaction by calling transaction.end(). Synchronous If neither of these options are fulfilled, the transaction will be ended when the handler returns synchronously. Custom background transaction example: Instrument within setInterval This example instruments update:cache within setInterval: var nr = require('newrelic') var redis = require('redis').createClient() // Using API#getTransaction to manage ending the transaction setInterval(function () { nr.startBackgroundTransaction('update:cache', function transactionHandler() { var newValue = someDataGenerator() var transaction = nr.getTransaction() redis.set('some:cache:key', newValue, function () { transaction.end() }) }) }, 30000) // Every 30s //Using a promise to manage ending the transaction setInterval(function () { nr.startBackgroundTransaction('flush:cache', function transactionHandler() { return new Promise(function(resolve, reject) { flushCache(redis, function afterFlush(err) { if (err) { return reject(err) } resolve() }) }) }) }, 60*60*1000) Copy Expand instrumentation within transactions You can create instrumentation using the instrumentation registration methods on the API. Writing instrumentation using the instrumentation API allows you to specify metrics and naming in greater detail by \"monkey patching\" methods (replacing functions) on relevant objects. Other options can offer visibility into web transactions that are already instrumented, or gain insight into databases and other in-transaction work that is not automatically instrumented. To do this, wrap your callbacks in custom tracers. Custom tracers create and collect specific metrics for an additional segment within an existing transaction, such as a particular function or a database call. To instrument individual callbacks, call startSegment() inside the callback, and move the main callback logic to the handler function. To instrument a function that is called inside an asynchronous function, wrap both the target function and its parent asynchronous function with startSegment(). Important These examples must be placed in code that is running under a transaction. The origin of the transaction, custom or automatically created, does not matter. Example: Instrument a callback This example tracks a single callback: // Wrap the method in a segment. nr.startSegment('db:createObject', true, function(cb) { // This is recorded as the `db:createObject` segment. db.createObject(cb) }, function(err, result) { // This is recorded as the callback to the `db:createObject` segment. if (util.handleError(err, res)) { return } res.write(JSON.stringify(result.rows[0].id)) res.write('\\n') res.end() }) Copy Example: Instrument asynchronous functions using callbacks This example tracks both pg.connect and client.query. This is because client.query is called by an asynchronous parent function (pg.connect). Otherwise, you would not get any data from client.query. This allows startSegment() to propagate the active transaction across those asynchronous boundaries. nr.startSegment('pg:connect', true, function(cb) { pg.connect(config.db_string, cb) }, function(err, client, done) { if (util.handleError(err, '500', res)) { return done() } nr.startSegment('pg:query', true, function(cb) { client.query('SELECT count(*) FROM test_count'), cb) }, function(err, result) { if (util.handleError(err, '500', res)) { return done() } res.write(result.rows[0].count) res.write('\\n') }) }) Copy Example: Instrument asynchronous functions using promises This example is the same as the callback one, but for interacting with a promise-based API. For promises, simply return the promise and call then after startSegment to continue your execution. nr.startSegment('pg:connect', true, function() { // This `pg:connect` segment will time until the returned promise // either resolves or rejects. return pg.connect(config.db_string) }).then(function(client) { // The transaction context is propagated into following promises. return nr.startSegment('pg:query', true, function() { return client.query('SELECT count(*) FROM test_count')) }).then(function(result) { res.write(result.rows[0].count) res.write('\\n') res.end() }, function(err) { // Error from querying. util.handleError(err, '500', res) }).finally(function() { return client.release() }) }, function(err) { // Error from connecting. util.handleError(err, '500', res) }) Copy Example: Instrument async functions This example shows how to instrument code using async/await to control asynchronous work. This requires using Node 8 or higher, as well as the New Relic for Node.js agent v2.3.0 or higher. try { const client = await nr.startSegment('pg:connect', true, async () => { // Async functions simply return promises, so this example is // very similar to the promise one. return await pg.connect(config.db_string) }) // The transaction context is propagated into the code following `await`. try { const result = await nr.startSegment('pg:query', true, async () => { return await client.query('SELECT count(*) FROM test_count')) }) res.write(result.rows[0].count) res.write('\\n') res.end() } catch(err) { // Error from querying. util.handleError(err, '500', res) } finally { await client.release() } } catch(err) { // Error from connecting. util.handleError(err, '500', res) } Copy Example: Instrument a synchronous function This example shows how startSegment can be used to record a synchronous function that is responsible for assigning its return value to a variable. var result = nr.startSegment('calculateTotal', true, function() { return calculateTotal(outerVar1, outerVar2) }) Copy Important The startSegment function is available of the Node Agent 3.3.0 release.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.75642,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Node.js custom <em>instrumentation</em>",
        "sections": "Node.js custom <em>instrumentation</em>",
        "tags": "<em>Extend</em> <em>your</em> <em>instrumentation</em>",
        "body": " analysis. <em>Agent</em> version requirements The custom <em>instrumentation</em> methods in this document are available as of <em>Node.js</em> <em>agent</em> version 2.0.0. For information on <em>instrumentation</em> using the custom <em>instrumentation</em> API v1.x, see the documentation for legacy <em>Node.js</em> custom <em>instrumentation</em>. <em>Instrument</em> unsupported web"
      },
      "id": "603ec39964441f02dc4e8882"
    },
    {
      "sections": [
        "Browser monitoring and the Node.js agent",
        "Insert the JavaScript header",
        "Framework examples",
        "Express and jade",
        "Express and Swig",
        "Hapi.js and handlebars",
        "Disable header generation",
        "Caution"
      ],
      "title": "Browser monitoring and the Node.js agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Extend your instrumentation"
      ],
      "external_id": "8b8cba2d5ce2acdc55df2621d850329cf4796bbd",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/extend-your-instrumentation/browser-monitoring-nodejs-agent/",
      "published_at": "2021-06-02T15:16:26Z",
      "updated_at": "2021-03-16T09:02:23Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With the Node.js agent, you can add browser instrumentation to your web pages. To use browser monitoring with your Node.js agent, ensure you have the latest release of the Node.js agent. To enable browser monitoring in the user interface, follow the procedures to install the browser agent. Then follow the procedures in this section to set up the Node.js agent. Insert the JavaScript header Instrumentation for the Node.js agent can continue beyond your application into end users' browsers. The newrelic module can generate script headers which, when inserted into your HTML templates, will capture the end users' page load times. The headers must be manually injected, but no extra configuration is necessary. At the beginning of your html page's head tag, insert the results of newrelic.getBrowserTimingHeader() after any CHARSET meta tags. Exception: For maximum Internet Explorer compatibility, insert the results of newrelic.getBrowserTimingHeader() after any X-UA-COMPATIBLE HTTP-EQUIV meta tags. Call the header once for every request. Do not cache the header. Generating headers is fast, and it does not require your application to make extra requests to New Relic. Framework examples Here are some examples of how to set up browser monitoring with different frameworks and templates. Express and jade This example uses Express, a web application framework, and jade, a template module. Although the specifics are different with other frameworks, this general approach should work in most cases. The simplest way to insert browser timing headings is to pass the newrelic module into your template, and then call newrelic.getBrowsertimingHeader() from within the template. In your app.js: var newrelic = require('newrelic'); var app = require('express')(); // in express, this lets you call newrelic from within a template app.locals.newrelic = newrelic; app.get('/user/:id', function (req, res) { res.render('user'); }); app.listen(process.env.PORT); Copy In your layout.jade: doctype html html head != newrelic.getBrowserTimingHeader() title= title link(rel='stylesheet', href='stylesheets/style.css') body block content Copy Express and Swig This example uses Express with Swig. In your app.js: var newrelic = require('newrelic'); var http = require('http') var path = require('path') var swig = require('swig') var app = require('express')(); app.locals.newrelic = newrelic; //taken from http://paularmstrong.github.io/swig/docs/#express app.engine('html', swig.renderFile); app.set('view engine', 'html'); app.set('views', __dirname + '/views'); app.get('/user/:id', function (req, res) { res.render('user'); }); app.listen(process.env.PORT); Copy In your views/user.html: <!DOCTYPE html> <html> <head> {{ newrelic.getBrowserTimingHeader() }} <title>Hello</title> </head> <body> <h1>Hello World</h1> </body> </html> Copy Hapi.js and handlebars This example uses hapi.js and handlebars. Other similar templating languages typically require triple brackets; for example, using mustache with hogan-express. This helps prevent escaping of the script content. Using hapi, in your app.js: var newrelic = require('newrelic'); var Hapi = require('hapi'); var server = new Hapi.Server(parseInt(PORT), '0.0.0.0', { views: { engines : {html: 'handlebars' }, path : __dirname + '/templates' } }); function homepage(request, reply) { var context = { // pass in the header each request nreum : newrelic.getBrowserTimingHeader(), content : ... }; reply.view('homepage', context); }; server.route({ method : 'GET', path : '/', handler : homepage }); server.start(); Copy In your templates/homepage.html: <!DOCTYPE html> <html> <head> {{{ nreum }}} <title>Hello</title> </head> <body> {{ content }} </body> </html> Copy Disable header generation By default, calls to newrelic.getBrowserTimingHeader() should return valid headers. To disable header generation without removing your template code: In your newrelic.js file, add: browser_monitoring : { enable : false } Copy You can also set the environment variable NEW_RELIC_BROWSER_MONITOR_ENABLE=false. Caution Always leave ssl between the agent and the New Relic collector when using browser monitoring. You can safely leave the API calls in place even if you are not using browser monitoring or the newrelic module. If browser monitoring is disabled, or if there is an error so that working headers cannot be generated, the newrelic module generates an innocuous HTML comment. If you disable the newrelic module completely, no content will be generated.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.71094,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Browser monitoring and the Node.js <em>agent</em>",
        "sections": "Browser monitoring and the Node.js <em>agent</em>",
        "tags": "<em>Extend</em> <em>your</em> <em>instrumentation</em>",
        "body": "With the <em>Node.js</em> <em>agent</em>, you can add browser <em>instrumentation</em> to <em>your</em> web pages. To use browser monitoring with <em>your</em> <em>Node.js</em> <em>agent</em>, ensure you have the latest release of the <em>Node.js</em> <em>agent</em>. To enable browser monitoring in the user interface, follow the procedures to install the browser <em>agent</em>"
      },
      "id": "603e8376e7b9d2b7472a07f7"
    },
    {
      "sections": [
        "Apollo Server plugin and Node.js",
        "Compatibility",
        "GitHub documentation"
      ],
      "title": "Apollo Server plugin and Node.js",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Extend your instrumentation"
      ],
      "external_id": "823dc0152fa10c89d0379c58ab3e8599726e56a9",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/extend-your-instrumentation/apollo-server-plugin-nodejs/",
      "published_at": "2021-06-02T15:16:26Z",
      "updated_at": "2021-03-13T07:26:51Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Apollo Server plugin instruments your Apollo Server applications to give visibility into your GraphQL payloads. This helps you uncover and diagnose the cause of your slow GraphQL queries. Our plugin records overall timings for queries and uses distributed tracing to uncover the route problem. Use this instrumentation to see if the problem arises from resolving a piece of requested data or if it stems from work done on other services or databases. Compatibility The New Relic plugin works with the following Apollo Server modules: apollo-server apollo-server-express apollo-server-hapi apollo-server-koa apollo-server-fastify Because fastify is not fully instrumented in the Node.js agent, transactions are prefixed with WebTransaction\\Nodejs. Other plugins may work, depending on their underlying implementation, but they have not been verified. GitHub documentation For detailed information about installation, configuration, transaction details, metrics, segments, errors, testing, troubleshooting, and more, see New Relic's Apollo Server plugin documentation on GitHub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 138.16946,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Extend</em> <em>your</em> <em>instrumentation</em>",
        "body": "-hapi apollo-server-koa apollo-server-fastify Because fastify is not fully instrumented in the <em>Node.js</em> <em>agent</em>, transactions are prefixed with WebTransaction\\<em>Nodejs</em>. Other plugins may work, depending on their underlying implementation, but they have not been verified. GitHub documentation For detailed"
      },
      "id": "6043cd9528ccbceaf72c60be"
    }
  ],
  "/docs/agents/nodejs-agent/getting-started/apm-agent-security-nodejs": [
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.448135,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the Java <em>agent</em>",
        "sections": "Compatibility and requirements for the Java <em>agent</em>",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " method. The Java <em>agent</em> reports the database name and database server&#x2F;identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, <em>get</em> support at support.newrelic.com. Hosting services You can install"
      },
      "id": "6043b8f6196a6771a9960f87"
    },
    {
      "sections": [
        "APM agent security: Java",
        "Default security settings",
        "Caution",
        "High security mode settings",
        "Custom security settings"
      ],
      "title": "APM agent security: Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "fd9f5744c001453dbb9f129480f4e7e5ce42a176",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/apm-agent-security-java/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives, you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see Java agent error configuration. By default, here is how the New Relic Java agent handles the following potentially sensitive data:: Request parameters: The agent does not capture HTTP request parameters. HTTPS: The agent communicates with New Relic using HTTPS. SQL: The agent sets SQL recording to obfuscated, which removes the potentially sensitive numeric and string literal values. High security mode settings When you enable high security mode, the default settings are locked so that users cannot change them. In addition: The agent does not collect message queue parameters. You cannot create custom events. You cannot implement custom instrumentation using the Custom Instrumentation Editor. You cannot collect user attributes. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: Java agent configuration file Custom attributes Java agent API Setting Effects on data security audit_mode boolean Default: false By default, the Java agent does not log all data sent to New Relic in the agent log file. If you set this to true, the agent logs data sent to the New Relic collector in the agent log file. You can then evaluate the information that the agent sends by reviewing the agent log file to see if it includes sensitive information. high_security boolean Default: false To enable high security mode, set this to true and enable high security in New Relic. This restricts the information you can send to New Relic. proxy_host string Default: (none) Some proxies default to using HTTP, which is a less secure protocol. attributes.enabled boolean Default: true Default for the Custom Instrumentation Editor: false By default, you are sending attributes to New Relic, except for methods instrumented using the Custom Instrumentation Editor. If you do not want to send attributes to New Relic, set this to false. attributes.exclude string Default: (none) If there are specific attribute keys that you do not want to send to New Relic in transaction traces, identify them using attributes.exclude. This restricts the information sent to New Relic. Consider if you want to exclude these potentially sensitive attributes using attributes.exclude or if you need the information sent to New Relic: request.headers.*: Removes all request headers. (Note that HTTP headers that contain sensitive data such as cookie and authorization are never collected.) response.headers.*: Removes all response headers. request_uri: Removes the path for the transaction's incoming request. log_sql boolean Default: false By default, you are sending queries to New Relic using record_sql. If you want to log queries in the agent log file as well as send them to New Relic, set this to true. record_sql string Default: obfuscated By default, record_sql is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to off. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. strip_exception_messages boolean Default: false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. If you are not using high security mode but still want to strip messages from all exceptions except those in your allow list, set this to true. custom_insights_events.enabled boolean Default: true By default, the agent records events sent to the Event API via recordCustomEvent(). If you enable high security mode, this is automatically set to false.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.44803,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>agent</em> security: Java",
        "sections": "APM <em>agent</em> security: Java",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": "The New Relic Java <em>agent</em> default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives"
      },
      "id": "6043b8bb28ccbc3db92c60b7"
    },
    {
      "sections": [
        "APM agent security: PHP",
        "Default security settings",
        "High security mode settings",
        "Custom security settings",
        "Caution",
        "For more help"
      ],
      "title": "APM agent security: PHP",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "Getting started"
      ],
      "external_id": "596768c4a7e0d13fe9949726b49ab09167759582",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/getting-started/apm-agent-security-php/",
      "published_at": "2021-06-02T15:08:42Z",
      "updated_at": "2021-06-02T15:08:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The PHP agent default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives, you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Default security settings By default, here is how the New Relic PHP agent handles the following potentially sensitive data: Request parameters: The agent does not capture HTTP request parameters. HTTPS: The agent communicates with New Relic using HTTPS. SQL: The agent sets SQL recording to obfuscated, which removes the potentially sensitive numeric and string literal values. High security mode settings When you enable high security mode, the default settings are locked so that users cannot change them. In addition: You cannot create custom events. The agent strips exception messages from errors. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: PHP agent configuration file Attribute settings PHP agent API Setting Effects on data security newrelic.daemon.auditlog string Default: (none) If you use this to set the name of the audit log file, the agent will log details of messages passed back and forth between the monitored process and the New Relic collector. You can then evaluate the information that the agent sends to the New Relic collector to see if it includes sensitive information. newrelic.high_security boolean Default: false To enable high security mode, set this to true and enable high security in New Relic. This restricts the information you can send to New Relic. newrelic.daemon.proxy string Default: (none) Some proxies default to using HTTP, which is a less secure protocol. newrelic.attributes.enabled boolean Default: true By default, you are sending attributes to New Relic. If you do not want to send attributes to New Relic, set this to false. newrelic.attributes.exclude string Default: (none) If there are specific attribute keys that you do not want to send to New Relic in transaction traces, identify them using newrelic.attributes.exclude. This restricts the information sent to New Relic. Consider if you want to exclude these potentially sensitive attributes using newrelic.attributes.exclude or if you need the information sent to New Relic: request.headers.*: Removes all request headers. response.headers.*: Removes all response headers. newrelic.custom_insights_events.enabled boolean Default: true By default, the agent records events sent to the Event API via newrelic_record_custom_event(). If you enable high security mode, this is automatically set to false. newrelic.transaction_tracer.record_sql string Default: obfuscated By default, newrelic.transaction_tracer.record_sql is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to off. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. For more help If you need more help, check out these support and learning resources: Suggest a change and learn how to contribute to our PHP agent open source repository. Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.364136,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>agent</em> security: PHP",
        "sections": "APM <em>agent</em> security: PHP",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " a change and learn how to contribute to our PHP <em>agent</em> open source repository. Browse the Explorers Hub to <em>get</em> help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic&#x27;s data security and licenses documentation."
      },
      "id": "6043da63196a67cb6f960f6a"
    }
  ],
  "/docs/agents/nodejs-agent/getting-started/compatibility-requirements-nodejs-agent": [
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.44803,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the Java <em>agent</em>",
        "sections": "Compatibility and requirements for the Java <em>agent</em>",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " method. The Java <em>agent</em> reports the database name and database server&#x2F;identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, <em>get</em> support at support.newrelic.com. Hosting services You can install"
      },
      "id": "6043b8f6196a6771a9960f87"
    },
    {
      "sections": [
        "APM agent security: Java",
        "Default security settings",
        "Caution",
        "High security mode settings",
        "Custom security settings"
      ],
      "title": "APM agent security: Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "fd9f5744c001453dbb9f129480f4e7e5ce42a176",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/apm-agent-security-java/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives, you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see Java agent error configuration. By default, here is how the New Relic Java agent handles the following potentially sensitive data:: Request parameters: The agent does not capture HTTP request parameters. HTTPS: The agent communicates with New Relic using HTTPS. SQL: The agent sets SQL recording to obfuscated, which removes the potentially sensitive numeric and string literal values. High security mode settings When you enable high security mode, the default settings are locked so that users cannot change them. In addition: The agent does not collect message queue parameters. You cannot create custom events. You cannot implement custom instrumentation using the Custom Instrumentation Editor. You cannot collect user attributes. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: Java agent configuration file Custom attributes Java agent API Setting Effects on data security audit_mode boolean Default: false By default, the Java agent does not log all data sent to New Relic in the agent log file. If you set this to true, the agent logs data sent to the New Relic collector in the agent log file. You can then evaluate the information that the agent sends by reviewing the agent log file to see if it includes sensitive information. high_security boolean Default: false To enable high security mode, set this to true and enable high security in New Relic. This restricts the information you can send to New Relic. proxy_host string Default: (none) Some proxies default to using HTTP, which is a less secure protocol. attributes.enabled boolean Default: true Default for the Custom Instrumentation Editor: false By default, you are sending attributes to New Relic, except for methods instrumented using the Custom Instrumentation Editor. If you do not want to send attributes to New Relic, set this to false. attributes.exclude string Default: (none) If there are specific attribute keys that you do not want to send to New Relic in transaction traces, identify them using attributes.exclude. This restricts the information sent to New Relic. Consider if you want to exclude these potentially sensitive attributes using attributes.exclude or if you need the information sent to New Relic: request.headers.*: Removes all request headers. (Note that HTTP headers that contain sensitive data such as cookie and authorization are never collected.) response.headers.*: Removes all response headers. request_uri: Removes the path for the transaction's incoming request. log_sql boolean Default: false By default, you are sending queries to New Relic using record_sql. If you want to log queries in the agent log file as well as send them to New Relic, set this to true. record_sql string Default: obfuscated By default, record_sql is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to off. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. strip_exception_messages boolean Default: false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. If you are not using high security mode but still want to strip messages from all exceptions except those in your allow list, set this to true. custom_insights_events.enabled boolean Default: true By default, the agent records events sent to the Event API via recordCustomEvent(). If you enable high security mode, this is automatically set to false.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.44792,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>agent</em> security: Java",
        "sections": "APM <em>agent</em> security: Java",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": "The New Relic Java <em>agent</em> default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives"
      },
      "id": "6043b8bb28ccbc3db92c60b7"
    },
    {
      "sections": [
        "APM agent security: PHP",
        "Default security settings",
        "High security mode settings",
        "Custom security settings",
        "Caution",
        "For more help"
      ],
      "title": "APM agent security: PHP",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "Getting started"
      ],
      "external_id": "596768c4a7e0d13fe9949726b49ab09167759582",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/getting-started/apm-agent-security-php/",
      "published_at": "2021-06-02T15:08:42Z",
      "updated_at": "2021-06-02T15:08:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The PHP agent default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives, you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Default security settings By default, here is how the New Relic PHP agent handles the following potentially sensitive data: Request parameters: The agent does not capture HTTP request parameters. HTTPS: The agent communicates with New Relic using HTTPS. SQL: The agent sets SQL recording to obfuscated, which removes the potentially sensitive numeric and string literal values. High security mode settings When you enable high security mode, the default settings are locked so that users cannot change them. In addition: You cannot create custom events. The agent strips exception messages from errors. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: PHP agent configuration file Attribute settings PHP agent API Setting Effects on data security newrelic.daemon.auditlog string Default: (none) If you use this to set the name of the audit log file, the agent will log details of messages passed back and forth between the monitored process and the New Relic collector. You can then evaluate the information that the agent sends to the New Relic collector to see if it includes sensitive information. newrelic.high_security boolean Default: false To enable high security mode, set this to true and enable high security in New Relic. This restricts the information you can send to New Relic. newrelic.daemon.proxy string Default: (none) Some proxies default to using HTTP, which is a less secure protocol. newrelic.attributes.enabled boolean Default: true By default, you are sending attributes to New Relic. If you do not want to send attributes to New Relic, set this to false. newrelic.attributes.exclude string Default: (none) If there are specific attribute keys that you do not want to send to New Relic in transaction traces, identify them using newrelic.attributes.exclude. This restricts the information sent to New Relic. Consider if you want to exclude these potentially sensitive attributes using newrelic.attributes.exclude or if you need the information sent to New Relic: request.headers.*: Removes all request headers. response.headers.*: Removes all response headers. newrelic.custom_insights_events.enabled boolean Default: true By default, the agent records events sent to the Event API via newrelic_record_custom_event(). If you enable high security mode, this is automatically set to false. newrelic.transaction_tracer.record_sql string Default: obfuscated By default, newrelic.transaction_tracer.record_sql is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to off. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. For more help If you need more help, check out these support and learning resources: Suggest a change and learn how to contribute to our PHP agent open source repository. Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.364044,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>agent</em> security: PHP",
        "sections": "APM <em>agent</em> security: PHP",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " a change and learn how to contribute to our PHP <em>agent</em> open source repository. Browse the Explorers Hub to <em>get</em> help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic&#x27;s data security and licenses documentation."
      },
      "id": "6043da63196a67cb6f960f6a"
    }
  ],
  "/docs/agents/nodejs-agent/getting-started/introduction-new-relic-nodejs": [
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.44803,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the Java <em>agent</em>",
        "sections": "Compatibility and requirements for the Java <em>agent</em>",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " method. The Java <em>agent</em> reports the database name and database server&#x2F;identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, <em>get</em> support at support.newrelic.com. Hosting services You can install"
      },
      "id": "6043b8f6196a6771a9960f87"
    },
    {
      "sections": [
        "APM agent security: Java",
        "Default security settings",
        "Caution",
        "High security mode settings",
        "Custom security settings"
      ],
      "title": "APM agent security: Java",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "fd9f5744c001453dbb9f129480f4e7e5ce42a176",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/apm-agent-security-java/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:25Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The New Relic Java agent default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives, you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Default security settings Caution Stack traces cannot be obfuscated and may contain sensitive information, including SQL queries. For more information about ignoring errors, see Java agent error configuration. By default, here is how the New Relic Java agent handles the following potentially sensitive data:: Request parameters: The agent does not capture HTTP request parameters. HTTPS: The agent communicates with New Relic using HTTPS. SQL: The agent sets SQL recording to obfuscated, which removes the potentially sensitive numeric and string literal values. High security mode settings When you enable high security mode, the default settings are locked so that users cannot change them. In addition: The agent does not collect message queue parameters. You cannot create custom events. You cannot implement custom instrumentation using the Custom Instrumentation Editor. You cannot collect user attributes. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: Java agent configuration file Custom attributes Java agent API Setting Effects on data security audit_mode boolean Default: false By default, the Java agent does not log all data sent to New Relic in the agent log file. If you set this to true, the agent logs data sent to the New Relic collector in the agent log file. You can then evaluate the information that the agent sends by reviewing the agent log file to see if it includes sensitive information. high_security boolean Default: false To enable high security mode, set this to true and enable high security in New Relic. This restricts the information you can send to New Relic. proxy_host string Default: (none) Some proxies default to using HTTP, which is a less secure protocol. attributes.enabled boolean Default: true Default for the Custom Instrumentation Editor: false By default, you are sending attributes to New Relic, except for methods instrumented using the Custom Instrumentation Editor. If you do not want to send attributes to New Relic, set this to false. attributes.exclude string Default: (none) If there are specific attribute keys that you do not want to send to New Relic in transaction traces, identify them using attributes.exclude. This restricts the information sent to New Relic. Consider if you want to exclude these potentially sensitive attributes using attributes.exclude or if you need the information sent to New Relic: request.headers.*: Removes all request headers. (Note that HTTP headers that contain sensitive data such as cookie and authorization are never collected.) response.headers.*: Removes all response headers. request_uri: Removes the path for the transaction's incoming request. log_sql boolean Default: false By default, you are sending queries to New Relic using record_sql. If you want to log queries in the agent log file as well as send them to New Relic, set this to true. record_sql string Default: obfuscated By default, record_sql is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to off. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. strip_exception_messages boolean Default: false By default, this is set to false, which means that the agent sends messages from all exceptions to the New Relic collector. If you enable high security mode, this is automatically changed to true, and the agent strips the messages from exceptions. If you are not using high security mode but still want to strip messages from all exceptions except those in your allow list, set this to true. custom_insights_events.enabled boolean Default: true By default, the agent records events sent to the Event API via recordCustomEvent(). If you enable high security mode, this is automatically set to false.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.44792,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>agent</em> security: Java",
        "sections": "APM <em>agent</em> security: Java",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": "The New Relic Java <em>agent</em> default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives"
      },
      "id": "6043b8bb28ccbc3db92c60b7"
    },
    {
      "sections": [
        "APM agent security: PHP",
        "Default security settings",
        "High security mode settings",
        "Custom security settings",
        "Caution",
        "For more help"
      ],
      "title": "APM agent security: PHP",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "Getting started"
      ],
      "external_id": "596768c4a7e0d13fe9949726b49ab09167759582",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/getting-started/apm-agent-security-php/",
      "published_at": "2021-06-02T15:08:42Z",
      "updated_at": "2021-06-02T15:08:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The PHP agent default security settings automatically provide security for your APM data to ensure data privacy and to limit the kind of information New Relic receives. You may have business reasons to change these settings. If you want to restrict the information that New Relic receives, you can enable high security mode. If high security mode or the default settings do not work for your business needs, you can apply custom settings. For more information about New Relic's security measures, see our security and privacy documentation, or visit the New Relic security website. Default security settings By default, here is how the New Relic PHP agent handles the following potentially sensitive data: Request parameters: The agent does not capture HTTP request parameters. HTTPS: The agent communicates with New Relic using HTTPS. SQL: The agent sets SQL recording to obfuscated, which removes the potentially sensitive numeric and string literal values. High security mode settings When you enable high security mode, the default settings are locked so that users cannot change them. In addition: You cannot create custom events. The agent strips exception messages from errors. Custom security settings Caution If you customize security settings, it may impact the security of your application. If you need different security settings than default or high security mode, you can customize these settings: PHP agent configuration file Attribute settings PHP agent API Setting Effects on data security newrelic.daemon.auditlog string Default: (none) If you use this to set the name of the audit log file, the agent will log details of messages passed back and forth between the monitored process and the New Relic collector. You can then evaluate the information that the agent sends to the New Relic collector to see if it includes sensitive information. newrelic.high_security boolean Default: false To enable high security mode, set this to true and enable high security in New Relic. This restricts the information you can send to New Relic. newrelic.daemon.proxy string Default: (none) Some proxies default to using HTTP, which is a less secure protocol. newrelic.attributes.enabled boolean Default: true By default, you are sending attributes to New Relic. If you do not want to send attributes to New Relic, set this to false. newrelic.attributes.exclude string Default: (none) If there are specific attribute keys that you do not want to send to New Relic in transaction traces, identify them using newrelic.attributes.exclude. This restricts the information sent to New Relic. Consider if you want to exclude these potentially sensitive attributes using newrelic.attributes.exclude or if you need the information sent to New Relic: request.headers.*: Removes all request headers. response.headers.*: Removes all response headers. newrelic.custom_insights_events.enabled boolean Default: true By default, the agent records events sent to the Event API via newrelic_record_custom_event(). If you enable high security mode, this is automatically set to false. newrelic.transaction_tracer.record_sql string Default: obfuscated By default, newrelic.transaction_tracer.record_sql is set to obfuscated, which strips out the numeric and string literals. If you do not want the agent to capture query information, set this to off. If you want the agent to capture all query information in its original form, set this to raw. When you enable high security mode, this is automatically set to obfuscated. For more help If you need more help, check out these support and learning resources: Suggest a change and learn how to contribute to our PHP agent open source repository. Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 115.364044,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "APM <em>agent</em> security: PHP",
        "sections": "APM <em>agent</em> security: PHP",
        "tags": "<em>Getting</em> <em>started</em>",
        "body": " a change and learn how to contribute to our PHP <em>agent</em> open source repository. Browse the Explorers Hub to <em>get</em> help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic&#x27;s data security and licenses documentation."
      },
      "id": "6043da63196a67cb6f960f6a"
    }
  ],
  "/docs/agents/nodejs-agent/hosting-services/install-new-relic-nodejs-agent-gae-flexible-environment": [
    {
      "sections": [
        "Node.js agent and Heroku",
        "Install the agent add-on",
        "Troubleshoot your installation",
        "Customize your configuration",
        "Upgrade from an existing New Relic installation",
        "For more help"
      ],
      "title": "Node.js agent and Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Hosting services"
      ],
      "external_id": "5a5a3dc52312ca8d70d4bb08c4b15df3209764a3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/hosting-services/nodejs-agent-heroku/",
      "published_at": "2021-06-02T20:27:19Z",
      "updated_at": "2021-03-11T09:41:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Node.js. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Here we describe special considerations for using Heroku as a hosting service with New Relic's Node.js agent. Install the agent add-on After deploying your Node.js app on Heroku, install the New Relic agent. Installing the add-on automatically creates a private New Relic account and configures access for Heroku servers. To install the New Relic add-on through the Heroku website's Add-on page for New Relic, you must be logged in to Heroku. From Heroku's Add-on page for New Relic, select the appropriate subscription plan. Then run this toolbelt command: heroku addons:create newrelic:$planlevel Copy From Select an app, select your New Relic app. Use this toolbelt command to give your app a descriptive name: heroku config:set NEW_RELIC_APP_NAME='Your Application Name' Copy If you are using environment variables instead of your newrelic.js config file settings to customize your Node.js agent configuration, use this toolbelt command: heroku config:set NEW_RELIC_NO_CONFIG_FILE='true' Copy Verify your New Relic app name, license key, and log setting: heroku config Copy Install the Node.js agent and save to your npm dependencies. npm install newrelic --save Copy To ensure that the newrelic package is properly included in your package.json file when you push to Heroku, install the New Relic Node.js agent package on your local system. Include New Relic on the first line of your app's main module: require ('newrelic'); Copy Run the following commands: git add . && git commit -m \"Add New Relic\" git push heroku master && heroku logs --tail Copy Restart your dyno. Generate some traffic to your app. New Relic will begin monitoring application performance, end user experience, and host performance collected after the add-on is installed. Within a few minutes, data should start appearing in your APM Summary page. Troubleshoot your installation If no data appears within a few minutes after you complete the installation procedures, follow the Node.js agent troubleshooting procedures. Customize your configuration You can customize the New Relic newrelic.js config file for your Node.js agent. You can also use New Relic's Node.js agent environment variables in the Heroku environment to override your config file values. Here is an example of using the Heroku command line to set environment variables instead of using your newrelic.js config file. $ heroku config:set NEW_RELIC_LICENSE_KEY=your license key $ heroku config:set NEW_RELIC_APP_NAME=your production app name $ heroku config:set NEW_RELIC_NO_CONFIG_FILE='true' Copy To confirm your settings from the command line, use: $ heroku config Copy Upgrade from an existing New Relic installation To upgrade your Node.js agent version if New Relic is already installed, use this toolbelt command: npm install newrelic --save Copy For more help Additional documentation resources include: Heroku and New Relic (additional topics for Heroku users) Heroku Dev Center (information on the Heroku site on installing New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.09807,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Node.js <em>agent</em> and Heroku",
        "sections": "Node.js <em>agent</em> and Heroku",
        "tags": "<em>Hosting</em> <em>services</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for <em>hosting</em> web applications in various <em>agent</em> languages, including <em>Node.js</em>. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Here we describe special considerations for using Heroku as a <em>hosting</em> service with New"
      },
      "id": "6043d8dc28ccbcbd982c60a8"
    },
    {
      "sections": [
        "Node.js agent on Microsoft Azure Web Apps",
        "What you need",
        "Installing the Node.js agent",
        "Adding app settings in Azure",
        "Optional: Adding app settings with the CLI",
        "Using environment variables",
        "For more help"
      ],
      "title": "Node.js agent on Microsoft Azure Web Apps",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Hosting services"
      ],
      "external_id": "83ad47cdad2739c3137c7a3b060d6d78f1884463",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/hosting-services/nodejs-agent-microsoft-azure/",
      "published_at": "2021-06-02T20:27:18Z",
      "updated_at": "2021-03-16T15:02:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Read on to learn about special considerations for using Microsoft Azure Web Apps as a hosting service with New Relic's Node.js agent. What you need In addition to the Compatibility and requirements for the Node.js agent, this tutorial assumes you have a working installation of Node.js and the Windows Azure SDK for Node.js for your platform: Install the Azure SDK for Node.js. Ensure Git is installed. Installing the Node.js agent To add the New Relic Node.js agent to your Azure application: In your app's root, verify that there is a package.json file. If there is not, create one via the command line: touch package.json Copy Add the following to your package.json file: { \"name\": \"node\", \"version\": \"0.0.1\", \"dependencies\" : { \"newrelic\" : \"*\" }, \"engine\": { \"node\": \"10.18\" } } Copy Add require('newrelic'); to the top of the server.js file. For example: require('newrelic'); var http = require('http') var port = process.env.PORT || 1337; http.createServer(function(req, res) { res.writeHead(200, { 'Content-Type': 'text/plain' }); res.end('Hello New Relic Node.js agent!\\n'); }).listen(port); Copy Adding app settings in Azure After installation, you must configure your app in Azure Web Apps: Sign in to portal.azure.com. Select App Services > (select a Node.js app) > Configure. Add the following to the app settings: new_relic_app_name: Your Windows Azure website name new_relic_license_key: Your New Relic license key Save your settings. Restart your Node.js app. Generate some traffic to your app and wait a few minutes. After waiting, see your data by going to one.newrelic.com > APM > (select your app). Optional: Adding app settings with the CLI Optional: Here is an example of how to add the app settings by using the CLI (Node SDK): azure account download \"YOUR_SUBSCRIPTION_NAME\" azure account import \"PATH_TO_PUBLISH_SETTINGS_FILE\" azure site config add \"new_relic_app_name=REPLACE_WITH_YOUR_APP_NAME\" azure site config add \"new_relic_license_key=REPLACE_WITH_YOUR_LICENSE_KEY\" azure site restart AZURE_WEB_APP_NAME Copy Using environment variables If your agent runs in PaaS environments such as Heroku or Azure Web Apps, all of the configuration variables in newrelic.js have counterparts that can be set as environment variables. You can freely mix and match variables in the configuration file. Environment variables override your configuration file settings. For example, as a convenience to Azure users, the agent will use APP_POOL_ID as the application name (NEW_RELIC_APP_NAME) if it's set, so you can use the name you chose without setting it twice. For more information, see Configuring Node.js with environment variables. For more help Additional documentation resources include: Node.js agent configuration (changing the default values in your agent configuration file)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 119.27579,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Node.js <em>agent</em> on Microsoft Azure Web Apps",
        "sections": "Node.js <em>agent</em> on Microsoft Azure Web Apps",
        "tags": "<em>Hosting</em> <em>services</em>",
        "body": "Read on to learn about special considerations for using Microsoft Azure Web Apps as a <em>hosting</em> service with New Relic&#x27;s <em>Node.js</em> <em>agent</em>. What you need In addition to the Compatibility and requirements for the <em>Node.js</em> <em>agent</em>, this tutorial assumes you have a working installation of <em>Node.js</em>"
      },
      "id": "603e881528ccbc2501eba7a0"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 79.1203,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the Java <em>agent</em>",
        "sections": "<em>Hosting</em> <em>services</em>",
        "tags": "<em>Agents</em>",
        "body": " method. The Java <em>agent</em> reports the database name and database server&#x2F;identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. <em>Hosting</em> <em>services</em> You can install"
      },
      "id": "6043b8f6196a6771a9960f87"
    }
  ],
  "/docs/agents/nodejs-agent/hosting-services/nodejs-agent-heroku": [
    {
      "sections": [
        "Node.js agent on Microsoft Azure Web Apps",
        "What you need",
        "Installing the Node.js agent",
        "Adding app settings in Azure",
        "Optional: Adding app settings with the CLI",
        "Using environment variables",
        "For more help"
      ],
      "title": "Node.js agent on Microsoft Azure Web Apps",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Hosting services"
      ],
      "external_id": "83ad47cdad2739c3137c7a3b060d6d78f1884463",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/hosting-services/nodejs-agent-microsoft-azure/",
      "published_at": "2021-06-02T20:27:18Z",
      "updated_at": "2021-03-16T15:02:20Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Read on to learn about special considerations for using Microsoft Azure Web Apps as a hosting service with New Relic's Node.js agent. What you need In addition to the Compatibility and requirements for the Node.js agent, this tutorial assumes you have a working installation of Node.js and the Windows Azure SDK for Node.js for your platform: Install the Azure SDK for Node.js. Ensure Git is installed. Installing the Node.js agent To add the New Relic Node.js agent to your Azure application: In your app's root, verify that there is a package.json file. If there is not, create one via the command line: touch package.json Copy Add the following to your package.json file: { \"name\": \"node\", \"version\": \"0.0.1\", \"dependencies\" : { \"newrelic\" : \"*\" }, \"engine\": { \"node\": \"10.18\" } } Copy Add require('newrelic'); to the top of the server.js file. For example: require('newrelic'); var http = require('http') var port = process.env.PORT || 1337; http.createServer(function(req, res) { res.writeHead(200, { 'Content-Type': 'text/plain' }); res.end('Hello New Relic Node.js agent!\\n'); }).listen(port); Copy Adding app settings in Azure After installation, you must configure your app in Azure Web Apps: Sign in to portal.azure.com. Select App Services > (select a Node.js app) > Configure. Add the following to the app settings: new_relic_app_name: Your Windows Azure website name new_relic_license_key: Your New Relic license key Save your settings. Restart your Node.js app. Generate some traffic to your app and wait a few minutes. After waiting, see your data by going to one.newrelic.com > APM > (select your app). Optional: Adding app settings with the CLI Optional: Here is an example of how to add the app settings by using the CLI (Node SDK): azure account download \"YOUR_SUBSCRIPTION_NAME\" azure account import \"PATH_TO_PUBLISH_SETTINGS_FILE\" azure site config add \"new_relic_app_name=REPLACE_WITH_YOUR_APP_NAME\" azure site config add \"new_relic_license_key=REPLACE_WITH_YOUR_LICENSE_KEY\" azure site restart AZURE_WEB_APP_NAME Copy Using environment variables If your agent runs in PaaS environments such as Heroku or Azure Web Apps, all of the configuration variables in newrelic.js have counterparts that can be set as environment variables. You can freely mix and match variables in the configuration file. Environment variables override your configuration file settings. For example, as a convenience to Azure users, the agent will use APP_POOL_ID as the application name (NEW_RELIC_APP_NAME) if it's set, so you can use the name you chose without setting it twice. For more information, see Configuring Node.js with environment variables. For more help Additional documentation resources include: Node.js agent configuration (changing the default values in your agent configuration file)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 119.27579,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Node.js <em>agent</em> on Microsoft Azure Web Apps",
        "sections": "Node.js <em>agent</em> on Microsoft Azure Web Apps",
        "tags": "<em>Hosting</em> <em>services</em>",
        "body": "Read on to learn about special considerations for using Microsoft Azure Web Apps as a <em>hosting</em> service with New Relic&#x27;s <em>Node.js</em> <em>agent</em>. What you need In addition to the Compatibility and requirements for the <em>Node.js</em> <em>agent</em>, this tutorial assumes you have a working installation of <em>Node.js</em>"
      },
      "id": "603e881528ccbc2501eba7a0"
    },
    {
      "sections": [
        "Install New Relic Node.js agent in GAE flexible environment",
        "Use native deploy",
        "Build a custom runtime",
        "1. Set up the GAE project and install dependencies",
        "2. Configure your app.yaml",
        "3. Configure and deploy",
        "Optional: Disable health checks",
        "Get New Relic agent troubleshooting logs from GAE"
      ],
      "title": "Install New Relic Node.js agent in GAE flexible environment",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Hosting services"
      ],
      "external_id": "28df1194ff848b2c26e5c966843d2bf5f0adbf9e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/hosting-services/install-new-relic-nodejs-agent-gae-flexible-environment/",
      "published_at": "2021-06-02T20:27:18Z",
      "updated_at": "2021-03-11T07:59:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's Node.js agent, you can monitor applications that reside in the Google App Engine (GAE) flexible environment. Adding New Relic to your GAE flex app gives you insight into the health and performance of your app and extends GAE with metrics you can view in APM and browser monitoring. This document explains how to add New Relic to your GAE flex app using either of these methods: Google App Engine's \"native mode\" installation with a standard GAE runtime Docker installation using a custom runtime Use native deploy To use Google App Engine's \"native mode\" installation with your Node.js app: Follow standard procedures to install New Relic's Node.js agent, including your license key. Be sure to save the newrelic module to the package.json file. Follow Google App Engine procedures for Node.js to create a new Cloud Platform project, create an App Engine application, and complete other prerequisites for the Google Cloud SDK. Optional: Set environment variables to configure the Node.js agent's GAE app.yaml file. Use the Google Cloud SDK's gcloud command line tool to deploy GAE apps. To deploy your Node.js app to your initialized GAE flexible environment, run the following command: gcloud --project new-relic-apm-nodejs app deploy Copy Google App Engine automatically includes your Node.js app's newrelic.js configuration file in the deployed package. Wait until the deployment completes, then view your GAE flex app data in the APM Summary page. Build a custom runtime See Google's documentation for building custom runtimes. This example describes how to add New Relic to your GAE flex app by building a custom runtime for Docker. You can deploy the app without any special configuration. For more information about deploying and configuring your Node.js app in the GAE flexible environment, see: Google App Engine's documentation for Node.js Google App Engine's tutorial to deploy a Node.js app 1. Set up the GAE project and install dependencies Follow standard procedures to install New Relic's Node.js agent, including your license key. Be sure to save the newrelic module to the package.json file. Follow Google App Engine procedures for Node.js to create a new Cloud Platform project, create an App Engine application, and complete other prerequisites for the Google Cloud SDK. The Google Cloud SDK provides the gcloud command line tool to manage and deploy GAE apps. 2. Configure your app.yaml The app.yaml configuration file is required for a GAE flexible environment app with a custom runtime. At a minimum, make sure it contains: runtime: custom env: flex Copy Optional: Set environment variables. 3. Configure and deploy The Dockerfile defines the Docker image to be built and is required for a GAE flexible environment app. To create the Dockerfile, build the container, and deploy your app, follow the GAE procedures for Node.js. Wait until the deployment completes. To view your GAE flex app data in New Relic, go to the APM Summary page. Optional: Disable health checks Google App Engine sends periodic health check requests to confirm that an instance has been successfully deployed, and to check that a running instance maintains a healthy status. A health check is an HTTP request to the URL /_ah/health. If you create a custom runtime, your app must be able to handle a large number of health check requests. Otherwise, your app data may not display correctly in New Relic APM. If you notice performance issues, disable GAE health checks. In your app.yaml, add: health_check: enable_health_check: False Copy Get New Relic agent troubleshooting logs from GAE Use these resources to troubleshoot your GAE flex environment app: To connect to the GAE instance and start a shell in the Docker container running your code, see Debugging an instance. To redirect New Relic Node.js agent logs to Stackdriver in the Cloud Platform Console, change the newrelic.js configuration file to: log_file_name: STDOUT Copy To view the logs, use the Cloud Platform Console's Log Viewer.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 118.48743,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install New Relic Node.js <em>agent</em> in GAE flexible environment",
        "sections": "Install New Relic Node.js <em>agent</em> in GAE flexible environment",
        "tags": "<em>Hosting</em> <em>services</em>",
        "body": "With New Relic&#x27;s <em>Node.js</em> <em>agent</em>, you can monitor applications that reside in the Google App Engine (GAE) flexible environment. Adding New Relic to your GAE flex app gives you insight into the health and performance of your app and extends GAE with metrics you can view in APM and browser monitoring"
      },
      "id": "6043d8da28ccbc08242c60a6"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 79.1203,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the Java <em>agent</em>",
        "sections": "<em>Hosting</em> <em>services</em>",
        "tags": "<em>Agents</em>",
        "body": " method. The Java <em>agent</em> reports the database name and database server&#x2F;identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. <em>Hosting</em> <em>services</em> You can install"
      },
      "id": "6043b8f6196a6771a9960f87"
    }
  ],
  "/docs/agents/nodejs-agent/hosting-services/nodejs-agent-microsoft-azure": [
    {
      "sections": [
        "Node.js agent and Heroku",
        "Install the agent add-on",
        "Troubleshoot your installation",
        "Customize your configuration",
        "Upgrade from an existing New Relic installation",
        "For more help"
      ],
      "title": "Node.js agent and Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Hosting services"
      ],
      "external_id": "5a5a3dc52312ca8d70d4bb08c4b15df3209764a3",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/hosting-services/nodejs-agent-heroku/",
      "published_at": "2021-06-02T20:27:19Z",
      "updated_at": "2021-03-11T09:41:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various agent languages, including Node.js. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Here we describe special considerations for using Heroku as a hosting service with New Relic's Node.js agent. Install the agent add-on After deploying your Node.js app on Heroku, install the New Relic agent. Installing the add-on automatically creates a private New Relic account and configures access for Heroku servers. To install the New Relic add-on through the Heroku website's Add-on page for New Relic, you must be logged in to Heroku. From Heroku's Add-on page for New Relic, select the appropriate subscription plan. Then run this toolbelt command: heroku addons:create newrelic:$planlevel Copy From Select an app, select your New Relic app. Use this toolbelt command to give your app a descriptive name: heroku config:set NEW_RELIC_APP_NAME='Your Application Name' Copy If you are using environment variables instead of your newrelic.js config file settings to customize your Node.js agent configuration, use this toolbelt command: heroku config:set NEW_RELIC_NO_CONFIG_FILE='true' Copy Verify your New Relic app name, license key, and log setting: heroku config Copy Install the Node.js agent and save to your npm dependencies. npm install newrelic --save Copy To ensure that the newrelic package is properly included in your package.json file when you push to Heroku, install the New Relic Node.js agent package on your local system. Include New Relic on the first line of your app's main module: require ('newrelic'); Copy Run the following commands: git add . && git commit -m \"Add New Relic\" git push heroku master && heroku logs --tail Copy Restart your dyno. Generate some traffic to your app. New Relic will begin monitoring application performance, end user experience, and host performance collected after the add-on is installed. Within a few minutes, data should start appearing in your APM Summary page. Troubleshoot your installation If no data appears within a few minutes after you complete the installation procedures, follow the Node.js agent troubleshooting procedures. Customize your configuration You can customize the New Relic newrelic.js config file for your Node.js agent. You can also use New Relic's Node.js agent environment variables in the Heroku environment to override your config file values. Here is an example of using the Heroku command line to set environment variables instead of using your newrelic.js config file. $ heroku config:set NEW_RELIC_LICENSE_KEY=your license key $ heroku config:set NEW_RELIC_APP_NAME=your production app name $ heroku config:set NEW_RELIC_NO_CONFIG_FILE='true' Copy To confirm your settings from the command line, use: $ heroku config Copy Upgrade from an existing New Relic installation To upgrade your Node.js agent version if New Relic is already installed, use this toolbelt command: npm install newrelic --save Copy For more help Additional documentation resources include: Heroku and New Relic (additional topics for Heroku users) Heroku Dev Center (information on the Heroku site on installing New Relic)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 121.09807,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Node.js <em>agent</em> and Heroku",
        "sections": "Node.js <em>agent</em> and Heroku",
        "tags": "<em>Hosting</em> <em>services</em>",
        "body": "Heroku is a Platform as a Service (PaaS) solution for <em>hosting</em> web applications in various <em>agent</em> languages, including <em>Node.js</em>. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Here we describe special considerations for using Heroku as a <em>hosting</em> service with New"
      },
      "id": "6043d8dc28ccbcbd982c60a8"
    },
    {
      "sections": [
        "Install New Relic Node.js agent in GAE flexible environment",
        "Use native deploy",
        "Build a custom runtime",
        "1. Set up the GAE project and install dependencies",
        "2. Configure your app.yaml",
        "3. Configure and deploy",
        "Optional: Disable health checks",
        "Get New Relic agent troubleshooting logs from GAE"
      ],
      "title": "Install New Relic Node.js agent in GAE flexible environment",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Hosting services"
      ],
      "external_id": "28df1194ff848b2c26e5c966843d2bf5f0adbf9e",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/hosting-services/install-new-relic-nodejs-agent-gae-flexible-environment/",
      "published_at": "2021-06-02T20:27:18Z",
      "updated_at": "2021-03-11T07:59:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "With New Relic's Node.js agent, you can monitor applications that reside in the Google App Engine (GAE) flexible environment. Adding New Relic to your GAE flex app gives you insight into the health and performance of your app and extends GAE with metrics you can view in APM and browser monitoring. This document explains how to add New Relic to your GAE flex app using either of these methods: Google App Engine's \"native mode\" installation with a standard GAE runtime Docker installation using a custom runtime Use native deploy To use Google App Engine's \"native mode\" installation with your Node.js app: Follow standard procedures to install New Relic's Node.js agent, including your license key. Be sure to save the newrelic module to the package.json file. Follow Google App Engine procedures for Node.js to create a new Cloud Platform project, create an App Engine application, and complete other prerequisites for the Google Cloud SDK. Optional: Set environment variables to configure the Node.js agent's GAE app.yaml file. Use the Google Cloud SDK's gcloud command line tool to deploy GAE apps. To deploy your Node.js app to your initialized GAE flexible environment, run the following command: gcloud --project new-relic-apm-nodejs app deploy Copy Google App Engine automatically includes your Node.js app's newrelic.js configuration file in the deployed package. Wait until the deployment completes, then view your GAE flex app data in the APM Summary page. Build a custom runtime See Google's documentation for building custom runtimes. This example describes how to add New Relic to your GAE flex app by building a custom runtime for Docker. You can deploy the app without any special configuration. For more information about deploying and configuring your Node.js app in the GAE flexible environment, see: Google App Engine's documentation for Node.js Google App Engine's tutorial to deploy a Node.js app 1. Set up the GAE project and install dependencies Follow standard procedures to install New Relic's Node.js agent, including your license key. Be sure to save the newrelic module to the package.json file. Follow Google App Engine procedures for Node.js to create a new Cloud Platform project, create an App Engine application, and complete other prerequisites for the Google Cloud SDK. The Google Cloud SDK provides the gcloud command line tool to manage and deploy GAE apps. 2. Configure your app.yaml The app.yaml configuration file is required for a GAE flexible environment app with a custom runtime. At a minimum, make sure it contains: runtime: custom env: flex Copy Optional: Set environment variables. 3. Configure and deploy The Dockerfile defines the Docker image to be built and is required for a GAE flexible environment app. To create the Dockerfile, build the container, and deploy your app, follow the GAE procedures for Node.js. Wait until the deployment completes. To view your GAE flex app data in New Relic, go to the APM Summary page. Optional: Disable health checks Google App Engine sends periodic health check requests to confirm that an instance has been successfully deployed, and to check that a running instance maintains a healthy status. A health check is an HTTP request to the URL /_ah/health. If you create a custom runtime, your app must be able to handle a large number of health check requests. Otherwise, your app data may not display correctly in New Relic APM. If you notice performance issues, disable GAE health checks. In your app.yaml, add: health_check: enable_health_check: False Copy Get New Relic agent troubleshooting logs from GAE Use these resources to troubleshoot your GAE flex environment app: To connect to the GAE instance and start a shell in the Docker container running your code, see Debugging an instance. To redirect New Relic Node.js agent logs to Stackdriver in the Cloud Platform Console, change the newrelic.js configuration file to: log_file_name: STDOUT Copy To view the logs, use the Cloud Platform Console's Log Viewer.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 118.48743,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Install New Relic Node.js <em>agent</em> in GAE flexible environment",
        "sections": "Install New Relic Node.js <em>agent</em> in GAE flexible environment",
        "tags": "<em>Hosting</em> <em>services</em>",
        "body": "With New Relic&#x27;s <em>Node.js</em> <em>agent</em>, you can monitor applications that reside in the Google App Engine (GAE) flexible environment. Adding New Relic to your GAE flex app gives you insight into the health and performance of your app and extends GAE with metrics you can view in APM and browser monitoring"
      },
      "id": "6043d8da28ccbc08242c60a6"
    },
    {
      "sections": [
        "Compatibility and requirements for the Java agent",
        "Requirements to install the agent",
        "JVM",
        "Tip",
        "Security requirements",
        "Use of other monitoring software",
        "Built-in instrumentation",
        "App/Web servers",
        "Frameworks and libraries",
        "HTTP and messaging",
        "Datastores",
        "Instance-level database information",
        "Hosting services",
        "Asynchronous instrumentation",
        "Other instrumented features",
        "Connect the agent to other New Relic products"
      ],
      "title": "Compatibility and requirements for the Java agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Java agent",
        "Getting started"
      ],
      "external_id": "4f74ff9a5d2402145001db0dd2c07e95166e2403",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/java-agent/getting-started/compatibility-requirements-java-agent/",
      "published_at": "2021-06-02T15:22:26Z",
      "updated_at": "2021-06-02T15:22:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "New Relic's Java agent includes built-in instrumentation of the most popular parts of the Java ecosystem, including app servers, frameworks, databases, and message queuing systems. For frameworks and libraries that are not instrumented out of the box, you can extend the agent with Java custom instrumentation. Requirements to install the agent Before you install the Java agent, ensure your system meets these requirements: JVM Tip The Java agent is compatible with any JVM-based language, including: Java, Scala, Kotlin, and Clojure. For instrumentation support for language-specific features, see the Automatically instrumented frameworks and libraries section below. Java version Agent support Java 5 Agent v1.3.0 to v2.21.7 Java 6 Agent v3.0.0 to v4.3.0 Java 7 Agent v3.0.0 to v6.5.0 Java 8 Agent v3.10.0 to current Java 9 Agent v3.43.0 to current Java 10 Agent v4.4.0 to current Java 11 Agent v4.7.0 to current Java 12 Agent v4.12.0 to current Java 13 Agent v5.7.0 to current Java 14 Agent v5.11.0 to current Java 15 Agent v6.1.0 to current Fully supported: IBM JVM versions 7 and 8 for Linux Eclipse OpenJ9 versions 8 to 13 for Linux, Windows, and macOS OpenJDK and AdoptOpenJDK JVM versions 7 to 15 for Linux, Windows, and macOS Oracle Hotspot JVM versions 7 to 15 for Linux, Solaris, Windows, and macOS Azul Zing JVM versions 8 and 11 for Linux, Windows, and macOS Azul Zulu JVM versions 8 to 12 for Linux, Windows, and macOS Amazon Corretto JVM versions 8 and 11 for Linux, Windows, and macOS Alibaba Dragonwell JVM versions 8 and 11 for Linux, Windows, and macOS Supported only with Java agent 4.3.x [ ZIP | 2.8 MB] legacy agent: Apple Hotspot JVM version 6 for macOS IBM JVM version 6 Oracle Hotspot JVM version 6.0 for Linux, Solaris, Windows, macOS Supported only with Java agent 2.21.x [ ZIP | 2.8 MB] legacy agent: Oracle Hotspot JVM version 5.0 for Linux, Solaris, Windows, macOS (Java SE 5.0) Oracle JRockit up to and including 1.6.0_50 Security requirements As a standard security measure for data collection, your app server must support SHA-2 (256-bit). SHA-1 is not supported. Use of other monitoring software If your application uses other application monitoring software besides our agent, we cannot guarantee that our agent will work correctly and we cannot offer technical support. For more information, see Errors while using other monitoring software. Built-in instrumentation After you install the Java agent, it automatically instruments many popular frameworks and libraries. With automatic instrumentation, the agent collects rich data out of the box, and data will show up in your New Relic dashboards within minutes of installation. Even if your library is not automatically instrumented, you can still collect data with custom instrumentation and the Java agent API. The agent automatically instruments these frameworks and libraries: App/Web servers The agent automatically instruments the following app/web servers. To install the Java agent on supported app/web servers, see Install the Java agent. ColdFusion 10 Glassfish 3.0 to 5.x JBoss 7.0 to latest JBoss EAP 6.0 to latest Jetty 7.0.0.M3 to 9.4.x Mule ESB 3.4 to 3.8.x Netty 3.3.0.Alpha1 to 5.0.0.Alpha1 Resin 3.1.9 to 4.0.x Spray-can 1.3.1 to latest Tomcat 7.0.0 to 9.0.x TomEE 1.5 to 8.0.x WebLogic 12.1.2.1 to 12.2.x WebSphere 8.5.x to 9.x WebSphere Liberty Profile 8.5 to latest WildFly 8.0.0.Final to latest Frameworks and libraries The agent automatically instruments the following frameworks. To install the Java agent on supported frameworks, see Install the Java agent. Akka 2.2.0-RC1 to latest AmazonS3 client 1.2.13 to latest AmazonSNS and AmazonSNSAsync clients 1.11.12 to latest AmazonSQS and AmazonSQSAsync clients 1.3.22 to latest S3Client 2.1.0 to latest SnsClient 2.1.0 to latest SqsClient 2.1.0 to latest CXF 2.1.3 to latest Grails 1.3.7 to 2.3.x Hibernate 3.3.0.CR1 to 6.0.0.Alpha2 Hystrix 1.3.15 to latest JAX-RS 1.0 to 2.0 JCache API 1.0.0 to latest Jersey 1.0.1 to 2.x JSF (Java Server Faces) Play 2.3.0 to latest Quartz Job Scheduler 1.8.3 to 2.2.x RESTEasy 2.2-RC-1 to latest Spray 1.3.1 to latest Spring 3.0.0.RELEASE to latest Spring webclient 5.0.0.RELEASE to latest Spring Web Services from 1.5.7 to latest Spring Boot 1.4.x to latest Struts 2 Thrift 0.8.0 to latest Vert.x 3.2.0 to 3.8.3 HTTP and messaging The agent automatically instruments the following HTTP clients and messaging services. For instructions, see Install the Java agent. Akka HTTP 2.4.5 to latest Akka Http Core from 0.4 to latest AsyncHttpClient 2.0.0-RC1 to latest gRPC 1.4.0 to latest HttpAsyncClient 4.1 to latest Apache Httpclient from 3.0 to latest java.net.HttpURLConnection JMS and Spring-JMS 1.1 to latest Kafka Clients 0.10.0.0 to latest (for metric and event data) Kafka Clients 0.11.0.0 to latest (for distributed tracing, metric, and event data) OkHttp 3.x to 4.3.x Ning AsyncHttpClient 1.x Play WS 2.6.0 to latest RabbitMQ 1.7.2 to latest (AMQP and JMS) Spray-client 1.3.1 to latest Spring webclient from 5.0.0.release to latest Datastores New Relic currently supports MySQL and PostgreSQL to capture explain plans for slow database queries. Amazon DynamoDB 1.11.106 to latest Anorm from 2.0 to 2.5 DataStax Cassandra 2.1.2 to 4.0.0 (If you use high security, see the configuration documentation for allow lists.) DB2 9.1 to latest Derby 10.2.1.6 to latest Generic JDBC (any JDBC compliant driver) H2 1.0.57 to latest HSQL 1.7.2.2 to latest INet Oracle Driver (Oranxo) 3.06, 3.14 INet MERLIA 7.0.3, 8.04.03, and 8.06 Jedis Redis driver 1.4.0 to 2.10.x, 3.0.0 to latest jTDS 1.2 to latest MariaDB 1.1.7 or higher Microsoft SQL Server 1.2 to latest MongoDB 2.12.0-rc0 to latest (synchronous clients only) MySQL mysql-connector-java 3.0.8 to latest Oracle ojdbc5, ojdbc6, ojdbc7, ojdbc8, ojdbc10, ojdbc14 Postgres 8.0-312.jdbc3 to latest Slick 3.0.0 to latest Solr 4.0 to latest Spymemcached 2.11 to latest Sybase (jConnect) JDBC 3 driver 6.0 to latest Instance-level database information New Relic collects instance details for a variety of databases and database drivers. The ability to view specific instances and the types of database information in APM depends on your New Relic agent version. New Relic's Java agent versions 3.33.0 or higher support the following: Any compatible JDBC driver Amazon DynamoDB 1.11.106 or higher DataStax Cassandra driver 2.1.2 to 4.0.0 Jedis Redis driver 1.4 to 2.10.x, 3.0.0 to latest Mongo 2.12.0 to latest (synchronous clients only)/li> Spymemcached 2.11.0 to 2.12.x Exception: Instance-level information is not reported for calls to the getBulk() API method. The Java agent reports the database name and database server/identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. Hosting services You can install the Java agent on a variety of hosting services, including ones not listed below. Here are detailed installation guides for particular hosting services: Google App Engine (GAE) flexible environment Heroku Asynchronous instrumentation For supported frameworks, the Java agent usually instruments async work automatically. However, you can use the Java agent API to extend this instrumentation. Other instrumented features EJB Session Beans 3.0 or higher JMX JSP (Java Server Pages) 2.0 to 2.2 Scala 2.9.3 to 2.13.x Connect the agent to other New Relic products The Java agent integrates with other New Relic products to give you end-to-end visibility: Product Integration Browser monitoring The Java agent automatically injects the Browser JavaScript agent when you enable auto-instrumentation. After enabling Browser injection, you can view Browser data in the APM Summary page and quickly switch between the APM and Browser data for a particular app. For configuration options and manual instrumentation, see Browser monitoring and the Java agent. Infrastructure monitoring When you install the Infrastructure and APM agents on the same host, they automatically detect one another. You can then view a list of hosts in the APM UI, and filter your Infrastructure hosts by APM app in the Infrastructure UI. For more information, see APM data in Infrastructure. New Relic One dashboards The Java agent sends default events and attributes to dashboards, or you can run NRQL queries in the query builder. You can also record custom events for advanced analysis. Synthetic monitoring Synthetic transaction traces connect requests from Synthetics monitors to the underlying APM transaction.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 79.12023,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Compatibility and requirements for the Java <em>agent</em>",
        "sections": "<em>Hosting</em> <em>services</em>",
        "tags": "<em>Agents</em>",
        "body": " method. The Java <em>agent</em> reports the database name and database server&#x2F;identifier attributes on slow query traces and transaction traces for these database drivers. To request instance-level information from additional datastores, get support at support.newrelic.com. <em>Hosting</em> <em>services</em> You can install"
      },
      "id": "6043b8f6196a6771a9960f87"
    }
  ],
  "/docs/agents/nodejs-agent/index": [
    {
      "sections": [
        "Troubleshooting large memory usage (Node.js)",
        "Problem",
        "Solution",
        "Increase caused by TLS memory buffer allocation",
        "Caution",
        "Increase caused by cluster worker slab allocations",
        "Increase caused by log messages stored to disk",
        "Increase caused by leaked MongoDB cursors",
        "Increase caused by agent data storage"
      ],
      "title": "Troubleshooting large memory usage (Node.js)",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Troubleshooting"
      ],
      "external_id": "fdacc90072462a34ca0db2b51f5145c1be4caf9d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/troubleshooting/troubleshooting-large-memory-usage-nodejs/",
      "published_at": "2021-06-02T15:29:05Z",
      "updated_at": "2021-05-10T19:02:56Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You installed the New Relic Node.js agent, and your Node.js application's memory usage increased. Solution There are several possible causes for this memory increase and potential solutions for each. Increase caused by TLS memory buffer allocation The first time a Node.js application uses any form of encryption, including SSL and HTTPS, a slab buffer is created. The default size for this buffer is 10 MB. Applications running in environments where SSL termination on inbound requests occurs in a separate router layer do not normally incur this overhead. Cloud services like Heroku and AWS often operate this way. However, the Node.js agent sends outbound data to New Relic services over HTTPS, and this triggers the allocation of a slab buffer. Solution: In some cases, you can reduce the slab buffer below its 10 MB default. To set the slab buffer size, use tls.SLAB_BUFFER_SIZE. Caution When using the New Relic agent, do not set the slab buffer size below 128 KB. The slab buffer allocation should not be reduced for apps that communicate with services or clients using SSL, HTTPS, or any other form of cryptography. Increase caused by cluster worker slab allocations Node.js provides the Cluster module. This allows for handling requests in parallel by using all processor cores available on a host. However, each cluster worker allocates its own slab buffer for SSL transactions, and keeps its own copy of Node.js agent data. This multiplies the memory overhead by the number of cluster workers used. The is also true if a host runs multiple Node.js applications at the same time. Solution: Some cloud service providers use environments that state a higher number of processor cores than can actually be used at any given time. Reducing the number of cluster workers or running without Cluster support may decrease memory usage without impacting performance. Increase caused by log messages stored to disk Log messages are logged to disk by default. Due to how message data is handled, message objects may be moved into Old-pointer-space for garbage collection. This means the objects stay in memory for a while, even after all references to them are gone. This leads to a larger amount of memory consumed by a process at any given time. Additional processing time is also used for garbage collection. Solution: Depending on your version of the Node.js, the agent may default to the trace or info log levels. Decrease logging verbosity to info or warn levels to noticeably decrease memory usage and time spent in garbage collection. Increase caused by leaked MongoDB cursors Many database drivers use an abstraction called a cursor. Cursors provide the ability to iterate through the results of queries. For example, the mongodb driver provides cursors when executing find queries. Cursors live both as objects in the Node.js runtime and as entities in the MongoDB server. When an application has finished using a cursor, it should close it to free up resources in both the server and the client application. In Node.js, it is possible for a cursor to be garbage collected, freeing resources in the application, without closing the cursor in the server. This may be go unnoticed in the application. However, the New Relic Node.js agent keeps track of open cursors to measure the time spent iterating through results. If your application does not close all the cursors it uses, the agent will continue to track stale cursors and leak memory. Solution: Ensure every cursor created in your application is closed by calling cursor.close() after the application finishes processing the results of the query. Increase caused by agent data storage The Node.js agent records data for each transaction your app handles. Data is generally grouped by transaction name. The memory used by the agent increases with the number of different transactions recorded in each minute-long harvest cycle. In addition, a larger amount of data is kept during each transaction, but is eventually discarded when the transaction completes. Memory used by the agent increases with the number of concurrent transactions handled by the application. Solution: If agent data storage is identified as the cause of a memory usage increase, this can best be addressed by adding additional memory to your host, or by switching to a larger cloud instance.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 71.36983,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "Increase caused by <em>agent</em> data storage",
        "tags": "<em>Nodejs</em> <em>agent</em>",
        "body": "Problem You installed the New Relic <em>Node.js</em> <em>agent</em>, and your <em>Node.js</em> application&#x27;s memory usage increased. Solution There are several possible causes for this memory increase and potential solutions for each. Increase caused by TLS memory buffer allocation The first time a <em>Node.js</em> application uses"
      },
      "id": "603e9d6828ccbcb774eba788"
    },
    {
      "sections": [
        "Troubleshoot message consumers",
        "Problem",
        "Solution",
        "Callbacks",
        "Callback problem",
        "Promises",
        "Promise problem"
      ],
      "title": "Troubleshoot message consumers",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Troubleshooting"
      ],
      "external_id": "0658082539671d572e780dcc3599593dfd562419",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/troubleshooting/troubleshoot-message-consumers/",
      "published_at": "2021-06-02T15:29:05Z",
      "updated_at": "2021-03-16T15:05:11Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem Message consumer services have a few differences to HTTP servers that make monitoring them more difficult. This document discusses those limitations and ways to work around them with the New Relic Node.js agent. Because a message does not necessarily have a reply, it can be hard to determine the end of a transaction. If New Relic's Node.js agent cannot determine when a message consumer will be done, it will immediately end the transaction. Follow these troubleshooting tips depending on your application. Solution The solution to this issue depends on whether you are using callbacks or promises: Callbacks When using a callback-based messaging API such as amqplib's callback_api, there is no easy way to determine when your consumer is done. Here is an example. Callback problem In this example, all the transactions created for this service will be immediately ended and not show any of the work done by doWorkWithMessage. const newrelic = require('newrelic'); const amqp = require('amqplib/callback_api'); // Connect, make a channel, and assert required queues... channel.consume('my.queue', (msg) => { doWorkWithMessage(msg, (err) => { if (err) { logger.error(err); channel.reject(msg, true); // Requeue message on failure. } }); }, {noAck: true}); Copy In order to properly time the transaction, you need to get the transaction and end it manually, as shown in the following solution. Solution To properly time the transaction, get the transaction and end it manually. Modify the consumer to this: channel.consume('my.queue', (msg) => { var transaction = newrelic.getTransaction(); doWorkWithMessage(msg, (err) => { if (err) { logger.error(err); channel.reject(msg, true); // Requeue message on failure. } transaction.end(); }); }, {noAck: true}); Copy Promises For promise-based servers, the message consumer simply needs to return a promise. When that promise resolves or rejects, the transaction will be ended. Here is an example: Promise problem In this example, doWorkWithMessage returns a promise: const newrelic = require('newrelic'); const amqp = require('amqplib'); // Connect, make a channel, and assert required queues... channel.consume('my.queue', (msg) => { doWorkWithMessage(msg).catch((err) => { if (err) { logger.error(err); channel.reject(msg, true); // Requeue message on failure. } }); }, {noAck: true}); Copy Solution To get correct timing, return the end of the chain by modifying the code to: channel.consume('my.queue', (msg) => { return doWorkWithMessage(msg).catch((err) => { if (err) { logger.error(err); channel.reject(msg, true); // Requeue message on failure. } }); }, {noAck: true}); Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 59.217266,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Nodejs</em> <em>agent</em>",
        "body": "Problem Message consumer services have a few differences to HTTP servers that make monitoring them more difficult. This document discusses those limitations and ways to work around them with the New Relic <em>Node.js</em> <em>agent</em>. Because a message does not necessarily have a reply, it can be hard"
      },
      "id": "603e8eb4196a670c1ba83de2"
    },
    {
      "sections": [
        "Troubleshoot your Node.js installation",
        "Problem",
        "Solution",
        "Not seeing data",
        "Installation problems",
        "Log files",
        "Missing VM metrics"
      ],
      "title": "Troubleshoot your Node.js installation",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Troubleshooting"
      ],
      "external_id": "2c9fef97ba7342d3e3b334a26890c3a166a12849",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/troubleshooting/troubleshoot-your-nodejs-installation/",
      "published_at": "2021-06-02T15:26:38Z",
      "updated_at": "2021-03-16T15:05:11Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem If you have encountered any of these common problems after installing your New Relic Node.js agent, try these troubleshooting tips. Solution Some common problems users encounter after installing the New Relic Node.js agent include: Not seeing data To minimize the amount of bandwidth the Node.js agent consumes, New Relic only reports data once per minute. If you add the agent to tests that take less than a minute to run, it will not have time to report data to New Relic. If you do not see transaction traces or other data after deploying the agent, this may be due to configuration, framework, or Apdex settings. Use New Relic Diagnostics to try to automatically identify the issue. Installation problems What to check Comments Main module Ensure that you have added require('newrelic'); as the first line of the app's main module. If the require is added later, the Node.js agent may not properly instrument your application. Conditional logic If you have any conditional logic in your require, move the conditional logic to your newrelic.js configuration file. Frameworks For problems with supported frameworks, make sure you are using Connect, Express, Hapi, Kraken, or Restify. There are other Node.js frameworks, but New Relic does not support all of them. Apdex For problems with your Apdex results, try adjusting your Apdex score via your Node.js agent config file (newrelic.js) or the New Relic user interface. Log files The Node.js agent writes its log to the newrelic_agent.log file in the application directory, unless you have changed the logging settings. If the agent does not send data or crashes your app, you can generate a troubleshooting log file to accompany bug reports and support requests. Missing VM metrics The agent can collect VM metrics related to garbage collection (GC), memory, and CPU. Some of these metrics require an additional native module to be installed. Here are some common problems and their solutions: Problem During installation, npm shows one of the following error messages: gyp ERR! configure error gyp ERR! stack Error: Can't find Python executable \"python\", you can set the PYTHON env variable. Copy gyp ERR! build error gyp ERR! stack Error: not found: make Copy make: g++: Command not found Copy Solution Ensure that the prerequisites for the node-gyp module are installed. On Debian/Ubuntu platforms, use this command: apt-get install build-essential Copy For more information, see Node.js VM measurements. Other troubleshooting resources on our Explorers Hub forum: Troubleshooting install General configuration troubleshooting",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 59.217266,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "tags": "<em>Nodejs</em> <em>agent</em>",
        "body": "Problem If you have encountered any of these common problems after installing your New Relic <em>Node.js</em> <em>agent</em>, try these troubleshooting tips. Solution Some common problems users encounter after installing the New Relic <em>Node.js</em> <em>agent</em> include: Not seeing data To minimize the amount of bandwidth"
      },
      "id": "603e7e83e7b9d25c0b2a07d1"
    }
  ],
  "/docs/agents/nodejs-agent/installation-configuration/install-nodejs-agent-docker": [
    {
      "sections": [
        "Install the Node.js agent",
        "Tip",
        "Important",
        "Keep your Node.js agent up-to-date",
        "Troubleshooting"
      ],
      "title": "Install the Node.js agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Installation and configuration"
      ],
      "external_id": "5877d4bc24ac6201ac15fd7dd909ce85213e6680",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/installation-configuration/install-nodejs-agent/",
      "published_at": "2021-06-02T20:28:30Z",
      "updated_at": "2021-03-16T15:03:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Node.js agent is publicly available on the Node Package Manager (npm) repository as well as on GitHub. You can use our launcher, or follow the instructions in this document to complete a basic Node.js agent installation. Tip To use Node.js or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Add Node.js data Install the Node.js agent Important If you're using the agent in a Docker container, install the agent in each container. To install the Node.js agent: Ensure you meet the system requirements. In particular, make sure you use a supported Node version. Use the command npm install newrelic --save for each application you want to monitor. From node_modules/newrelic, copy newrelic.js into the root directory of your app. Configure agent via the newrelic.js file or via environment variable: Customize the license_key setting with your license key. Customize the app_name setting with one or more meaningful app names. Add require('newrelic'); as the first line of your app's main module. Optional: For additional Node.js runtime-level statistics, ensure the @newrelic/native-metrics package is installed. Generate some traffic, then wait a few minutes for data to appear in the APM UI. You can further customize your agent behavior via newrelic.js or an environment variable. To keep the agent configuration separate from your app, edit the NEW_RELIC_HOME environmental variable. Keep your Node.js agent up-to-date To ensure that you have the most up-to-date version of New Relic, refer to the Node.js release notes. When applicable, the release notes include a download link with instructions on how to update the Node.js agent. Troubleshooting After you update the agent, generate some traffic and wait a few minutes. If no data appears in the New Relic UI, see the troubleshooting procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 152.04909,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the Node.js <em>agent</em>",
        "sections": "<em>Install</em> the Node.js <em>agent</em>",
        "tags": "<em>Installation</em> <em>and</em> <em>configuration</em>",
        "body": "Our <em>Node.js</em> <em>agent</em> is publicly available on the Node Package Manager (npm) repository as well as on GitHub. You can use our launcher, or follow the instructions in this document to complete a basic <em>Node.js</em> <em>agent</em> <em>installation</em>. Tip To use <em>Node.js</em> or any other <em>agent</em>, as well as the rest of our"
      },
      "id": "603e962e28ccbcf759eba75b"
    },
    {
      "sections": [
        "Uninstall the Node.js agent",
        "Tip",
        "For more help"
      ],
      "title": "Uninstall the Node.js agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Installation and configuration"
      ],
      "external_id": "17cdfffa0ea6ea5888c601dca3846e50772fc112",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/installation-configuration/uninstall-nodejs-agent/",
      "published_at": "2021-06-02T20:29:31Z",
      "updated_at": "2021-03-13T02:39:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Read on to learn how to uninstall the New Relic Node.js agent. For instructions on how to temporarily disable the agent, see Disable the agent. To uninstall the New Relic Node.js agent: Remove require('newrelic'); as the first line of the app's main module. Remove the npm package with npm uninstall newrelic --save. Delete the newrelic.js file and unset any environment variables being used. When the uninstall process finishes, restart your app. For more information about installation, see Installing and maintaining Node.js. Tip You may also want to remove your app from New Relic. For more help Additional documentation resources include: Troubleshooting the Node.js agent (a library of troubleshooting solutions for Node.js)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 148.51941,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Uninstall the Node.js <em>agent</em>",
        "sections": "Uninstall the Node.js <em>agent</em>",
        "tags": "<em>Installation</em> <em>and</em> <em>configuration</em>",
        "body": " newrelic --save. Delete the newrelic.js file and unset any environment variables being used. When the uninstall process finishes, restart your app. For more information about <em>installation</em>, see Installing and maintaining <em>Node.js</em>. Tip You may also want to remove your app from New Relic. For more help Additional documentation resources include: Troubleshooting the <em>Node.js</em> <em>agent</em> (a library of troubleshooting solutions for <em>Node.js</em>)"
      },
      "id": "6043d36a196a676f52960f77"
    },
    {
      "sections": [
        "Node.js agent configuration",
        "Important",
        "Configuration methods and precedence",
        "Agent configuration file",
        "Environment variables",
        "Server-side configuration",
        "Exports variables",
        "app_name (REQUIRED)",
        "Tip",
        "license_key (REQUIRED)",
        "agent_enabled",
        "allow_all_headers",
        "Caution",
        "apdex_t (DEPRECATED)",
        "certificates",
        "high_security",
        "host",
        "labels",
        "port",
        "proxy",
        "proxy_host",
        "proxy_pass",
        "proxy_port",
        "proxy_user",
        "Logging variables",
        "enabled",
        "level",
        "filepath",
        "Audit logging",
        "endpoints",
        "API configuration",
        "custom_attributes_enabled",
        "custom_events_enabled",
        "notice_error_enabled",
        "Attributes",
        "exclude",
        "include",
        "include_enabled",
        "Error collector variables",
        "ignore_status_codes",
        "ignore_classes",
        "ignore_messages",
        "expected_status_codes",
        "expected_classes",
        "expected_messages",
        "attributes.enabled",
        "attributes.exclude",
        "attributes.include",
        "Transaction tracer variables",
        "explain_threshold",
        "record_sql",
        "top_n",
        "transaction_threshold",
        "hide_internals",
        "Rules variables",
        "name",
        "ignore",
        "enforce_backstop",
        "Transaction events variables",
        "max_samples_stored",
        "max_samples_stored (DEPRECATED)",
        "max_samples_per_minute (DEPRECATED)",
        "Browser monitoring variables",
        "enable",
        "debug",
        "Custom events variables",
        "Slow queries variables",
        "max_samples",
        "Custom hostname variables",
        "display_name",
        "ipv_preference",
        "Environment variable overrides",
        "NEW_RELIC_HOME",
        "NEW_RELIC_NO_CONFIG_FILE",
        "Datastore tracer variables",
        "instance_reporting.enabled",
        "database_name_reporting.enabled",
        "Cross application tracing",
        "Error message redaction variables",
        "Distributed tracing",
        "exclude_newrelic_header",
        "Span events",
        "Infinite Tracing",
        "trace_observer.host"
      ],
      "title": "Node.js agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Installation and configuration"
      ],
      "external_id": "6776895960bd4803e98f4c7260c0563c89c09f70",
      "image": "https://docs.newrelic.com/static/bab8ec5bda2eda3aaa5ddaefbed52d93/9fc4b/nodejs-configuration-precedence.png",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/installation-configuration/nodejs-agent-configuration/",
      "published_at": "2021-05-28T15:25:01Z",
      "updated_at": "2021-03-16T15:53:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can tailor the Node.js agent to your app's requirements by editing your newrelic.js config file or by setting an environment variable. The config file resides in the root directory of your app. You can also configure a few options from New Relic, or use the Node.js agent API. Important The license_key setting is required. We highly recommend setting the app_name so that your app has a meaningful name instead of the default My Application. Configuration methods and precedence The primary method to configure the Node.js agent is the agent configuration file (newrelic.js). You can also configure most settings with environment variables. You can also adjust some settings with server-side configuration. The Node.js agent uses this order of precedence for configuration methods: Node.js configuration hierarchy: Server-side configuration settings override environment variables. Environment variables override the agent config file. The config file overrides the agent defaults. Here are detailed descriptions of each configuration method: Agent configuration file The config file (newrelic.js) contains every Node.js agent setting. When you install the Node.js agent, you must copy newrelic.js into your app's root directory. Most settings are empty by default; they inherit their values from config/default.js. Environment variables Most configuration settings in newrelic.js have equivalent environment variables. These are useful, for example, if your agent runs in a PaaS environment such as Heroku or Microsoft Azure. Node.js agent environment variables always start with NEW_RELIC_. Where available, these environment variables are documented below under individual config options as the Environ variable. There are also two rarely used settings that can only be configured via environment variables. Server-side configuration Owners and Admins can view and configure a few settings directly in New Relic. Where available, the UI labels for server-side config are listed in this document under individual config options as the Server-side label. Exports variables This section defines the Node.js agent variables in the order they typically appear in the exports.config = { section of your app's newrelic.js configuration file. app_name (REQUIRED) Type String Default \"My Application\" Environ variable NEW_RELIC_APP_NAME The name New Relic uses to identify your app. For example, app_name: ['MyNodeApp']. To use multiple names for your app, specify a comma-delimited list of names. Data for all applications with the same name will be merged in the New Relic UI, so set this carefully. We highly recommend that you replace the default name with a descriptive name to avoid confusion and unintended aggregation of data. Tip For Azure users, the Node.js agent will use APP_POOL_ID if it is set, so you can use the name you chose for your Azure Web Server without setting it twice. license_key (REQUIRED) Type String Default (none) Environ variable NEW_RELIC_LICENSE_KEY This setting is required. Your New Relic license key. For example, license_key: '40HexadecimalCharacters'. agent_enabled Type Boolean Default true Environ variable NEW_RELIC_ENABLED Set to false to stop the agent from starting up. This is useful when debugging your code requires temporarily disabling the agent. It prevents the agent from bootstrapping its instrumentation or setting up all its pieces, which prevents the agent from starting up and connecting to New Relic's servers. allow_all_headers If true, enables capture of all HTTP headers, except for those filtered by exclude rules. If false, collected headers are limited to those defined in Node.js agent attributes. Type Boolean Default false Caution Any header-related include/exclude rules must be in camelCase form to be filtered. apdex_t (DEPRECATED) Type Number Default 0.100 Server-side label Apdex T Set your Apdex T via the New Relic UI. certificates Type Array of strings Default (none) Additional certificates to trust for SSL connections, specified as an array of strings in PEM format. This affects both connections to an HTTPS proxy and connections to New Relic. Tip You can also configure the agent to read its certificates from a file: certificates: [ fs.readFileSync('myca.crt', {encoding: 'utf8'}) ] Copy high_security Type Boolean Default false Environ variable NEW_RELIC_HIGH_SECURITY When set to true, enables high security v2. You must also enable the ssl setting and enable high security in the UI. host Type String Default collector.newrelic.com Environ variable NEW_RELIC_HOST Important Do not edit this value unless New Relic Support asks you to change it. Hostname for the New Relic collector to connect to the Internet; for example, host: 'collector.newrelic.com'. labels Adds tags. Specify your tags as objects or a semicolon-delimited string of colon-separated pairs (for example, Server:One;Data Center:Primary). Type Object or string Default (none) Environ variable NEW_RELIC_LABELS port Type Integer Default 443 Environ variable NEW_RELIC_PORT Important Do not edit this value unless New Relic Support asks you to change it. Port number to connect to the New Relic collector; for example, port: 443. proxy Type String Default (none) Environ variable NEW_RELIC_PROXY_URL A URL specifying the proxy server to connect to the Internet. For example, proxy: 'http://user:pass@10.0.0.1:8000/'. Important The proxy config file setting overrides the other config file proxy settings (proxy_host, proxy_port, proxy_user, proxy_pass) if used. Similarly, the NEW_RELIC_PROXY_URL environment variable overrides the other environment variable proxy settings (NEW_RELIC_PROXY_HOST, NEW_RELIC_PROXY_PORT, NEW_RELIC_PROXY_USER, and NEW_RELIC_PROXY_PASS) if used. proxy_host Type String Default (none) Environ variable NEW_RELIC_PROXY_HOST Hostname or IP address of the proxy server to connect to the Internet. proxy_pass Type String Default (none) Environ variable NEW_RELIC_PROXY_PASS Password for authenticating to the proxy server. The agent supports only basic HTTP authentication. proxy_port Type String Default (none) Environ variable NEW_RELIC_PROXY_PORT Port number of the proxy server to connect to the Internet. proxy_user Type String Default (none) Environ variable NEW_RELIC_PROXY_USER User name for authenticating to the proxy server. The agent supports only basic HTTP authentication. Logging variables This section defines the Node.js agent variables in the order they typically appear in the logging: { section of your app's newrelic.js configuration file. enabled Type String Default true (false in serverless_mode) Environ variable NEW_RELIC_LOG_ENABLED Enables or disables agent specific logging. level Type String Default info Environ variable NEW_RELIC_LOG_LEVEL Defines the level of detail recorded in the agent logs. From least detail to most detail, possible values are fatal, error, warn, info, debug, or trace. Caution Do not use debug or trace logging unless New Relic Support asks you to use them. These levels of logging can generate excessive overhead. For most situations, use info. filepath Type String Default process.cwd() plus newrelic_agent.log Environ variable NEW_RELIC_LOG Complete path to the New Relic agent log, including the filename. Defaults to filepath: require('path').join(process.cwd(), 'newrelic_agent.log'). The agent will shut down the process if it cannot create this file. The agent creates a log file with the same permissions as the parent Node.js agent process. To write all logging to stdout, set this to stdout. To write all logging to stderr, set this to stderr. Audit logging This section defines the Node.js agent variables in the order they typically appear in the audit_log: { section of your app's newrelic.js configuration file. enabled Type Boolean Default false Environ variable NEW_RELIC_AUDIT_LOG_ENABLED When enabled, the agent logs the payloads it sends to the collector. This data is included in the main log file even when logging level is set to the lowest level. endpoints Type Array Default Empty array (include all types) Environ variable NEW_RELIC_AUDIT_LOG_ENDPOINTS The agent sends several different types of data to the collector in separate payloads. By default, all of them are included in the log file. This option makes it possible to limit logging only to specific types of data. Valid values include: agent_settings analytic_event_data connect custom_event_data error_data error_event_data metric_data preconnect shutdown span_event_data sql_trace_data transaction_sample_data API configuration This section allows you to choose which API methods are enabled. Each configuration option allows you to modularly enable API methods that are responsible for sending custom information to New Relic. Important All of these are set to false when the agent is in high security mode. custom_attributes_enabled Type Boolean Default true Environ variable NEW_RELIC_API_CUSTOM_ATTRIBUTES This option enables newrelic.addCustomAttribute and newrelic.addCustomAttributes. custom_events_enabled Type Boolean Default true Environ variable NEW_RELIC_API_CUSTOM_EVENTS This option enables recordCustomEvent. notice_error_enabled Type Boolean Default true Environ variable NEW_RELIC_API_NOTICE_ERROR This option enables newrelic.noticeError. Attributes This section defines the variables for Node.js agent attributes in the order they typically appear in the attributes: { section of your app's newrelic.js configuration file. Caution Any header-related include/exclude rules must be in camelCase form to be filtered. enabled Type Boolean Default true Environ variable NEW_RELIC_ATTRIBUTES_ENABLED If true, enables capture of attributes for all destinations. exclude Type Array Default [] Environ variable NEW_RELIC_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from all destinations. Allows * as wildcard at end. include Type Array Default [] Environ variable NEW_RELIC_ATTRIBUTES_INCLUDE Prefix of attributes to include from all destinations. Allows * as wildcard at end. include_enabled Type Boolean Default true Environ variable NEW_RELIC_ATTRIBUTES_INCLUDE_ENABLED When true, patterns may be added to the attributes.include list. Error collector variables You can manage how error are handled in New Relic. This section defines the Node.js agent variables in the order they typically appear in the error_collector: { section of your app's newrelic.js configuration file. enabled Type Boolean Default true Environ variable NEW_RELIC_ERROR_COLLECTOR_ENABLED Server-side label Enable error collection? When enabled, the agent collects error traces from your app. ignore_status_codes Type Array Default 404 Environ variable NEW_RELIC_ERROR_COLLECTOR_IGNORE_ERROR_CODES Server-side label Ignore these status codes Comma-delimited list of HTTP status codes for the error collector to ignore. Caution Errors recorded using newrelic.noticeError do not obey this configuration value. ignore_classes Type Array|Object Default [] Environ variable NEW_RELIC_ERROR_COLLECTOR_IGNORE_ERRORS Comma-delimited list of javascript error types/classes for the error collector to ignore. The following configuration /* ... */ error_collector: { ignore_classes: [\"ReferenceError\"] } /* ... */ Copy Would ignore all reference errors. Caution Errors recorded using newrelic.noticeError do not obey this configuration value. ignore_messages Type Object Default {} A javascript object describing a list of javascript classes tied to javascript error messages for the collector to ignore. The following configuration. /* ... */ error_collector: { /* ... */ ignore_messages: {\"Error\":[\"Undefined\", \"Out of time\"]} /* ... */ } /* ... */ Copy Would ignore all errors of type Error, with the exact (case-sensitive) message strings of Undefined and Out of time. Caution Errors recorded using newrelic.noticeError do not obey this configuration value. expected_status_codes Type Array Default [] Environ variable NEW_RELIC_ERROR_COLLECTOR_EXPECTED_ERROR_CODES Comma-delimited list of HTTP status codes for the error collector to mark as expected. Caution Errors recorded using newrelic.noticeError do not obey this configuration value. expected_classes Type Array Default [] Environ variable NEW_RELIC_ERROR_COLLECTOR_EXPECTED_ERRORS The following configuration /* ... */ error_collector: { expected_classes: [\"ReferenceError\"] } /* ... */ Copy Would mark all reference errors as expected. Caution Errors recorded using newrelic.noticeError do not obey this configuration value. expected_messages Type Object Default {} A javascript object describing a list of javascript classes tied to javascript error messages for the collector to ignore. The following configuration. /* ... */ error_collector: { /* ... */ expected_messages: {\"Error\":[\"Undefined\", \"Out of time\"]} /* ... */ } /* ... */ Copy Would mark all errors of type Error, with the exact (case-sensitive) message strings of Undefined and Out of time. Caution Errors recorded using newrelic.noticeError do not obey this configuration value. attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_ERROR_COLLECTOR_ATTRIBUTES_ENABLED If true, the agent captures attributes from error collection. Caution Any header-related include/exclude rules must be in camelCase form to be filtered. attributes.exclude Type Array Default [] Environ variable NEW_RELIC_ERROR_COLLECTOR_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from error collection. Allows * as wildcard at end. attributes.include Type Array Default [] Environ variable NEW_RELIC_ERROR_COLLECTOR_ATTRIBUTES_INCLUDE Prefix of attributes to include in error collection. Allows * as wildcard at end. Transaction tracer variables The agent groups your requests into transactions, which are used to: Visualize where your app spends its time (in transaction breakdowns). Identify slow requests. Group metrics. Isolate other issues, such as slow database performance. This section defines the Node.js agent variables in the order they typically appear in the transaction_tracer: { section of your app's newrelic.js configuration file. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. enabled Type Boolean Default true Environ variable NEW_RELIC_TRACER_ENABLED Server-side label Enable transaction tracing? When enabled, the agent collects slow transaction traces. explain_threshold Type Integer Default 500 Environ variable NEW_RELIC_EXPLAIN_THRESHOLD Minimum query duration (in milliseconds) for a transaction to be eligible for slow queries in transaction traces. record_sql Type String (off, obfuscated, or raw) Default off Environ variable NEW_RELIC_RECORD_SQL This option affects both slow queries and record_sql for transaction traces. It can have one of three values: off, obfuscated, or raw. When set to off no slow queries will be captured, and backtraces and SQL will not be included in transaction traces. If set to raw or obfuscated, the agent sends raw or obfuscated SQL and a slow query sample to the collector. The agent may also send SQL when other criteria are met, such as when slow_sql.enabled is set. top_n Type Integer Default 20 Environ variable NEW_RELIC_TRACER_TOP_N Defines the maximum number of requests eligible for transaction traces. Transactions are named based on the request, and top_n refers to the \"top n slowest transactions\" grouped by these names. The module replaces a recorded trace with a new trace only if the new trace is slower than the previous slowest trace of that name. The default value for this setting is top_n: 20, because the Transactions page also defaults to the 20 slowest transactions. The Node.js agent captures at least five different slow transactions in the first harvest cycle after start up. It will also reset and capture different transactions if no slow transactions have been captured for the last five harvest cycles. This allows you to see more information about more of your app's request paths, at the possible cost of not focusing on the absolutely slowest request for that harvest cycle. Tip To record the absolute slowest transaction over the last minute, you can set top_n: 0 or top_n: 1. However, this causes one very slow route to dominate your transaction traces. transaction_threshold Type Integer or apdex_f Default apdex_f Environ variable NEW_RELIC_TRACER_THRESHOLD Server-side label Threshold Threshold of web transaction response time in seconds beyond which a transaction is eligible for transaction tracing. The default value is apdex_f; this sets the trace threshold to four times your application's Apdex T. You can also enter a specific time value in milliseconds. Example: Threshold set to apdex_f The default apdex_t is 100 milliseconds. If your transaction threshold is set to apdex_f, a \"slow\" transaction is 400 milliseconds. hide_internals Type boolean Default true Environ variable NEW_RELIC_HIDE_INTERNALS The agent uses a small amount of CPU in order to hide internal properties that are attached to the web application. If you change this configuration to false, it may slightly decrease your agent overhead, but it could also have an impact on the performance of the agent. attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_TRANSACTION_TRACER_ATTRIBUTES_ENABLED If true, the agent captures attributes from transaction traces. Caution Any header-related include/exclude rules must be in camelCase form to be filtered. attributes.exclude Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_TRACER_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from transaction traces. Allows * as wildcard at end. attributes.include Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_TRACER_ATTRIBUTES_INCLUDE Prefix of attributes to include in transaction traces. Allows * as wildcard at end. Rules variables This section defines the Node.js agent variables in the order they typically appear in the rules: { section of your app's newrelic.js configuration file. name Type Strings or regular expressions Default (none) Environ variable NEW_RELIC_NAMING_RULES A comma-delimited list of rules to match incoming request URLs and name the associated New Relic transaction. Uses the format: name: [ {pattern: 'STRING_OR_REGEX', name: 'NAME'}, {pattern: 'STRING_OR_REGEX', name: 'NAME'} ], Copy Both parameters are required. For strings, you must escape control characters. You do not need to escape control characters in regular expressions. Additional attributes are ignored. Regular expressions support JavaScript-style capture groups, and names use $1-style replacement strings. Regular expressions only find the first matching result; subsequent matches are ignored. For more information, see Node.js transaction naming API. For the NEW_RELIC_NAMING_RULES environment variable, pass the rules as comma-delimited JSON object literals: NEW_RELIC_NAMING_RULES='{\"pattern\":\"^t\",\"name\":\"u\"},{\"pattern\":\"^u\",\"name\":\"t\"}' Copy ignore Type Strings or regular expressions Default Regular expression to match socket.io long-polling requests (\"^ \\ /socket \\ .io \\ /. * \\ /xhr-polling/\"). Environ variable NEW_RELIC_IGNORING_RULES Define a list of request URLs you want the agent to ignore. Specify the list as patterns, which can be strings or regular expressions. enforce_backstop Type Boolean Default true Environ variable NEW_RELIC_ENFORCE_BACKSTOP Caution Do not change this setting unless you understand metric grouping issues. When enabled, the agent renames transactions that are not affected by other naming logic (such as the API, rules, or metric normalization rules) to NormalizedUri/*. If you set this to false, the agent sets transaction names to Uri/path/to/resource. Transaction events variables This section defines the Node.js agent variables in the order they typically appear in the transaction_events: { section of your app's newrelic.js configuration file. enabled Type Boolean Default true When enabled, the agent sends transaction events to New Relic. This event data includes transaction timing, transaction name, and any custom parameters. If this is disabled, the agent does not collect this data or send it to New Relic. max_samples_stored Type Integer Default 10000 Defines the maximum number of events the agent collects per minute. If there are more than this number, the agent collects a statistical sampling. We do not recommend configuring past 10k. The server will cap data at 10k per-minute. Important This configuration had different behavior in agent versions lower than 6.0.0. See max_samples_stored (DEPRECATED) for agent versions 5.x or lower. max_samples_stored (DEPRECATED) Type Integer Default 20000 Defines the maximum number of events the agent stores if it is unable to communicate with the New Relic collector. The values from the previous harvest cycle will be merged into the next one, with this option limiting the maximum number. Make sure this number is greater than max_samples_per_minute; for example, set it to twice as much. Consider your memory overhead before increasing this value. Caution This configuration has different behavior starting with agent version 6.0.0 and a new recommended maximum. See max_samples_stored for agent versions 6.x or higher. max_samples_per_minute (DEPRECATED) Type Integer Default 10000 Defines the maximum number of events the agent collects per minute. If there are more than this number, the agent collects a statistical sampling. Caution This configuration has been replaced with max_samples_stored starting with version 6.0.0 of the agent. See max_samples_stored for 6.x or later agents. attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_TRANSACTION_EVENTS_ATTRIBUTES_ENABLED If true, the agent captures attributes from transaction events. Caution Any header-related include/exclude rules must be in camelCase form to be filtered. attributes.exclude Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_EVENTS_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from transaction events. Allows * as wildcard at end. attributes.include Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_EVENTS_ATTRIBUTES_INCLUDE Prefix of attributes to include in transaction events. Allows * as wildcard at end. Browser monitoring variables This section defines the Node.js agent variables in the order they typically appear in the browser_monitoring: { section of your app's newrelic.js configuration file. enable Type Boolean Default true Environ variable NEW_RELIC_BROWSER_MONITOR_ENABLE Server-side label Enable browser monitoring? Generate JavaScript headers for browser instrumentation. Although this defaults to true, the agent doesn't inject the browser JS code unless you have enabled browser monitoring. Even if you have enabled it and added the browser timing header, you can disable browser monitoring for your app by setting this to false. debug Type Boolean Default false Environ variable NEW_RELIC_BROWSER_MONITOR_DEBUG If true, request un-minified sources from the server. attributes.enabled Type Boolean Default false Environ variable NEW_RELIC_BROWSER_MONITORING_ATTRIBUTES_ENABLED If true, the agent sends custom attributes to browser monitoring. Caution Any header-related include/exclude rules must be in camelCase form to be filtered. attributes.exclude Type Array Default [] Environ variable NEW_RELIC_BROWSER_MONITORING_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from browser monitoring. Allows * as wildcard at end. attributes.include Type Array Default [] Environ variable NEW_RELIC_BROWSER_MONITORING_ATTRIBUTES_INCLUDE Prefix of attributes to include in browser monitoring. Allows * as wildcard at end. Custom events variables This section defines the Node.js agent variables in the order they typically appear in the custom_insights_events: { section of your app's newrelic.js configuration file. Currently there are no environment variables for custom events. enabled Type Boolean Default true When enabled, the agent sends custom events recorded with recordCustomEvent() to New Relic. If this is disabled, the agent does not collect this data or send it to New Relic. max_samples_stored Type Integer Default 1000 Defines the maximum number of custom events the agent collects per minute. If the number of custom events exceeds this limit, the agent collects a statistical sampling. Important Increasing this limit increases memory usage. Slow queries variables This section defines the Node.js agent variables in the order they typically appear in the slow_sql: { section of your app's newrelic.js configuration file. These options control behavior for slow queries, but do not affect SQL nodes in transaction traces. enabled Type Boolean Default false Environ variable NEW_RELIC_SLOW_SQL_ENABLED When enabled, the agent collects slow query details. max_samples Type Integer Default 10 Environ variable NEW_RELIC_MAX_SQL_SAMPLES Defines the maximum number of slow queries the agent collects per minute. The agent discards additional queries after the limit is reached. Important Increasing this limit increases memory usage. Custom hostname variables This section defines the Node.js agent variables in the order they typically appear in the process_host: { section of your app's newrelic.js configuration file. These options control behavior regarding the host display name in the New Relic APM UI. display_name Type String of 255 bytes or less Default (none) Environ variable NEW_RELIC_PROCESS_HOST_DISPLAY_NAME Specify a custom hostname for display in New Relic. If you do not set this field, New Relic will continue to use the default hostname found by calling os.hostname(). If you use the default hostname settings, New Relic finds the hostname through os.hostname(). If this call fails, New Relic uses the host's IP as the name. If you set ipv_preference: 4 or ipv_preference: 6, you can select the type of IP address (IPv4 or IPv6) that appears in the New Relic UI. ipv_preference Type Integer (4 or 6) Default 4 Environ variable NEW_RELIC_IPV_PREFERENCE Environment variable overrides This section defines two configuration options only available with environment variables. These overrides are not used in most configurations. NEW_RELIC_HOME Path to the directory containing newrelic.js. This is available only as an environment variable. You cannot set it in your config file. Type String Default (none) NEW_RELIC_NO_CONFIG_FILE If used, this prevents the agent from reading configuration settings from newrelic.js. Default values and values from environment variables will still be set. This is available only as an environment variable. You cannot set it in your config file. Type Boolean Default False Datastore tracer variables This section defines the Node.js agent variables in the order they typically appear in the datastore_tracer section of your app's newrelic.js configuration file. These options control behavior for collecting datastore instance metrics. instance_reporting.enabled Type Boolean Default true When enabled, the agent collects datastore instance metrics (such as host and port) for some database drivers. These are reported on slow query traces and transaction traces. database_name_reporting.enabled Type Boolean Default true When enabled, the agent collects database name on slow query traces and transaction traces for some database drivers. Cross application tracing The Node.js agent variables that control cross application tracing typically appear in the cross_application_tracer section of your app's newrelic.js configuration file: enabled Type Boolean Default true When set to true, allows tracing of transactions across more than one New Relic-monitored applications. Error message redaction variables The Node.js agent variables that control error message redaction appear in the allow_raw_exception_messages section of your app's newrelic.js configuration file: enabled Type Boolean Default true Environ variable NEW_RELIC_ALLOW_RAW_EXCEPTION_MESSAGES_ENABLED When false, the agent will redact the messages of captured errors. Distributed tracing Important Enabling distributed tracing disables cross application tracing, and has effects on other APM features. Before enabling, read the transition guide. Requires Node.js agent version 4.7.0 or higher. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. When configuring via the config file, place the following option in the distributed_tracing section. When distributed tracing is enabled, you can collect span events. enabled Type Boolean Default false Environ variable NEW_RELIC_DISTRIBUTED_TRACING_ENABLED Set this to true to enable distributed tracing. For example, to enable this in the config file, you would use: distributed_tracing: { enabled: true } Copy exclude_newrelic_header Type Boolean Default false Set this to true to exclude the New Relic header that is attached to outbound requests, and instead only rely on W3C Trace Context Headers for distributed tracing. If this is false then both types of headers are used. For example, to enable this in the config file, you would use: distributed_tracing:{ enabled: true, exclude_newrelic_header: true } Copy Span events Span events are reported for distributed tracing. Distributed tracing must be enabled to report span events. Span configuration is set in the span_events stanza. Options include: enabled Type Boolean Default true Environ variable NEW_RELIC_SPAN_EVENTS_ENABLED Turns reporting of span events on or off. attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_SPAN_EVENTS_ATTRIBUTES_ENABLED This setting can be used to turn reporting of attributes on or off for span events. If attributes.enabled at the root level is false, no attributes will be sent to span events regardless on how this is set. attributes.include Type Array Default [] Environ variable NEW_RELIC_SPAN_EVENTS_ATTRIBUTES_INCLUDE If attributes are enabled for span events, all attribute keys found in this list will be attached to span events. For more information, see the agent attribute rules. attributes.exclude Type Array Default [] Environ variable NEW_RELIC_SPAN_EVENTS_ATTRIBUTES_EXCLUDE All attribute keys found in this list will not be sent with span events. For more information, see the agent attribute rules. Infinite Tracing To turn on Infinite Tracing, enable distributed tracing (set distributed_tracing to enabled: true) and add the additional settings below. For an example, see Language Agents: Configure Distributed Tracing. trace_observer.host Type String Default (none) Environ variable NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST For help getting a valid Infinite Tracing trace observer host entry, see Find or create a trace observer endpoint.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 148.5103,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Node.js <em>agent</em> <em>configuration</em>",
        "sections": "Node.js <em>agent</em> <em>configuration</em>",
        "tags": "<em>Installation</em> <em>and</em> <em>configuration</em>",
        "body": " The license_key setting is required. We highly recommend setting the app_name so that your app has a meaningful name instead of the default My Application. <em>Configuration</em> methods and precedence The primary method to configure the <em>Node.js</em> <em>agent</em> is the <em>agent</em> <em>configuration</em> file (newrelic.js). You can also"
      },
      "id": "603e87a728ccbc4653eba75b"
    }
  ],
  "/docs/agents/nodejs-agent/installation-configuration/install-nodejs-agent": [
    {
      "sections": [
        "Uninstall the Node.js agent",
        "Tip",
        "For more help"
      ],
      "title": "Uninstall the Node.js agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Installation and configuration"
      ],
      "external_id": "17cdfffa0ea6ea5888c601dca3846e50772fc112",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/installation-configuration/uninstall-nodejs-agent/",
      "published_at": "2021-06-02T20:29:31Z",
      "updated_at": "2021-03-13T02:39:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Read on to learn how to uninstall the New Relic Node.js agent. For instructions on how to temporarily disable the agent, see Disable the agent. To uninstall the New Relic Node.js agent: Remove require('newrelic'); as the first line of the app's main module. Remove the npm package with npm uninstall newrelic --save. Delete the newrelic.js file and unset any environment variables being used. When the uninstall process finishes, restart your app. For more information about installation, see Installing and maintaining Node.js. Tip You may also want to remove your app from New Relic. For more help Additional documentation resources include: Troubleshooting the Node.js agent (a library of troubleshooting solutions for Node.js)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 148.51941,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Uninstall the Node.js <em>agent</em>",
        "sections": "Uninstall the Node.js <em>agent</em>",
        "tags": "<em>Installation</em> <em>and</em> <em>configuration</em>",
        "body": " newrelic --save. Delete the newrelic.js file and unset any environment variables being used. When the uninstall process finishes, restart your app. For more information about <em>installation</em>, see Installing and maintaining <em>Node.js</em>. Tip You may also want to remove your app from New Relic. For more help Additional documentation resources include: Troubleshooting the <em>Node.js</em> <em>agent</em> (a library of troubleshooting solutions for <em>Node.js</em>)"
      },
      "id": "6043d36a196a676f52960f77"
    },
    {
      "sections": [
        "Node.js agent configuration",
        "Important",
        "Configuration methods and precedence",
        "Agent configuration file",
        "Environment variables",
        "Server-side configuration",
        "Exports variables",
        "app_name (REQUIRED)",
        "Tip",
        "license_key (REQUIRED)",
        "agent_enabled",
        "allow_all_headers",
        "Caution",
        "apdex_t (DEPRECATED)",
        "certificates",
        "high_security",
        "host",
        "labels",
        "port",
        "proxy",
        "proxy_host",
        "proxy_pass",
        "proxy_port",
        "proxy_user",
        "Logging variables",
        "enabled",
        "level",
        "filepath",
        "Audit logging",
        "endpoints",
        "API configuration",
        "custom_attributes_enabled",
        "custom_events_enabled",
        "notice_error_enabled",
        "Attributes",
        "exclude",
        "include",
        "include_enabled",
        "Error collector variables",
        "ignore_status_codes",
        "ignore_classes",
        "ignore_messages",
        "expected_status_codes",
        "expected_classes",
        "expected_messages",
        "attributes.enabled",
        "attributes.exclude",
        "attributes.include",
        "Transaction tracer variables",
        "explain_threshold",
        "record_sql",
        "top_n",
        "transaction_threshold",
        "hide_internals",
        "Rules variables",
        "name",
        "ignore",
        "enforce_backstop",
        "Transaction events variables",
        "max_samples_stored",
        "max_samples_stored (DEPRECATED)",
        "max_samples_per_minute (DEPRECATED)",
        "Browser monitoring variables",
        "enable",
        "debug",
        "Custom events variables",
        "Slow queries variables",
        "max_samples",
        "Custom hostname variables",
        "display_name",
        "ipv_preference",
        "Environment variable overrides",
        "NEW_RELIC_HOME",
        "NEW_RELIC_NO_CONFIG_FILE",
        "Datastore tracer variables",
        "instance_reporting.enabled",
        "database_name_reporting.enabled",
        "Cross application tracing",
        "Error message redaction variables",
        "Distributed tracing",
        "exclude_newrelic_header",
        "Span events",
        "Infinite Tracing",
        "trace_observer.host"
      ],
      "title": "Node.js agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Installation and configuration"
      ],
      "external_id": "6776895960bd4803e98f4c7260c0563c89c09f70",
      "image": "https://docs.newrelic.com/static/bab8ec5bda2eda3aaa5ddaefbed52d93/9fc4b/nodejs-configuration-precedence.png",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/installation-configuration/nodejs-agent-configuration/",
      "published_at": "2021-05-28T15:25:01Z",
      "updated_at": "2021-03-16T15:53:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can tailor the Node.js agent to your app's requirements by editing your newrelic.js config file or by setting an environment variable. The config file resides in the root directory of your app. You can also configure a few options from New Relic, or use the Node.js agent API. Important The license_key setting is required. We highly recommend setting the app_name so that your app has a meaningful name instead of the default My Application. Configuration methods and precedence The primary method to configure the Node.js agent is the agent configuration file (newrelic.js). You can also configure most settings with environment variables. You can also adjust some settings with server-side configuration. The Node.js agent uses this order of precedence for configuration methods: Node.js configuration hierarchy: Server-side configuration settings override environment variables. Environment variables override the agent config file. The config file overrides the agent defaults. Here are detailed descriptions of each configuration method: Agent configuration file The config file (newrelic.js) contains every Node.js agent setting. When you install the Node.js agent, you must copy newrelic.js into your app's root directory. Most settings are empty by default; they inherit their values from config/default.js. Environment variables Most configuration settings in newrelic.js have equivalent environment variables. These are useful, for example, if your agent runs in a PaaS environment such as Heroku or Microsoft Azure. Node.js agent environment variables always start with NEW_RELIC_. Where available, these environment variables are documented below under individual config options as the Environ variable. There are also two rarely used settings that can only be configured via environment variables. Server-side configuration Owners and Admins can view and configure a few settings directly in New Relic. Where available, the UI labels for server-side config are listed in this document under individual config options as the Server-side label. Exports variables This section defines the Node.js agent variables in the order they typically appear in the exports.config = { section of your app's newrelic.js configuration file. app_name (REQUIRED) Type String Default \"My Application\" Environ variable NEW_RELIC_APP_NAME The name New Relic uses to identify your app. For example, app_name: ['MyNodeApp']. To use multiple names for your app, specify a comma-delimited list of names. Data for all applications with the same name will be merged in the New Relic UI, so set this carefully. We highly recommend that you replace the default name with a descriptive name to avoid confusion and unintended aggregation of data. Tip For Azure users, the Node.js agent will use APP_POOL_ID if it is set, so you can use the name you chose for your Azure Web Server without setting it twice. license_key (REQUIRED) Type String Default (none) Environ variable NEW_RELIC_LICENSE_KEY This setting is required. Your New Relic license key. For example, license_key: '40HexadecimalCharacters'. agent_enabled Type Boolean Default true Environ variable NEW_RELIC_ENABLED Set to false to stop the agent from starting up. This is useful when debugging your code requires temporarily disabling the agent. It prevents the agent from bootstrapping its instrumentation or setting up all its pieces, which prevents the agent from starting up and connecting to New Relic's servers. allow_all_headers If true, enables capture of all HTTP headers, except for those filtered by exclude rules. If false, collected headers are limited to those defined in Node.js agent attributes. Type Boolean Default false Caution Any header-related include/exclude rules must be in camelCase form to be filtered. apdex_t (DEPRECATED) Type Number Default 0.100 Server-side label Apdex T Set your Apdex T via the New Relic UI. certificates Type Array of strings Default (none) Additional certificates to trust for SSL connections, specified as an array of strings in PEM format. This affects both connections to an HTTPS proxy and connections to New Relic. Tip You can also configure the agent to read its certificates from a file: certificates: [ fs.readFileSync('myca.crt', {encoding: 'utf8'}) ] Copy high_security Type Boolean Default false Environ variable NEW_RELIC_HIGH_SECURITY When set to true, enables high security v2. You must also enable the ssl setting and enable high security in the UI. host Type String Default collector.newrelic.com Environ variable NEW_RELIC_HOST Important Do not edit this value unless New Relic Support asks you to change it. Hostname for the New Relic collector to connect to the Internet; for example, host: 'collector.newrelic.com'. labels Adds tags. Specify your tags as objects or a semicolon-delimited string of colon-separated pairs (for example, Server:One;Data Center:Primary). Type Object or string Default (none) Environ variable NEW_RELIC_LABELS port Type Integer Default 443 Environ variable NEW_RELIC_PORT Important Do not edit this value unless New Relic Support asks you to change it. Port number to connect to the New Relic collector; for example, port: 443. proxy Type String Default (none) Environ variable NEW_RELIC_PROXY_URL A URL specifying the proxy server to connect to the Internet. For example, proxy: 'http://user:pass@10.0.0.1:8000/'. Important The proxy config file setting overrides the other config file proxy settings (proxy_host, proxy_port, proxy_user, proxy_pass) if used. Similarly, the NEW_RELIC_PROXY_URL environment variable overrides the other environment variable proxy settings (NEW_RELIC_PROXY_HOST, NEW_RELIC_PROXY_PORT, NEW_RELIC_PROXY_USER, and NEW_RELIC_PROXY_PASS) if used. proxy_host Type String Default (none) Environ variable NEW_RELIC_PROXY_HOST Hostname or IP address of the proxy server to connect to the Internet. proxy_pass Type String Default (none) Environ variable NEW_RELIC_PROXY_PASS Password for authenticating to the proxy server. The agent supports only basic HTTP authentication. proxy_port Type String Default (none) Environ variable NEW_RELIC_PROXY_PORT Port number of the proxy server to connect to the Internet. proxy_user Type String Default (none) Environ variable NEW_RELIC_PROXY_USER User name for authenticating to the proxy server. The agent supports only basic HTTP authentication. Logging variables This section defines the Node.js agent variables in the order they typically appear in the logging: { section of your app's newrelic.js configuration file. enabled Type String Default true (false in serverless_mode) Environ variable NEW_RELIC_LOG_ENABLED Enables or disables agent specific logging. level Type String Default info Environ variable NEW_RELIC_LOG_LEVEL Defines the level of detail recorded in the agent logs. From least detail to most detail, possible values are fatal, error, warn, info, debug, or trace. Caution Do not use debug or trace logging unless New Relic Support asks you to use them. These levels of logging can generate excessive overhead. For most situations, use info. filepath Type String Default process.cwd() plus newrelic_agent.log Environ variable NEW_RELIC_LOG Complete path to the New Relic agent log, including the filename. Defaults to filepath: require('path').join(process.cwd(), 'newrelic_agent.log'). The agent will shut down the process if it cannot create this file. The agent creates a log file with the same permissions as the parent Node.js agent process. To write all logging to stdout, set this to stdout. To write all logging to stderr, set this to stderr. Audit logging This section defines the Node.js agent variables in the order they typically appear in the audit_log: { section of your app's newrelic.js configuration file. enabled Type Boolean Default false Environ variable NEW_RELIC_AUDIT_LOG_ENABLED When enabled, the agent logs the payloads it sends to the collector. This data is included in the main log file even when logging level is set to the lowest level. endpoints Type Array Default Empty array (include all types) Environ variable NEW_RELIC_AUDIT_LOG_ENDPOINTS The agent sends several different types of data to the collector in separate payloads. By default, all of them are included in the log file. This option makes it possible to limit logging only to specific types of data. Valid values include: agent_settings analytic_event_data connect custom_event_data error_data error_event_data metric_data preconnect shutdown span_event_data sql_trace_data transaction_sample_data API configuration This section allows you to choose which API methods are enabled. Each configuration option allows you to modularly enable API methods that are responsible for sending custom information to New Relic. Important All of these are set to false when the agent is in high security mode. custom_attributes_enabled Type Boolean Default true Environ variable NEW_RELIC_API_CUSTOM_ATTRIBUTES This option enables newrelic.addCustomAttribute and newrelic.addCustomAttributes. custom_events_enabled Type Boolean Default true Environ variable NEW_RELIC_API_CUSTOM_EVENTS This option enables recordCustomEvent. notice_error_enabled Type Boolean Default true Environ variable NEW_RELIC_API_NOTICE_ERROR This option enables newrelic.noticeError. Attributes This section defines the variables for Node.js agent attributes in the order they typically appear in the attributes: { section of your app's newrelic.js configuration file. Caution Any header-related include/exclude rules must be in camelCase form to be filtered. enabled Type Boolean Default true Environ variable NEW_RELIC_ATTRIBUTES_ENABLED If true, enables capture of attributes for all destinations. exclude Type Array Default [] Environ variable NEW_RELIC_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from all destinations. Allows * as wildcard at end. include Type Array Default [] Environ variable NEW_RELIC_ATTRIBUTES_INCLUDE Prefix of attributes to include from all destinations. Allows * as wildcard at end. include_enabled Type Boolean Default true Environ variable NEW_RELIC_ATTRIBUTES_INCLUDE_ENABLED When true, patterns may be added to the attributes.include list. Error collector variables You can manage how error are handled in New Relic. This section defines the Node.js agent variables in the order they typically appear in the error_collector: { section of your app's newrelic.js configuration file. enabled Type Boolean Default true Environ variable NEW_RELIC_ERROR_COLLECTOR_ENABLED Server-side label Enable error collection? When enabled, the agent collects error traces from your app. ignore_status_codes Type Array Default 404 Environ variable NEW_RELIC_ERROR_COLLECTOR_IGNORE_ERROR_CODES Server-side label Ignore these status codes Comma-delimited list of HTTP status codes for the error collector to ignore. Caution Errors recorded using newrelic.noticeError do not obey this configuration value. ignore_classes Type Array|Object Default [] Environ variable NEW_RELIC_ERROR_COLLECTOR_IGNORE_ERRORS Comma-delimited list of javascript error types/classes for the error collector to ignore. The following configuration /* ... */ error_collector: { ignore_classes: [\"ReferenceError\"] } /* ... */ Copy Would ignore all reference errors. Caution Errors recorded using newrelic.noticeError do not obey this configuration value. ignore_messages Type Object Default {} A javascript object describing a list of javascript classes tied to javascript error messages for the collector to ignore. The following configuration. /* ... */ error_collector: { /* ... */ ignore_messages: {\"Error\":[\"Undefined\", \"Out of time\"]} /* ... */ } /* ... */ Copy Would ignore all errors of type Error, with the exact (case-sensitive) message strings of Undefined and Out of time. Caution Errors recorded using newrelic.noticeError do not obey this configuration value. expected_status_codes Type Array Default [] Environ variable NEW_RELIC_ERROR_COLLECTOR_EXPECTED_ERROR_CODES Comma-delimited list of HTTP status codes for the error collector to mark as expected. Caution Errors recorded using newrelic.noticeError do not obey this configuration value. expected_classes Type Array Default [] Environ variable NEW_RELIC_ERROR_COLLECTOR_EXPECTED_ERRORS The following configuration /* ... */ error_collector: { expected_classes: [\"ReferenceError\"] } /* ... */ Copy Would mark all reference errors as expected. Caution Errors recorded using newrelic.noticeError do not obey this configuration value. expected_messages Type Object Default {} A javascript object describing a list of javascript classes tied to javascript error messages for the collector to ignore. The following configuration. /* ... */ error_collector: { /* ... */ expected_messages: {\"Error\":[\"Undefined\", \"Out of time\"]} /* ... */ } /* ... */ Copy Would mark all errors of type Error, with the exact (case-sensitive) message strings of Undefined and Out of time. Caution Errors recorded using newrelic.noticeError do not obey this configuration value. attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_ERROR_COLLECTOR_ATTRIBUTES_ENABLED If true, the agent captures attributes from error collection. Caution Any header-related include/exclude rules must be in camelCase form to be filtered. attributes.exclude Type Array Default [] Environ variable NEW_RELIC_ERROR_COLLECTOR_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from error collection. Allows * as wildcard at end. attributes.include Type Array Default [] Environ variable NEW_RELIC_ERROR_COLLECTOR_ATTRIBUTES_INCLUDE Prefix of attributes to include in error collection. Allows * as wildcard at end. Transaction tracer variables The agent groups your requests into transactions, which are used to: Visualize where your app spends its time (in transaction breakdowns). Identify slow requests. Group metrics. Isolate other issues, such as slow database performance. This section defines the Node.js agent variables in the order they typically appear in the transaction_tracer: { section of your app's newrelic.js configuration file. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. enabled Type Boolean Default true Environ variable NEW_RELIC_TRACER_ENABLED Server-side label Enable transaction tracing? When enabled, the agent collects slow transaction traces. explain_threshold Type Integer Default 500 Environ variable NEW_RELIC_EXPLAIN_THRESHOLD Minimum query duration (in milliseconds) for a transaction to be eligible for slow queries in transaction traces. record_sql Type String (off, obfuscated, or raw) Default off Environ variable NEW_RELIC_RECORD_SQL This option affects both slow queries and record_sql for transaction traces. It can have one of three values: off, obfuscated, or raw. When set to off no slow queries will be captured, and backtraces and SQL will not be included in transaction traces. If set to raw or obfuscated, the agent sends raw or obfuscated SQL and a slow query sample to the collector. The agent may also send SQL when other criteria are met, such as when slow_sql.enabled is set. top_n Type Integer Default 20 Environ variable NEW_RELIC_TRACER_TOP_N Defines the maximum number of requests eligible for transaction traces. Transactions are named based on the request, and top_n refers to the \"top n slowest transactions\" grouped by these names. The module replaces a recorded trace with a new trace only if the new trace is slower than the previous slowest trace of that name. The default value for this setting is top_n: 20, because the Transactions page also defaults to the 20 slowest transactions. The Node.js agent captures at least five different slow transactions in the first harvest cycle after start up. It will also reset and capture different transactions if no slow transactions have been captured for the last five harvest cycles. This allows you to see more information about more of your app's request paths, at the possible cost of not focusing on the absolutely slowest request for that harvest cycle. Tip To record the absolute slowest transaction over the last minute, you can set top_n: 0 or top_n: 1. However, this causes one very slow route to dominate your transaction traces. transaction_threshold Type Integer or apdex_f Default apdex_f Environ variable NEW_RELIC_TRACER_THRESHOLD Server-side label Threshold Threshold of web transaction response time in seconds beyond which a transaction is eligible for transaction tracing. The default value is apdex_f; this sets the trace threshold to four times your application's Apdex T. You can also enter a specific time value in milliseconds. Example: Threshold set to apdex_f The default apdex_t is 100 milliseconds. If your transaction threshold is set to apdex_f, a \"slow\" transaction is 400 milliseconds. hide_internals Type boolean Default true Environ variable NEW_RELIC_HIDE_INTERNALS The agent uses a small amount of CPU in order to hide internal properties that are attached to the web application. If you change this configuration to false, it may slightly decrease your agent overhead, but it could also have an impact on the performance of the agent. attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_TRANSACTION_TRACER_ATTRIBUTES_ENABLED If true, the agent captures attributes from transaction traces. Caution Any header-related include/exclude rules must be in camelCase form to be filtered. attributes.exclude Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_TRACER_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from transaction traces. Allows * as wildcard at end. attributes.include Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_TRACER_ATTRIBUTES_INCLUDE Prefix of attributes to include in transaction traces. Allows * as wildcard at end. Rules variables This section defines the Node.js agent variables in the order they typically appear in the rules: { section of your app's newrelic.js configuration file. name Type Strings or regular expressions Default (none) Environ variable NEW_RELIC_NAMING_RULES A comma-delimited list of rules to match incoming request URLs and name the associated New Relic transaction. Uses the format: name: [ {pattern: 'STRING_OR_REGEX', name: 'NAME'}, {pattern: 'STRING_OR_REGEX', name: 'NAME'} ], Copy Both parameters are required. For strings, you must escape control characters. You do not need to escape control characters in regular expressions. Additional attributes are ignored. Regular expressions support JavaScript-style capture groups, and names use $1-style replacement strings. Regular expressions only find the first matching result; subsequent matches are ignored. For more information, see Node.js transaction naming API. For the NEW_RELIC_NAMING_RULES environment variable, pass the rules as comma-delimited JSON object literals: NEW_RELIC_NAMING_RULES='{\"pattern\":\"^t\",\"name\":\"u\"},{\"pattern\":\"^u\",\"name\":\"t\"}' Copy ignore Type Strings or regular expressions Default Regular expression to match socket.io long-polling requests (\"^ \\ /socket \\ .io \\ /. * \\ /xhr-polling/\"). Environ variable NEW_RELIC_IGNORING_RULES Define a list of request URLs you want the agent to ignore. Specify the list as patterns, which can be strings or regular expressions. enforce_backstop Type Boolean Default true Environ variable NEW_RELIC_ENFORCE_BACKSTOP Caution Do not change this setting unless you understand metric grouping issues. When enabled, the agent renames transactions that are not affected by other naming logic (such as the API, rules, or metric normalization rules) to NormalizedUri/*. If you set this to false, the agent sets transaction names to Uri/path/to/resource. Transaction events variables This section defines the Node.js agent variables in the order they typically appear in the transaction_events: { section of your app's newrelic.js configuration file. enabled Type Boolean Default true When enabled, the agent sends transaction events to New Relic. This event data includes transaction timing, transaction name, and any custom parameters. If this is disabled, the agent does not collect this data or send it to New Relic. max_samples_stored Type Integer Default 10000 Defines the maximum number of events the agent collects per minute. If there are more than this number, the agent collects a statistical sampling. We do not recommend configuring past 10k. The server will cap data at 10k per-minute. Important This configuration had different behavior in agent versions lower than 6.0.0. See max_samples_stored (DEPRECATED) for agent versions 5.x or lower. max_samples_stored (DEPRECATED) Type Integer Default 20000 Defines the maximum number of events the agent stores if it is unable to communicate with the New Relic collector. The values from the previous harvest cycle will be merged into the next one, with this option limiting the maximum number. Make sure this number is greater than max_samples_per_minute; for example, set it to twice as much. Consider your memory overhead before increasing this value. Caution This configuration has different behavior starting with agent version 6.0.0 and a new recommended maximum. See max_samples_stored for agent versions 6.x or higher. max_samples_per_minute (DEPRECATED) Type Integer Default 10000 Defines the maximum number of events the agent collects per minute. If there are more than this number, the agent collects a statistical sampling. Caution This configuration has been replaced with max_samples_stored starting with version 6.0.0 of the agent. See max_samples_stored for 6.x or later agents. attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_TRANSACTION_EVENTS_ATTRIBUTES_ENABLED If true, the agent captures attributes from transaction events. Caution Any header-related include/exclude rules must be in camelCase form to be filtered. attributes.exclude Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_EVENTS_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from transaction events. Allows * as wildcard at end. attributes.include Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_EVENTS_ATTRIBUTES_INCLUDE Prefix of attributes to include in transaction events. Allows * as wildcard at end. Browser monitoring variables This section defines the Node.js agent variables in the order they typically appear in the browser_monitoring: { section of your app's newrelic.js configuration file. enable Type Boolean Default true Environ variable NEW_RELIC_BROWSER_MONITOR_ENABLE Server-side label Enable browser monitoring? Generate JavaScript headers for browser instrumentation. Although this defaults to true, the agent doesn't inject the browser JS code unless you have enabled browser monitoring. Even if you have enabled it and added the browser timing header, you can disable browser monitoring for your app by setting this to false. debug Type Boolean Default false Environ variable NEW_RELIC_BROWSER_MONITOR_DEBUG If true, request un-minified sources from the server. attributes.enabled Type Boolean Default false Environ variable NEW_RELIC_BROWSER_MONITORING_ATTRIBUTES_ENABLED If true, the agent sends custom attributes to browser monitoring. Caution Any header-related include/exclude rules must be in camelCase form to be filtered. attributes.exclude Type Array Default [] Environ variable NEW_RELIC_BROWSER_MONITORING_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from browser monitoring. Allows * as wildcard at end. attributes.include Type Array Default [] Environ variable NEW_RELIC_BROWSER_MONITORING_ATTRIBUTES_INCLUDE Prefix of attributes to include in browser monitoring. Allows * as wildcard at end. Custom events variables This section defines the Node.js agent variables in the order they typically appear in the custom_insights_events: { section of your app's newrelic.js configuration file. Currently there are no environment variables for custom events. enabled Type Boolean Default true When enabled, the agent sends custom events recorded with recordCustomEvent() to New Relic. If this is disabled, the agent does not collect this data or send it to New Relic. max_samples_stored Type Integer Default 1000 Defines the maximum number of custom events the agent collects per minute. If the number of custom events exceeds this limit, the agent collects a statistical sampling. Important Increasing this limit increases memory usage. Slow queries variables This section defines the Node.js agent variables in the order they typically appear in the slow_sql: { section of your app's newrelic.js configuration file. These options control behavior for slow queries, but do not affect SQL nodes in transaction traces. enabled Type Boolean Default false Environ variable NEW_RELIC_SLOW_SQL_ENABLED When enabled, the agent collects slow query details. max_samples Type Integer Default 10 Environ variable NEW_RELIC_MAX_SQL_SAMPLES Defines the maximum number of slow queries the agent collects per minute. The agent discards additional queries after the limit is reached. Important Increasing this limit increases memory usage. Custom hostname variables This section defines the Node.js agent variables in the order they typically appear in the process_host: { section of your app's newrelic.js configuration file. These options control behavior regarding the host display name in the New Relic APM UI. display_name Type String of 255 bytes or less Default (none) Environ variable NEW_RELIC_PROCESS_HOST_DISPLAY_NAME Specify a custom hostname for display in New Relic. If you do not set this field, New Relic will continue to use the default hostname found by calling os.hostname(). If you use the default hostname settings, New Relic finds the hostname through os.hostname(). If this call fails, New Relic uses the host's IP as the name. If you set ipv_preference: 4 or ipv_preference: 6, you can select the type of IP address (IPv4 or IPv6) that appears in the New Relic UI. ipv_preference Type Integer (4 or 6) Default 4 Environ variable NEW_RELIC_IPV_PREFERENCE Environment variable overrides This section defines two configuration options only available with environment variables. These overrides are not used in most configurations. NEW_RELIC_HOME Path to the directory containing newrelic.js. This is available only as an environment variable. You cannot set it in your config file. Type String Default (none) NEW_RELIC_NO_CONFIG_FILE If used, this prevents the agent from reading configuration settings from newrelic.js. Default values and values from environment variables will still be set. This is available only as an environment variable. You cannot set it in your config file. Type Boolean Default False Datastore tracer variables This section defines the Node.js agent variables in the order they typically appear in the datastore_tracer section of your app's newrelic.js configuration file. These options control behavior for collecting datastore instance metrics. instance_reporting.enabled Type Boolean Default true When enabled, the agent collects datastore instance metrics (such as host and port) for some database drivers. These are reported on slow query traces and transaction traces. database_name_reporting.enabled Type Boolean Default true When enabled, the agent collects database name on slow query traces and transaction traces for some database drivers. Cross application tracing The Node.js agent variables that control cross application tracing typically appear in the cross_application_tracer section of your app's newrelic.js configuration file: enabled Type Boolean Default true When set to true, allows tracing of transactions across more than one New Relic-monitored applications. Error message redaction variables The Node.js agent variables that control error message redaction appear in the allow_raw_exception_messages section of your app's newrelic.js configuration file: enabled Type Boolean Default true Environ variable NEW_RELIC_ALLOW_RAW_EXCEPTION_MESSAGES_ENABLED When false, the agent will redact the messages of captured errors. Distributed tracing Important Enabling distributed tracing disables cross application tracing, and has effects on other APM features. Before enabling, read the transition guide. Requires Node.js agent version 4.7.0 or higher. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. When configuring via the config file, place the following option in the distributed_tracing section. When distributed tracing is enabled, you can collect span events. enabled Type Boolean Default false Environ variable NEW_RELIC_DISTRIBUTED_TRACING_ENABLED Set this to true to enable distributed tracing. For example, to enable this in the config file, you would use: distributed_tracing: { enabled: true } Copy exclude_newrelic_header Type Boolean Default false Set this to true to exclude the New Relic header that is attached to outbound requests, and instead only rely on W3C Trace Context Headers for distributed tracing. If this is false then both types of headers are used. For example, to enable this in the config file, you would use: distributed_tracing:{ enabled: true, exclude_newrelic_header: true } Copy Span events Span events are reported for distributed tracing. Distributed tracing must be enabled to report span events. Span configuration is set in the span_events stanza. Options include: enabled Type Boolean Default true Environ variable NEW_RELIC_SPAN_EVENTS_ENABLED Turns reporting of span events on or off. attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_SPAN_EVENTS_ATTRIBUTES_ENABLED This setting can be used to turn reporting of attributes on or off for span events. If attributes.enabled at the root level is false, no attributes will be sent to span events regardless on how this is set. attributes.include Type Array Default [] Environ variable NEW_RELIC_SPAN_EVENTS_ATTRIBUTES_INCLUDE If attributes are enabled for span events, all attribute keys found in this list will be attached to span events. For more information, see the agent attribute rules. attributes.exclude Type Array Default [] Environ variable NEW_RELIC_SPAN_EVENTS_ATTRIBUTES_EXCLUDE All attribute keys found in this list will not be sent with span events. For more information, see the agent attribute rules. Infinite Tracing To turn on Infinite Tracing, enable distributed tracing (set distributed_tracing to enabled: true) and add the additional settings below. For an example, see Language Agents: Configure Distributed Tracing. trace_observer.host Type String Default (none) Environ variable NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST For help getting a valid Infinite Tracing trace observer host entry, see Find or create a trace observer endpoint.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 148.5103,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Node.js <em>agent</em> <em>configuration</em>",
        "sections": "Node.js <em>agent</em> <em>configuration</em>",
        "tags": "<em>Installation</em> <em>and</em> <em>configuration</em>",
        "body": " The license_key setting is required. We highly recommend setting the app_name so that your app has a meaningful name instead of the default My Application. <em>Configuration</em> methods and precedence The primary method to configure the <em>Node.js</em> <em>agent</em> is the <em>agent</em> <em>configuration</em> file (newrelic.js). You can also"
      },
      "id": "603e87a728ccbc4653eba75b"
    },
    {
      "sections": [
        "Install the Node.js agent for Docker",
        "Tip",
        "Instrument your container",
        "Other configuration options",
        "Caution"
      ],
      "title": "Install the Node.js agent for Docker",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Installation and configuration"
      ],
      "external_id": "e8c8820b46d5d7ed0983a5001f83235f3bbd09b7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/installation-configuration/install-nodejs-agent-docker/",
      "published_at": "2021-06-02T20:28:30Z",
      "updated_at": "2021-03-13T04:22:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use our Node.js agent to instrument Node.js applications deployed in Docker containers. This document explains how to build, configure, and deploy your Dockerized Node.js application that has been instrumented with New Relic. Tip To use Node.js or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Instrument your container With just a few additions your existing Dockerfile can be used with our Node.js agent. You'll configure the agent by running your new Docker image with environment variables set. Add newrelic to your package.json: \"newrelic\": \"latest\", Copy Install a specific version, or use any of the other options provided by the package.json format. Check the Node.js agent release notes for information about past agent versions. In the first line of your app's main module, add require('newrelic');. Add this line to your Dockerfile so the agent can run without a configuration file: ENV NEW_RELIC_NO_CONFIG_FILE=true Copy Build your Docker image the way you normally do. To run your Docker app with the agent enabled, add your license key and app name to your docker run command as environment variables: docker run -e NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ -e NEW_RELIC_APP_NAME=\"Your Application Name\" \\ your_image_name:latest Copy Other configuration options Caution Do not include your license key in your Dockerfile or Docker image. For more information, see our documentation on license key security. In addition to setting your application name or license key, you can set other configuration options by starting your container with the -e option. For example, to enable distributed tracing, use: $ docker run -e NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ -e NEW_RELIC_APP_NAME=\"Your Application Name\" \\ -e NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true \\ your_image_name:latest Copy You can also set configuration options in your Dockerfile using ENV directives: ENV NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true \\ NEW_RELIC_LOG=stdout # etc. Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.85133,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the Node.js <em>agent</em> for Docker",
        "sections": "<em>Install</em> the Node.js <em>agent</em> for Docker",
        "tags": "<em>Installation</em> <em>and</em> <em>configuration</em>",
        "body": "You can use our <em>Node.js</em> <em>agent</em> to instrument <em>Node.js</em> applications deployed in Docker containers. This document explains how to build, configure, and deploy your Dockerized <em>Node.js</em> application that has been instrumented with New Relic. Tip To use <em>Node.js</em> or any other <em>agent</em>, as well as the rest of our"
      },
      "id": "6043d3b728ccbcd4b82c60ce"
    }
  ],
  "/docs/agents/nodejs-agent/installation-configuration/nodejs-agent-configuration": [
    {
      "sections": [
        "Install the Node.js agent",
        "Tip",
        "Important",
        "Keep your Node.js agent up-to-date",
        "Troubleshooting"
      ],
      "title": "Install the Node.js agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Installation and configuration"
      ],
      "external_id": "5877d4bc24ac6201ac15fd7dd909ce85213e6680",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/installation-configuration/install-nodejs-agent/",
      "published_at": "2021-06-02T20:28:30Z",
      "updated_at": "2021-03-16T15:03:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Node.js agent is publicly available on the Node Package Manager (npm) repository as well as on GitHub. You can use our launcher, or follow the instructions in this document to complete a basic Node.js agent installation. Tip To use Node.js or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Add Node.js data Install the Node.js agent Important If you're using the agent in a Docker container, install the agent in each container. To install the Node.js agent: Ensure you meet the system requirements. In particular, make sure you use a supported Node version. Use the command npm install newrelic --save for each application you want to monitor. From node_modules/newrelic, copy newrelic.js into the root directory of your app. Configure agent via the newrelic.js file or via environment variable: Customize the license_key setting with your license key. Customize the app_name setting with one or more meaningful app names. Add require('newrelic'); as the first line of your app's main module. Optional: For additional Node.js runtime-level statistics, ensure the @newrelic/native-metrics package is installed. Generate some traffic, then wait a few minutes for data to appear in the APM UI. You can further customize your agent behavior via newrelic.js or an environment variable. To keep the agent configuration separate from your app, edit the NEW_RELIC_HOME environmental variable. Keep your Node.js agent up-to-date To ensure that you have the most up-to-date version of New Relic, refer to the Node.js release notes. When applicable, the release notes include a download link with instructions on how to update the Node.js agent. Troubleshooting After you update the agent, generate some traffic and wait a few minutes. If no data appears in the New Relic UI, see the troubleshooting procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 152.04909,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the Node.js <em>agent</em>",
        "sections": "<em>Install</em> the Node.js <em>agent</em>",
        "tags": "<em>Installation</em> <em>and</em> <em>configuration</em>",
        "body": "Our <em>Node.js</em> <em>agent</em> is publicly available on the Node Package Manager (npm) repository as well as on GitHub. You can use our launcher, or follow the instructions in this document to complete a basic <em>Node.js</em> <em>agent</em> <em>installation</em>. Tip To use <em>Node.js</em> or any other <em>agent</em>, as well as the rest of our"
      },
      "id": "603e962e28ccbcf759eba75b"
    },
    {
      "sections": [
        "Uninstall the Node.js agent",
        "Tip",
        "For more help"
      ],
      "title": "Uninstall the Node.js agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Installation and configuration"
      ],
      "external_id": "17cdfffa0ea6ea5888c601dca3846e50772fc112",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/installation-configuration/uninstall-nodejs-agent/",
      "published_at": "2021-06-02T20:29:31Z",
      "updated_at": "2021-03-13T02:39:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Read on to learn how to uninstall the New Relic Node.js agent. For instructions on how to temporarily disable the agent, see Disable the agent. To uninstall the New Relic Node.js agent: Remove require('newrelic'); as the first line of the app's main module. Remove the npm package with npm uninstall newrelic --save. Delete the newrelic.js file and unset any environment variables being used. When the uninstall process finishes, restart your app. For more information about installation, see Installing and maintaining Node.js. Tip You may also want to remove your app from New Relic. For more help Additional documentation resources include: Troubleshooting the Node.js agent (a library of troubleshooting solutions for Node.js)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 148.51941,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Uninstall the Node.js <em>agent</em>",
        "sections": "Uninstall the Node.js <em>agent</em>",
        "tags": "<em>Installation</em> <em>and</em> <em>configuration</em>",
        "body": " newrelic --save. Delete the newrelic.js file and unset any environment variables being used. When the uninstall process finishes, restart your app. For more information about <em>installation</em>, see Installing and maintaining <em>Node.js</em>. Tip You may also want to remove your app from New Relic. For more help Additional documentation resources include: Troubleshooting the <em>Node.js</em> <em>agent</em> (a library of troubleshooting solutions for <em>Node.js</em>)"
      },
      "id": "6043d36a196a676f52960f77"
    },
    {
      "sections": [
        "Install the Node.js agent for Docker",
        "Tip",
        "Instrument your container",
        "Other configuration options",
        "Caution"
      ],
      "title": "Install the Node.js agent for Docker",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Installation and configuration"
      ],
      "external_id": "e8c8820b46d5d7ed0983a5001f83235f3bbd09b7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/installation-configuration/install-nodejs-agent-docker/",
      "published_at": "2021-06-02T20:28:30Z",
      "updated_at": "2021-03-13T04:22:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use our Node.js agent to instrument Node.js applications deployed in Docker containers. This document explains how to build, configure, and deploy your Dockerized Node.js application that has been instrumented with New Relic. Tip To use Node.js or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Instrument your container With just a few additions your existing Dockerfile can be used with our Node.js agent. You'll configure the agent by running your new Docker image with environment variables set. Add newrelic to your package.json: \"newrelic\": \"latest\", Copy Install a specific version, or use any of the other options provided by the package.json format. Check the Node.js agent release notes for information about past agent versions. In the first line of your app's main module, add require('newrelic');. Add this line to your Dockerfile so the agent can run without a configuration file: ENV NEW_RELIC_NO_CONFIG_FILE=true Copy Build your Docker image the way you normally do. To run your Docker app with the agent enabled, add your license key and app name to your docker run command as environment variables: docker run -e NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ -e NEW_RELIC_APP_NAME=\"Your Application Name\" \\ your_image_name:latest Copy Other configuration options Caution Do not include your license key in your Dockerfile or Docker image. For more information, see our documentation on license key security. In addition to setting your application name or license key, you can set other configuration options by starting your container with the -e option. For example, to enable distributed tracing, use: $ docker run -e NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ -e NEW_RELIC_APP_NAME=\"Your Application Name\" \\ -e NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true \\ your_image_name:latest Copy You can also set configuration options in your Dockerfile using ENV directives: ENV NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true \\ NEW_RELIC_LOG=stdout # etc. Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.85133,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the Node.js <em>agent</em> for Docker",
        "sections": "<em>Install</em> the Node.js <em>agent</em> for Docker",
        "tags": "<em>Installation</em> <em>and</em> <em>configuration</em>",
        "body": "You can use our <em>Node.js</em> <em>agent</em> to instrument <em>Node.js</em> applications deployed in Docker containers. This document explains how to build, configure, and deploy your Dockerized <em>Node.js</em> application that has been instrumented with New Relic. Tip To use <em>Node.js</em> or any other <em>agent</em>, as well as the rest of our"
      },
      "id": "6043d3b728ccbcd4b82c60ce"
    }
  ],
  "/docs/agents/nodejs-agent/installation-configuration/uninstall-nodejs-agent": [
    {
      "sections": [
        "Install the Node.js agent",
        "Tip",
        "Important",
        "Keep your Node.js agent up-to-date",
        "Troubleshooting"
      ],
      "title": "Install the Node.js agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Installation and configuration"
      ],
      "external_id": "5877d4bc24ac6201ac15fd7dd909ce85213e6680",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/installation-configuration/install-nodejs-agent/",
      "published_at": "2021-06-02T20:28:30Z",
      "updated_at": "2021-03-16T15:03:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Node.js agent is publicly available on the Node Package Manager (npm) repository as well as on GitHub. You can use our launcher, or follow the instructions in this document to complete a basic Node.js agent installation. Tip To use Node.js or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Add Node.js data Install the Node.js agent Important If you're using the agent in a Docker container, install the agent in each container. To install the Node.js agent: Ensure you meet the system requirements. In particular, make sure you use a supported Node version. Use the command npm install newrelic --save for each application you want to monitor. From node_modules/newrelic, copy newrelic.js into the root directory of your app. Configure agent via the newrelic.js file or via environment variable: Customize the license_key setting with your license key. Customize the app_name setting with one or more meaningful app names. Add require('newrelic'); as the first line of your app's main module. Optional: For additional Node.js runtime-level statistics, ensure the @newrelic/native-metrics package is installed. Generate some traffic, then wait a few minutes for data to appear in the APM UI. You can further customize your agent behavior via newrelic.js or an environment variable. To keep the agent configuration separate from your app, edit the NEW_RELIC_HOME environmental variable. Keep your Node.js agent up-to-date To ensure that you have the most up-to-date version of New Relic, refer to the Node.js release notes. When applicable, the release notes include a download link with instructions on how to update the Node.js agent. Troubleshooting After you update the agent, generate some traffic and wait a few minutes. If no data appears in the New Relic UI, see the troubleshooting procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 152.04909,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the Node.js <em>agent</em>",
        "sections": "<em>Install</em> the Node.js <em>agent</em>",
        "tags": "<em>Installation</em> <em>and</em> <em>configuration</em>",
        "body": "Our <em>Node.js</em> <em>agent</em> is publicly available on the Node Package Manager (npm) repository as well as on GitHub. You can use our launcher, or follow the instructions in this document to complete a basic <em>Node.js</em> <em>agent</em> <em>installation</em>. Tip To use <em>Node.js</em> or any other <em>agent</em>, as well as the rest of our"
      },
      "id": "603e962e28ccbcf759eba75b"
    },
    {
      "sections": [
        "Node.js agent configuration",
        "Important",
        "Configuration methods and precedence",
        "Agent configuration file",
        "Environment variables",
        "Server-side configuration",
        "Exports variables",
        "app_name (REQUIRED)",
        "Tip",
        "license_key (REQUIRED)",
        "agent_enabled",
        "allow_all_headers",
        "Caution",
        "apdex_t (DEPRECATED)",
        "certificates",
        "high_security",
        "host",
        "labels",
        "port",
        "proxy",
        "proxy_host",
        "proxy_pass",
        "proxy_port",
        "proxy_user",
        "Logging variables",
        "enabled",
        "level",
        "filepath",
        "Audit logging",
        "endpoints",
        "API configuration",
        "custom_attributes_enabled",
        "custom_events_enabled",
        "notice_error_enabled",
        "Attributes",
        "exclude",
        "include",
        "include_enabled",
        "Error collector variables",
        "ignore_status_codes",
        "ignore_classes",
        "ignore_messages",
        "expected_status_codes",
        "expected_classes",
        "expected_messages",
        "attributes.enabled",
        "attributes.exclude",
        "attributes.include",
        "Transaction tracer variables",
        "explain_threshold",
        "record_sql",
        "top_n",
        "transaction_threshold",
        "hide_internals",
        "Rules variables",
        "name",
        "ignore",
        "enforce_backstop",
        "Transaction events variables",
        "max_samples_stored",
        "max_samples_stored (DEPRECATED)",
        "max_samples_per_minute (DEPRECATED)",
        "Browser monitoring variables",
        "enable",
        "debug",
        "Custom events variables",
        "Slow queries variables",
        "max_samples",
        "Custom hostname variables",
        "display_name",
        "ipv_preference",
        "Environment variable overrides",
        "NEW_RELIC_HOME",
        "NEW_RELIC_NO_CONFIG_FILE",
        "Datastore tracer variables",
        "instance_reporting.enabled",
        "database_name_reporting.enabled",
        "Cross application tracing",
        "Error message redaction variables",
        "Distributed tracing",
        "exclude_newrelic_header",
        "Span events",
        "Infinite Tracing",
        "trace_observer.host"
      ],
      "title": "Node.js agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Installation and configuration"
      ],
      "external_id": "6776895960bd4803e98f4c7260c0563c89c09f70",
      "image": "https://docs.newrelic.com/static/bab8ec5bda2eda3aaa5ddaefbed52d93/9fc4b/nodejs-configuration-precedence.png",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/installation-configuration/nodejs-agent-configuration/",
      "published_at": "2021-05-28T15:25:01Z",
      "updated_at": "2021-03-16T15:53:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can tailor the Node.js agent to your app's requirements by editing your newrelic.js config file or by setting an environment variable. The config file resides in the root directory of your app. You can also configure a few options from New Relic, or use the Node.js agent API. Important The license_key setting is required. We highly recommend setting the app_name so that your app has a meaningful name instead of the default My Application. Configuration methods and precedence The primary method to configure the Node.js agent is the agent configuration file (newrelic.js). You can also configure most settings with environment variables. You can also adjust some settings with server-side configuration. The Node.js agent uses this order of precedence for configuration methods: Node.js configuration hierarchy: Server-side configuration settings override environment variables. Environment variables override the agent config file. The config file overrides the agent defaults. Here are detailed descriptions of each configuration method: Agent configuration file The config file (newrelic.js) contains every Node.js agent setting. When you install the Node.js agent, you must copy newrelic.js into your app's root directory. Most settings are empty by default; they inherit their values from config/default.js. Environment variables Most configuration settings in newrelic.js have equivalent environment variables. These are useful, for example, if your agent runs in a PaaS environment such as Heroku or Microsoft Azure. Node.js agent environment variables always start with NEW_RELIC_. Where available, these environment variables are documented below under individual config options as the Environ variable. There are also two rarely used settings that can only be configured via environment variables. Server-side configuration Owners and Admins can view and configure a few settings directly in New Relic. Where available, the UI labels for server-side config are listed in this document under individual config options as the Server-side label. Exports variables This section defines the Node.js agent variables in the order they typically appear in the exports.config = { section of your app's newrelic.js configuration file. app_name (REQUIRED) Type String Default \"My Application\" Environ variable NEW_RELIC_APP_NAME The name New Relic uses to identify your app. For example, app_name: ['MyNodeApp']. To use multiple names for your app, specify a comma-delimited list of names. Data for all applications with the same name will be merged in the New Relic UI, so set this carefully. We highly recommend that you replace the default name with a descriptive name to avoid confusion and unintended aggregation of data. Tip For Azure users, the Node.js agent will use APP_POOL_ID if it is set, so you can use the name you chose for your Azure Web Server without setting it twice. license_key (REQUIRED) Type String Default (none) Environ variable NEW_RELIC_LICENSE_KEY This setting is required. Your New Relic license key. For example, license_key: '40HexadecimalCharacters'. agent_enabled Type Boolean Default true Environ variable NEW_RELIC_ENABLED Set to false to stop the agent from starting up. This is useful when debugging your code requires temporarily disabling the agent. It prevents the agent from bootstrapping its instrumentation or setting up all its pieces, which prevents the agent from starting up and connecting to New Relic's servers. allow_all_headers If true, enables capture of all HTTP headers, except for those filtered by exclude rules. If false, collected headers are limited to those defined in Node.js agent attributes. Type Boolean Default false Caution Any header-related include/exclude rules must be in camelCase form to be filtered. apdex_t (DEPRECATED) Type Number Default 0.100 Server-side label Apdex T Set your Apdex T via the New Relic UI. certificates Type Array of strings Default (none) Additional certificates to trust for SSL connections, specified as an array of strings in PEM format. This affects both connections to an HTTPS proxy and connections to New Relic. Tip You can also configure the agent to read its certificates from a file: certificates: [ fs.readFileSync('myca.crt', {encoding: 'utf8'}) ] Copy high_security Type Boolean Default false Environ variable NEW_RELIC_HIGH_SECURITY When set to true, enables high security v2. You must also enable the ssl setting and enable high security in the UI. host Type String Default collector.newrelic.com Environ variable NEW_RELIC_HOST Important Do not edit this value unless New Relic Support asks you to change it. Hostname for the New Relic collector to connect to the Internet; for example, host: 'collector.newrelic.com'. labels Adds tags. Specify your tags as objects or a semicolon-delimited string of colon-separated pairs (for example, Server:One;Data Center:Primary). Type Object or string Default (none) Environ variable NEW_RELIC_LABELS port Type Integer Default 443 Environ variable NEW_RELIC_PORT Important Do not edit this value unless New Relic Support asks you to change it. Port number to connect to the New Relic collector; for example, port: 443. proxy Type String Default (none) Environ variable NEW_RELIC_PROXY_URL A URL specifying the proxy server to connect to the Internet. For example, proxy: 'http://user:pass@10.0.0.1:8000/'. Important The proxy config file setting overrides the other config file proxy settings (proxy_host, proxy_port, proxy_user, proxy_pass) if used. Similarly, the NEW_RELIC_PROXY_URL environment variable overrides the other environment variable proxy settings (NEW_RELIC_PROXY_HOST, NEW_RELIC_PROXY_PORT, NEW_RELIC_PROXY_USER, and NEW_RELIC_PROXY_PASS) if used. proxy_host Type String Default (none) Environ variable NEW_RELIC_PROXY_HOST Hostname or IP address of the proxy server to connect to the Internet. proxy_pass Type String Default (none) Environ variable NEW_RELIC_PROXY_PASS Password for authenticating to the proxy server. The agent supports only basic HTTP authentication. proxy_port Type String Default (none) Environ variable NEW_RELIC_PROXY_PORT Port number of the proxy server to connect to the Internet. proxy_user Type String Default (none) Environ variable NEW_RELIC_PROXY_USER User name for authenticating to the proxy server. The agent supports only basic HTTP authentication. Logging variables This section defines the Node.js agent variables in the order they typically appear in the logging: { section of your app's newrelic.js configuration file. enabled Type String Default true (false in serverless_mode) Environ variable NEW_RELIC_LOG_ENABLED Enables or disables agent specific logging. level Type String Default info Environ variable NEW_RELIC_LOG_LEVEL Defines the level of detail recorded in the agent logs. From least detail to most detail, possible values are fatal, error, warn, info, debug, or trace. Caution Do not use debug or trace logging unless New Relic Support asks you to use them. These levels of logging can generate excessive overhead. For most situations, use info. filepath Type String Default process.cwd() plus newrelic_agent.log Environ variable NEW_RELIC_LOG Complete path to the New Relic agent log, including the filename. Defaults to filepath: require('path').join(process.cwd(), 'newrelic_agent.log'). The agent will shut down the process if it cannot create this file. The agent creates a log file with the same permissions as the parent Node.js agent process. To write all logging to stdout, set this to stdout. To write all logging to stderr, set this to stderr. Audit logging This section defines the Node.js agent variables in the order they typically appear in the audit_log: { section of your app's newrelic.js configuration file. enabled Type Boolean Default false Environ variable NEW_RELIC_AUDIT_LOG_ENABLED When enabled, the agent logs the payloads it sends to the collector. This data is included in the main log file even when logging level is set to the lowest level. endpoints Type Array Default Empty array (include all types) Environ variable NEW_RELIC_AUDIT_LOG_ENDPOINTS The agent sends several different types of data to the collector in separate payloads. By default, all of them are included in the log file. This option makes it possible to limit logging only to specific types of data. Valid values include: agent_settings analytic_event_data connect custom_event_data error_data error_event_data metric_data preconnect shutdown span_event_data sql_trace_data transaction_sample_data API configuration This section allows you to choose which API methods are enabled. Each configuration option allows you to modularly enable API methods that are responsible for sending custom information to New Relic. Important All of these are set to false when the agent is in high security mode. custom_attributes_enabled Type Boolean Default true Environ variable NEW_RELIC_API_CUSTOM_ATTRIBUTES This option enables newrelic.addCustomAttribute and newrelic.addCustomAttributes. custom_events_enabled Type Boolean Default true Environ variable NEW_RELIC_API_CUSTOM_EVENTS This option enables recordCustomEvent. notice_error_enabled Type Boolean Default true Environ variable NEW_RELIC_API_NOTICE_ERROR This option enables newrelic.noticeError. Attributes This section defines the variables for Node.js agent attributes in the order they typically appear in the attributes: { section of your app's newrelic.js configuration file. Caution Any header-related include/exclude rules must be in camelCase form to be filtered. enabled Type Boolean Default true Environ variable NEW_RELIC_ATTRIBUTES_ENABLED If true, enables capture of attributes for all destinations. exclude Type Array Default [] Environ variable NEW_RELIC_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from all destinations. Allows * as wildcard at end. include Type Array Default [] Environ variable NEW_RELIC_ATTRIBUTES_INCLUDE Prefix of attributes to include from all destinations. Allows * as wildcard at end. include_enabled Type Boolean Default true Environ variable NEW_RELIC_ATTRIBUTES_INCLUDE_ENABLED When true, patterns may be added to the attributes.include list. Error collector variables You can manage how error are handled in New Relic. This section defines the Node.js agent variables in the order they typically appear in the error_collector: { section of your app's newrelic.js configuration file. enabled Type Boolean Default true Environ variable NEW_RELIC_ERROR_COLLECTOR_ENABLED Server-side label Enable error collection? When enabled, the agent collects error traces from your app. ignore_status_codes Type Array Default 404 Environ variable NEW_RELIC_ERROR_COLLECTOR_IGNORE_ERROR_CODES Server-side label Ignore these status codes Comma-delimited list of HTTP status codes for the error collector to ignore. Caution Errors recorded using newrelic.noticeError do not obey this configuration value. ignore_classes Type Array|Object Default [] Environ variable NEW_RELIC_ERROR_COLLECTOR_IGNORE_ERRORS Comma-delimited list of javascript error types/classes for the error collector to ignore. The following configuration /* ... */ error_collector: { ignore_classes: [\"ReferenceError\"] } /* ... */ Copy Would ignore all reference errors. Caution Errors recorded using newrelic.noticeError do not obey this configuration value. ignore_messages Type Object Default {} A javascript object describing a list of javascript classes tied to javascript error messages for the collector to ignore. The following configuration. /* ... */ error_collector: { /* ... */ ignore_messages: {\"Error\":[\"Undefined\", \"Out of time\"]} /* ... */ } /* ... */ Copy Would ignore all errors of type Error, with the exact (case-sensitive) message strings of Undefined and Out of time. Caution Errors recorded using newrelic.noticeError do not obey this configuration value. expected_status_codes Type Array Default [] Environ variable NEW_RELIC_ERROR_COLLECTOR_EXPECTED_ERROR_CODES Comma-delimited list of HTTP status codes for the error collector to mark as expected. Caution Errors recorded using newrelic.noticeError do not obey this configuration value. expected_classes Type Array Default [] Environ variable NEW_RELIC_ERROR_COLLECTOR_EXPECTED_ERRORS The following configuration /* ... */ error_collector: { expected_classes: [\"ReferenceError\"] } /* ... */ Copy Would mark all reference errors as expected. Caution Errors recorded using newrelic.noticeError do not obey this configuration value. expected_messages Type Object Default {} A javascript object describing a list of javascript classes tied to javascript error messages for the collector to ignore. The following configuration. /* ... */ error_collector: { /* ... */ expected_messages: {\"Error\":[\"Undefined\", \"Out of time\"]} /* ... */ } /* ... */ Copy Would mark all errors of type Error, with the exact (case-sensitive) message strings of Undefined and Out of time. Caution Errors recorded using newrelic.noticeError do not obey this configuration value. attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_ERROR_COLLECTOR_ATTRIBUTES_ENABLED If true, the agent captures attributes from error collection. Caution Any header-related include/exclude rules must be in camelCase form to be filtered. attributes.exclude Type Array Default [] Environ variable NEW_RELIC_ERROR_COLLECTOR_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from error collection. Allows * as wildcard at end. attributes.include Type Array Default [] Environ variable NEW_RELIC_ERROR_COLLECTOR_ATTRIBUTES_INCLUDE Prefix of attributes to include in error collection. Allows * as wildcard at end. Transaction tracer variables The agent groups your requests into transactions, which are used to: Visualize where your app spends its time (in transaction breakdowns). Identify slow requests. Group metrics. Isolate other issues, such as slow database performance. This section defines the Node.js agent variables in the order they typically appear in the transaction_tracer: { section of your app's newrelic.js configuration file. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. enabled Type Boolean Default true Environ variable NEW_RELIC_TRACER_ENABLED Server-side label Enable transaction tracing? When enabled, the agent collects slow transaction traces. explain_threshold Type Integer Default 500 Environ variable NEW_RELIC_EXPLAIN_THRESHOLD Minimum query duration (in milliseconds) for a transaction to be eligible for slow queries in transaction traces. record_sql Type String (off, obfuscated, or raw) Default off Environ variable NEW_RELIC_RECORD_SQL This option affects both slow queries and record_sql for transaction traces. It can have one of three values: off, obfuscated, or raw. When set to off no slow queries will be captured, and backtraces and SQL will not be included in transaction traces. If set to raw or obfuscated, the agent sends raw or obfuscated SQL and a slow query sample to the collector. The agent may also send SQL when other criteria are met, such as when slow_sql.enabled is set. top_n Type Integer Default 20 Environ variable NEW_RELIC_TRACER_TOP_N Defines the maximum number of requests eligible for transaction traces. Transactions are named based on the request, and top_n refers to the \"top n slowest transactions\" grouped by these names. The module replaces a recorded trace with a new trace only if the new trace is slower than the previous slowest trace of that name. The default value for this setting is top_n: 20, because the Transactions page also defaults to the 20 slowest transactions. The Node.js agent captures at least five different slow transactions in the first harvest cycle after start up. It will also reset and capture different transactions if no slow transactions have been captured for the last five harvest cycles. This allows you to see more information about more of your app's request paths, at the possible cost of not focusing on the absolutely slowest request for that harvest cycle. Tip To record the absolute slowest transaction over the last minute, you can set top_n: 0 or top_n: 1. However, this causes one very slow route to dominate your transaction traces. transaction_threshold Type Integer or apdex_f Default apdex_f Environ variable NEW_RELIC_TRACER_THRESHOLD Server-side label Threshold Threshold of web transaction response time in seconds beyond which a transaction is eligible for transaction tracing. The default value is apdex_f; this sets the trace threshold to four times your application's Apdex T. You can also enter a specific time value in milliseconds. Example: Threshold set to apdex_f The default apdex_t is 100 milliseconds. If your transaction threshold is set to apdex_f, a \"slow\" transaction is 400 milliseconds. hide_internals Type boolean Default true Environ variable NEW_RELIC_HIDE_INTERNALS The agent uses a small amount of CPU in order to hide internal properties that are attached to the web application. If you change this configuration to false, it may slightly decrease your agent overhead, but it could also have an impact on the performance of the agent. attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_TRANSACTION_TRACER_ATTRIBUTES_ENABLED If true, the agent captures attributes from transaction traces. Caution Any header-related include/exclude rules must be in camelCase form to be filtered. attributes.exclude Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_TRACER_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from transaction traces. Allows * as wildcard at end. attributes.include Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_TRACER_ATTRIBUTES_INCLUDE Prefix of attributes to include in transaction traces. Allows * as wildcard at end. Rules variables This section defines the Node.js agent variables in the order they typically appear in the rules: { section of your app's newrelic.js configuration file. name Type Strings or regular expressions Default (none) Environ variable NEW_RELIC_NAMING_RULES A comma-delimited list of rules to match incoming request URLs and name the associated New Relic transaction. Uses the format: name: [ {pattern: 'STRING_OR_REGEX', name: 'NAME'}, {pattern: 'STRING_OR_REGEX', name: 'NAME'} ], Copy Both parameters are required. For strings, you must escape control characters. You do not need to escape control characters in regular expressions. Additional attributes are ignored. Regular expressions support JavaScript-style capture groups, and names use $1-style replacement strings. Regular expressions only find the first matching result; subsequent matches are ignored. For more information, see Node.js transaction naming API. For the NEW_RELIC_NAMING_RULES environment variable, pass the rules as comma-delimited JSON object literals: NEW_RELIC_NAMING_RULES='{\"pattern\":\"^t\",\"name\":\"u\"},{\"pattern\":\"^u\",\"name\":\"t\"}' Copy ignore Type Strings or regular expressions Default Regular expression to match socket.io long-polling requests (\"^ \\ /socket \\ .io \\ /. * \\ /xhr-polling/\"). Environ variable NEW_RELIC_IGNORING_RULES Define a list of request URLs you want the agent to ignore. Specify the list as patterns, which can be strings or regular expressions. enforce_backstop Type Boolean Default true Environ variable NEW_RELIC_ENFORCE_BACKSTOP Caution Do not change this setting unless you understand metric grouping issues. When enabled, the agent renames transactions that are not affected by other naming logic (such as the API, rules, or metric normalization rules) to NormalizedUri/*. If you set this to false, the agent sets transaction names to Uri/path/to/resource. Transaction events variables This section defines the Node.js agent variables in the order they typically appear in the transaction_events: { section of your app's newrelic.js configuration file. enabled Type Boolean Default true When enabled, the agent sends transaction events to New Relic. This event data includes transaction timing, transaction name, and any custom parameters. If this is disabled, the agent does not collect this data or send it to New Relic. max_samples_stored Type Integer Default 10000 Defines the maximum number of events the agent collects per minute. If there are more than this number, the agent collects a statistical sampling. We do not recommend configuring past 10k. The server will cap data at 10k per-minute. Important This configuration had different behavior in agent versions lower than 6.0.0. See max_samples_stored (DEPRECATED) for agent versions 5.x or lower. max_samples_stored (DEPRECATED) Type Integer Default 20000 Defines the maximum number of events the agent stores if it is unable to communicate with the New Relic collector. The values from the previous harvest cycle will be merged into the next one, with this option limiting the maximum number. Make sure this number is greater than max_samples_per_minute; for example, set it to twice as much. Consider your memory overhead before increasing this value. Caution This configuration has different behavior starting with agent version 6.0.0 and a new recommended maximum. See max_samples_stored for agent versions 6.x or higher. max_samples_per_minute (DEPRECATED) Type Integer Default 10000 Defines the maximum number of events the agent collects per minute. If there are more than this number, the agent collects a statistical sampling. Caution This configuration has been replaced with max_samples_stored starting with version 6.0.0 of the agent. See max_samples_stored for 6.x or later agents. attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_TRANSACTION_EVENTS_ATTRIBUTES_ENABLED If true, the agent captures attributes from transaction events. Caution Any header-related include/exclude rules must be in camelCase form to be filtered. attributes.exclude Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_EVENTS_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from transaction events. Allows * as wildcard at end. attributes.include Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_EVENTS_ATTRIBUTES_INCLUDE Prefix of attributes to include in transaction events. Allows * as wildcard at end. Browser monitoring variables This section defines the Node.js agent variables in the order they typically appear in the browser_monitoring: { section of your app's newrelic.js configuration file. enable Type Boolean Default true Environ variable NEW_RELIC_BROWSER_MONITOR_ENABLE Server-side label Enable browser monitoring? Generate JavaScript headers for browser instrumentation. Although this defaults to true, the agent doesn't inject the browser JS code unless you have enabled browser monitoring. Even if you have enabled it and added the browser timing header, you can disable browser monitoring for your app by setting this to false. debug Type Boolean Default false Environ variable NEW_RELIC_BROWSER_MONITOR_DEBUG If true, request un-minified sources from the server. attributes.enabled Type Boolean Default false Environ variable NEW_RELIC_BROWSER_MONITORING_ATTRIBUTES_ENABLED If true, the agent sends custom attributes to browser monitoring. Caution Any header-related include/exclude rules must be in camelCase form to be filtered. attributes.exclude Type Array Default [] Environ variable NEW_RELIC_BROWSER_MONITORING_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from browser monitoring. Allows * as wildcard at end. attributes.include Type Array Default [] Environ variable NEW_RELIC_BROWSER_MONITORING_ATTRIBUTES_INCLUDE Prefix of attributes to include in browser monitoring. Allows * as wildcard at end. Custom events variables This section defines the Node.js agent variables in the order they typically appear in the custom_insights_events: { section of your app's newrelic.js configuration file. Currently there are no environment variables for custom events. enabled Type Boolean Default true When enabled, the agent sends custom events recorded with recordCustomEvent() to New Relic. If this is disabled, the agent does not collect this data or send it to New Relic. max_samples_stored Type Integer Default 1000 Defines the maximum number of custom events the agent collects per minute. If the number of custom events exceeds this limit, the agent collects a statistical sampling. Important Increasing this limit increases memory usage. Slow queries variables This section defines the Node.js agent variables in the order they typically appear in the slow_sql: { section of your app's newrelic.js configuration file. These options control behavior for slow queries, but do not affect SQL nodes in transaction traces. enabled Type Boolean Default false Environ variable NEW_RELIC_SLOW_SQL_ENABLED When enabled, the agent collects slow query details. max_samples Type Integer Default 10 Environ variable NEW_RELIC_MAX_SQL_SAMPLES Defines the maximum number of slow queries the agent collects per minute. The agent discards additional queries after the limit is reached. Important Increasing this limit increases memory usage. Custom hostname variables This section defines the Node.js agent variables in the order they typically appear in the process_host: { section of your app's newrelic.js configuration file. These options control behavior regarding the host display name in the New Relic APM UI. display_name Type String of 255 bytes or less Default (none) Environ variable NEW_RELIC_PROCESS_HOST_DISPLAY_NAME Specify a custom hostname for display in New Relic. If you do not set this field, New Relic will continue to use the default hostname found by calling os.hostname(). If you use the default hostname settings, New Relic finds the hostname through os.hostname(). If this call fails, New Relic uses the host's IP as the name. If you set ipv_preference: 4 or ipv_preference: 6, you can select the type of IP address (IPv4 or IPv6) that appears in the New Relic UI. ipv_preference Type Integer (4 or 6) Default 4 Environ variable NEW_RELIC_IPV_PREFERENCE Environment variable overrides This section defines two configuration options only available with environment variables. These overrides are not used in most configurations. NEW_RELIC_HOME Path to the directory containing newrelic.js. This is available only as an environment variable. You cannot set it in your config file. Type String Default (none) NEW_RELIC_NO_CONFIG_FILE If used, this prevents the agent from reading configuration settings from newrelic.js. Default values and values from environment variables will still be set. This is available only as an environment variable. You cannot set it in your config file. Type Boolean Default False Datastore tracer variables This section defines the Node.js agent variables in the order they typically appear in the datastore_tracer section of your app's newrelic.js configuration file. These options control behavior for collecting datastore instance metrics. instance_reporting.enabled Type Boolean Default true When enabled, the agent collects datastore instance metrics (such as host and port) for some database drivers. These are reported on slow query traces and transaction traces. database_name_reporting.enabled Type Boolean Default true When enabled, the agent collects database name on slow query traces and transaction traces for some database drivers. Cross application tracing The Node.js agent variables that control cross application tracing typically appear in the cross_application_tracer section of your app's newrelic.js configuration file: enabled Type Boolean Default true When set to true, allows tracing of transactions across more than one New Relic-monitored applications. Error message redaction variables The Node.js agent variables that control error message redaction appear in the allow_raw_exception_messages section of your app's newrelic.js configuration file: enabled Type Boolean Default true Environ variable NEW_RELIC_ALLOW_RAW_EXCEPTION_MESSAGES_ENABLED When false, the agent will redact the messages of captured errors. Distributed tracing Important Enabling distributed tracing disables cross application tracing, and has effects on other APM features. Before enabling, read the transition guide. Requires Node.js agent version 4.7.0 or higher. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. When configuring via the config file, place the following option in the distributed_tracing section. When distributed tracing is enabled, you can collect span events. enabled Type Boolean Default false Environ variable NEW_RELIC_DISTRIBUTED_TRACING_ENABLED Set this to true to enable distributed tracing. For example, to enable this in the config file, you would use: distributed_tracing: { enabled: true } Copy exclude_newrelic_header Type Boolean Default false Set this to true to exclude the New Relic header that is attached to outbound requests, and instead only rely on W3C Trace Context Headers for distributed tracing. If this is false then both types of headers are used. For example, to enable this in the config file, you would use: distributed_tracing:{ enabled: true, exclude_newrelic_header: true } Copy Span events Span events are reported for distributed tracing. Distributed tracing must be enabled to report span events. Span configuration is set in the span_events stanza. Options include: enabled Type Boolean Default true Environ variable NEW_RELIC_SPAN_EVENTS_ENABLED Turns reporting of span events on or off. attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_SPAN_EVENTS_ATTRIBUTES_ENABLED This setting can be used to turn reporting of attributes on or off for span events. If attributes.enabled at the root level is false, no attributes will be sent to span events regardless on how this is set. attributes.include Type Array Default [] Environ variable NEW_RELIC_SPAN_EVENTS_ATTRIBUTES_INCLUDE If attributes are enabled for span events, all attribute keys found in this list will be attached to span events. For more information, see the agent attribute rules. attributes.exclude Type Array Default [] Environ variable NEW_RELIC_SPAN_EVENTS_ATTRIBUTES_EXCLUDE All attribute keys found in this list will not be sent with span events. For more information, see the agent attribute rules. Infinite Tracing To turn on Infinite Tracing, enable distributed tracing (set distributed_tracing to enabled: true) and add the additional settings below. For an example, see Language Agents: Configure Distributed Tracing. trace_observer.host Type String Default (none) Environ variable NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST For help getting a valid Infinite Tracing trace observer host entry, see Find or create a trace observer endpoint.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 148.5103,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Node.js <em>agent</em> <em>configuration</em>",
        "sections": "Node.js <em>agent</em> <em>configuration</em>",
        "tags": "<em>Installation</em> <em>and</em> <em>configuration</em>",
        "body": " The license_key setting is required. We highly recommend setting the app_name so that your app has a meaningful name instead of the default My Application. <em>Configuration</em> methods and precedence The primary method to configure the <em>Node.js</em> <em>agent</em> is the <em>agent</em> <em>configuration</em> file (newrelic.js). You can also"
      },
      "id": "603e87a728ccbc4653eba75b"
    },
    {
      "sections": [
        "Install the Node.js agent for Docker",
        "Tip",
        "Instrument your container",
        "Other configuration options",
        "Caution"
      ],
      "title": "Install the Node.js agent for Docker",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Installation and configuration"
      ],
      "external_id": "e8c8820b46d5d7ed0983a5001f83235f3bbd09b7",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/installation-configuration/install-nodejs-agent-docker/",
      "published_at": "2021-06-02T20:28:30Z",
      "updated_at": "2021-03-13T04:22:09Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can use our Node.js agent to instrument Node.js applications deployed in Docker containers. This document explains how to build, configure, and deploy your Dockerized Node.js application that has been instrumented with New Relic. Tip To use Node.js or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Instrument your container With just a few additions your existing Dockerfile can be used with our Node.js agent. You'll configure the agent by running your new Docker image with environment variables set. Add newrelic to your package.json: \"newrelic\": \"latest\", Copy Install a specific version, or use any of the other options provided by the package.json format. Check the Node.js agent release notes for information about past agent versions. In the first line of your app's main module, add require('newrelic');. Add this line to your Dockerfile so the agent can run without a configuration file: ENV NEW_RELIC_NO_CONFIG_FILE=true Copy Build your Docker image the way you normally do. To run your Docker app with the agent enabled, add your license key and app name to your docker run command as environment variables: docker run -e NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ -e NEW_RELIC_APP_NAME=\"Your Application Name\" \\ your_image_name:latest Copy Other configuration options Caution Do not include your license key in your Dockerfile or Docker image. For more information, see our documentation on license key security. In addition to setting your application name or license key, you can set other configuration options by starting your container with the -e option. For example, to enable distributed tracing, use: $ docker run -e NEW_RELIC_LICENSE_KEY=YOUR_LICENSE_KEY \\ -e NEW_RELIC_APP_NAME=\"Your Application Name\" \\ -e NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true \\ your_image_name:latest Copy You can also set configuration options in your Dockerfile using ENV directives: ENV NEW_RELIC_DISTRIBUTED_TRACING_ENABLED=true \\ NEW_RELIC_LOG=stdout # etc. Copy",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 147.85133,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the Node.js <em>agent</em> for Docker",
        "sections": "<em>Install</em> the Node.js <em>agent</em> for Docker",
        "tags": "<em>Installation</em> <em>and</em> <em>configuration</em>",
        "body": "You can use our <em>Node.js</em> <em>agent</em> to instrument <em>Node.js</em> applications deployed in Docker containers. This document explains how to build, configure, and deploy your Dockerized <em>Node.js</em> application that has been instrumented with New Relic. Tip To use <em>Node.js</em> or any other <em>agent</em>, as well as the rest of our"
      },
      "id": "6043d3b728ccbcd4b82c60ce"
    }
  ],
  "/docs/agents/nodejs-agent/installation-configuration/update-nodejs-agent": [
    {
      "sections": [
        "Install the Node.js agent",
        "Tip",
        "Important",
        "Keep your Node.js agent up-to-date",
        "Troubleshooting"
      ],
      "title": "Install the Node.js agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Installation and configuration"
      ],
      "external_id": "5877d4bc24ac6201ac15fd7dd909ce85213e6680",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/installation-configuration/install-nodejs-agent/",
      "published_at": "2021-06-02T20:28:30Z",
      "updated_at": "2021-03-16T15:03:26Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Our Node.js agent is publicly available on the Node Package Manager (npm) repository as well as on GitHub. You can use our launcher, or follow the instructions in this document to complete a basic Node.js agent installation. Tip To use Node.js or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Add Node.js data Install the Node.js agent Important If you're using the agent in a Docker container, install the agent in each container. To install the Node.js agent: Ensure you meet the system requirements. In particular, make sure you use a supported Node version. Use the command npm install newrelic --save for each application you want to monitor. From node_modules/newrelic, copy newrelic.js into the root directory of your app. Configure agent via the newrelic.js file or via environment variable: Customize the license_key setting with your license key. Customize the app_name setting with one or more meaningful app names. Add require('newrelic'); as the first line of your app's main module. Optional: For additional Node.js runtime-level statistics, ensure the @newrelic/native-metrics package is installed. Generate some traffic, then wait a few minutes for data to appear in the APM UI. You can further customize your agent behavior via newrelic.js or an environment variable. To keep the agent configuration separate from your app, edit the NEW_RELIC_HOME environmental variable. Keep your Node.js agent up-to-date To ensure that you have the most up-to-date version of New Relic, refer to the Node.js release notes. When applicable, the release notes include a download link with instructions on how to update the Node.js agent. Troubleshooting After you update the agent, generate some traffic and wait a few minutes. If no data appears in the New Relic UI, see the troubleshooting procedures.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 152.04907,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Install</em> the Node.js <em>agent</em>",
        "sections": "<em>Install</em> the Node.js <em>agent</em>",
        "tags": "<em>Installation</em> <em>and</em> <em>configuration</em>",
        "body": "Our <em>Node.js</em> <em>agent</em> is publicly available on the Node Package Manager (npm) repository as well as on GitHub. You can use our launcher, or follow the instructions in this document to complete a basic <em>Node.js</em> <em>agent</em> <em>installation</em>. Tip To use <em>Node.js</em> or any other <em>agent</em>, as well as the rest of our"
      },
      "id": "603e962e28ccbcf759eba75b"
    },
    {
      "sections": [
        "Uninstall the Node.js agent",
        "Tip",
        "For more help"
      ],
      "title": "Uninstall the Node.js agent",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Installation and configuration"
      ],
      "external_id": "17cdfffa0ea6ea5888c601dca3846e50772fc112",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/installation-configuration/uninstall-nodejs-agent/",
      "published_at": "2021-06-02T20:29:31Z",
      "updated_at": "2021-03-13T02:39:48Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Read on to learn how to uninstall the New Relic Node.js agent. For instructions on how to temporarily disable the agent, see Disable the agent. To uninstall the New Relic Node.js agent: Remove require('newrelic'); as the first line of the app's main module. Remove the npm package with npm uninstall newrelic --save. Delete the newrelic.js file and unset any environment variables being used. When the uninstall process finishes, restart your app. For more information about installation, see Installing and maintaining Node.js. Tip You may also want to remove your app from New Relic. For more help Additional documentation resources include: Troubleshooting the Node.js agent (a library of troubleshooting solutions for Node.js)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 148.51941,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Uninstall the Node.js <em>agent</em>",
        "sections": "Uninstall the Node.js <em>agent</em>",
        "tags": "<em>Installation</em> <em>and</em> <em>configuration</em>",
        "body": " newrelic --save. Delete the newrelic.js file and unset any environment variables being used. When the uninstall process finishes, restart your app. For more information about <em>installation</em>, see Installing and maintaining <em>Node.js</em>. Tip You may also want to remove your app from New Relic. For more help Additional documentation resources include: Troubleshooting the <em>Node.js</em> <em>agent</em> (a library of troubleshooting solutions for <em>Node.js</em>)"
      },
      "id": "6043d36a196a676f52960f77"
    },
    {
      "sections": [
        "Node.js agent configuration",
        "Important",
        "Configuration methods and precedence",
        "Agent configuration file",
        "Environment variables",
        "Server-side configuration",
        "Exports variables",
        "app_name (REQUIRED)",
        "Tip",
        "license_key (REQUIRED)",
        "agent_enabled",
        "allow_all_headers",
        "Caution",
        "apdex_t (DEPRECATED)",
        "certificates",
        "high_security",
        "host",
        "labels",
        "port",
        "proxy",
        "proxy_host",
        "proxy_pass",
        "proxy_port",
        "proxy_user",
        "Logging variables",
        "enabled",
        "level",
        "filepath",
        "Audit logging",
        "endpoints",
        "API configuration",
        "custom_attributes_enabled",
        "custom_events_enabled",
        "notice_error_enabled",
        "Attributes",
        "exclude",
        "include",
        "include_enabled",
        "Error collector variables",
        "ignore_status_codes",
        "ignore_classes",
        "ignore_messages",
        "expected_status_codes",
        "expected_classes",
        "expected_messages",
        "attributes.enabled",
        "attributes.exclude",
        "attributes.include",
        "Transaction tracer variables",
        "explain_threshold",
        "record_sql",
        "top_n",
        "transaction_threshold",
        "hide_internals",
        "Rules variables",
        "name",
        "ignore",
        "enforce_backstop",
        "Transaction events variables",
        "max_samples_stored",
        "max_samples_stored (DEPRECATED)",
        "max_samples_per_minute (DEPRECATED)",
        "Browser monitoring variables",
        "enable",
        "debug",
        "Custom events variables",
        "Slow queries variables",
        "max_samples",
        "Custom hostname variables",
        "display_name",
        "ipv_preference",
        "Environment variable overrides",
        "NEW_RELIC_HOME",
        "NEW_RELIC_NO_CONFIG_FILE",
        "Datastore tracer variables",
        "instance_reporting.enabled",
        "database_name_reporting.enabled",
        "Cross application tracing",
        "Error message redaction variables",
        "Distributed tracing",
        "exclude_newrelic_header",
        "Span events",
        "Infinite Tracing",
        "trace_observer.host"
      ],
      "title": "Node.js agent configuration",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Installation and configuration"
      ],
      "external_id": "6776895960bd4803e98f4c7260c0563c89c09f70",
      "image": "https://docs.newrelic.com/static/bab8ec5bda2eda3aaa5ddaefbed52d93/9fc4b/nodejs-configuration-precedence.png",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/installation-configuration/nodejs-agent-configuration/",
      "published_at": "2021-05-28T15:25:01Z",
      "updated_at": "2021-03-16T15:53:42Z",
      "document_type": "page",
      "popularity": 1,
      "body": "You can tailor the Node.js agent to your app's requirements by editing your newrelic.js config file or by setting an environment variable. The config file resides in the root directory of your app. You can also configure a few options from New Relic, or use the Node.js agent API. Important The license_key setting is required. We highly recommend setting the app_name so that your app has a meaningful name instead of the default My Application. Configuration methods and precedence The primary method to configure the Node.js agent is the agent configuration file (newrelic.js). You can also configure most settings with environment variables. You can also adjust some settings with server-side configuration. The Node.js agent uses this order of precedence for configuration methods: Node.js configuration hierarchy: Server-side configuration settings override environment variables. Environment variables override the agent config file. The config file overrides the agent defaults. Here are detailed descriptions of each configuration method: Agent configuration file The config file (newrelic.js) contains every Node.js agent setting. When you install the Node.js agent, you must copy newrelic.js into your app's root directory. Most settings are empty by default; they inherit their values from config/default.js. Environment variables Most configuration settings in newrelic.js have equivalent environment variables. These are useful, for example, if your agent runs in a PaaS environment such as Heroku or Microsoft Azure. Node.js agent environment variables always start with NEW_RELIC_. Where available, these environment variables are documented below under individual config options as the Environ variable. There are also two rarely used settings that can only be configured via environment variables. Server-side configuration Owners and Admins can view and configure a few settings directly in New Relic. Where available, the UI labels for server-side config are listed in this document under individual config options as the Server-side label. Exports variables This section defines the Node.js agent variables in the order they typically appear in the exports.config = { section of your app's newrelic.js configuration file. app_name (REQUIRED) Type String Default \"My Application\" Environ variable NEW_RELIC_APP_NAME The name New Relic uses to identify your app. For example, app_name: ['MyNodeApp']. To use multiple names for your app, specify a comma-delimited list of names. Data for all applications with the same name will be merged in the New Relic UI, so set this carefully. We highly recommend that you replace the default name with a descriptive name to avoid confusion and unintended aggregation of data. Tip For Azure users, the Node.js agent will use APP_POOL_ID if it is set, so you can use the name you chose for your Azure Web Server without setting it twice. license_key (REQUIRED) Type String Default (none) Environ variable NEW_RELIC_LICENSE_KEY This setting is required. Your New Relic license key. For example, license_key: '40HexadecimalCharacters'. agent_enabled Type Boolean Default true Environ variable NEW_RELIC_ENABLED Set to false to stop the agent from starting up. This is useful when debugging your code requires temporarily disabling the agent. It prevents the agent from bootstrapping its instrumentation or setting up all its pieces, which prevents the agent from starting up and connecting to New Relic's servers. allow_all_headers If true, enables capture of all HTTP headers, except for those filtered by exclude rules. If false, collected headers are limited to those defined in Node.js agent attributes. Type Boolean Default false Caution Any header-related include/exclude rules must be in camelCase form to be filtered. apdex_t (DEPRECATED) Type Number Default 0.100 Server-side label Apdex T Set your Apdex T via the New Relic UI. certificates Type Array of strings Default (none) Additional certificates to trust for SSL connections, specified as an array of strings in PEM format. This affects both connections to an HTTPS proxy and connections to New Relic. Tip You can also configure the agent to read its certificates from a file: certificates: [ fs.readFileSync('myca.crt', {encoding: 'utf8'}) ] Copy high_security Type Boolean Default false Environ variable NEW_RELIC_HIGH_SECURITY When set to true, enables high security v2. You must also enable the ssl setting and enable high security in the UI. host Type String Default collector.newrelic.com Environ variable NEW_RELIC_HOST Important Do not edit this value unless New Relic Support asks you to change it. Hostname for the New Relic collector to connect to the Internet; for example, host: 'collector.newrelic.com'. labels Adds tags. Specify your tags as objects or a semicolon-delimited string of colon-separated pairs (for example, Server:One;Data Center:Primary). Type Object or string Default (none) Environ variable NEW_RELIC_LABELS port Type Integer Default 443 Environ variable NEW_RELIC_PORT Important Do not edit this value unless New Relic Support asks you to change it. Port number to connect to the New Relic collector; for example, port: 443. proxy Type String Default (none) Environ variable NEW_RELIC_PROXY_URL A URL specifying the proxy server to connect to the Internet. For example, proxy: 'http://user:pass@10.0.0.1:8000/'. Important The proxy config file setting overrides the other config file proxy settings (proxy_host, proxy_port, proxy_user, proxy_pass) if used. Similarly, the NEW_RELIC_PROXY_URL environment variable overrides the other environment variable proxy settings (NEW_RELIC_PROXY_HOST, NEW_RELIC_PROXY_PORT, NEW_RELIC_PROXY_USER, and NEW_RELIC_PROXY_PASS) if used. proxy_host Type String Default (none) Environ variable NEW_RELIC_PROXY_HOST Hostname or IP address of the proxy server to connect to the Internet. proxy_pass Type String Default (none) Environ variable NEW_RELIC_PROXY_PASS Password for authenticating to the proxy server. The agent supports only basic HTTP authentication. proxy_port Type String Default (none) Environ variable NEW_RELIC_PROXY_PORT Port number of the proxy server to connect to the Internet. proxy_user Type String Default (none) Environ variable NEW_RELIC_PROXY_USER User name for authenticating to the proxy server. The agent supports only basic HTTP authentication. Logging variables This section defines the Node.js agent variables in the order they typically appear in the logging: { section of your app's newrelic.js configuration file. enabled Type String Default true (false in serverless_mode) Environ variable NEW_RELIC_LOG_ENABLED Enables or disables agent specific logging. level Type String Default info Environ variable NEW_RELIC_LOG_LEVEL Defines the level of detail recorded in the agent logs. From least detail to most detail, possible values are fatal, error, warn, info, debug, or trace. Caution Do not use debug or trace logging unless New Relic Support asks you to use them. These levels of logging can generate excessive overhead. For most situations, use info. filepath Type String Default process.cwd() plus newrelic_agent.log Environ variable NEW_RELIC_LOG Complete path to the New Relic agent log, including the filename. Defaults to filepath: require('path').join(process.cwd(), 'newrelic_agent.log'). The agent will shut down the process if it cannot create this file. The agent creates a log file with the same permissions as the parent Node.js agent process. To write all logging to stdout, set this to stdout. To write all logging to stderr, set this to stderr. Audit logging This section defines the Node.js agent variables in the order they typically appear in the audit_log: { section of your app's newrelic.js configuration file. enabled Type Boolean Default false Environ variable NEW_RELIC_AUDIT_LOG_ENABLED When enabled, the agent logs the payloads it sends to the collector. This data is included in the main log file even when logging level is set to the lowest level. endpoints Type Array Default Empty array (include all types) Environ variable NEW_RELIC_AUDIT_LOG_ENDPOINTS The agent sends several different types of data to the collector in separate payloads. By default, all of them are included in the log file. This option makes it possible to limit logging only to specific types of data. Valid values include: agent_settings analytic_event_data connect custom_event_data error_data error_event_data metric_data preconnect shutdown span_event_data sql_trace_data transaction_sample_data API configuration This section allows you to choose which API methods are enabled. Each configuration option allows you to modularly enable API methods that are responsible for sending custom information to New Relic. Important All of these are set to false when the agent is in high security mode. custom_attributes_enabled Type Boolean Default true Environ variable NEW_RELIC_API_CUSTOM_ATTRIBUTES This option enables newrelic.addCustomAttribute and newrelic.addCustomAttributes. custom_events_enabled Type Boolean Default true Environ variable NEW_RELIC_API_CUSTOM_EVENTS This option enables recordCustomEvent. notice_error_enabled Type Boolean Default true Environ variable NEW_RELIC_API_NOTICE_ERROR This option enables newrelic.noticeError. Attributes This section defines the variables for Node.js agent attributes in the order they typically appear in the attributes: { section of your app's newrelic.js configuration file. Caution Any header-related include/exclude rules must be in camelCase form to be filtered. enabled Type Boolean Default true Environ variable NEW_RELIC_ATTRIBUTES_ENABLED If true, enables capture of attributes for all destinations. exclude Type Array Default [] Environ variable NEW_RELIC_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from all destinations. Allows * as wildcard at end. include Type Array Default [] Environ variable NEW_RELIC_ATTRIBUTES_INCLUDE Prefix of attributes to include from all destinations. Allows * as wildcard at end. include_enabled Type Boolean Default true Environ variable NEW_RELIC_ATTRIBUTES_INCLUDE_ENABLED When true, patterns may be added to the attributes.include list. Error collector variables You can manage how error are handled in New Relic. This section defines the Node.js agent variables in the order they typically appear in the error_collector: { section of your app's newrelic.js configuration file. enabled Type Boolean Default true Environ variable NEW_RELIC_ERROR_COLLECTOR_ENABLED Server-side label Enable error collection? When enabled, the agent collects error traces from your app. ignore_status_codes Type Array Default 404 Environ variable NEW_RELIC_ERROR_COLLECTOR_IGNORE_ERROR_CODES Server-side label Ignore these status codes Comma-delimited list of HTTP status codes for the error collector to ignore. Caution Errors recorded using newrelic.noticeError do not obey this configuration value. ignore_classes Type Array|Object Default [] Environ variable NEW_RELIC_ERROR_COLLECTOR_IGNORE_ERRORS Comma-delimited list of javascript error types/classes for the error collector to ignore. The following configuration /* ... */ error_collector: { ignore_classes: [\"ReferenceError\"] } /* ... */ Copy Would ignore all reference errors. Caution Errors recorded using newrelic.noticeError do not obey this configuration value. ignore_messages Type Object Default {} A javascript object describing a list of javascript classes tied to javascript error messages for the collector to ignore. The following configuration. /* ... */ error_collector: { /* ... */ ignore_messages: {\"Error\":[\"Undefined\", \"Out of time\"]} /* ... */ } /* ... */ Copy Would ignore all errors of type Error, with the exact (case-sensitive) message strings of Undefined and Out of time. Caution Errors recorded using newrelic.noticeError do not obey this configuration value. expected_status_codes Type Array Default [] Environ variable NEW_RELIC_ERROR_COLLECTOR_EXPECTED_ERROR_CODES Comma-delimited list of HTTP status codes for the error collector to mark as expected. Caution Errors recorded using newrelic.noticeError do not obey this configuration value. expected_classes Type Array Default [] Environ variable NEW_RELIC_ERROR_COLLECTOR_EXPECTED_ERRORS The following configuration /* ... */ error_collector: { expected_classes: [\"ReferenceError\"] } /* ... */ Copy Would mark all reference errors as expected. Caution Errors recorded using newrelic.noticeError do not obey this configuration value. expected_messages Type Object Default {} A javascript object describing a list of javascript classes tied to javascript error messages for the collector to ignore. The following configuration. /* ... */ error_collector: { /* ... */ expected_messages: {\"Error\":[\"Undefined\", \"Out of time\"]} /* ... */ } /* ... */ Copy Would mark all errors of type Error, with the exact (case-sensitive) message strings of Undefined and Out of time. Caution Errors recorded using newrelic.noticeError do not obey this configuration value. attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_ERROR_COLLECTOR_ATTRIBUTES_ENABLED If true, the agent captures attributes from error collection. Caution Any header-related include/exclude rules must be in camelCase form to be filtered. attributes.exclude Type Array Default [] Environ variable NEW_RELIC_ERROR_COLLECTOR_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from error collection. Allows * as wildcard at end. attributes.include Type Array Default [] Environ variable NEW_RELIC_ERROR_COLLECTOR_ATTRIBUTES_INCLUDE Prefix of attributes to include in error collection. Allows * as wildcard at end. Transaction tracer variables The agent groups your requests into transactions, which are used to: Visualize where your app spends its time (in transaction breakdowns). Identify slow requests. Group metrics. Isolate other issues, such as slow database performance. This section defines the Node.js agent variables in the order they typically appear in the transaction_tracer: { section of your app's newrelic.js configuration file. Important Do not use brackets [suffix] at the end of your transaction name. New Relic automatically strips brackets from the name. Instead, use parentheses (suffix) or other symbols if needed. enabled Type Boolean Default true Environ variable NEW_RELIC_TRACER_ENABLED Server-side label Enable transaction tracing? When enabled, the agent collects slow transaction traces. explain_threshold Type Integer Default 500 Environ variable NEW_RELIC_EXPLAIN_THRESHOLD Minimum query duration (in milliseconds) for a transaction to be eligible for slow queries in transaction traces. record_sql Type String (off, obfuscated, or raw) Default off Environ variable NEW_RELIC_RECORD_SQL This option affects both slow queries and record_sql for transaction traces. It can have one of three values: off, obfuscated, or raw. When set to off no slow queries will be captured, and backtraces and SQL will not be included in transaction traces. If set to raw or obfuscated, the agent sends raw or obfuscated SQL and a slow query sample to the collector. The agent may also send SQL when other criteria are met, such as when slow_sql.enabled is set. top_n Type Integer Default 20 Environ variable NEW_RELIC_TRACER_TOP_N Defines the maximum number of requests eligible for transaction traces. Transactions are named based on the request, and top_n refers to the \"top n slowest transactions\" grouped by these names. The module replaces a recorded trace with a new trace only if the new trace is slower than the previous slowest trace of that name. The default value for this setting is top_n: 20, because the Transactions page also defaults to the 20 slowest transactions. The Node.js agent captures at least five different slow transactions in the first harvest cycle after start up. It will also reset and capture different transactions if no slow transactions have been captured for the last five harvest cycles. This allows you to see more information about more of your app's request paths, at the possible cost of not focusing on the absolutely slowest request for that harvest cycle. Tip To record the absolute slowest transaction over the last minute, you can set top_n: 0 or top_n: 1. However, this causes one very slow route to dominate your transaction traces. transaction_threshold Type Integer or apdex_f Default apdex_f Environ variable NEW_RELIC_TRACER_THRESHOLD Server-side label Threshold Threshold of web transaction response time in seconds beyond which a transaction is eligible for transaction tracing. The default value is apdex_f; this sets the trace threshold to four times your application's Apdex T. You can also enter a specific time value in milliseconds. Example: Threshold set to apdex_f The default apdex_t is 100 milliseconds. If your transaction threshold is set to apdex_f, a \"slow\" transaction is 400 milliseconds. hide_internals Type boolean Default true Environ variable NEW_RELIC_HIDE_INTERNALS The agent uses a small amount of CPU in order to hide internal properties that are attached to the web application. If you change this configuration to false, it may slightly decrease your agent overhead, but it could also have an impact on the performance of the agent. attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_TRANSACTION_TRACER_ATTRIBUTES_ENABLED If true, the agent captures attributes from transaction traces. Caution Any header-related include/exclude rules must be in camelCase form to be filtered. attributes.exclude Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_TRACER_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from transaction traces. Allows * as wildcard at end. attributes.include Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_TRACER_ATTRIBUTES_INCLUDE Prefix of attributes to include in transaction traces. Allows * as wildcard at end. Rules variables This section defines the Node.js agent variables in the order they typically appear in the rules: { section of your app's newrelic.js configuration file. name Type Strings or regular expressions Default (none) Environ variable NEW_RELIC_NAMING_RULES A comma-delimited list of rules to match incoming request URLs and name the associated New Relic transaction. Uses the format: name: [ {pattern: 'STRING_OR_REGEX', name: 'NAME'}, {pattern: 'STRING_OR_REGEX', name: 'NAME'} ], Copy Both parameters are required. For strings, you must escape control characters. You do not need to escape control characters in regular expressions. Additional attributes are ignored. Regular expressions support JavaScript-style capture groups, and names use $1-style replacement strings. Regular expressions only find the first matching result; subsequent matches are ignored. For more information, see Node.js transaction naming API. For the NEW_RELIC_NAMING_RULES environment variable, pass the rules as comma-delimited JSON object literals: NEW_RELIC_NAMING_RULES='{\"pattern\":\"^t\",\"name\":\"u\"},{\"pattern\":\"^u\",\"name\":\"t\"}' Copy ignore Type Strings or regular expressions Default Regular expression to match socket.io long-polling requests (\"^ \\ /socket \\ .io \\ /. * \\ /xhr-polling/\"). Environ variable NEW_RELIC_IGNORING_RULES Define a list of request URLs you want the agent to ignore. Specify the list as patterns, which can be strings or regular expressions. enforce_backstop Type Boolean Default true Environ variable NEW_RELIC_ENFORCE_BACKSTOP Caution Do not change this setting unless you understand metric grouping issues. When enabled, the agent renames transactions that are not affected by other naming logic (such as the API, rules, or metric normalization rules) to NormalizedUri/*. If you set this to false, the agent sets transaction names to Uri/path/to/resource. Transaction events variables This section defines the Node.js agent variables in the order they typically appear in the transaction_events: { section of your app's newrelic.js configuration file. enabled Type Boolean Default true When enabled, the agent sends transaction events to New Relic. This event data includes transaction timing, transaction name, and any custom parameters. If this is disabled, the agent does not collect this data or send it to New Relic. max_samples_stored Type Integer Default 10000 Defines the maximum number of events the agent collects per minute. If there are more than this number, the agent collects a statistical sampling. We do not recommend configuring past 10k. The server will cap data at 10k per-minute. Important This configuration had different behavior in agent versions lower than 6.0.0. See max_samples_stored (DEPRECATED) for agent versions 5.x or lower. max_samples_stored (DEPRECATED) Type Integer Default 20000 Defines the maximum number of events the agent stores if it is unable to communicate with the New Relic collector. The values from the previous harvest cycle will be merged into the next one, with this option limiting the maximum number. Make sure this number is greater than max_samples_per_minute; for example, set it to twice as much. Consider your memory overhead before increasing this value. Caution This configuration has different behavior starting with agent version 6.0.0 and a new recommended maximum. See max_samples_stored for agent versions 6.x or higher. max_samples_per_minute (DEPRECATED) Type Integer Default 10000 Defines the maximum number of events the agent collects per minute. If there are more than this number, the agent collects a statistical sampling. Caution This configuration has been replaced with max_samples_stored starting with version 6.0.0 of the agent. See max_samples_stored for 6.x or later agents. attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_TRANSACTION_EVENTS_ATTRIBUTES_ENABLED If true, the agent captures attributes from transaction events. Caution Any header-related include/exclude rules must be in camelCase form to be filtered. attributes.exclude Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_EVENTS_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from transaction events. Allows * as wildcard at end. attributes.include Type Array Default [] Environ variable NEW_RELIC_TRANSACTION_EVENTS_ATTRIBUTES_INCLUDE Prefix of attributes to include in transaction events. Allows * as wildcard at end. Browser monitoring variables This section defines the Node.js agent variables in the order they typically appear in the browser_monitoring: { section of your app's newrelic.js configuration file. enable Type Boolean Default true Environ variable NEW_RELIC_BROWSER_MONITOR_ENABLE Server-side label Enable browser monitoring? Generate JavaScript headers for browser instrumentation. Although this defaults to true, the agent doesn't inject the browser JS code unless you have enabled browser monitoring. Even if you have enabled it and added the browser timing header, you can disable browser monitoring for your app by setting this to false. debug Type Boolean Default false Environ variable NEW_RELIC_BROWSER_MONITOR_DEBUG If true, request un-minified sources from the server. attributes.enabled Type Boolean Default false Environ variable NEW_RELIC_BROWSER_MONITORING_ATTRIBUTES_ENABLED If true, the agent sends custom attributes to browser monitoring. Caution Any header-related include/exclude rules must be in camelCase form to be filtered. attributes.exclude Type Array Default [] Environ variable NEW_RELIC_BROWSER_MONITORING_ATTRIBUTES_EXCLUDE Prefix of attributes to exclude from browser monitoring. Allows * as wildcard at end. attributes.include Type Array Default [] Environ variable NEW_RELIC_BROWSER_MONITORING_ATTRIBUTES_INCLUDE Prefix of attributes to include in browser monitoring. Allows * as wildcard at end. Custom events variables This section defines the Node.js agent variables in the order they typically appear in the custom_insights_events: { section of your app's newrelic.js configuration file. Currently there are no environment variables for custom events. enabled Type Boolean Default true When enabled, the agent sends custom events recorded with recordCustomEvent() to New Relic. If this is disabled, the agent does not collect this data or send it to New Relic. max_samples_stored Type Integer Default 1000 Defines the maximum number of custom events the agent collects per minute. If the number of custom events exceeds this limit, the agent collects a statistical sampling. Important Increasing this limit increases memory usage. Slow queries variables This section defines the Node.js agent variables in the order they typically appear in the slow_sql: { section of your app's newrelic.js configuration file. These options control behavior for slow queries, but do not affect SQL nodes in transaction traces. enabled Type Boolean Default false Environ variable NEW_RELIC_SLOW_SQL_ENABLED When enabled, the agent collects slow query details. max_samples Type Integer Default 10 Environ variable NEW_RELIC_MAX_SQL_SAMPLES Defines the maximum number of slow queries the agent collects per minute. The agent discards additional queries after the limit is reached. Important Increasing this limit increases memory usage. Custom hostname variables This section defines the Node.js agent variables in the order they typically appear in the process_host: { section of your app's newrelic.js configuration file. These options control behavior regarding the host display name in the New Relic APM UI. display_name Type String of 255 bytes or less Default (none) Environ variable NEW_RELIC_PROCESS_HOST_DISPLAY_NAME Specify a custom hostname for display in New Relic. If you do not set this field, New Relic will continue to use the default hostname found by calling os.hostname(). If you use the default hostname settings, New Relic finds the hostname through os.hostname(). If this call fails, New Relic uses the host's IP as the name. If you set ipv_preference: 4 or ipv_preference: 6, you can select the type of IP address (IPv4 or IPv6) that appears in the New Relic UI. ipv_preference Type Integer (4 or 6) Default 4 Environ variable NEW_RELIC_IPV_PREFERENCE Environment variable overrides This section defines two configuration options only available with environment variables. These overrides are not used in most configurations. NEW_RELIC_HOME Path to the directory containing newrelic.js. This is available only as an environment variable. You cannot set it in your config file. Type String Default (none) NEW_RELIC_NO_CONFIG_FILE If used, this prevents the agent from reading configuration settings from newrelic.js. Default values and values from environment variables will still be set. This is available only as an environment variable. You cannot set it in your config file. Type Boolean Default False Datastore tracer variables This section defines the Node.js agent variables in the order they typically appear in the datastore_tracer section of your app's newrelic.js configuration file. These options control behavior for collecting datastore instance metrics. instance_reporting.enabled Type Boolean Default true When enabled, the agent collects datastore instance metrics (such as host and port) for some database drivers. These are reported on slow query traces and transaction traces. database_name_reporting.enabled Type Boolean Default true When enabled, the agent collects database name on slow query traces and transaction traces for some database drivers. Cross application tracing The Node.js agent variables that control cross application tracing typically appear in the cross_application_tracer section of your app's newrelic.js configuration file: enabled Type Boolean Default true When set to true, allows tracing of transactions across more than one New Relic-monitored applications. Error message redaction variables The Node.js agent variables that control error message redaction appear in the allow_raw_exception_messages section of your app's newrelic.js configuration file: enabled Type Boolean Default true Environ variable NEW_RELIC_ALLOW_RAW_EXCEPTION_MESSAGES_ENABLED When false, the agent will redact the messages of captured errors. Distributed tracing Important Enabling distributed tracing disables cross application tracing, and has effects on other APM features. Before enabling, read the transition guide. Requires Node.js agent version 4.7.0 or higher. Distributed tracing lets you see the path that a request takes as it travels through a distributed system. When configuring via the config file, place the following option in the distributed_tracing section. When distributed tracing is enabled, you can collect span events. enabled Type Boolean Default false Environ variable NEW_RELIC_DISTRIBUTED_TRACING_ENABLED Set this to true to enable distributed tracing. For example, to enable this in the config file, you would use: distributed_tracing: { enabled: true } Copy exclude_newrelic_header Type Boolean Default false Set this to true to exclude the New Relic header that is attached to outbound requests, and instead only rely on W3C Trace Context Headers for distributed tracing. If this is false then both types of headers are used. For example, to enable this in the config file, you would use: distributed_tracing:{ enabled: true, exclude_newrelic_header: true } Copy Span events Span events are reported for distributed tracing. Distributed tracing must be enabled to report span events. Span configuration is set in the span_events stanza. Options include: enabled Type Boolean Default true Environ variable NEW_RELIC_SPAN_EVENTS_ENABLED Turns reporting of span events on or off. attributes.enabled Type Boolean Default true Environ variable NEW_RELIC_SPAN_EVENTS_ATTRIBUTES_ENABLED This setting can be used to turn reporting of attributes on or off for span events. If attributes.enabled at the root level is false, no attributes will be sent to span events regardless on how this is set. attributes.include Type Array Default [] Environ variable NEW_RELIC_SPAN_EVENTS_ATTRIBUTES_INCLUDE If attributes are enabled for span events, all attribute keys found in this list will be attached to span events. For more information, see the agent attribute rules. attributes.exclude Type Array Default [] Environ variable NEW_RELIC_SPAN_EVENTS_ATTRIBUTES_EXCLUDE All attribute keys found in this list will not be sent with span events. For more information, see the agent attribute rules. Infinite Tracing To turn on Infinite Tracing, enable distributed tracing (set distributed_tracing to enabled: true) and add the additional settings below. For an example, see Language Agents: Configure Distributed Tracing. trace_observer.host Type String Default (none) Environ variable NEW_RELIC_INFINITE_TRACING_TRACE_OBSERVER_HOST For help getting a valid Infinite Tracing trace observer host entry, see Find or create a trace observer endpoint.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 148.5103,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Node.js <em>agent</em> <em>configuration</em>",
        "sections": "Node.js <em>agent</em> <em>configuration</em>",
        "tags": "<em>Installation</em> <em>and</em> <em>configuration</em>",
        "body": " The license_key setting is required. We highly recommend setting the app_name so that your app has a meaningful name instead of the default My Application. <em>Configuration</em> methods and precedence The primary method to configure the <em>Node.js</em> <em>agent</em> is the <em>agent</em> <em>configuration</em> file (newrelic.js). You can also"
      },
      "id": "603e87a728ccbc4653eba75b"
    }
  ],
  "/docs/agents/nodejs-agent/troubleshooting/generate-trace-log-troubleshooting-nodejs": [
    {
      "sections": [
        "Troubleshooting large memory usage (Node.js)",
        "Problem",
        "Solution",
        "Increase caused by TLS memory buffer allocation",
        "Caution",
        "Increase caused by cluster worker slab allocations",
        "Increase caused by log messages stored to disk",
        "Increase caused by leaked MongoDB cursors",
        "Increase caused by agent data storage"
      ],
      "title": "Troubleshooting large memory usage (Node.js)",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Troubleshooting"
      ],
      "external_id": "fdacc90072462a34ca0db2b51f5145c1be4caf9d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/troubleshooting/troubleshooting-large-memory-usage-nodejs/",
      "published_at": "2021-06-02T15:29:05Z",
      "updated_at": "2021-05-10T19:02:56Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You installed the New Relic Node.js agent, and your Node.js application's memory usage increased. Solution There are several possible causes for this memory increase and potential solutions for each. Increase caused by TLS memory buffer allocation The first time a Node.js application uses any form of encryption, including SSL and HTTPS, a slab buffer is created. The default size for this buffer is 10 MB. Applications running in environments where SSL termination on inbound requests occurs in a separate router layer do not normally incur this overhead. Cloud services like Heroku and AWS often operate this way. However, the Node.js agent sends outbound data to New Relic services over HTTPS, and this triggers the allocation of a slab buffer. Solution: In some cases, you can reduce the slab buffer below its 10 MB default. To set the slab buffer size, use tls.SLAB_BUFFER_SIZE. Caution When using the New Relic agent, do not set the slab buffer size below 128 KB. The slab buffer allocation should not be reduced for apps that communicate with services or clients using SSL, HTTPS, or any other form of cryptography. Increase caused by cluster worker slab allocations Node.js provides the Cluster module. This allows for handling requests in parallel by using all processor cores available on a host. However, each cluster worker allocates its own slab buffer for SSL transactions, and keeps its own copy of Node.js agent data. This multiplies the memory overhead by the number of cluster workers used. The is also true if a host runs multiple Node.js applications at the same time. Solution: Some cloud service providers use environments that state a higher number of processor cores than can actually be used at any given time. Reducing the number of cluster workers or running without Cluster support may decrease memory usage without impacting performance. Increase caused by log messages stored to disk Log messages are logged to disk by default. Due to how message data is handled, message objects may be moved into Old-pointer-space for garbage collection. This means the objects stay in memory for a while, even after all references to them are gone. This leads to a larger amount of memory consumed by a process at any given time. Additional processing time is also used for garbage collection. Solution: Depending on your version of the Node.js, the agent may default to the trace or info log levels. Decrease logging verbosity to info or warn levels to noticeably decrease memory usage and time spent in garbage collection. Increase caused by leaked MongoDB cursors Many database drivers use an abstraction called a cursor. Cursors provide the ability to iterate through the results of queries. For example, the mongodb driver provides cursors when executing find queries. Cursors live both as objects in the Node.js runtime and as entities in the MongoDB server. When an application has finished using a cursor, it should close it to free up resources in both the server and the client application. In Node.js, it is possible for a cursor to be garbage collected, freeing resources in the application, without closing the cursor in the server. This may be go unnoticed in the application. However, the New Relic Node.js agent keeps track of open cursors to measure the time spent iterating through results. If your application does not close all the cursors it uses, the agent will continue to track stale cursors and leak memory. Solution: Ensure every cursor created in your application is closed by calling cursor.close() after the application finishes processing the results of the query. Increase caused by agent data storage The Node.js agent records data for each transaction your app handles. Data is generally grouped by transaction name. The memory used by the agent increases with the number of different transactions recorded in each minute-long harvest cycle. In addition, a larger amount of data is kept during each transaction, but is eventually discarded when the transaction completes. Memory used by the agent increases with the number of concurrent transactions handled by the application. Solution: If agent data storage is identified as the cause of a memory usage increase, this can best be addressed by adding additional memory to your host, or by switching to a larger cloud instance.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 97.7684,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Troubleshooting</em> large memory usage (Node.js)",
        "sections": "<em>Troubleshooting</em> large memory usage (Node.js)",
        "tags": "<em>Nodejs</em> <em>agent</em>",
        "body": "Problem You installed the New Relic <em>Node.js</em> <em>agent</em>, and your <em>Node.js</em> application&#x27;s memory usage increased. Solution There are several possible causes for this memory increase and potential solutions for each. Increase caused by TLS memory buffer allocation The first time a <em>Node.js</em> application uses"
      },
      "id": "603e9d6828ccbcb774eba788"
    },
    {
      "sections": [
        "Troubleshoot your Node.js installation",
        "Problem",
        "Solution",
        "Not seeing data",
        "Installation problems",
        "Log files",
        "Missing VM metrics"
      ],
      "title": "Troubleshoot your Node.js installation",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Troubleshooting"
      ],
      "external_id": "2c9fef97ba7342d3e3b334a26890c3a166a12849",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/troubleshooting/troubleshoot-your-nodejs-installation/",
      "published_at": "2021-06-02T15:26:38Z",
      "updated_at": "2021-03-16T15:05:11Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem If you have encountered any of these common problems after installing your New Relic Node.js agent, try these troubleshooting tips. Solution Some common problems users encounter after installing the New Relic Node.js agent include: Not seeing data To minimize the amount of bandwidth the Node.js agent consumes, New Relic only reports data once per minute. If you add the agent to tests that take less than a minute to run, it will not have time to report data to New Relic. If you do not see transaction traces or other data after deploying the agent, this may be due to configuration, framework, or Apdex settings. Use New Relic Diagnostics to try to automatically identify the issue. Installation problems What to check Comments Main module Ensure that you have added require('newrelic'); as the first line of the app's main module. If the require is added later, the Node.js agent may not properly instrument your application. Conditional logic If you have any conditional logic in your require, move the conditional logic to your newrelic.js configuration file. Frameworks For problems with supported frameworks, make sure you are using Connect, Express, Hapi, Kraken, or Restify. There are other Node.js frameworks, but New Relic does not support all of them. Apdex For problems with your Apdex results, try adjusting your Apdex score via your Node.js agent config file (newrelic.js) or the New Relic user interface. Log files The Node.js agent writes its log to the newrelic_agent.log file in the application directory, unless you have changed the logging settings. If the agent does not send data or crashes your app, you can generate a troubleshooting log file to accompany bug reports and support requests. Missing VM metrics The agent can collect VM metrics related to garbage collection (GC), memory, and CPU. Some of these metrics require an additional native module to be installed. Here are some common problems and their solutions: Problem During installation, npm shows one of the following error messages: gyp ERR! configure error gyp ERR! stack Error: Can't find Python executable \"python\", you can set the PYTHON env variable. Copy gyp ERR! build error gyp ERR! stack Error: not found: make Copy make: g++: Command not found Copy Solution Ensure that the prerequisites for the node-gyp module are installed. On Debian/Ubuntu platforms, use this command: apt-get install build-essential Copy For more information, see Node.js VM measurements. Other troubleshooting resources on our Explorers Hub forum: Troubleshooting install General configuration troubleshooting",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.769165,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Troubleshoot</em> your Node.js installation",
        "sections": "<em>Troubleshoot</em> your Node.js installation",
        "tags": "<em>Nodejs</em> <em>agent</em>",
        "body": "Problem If you have encountered any of these common problems after installing your New Relic <em>Node.js</em> <em>agent</em>, try these <em>troubleshooting</em> tips. Solution Some common problems users encounter after installing the New Relic <em>Node.js</em> <em>agent</em> include: Not seeing data To minimize the amount of bandwidth"
      },
      "id": "603e7e83e7b9d25c0b2a07d1"
    },
    {
      "sections": [
        "Introduction to New Relic for Node.js",
        "Tip",
        "Why it matters",
        "Installation",
        "Extend your instrumentation",
        "Troubleshoot your installation",
        "Check the source code"
      ],
      "title": "Introduction to New Relic for Node.js",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Getting started"
      ],
      "external_id": "8e664d52df4f0ccf1c91301e3b620699a0770850",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/getting-started/introduction-new-relic-nodejs/",
      "published_at": "2021-06-02T20:26:13Z",
      "updated_at": "2021-03-11T07:59:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Pinpoint and solve issues down to the line of code with Node.js monitoring from New Relic. With features like service maps and error analytics, our Node.js agent helps you get the full picture of your app environment. Tip To use Node.js or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Why it matters Many Node application requests are based on raw URLs. Our solution is different. New Relic for Node.js assumes it can group requests to your application into transactions instead of HTTP requests. Transactions are defined by giving one or more request paths a name. These names are used to: Visualize where your app is spending its time (in transaction breakdowns). Identify slow requests. Group metrics. Show you which portions of your application are suffering from slow database performance. Installation To install our agent, you need to sign up for New Relic first. Once you're logged in, follow the instructions or use our launcher to get data flowing in. Review the system requirements. Read the install docs. Go directly to the New Relic UI to add Node.js data. Extend your instrumentation After installing the Node.js agent, extend your instrumentation: Extend your instrumentation Comments Customization Implement Node.js custom instrumentation. Collect custom metrics via an API call. Use our Node.js agent API to control, customize, or extend the agent's functionality. Open source telemetry To create your own integrations, use our Node Telemetry SDK. To gain visibility into your GraphQL payloads, use our Apollo Server plugin. Traces Enable distributed tracing. VM measurements Collect key metric timeslice data from the Node.js virtual machine. View detailed VM statistics in the New Relic UI. End-user activity Integrate the Node.js agent with browser monitoring. Gain visibility into user activity with browser monitoring's page load timing process. Troubleshoot your installation If you encounter issues with your Node.js agent, see our troubleshooting information: Large memory usage: If you've installed the Node.js agent and your memory usage has increased, check out these possible solutions. Troubleshooting your Node.js installation: Try these steps if you don't see any data, cannot log files, or encounter other installation problems with the Node.js agent. Troubleshooting Browser instrumentation: If you encounter problems with Browser data, see these additional tips for Node.js. You can also view all troubleshooting docs. If you need additional assistance, get support at support.newrelic.com. Check the source code Our Node.js agent is open source software. You can browse the source code and send improvements, or create your own fork and build it. For more information, see the node-newrelic README on GitHub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 84.58871,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Troubleshoot</em> your installation",
        "tags": "<em>Nodejs</em> <em>agent</em>",
        "body": " from the <em>Node.js</em> virtual machine. View detailed VM statistics in the New Relic UI. End-user activity Integrate the <em>Node.js</em> <em>agent</em> with browser monitoring. Gain visibility into user activity with browser monitoring&#x27;s page load timing process. <em>Troubleshoot</em> your installation If you encounter issues"
      },
      "id": "6043d881196a67be9f960f7a"
    }
  ],
  "/docs/agents/nodejs-agent/troubleshooting/troubleshoot-browser-instrumentation-nodejs": [
    {
      "sections": [
        "Troubleshooting large memory usage (Node.js)",
        "Problem",
        "Solution",
        "Increase caused by TLS memory buffer allocation",
        "Caution",
        "Increase caused by cluster worker slab allocations",
        "Increase caused by log messages stored to disk",
        "Increase caused by leaked MongoDB cursors",
        "Increase caused by agent data storage"
      ],
      "title": "Troubleshooting large memory usage (Node.js)",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Troubleshooting"
      ],
      "external_id": "fdacc90072462a34ca0db2b51f5145c1be4caf9d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/troubleshooting/troubleshooting-large-memory-usage-nodejs/",
      "published_at": "2021-06-02T15:29:05Z",
      "updated_at": "2021-05-10T19:02:56Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You installed the New Relic Node.js agent, and your Node.js application's memory usage increased. Solution There are several possible causes for this memory increase and potential solutions for each. Increase caused by TLS memory buffer allocation The first time a Node.js application uses any form of encryption, including SSL and HTTPS, a slab buffer is created. The default size for this buffer is 10 MB. Applications running in environments where SSL termination on inbound requests occurs in a separate router layer do not normally incur this overhead. Cloud services like Heroku and AWS often operate this way. However, the Node.js agent sends outbound data to New Relic services over HTTPS, and this triggers the allocation of a slab buffer. Solution: In some cases, you can reduce the slab buffer below its 10 MB default. To set the slab buffer size, use tls.SLAB_BUFFER_SIZE. Caution When using the New Relic agent, do not set the slab buffer size below 128 KB. The slab buffer allocation should not be reduced for apps that communicate with services or clients using SSL, HTTPS, or any other form of cryptography. Increase caused by cluster worker slab allocations Node.js provides the Cluster module. This allows for handling requests in parallel by using all processor cores available on a host. However, each cluster worker allocates its own slab buffer for SSL transactions, and keeps its own copy of Node.js agent data. This multiplies the memory overhead by the number of cluster workers used. The is also true if a host runs multiple Node.js applications at the same time. Solution: Some cloud service providers use environments that state a higher number of processor cores than can actually be used at any given time. Reducing the number of cluster workers or running without Cluster support may decrease memory usage without impacting performance. Increase caused by log messages stored to disk Log messages are logged to disk by default. Due to how message data is handled, message objects may be moved into Old-pointer-space for garbage collection. This means the objects stay in memory for a while, even after all references to them are gone. This leads to a larger amount of memory consumed by a process at any given time. Additional processing time is also used for garbage collection. Solution: Depending on your version of the Node.js, the agent may default to the trace or info log levels. Decrease logging verbosity to info or warn levels to noticeably decrease memory usage and time spent in garbage collection. Increase caused by leaked MongoDB cursors Many database drivers use an abstraction called a cursor. Cursors provide the ability to iterate through the results of queries. For example, the mongodb driver provides cursors when executing find queries. Cursors live both as objects in the Node.js runtime and as entities in the MongoDB server. When an application has finished using a cursor, it should close it to free up resources in both the server and the client application. In Node.js, it is possible for a cursor to be garbage collected, freeing resources in the application, without closing the cursor in the server. This may be go unnoticed in the application. However, the New Relic Node.js agent keeps track of open cursors to measure the time spent iterating through results. If your application does not close all the cursors it uses, the agent will continue to track stale cursors and leak memory. Solution: Ensure every cursor created in your application is closed by calling cursor.close() after the application finishes processing the results of the query. Increase caused by agent data storage The Node.js agent records data for each transaction your app handles. Data is generally grouped by transaction name. The memory used by the agent increases with the number of different transactions recorded in each minute-long harvest cycle. In addition, a larger amount of data is kept during each transaction, but is eventually discarded when the transaction completes. Memory used by the agent increases with the number of concurrent transactions handled by the application. Solution: If agent data storage is identified as the cause of a memory usage increase, this can best be addressed by adding additional memory to your host, or by switching to a larger cloud instance.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 97.768394,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Troubleshooting</em> large memory usage (Node.js)",
        "sections": "<em>Troubleshooting</em> large memory usage (Node.js)",
        "tags": "<em>Nodejs</em> <em>agent</em>",
        "body": "Problem You installed the New Relic <em>Node.js</em> <em>agent</em>, and your <em>Node.js</em> application&#x27;s memory usage increased. Solution There are several possible causes for this memory increase and potential solutions for each. Increase caused by TLS memory buffer allocation The first time a <em>Node.js</em> application uses"
      },
      "id": "603e9d6828ccbcb774eba788"
    },
    {
      "sections": [
        "Troubleshoot your Node.js installation",
        "Problem",
        "Solution",
        "Not seeing data",
        "Installation problems",
        "Log files",
        "Missing VM metrics"
      ],
      "title": "Troubleshoot your Node.js installation",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Troubleshooting"
      ],
      "external_id": "2c9fef97ba7342d3e3b334a26890c3a166a12849",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/troubleshooting/troubleshoot-your-nodejs-installation/",
      "published_at": "2021-06-02T15:26:38Z",
      "updated_at": "2021-03-16T15:05:11Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem If you have encountered any of these common problems after installing your New Relic Node.js agent, try these troubleshooting tips. Solution Some common problems users encounter after installing the New Relic Node.js agent include: Not seeing data To minimize the amount of bandwidth the Node.js agent consumes, New Relic only reports data once per minute. If you add the agent to tests that take less than a minute to run, it will not have time to report data to New Relic. If you do not see transaction traces or other data after deploying the agent, this may be due to configuration, framework, or Apdex settings. Use New Relic Diagnostics to try to automatically identify the issue. Installation problems What to check Comments Main module Ensure that you have added require('newrelic'); as the first line of the app's main module. If the require is added later, the Node.js agent may not properly instrument your application. Conditional logic If you have any conditional logic in your require, move the conditional logic to your newrelic.js configuration file. Frameworks For problems with supported frameworks, make sure you are using Connect, Express, Hapi, Kraken, or Restify. There are other Node.js frameworks, but New Relic does not support all of them. Apdex For problems with your Apdex results, try adjusting your Apdex score via your Node.js agent config file (newrelic.js) or the New Relic user interface. Log files The Node.js agent writes its log to the newrelic_agent.log file in the application directory, unless you have changed the logging settings. If the agent does not send data or crashes your app, you can generate a troubleshooting log file to accompany bug reports and support requests. Missing VM metrics The agent can collect VM metrics related to garbage collection (GC), memory, and CPU. Some of these metrics require an additional native module to be installed. Here are some common problems and their solutions: Problem During installation, npm shows one of the following error messages: gyp ERR! configure error gyp ERR! stack Error: Can't find Python executable \"python\", you can set the PYTHON env variable. Copy gyp ERR! build error gyp ERR! stack Error: not found: make Copy make: g++: Command not found Copy Solution Ensure that the prerequisites for the node-gyp module are installed. On Debian/Ubuntu platforms, use this command: apt-get install build-essential Copy For more information, see Node.js VM measurements. Other troubleshooting resources on our Explorers Hub forum: Troubleshooting install General configuration troubleshooting",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.769165,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Troubleshoot</em> your Node.js installation",
        "sections": "<em>Troubleshoot</em> your Node.js installation",
        "tags": "<em>Nodejs</em> <em>agent</em>",
        "body": "Problem If you have encountered any of these common problems after installing your New Relic <em>Node.js</em> <em>agent</em>, try these <em>troubleshooting</em> tips. Solution Some common problems users encounter after installing the New Relic <em>Node.js</em> <em>agent</em> include: Not seeing data To minimize the amount of bandwidth"
      },
      "id": "603e7e83e7b9d25c0b2a07d1"
    },
    {
      "sections": [
        "Generate trace log for troubleshooting (Node.js)",
        "Important",
        "Generate log files",
        "Examine log file",
        "For more help"
      ],
      "title": "Generate trace log for troubleshooting (Node.js)",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Troubleshooting"
      ],
      "external_id": "8a65a36752d2e3c296e49e0d6b8161722c6d9042",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/troubleshooting/generate-trace-log-troubleshooting-nodejs/",
      "published_at": "2021-06-02T20:29:31Z",
      "updated_at": "2021-03-13T02:56:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your New Relic Node.js agent log captures errors at the default info level. However, when troubleshooting or debugging, generate a more verbose trace log to help find and investigate problems. Important The trace log setting is a highly verbose logging level. To reduce disk space consumption, return the logging : { section's level to its original setting after testing. Generate log files To generate the detailed trace log file: Edit your newrelic.js file and change the logging section's level to trace. logging: { level: 'trace' } Copy Restart Node. Exercise your web application for about five minutes to generate sufficient logging data. After testing, change the level to a less verbose logging level, such as info (default). Open and examine the generated log file. Examine log file By default, the Node.js agent stores the log file in the current working directory as newrelic_agent.log. If the log file or folder are not visible: Check whether you have set the logging path to stdout or stderr. Verify that the current working directory is the same as the directory where you expect the log file to be located. For more help Additional documentation resources include the Node.js agent's Troubleshooting section. For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 88.90827,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate trace log for <em>troubleshooting</em> (Node.js)",
        "sections": "Generate trace log for <em>troubleshooting</em> (Node.js)",
        "tags": "<em>Nodejs</em> <em>agent</em>",
        "body": ".log. If the log file or folder are not visible: Check whether you have set the logging path to stdout or stderr. Verify that the current working directory is the same as the directory where you expect the log file to be located. For more help Additional documentation resources include the <em>Node.js</em> <em>agent</em>&#x27;s <em>Troubleshooting</em> section. For logging on all New Relic <em>agents</em>, see New Relic <em>agent</em> logs and <em>troubleshooting</em>."
      },
      "id": "6043d43128ccbce0f02c606a"
    }
  ],
  "/docs/agents/nodejs-agent/troubleshooting/troubleshoot-message-consumers": [
    {
      "sections": [
        "Troubleshooting large memory usage (Node.js)",
        "Problem",
        "Solution",
        "Increase caused by TLS memory buffer allocation",
        "Caution",
        "Increase caused by cluster worker slab allocations",
        "Increase caused by log messages stored to disk",
        "Increase caused by leaked MongoDB cursors",
        "Increase caused by agent data storage"
      ],
      "title": "Troubleshooting large memory usage (Node.js)",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Troubleshooting"
      ],
      "external_id": "fdacc90072462a34ca0db2b51f5145c1be4caf9d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/troubleshooting/troubleshooting-large-memory-usage-nodejs/",
      "published_at": "2021-06-02T15:29:05Z",
      "updated_at": "2021-05-10T19:02:56Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You installed the New Relic Node.js agent, and your Node.js application's memory usage increased. Solution There are several possible causes for this memory increase and potential solutions for each. Increase caused by TLS memory buffer allocation The first time a Node.js application uses any form of encryption, including SSL and HTTPS, a slab buffer is created. The default size for this buffer is 10 MB. Applications running in environments where SSL termination on inbound requests occurs in a separate router layer do not normally incur this overhead. Cloud services like Heroku and AWS often operate this way. However, the Node.js agent sends outbound data to New Relic services over HTTPS, and this triggers the allocation of a slab buffer. Solution: In some cases, you can reduce the slab buffer below its 10 MB default. To set the slab buffer size, use tls.SLAB_BUFFER_SIZE. Caution When using the New Relic agent, do not set the slab buffer size below 128 KB. The slab buffer allocation should not be reduced for apps that communicate with services or clients using SSL, HTTPS, or any other form of cryptography. Increase caused by cluster worker slab allocations Node.js provides the Cluster module. This allows for handling requests in parallel by using all processor cores available on a host. However, each cluster worker allocates its own slab buffer for SSL transactions, and keeps its own copy of Node.js agent data. This multiplies the memory overhead by the number of cluster workers used. The is also true if a host runs multiple Node.js applications at the same time. Solution: Some cloud service providers use environments that state a higher number of processor cores than can actually be used at any given time. Reducing the number of cluster workers or running without Cluster support may decrease memory usage without impacting performance. Increase caused by log messages stored to disk Log messages are logged to disk by default. Due to how message data is handled, message objects may be moved into Old-pointer-space for garbage collection. This means the objects stay in memory for a while, even after all references to them are gone. This leads to a larger amount of memory consumed by a process at any given time. Additional processing time is also used for garbage collection. Solution: Depending on your version of the Node.js, the agent may default to the trace or info log levels. Decrease logging verbosity to info or warn levels to noticeably decrease memory usage and time spent in garbage collection. Increase caused by leaked MongoDB cursors Many database drivers use an abstraction called a cursor. Cursors provide the ability to iterate through the results of queries. For example, the mongodb driver provides cursors when executing find queries. Cursors live both as objects in the Node.js runtime and as entities in the MongoDB server. When an application has finished using a cursor, it should close it to free up resources in both the server and the client application. In Node.js, it is possible for a cursor to be garbage collected, freeing resources in the application, without closing the cursor in the server. This may be go unnoticed in the application. However, the New Relic Node.js agent keeps track of open cursors to measure the time spent iterating through results. If your application does not close all the cursors it uses, the agent will continue to track stale cursors and leak memory. Solution: Ensure every cursor created in your application is closed by calling cursor.close() after the application finishes processing the results of the query. Increase caused by agent data storage The Node.js agent records data for each transaction your app handles. Data is generally grouped by transaction name. The memory used by the agent increases with the number of different transactions recorded in each minute-long harvest cycle. In addition, a larger amount of data is kept during each transaction, but is eventually discarded when the transaction completes. Memory used by the agent increases with the number of concurrent transactions handled by the application. Solution: If agent data storage is identified as the cause of a memory usage increase, this can best be addressed by adding additional memory to your host, or by switching to a larger cloud instance.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 97.768394,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Troubleshooting</em> large memory usage (Node.js)",
        "sections": "<em>Troubleshooting</em> large memory usage (Node.js)",
        "tags": "<em>Nodejs</em> <em>agent</em>",
        "body": "Problem You installed the New Relic <em>Node.js</em> <em>agent</em>, and your <em>Node.js</em> application&#x27;s memory usage increased. Solution There are several possible causes for this memory increase and potential solutions for each. Increase caused by TLS memory buffer allocation The first time a <em>Node.js</em> application uses"
      },
      "id": "603e9d6828ccbcb774eba788"
    },
    {
      "sections": [
        "Troubleshoot your Node.js installation",
        "Problem",
        "Solution",
        "Not seeing data",
        "Installation problems",
        "Log files",
        "Missing VM metrics"
      ],
      "title": "Troubleshoot your Node.js installation",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Troubleshooting"
      ],
      "external_id": "2c9fef97ba7342d3e3b334a26890c3a166a12849",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/troubleshooting/troubleshoot-your-nodejs-installation/",
      "published_at": "2021-06-02T15:26:38Z",
      "updated_at": "2021-03-16T15:05:11Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem If you have encountered any of these common problems after installing your New Relic Node.js agent, try these troubleshooting tips. Solution Some common problems users encounter after installing the New Relic Node.js agent include: Not seeing data To minimize the amount of bandwidth the Node.js agent consumes, New Relic only reports data once per minute. If you add the agent to tests that take less than a minute to run, it will not have time to report data to New Relic. If you do not see transaction traces or other data after deploying the agent, this may be due to configuration, framework, or Apdex settings. Use New Relic Diagnostics to try to automatically identify the issue. Installation problems What to check Comments Main module Ensure that you have added require('newrelic'); as the first line of the app's main module. If the require is added later, the Node.js agent may not properly instrument your application. Conditional logic If you have any conditional logic in your require, move the conditional logic to your newrelic.js configuration file. Frameworks For problems with supported frameworks, make sure you are using Connect, Express, Hapi, Kraken, or Restify. There are other Node.js frameworks, but New Relic does not support all of them. Apdex For problems with your Apdex results, try adjusting your Apdex score via your Node.js agent config file (newrelic.js) or the New Relic user interface. Log files The Node.js agent writes its log to the newrelic_agent.log file in the application directory, unless you have changed the logging settings. If the agent does not send data or crashes your app, you can generate a troubleshooting log file to accompany bug reports and support requests. Missing VM metrics The agent can collect VM metrics related to garbage collection (GC), memory, and CPU. Some of these metrics require an additional native module to be installed. Here are some common problems and their solutions: Problem During installation, npm shows one of the following error messages: gyp ERR! configure error gyp ERR! stack Error: Can't find Python executable \"python\", you can set the PYTHON env variable. Copy gyp ERR! build error gyp ERR! stack Error: not found: make Copy make: g++: Command not found Copy Solution Ensure that the prerequisites for the node-gyp module are installed. On Debian/Ubuntu platforms, use this command: apt-get install build-essential Copy For more information, see Node.js VM measurements. Other troubleshooting resources on our Explorers Hub forum: Troubleshooting install General configuration troubleshooting",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.769165,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Troubleshoot</em> your Node.js installation",
        "sections": "<em>Troubleshoot</em> your Node.js installation",
        "tags": "<em>Nodejs</em> <em>agent</em>",
        "body": "Problem If you have encountered any of these common problems after installing your New Relic <em>Node.js</em> <em>agent</em>, try these <em>troubleshooting</em> tips. Solution Some common problems users encounter after installing the New Relic <em>Node.js</em> <em>agent</em> include: Not seeing data To minimize the amount of bandwidth"
      },
      "id": "603e7e83e7b9d25c0b2a07d1"
    },
    {
      "sections": [
        "Generate trace log for troubleshooting (Node.js)",
        "Important",
        "Generate log files",
        "Examine log file",
        "For more help"
      ],
      "title": "Generate trace log for troubleshooting (Node.js)",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Troubleshooting"
      ],
      "external_id": "8a65a36752d2e3c296e49e0d6b8161722c6d9042",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/troubleshooting/generate-trace-log-troubleshooting-nodejs/",
      "published_at": "2021-06-02T20:29:31Z",
      "updated_at": "2021-03-13T02:56:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your New Relic Node.js agent log captures errors at the default info level. However, when troubleshooting or debugging, generate a more verbose trace log to help find and investigate problems. Important The trace log setting is a highly verbose logging level. To reduce disk space consumption, return the logging : { section's level to its original setting after testing. Generate log files To generate the detailed trace log file: Edit your newrelic.js file and change the logging section's level to trace. logging: { level: 'trace' } Copy Restart Node. Exercise your web application for about five minutes to generate sufficient logging data. After testing, change the level to a less verbose logging level, such as info (default). Open and examine the generated log file. Examine log file By default, the Node.js agent stores the log file in the current working directory as newrelic_agent.log. If the log file or folder are not visible: Check whether you have set the logging path to stdout or stderr. Verify that the current working directory is the same as the directory where you expect the log file to be located. For more help Additional documentation resources include the Node.js agent's Troubleshooting section. For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 88.90827,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate trace log for <em>troubleshooting</em> (Node.js)",
        "sections": "Generate trace log for <em>troubleshooting</em> (Node.js)",
        "tags": "<em>Nodejs</em> <em>agent</em>",
        "body": ".log. If the log file or folder are not visible: Check whether you have set the logging path to stdout or stderr. Verify that the current working directory is the same as the directory where you expect the log file to be located. For more help Additional documentation resources include the <em>Node.js</em> <em>agent</em>&#x27;s <em>Troubleshooting</em> section. For logging on all New Relic <em>agents</em>, see New Relic <em>agent</em> logs and <em>troubleshooting</em>."
      },
      "id": "6043d43128ccbce0f02c606a"
    }
  ],
  "/docs/agents/nodejs-agent/troubleshooting/troubleshoot-your-nodejs-installation": [
    {
      "sections": [
        "Troubleshooting large memory usage (Node.js)",
        "Problem",
        "Solution",
        "Increase caused by TLS memory buffer allocation",
        "Caution",
        "Increase caused by cluster worker slab allocations",
        "Increase caused by log messages stored to disk",
        "Increase caused by leaked MongoDB cursors",
        "Increase caused by agent data storage"
      ],
      "title": "Troubleshooting large memory usage (Node.js)",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Troubleshooting"
      ],
      "external_id": "fdacc90072462a34ca0db2b51f5145c1be4caf9d",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/troubleshooting/troubleshooting-large-memory-usage-nodejs/",
      "published_at": "2021-06-02T15:29:05Z",
      "updated_at": "2021-05-10T19:02:56Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem You installed the New Relic Node.js agent, and your Node.js application's memory usage increased. Solution There are several possible causes for this memory increase and potential solutions for each. Increase caused by TLS memory buffer allocation The first time a Node.js application uses any form of encryption, including SSL and HTTPS, a slab buffer is created. The default size for this buffer is 10 MB. Applications running in environments where SSL termination on inbound requests occurs in a separate router layer do not normally incur this overhead. Cloud services like Heroku and AWS often operate this way. However, the Node.js agent sends outbound data to New Relic services over HTTPS, and this triggers the allocation of a slab buffer. Solution: In some cases, you can reduce the slab buffer below its 10 MB default. To set the slab buffer size, use tls.SLAB_BUFFER_SIZE. Caution When using the New Relic agent, do not set the slab buffer size below 128 KB. The slab buffer allocation should not be reduced for apps that communicate with services or clients using SSL, HTTPS, or any other form of cryptography. Increase caused by cluster worker slab allocations Node.js provides the Cluster module. This allows for handling requests in parallel by using all processor cores available on a host. However, each cluster worker allocates its own slab buffer for SSL transactions, and keeps its own copy of Node.js agent data. This multiplies the memory overhead by the number of cluster workers used. The is also true if a host runs multiple Node.js applications at the same time. Solution: Some cloud service providers use environments that state a higher number of processor cores than can actually be used at any given time. Reducing the number of cluster workers or running without Cluster support may decrease memory usage without impacting performance. Increase caused by log messages stored to disk Log messages are logged to disk by default. Due to how message data is handled, message objects may be moved into Old-pointer-space for garbage collection. This means the objects stay in memory for a while, even after all references to them are gone. This leads to a larger amount of memory consumed by a process at any given time. Additional processing time is also used for garbage collection. Solution: Depending on your version of the Node.js, the agent may default to the trace or info log levels. Decrease logging verbosity to info or warn levels to noticeably decrease memory usage and time spent in garbage collection. Increase caused by leaked MongoDB cursors Many database drivers use an abstraction called a cursor. Cursors provide the ability to iterate through the results of queries. For example, the mongodb driver provides cursors when executing find queries. Cursors live both as objects in the Node.js runtime and as entities in the MongoDB server. When an application has finished using a cursor, it should close it to free up resources in both the server and the client application. In Node.js, it is possible for a cursor to be garbage collected, freeing resources in the application, without closing the cursor in the server. This may be go unnoticed in the application. However, the New Relic Node.js agent keeps track of open cursors to measure the time spent iterating through results. If your application does not close all the cursors it uses, the agent will continue to track stale cursors and leak memory. Solution: Ensure every cursor created in your application is closed by calling cursor.close() after the application finishes processing the results of the query. Increase caused by agent data storage The Node.js agent records data for each transaction your app handles. Data is generally grouped by transaction name. The memory used by the agent increases with the number of different transactions recorded in each minute-long harvest cycle. In addition, a larger amount of data is kept during each transaction, but is eventually discarded when the transaction completes. Memory used by the agent increases with the number of concurrent transactions handled by the application. Solution: If agent data storage is identified as the cause of a memory usage increase, this can best be addressed by adding additional memory to your host, or by switching to a larger cloud instance.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 97.76839,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Troubleshooting</em> large memory usage (Node.js)",
        "sections": "<em>Troubleshooting</em> large memory usage (Node.js)",
        "tags": "<em>Nodejs</em> <em>agent</em>",
        "body": "Problem You installed the New Relic <em>Node.js</em> <em>agent</em>, and your <em>Node.js</em> application&#x27;s memory usage increased. Solution There are several possible causes for this memory increase and potential solutions for each. Increase caused by TLS memory buffer allocation The first time a <em>Node.js</em> application uses"
      },
      "id": "603e9d6828ccbcb774eba788"
    },
    {
      "sections": [
        "Generate trace log for troubleshooting (Node.js)",
        "Important",
        "Generate log files",
        "Examine log file",
        "For more help"
      ],
      "title": "Generate trace log for troubleshooting (Node.js)",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Troubleshooting"
      ],
      "external_id": "8a65a36752d2e3c296e49e0d6b8161722c6d9042",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/troubleshooting/generate-trace-log-troubleshooting-nodejs/",
      "published_at": "2021-06-02T20:29:31Z",
      "updated_at": "2021-03-13T02:56:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your New Relic Node.js agent log captures errors at the default info level. However, when troubleshooting or debugging, generate a more verbose trace log to help find and investigate problems. Important The trace log setting is a highly verbose logging level. To reduce disk space consumption, return the logging : { section's level to its original setting after testing. Generate log files To generate the detailed trace log file: Edit your newrelic.js file and change the logging section's level to trace. logging: { level: 'trace' } Copy Restart Node. Exercise your web application for about five minutes to generate sufficient logging data. After testing, change the level to a less verbose logging level, such as info (default). Open and examine the generated log file. Examine log file By default, the Node.js agent stores the log file in the current working directory as newrelic_agent.log. If the log file or folder are not visible: Check whether you have set the logging path to stdout or stderr. Verify that the current working directory is the same as the directory where you expect the log file to be located. For more help Additional documentation resources include the Node.js agent's Troubleshooting section. For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 88.90827,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate trace log for <em>troubleshooting</em> (Node.js)",
        "sections": "Generate trace log for <em>troubleshooting</em> (Node.js)",
        "tags": "<em>Nodejs</em> <em>agent</em>",
        "body": ".log. If the log file or folder are not visible: Check whether you have set the logging path to stdout or stderr. Verify that the current working directory is the same as the directory where you expect the log file to be located. For more help Additional documentation resources include the <em>Node.js</em> <em>agent</em>&#x27;s <em>Troubleshooting</em> section. For logging on all New Relic <em>agents</em>, see New Relic <em>agent</em> logs and <em>troubleshooting</em>."
      },
      "id": "6043d43128ccbce0f02c606a"
    },
    {
      "sections": [
        "Introduction to New Relic for Node.js",
        "Tip",
        "Why it matters",
        "Installation",
        "Extend your instrumentation",
        "Troubleshoot your installation",
        "Check the source code"
      ],
      "title": "Introduction to New Relic for Node.js",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Getting started"
      ],
      "external_id": "8e664d52df4f0ccf1c91301e3b620699a0770850",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/getting-started/introduction-new-relic-nodejs/",
      "published_at": "2021-06-02T20:26:13Z",
      "updated_at": "2021-03-11T07:59:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Pinpoint and solve issues down to the line of code with Node.js monitoring from New Relic. With features like service maps and error analytics, our Node.js agent helps you get the full picture of your app environment. Tip To use Node.js or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Why it matters Many Node application requests are based on raw URLs. Our solution is different. New Relic for Node.js assumes it can group requests to your application into transactions instead of HTTP requests. Transactions are defined by giving one or more request paths a name. These names are used to: Visualize where your app is spending its time (in transaction breakdowns). Identify slow requests. Group metrics. Show you which portions of your application are suffering from slow database performance. Installation To install our agent, you need to sign up for New Relic first. Once you're logged in, follow the instructions or use our launcher to get data flowing in. Review the system requirements. Read the install docs. Go directly to the New Relic UI to add Node.js data. Extend your instrumentation After installing the Node.js agent, extend your instrumentation: Extend your instrumentation Comments Customization Implement Node.js custom instrumentation. Collect custom metrics via an API call. Use our Node.js agent API to control, customize, or extend the agent's functionality. Open source telemetry To create your own integrations, use our Node Telemetry SDK. To gain visibility into your GraphQL payloads, use our Apollo Server plugin. Traces Enable distributed tracing. VM measurements Collect key metric timeslice data from the Node.js virtual machine. View detailed VM statistics in the New Relic UI. End-user activity Integrate the Node.js agent with browser monitoring. Gain visibility into user activity with browser monitoring's page load timing process. Troubleshoot your installation If you encounter issues with your Node.js agent, see our troubleshooting information: Large memory usage: If you've installed the Node.js agent and your memory usage has increased, check out these possible solutions. Troubleshooting your Node.js installation: Try these steps if you don't see any data, cannot log files, or encounter other installation problems with the Node.js agent. Troubleshooting Browser instrumentation: If you encounter problems with Browser data, see these additional tips for Node.js. You can also view all troubleshooting docs. If you need additional assistance, get support at support.newrelic.com. Check the source code Our Node.js agent is open source software. You can browse the source code and send improvements, or create your own fork and build it. For more information, see the node-newrelic README on GitHub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 84.5887,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Troubleshoot</em> your installation",
        "tags": "<em>Nodejs</em> <em>agent</em>",
        "body": " from the <em>Node.js</em> virtual machine. View detailed VM statistics in the New Relic UI. End-user activity Integrate the <em>Node.js</em> <em>agent</em> with browser monitoring. Gain visibility into user activity with browser monitoring&#x27;s page load timing process. <em>Troubleshoot</em> your installation If you encounter issues"
      },
      "id": "6043d881196a67be9f960f7a"
    }
  ],
  "/docs/agents/nodejs-agent/troubleshooting/troubleshooting-large-memory-usage-nodejs": [
    {
      "sections": [
        "Troubleshoot your Node.js installation",
        "Problem",
        "Solution",
        "Not seeing data",
        "Installation problems",
        "Log files",
        "Missing VM metrics"
      ],
      "title": "Troubleshoot your Node.js installation",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Troubleshooting"
      ],
      "external_id": "2c9fef97ba7342d3e3b334a26890c3a166a12849",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/troubleshooting/troubleshoot-your-nodejs-installation/",
      "published_at": "2021-06-02T15:26:38Z",
      "updated_at": "2021-03-16T15:05:11Z",
      "document_type": "troubleshooting_doc",
      "popularity": 1,
      "body": "Problem If you have encountered any of these common problems after installing your New Relic Node.js agent, try these troubleshooting tips. Solution Some common problems users encounter after installing the New Relic Node.js agent include: Not seeing data To minimize the amount of bandwidth the Node.js agent consumes, New Relic only reports data once per minute. If you add the agent to tests that take less than a minute to run, it will not have time to report data to New Relic. If you do not see transaction traces or other data after deploying the agent, this may be due to configuration, framework, or Apdex settings. Use New Relic Diagnostics to try to automatically identify the issue. Installation problems What to check Comments Main module Ensure that you have added require('newrelic'); as the first line of the app's main module. If the require is added later, the Node.js agent may not properly instrument your application. Conditional logic If you have any conditional logic in your require, move the conditional logic to your newrelic.js configuration file. Frameworks For problems with supported frameworks, make sure you are using Connect, Express, Hapi, Kraken, or Restify. There are other Node.js frameworks, but New Relic does not support all of them. Apdex For problems with your Apdex results, try adjusting your Apdex score via your Node.js agent config file (newrelic.js) or the New Relic user interface. Log files The Node.js agent writes its log to the newrelic_agent.log file in the application directory, unless you have changed the logging settings. If the agent does not send data or crashes your app, you can generate a troubleshooting log file to accompany bug reports and support requests. Missing VM metrics The agent can collect VM metrics related to garbage collection (GC), memory, and CPU. Some of these metrics require an additional native module to be installed. Here are some common problems and their solutions: Problem During installation, npm shows one of the following error messages: gyp ERR! configure error gyp ERR! stack Error: Can't find Python executable \"python\", you can set the PYTHON env variable. Copy gyp ERR! build error gyp ERR! stack Error: not found: make Copy make: g++: Command not found Copy Solution Ensure that the prerequisites for the node-gyp module are installed. On Debian/Ubuntu platforms, use this command: apt-get install build-essential Copy For more information, see Node.js VM measurements. Other troubleshooting resources on our Explorers Hub forum: Troubleshooting install General configuration troubleshooting",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 89.76916,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>Troubleshoot</em> your Node.js installation",
        "sections": "<em>Troubleshoot</em> your Node.js installation",
        "tags": "<em>Nodejs</em> <em>agent</em>",
        "body": "Problem If you have encountered any of these common problems after installing your New Relic <em>Node.js</em> <em>agent</em>, try these <em>troubleshooting</em> tips. Solution Some common problems users encounter after installing the New Relic <em>Node.js</em> <em>agent</em> include: Not seeing data To minimize the amount of bandwidth"
      },
      "id": "603e7e83e7b9d25c0b2a07d1"
    },
    {
      "sections": [
        "Generate trace log for troubleshooting (Node.js)",
        "Important",
        "Generate log files",
        "Examine log file",
        "For more help"
      ],
      "title": "Generate trace log for troubleshooting (Node.js)",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Troubleshooting"
      ],
      "external_id": "8a65a36752d2e3c296e49e0d6b8161722c6d9042",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/troubleshooting/generate-trace-log-troubleshooting-nodejs/",
      "published_at": "2021-06-02T20:29:31Z",
      "updated_at": "2021-03-13T02:56:41Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Your New Relic Node.js agent log captures errors at the default info level. However, when troubleshooting or debugging, generate a more verbose trace log to help find and investigate problems. Important The trace log setting is a highly verbose logging level. To reduce disk space consumption, return the logging : { section's level to its original setting after testing. Generate log files To generate the detailed trace log file: Edit your newrelic.js file and change the logging section's level to trace. logging: { level: 'trace' } Copy Restart Node. Exercise your web application for about five minutes to generate sufficient logging data. After testing, change the level to a less verbose logging level, such as info (default). Open and examine the generated log file. Examine log file By default, the Node.js agent stores the log file in the current working directory as newrelic_agent.log. If the log file or folder are not visible: Check whether you have set the logging path to stdout or stderr. Verify that the current working directory is the same as the directory where you expect the log file to be located. For more help Additional documentation resources include the Node.js agent's Troubleshooting section. For logging on all New Relic agents, see New Relic agent logs and troubleshooting.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 88.90827,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Generate trace log for <em>troubleshooting</em> (Node.js)",
        "sections": "Generate trace log for <em>troubleshooting</em> (Node.js)",
        "tags": "<em>Nodejs</em> <em>agent</em>",
        "body": ".log. If the log file or folder are not visible: Check whether you have set the logging path to stdout or stderr. Verify that the current working directory is the same as the directory where you expect the log file to be located. For more help Additional documentation resources include the <em>Node.js</em> <em>agent</em>&#x27;s <em>Troubleshooting</em> section. For logging on all New Relic <em>agents</em>, see New Relic <em>agent</em> logs and <em>troubleshooting</em>."
      },
      "id": "6043d43128ccbce0f02c606a"
    },
    {
      "sections": [
        "Introduction to New Relic for Node.js",
        "Tip",
        "Why it matters",
        "Installation",
        "Extend your instrumentation",
        "Troubleshoot your installation",
        "Check the source code"
      ],
      "title": "Introduction to New Relic for Node.js",
      "type": "docs",
      "tags": [
        "Agents",
        "Nodejs agent",
        "Getting started"
      ],
      "external_id": "8e664d52df4f0ccf1c91301e3b620699a0770850",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/nodejs-agent/getting-started/introduction-new-relic-nodejs/",
      "published_at": "2021-06-02T20:26:13Z",
      "updated_at": "2021-03-11T07:59:34Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Pinpoint and solve issues down to the line of code with Node.js monitoring from New Relic. With features like service maps and error analytics, our Node.js agent helps you get the full picture of your app environment. Tip To use Node.js or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Why it matters Many Node application requests are based on raw URLs. Our solution is different. New Relic for Node.js assumes it can group requests to your application into transactions instead of HTTP requests. Transactions are defined by giving one or more request paths a name. These names are used to: Visualize where your app is spending its time (in transaction breakdowns). Identify slow requests. Group metrics. Show you which portions of your application are suffering from slow database performance. Installation To install our agent, you need to sign up for New Relic first. Once you're logged in, follow the instructions or use our launcher to get data flowing in. Review the system requirements. Read the install docs. Go directly to the New Relic UI to add Node.js data. Extend your instrumentation After installing the Node.js agent, extend your instrumentation: Extend your instrumentation Comments Customization Implement Node.js custom instrumentation. Collect custom metrics via an API call. Use our Node.js agent API to control, customize, or extend the agent's functionality. Open source telemetry To create your own integrations, use our Node Telemetry SDK. To gain visibility into your GraphQL payloads, use our Apollo Server plugin. Traces Enable distributed tracing. VM measurements Collect key metric timeslice data from the Node.js virtual machine. View detailed VM statistics in the New Relic UI. End-user activity Integrate the Node.js agent with browser monitoring. Gain visibility into user activity with browser monitoring's page load timing process. Troubleshoot your installation If you encounter issues with your Node.js agent, see our troubleshooting information: Large memory usage: If you've installed the Node.js agent and your memory usage has increased, check out these possible solutions. Troubleshooting your Node.js installation: Try these steps if you don't see any data, cannot log files, or encounter other installation problems with the Node.js agent. Troubleshooting Browser instrumentation: If you encounter problems with Browser data, see these additional tips for Node.js. You can also view all troubleshooting docs. If you need additional assistance, get support at support.newrelic.com. Check the source code Our Node.js agent is open source software. You can browse the source code and send improvements, or create your own fork and build it. For more information, see the node-newrelic README on GitHub.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 84.5887,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "sections": "<em>Troubleshoot</em> your installation",
        "tags": "<em>Nodejs</em> <em>agent</em>",
        "body": " from the <em>Node.js</em> virtual machine. View detailed VM statistics in the New Relic UI. End-user activity Integrate the <em>Node.js</em> <em>agent</em> with browser monitoring. Gain visibility into user activity with browser monitoring&#x27;s page load timing process. <em>Troubleshoot</em> your installation If you encounter issues"
      },
      "id": "6043d881196a67be9f960f7a"
    }
  ],
  "/docs/agents/php-agent/advanced-installation/docker-other-container-environments-install-php-agent": [
    {
      "sections": [
        "PHP agent and Heroku",
        "Prepare your application",
        "Install the PHP agent",
        "Via the Heroku website",
        "Via Heroku toolbelt",
        "Configure the agent on Heroku",
        "Caution",
        "Name your application",
        "Verify your installation",
        "Troubleshooting the agent on Heroku",
        "For more help"
      ],
      "title": "PHP agent and Heroku",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "Advanced installation"
      ],
      "external_id": "9f6eae3896918ade4e325f2db7ee5685477c1cf2",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/advanced-installation/php-agent-heroku/",
      "published_at": "2021-06-02T15:36:27Z",
      "updated_at": "2021-05-21T20:05:08Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Heroku is a Platform as a Service (PaaS) solution for hosting web applications in various languages, including PHP. With New Relic, you can extend Heroku with metrics from APM and browser monitoring. Prepare your application Before installing the PHP agent, make sure your PHP web application is installed and running under Heroku. For more information, see Getting Started with PHP on Heroku. Install the PHP agent After deploying your PHP app on Heroku, install our PHP agent: Via the Heroku website To install the New Relic add-on through the Heroku website: From the New Relic Add-on Page, select a subscription plan. From the Select an app dropdown, select your app. Give your application a descriptive name with this Heroku toolbelt command: heroku config:set NEW_RELIC_APP_NAME='YOUR_APP_NAME' Copy Push a change to Heroku (for example, git commit --allow-empty) to enable the PHP extension during build. Generate some traffic to your app. Via Heroku toolbelt To install the New Relic add-on with Heroku toolbelt: Via Heroku toolbelt, run the following command and substitute the appropriate subscription plan: heroku addons:create newrelic:YOUR_PLAN_LEVEL Copy Give your application a descriptive name with this Heroku toolbelt command: heroku config:set NEW_RELIC_APP_NAME='YOUR_APP_NAME' Copy Push a change to Heroku (for example, git commit --allow-empty) to enable the PHP extension during build. Generate some traffic to your app. Within a few minutes, data should start appearing in your APM Summary page. If no data appears, see the verification and troubleshooting procedures in this document. Configure the agent on Heroku Heroku automatically configures default environment variables for your app. To customize your settings, create and upload a newrelic.ini file to Heroku: Download a \"clean\" copy of newrelic.ini_.heroku [INI | 16KB] . Rename the file from newrelic.ini _ .heroku to newrelic.ini. Copy newrelic.ini to the root directory of your project repository. Customize your settings as described in PHP agent configuration. Caution Do not change newrelic.license, newrelic.loglevel, or newrelic.appname. These settings are configured by Heroku toolbelt. Commit your config file changes to your repository, and push your changes to Heroku. Instruct Heroku to use your customized config file via this Heroku toolbelt command: heroku config:set NEW_RELIC_CONFIG_FILE=newrelic.ini Copy Name your application To ensure that metrics from each app are reported separately, give each app a descriptive name. Your application name defaults to PHP Application on Heroku. New Relic uses the app name to aggregate data. If you do not change this name, New Relic will aggregate the data from each additional PHP app you install under this same name. To name your application, run this Heroku toolbelt command: heroku config:set NEW_RELIC_APP_NAME='YOUR_APP_NAME' Copy To verify your app's name change, run: heroku run env | grep NEW_RELIC_APP_NAME Copy Verify that the confirmation prompt returns the new app name: NEW_RELIC_APP_NAME=YOUR_APP_NAME Copy Verify your installation To verify that Heroku has installed the New Relic add-on, run this Heroku toolbelt command: heroku run env | grep NEW_RELIC Copy This will generate a list of New Relic environment variables in Heroku. The agent uses these environment variables to determine which account to report data to. You should see at least the following variables: NEW_RELIC_LICENSE_KEY='YOUR_LICENSE_KEY' NEW_RELIC_LOG_LEVEL=\"warning\" NEW_RELIC_APP_NAME=\"YOUR_APP_NAME\" Copy You can also use phpinfo to verify that your app is being instrumented. Troubleshooting the agent on Heroku To troubleshoot the PHP agent on Heroku, examine your log file, which is stored in the Heroku web server log. To view the web server log, run this Heroku toolbelt command: heroku logs -t | tee newrelic.log Copy Use the log file to troubleshoot the issue. If you need further assistance, get support at support.newrelic.com. The PHP agent defaults to the warning log level. New Relic Support may also request logs at the verbosedebug log level. To change the log level to verbosedebug, run this Heroku toolbelt command: heroku config:set NEW_RELIC_LOG_LEVEL=verbosedebug Copy Caution The verbosedebug log level quickly generates a large volume of data. Use this setting only if New Relic Support requests it, and remove this setting as soon as you collect the output by running this Heroku toolbelt command: heroku config:unset NEW_RELIC_LOG_LEVEL Copy For more help Additional documentation resources include: Suggest a change and learn how to contribute to our PHP agent open source repository. Heroku Dev Center (information on the Heroku site on installing New Relic) New Relic for PHP (overview of the New Relic PHP agent) Using multiple names for an app (advanced techniques to \"roll up\" data from multiple applications under a single name)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 167.18558,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "<em>PHP</em> <em>agent</em> and Heroku",
        "sections": "<em>Install</em> the <em>PHP</em> <em>agent</em>",
        "tags": "<em>Advanced</em> <em>installation</em>",
        "body": " Copy For more help Additional documentation resources include: Suggest a change and learn how to contribute to our <em>PHP</em> <em>agent</em> open source repository. Heroku Dev Center (information on the Heroku site on installing New Relic) New Relic for <em>PHP</em> (overview of the New Relic <em>PHP</em> <em>agent</em>) Using multiple names for an app (<em>advanced</em> techniques to &quot;roll up&quot; data from multiple applications under a single name)"
      },
      "id": "603eb5dae7b9d210e22a07ec"
    },
    {
      "sections": [
        "Uninstall the PHP agent",
        "Uninstalling the agent",
        "RedHat or CentOS",
        "Ubuntu or Debian",
        "For more help"
      ],
      "title": "Uninstall the PHP agent",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "Advanced installation"
      ],
      "external_id": "202825bfa945db1e173a7fd950f5e3795ce77ad4",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/advanced-installation/uninstalling-php-agent/",
      "published_at": "2021-06-02T16:41:40Z",
      "updated_at": "2021-04-16T09:19:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "Read on to learn how to uninstall the New Relic PHP agent. For instructions on how to temporarily disable the agent, see Disable the agent. This document explains how to uninstall the New Relic PHP agent for the following systems: RedHat and CentOS Ubuntu and Debian Tar archive (any supported system) Uninstalling the agent When uninstalling New Relic from a PHP application, you must remove the New Relic agent and also remove associated New Relic configuration files. To uninstall the PHP agent from your system: Remove the agent files from your system: RedHat or CentOS Run the newrelic-install script with no options and select the uninstall option from the main menu when invoking the script. Ubuntu or Debian Use apt-get to remove the agent: apt-get remove newrelic-php5 Copy Remove any remaining New Relic configuration files. Use the newrelic-install or apt-get remove commands with the purge option. newrelic-install purge Copy OR apt-get remove --purge newrelic Copy If you use a package manager, remove files specific to the manager: RedHat or CentOS Using yum: sudo yum remove newrelic-php5 Copy Using rpm (32-bit): rpm -e newrelic-php5-common-X.X.X.X (YOUR VERSION #)-1.noarch.rpm newrelic-daemon-X.X.X.X (YOUR VERSION NUMBER)-1.i386.rpm newrelic-php5-X.X.X.X-1.i386.rpm Copy Using rpm (64-bit): rpm -e newrelic-php5-common-X.X.X.X (VERSION NUMBER)-1.noarch.rpm newrelic-daemon-X.X.X.X (YOUR VERSION NUMBER)-1.x86_64.rpm newrelic-php5-X.X.X.X-1.x86_64.rpm Copy Ubuntu or Debian Using apt-get: sudo apt-get purge newrelic-php5 Copy Using dpkg (32-bit): dpkg -P newrelic-php5-common_X.X.X.X (YOUR VERSION NUMBER)_all.deb newrelic-daemon_X.X.X.X_i386.deb newrelic-php5_X.X.X.X_i386.deb Copy Using dpkg (64-bit): dpkg -P newrelic-php5-common_X.X.X.X (YOUR VERSION NUMBER)_all.deb newrelic-daemon_X.X.X.X_amd64.deb newrelic-php5_X.X.X.X_amd64.deb Copy Restart your web servers (Apache, Nginx, PHP-FPM, etc.). For more help Additional documentation resources include: Suggest a change and learn how to contribute to our PHP agent open source repository. The newrelic-install script (steps for using the install script to install and uninstall the agent) Remove apps from New Relic (steps to remove an app from showing up in your New Relic account)",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.983376,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Uninstall the <em>PHP</em> <em>agent</em>",
        "sections": "Uninstall the <em>PHP</em> <em>agent</em>",
        "tags": "<em>Advanced</em> <em>installation</em>",
        "body": "Read on to learn how to uninstall the New Relic <em>PHP</em> <em>agent</em>. For instructions on how to temporarily disable the <em>agent</em>, see Disable the <em>agent</em>. This document explains how to uninstall the New Relic <em>PHP</em> <em>agent</em> for the following systems: RedHat and CentOS Ubuntu and Debian Tar archive (any supported"
      },
      "id": "6043b63828ccbc66612c6081"
    },
    {
      "sections": [
        "Use the newrelic-install script for PHP",
        "Important",
        "Find the installer script",
        "Tip",
        "Work with multiple PHP installations",
        "Invoke the installer script",
        "Use the install mode",
        "1. Invoke install mode.",
        "2. Provide your New Relic license key.",
        "3. Select which PHP version to use if applicable.",
        "4. Install the daemon if applicable.",
        "5. Restart your web server.",
        "6. Note your archive file.",
        "7. Fine-tune your configuration.",
        "Use the install-daemon mode",
        "Troubleshoot your PHP installation",
        "Uninstall mode",
        "Uninstall and keep config files.",
        "Permanently uninstall New Relic.",
        "For more help"
      ],
      "title": "Use the newrelic-install script for PHP",
      "type": "docs",
      "tags": [
        "Agents",
        "PHP agent",
        "Advanced installation"
      ],
      "external_id": "71ab50634a65e0f31ac82963ee78cf99dbaf752b",
      "image": "",
      "url": "https://docs.newrelic.com/docs/agents/php-agent/advanced-installation/use-newrelic-install-script-php/",
      "published_at": "2021-06-02T16:41:41Z",
      "updated_at": "2021-04-16T09:19:32Z",
      "document_type": "page",
      "popularity": 1,
      "body": "The interactive newrelic-install script simplifies installing New Relic for PHP applications. It works with multiple PHP installations as well as installations in non-standard locations. Running it will: Copy the correct PHP modules into place. Install sample ini files. Configure the New Relic proxy daemon. Important Be sure to review the information about working with multiple installations and non-standard locations before running the script. Find the installer script The installer script location depends on how you installed the New Relic PHP agent. Via system package manager: The installation script is in the /usr/bin directory. Via a tarball: The installation script is in the directory where you extracted the tar archive file. The script in the tar distribution includes installation steps otherwise handled by the package manager. Tip To use PHP or any other agent, as well as the rest of our observability platform, join the New Relic family! Sign up to create your free account in only a few seconds. Then ingest up to 100GB of data for free each month. Forever. Work with multiple PHP installations For newrelic-install to correctly detect multiple installations, ensure your PATH environment variable is correctly set. The newrelic-install script can only install the agent for versions it can find. If you want to... Do this... Specify additional directories Use the NR_INSTALL_PATH environment variable with a colon-separated list. Override NR_INSTALL_PATH and PATH Specify a set of directories in the NR_INSTALL_PHPLIST environment variable as a colon-separated list. These directories must contain either the command line version of PHP or the php-config script. Invoke the installer script The script has two modes: install and uninstall. If you invoke it with no arguments you will be prompted to select a mode. From the command line, run the script at its location: Via system package manager: /usr/bin/newrelic-install Via a tar archive directory: ./newrelic-install Use the install mode Important As of PHP agent version 4.0, the installer will not work properly if it detects a single version of PHP if that version is PHP 5.1, which is deprecated. If you must run PHP 5.1, use PHP agent version 3.9.5.13. If you need help, get support at support.newrelic.com. Follow this process to install New Relic. 1. Invoke install mode. Invoke install mode by using one of these methods: Run newrelic-install with the install command line option. Run newrelic-install with no options and select the install option from the main menu when invoking the script. 2. Provide your New Relic license key. At the prompt, enter your New Relic license key. This key will be inserted into any INI files created during the rest of the installation process. 3. Select which PHP version to use if applicable. If newrelic-install finds more than one version of PHP, select which version of PHP to use. You will not see this screen if the script only found a single version of PHP. Example: The menu shows seven options: 1) /usr/bin 2) /usr/local/php/5.2.16/bin 3) /usr/local/php/5.2.16-zts/bin 4) /usr/local/php/5.3.4/bin 5) /usr/local/php/5.3.4-zts/bin 6) /usr/local/php/5.4.19-zts/bin 7) /usr/local/php/5.5.4-zts/bin 0) Exit Select (1-7, 0 to exit, or all): Copy At the menu, use any of these options: To select only one version, enter the number indicating the version you want to use. To select multiple versions, enter a comma- or space-separated list of numbers. To select every version listed, enter the keyword all. To exit the installation process, Enter 0. For each directory selected, the script will attempt to install the agent in the proper place and report on each attempt. Important For PHP installations that allow multiple .ini files, the install script will copy a template file into place, if a modified one is not already installed. Make a note of the .ini files you will need to modify manually. 4. Install the daemon if applicable. If the daemon was not installed by the package manager, install the daemon. If this is an update or reinstall, the script provide a confirmation prompt before overwriting the old copy of the daemon. If installation is successful, the script will show this final message: New Relic is now installed on your system. Congratulations! Copy 5. Restart your web server. To activate the PHP agent, restart your web server. Important If you are running PHP-FPM, you may also need to restart PHP-FPM separately before the agent will be active. 6. Note your archive file. Note the name and location of the install archive file. This file will be located at /tmp/nrinstall-nnnn.tar and will contain both the install log and useful system information to help New Relic Technical Support with troubleshooting. 7. Fine-tune your configuration. After you install New Relic successfully and restart your web server, you can begin gathering data about your applications. After a few minutes, data will begin to appear on your APM Summary page. To fine-tune operation of both the PHP agent and daemon, review the PHP configuration options. Use the install-daemon mode Important Requires PHP agent 9.2 or higher. To install the daemon without the agent, run newrelic-install with the install_daemon command line option. This may be useful if the daemon is running on a different host or in a different container than the PHP application (as may happen with agent install on containers). Troubleshoot your PHP installation If there were problems with the installation process, or if no data appears in APM, review the PHP troubleshooting procedures before contacting New Relic for support. Be sure to attach your archive file to any bug report, as well as the output of the phpinfo() function produced by your web server. Uninstall mode You can uninstall New Relic but keep valuable config files (useful when upgrading), or permanently uninstall New Relic from your system. Uninstall and keep config files. This method is useful when you want to uninstall and upgrade. To uninstall New Relic using the install script, use either of these options: Invoke newrelic-install with the uninstall option. Run newrelic-install with no options, and select the uninstall option from the main menu when invoking the script. The uninstall does not remove important configuration files, such as your daemon configuration file. Also, it does not remove any newrelic.ini files that you have modified. Permanently uninstall New Relic. To permanently uninstall New Relic from your system: Invoke newrelic-install with the purge option. This will remove all the configuration files and any links created at installation time. This will not affect any configuration parameters that might have been placed in files such as php.in. Also, this will not remove the software packages installed on the system. Tip To remove the New Relic software packages installed with a package manager, see Uninstalling (RedHat and CentOS) or Uninstalling (Ubuntu and Debian). For more help If you need more help, check out these support and learning resources: Suggest a change and learn how to contribute to our PHP agent open source repository. Browse the Explorers Hub to get help from the community and join in discussions. Find answers on our sites and learn how to use our support portal. Run New Relic Diagnostics, our troubleshooting tool for Linux, Windows, and macOS. Review New Relic's data security and licenses documentation.",
      "info": "",
      "_index": "520d1d5d14cc8a32e600034b",
      "_type": "520d1d5d14cc8a32e600034c",
      "_score": 124.15406,
      "_version": null,
      "_explanation": null,
      "sort": null,
      "highlight": {
        "title": "Use the newrelic-<em>install</em> script for <em>PHP</em>",
        "sections": "Work with multiple <em>PHP</em> <em>installations</em>",
        "tags": "<em>Advanced</em> <em>installation</em>",
        "body": ": The <em>installation</em> script is in the &#x2F;usr&#x2F;bin directory. Via a tarball: The <em>installation</em> script is in the directory where you extracted the tar archive file. The script in the tar distribution includes <em>installation</em> steps otherwise handled by the package manager. Tip To use <em>PHP</em> or any other <em>agent</em>, as well"
      },
      "id": "603e841728ccbc222aeba788"
    }
  ]
}